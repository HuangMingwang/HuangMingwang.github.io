<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>leyou常见问题 | MingwHuang's Blog</title><meta name="keywords" content="Leyou"><meta name="author" content="MingwHuang"><meta name="copyright" content="MingwHuang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="项目问题乐优商城采用了前后端分离的架构方式，  前端采用Vue技术栈，从使用者的角度，分为： 前台门户系统：支持H5 后台管理系统：基于Vue实现的单页应用（SPA），实现管理功能   服务端采用SpringCloud技术栈形成微服务集群，会包括： 商品微服务：商品及商品分类、品牌、库存等的服务 搜索微服务：实现搜索功能 交易微服务：实现订单相关业务、实现购物车相关业务 用户服务：用户的登录注册、">
<meta property="og:type" content="article">
<meta property="og:title" content="leyou常见问题">
<meta property="og:url" content="http://example.com/2021/12/21/leyou/leyou%E9%9D%A2%E8%AF%95%E7%89%88/index.html">
<meta property="og:site_name" content="MingwHuang&#39;s Blog">
<meta property="og:description" content="项目问题乐优商城采用了前后端分离的架构方式，  前端采用Vue技术栈，从使用者的角度，分为： 前台门户系统：支持H5 后台管理系统：基于Vue实现的单页应用（SPA），实现管理功能   服务端采用SpringCloud技术栈形成微服务集群，会包括： 商品微服务：商品及商品分类、品牌、库存等的服务 搜索微服务：实现搜索功能 交易微服务：实现订单相关业务、实现购物车相关业务 用户服务：用户的登录注册、">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272047554.jpg">
<meta property="article:published_time" content="2021-12-21T08:42:14.000Z">
<meta property="article:modified_time" content="2022-02-22T13:55:23.937Z">
<meta property="article:author" content="MingwHuang">
<meta property="article:tag" content="Leyou">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272047554.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2021/12/21/leyou/leyou%E9%9D%A2%E8%AF%95%E7%89%88/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":500},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'leyou常见问题',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-02-22 21:55:23'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272113875.JPG" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">42</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">41</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">20</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272047554.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">MingwHuang's Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">leyou常见问题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-12-21T08:42:14.000Z" title="发表于 2021-12-21 16:42:14">2021-12-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-02-22T13:55:23.937Z" title="更新于 2022-02-22 21:55:23">2022-02-22</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Leyou/">Leyou</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="leyou常见问题"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="项目问题"><a href="#项目问题" class="headerlink" title="项目问题"></a>项目问题</h1><p>乐优商城采用了前后端分离的架构方式，</p>
<ul>
<li>前端采用Vue技术栈，从使用者的角度，分为：<ul>
<li>前台门户系统：支持H5</li>
<li>后台管理系统：基于Vue实现的单页应用（SPA），实现管理功能</li>
</ul>
</li>
<li>服务端采用SpringCloud技术栈形成微服务集群，会包括：<ul>
<li>商品微服务：商品及商品分类、品牌、库存等的服务</li>
<li>搜索微服务：实现搜索功能</li>
<li>交易微服务：实现订单相关业务、实现购物车相关业务</li>
<li>用户服务：用户的登录注册、用户信息管理等功能</li>
<li>短信服务：完成各种短信的发送任务</li>
<li>支付服务：对接微信支付平台</li>
<li>授权服务：完成对用户的授权、鉴权等功能</li>
</ul>
</li>
</ul>
<p>如果有项目的话，技术面试第一步，面试官一般都是让你自己介绍一下你的项目。你可以从下面</p>
<p>几个方向来考虑:</p>
<ol>
<li><p>对项目整体设计的一个感受(面试官可能会让你画系统的架构图)</p>
</li>
<li><p>在这个项目中你负责了什么、做了什么、担任了什么⻆色</p>
</li>
<li><p>从这个项目中你学会了那些东⻄，使用到了那些技术，学会了那些新技术的使用</p>
</li>
<li><p>另外项目描述中，最好可以体现自己的综合素质，比如你是如何协调项目组成员协同开发的</p>
<p>或者在遇到某一个棘手的问题的时候你是如何解决的又或者说你在这个项目用了什么技术实 现了什么功能比如:用redis做缓存提高访问速度和并发量、使用消息队列削峰和降流等等。</p>
</li>
</ol>
<p>面试官，您好!我叫秀儿。研究生期间时间我主要利用课外时间学习了 Java 以及 jvm, mysql, redis等框架 。在校期间参与过一个B2C的类京东的电商网站的开发，乐购生活项目是采用分布式服务系统架构打造的 B2C 模式的电商网站,整个项目分为运营商家后台管理系统、门户网 站两个子系统.项目采用微服务架构,前后端分离,微服务技术采用了Spring Cloud 技术栈,各个微服务站点基于 Spring Boot 构 建.各个微服务之间采用RabbitMQ 实现异步通信,降低系统之间的耦合度,提高了系统的扩展性以及部署的灵活性.使用Redis 做 系统缓存,提高系统的性能,热点页面采用了 openresty 页面静态化技术. 生活中我是一个比􏰀积极乐观的人，一般会通过跑步健身的方式来放松。我 一直都非常想加入贵公司，我觉得贵公司的文化和技术氛围我都非常喜欢，期待能与你共事;</p>
<p>Q：希望能够着重讲一下<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/452184164">项目</a>经历以及扮演的角色</p>
<p>A：具体讲了一下自己做的一个微服务<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/452184164">项目</a>，有xxx功能，从GateWay到Sentinel以及Redis和MQ等技术，讲了讲如何在网关层面通过Token鉴权（同时穿插自己对技术选型的考量）</p>
<p>我们整个项目采用的是前后端分离开发模式。</p>
<ul>
<li><p>前端分为两部分：</p>
<ul>
<li>后台管理：主要面向的是数据管理人员，采用基于Vue的单页应用开发方式</li>
<li>门户系统：面向的是客户，门户采用的是Vue结合Nuxt实现服务端渲染方式</li>
</ul>
</li>
<li><p>后端</p>
<p>后端采用基于SpringCloud的微服务架构，统一对外提供Rest风格接口，无论是后台管理还是门户系统都共享这些微服务接口，而微服务中通过JWT方式来识别用户身份，开放不同接口。</p>
<p>到这里先不说了。如果继续追问微服务拆分粒度或者SpringCloud细节，再接着回答我们的服务拆分。</p>
</li>
</ul>
<p>Q：OK，那我们一个一个技术点聊，首先讲讲token的技术原理吧？</p>
<p>A：在<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/452184164">项目</a>中用到的Token是通过JJWT生成的，然后讲了讲PayLoad以及相关内容，最后讲Token防篡改等好处</p>
<p>Q：如果Token被第三方截获了怎么办？</p>
<p>A：使用HTTPS，以下省略八股文若干</p>
<p>Q：假设一个场景：用户的Token被从某js插件直接截获并拿到别的机器上访问你的接口，怎么办？</p>
<p>A：（对于这个问题有点懵，因为你浏览器里存的内容都能被拿了那似乎也没有什么特别好的方法处理了，但是后来想了想可以把用户ip或者mac地址放进去，但我感觉还是治标不治本，希望有大佬能帮我解答一下）思考了一下然后说把token的有效时间缩短（给自己埋了坑）这个是xss攻击吧,只需要设置httponly就可以防御;</p>
<p>Q：那如果用户在写文章，写了半个小时，你缩减了token的有效时间，用户的体验会变差很多，这种情况怎么办？</p>
<p>A：讲了讲token过期如何延期（把自己更加带进坑里了）</p>
<p>Q：那你又要缩短token有效时间，又要延期这不是很矛盾吗？况且你延期的话导致接口的风险也会逐渐增加呢？A：我真不知道了呜呜呜！（其实感觉这里该讲讲如何判断用户活跃的，用户活跃再进行延期，不过第一次面大厂真的被问懵了）</p>
<p>Q：没关系这只是作为开放性探讨的问题而已（被安慰一下还是挺好的）</p>
<p>Q：你说你用GateWay对微服务进行转发，那如果某个接口的访问特别慢，你如何避免的你网关被这个特别慢的微服务拖垮呢？</p>
<p>A：(一开始没太听懂，面试官又详细描述了一下场景) 如果接口访问特别慢，我们在选型的时候使用了Sentinel，Sentinel可以对慢接口进行降级，然后讲了讲Sentinel是怎么用的</p>
<p>Q：降级也是一种策略，那如果这个问题产生的原因是你的微服务自身的问题，不用Sentinel如何去解决？（插一句，这里后面复盘的时候才反应过来面试官应该是想问如何排查慢服务，比如从SQL、网络等方面进行解答，但是token那个问题真是把我问懵了，后续的问题人都是处于一种麻木的状态）</p>
<p>A：调用接口的时候可以设置超时时间，讲了讲FailBack之类的。</p>
<p>Q：如果我们想要查明这个慢，究竟是因为网络比较慢，还是因为复杂业务比较慢，该如何排查？然后给了一个详细的不能再详细的场景（已经明示了2333)</p>
<p>A：首先排查是否为网络原因，其次是排查服务中是否有复杂流程，最后检查是否因为第三方框架的不完善等等导致缓慢</p>
<p>Q：那我们现在如果已经确定了是网络比较慢，怀疑是发生了丢包，如何去确认？</p>
<p>A：ping命令（tcpdump 我看过但忘记了！！！</p>
<p>Q：建议回去了解一下tcpdump</p>
<p>Q：你认为消息队列是什么呢？</p>
<p>A：讲了讲自己的理解（觉得他和操作系统里面的消息队列差不多），然后说了说生产者消费者模型</p>
<p>Q：如果一个消息投递了多次都没成功怎么办？</p>
<p>A：会把消息持久化（忘了答死信队列，裂开）</p>
<p>Q：如何持久化？</p>
<p>A：确实没怎么了解过</p>
<p>Q：这些偏向底层的东西没看过确实不太好回答，没关系的，我们下面来聊一些基础的问题（内心OS：终于到我最喜欢的Java八股文了吗，嘿嘿嘿）</p>
<p>Q：操作系统学过吧，举个简单栗子，我们今天写了个Java应用，打开了一个文件句柄，在文件句柄中写入了一行字符串，flush这个文件句柄最后close掉，从操作系统层面讲讲这期间发生了哪些事情？</p>
<p>A：胡扯了一些然后说不太了解（为什么别人问操作系统都是线程进程死锁之类的，我的这么“简单”呜呜呜</p>
<p>Q：那你讲讲进程间通信的方式吧？</p>
<p>A：八股文若干</p>
<p>Q：OK，那我们接下来问问数据库方面的，一条普通的查询语句执行的流程是什么？</p>
<p>A：我真的是被问懵了，这里应该答连接器，解析器优化器之类的，结果我说到怎么在B+树上查找去了，甚至还扯了MVCC，我感觉面试官听着都尴尬</p>
<p>Q：这个基础部分你掌握的不够扎实啊，如果一条SQL语句执行的比较慢怎么办？（我心想我已经凉了，ε&#x3D;(´ο｀*)))唉</p>
<p>A：explain 以及相应的分析</p>
<p>Q：HTTP了解过吧，HTTP2.0和HTTP1.1的区别？</p>
<p>A：  HTTP2.0使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。HTTP1.1也可以多建立几个TCP连接，来支持处理更多并发的请求，但是创建TCP连接本身也是有开销的。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212149721.jpeg" alt="img"></p>
<p>​    HTTP1.1不支持header数据的压缩，HTTP2.0使用HPACK算法对header的数据进行压缩，这样数据体积小了，在网络上传输就会更快。</p>
<p> 为了改善延迟，HTTP2.0引入了server push，它允许服务端推送资源给浏览器，在浏览器明确地请求之前，免得客户端再次创建连接发送请求到服务器端获取。这样客户端可以直接从本地加载这些资源，不用再通过网络。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212149722.jpeg" alt="img"></p>
<p>Q：你说<a href="">项目</a>中用了前后端分离以及RESTful，什么是RESTful？</p>
<p>A：RESTful 是目前最流行的 API 设计规范，用于 Web 数据接口的设计; RESTful 的核心思想就是，客户端发出的数据操作指令都是”动词 + 宾语”的结构。比如，GET &#x2F;articles这个命令，GET是动词，&#x2F;articles是宾语。宾语必须是名词</p>
<p>有些客户端只能使用GET和POST这两种方法。服务器必须接受POST模拟其他三个方法（PUT、PATCH、DELETE）。</p>
<p>这时，客户端发出的 HTTP 请求，要加上X-HTTP-Method-Override属性，告诉服务器应该使用哪一个动词，覆盖POST方法。</p>
<p>为了统一起见，建议都使用复数 URL，比如GET &#x2F;articles&#x2F;2要好于GET &#x2F;article&#x2F;2。</p>
<p>常见的情况是，资源需要多级分类，因此很容易写出多级的 URL，比如获取某个作者的某一类文章。</p>
<p>更好的做法是，除了第一级，其他级别都用查询字符串表达。GET &#x2F;authors&#x2F;12?categories&#x3D;2</p>
<p>状态码必须精确; </p>
<p>Q：请求方式有哪些呀？</p>
<p>A：Options,Delete, Post, Get, Put, Trace等</p>
<p>Q：使用RESTful和直接加参数有什么区别吗？</p>
<p>A：我个人感觉是没什么区别2333</p>
<p>Q：为什么架构中要使用GateWay？</p>
<p>A：GateWay用来给各个微服务进行反代，然后详细说了一下怎么做的，为什么这么做</p>
<p>Q：如果让你来实现一个GateWay，你觉得要做哪些考量？</p>
<p>A：动态配置路由，负载均衡，支持自定义拦截等等详细讲了很多</p>
<p>Q：你说你在网关层面做了鉴权，详细讲讲？</p>
<p>A：在GateWay上写了一些规则，拦截用户的请求，解析token，然后又讲了讲token原理，如何加密（3DES）</p>
<p>Q：你有了解过各大厂商提供的网关服务吗？比如阿里<a href="">百度</a><a href="">腾讯</a>提供的？</p>
<p>A：没了解过</p>
<p>Q：你在网关上还做了限流？</p>
<p>A：Sentinel相关的内容，就把限流，降级，熔断的规则都讲了讲，然后把场景也讲了讲</p>
<p>Q：如果让你来实现一个限流框架，怎么做？（这方面还好我之前比较喜欢，去了解了比较多相关知识）</p>
<p>A：令牌桶，漏桶，semaphor等，然后利用Guava的RateLimiter详细的讲了一下令牌桶，又通过一个例子讲了一下Semaphor</p>
<p>Q：那漏桶呢？</p>
<p>A：补充了一下漏桶模型</p>
<p>Q：你觉得漏桶和令牌桶的区别在哪？</p>
<p>A：讲了一下自己对两者的理解</p>
<p>Q：Redis我看你也有用到，为什么Redis这么快？</p>
<p>A：八股</p>
<p>Q：IO多路复用详细讲一下</p>
<p>A：balabalabala</p>
<p>Q：netty有了解吗？</p>
<p>A：了解的不多</p>
<p>Q：<a href="">redis</a>的常用类型，zset的底层数据结构？</p>
<p>A：跳表，为什么用跳表</p>
<p>Q：缓存击穿，缓存雪崩，缓存穿透有了解过吗？</p>
<p>A：八股，顺便讲了讲缓存淘汰策略，布隆过滤器等</p>
<p>Q：布隆过滤器原理？</p>
<p>A：记不太清了，大概记得和hashmap差不多，答了一下</p>
<p>Q：单Key过热怎么办？</p>
<p>A：Redis集群，然后一致性hash，把访问打到不同机器上</p>
<p>开始问另一个<a href="">项目</a></p>
<p>Q：统计用户访问ip怎么做的？</p>
<p>A：MySQL，用AOP在用户访问的时候记录</p>
<p>Q：实现了统计pv，如何实现uv？</p>
<p>A：做好去重，记录用户访问信息的时候把时间戳带上</p>
<p>Q：如何去重？在MySQL里面做吗？</p>
<p>A：是的</p>
<p>Q：有了解过hadoop相关吗？</p>
<p>A：了解过，但是没在<a href="">项目</a>中使用过</p>
<p>Q：建议可以去了解一下，因为大数据相关技术在我们这里用的挺多的</p>
<p>Q：如果有大量数据的话还能直接在MySQL里面做去重吗？</p>
<p>A：大量数据就用Redis，使用bitMap可以一战</p>
<p>（对于这里又提了几个场景，最后确实答不出了，感觉只有分布式计算才能破了）</p>
<p>Q：讲讲你的几个奖项吧？</p>
<p>A：把奖项，<a href="">项目</a>讲了讲balabala</p>
<h1 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h1><h2 id="Gateway限流-了解"><a href="#Gateway限流-了解" class="headerlink" title="Gateway限流(了解)"></a>Gateway限流(了解)</h2><p>网关除了请求路由、身份验证，还有一个非常重要的作用：请求限流。当系统面对高并发请求时，为了减少对业务处理服务的压力，需要在网关中对请求限流，按照一定的速率放行请求。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212149723.png" alt="image-20200108155348648"></p>
<h3 id="令牌桶算法原理"><a href="#令牌桶算法原理" class="headerlink" title="令牌桶算法原理"></a>令牌桶算法原理</h3><p>SpringGateway中采用的是令牌桶算法，令牌桶算法原理：</p>
<ul>
<li>准备一个令牌桶，有固定容量，一般为服务并发上限</li>
<li>按照固定速率，生成令牌并存入令牌桶，如果桶中令牌数达到上限，就丢弃令牌。</li>
<li>每次请求调用需要先获取令牌，只有拿到令牌，才继续执行，否则选择选择等待或者直接拒绝。</li>
</ul>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212149724.png" alt="image-20200108161959810"></p>
<h2 id="ribbon做负载均衡"><a href="#ribbon做负载均衡" class="headerlink" title="ribbon做负载均衡"></a>ribbon做负载均衡</h2><h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><p>5万的并发连接，一个master，多个worker，worker干活</p>
<h2 id="反向代理原理"><a href="#反向代理原理" class="headerlink" title="反向代理原理"></a>反向代理原理</h2><p>什么是反向代理？</p>
<ul>
<li>代理：通过客户机的配置，实现让一台服务器代理客户机，客户的所有请求都交给代理服务器处理。</li>
<li>反向代理：用一台服务器，代理真实服务器，用户访问时，不再是访问真实服务器，而是代理服务器。</li>
</ul>
<p>nginx可以当做反向代理服务器来使用：</p>
<ul>
<li>我们需要提前在nginx中配置好反向代理的规则，不同的请求，交给不同的真实服务器处理</li>
<li>当请求到达nginx，nginx会根据已经定义的规则进行请求的转发，从而实现路由功能</li>
</ul>
<p>利用反向代理，就可以解决我们前面所说的端口问题，如图：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212149725.png" alt="image-20200111175118787"></p>
<h2 id="负载均衡（了解）"><a href="#负载均衡（了解）" class="headerlink" title="负载均衡（了解）"></a>负载均衡（了解）</h2><p>我们的nginx反向代理，目标服务器地址是通过IP和Port来指定，那么新的问题来了：</p>
<p>如果我们的<code>leyou-manage</code>不是单节点，而是一个服务集群，如图：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212149726.png" alt="image-20200113094533555"></p>
<h3 id="负载均衡轮询策略"><a href="#负载均衡轮询策略" class="headerlink" title="负载均衡轮询策略"></a>负载均衡轮询策略</h3><p>首先定义负载均衡的集群节点信息，及负载均衡的策略，默认策略是轮询，顾名思义，所有请求都按照时间顺序分配到不同的服务上，如果服务Down掉，可以自动剔除，本例中配置四个节点轮询：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 负载均衡配置，默认是轮询</span></span><br><span class="line"><span class="section">upstream</span> leyou-manage&#123;</span><br><span class="line">	<span class="attribute">server</span>	<span class="number">127.0.0.1:9001</span>; <span class="comment"># 节点信息</span></span><br><span class="line">    <span class="attribute">server</span>	<span class="number">127.0.0.1:9002</span>; <span class="comment"># 节点信息</span></span><br><span class="line">    <span class="attribute">server</span>	<span class="number">127.0.0.1:9003</span>; <span class="comment"># 节点信息</span></span><br><span class="line">    <span class="attribute">server</span>	<span class="number">127.0.0.1:9004</span>; <span class="comment"># 节点信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在反向代理时不要指向具体IP，而是这里配置的：<code>leyou-manage</code>。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">	<span class="attribute">server_name</span>  manage.leyou.com;</span><br><span class="line">	</span><br><span class="line">	<span class="section">location</span> / &#123;</span><br><span class="line">	    <span class="attribute">proxy_pass</span>   http://leyou-manage;</span><br><span class="line">		<span class="attribute">proxy_connect_timeout</span> <span class="number">600</span>;</span><br><span class="line">		<span class="attribute">proxy_read_timeout</span> <span class="number">5000</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="加权轮询"><a href="#加权轮询" class="headerlink" title="加权轮询"></a>加权轮询</h3><p>指定每个服务的权重比例，weight和访问比率成正比，通常用于后端服务机器性能不统一，将性能好的分配权重高来发挥服务器最大性能，如下配置后9001服务的访问比率会是9002服务的二倍。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 负载均衡配置，默认是轮询</span></span><br><span class="line"><span class="section">upstream</span> leyou-manage&#123;</span><br><span class="line">	<span class="attribute">server</span>	<span class="number">127.0.0.1:9001</span> weight=<span class="number">1</span>; <span class="comment"># 节点信息</span></span><br><span class="line">    <span class="attribute">server</span>	<span class="number">127.0.0.1:9002</span> weight=<span class="number">2</span>; <span class="comment"># 节点信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="IP哈希"><a href="#IP哈希" class="headerlink" title="IP哈希"></a>IP哈希</h3><p>每个请求都根据访问ip的hash结果分配，经过这样的处理，每个访客固定访问一个后端服务</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span>  leyou-manage &#123;</span><br><span class="line">    ip_hash; </span><br><span class="line">	<span class="attribute">server</span>	<span class="number">127.0.0.1:9001</span>; <span class="comment"># 节点信息</span></span><br><span class="line">    <span class="attribute">server</span>	<span class="number">127.0.0.1:9002</span>; <span class="comment"># 节点信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最少连接"><a href="#最少连接" class="headerlink" title="最少连接"></a>最少连接</h3><p>将请求分配到连接数最少的服务上。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span> leyou-manage&#123;</span><br><span class="line">    least_conn;</span><br><span class="line">	<span class="attribute">server</span>	<span class="number">127.0.0.1:9001</span>; <span class="comment"># 节点信息</span></span><br><span class="line">    <span class="attribute">server</span>	<span class="number">127.0.0.1:9002</span>; <span class="comment"># 节点信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="作为图片服务器"><a href="#作为图片服务器" class="headerlink" title="作为图片服务器"></a>作为图片服务器</h2><p>将images放入html目录下,通过images.leyou.com访问图片服务器,可以通过配置开启sendfile系统调用, 零拷贝;</p>
<h1 id="上传文件到OSS"><a href="#上传文件到OSS" class="headerlink" title="上传文件到OSS"></a>上传文件到OSS</h1><h2 id="传统方式"><a href="#传统方式" class="headerlink" title="传统方式"></a>传统方式</h2><p>我们可以直接使用java代码来实现把图片上传到OSS，不过这样以来文件会先从客户端浏览器上传到我们的服务端tomcat，然后再上传到OSS，效率较低，如图：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212149727.png" alt="1552311281042"></p>
<p>以上方法有三个缺点：</p>
<ul>
<li>上传慢。先上传到应用服务器，再上传到OSS，网络传送比直传到OSS多了一倍。如果直传到OSS，不通过应用服务器，速度将大大提升，而且OSS采用BGP带宽，能保证各地各运营商的速度。</li>
<li>扩展性差。如果后续用户多了，应用服务器会成为瓶颈。</li>
<li>费用高。需要准备多台应用服务器。由于OSS上传流量是免费的，如果数据直传到OSS，不通过应用服务器，那么将能省下几台应用服务器。</li>
</ul>
<h2 id="web前端签名后直传"><a href="#web前端签名后直传" class="headerlink" title="web前端签名后直传"></a>web前端签名后直传</h2><p>客户端通过JavaScript代码完成签名，然后通过表单直传数据到OSS。无需访问应用服务器，对应用服务器压力较低。</p>
<p>流程图如下：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212149728.png" alt="image-20200127125730699"></p>
<ul>
<li>JavaScript客户端签名直传：<ul>
<li>优点：在客户端通过JavaScript代码完成签名，无需过多配置，即可实现直传，非常方便。</li>
<li>问题：客户端通过JavaScript把AccesssKeyID 和AccessKeySecret写在代码里面有泄露的风险</li>
</ul>
</li>
</ul>
<h2 id="服务端签名后直传流程"><a href="#服务端签名后直传流程" class="headerlink" title="服务端签名后直传流程"></a>服务端签名后直传流程</h2><p>服务端签名后直传的原理如下：</p>
<ol>
<li>用户发送上传Policy请求到应用服务器（我们的微服务）。</li>
<li>应用服务器返回上传Policy和签名给用户。</li>
<li>用户直接上传数据到OSS。</li>
</ol>
<p>流程图：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212149729.png" alt="1552311833528"></p>
<ul>
<li>服务端签名，JavaScript客户端直传：<ul>
<li>优点：Web端向服务端请求签名，然后直接上传，不会对服务端产生压力，而且安全可靠</li>
<li>问题：服务端无法实时了解用户上传了多少文件，上传了什么文件</li>
</ul>
</li>
</ul>
<p>在页面点击上传的按钮，可以看到请求已经发出：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212149730.png" alt="image-20200127132348077"> </p>
<p>这正是在向服务端申请签名，接下来我们需要在服务端接收请求，生成签名并返回。</p>
<p>我们要做的事情包括：</p>
<ul>
<li>搭建微服务</li>
<li>在微服务中，提供一个接口，生成文件上传需要的签名<ul>
<li>分析接口声明，分析请求方式、请求路径、请求参数、返回值类型</li>
<li>实现业务，生成签名<ul>
<li>把一些常量配置到yml文件</li>
<li>编写类，读取这些属性</li>
<li>把OSS客户端注入到spring容器</li>
<li>编写业务，实现签名的生成</li>
<li>解决跨域问题(在阿里云OSS上设置)</li>
</ul>
</li>
</ul>
</li>
<li>前端，调用我们的接口，获取签名（已完成）</li>
<li>前端，携带签名，完成上传（已完成）</li>
</ul>
<p>签名返回值</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;accessId&quot;</span><span class="punctuation">:</span><span class="string">&quot;6MKO******4AUk44&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;host&quot;</span><span class="punctuation">:</span><span class="string">&quot;http://post-test.oss-cn-hangzhou.aliyuncs.com&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;policy&quot;</span><span class="punctuation">:</span><span class="string">&quot;eyJleHBpcmF0aW9uIjoiMjAxNS0xMS0wNVQyMDo1Mjoy******Jjdb25kaXRpb25zIjpbWyJjdb250ZW50LWxlbmd0aC1yYW5nZSIsMCwxMDQ4NTc2MDAwXSxbInN0YXJ0cy13aXRoIiwiJGtleSIsInVzZXItZGlyXC8iXV19&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;signature&quot;</span><span class="punctuation">:</span><span class="string">&quot;VsxOcOudx******z93CLaXPz+4s=&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;expire&quot;</span><span class="punctuation">:</span><span class="number">1446727949</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;dir&quot;</span><span class="punctuation">:</span><span class="string">&quot;user-dirs/&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>详细解释：</p>
<ul>
<li><code>accessId</code>：用户的AccessKeyId</li>
<li><code>host</code>：申请的阿里OSS的bucket访问地址</li>
<li><code>policy</code>：文件上传的策略，主要包含对上传文件的要求，利用Base64加密后返回，<a target="_blank" rel="noopener" href="https://help.aliyun.com/document_detail/31988.html?spm=a2c4g.11186623.2.22.58cd7eaer5eXWw#section-d5z-1ww-wdb">说明文档</a></li>
<li><code>signature</code>：生成的签名</li>
<li><code>expire</code>：本次签名的过期时间，客户端可以换成签名，在有效期内无需再次签名</li>
<li><code>dir</code>：要上传到bucket中的哪个目录</li>
</ul>
<p>使用HmacSHA256签名,用户申请后授权微服务将这个发给客户端,客户端将这个和图片发给阿里云,阿里云验证后就可以上传了.阿里服务器将我们的用我们的私钥然后用同样的算法算出签名来验证.</p>
<h1 id="商品详情页"><a href="#商品详情页" class="headerlink" title="商品详情页"></a>商品详情页</h1><ul>
<li>如何做到动态响应需求变化，页面变化？<ul>
<li>将页面模板动态化，需要的数据静态化</li>
</ul>
</li>
<li>如何避免整个页面的全量更新？<ul>
<li>我们把页面分成几部分：如顶部面包屑、商品SKU展示、商品描述、商品评论等，形成多个页面模板（模块）。对应的数据也分成几部分，这些数据可能来自不同的微服务。这样可以减少因局部变更引起的整个页面重新生成。</li>
</ul>
</li>
<li>如何应对Tomcat的并发能力低问题？<ul>
<li>将模板渲染、数据放到nginx中做，利用nginx的高并发能力提高系统吞吐量</li>
</ul>
</li>
<li>如何实现数据静态化？<ul>
<li>需要的数据可以缓存在Nginx的本地共享词典中（长期不会修改的数据），如果命中则直接渲染并返回。如果未命中，则查询Redis集群，获取数据。如果Redis集群依然未命中，再去查询后台微服务，由微服务获取数据，然后写入缓存中，保证下次Nginx可以从缓存中拿到数据。这样可以减少服务端压力。</li>
</ul>
</li>
<li>如何保证数据一致性？<ul>
<li>为了保证Redis数据与数据库数据一致，我们还要用到Canal技术，监听数据库变化，及时更新Redis数据。</li>
</ul>
</li>
</ul>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212149731.png" alt="image-20210427235728804"></p>
<p>因此，我们需要做的事情包括：</p>
<ul>
<li>静态页数据服务：一个收集商品相关数据，并更新Redis缓存的数据服务</li>
<li>Nginx服务：接收用户请求，查询模板数据，利用模板渲染商品页面</li>
<li>Canal服务：监听数据库变化，同步通知静态页数据服务，更新Redis数据</li>
</ul>
<p>OpenResty® 是一个基于 <a target="_blank" rel="noopener" href="http://openresty.org/cn/nginx.html">Nginx</a> 与 Lua 的高性能 Web 平台，其内部集成了大量精良的 Lua 库、第三方模块以及大多数的依赖项。用于方便地搭建能够处理超高并发、扩展性极高的动态 Web 应用、Web 服务和动态网关。</p>
<p>OpenResty® 通过汇聚各种设计精良的 <a target="_blank" rel="noopener" href="http://openresty.org/cn/nginx.html">Nginx</a> 模块（主要由 OpenResty 团队自主开发），从而将 <a target="_blank" rel="noopener" href="http://openresty.org/cn/nginx.html">Nginx</a> 有效地变成一个强大的通用 Web 应用平台。这样，Web 开发人员和系统工程师可以使用 Lua 脚本语言调动 <a target="_blank" rel="noopener" href="http://openresty.org/cn/nginx.html">Nginx</a> 支持的各种 C 以及 Lua 模块，快速构造出足以胜任 10K 乃至 1000K 以上单机并发连接的高性能 Web 应用系统。</p>
<p>OpenResty® 的目标是让你的Web服务直接跑在 <a target="_blank" rel="noopener" href="http://openresty.org/cn/nginx.html">Nginx</a> 服务内部，充分利用 <a target="_blank" rel="noopener" href="http://openresty.org/cn/nginx.html">Nginx</a> 的非阻塞 I&#x2F;O 模型，不仅仅对 HTTP 客户端请求,甚至于对远程后端诸如 MySQL、PostgreSQL、Memcached 以及 Redis 等都进行一致的高性能响应。</p>
<p>接下来我们利用OpenResty实现商品详情页渲染，大概需要这样的步骤：</p>
<ul>
<li>监听用户请求,进入定义好的lua脚本</li>
<li>lua脚本中尝试读取redis数据</li>
<li>读取数据失败，尝试从<code>ly-page</code>读取数据<ul>
<li>获取数据失败：返回404</li>
<li>获取数据成功：开始渲染</li>
</ul>
</li>
<li>把数据和模板交给template模块渲染，然后返回</li>
</ul>
<p>我们要做的事情包括：</p>
<ul>
<li>定义内部请求代理：<ul>
<li>当需要向<code>ly-page</code>获取数据时，走这个内部请求代理</li>
<li>对这个请求做限流处理，防止并发过大引起雪崩</li>
</ul>
</li>
<li>定义通用工具模块：<ul>
<li>访问Redis的工具</li>
<li>访问<code>ly-page</code>的http工具</li>
</ul>
</li>
<li>定义商品详情页面模板</li>
<li>编写数据处理的lua脚本</li>
<li>编写商品页面请求的路径映射</li>
</ul>
<p>虽然已经实现了页面静态化，不过依然有值的优化的地方：</p>
<ul>
<li>在Nginx中设置本地缓存，把几乎不变的数据直接存储在nginx内部，例如：<ul>
<li>商品分类数据</li>
<li>品牌数据</li>
<li>规格参数数据</li>
</ul>
</li>
<li>在nginx中对生成的页面做缓存或静态化，做CDN服务，页面不变的时候，减少渲染对CPU的消耗</li>
<li>随着商品数据的日益增多，Redis可能难以支持海量商品信息，此时可以用SSDB来代替，SSDB存储基于磁盘存储，查询性能与Redis差不多，因此可以作为海量数据的缓存库</li>
</ul>
<h2 id="canal"><a href="#canal" class="headerlink" title="canal"></a>canal</h2><p>模拟salve, 监听binary log日志;</p>
<p>设置账号权限</p>
<ul>
<li>增、改：我们写入数据到redis</li>
<li>删：我们把数据从redis删除</li>
</ul>
<h1 id="用户中心"><a href="#用户中心" class="headerlink" title="用户中心"></a>用户中心</h1><h3 id="密码加密"><a href="#密码加密" class="headerlink" title="密码加密"></a>密码加密</h3><p>基本逻辑：</p>
<ul>
<li>1）校验短信验证码</li>
<li>2）对密码加密</li>
<li>3）写入数据库</li>
</ul>
<p>密码加密：</p>
<p>密码加密使用传统的MD5加密并不安全，这里我们使用的是Spring提供的BCryptPasswordEncoder加密算法，分成加密和验证两个过程：</p>
<ul>
<li><p>加密：算法会对明文密码随机生成一个salt，使用salt结合密码来加密，得到最终的密文。</p>
</li>
<li><p>验证密码：需要先拿到加密后的密码和要验证的密码，根据已加密的密码来推测出salt，然后利用相同的算法和salt对要验证码的密码加密，与已加密的密码对比即可。</p>
</li>
</ul>
<p>为了防止有人能根据密文推测出salt，我们需要在使用BCryptPasswordEncoder时配置随即密钥，在<code>com.leyou.user.config</code>包中创建一个配置类，注册<code>BCryptPasswordEncoder</code>对象</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ly:</span></span><br><span class="line">  <span class="attr">encoder:</span></span><br><span class="line">    <span class="attr">crypt:</span></span><br><span class="line">      <span class="attr">secret:</span> <span class="string">$&#123;random.uuid&#125;</span> <span class="comment"># 随机的密钥，使用uuid</span></span><br><span class="line">      <span class="attr">strength:</span> <span class="number">6</span> <span class="comment"># 加密强度4~31，决定盐加密时的运算强度，超过10以后加密耗时会显著增加</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(User user, String code)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.校验验证码</span></span><br><span class="line">    <span class="comment">// 1.1 取出redis中的验证码</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">cacheCode</span> <span class="operator">=</span> redisTemplate.opsForValue().get(KEY_PREFIX + user.getPhone());</span><br><span class="line">    <span class="comment">// 1.2 比较验证码</span></span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.equals(code, cacheCode)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">LyException</span>(<span class="number">400</span>, <span class="string">&quot;验证码错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.对密码加密</span></span><br><span class="line">    user.setPassword(passwordEncoder.encode(user.getPassword()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.写入数据库</span></span><br><span class="line">    save(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="为什么用MD5不安全"><a href="#为什么用MD5不安全" class="headerlink" title="为什么用MD5不安全?"></a>为什么用MD5不安全?</h4><p>MD5加密可以查表;</p>
<h4 id="BCryptPasswordEncoder的原理"><a href="#BCryptPasswordEncoder的原理" class="headerlink" title="BCryptPasswordEncoder的原理"></a>BCryptPasswordEncoder的原理</h4><p>SHA-256 +随机盐+密钥对密码进行加密,过程是不可以逆的; 加密(encode): 算出hash然后存取数据库,算法不可逆,密码强度超过10会变慢;  密码匹配(matches): 验证密码和hash有没有问题,然后通过存入数据库的hash计算出salt,然后再去加密比对;</p>
<h2 id="服务端数据校验"><a href="#服务端数据校验" class="headerlink" title="服务端数据校验"></a>服务端数据校验</h2><p>使用Hibernate-Validator(用注解的方式@Email @Pattern(value) 等)</p>
<p>@Pattern(regexp &#x3D; RegexPatterns.USERNAME_R EGEX, message &#x3D; “用户名格式不正确”)</p>
<p>@Pattern(regexp &#x3D; RegexPatterns.USERNAME_REGEX, message &#x3D; “密码格式不正确”)</p>
<p>@Pattern(regexp &#x3D; RegexPatterns.PHONE_REGEX, message &#x3D; “手机号格式不正确”)</p>
<h1 id="jwt登录"><a href="#jwt登录" class="headerlink" title="jwt登录"></a>jwt登录</h1><p>用对称加密的话会多一次调用;  订单那里还需要再次解析jwt, 下单需要知道用户信息, 每个线程绑定对应的用户信息, 使用ThreadLocal; 用对称加密就需要解析4次, 用Rsa只需要解析2次; </p>
<p>用户登录信息<strong>校验失败以后</strong>，判断用户路径是否是白名单中的路径，如果是则放行，如果不是则拦截。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212149732.png" alt="image-20200325115057407"></p>
<h2 id="面试常见问题"><a href="#面试常见问题" class="headerlink" title="面试常见问题"></a>面试常见问题</h2><h3 id="jwt和security的对比："><a href="#jwt和security的对比：" class="headerlink" title="jwt和security的对比："></a>jwt和security的对比：</h3><p>JWT的：</p>
<ul>
<li><p>优点：</p>
<ul>
<li>无需再服务端存储用户数据，减轻服务端压力</li>
<li>轻量级，json风格，比较简单</li>
<li>跨语言</li>
</ul>
</li>
<li><p>有利于水平扩展</p>
</li>
<li><p>缺点：</p>
<ul>
<li>token一旦签发，无法修改<ul>
<li>无法更新token有效期，用户登录状态刷新难以实现</li>
<li>无法销毁一个token，服务端不能对用户状态进行绝对控制</li>
</ul>
</li>
<li>不包含权限控制</li>
</ul>
</li>
</ul>
<p>SpringSecurity：</p>
<ul>
<li><p>优点：</p>
<ul>
<li>用户信息保存再服务端，服务端可以对用户状态绝对控制</li>
<li>基于Spring，无缝整合，修改登录逻辑，其实就是添加过滤器</li>
<li>整合权限管理</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>限定了语言</li>
<li>实现复杂，基于一连串的过滤器链</li>
<li>需要再服务端保存用户信息，增加服务端压力</li>
<li>依赖于tomcat的HttpSession、如果是分布式项目，session不共享，登录失效，需要借助于SpringSession，实现共享session效果（利用redis代替tomcat的session</li>
</ul>
</li>
</ul>
<h3 id="登录控制问题"><a href="#登录控制问题" class="headerlink" title="登录控制问题"></a>登录控制问题</h3><ul>
<li><p>你们使用JWT做登录凭证，如何解决token注销问题</p>
<p>答：jwt的缺陷是token生成后无法修改，因此无法让token失效。只能采用其它方案来弥补，基本思路如下：</p>
<p>  1）用户登录后，生成JWT，其中包含用户身份</p>
<p>  2）以用户id为key，把JWT的id存入redis，只有redis中有id的JWT，才是有效的JWT</p>
<p>  3）并且给Redis设置有效期，有效期到自动删除</p>
<p>  4）退出登录时，把ID从Redis删除即可</p>
</li>
<li><p>怎么解决登录超时后的登录续签问题？</p>
<p>答：判断登录是否超时的标准是redis，而不是JWT，因此每次用户访问网关，我们都会刷新redis的数据有效期，保证登录状态不断。</p>
</li>
<li><p>如何解决异地登录或跨设备登录问题？</p>
<p>答：</p>
<p>方案一：不允许多端登录</p>
<p>如果账户在第二个设备登录，自然会将redis中的JWT覆盖，那么之前的登录凭证就成了无效凭证。</p>
<p>方案二：允许多端登录</p>
<p>存入redis时，redis的类型可以选择set，这样一个用户可以具备多个JWT的id，实现多端登录。</p>
</li>
</ul>
<h3 id="cookie安全问题"><a href="#cookie安全问题" class="headerlink" title="cookie安全问题"></a>cookie安全问题</h3><ul>
<li><p>如何解决token被篡改问题？</p>
<ul>
<li>答：token中的数据可以篡改，但是签名无法篡改，否则服务端认证根本不会通过，因此篡改的token是无法通过服务端校验的</li>
</ul>
</li>
<li><p>如何防止token的伪造</p>
<p>与上个问题类似，token中带有签名认证，而签名需要私钥加密生成。只要私钥不泄露，就不可能有人伪造token，因为其它秘钥生成的token是不会被公钥认可的。</p>
</li>
<li><p>如何解决cookie被盗用问题？  分布式的话存到redis,</p>
<p>答：cookie被盗用的可能性主要包括下面几种：</p>
<ul>
<li><p>XSS攻击：这个可以再前端页面渲染时对 数据做安全处理即可，而且我们的cookie使用了Httponly为true，可以防止JS脚本的攻击。 </p>
</li>
<li><p>CSRF攻击：</p>
<ul>
<li>利用Referer头，防盗链</li>
<li>请求头中加随机码</li>
</ul>
</li>
<li><p>数据抓包，获取用户cookie：我们采用了HTTPS协议通信，无法获取请求的任何数据</p>
</li>
<li><p>请求重放攻击：对于普通用户的请求没有对请求重放做防御，而是对部分业务做好了幂等处理。运行管理系统中会对token添加随机码，认证token一次有效，来预防请求重放攻击。</p>
<p>(1)**加<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E9%9A%8F%E6%9C%BA%E6%95%B0/2454368">随机数</a>**。该方法优点是认证双方不需要时间同步，双方记住使用过的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E9%9A%8F%E6%9C%BA%E6%95%B0">随机数</a>，如发现<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%8A%A5%E6%96%87">报文</a>中有以前使用过的随机数，就认为是重放攻击。缺点是需要额外保存使用过的随机数，若记录的时间段较长，则保存和查询的开销较大。 [4] </p>
<p>(2)**加<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%97%B6%E9%97%B4%E6%88%B3">时间戳</a>**。该方法优点是不用额外保存其他信息。缺点是认证双方需要准确的时间同步，同步越好，受攻击的可能性就越小。但当系统很庞大，跨越的区域较广时，要做到精确的时间同步并不是很容易。 [4] </p>
<p>(3)**加<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%B5%81%E6%B0%B4%E5%8F%B7/5623476">流水号</a>**。就是双方在报文中添加一个逐步递增的整数，只要接收到一个不连续的流水号报文(太大或太小)，就认定有重放威胁。该方法优点是不需要时间同步，保存的信息量比随机数方式小。缺点是一旦攻击者对报文解密成功，就可以获得流水号，从而每次将流水号递增欺骗认证端。</p>
</li>
<li><p>用户电脑中毒：这个无法防范。</p>
</li>
</ul>
</li>
<li><p>用户的cookie被禁用怎么办？</p>
<ul>
<li>cookie一般情况下，是不会被禁用，因为普通人根本不知道是什么是cookie，一般不用管，为了友好，我们可以给用户一个提示：你的cookie已经被禁用了，请启用cookie。</li>
<li>把jwt作为响应头返回，浏览器中JS把token写到本地存储（sessionStorage），要求前端每次发ajax，都必须自己携带token。而且有被xss攻击的风险</li>
</ul>
</li>
</ul>
<h3 id="权限问题"><a href="#权限问题" class="headerlink" title="权限问题"></a>权限问题</h3><ul>
<li><p>如何完成权限校验的？</p>
<ul>
<li>首先我们有权限管理的服务，管理用户的各种权限，及可访问路径等</li>
<li>在网关中利用过滤器，拦截一切请求，在过滤器中，解析和验证jwt，获取用户身份，查询用户权限，判断用户身份可以访问当前路径</li>
</ul>
</li>
<li><p>服务端微服务地址不小心暴露了，用户就可以绕过网关，直接访问微服务，怎么办？</p>
<ul>
<li><p>首先，我们的微服务隐藏在网关的后面，而且整个服务被Nginx反向代理，用户只能看到nginx的地址，微服务暴露的可能性很低。</p>
</li>
<li><p>兜底方案：</p>
<ul>
<li>如果担心服务安全，我们可以将登录校验和权限校验分离。在网关中只负责登录校验功能，在每个微服务处理用户权限。这样即便有人绕过了网关访问，只要权限不通过，依然无法访问。</li>
<li>用户请求到网关，网关会生成一个新的令牌，这个令牌包含用户信息，仅在访问微服务时使用，被访问的微服务会校验这个内部令牌，从而验证请求者是不是内部的微服务</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="单点登录问题"><a href="#单点登录问题" class="headerlink" title="单点登录问题"></a>单点登录问题</h3><p>单点登录，顾名思义：在分布式服务中，用户只需要在一处登录，即可在各个受信任的服务器之间，共享登录状态，称为单点登录</p>
<p>任何登录都离不开cookie，如果cookie无法使用或共享，就会导致登录凭证无法共享，导致登录状态无法共享。例如因为跨域名的多个服务，其cookie不可共享，导致登录失效。</p>
<p>因此实现单点登录有多种方式，其区别就在于是否能解决跨域登录</p>
<ul>
<li>同域名单点登录<ul>
<li>分布式服务共享二级域名，二级以上域名不同，此时cookie可以共享。解决思路：<ul>
<li>JWT无状态登录</li>
<li>共享Session</li>
</ul>
</li>
</ul>
</li>
<li>跨域单点登录<ul>
<li>服务二级域名就不同，导致cookie无法共享，解决办法：<ul>
<li>OAuth协议实现单点登录：<a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2019/04/oauth_design.html">Oauth2.0协议</a>，成熟的框架：<a target="_blank" rel="noopener" href="https://blog.csdn.net/anumbrella/article/details/80821486">CAS</a></li>
<li>跨域跳转时，传递cookie数据，从而共享cookie</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>CAS原理:</p>
<p>1 用户第一次访问一个CAS 服务的客户web 应用时（访问URL ：<a target="_blank" rel="noopener" href="http://192.168.1.90:8081/web1">http://192.168.1.90:8081/web1</a> ），部署在客户web 应用的cas AuthenticationFilter ，会截获此请求，生成service 参数<br>2 然后redirect 到CAS 服务的login 接口，url为<a target="_blank" rel="noopener" href="https://cas:8443/cas/login?service=http://192.168.1.90:8081/web1/">https://cas:8443/cas/login?service=http%3A%2F%2F192.168.1.90%3A8081%2Fweb1%2F</a> ，认证成功后，CAS 服务器会生成认证cookie ，写入浏览器，同时将cookie 缓存到服务器本地，CAS 服务器还会根据service 参数生成ticket,ticket 会保存到服务器，也会加在url 后面<br>3 然后将请求redirect 回客户web 应用，url 为<a target="_blank" rel="noopener" href="http://192.168.1.90:8081/web1/?ticket=ST-5-Sx6eyvj7cPPCfn0pMZuMwnbMvxpCBcNAIi6-20">http://192.168.1.90:8081/web1/?ticket=ST-5-Sx6eyvj7cPPCfn0pMZuMwnbMvxpCBcNAIi6-20</a> 。<br>4 这时客户端的AuthenticationFilter 看到ticket 参数后，会跳过，由其后面的TicketValidationFilter 处理，TicketValidationFilter 会利用httpclient 工具访问cas 服务的&#x2F;serviceValidate 接口, 将ticket 、service 都传到此接口，由此接口验证ticket 的有效性，TicketValidationFilter 如果得到验证成功的消息，就会把用户信息写入web 应用的session里。至此为止，SSO 会话就建立起来了<br>5 以后用户在同一浏览器里访问此web 应用时，AuthenticationFilter 会在session 里读取到用户信息，所以就不会去CAS 认证<br>6 如果在此浏览器里访问别的web 应用时，AuthenticationFilter 在session 里读取不到用户信息，会去CAS 的login 接口认证，但这时CAS 会读取到浏览器传来的cookie ，所以CAS 不会要求用户去登录页面登录，只是会根据service 参数生成一个ticket ，然后再和web 应用做一个验证ticket 的交互。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212149733.png"></p>
<h1 id="购物车"><a href="#购物车" class="headerlink" title="购物车"></a>购物车</h1><p>未登录购物车:放在本地 LocalStorage; 已登录购物车放在moongoDB</p>
<p>web本地存储主要有两种方式：</p>
<ul>
<li>LocalStorage：localStorage 方法存储的数据没有时间限制。第二天、第二周或下一年之后，数据依然可用。 </li>
<li>SessionStorage：sessionStorage 方法针对一个 session 进行数据存储。当用户关闭浏览器窗口后，数据会被删除。</li>
</ul>
<p>Localstorage和sessionStorage的本质都时一个JS的对象</p>
<p>对象怎么操作，LocalStorage就怎么操作。</p>
<h3 id="ThreadLocal获取登录用户信息"><a href="#ThreadLocal获取登录用户信息" class="headerlink" title="ThreadLocal获取登录用户信息"></a>ThreadLocal获取登录用户信息</h3><p>既然要把用户id作为集合名称一部分，我们就必须想办法在请求进入交易服务时就获取用户信息，并且将当前用户信息与当前请求线程绑定。</p>
<p>其中有两个事情需要我们去思考：</p>
<ul>
<li>如何在请求进入后获取登录用户信息</li>
<li>如何将用户信息与当前请求线程绑定</li>
</ul>
<h4 id="获取用户思路分析"><a href="#获取用户思路分析" class="headerlink" title="获取用户思路分析"></a>获取用户思路分析</h4><p>要获取登录的用户信息，有以下几种方式：</p>
<ul>
<li>方式一：页面直接把用户作为请求参数传递<ul>
<li>优点：简单，方便，代码量为0</li>
<li>缺点：不安全，因为调用购物车CRUD的请求是从页面发过来的，我们不能确定这个传递来的id是不是真的是用户的id</li>
</ul>
</li>
<li>方式二：自己从cookie的token中解析用户信息<ul>
<li>优点：安全</li>
<li>缺点：<ul>
<li>需要重复校验JWT，已经在网关中做过了</li>
<li>代码麻烦</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>安全第一，我们选择方式二，如何解决重复校验的问题呢？我们微服务内部可以只解析用户信息，JWT的安全校验。</p>
<p>为了在请求进入服务后直接能拿到用户，我们可以拦截每一个进入controller的请求，统一完成登录用户的获取，这个拦截可以通过SpringMVC的通用拦截器：<code>HandlerInterceptor</code>来实现。</p>
<h1 id="下单功能"><a href="#下单功能" class="headerlink" title="下单功能"></a>下单功能</h1><h2 id="下单逻辑"><a href="#下单逻辑" class="headerlink" title="下单逻辑"></a>下单逻辑</h2><p>id类型：这里是<code>@TableId(type = IdType.ASSIGN_ID)</code>，代表是自动生成ID，id生成算法是由MybatisPlus内置的雪花算法（SnowFlake，由Twitter公司开源）</p>
<p>问题：为什么不让页面直接把商品价格、图片、spec、标题都提交到服务端，而是只提交了商品id？</p>
<p>答：为了安全考虑，商品价格等敏感信息由客户端提交存在风险。</p>
<h2 id="减库存"><a href="#减库存" class="headerlink" title="减库存"></a>减库存</h2><ul>
<li>支付减库存？<ul>
<li>优点：用户付款，才会减库存，可以确定用户一定有购买意图，不会出现恶意下单导致的库存堆积</li>
<li>缺点：可能用户付款后，发现库存不足，用户体验差</li>
</ul>
</li>
<li>下单减库存<ul>
<li>优点：下单就预留库存，用户付款一定能拿到商品，体验比较好</li>
<li>缺点：如果用户下单，不付款，会占用商家库存，导致它人无法购买</li>
</ul>
</li>
</ul>
<p>我们需要根据不同的场景去做选择，如果更在意用户体验，应该选择下单减库存！但是如何应对下单减库存的缺点呢？</p>
<ul>
<li>超时未支付的订单需要关闭</li>
<li>限定每个用户每天可以取消订单的次数</li>
</ul>
<h4 id="减库存安全问题"><a href="#减库存安全问题" class="headerlink" title="减库存安全问题"></a>减库存安全问题</h4><p>上面这样的操作存在线程安全的风险，因为我们的代码是允许在多线程环境的，当多个用户并发访问时，先判断库存是否充足，然后再执行减库存，会出现一种情况：判断的时候，库存是充足的，但是在减库存之前，有其它线程抢先一步，扣减库存，导致库存不足了，此时就会出现超卖现象！</p>
<h4 id="思路一-同步锁-Redis分布式锁"><a href="#思路一-同步锁-Redis分布式锁" class="headerlink" title="思路一: 同步锁(Redis分布式锁)"></a>思路一: 同步锁(Redis分布式锁)</h4><p>我们一般需要加同步锁，synchronized，目的是让多线程串行执行，从而保证线程安全，但是加synchronized只能保证在当前JVM内的线程安全。</p>
<p>如果是搭建一个微服务集群，同步锁synchronized就失效了。原因是因为线程锁，在多进程时会失效，因为每个进程都有自己的锁。</p>
<p>解决多进程安全问题，必须使用进程锁(分布式锁),这种方案需要额外实现一个分布式锁功能,比较麻烦;  </p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212149734.png" alt="image-20210415142201086"></p>
<h4 id="思路二-数据库排它锁"><a href="#思路二-数据库排它锁" class="headerlink" title="思路二: 数据库排它锁"></a>思路二: 数据库排它锁</h4><p>数据库锁简单来说有两种：</p>
<ul>
<li>共享锁：读操作时会开启共享锁，此时大家都可以查询</li>
<li>排它锁（互斥锁）：一般是写操作会开启排它锁，此时其它事务无法获取共享锁或排它锁，会阻塞</li>
</ul>
<p>要保证安全，必须加排它锁。</p>
<p>但是我们之前的业务是先查询sku（读），然后判断是否充足，然后减库存（写），这样就会导致多个请求同时查询到一样的库存，减库存还是有安全问题。</p>
<p>我们必须在查询时就加排它锁，怎么办？</p>
<p>可以通过select … for update语法来开启，但是我们要加锁的商品不止一个，此时加锁就是范围锁，甚至是表锁，性能会有较大的影响, </p>
<h4 id="思路三-乐观锁"><a href="#思路三-乐观锁" class="headerlink" title="思路三: 乐观锁"></a>思路三: 乐观锁</h4><p>上述思路1和思路2都是加锁，实现互斥，保证线程安全，我们称为悲观锁。</p>
<ul>
<li>悲观锁：认为线程安全问题一定会发生，因此会加锁保证线程串行执行，从而保证安全。</li>
</ul>
<p>我们为了追求性能，可以使用乐观锁机制。</p>
<ul>
<li>乐观锁：认为线程安全问题不一定会发生，因此允许多线程并行执行，一般会在执行那一刻进行判断和比较，然后根据是否存在风险来决定是否执行操作,乐观锁就是先比较再执行的思路，其实就是CAS（compare and set）的思想。JDK的JUC包下的AtomicInteger、AtomicLong等; Redis的watch,也是乐观锁,CAS原理;</li>
</ul>
<p>简化: 我们在减库存中,可以用stock来代替version,执行sql时,判断stock是否跟自己查询到的一样，</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> tb_stock <span class="keyword">set</span> stock <span class="operator">=</span> stock <span class="operator">-</span> <span class="number">1</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">10</span> <span class="keyword">AND</span> stock <span class="operator">=</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>继续简化: 我们可以不查询库存,直接执行sql,在sql语句中做判断</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> tb_stock <span class="keyword">set</span> stock <span class="operator">=</span> stock <span class="operator">-</span> <span class="number">1</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">10</span> <span class="keyword">AND</span> stock <span class="operator">&gt;=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>继续简化: 我们最终的目的是库存不能超卖,不能为负数,因此我们可以设置stock字段为无符号整数,数据库会自动对写入的数据判断,如果为负,会抛出异常,我们就无需加锁或其他任何判断.</p>
<h1 id="延迟队列清理订单"><a href="#延迟队列清理订单" class="headerlink" title="延迟队列清理订单"></a>延迟队列清理订单</h1><ul>
<li><strong>定期轮询数据库</strong></li>
<li><strong>DelayQueue</strong></li>
<li><strong>定时任务（Quartz）</strong></li>
<li><strong>Redis键过期通知</strong></li>
<li><strong>Redis(sorted_set)</strong> </li>
<li><strong>时间轮</strong></li>
<li><strong>RabbitMQ 死信队列</strong></li>
</ul>
<h1 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h1><h2 id="业务场景"><a href="#业务场景" class="headerlink" title="业务场景"></a>业务场景</h2><p>比如清除过期订单，查询订单是否已支付（幂等问题），更新订单状态（可以用cas解决），关闭订单也要考虑幂等问题（设置订单状态码解决，然后使用分布式锁）。恢复库存也也有分布式事务问题，还需要分布式锁，如果恢复库存失败，则订单状态也得回滚。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> tb_order <span class="keyword">set</span> status <span class="operator">=</span> <span class="number">2</span>, pay_time <span class="operator">=</span> NOW() <span class="keyword">where</span> order_id <span class="operator">=</span> <span class="number">45154151</span> <span class="keyword">AND</span> status <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212149735.png" alt="image-20210427224336819"></p>
<p>订单服务假设有10台订单微服务, 库存被恢复了两次;</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212149736.png" alt="image-20210427224444490"></p>
<h3 id="线程锁"><a href="#线程锁" class="headerlink" title="线程锁"></a>线程锁</h3><p>没用, 多个订单服务是多个JVM,内存中的锁显然是不共享的,每个JVM进程都有自己的锁, 自然无法保证线程的互斥了;</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212149737.png" alt="image-20210427224642737"></p>
<h3 id="分布式锁-1"><a href="#分布式锁-1" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>多进程可见; 互斥; 可重入(可选); 阻塞锁(可选):获取失败时, 具备重试机制, 尝试再次获取锁; 性能好(可选); 高可用;</p>
<p>常见的分布式锁解决方案包括: 基于数据库实现、基于缓存(Redis)实现、基于zookeeper实现</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212149738.png" alt="image-20210427224727255"></p>
<h2 id="Redis实现分布式锁"><a href="#Redis实现分布式锁" class="headerlink" title="Redis实现分布式锁"></a>Redis实现分布式锁</h2><h3 id="版本一-基本实现"><a href="#版本一-基本实现" class="headerlink" title="版本一:基本实现"></a>版本一:基本实现</h3><p>多进程可见: Redis本身就是基于JVM之外的, 因此满足多进程可见的要求;</p>
<p>互斥: 基于redis setnx指令实现, set when not exits, 多次执行setnx命令时, 只有第一个执行的才会成功并返回1, 其余情况都是返回0;</p>
<p>释放锁: 将key删除即可, 使用del xxx; 如果在执行del之前, 服务突然宕机, 那么锁岂不是永远无法删除了?  为了避免这个问题, 可以在获取锁的时候, 给锁加一个有效时间, 当时间超出时, 就会自动释放锁, 这样就不会死锁了.</p>
<p>但是setnx指令没有设置时间的功能, 我们要借助于set指令, 然后结合set的NX和PX来完成</p>
<p>EX: 过期时间, 单位秒; PX: 过期时间,单位毫米; NX: 等同于setnx;</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set lock 001 NX EX 30</span><br><span class="line">OK</span><br><span class="line">set lock 001 NX EX 30</span><br><span class="line">nil</span><br></pre></td></tr></table></figure>



<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212149739.png" alt="image-20210427230051328"></p>
<h3 id="版本二-互斥性"><a href="#版本二-互斥性" class="headerlink" title="版本二: 互斥性"></a>版本二: 互斥性</h3><p>版本一的问题:</p>
<ol>
<li>3个进程：A和B和C，在执行任务，并争抢锁，此时A获取了锁，并设置自动过期时间为10s</li>
<li>A开始执行业务，因为某种原因，业务阻塞，耗时超过了10秒，此时锁自动释放了</li>
<li>B恰好此时开始尝试获取锁，因为锁已经自动释放，成功获取锁</li>
<li>A此时业务执行完毕，执行释放锁逻辑（删除key），于是B的锁被释放了，而B其实还在执行业务</li>
<li>此时进程C尝试获取锁，也成功了，因为A把B的锁删除了。</li>
</ol>
<p>问题出现了：B和C同时获取了锁，违反了互斥性！</p>
<p>解决方案: 在删除之前判断锁是否时自己设置的锁, 如果不是, 就不要删除</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212149740.png" alt="image-20210427230526972"></p>
<h3 id="版本三-重入性"><a href="#版本三-重入性" class="headerlink" title="版本三: 重入性"></a>版本三: 重入性</h3><p>如果我们在获取锁以后，执行代码的过程中，再次尝试获取锁，执行setnx肯定会失败，因为锁已经存在了。这样有可能导致死锁，这样的锁就是<strong>不可重入</strong>的。</p>
<p>可重入锁可以避免因同一线程中多次获取锁而导致死锁发生;</p>
<p>实现: </p>
<ul>
<li><p>获取锁: 首先尝试获取锁，如果获取失败，<strong>判断这个锁是否是自己的，如果是则允许再次获取</strong>，而且必须记录重复获取锁的次数。</p>
</li>
<li><p>释放锁：释放锁不能直接删除了，因为锁是可重入的，如果锁进入了多次，在最内层直接删除锁，导致外部的业务在没有锁的情况下执行，会有安全问题。因此必须<strong>获取锁时累计重入的次数，释放时则减去重入次数，如果减到0，则可以删除锁</strong>.</p>
</li>
</ul>
<p>因此，存储在锁中的信息就必须包含：key、线程标识、重入次数。不能再使用简单的key-value结构，这里推荐使用hash结构：</p>
<ul>
<li>key：lock</li>
<li>hashKey：线程信息</li>
<li>hashValue：重入次数，默认1</li>
</ul>
<p>需要用到的一些Redis命令包括：</p>
<ul>
<li>EXISTS key：判断一个Key是否存在</li>
<li>HEXISTS key field：判断一个hash的field是否存在</li>
<li>HSET key field value ：给一个hash的field设置一个值</li>
<li>HINCRBY key field increment：给一个hash的field值增加指定数值</li>
<li>EXPIRE key seconds：给一个key设置过期时间</li>
<li>DEL key：删除指定key</li>
</ul>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212149741.png" alt="image-20210427231119197"></p>
<h3 id="Lua脚本解决原子性问题"><a href="#Lua脚本解决原子性问题" class="headerlink" title="Lua脚本解决原子性问题"></a>Lua脚本解决原子性问题</h3><p>如果不能保证这些Redis命令执行的原子性，则整个过程都是不安全的。</p>
<p>Redis支持Lua脚本来运行多行命令, 并且保证整个脚本运行的原子性;</p>
<p>Redis使用同一个Lua解释器来执行所有命令，同时，Redis保证以一种原子性的方式来执行脚本：当lua脚本在执行的时候，不会有其他脚本和命令同时执行，这种语义类似于 MULTI&#x2F;EXEC。从别的客户端的视角来看，一个lua脚本要么不可见，要么已经执行完。</p>
<p>然而这也意味着，执行一个较慢的lua脚本是不建议的，由于脚本的开销非常低，构造一个快速执行的脚本并非难事。但是你要注意到，当你正在执行一个比较慢的脚本时，所以其他的客户端都无法执行命令。</p>
<h3 id="普通互斥锁"><a href="#普通互斥锁" class="headerlink" title="普通互斥锁"></a>普通互斥锁</h3><p>版本二的实现:</p>
<ul>
<li>获取锁不需要脚本</li>
<li>释放锁需要</li>
</ul>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 判断锁是否是自己的</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;GET&#x27;</span>, KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>]) <span class="keyword">then</span></span><br><span class="line">  <span class="comment">-- 是则删除锁</span></span><br><span class="line">  <span class="keyword">return</span> redis.call(<span class="string">&#x27;DEL&#x27;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 不是则直接返回</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>参数的含义说明：</p>
<ul>
<li>KEYS[1]：就是锁的key，比如”lock”</li>
<li>ARGV[1]：就是线程的唯一标识，可以时随机字符串</li>
</ul>
<h3 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h3><p>获取锁:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> key = KEYS[<span class="number">1</span>]; <span class="comment">-- 锁的key</span></span><br><span class="line"><span class="keyword">local</span> threadId = ARGV[<span class="number">1</span>]; <span class="comment">-- 线程唯一标识</span></span><br><span class="line"><span class="keyword">local</span> releaseTime = ARGV[<span class="number">2</span>]; <span class="comment">-- 锁的自动释放时间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(redis.call(<span class="string">&#x27;exists&#x27;</span>, key) == <span class="number">0</span>) <span class="keyword">then</span> <span class="comment">-- 判断是否存在</span></span><br><span class="line">	redis.call(<span class="string">&#x27;hset&#x27;</span>, key, threadId, <span class="string">&#x27;1&#x27;</span>); <span class="comment">-- 不存在, 获取锁</span></span><br><span class="line">	redis.call(<span class="string">&#x27;expire&#x27;</span>, key, releaseTime); <span class="comment">-- 设置有效期</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>; <span class="comment">-- 返回结果</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(redis.call(<span class="string">&#x27;hexists&#x27;</span>, key, threadId) == <span class="number">1</span>) <span class="keyword">then</span> <span class="comment">-- 锁已经存在，判断threadId是否是自己	</span></span><br><span class="line">	redis.call(<span class="string">&#x27;hincrby&#x27;</span>, key, threadId, <span class="string">&#x27;1&#x27;</span>); <span class="comment">-- 不存在, 获取锁，重入次数+1</span></span><br><span class="line">	redis.call(<span class="string">&#x27;expire&#x27;</span>, key, releaseTime); <span class="comment">-- 设置有效期</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>; <span class="comment">-- 返回结果</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; <span class="comment">-- 代码走到这里,说明获取锁的不是自己，获取锁失败</span></span><br></pre></td></tr></table></figure>

<p>释放锁:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> key = KEYS[<span class="number">1</span>]; <span class="comment">-- 锁的key</span></span><br><span class="line"><span class="keyword">local</span> threadId = ARGV[<span class="number">1</span>]; <span class="comment">-- 线程唯一标识</span></span><br><span class="line"><span class="keyword">local</span> releaseTime = ARGV[<span class="number">2</span>]; <span class="comment">-- 锁的自动释放时间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;HEXISTS&#x27;</span>, key, threadId) == <span class="number">0</span>) <span class="keyword">then</span> <span class="comment">-- 判断当前锁是否还是被自己持有</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>; <span class="comment">-- 如果已经不是自己，则直接返回</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">local</span> count = redis.call(<span class="string">&#x27;HINCRBY&#x27;</span>, key, threadId, <span class="number">-1</span>); <span class="comment">-- 是自己的锁，则重入次数-1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (count &gt; <span class="number">0</span>) <span class="keyword">then</span> <span class="comment">-- 判断是否重入次数是否已经为0</span></span><br><span class="line">    redis.call(<span class="string">&#x27;EXPIRE&#x27;</span>, key, releaseTime); <span class="comment">-- 大于0说明不能释放锁，重置有效期然后返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    redis.call(<span class="string">&#x27;DEL&#x27;</span>, key); <span class="comment">-- 等于0说明可以释放锁，直接删除</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>

<p>执行lua脚本</p>
<p>把脚本封装到RedisScript对象中: 需要把脚本内容写到代码中, 作为参数传递, 不够优雅;</p>
<p>自己去创建<code>RedisScript</code>的实现类<code>DefaultRedisScript</code>的对象: 可以把脚本文件写到classpath下的某个位置，然后通过加载这个文件来获取脚本内容，并设置给<code>DefaultRedisScript</code>实例。</p>
<p>定义锁接口:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.demo.lock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 虎哥</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RedisLock</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> releaseTime</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> releaseTime)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>新建一个RedisLock实现: ReentranRedisLock, 利用静态代码块来加载脚本并初始化:</p>
<p>加载脚本:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantRedisLock</span> &#123;</span><br><span class="line">    <span class="comment">// 获取锁的脚本</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultRedisScript&lt;Long&gt; LOCK_SCRIPT;</span><br><span class="line">    <span class="comment">// 释放锁的脚本</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultRedisScript&lt;Object&gt; UNLOCK_SCRIPT;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 加载获取锁的脚本</span></span><br><span class="line">        LOCK_SCRIPT = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">        LOCK_SCRIPT.setScriptSource(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ResourceScriptSource</span>(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;lock.lua&quot;</span>)));</span><br><span class="line">        LOCK_SCRIPT.setResultType(Long.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加载释放锁的脚本</span></span><br><span class="line">        UNLOCK_SCRIPT = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">        UNLOCK_SCRIPT.setScriptSource(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ResourceScriptSource</span>(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;unlock.lua&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 其它代码略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现接口:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.demo.lock;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.ClassPathResource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.script.DefaultRedisScript;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scripting.support.ResourceScriptSource;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantRedisLock</span> <span class="keyword">implements</span> <span class="title class_">RedisLock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设定好锁对应的 key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String key;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存入的线程信息的前缀，防止与其它JVM中线程信息冲突</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ID_PREFIX</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ReentrantRedisLock</span><span class="params">(StringRedisTemplate redisTemplate, String key)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.redisTemplate = redisTemplate;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultRedisScript&lt;Long&gt; LOCK_SCRIPT;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultRedisScript&lt;Object&gt; UNLOCK_SCRIPT;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 加载释放锁的脚本</span></span><br><span class="line">        LOCK_SCRIPT = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">        LOCK_SCRIPT.setScriptSource(<span class="keyword">new</span> <span class="title class_">ResourceScriptSource</span>(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;lock.lua&quot;</span>)));</span><br><span class="line">        LOCK_SCRIPT.setResultType(Long.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加载释放锁的脚本</span></span><br><span class="line">        UNLOCK_SCRIPT = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">        UNLOCK_SCRIPT.setScriptSource(<span class="keyword">new</span> <span class="title class_">ResourceScriptSource</span>(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;unlock.lua&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 锁释放时间</span></span><br><span class="line">    <span class="keyword">private</span> String releaseTime;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> releaseTime)</span> &#123;</span><br><span class="line">        <span class="comment">// 记录释放时间</span></span><br><span class="line">        <span class="built_in">this</span>.releaseTime = String.valueOf(releaseTime);</span><br><span class="line">        <span class="comment">// 执行脚本</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> redisTemplate.execute(</span><br><span class="line">                LOCK_SCRIPT,</span><br><span class="line">                Collections.singletonList(key),</span><br><span class="line">                ID_PREFIX + Thread.currentThread().getId(), <span class="built_in">this</span>.releaseTime);</span><br><span class="line">        <span class="comment">// 判断结果</span></span><br><span class="line">        <span class="keyword">return</span> result != <span class="literal">null</span> &amp;&amp; result.intValue() == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 执行脚本</span></span><br><span class="line">        redisTemplate.execute(</span><br><span class="line">                UNLOCK_SCRIPT,</span><br><span class="line">                Collections.singletonList(key),</span><br><span class="line">                ID_PREFIX + Thread.currentThread().getId(), <span class="built_in">this</span>.releaseTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义锁工厂:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.demo.lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 虎哥</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisLockFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> RedisLock <span class="title function_">getReentrantLock</span><span class="params">(String key)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReentrantRedisLock</span>(redisTemplate, key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h3><h4 id="锁自动续期"><a href="#锁自动续期" class="headerlink" title="锁自动续期"></a>锁自动续期</h4><p>锁如果在执行任务时自动过期，就会引起各种问题， 因此我们需要在锁过期前自动申请续期，这个被称为watch dog，看门狗。</p>
<h4 id="带阻塞的获取锁"><a href="#带阻塞的获取锁" class="headerlink" title="带阻塞的获取锁"></a>带阻塞的获取锁</h4><p>阻塞获取锁, 会在获取失败以后重试, 不过会设置失败超时时间;</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>优点: 实现简单,性能好, 并发能力强,如果对并发能力有要求, 推荐使用</p>
<p>缺点: 可靠性有争议, 极端情况下会出现锁失效问题, 如果对安全要求较高, 不建议使用</p>
<h2 id="Zookeeper实现分布式锁"><a href="#Zookeeper实现分布式锁" class="headerlink" title="Zookeeper实现分布式锁"></a>Zookeeper实现分布式锁</h2><h2 id="基于数据库实现"><a href="#基于数据库实现" class="headerlink" title="基于数据库实现"></a>基于数据库实现</h2><p>准备一张表，记录锁相关信息:<code>tb_lock</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id	method_name</span><br><span class="line">1	createOrder</span><br><span class="line">2	evictOrder</span><br></pre></td></tr></table></figure>



<p>互斥：利用了数据库本身的排它锁来实现。</p>
<p>步骤：</p>
<ul>
<li>获取锁：select * from tb_lock where method_name &#x3D; “evictOrder” for update</li>
<li>执行自己的业务 …</li>
<li>释放锁：commit 提交事务</li>
</ul>
<p>优点：</p>
<ul>
<li>实现简单</li>
<li>锁的自动释放</li>
</ul>
<p>缺点：</p>
<ul>
<li>依赖于数据库，性能是一个问题</li>
<li>单点故障问题</li>
<li>并发一般</li>
</ul>
<h1 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h1><h2 id="什么是分布式事务"><a href="#什么是分布式事务" class="headerlink" title="什么是分布式事务?"></a>什么是分布式事务?</h2><h3 id="本地事务"><a href="#本地事务" class="headerlink" title="本地事务"></a>本地事务</h3><p>事务: 是指传统的单机数据库事务,必须具备ACID原则; 在传统的项目中,项目的部署基本是单点式: 即单个服务器和单个数据库. 这种情况下数据库本身的事务机制就能保证ACID原则,这样的事务就是本地事务. 单个服务和单个数据库的架构中,产生的事务都是本地事务.</p>
<h3 id="分布式事务-1"><a href="#分布式事务-1" class="headerlink" title="分布式事务"></a>分布式事务</h3><p>跨数据源的分布式事务, 跨服务的分布式事务</p>
<h4 id="跨数据源"><a href="#跨数据源" class="headerlink" title="跨数据源"></a>跨数据源</h4><p>对数据库进行了水平拆分,将原单库单表拆分成数据库分片,于是产生了跨数据库事务问题</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212149742.png" alt="image-20210415144156443"></p>
<h4 id="跨服务"><a href="#跨服务" class="headerlink" title="跨服务"></a>跨服务</h4><p>在业务发展初期，“一块大饼”的单业务系统架构，能满足基本的业务需求。但是随着业务的快速发展，系统的访问量和业务复杂程度都在快速增长，单系统架构逐渐成为业务发展瓶颈，解决业务系统的高耦合、可伸缩问题的需求越来越强烈。</p>
<p>如下图所示，按照面向服务（SOA,SOA粗暴理解：把系统按照实际业务，拆分成刚刚好大小的、合适的、独立部署的模块，每个模块之间相互独立。）的架构的设计原则，将单业务系统拆分成多个业务系统，降低了各系统之间的耦合度，使不同的业务系统专注于自身业务，更有利于业务的发展和系统容量的伸缩。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212149743.png" alt="image-20210415144342697"></p>
<h4 id="分布式系统的数据一致性问题"><a href="#分布式系统的数据一致性问题" class="headerlink" title="分布式系统的数据一致性问题"></a>分布式系统的数据一致性问题</h4><p>在数据库水平拆分、服务垂直拆分之后，一个业务操作通常要跨多个数据库、服务才能完成。在分布式网络环境下，我们无法保障所有服务、数据库都百分百可用，一定会出现部分服务、数据库执行成功，另一部分执行失败的问题。</p>
<p>当出现部分业务操作成功、部分业务操作失败时，业务数据就会出现不一致。</p>
<p>例如电商行业中比较常见的下单付款案例，包括下面几个行为：</p>
<ul>
<li>创建新订单</li>
<li>扣减商品库存</li>
<li>从用户账户余额扣除金额</li>
</ul>
<p>完成上面的操作需要访问三个不同的微服务和三个不同的数据库。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212149744.png" alt="image-20200304204442839"></p>
<p>在分布式环境下，肯定会出现部分操作成功、部分操作失败的问题，比如：订单生成了，库存也扣减了，但是 用户账户的余额不足，这就造成数据不一致。</p>
<p>订单的创建、库存的扣减、账户扣款在每一个服务和数据库内是一个本地事务，可以保证ACID原则。</p>
<p>但是当我们把三件事情看做一个事情事，要满足保证“业务”的原子性，要么所有操作全部成功，要么全部失败，不允许出现部分成功部分失败的现象，这就是分布式系统下的事务了。</p>
<p>此时ACID难以满足，这是分布式事务要解决的问题</p>
<h2 id="解决分布式事务的思路"><a href="#解决分布式事务的思路" class="headerlink" title="解决分布式事务的思路"></a>解决分布式事务的思路</h2><h3 id="CAP定理"><a href="#CAP定理" class="headerlink" title="CAP定理"></a>CAP定理</h3><p>Consistency(一致性), Availability(可用性), Partition Tolerance(分区容错性); 这个三个指标不可能同时完成, 这个结论就叫做CAP定理;</p>
<p>舍弃容错性。但是这也就意味着你的系统不是分布式的了，因为涉及分布式的想法就是把功能分开，部署到不同的机器上。</p>
<h3 id="Base理论"><a href="#Base理论" class="headerlink" title="Base理论"></a>Base理论</h3><p>Basically Available(基本可用), Soft state(软状态), Eventually consistent(最终一致性)</p>
<h4 id="基本可用"><a href="#基本可用" class="headerlink" title="基本可用"></a>基本可用</h4><p><strong>响应时间上的损失</strong>：正常情况下的搜索引擎0.5秒即返回给用户结果，而基本可用的搜索引擎可以在2秒作用返回结果。</p>
<p><strong>功能上的损失</strong>：在一个电商网站上，正常情况下，用户可以顺利完成每一笔订单。但是到了大促期间，为了保护购物系统的稳定性，部分消费者可能会被引导到一个降级页面。</p>
<h4 id="软状态"><a href="#软状态" class="headerlink" title="软状态"></a>软状态</h4><p>什么是软状态呢？相对于原子性而言，要求多个节点的数据副本都是一致的，这是一种“硬状态”。</p>
<p>软状态指的是：允许系统中的数据存在中间状态，并认为该状态不影响系统的整体可用性，即允许系统在多个不同节点的数据副本存在数据延时。</p>
<h4 id="最终一致性"><a href="#最终一致性" class="headerlink" title="最终一致性"></a>最终一致性</h4><p>上面说软状态，然后不可能一直是软状态，必须有个时间期限。在期限过后，应当保证所有副本保持数据一致性，从而达到数据的最终一致性。这个时间期限取决于网络延时、系统负载、数据复制方案设计等等因素。</p>
<p>而在实际工程实践中，最终一致性分为5种：</p>
<p>因果一致性（Causal consistency）</p>
<p>因果一致性指的是：如果节点A在更新完某个数据后通知了节点B，那么节点B之后对该数据的访问和修改都是基于A更新后的值。于此同时，和节点A无因果关系的节点C的数据访问则没有这样的限制。</p>
<p>读己之所写（Read your writes）</p>
<p>读己之所写指的是：节点A更新一个数据后，它自身总是能访问到自身更新过的最新值，而不会看到旧值。其实也算一种因果一致性。</p>
<p>会话一致性（Session consistency）</p>
<p>会话一致性将对系统数据的访问过程框定在了一个会话当中：系统能保证在同一个有效的会话中实现 “读己之所写” 的一致性，也就是说，执行更新操作之后，客户端能够在同一个会话中始终读取到该数据项的最新值。</p>
<p>单调读一致性（Monotonic read consistency）</p>
<p>单调读一致性指的是：如果一个节点从系统中读取出一个数据项的某个值后，那么系统对于该节点后续的任何数据访问都不应该返回更旧的值。</p>
<p>单调写一致性（Monotonic write consistency）</p>
<p>单调写一致性指的是：一个系统要能够保证来自同一个节点的写操作被顺序的执行。</p>
<p>在实际的实践中，这5种系统往往会结合使用，以构建一个具有最终一致性的分布式系统。</p>
<p>实际上，不只是分布式系统使用最终一致性，关系型数据库在某个功能上，也是使用最终一致性的。比如备份，数据库的复制过程是需要时间的，这个复制过程中，业务读取到的值就是旧的。当然，最终还是达成了数据一致性。这也算是一个最终一致性的经典案例。</p>
<p>小结</p>
<p>总体来说BASE理论面向的是大型高可用、可扩展的分布式系统。与传统ACID特性相反，不同于ACID的强一致性模型，BASE提出通过牺牲强一致性来获得可用性，并允许数据段时间内的不一致，但是最终达到一致状态。同时，在实际分布式场景中，不同业务对数据的一致性要求不一样。因此在设计中，ACID和BASE理论往往又会结合使用。</p>
<p>而我们解决分布式事务，就是根据Base理论和CAP理论来实现。</p>
<p>还以上面的下单减库存和扣款为例：</p>
<p>订单服务、库存服务、用户服务及他们对应的数据库就是分布式应用中的三个部分。</p>
<ul>
<li><p>CP方式：现在如果要满足事务的强一致性，就必须在订单服务数据库锁定的同时，对库存服务、用户服务数据资源同时锁定。等待三个服务业务全部处理完成，才可以释放资源。此时如果有其他请求想要操作被锁定的资源就会被阻塞，这样就是满足了CP。</p>
<p>这就是强一致，弱可用</p>
</li>
<li><p>AP方式：三个服务的对应数据库各自独立执行自己的业务，执行本地事务，不要求互相锁定资源。但是这个中间状态下，我们去访问数据库，可能遇到数据不一致的情况，不过我们需要做一些后补措施，保证在经过一段时间后，数据最终满足一致性。</p>
<p>这就是高可用，但弱一致（最终一致）。</p>
</li>
</ul>
<p>由上面的两种思想，延伸出了很多的分布式事务解决方案：</p>
<ul>
<li>XA</li>
<li>TCC</li>
<li>可靠消息最终一致</li>
<li>TA</li>
</ul>
<p>不过，要想搞懂这些原理，你必须知道数据库本地事务是如何实现的，也就是undo和redo日志的故事。</p>
<h3 id="undo和redo"><a href="#undo和redo" class="headerlink" title="undo和redo"></a>undo和redo</h3><p>在数据库系统中，既有存放数据的文件，也有存放日志的文件。日志在内存中也是有缓存Log buffer，也有磁盘文件log file。MySQL中的日志文件，有这么两类与事务有关：undo日志与redo日志。</p>
<h4 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h4><p>持久性和原子性可以利用undo log来实现</p>
<p>原理: 为了满足事务的原子性,在操作任何数据之前,首先将数据备份到undo log. 然后进行数据的修改. 如果出现了错误或者用户执行了ROLLBACK语句,系统可以利用Undo log 中的备份数据将数据恢复到事务开始之前的状态.</p>
<p>数据库写入数据到磁盘之前, 会把数据先缓存在内存中,事务提交时才会写入磁盘中.</p>
<p>用undo log 实现原子性和持久性的事务的简化过程: </p>
<p>假设有A、B两个数据,值分别为1,2</p>
<p> A. 事务开始.<br> B. 记录A&#x3D;1到undo log buffer.<br> C. 修改A&#x3D;3.<br> D. 记录B&#x3D;2到undo log buffer.<br> E. 修改B&#x3D;4.<br> F. 将undo log buffer写到磁盘。<br> G. 将数据写到磁盘。<br> H. 事务提交</p>
<ul>
<li><p>如何保证原子性？</p>
<p>在修改数据到磁盘前，会先记录undo log，并将undo log持久化到硬盘</p>
</li>
<li><p>如何保证持久性？</p>
<p>在事务提交之前，把内存中缓存的数据写入磁盘。这样事务提交时，可以确定数据是已经持久化的，不会丢失。</p>
</li>
<li><p>若系统在G和H之间崩溃</p>
<p>此时事务并未提交，需要回滚。而undo log已经被持久化，可以根据undo log来恢复数据</p>
</li>
<li><p>若系统在G之前崩溃</p>
<p>此时数据并未持久化到硬盘，依然保持在事务之前的状态</p>
</li>
</ul>
<p><strong>缺陷：</strong>每个事务提交前将数据和Undo Log写入磁盘，这样会导致大量的磁盘IO，因此性能很低。</p>
<p>如果能够将数据缓存一段时间，就能减少IO提高性能。但是这样就会丧失事务的持久性。因此引入了另外一种机制来实现持久化，即<strong>Redo Log</strong>.</p>
<h4 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h4><p>和Undo Log相反，Redo Log记录的是<strong>新数据</strong>的备份。<strong>在事务提交前，只要将Redo Log持久化即可，不需要将数据持久化，减少了IO的次数。</strong></p>
<p>先来看下基本原理：</p>
<blockquote>
<p><strong>Undo + Redo事务的简化过程</strong></p>
</blockquote>
<p> 假设有A、B两个数据，值分别为1,2</p>
<p> A. 事务开始.<br> B. 记录A&#x3D;1到undo log.<br> C. 修改A&#x3D;3.<br> D. 记录A&#x3D;3到redo log.<br> E. 记录B&#x3D;2到undo log.<br> F. 修改B&#x3D;4.<br> G. 记录B&#x3D;4到redo log.<br> H. 将undo log写入redo log<br> I. 将redo log写入磁盘<br> J. 事务提交</p>
<blockquote>
<p>安全和性能问题</p>
</blockquote>
<ul>
<li><p>如何保证原子性？</p>
<p>如果在事务提交前故障，通过undo log日志恢复数据。如果undo log都还没写入，那么数据就尚未持久化，无需回滚</p>
</li>
<li><p>如何保证持久化？</p>
<p>大家会发现，这里并没有出现数据的持久化。因为数据已经写入redo log，而redo log持久化到了硬盘，因此只要到了I以后，事务是可以提交的。</p>
</li>
<li><p>内存中的数据库数据何时持久化到磁盘？</p>
<p>因为redo log已经持久化，因此数据库数据写入磁盘与否影响不大，不过为了避免出现脏数据（内存中与磁盘不一致），事务提交后也会将内存数据刷入磁盘（也可以按照固设定的频率刷新内存数据到磁盘中）。</p>
</li>
<li><p>持久化redo和持久化数据库数据有什么性能差异？</p>
<ul>
<li><p>数据库数据写入是随机IO，性能很差</p>
</li>
<li><p>redo log在初始化时会开辟一段连续的空间，写入是顺序IO，性能很好</p>
</li>
</ul>
</li>
<li><p>redo log中记录的数据，有可能尚未提交，那么如何完成数据恢复？</p>
<p>数据恢复有两种策略：</p>
<ul>
<li>恢复时，只重做已经提交了的事务</li>
<li>恢复时，重做所有事务包括未提交的事务和回滚了的事务。然后通过Undo Log回滚那些未提交的事务</li>
</ul>
<p>Inodb引擎采用的是第二种方案，因此undo log要在 redo log前持久化</p>
</li>
<li><p>写入性能的优化</p>
<p>事务提交前需要同时写入undo log和 redo log，势必增加IO次数，因此实际上undo log并不是直接写入磁盘，而是先写入到redo log中，当redo log持久化时，undo log就同时持久化到硬盘了。</p>
<p>因此事务提交前，只需要对redo log持久化即可。</p>
<p>另外，redo log并不是写入一次就持久化一次，redo log在内存中也有自己的缓冲池：<code>redo log buffer</code>。每次写redo log都是写入到buffer，在提交时一次性持久化到磁盘，减少IO此时。</p>
</li>
</ul>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>最后总结一下：</p>
<ul>
<li>undo log 记录更新前数据，用于保证事务原子性</li>
<li>redo log 记录更新后数据，用于保证事务的持久性</li>
<li>redo log有自己的内存buffer，先写入到buffer，事务提交时写入磁盘</li>
<li>redo log持久化之后，意味着事务是<strong>可提交</strong>的</li>
</ul>
<h3 id="分阶段提交"><a href="#分阶段提交" class="headerlink" title="分阶段提交"></a>分阶段提交</h3><h4 id="DTP和XA"><a href="#DTP和XA" class="headerlink" title="DTP和XA"></a>DTP和XA</h4><p>分布式事务的解决手段之一，就是两阶段提交协议（2PC：Two-Phase Commit）</p>
<p>那么到底什么是两阶段提交协议呢？</p>
<p>1994 年，X&#x2F;Open 组织（即现在的 Open Group ）定义了分布式事务处理的DTP 模型。该模型包括这样几个角色：</p>
<ul>
<li>应用程序（ AP,Application ）：我们的微服务</li>
<li>事务管理器（ TM, Transction Manager）：全局事务管理者</li>
<li>资源管理器（ RM, Resource Manager ）：一般是数据库</li>
<li>通信资源管理器（ CRM, Communication Resource Manager）：是TM和RM间的通信中间件</li>
</ul>
<p>在该模型中，一个分布式事务（全局事务）可以被拆分成许多个本地事务，运行在不同的AP和RM上。每个本地事务的ACID很好实现，但是全局事务必须保证其中包含的每一个本地事务都能同时成功，若有一个本地事务失败，则所有其它事务都必须回滚。但问题是，本地事务处理过程中，并不知道其它事务的运行状态。因此，就需要通过CRM来通知各个本地事务，同步事务执行的状态。</p>
<p>因此，各个本地事务的通信必须有统一的标准，否则不同数据库间就无法通信。<strong>XA</strong>就是 X&#x2F;Open DTP中通信中间件与TM间联系的<strong>接口规范</strong>，定义了用于通知事务开始、提交、终止、回滚等接口，各个数据库厂商都必须实现这些接口。</p>
<h4 id="二阶段提交"><a href="#二阶段提交" class="headerlink" title="二阶段提交"></a>二阶段提交</h4><p>2PC：Two-Phase(feis) Commit）</p>
<p>参考：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/35298019">漫话分布式系统共识协议: 2PC&#x2F;3PC篇</a></p>
<p><strong>二阶提交协议</strong>就是根据这一思想衍生出来的，将全局事务拆分为两个阶段来执行：</p>
<ul>
<li>阶段一：准备阶段，各个本地事务完成本地事务的准备工作。</li>
<li>阶段二：执行阶段，各个本地事务根据上一阶段执行结果，进行提交或回滚。</li>
</ul>
<p>这个过程中需要一个协调者（coordinator），还有事务的参与者（voter）。</p>
<blockquote>
<p>1）正常情况</p>
</blockquote>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212149745.png" alt="image-20200305141029973"> </p>
<p><strong>投票阶段</strong>：协调组询问各个事务参与者，是否可以执行事务。每个事务参与者执行事务，写入redo和undo日志，然后反馈事务执行成功的信息（<code>agree</code>）</p>
<p><strong>提交阶段</strong>：协调组发现每个参与者都可以执行事务（<code>agree</code>），于是向各个事务参与者发出<code>commit</code>指令，各个事务参与者提交事务。</p>
<blockquote>
<p>2）异常情况</p>
</blockquote>
<p>当然，也有异常的时候：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212149746.png" alt="image-20200305141318326"> </p>
<p><strong>投票阶段</strong>：协调组询问各个事务参与者，是否可以执行事务。每个事务参与者执行事务，写入redo和undo日志，然后反馈事务执行结果，但只要有一个参与者返回的是<code>Disagree</code>，则说明执行失败。</p>
<p><strong>提交阶段</strong>：协调组发现有一个或多个参与者返回的是<code>Disagree</code>，认为执行失败。于是向各个事务参与者发出<code>abort</code>指令，各个事务参与者回滚事务。</p>
<blockquote>
<p>3）缺陷</p>
</blockquote>
<p>二阶段提交的问题：</p>
<ul>
<li><p>单点故障问题</p>
<p>2PC的缺点在于不能处理fail-stop形式的节点failure. 比如下图这种情况.</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212149747.png" alt="image-20200305142812815"> </p>
<p>假设coordinator和voter3都在Commit这个阶段crash了, 而voter1和voter2没有收到commit消息. 这时候voter1和voter2就陷入了一个困境. 因为他们并不能判断现在是两个场景中的哪一种:</p>
<p> (1)上轮全票通过然后voter3第一个收到了commit的消息并在commit操作之后crash了</p>
<p> (2)上轮voter3反对所以干脆没有通过.</p>
</li>
<li><p>阻塞问题</p>
<p>在准备阶段、提交阶段，每个事物参与者都会锁定本地资源，并等待其它事务的执行结果，阻塞时间较长，资源锁定时间太久，因此执行的效率就比较低了。</p>
</li>
</ul>
<p>面对二阶段提交的上述缺点，后来又演变出了三阶段提交，但是依然没有完全解决阻塞和资源锁定的问题，而且引入了一些新的问题，因此实际使用的场景较少。对事务有强一致性要求,对事务的执行效率不敏感,并且不希望有太多的代码侵入.</p>
<h3 id="TCC"><a href="#TCC" class="headerlink" title="TCC"></a>TCC</h3><p>Try-confirm-cancel</p>
<p>TCC模式可以解决2PC中的资源锁定和阻塞问题，减少资源锁定时间。它采用的是一种补偿型事务的思想。</p>
<h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><p>它本质是一种补偿的思路。事务运行过程包括三个方法，</p>
<ul>
<li>Try：资源的检测和预留；</li>
<li>Confirm：执行的业务操作提交；要求 Try 成功 Confirm 一定要能成功；</li>
<li>Cancel：预留资源释放。</li>
</ul>
<p>执行分两个阶段：</p>
<ul>
<li>准备阶段（try）：资源的检测和预留；</li>
<li>执行阶段（confirm&#x2F;cancel）：根据上一步结果，判断下面的执行方法。如果上一步中所有事务参与者都成功，则这里执行confirm。反之，执行cancel</li>
</ul>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212149748.png" alt="image-20200305155521612"> </p>
<p>粗看似乎与两阶段提交没什么区别，但其实差别很大：</p>
<ul>
<li>try、confirm、cancel都是独立的事务，不受其它参与者的影响，不会阻塞等待它人</li>
<li>try、confirm、cancel由程序员在业务层编写，锁粒度有代码控制</li>
</ul>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>我们以之前的下单业务中的扣减余额为例来看下三个不同的方法要怎么编写，假设账户A原来余额是100，需要余额扣减30元。如图：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212149749.png" alt="image-20200305155830732"></p>
<ul>
<li><p>一阶段（Try）：余额检查，并冻结用户部分金额，此阶段执行完毕，事务已经提交</p>
<ul>
<li>检查用户余额是否充足，如果充足，冻结部分余额</li>
<li>在账户表中添加冻结金额字段，值为30，余额不变</li>
</ul>
</li>
<li><p>二阶段</p>
<ul>
<li>提交（Confirm）：真正的扣款，把冻结金额从余额中扣除，冻结金额清空<ul>
<li>修改冻结金额为0，修改余额为100-30 &#x3D; 70元</li>
</ul>
</li>
<li>补偿（Cancel）：释放之前冻结的金额，并非回滚<ul>
<li>余额不变，修改账户冻结金额为0</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="优势和缺点"><a href="#优势和缺点" class="headerlink" title="优势和缺点"></a>优势和缺点</h4><ul>
<li><p>优势</p>
<p>TCC执行的每一个阶段都会提交本地事务并释放锁，并不需要等待其它事务的执行结果。而如果其它事务执行失败，最后不是回滚，而是执行补偿操作。这样就避免了资源的长期锁定和阻塞等待，执行效率比较高，属于性能最好的分布式事务方式。</p>
</li>
<li><p>缺点</p>
<ul>
<li>代码侵入：需要人为编写代码实现，代码侵入较多</li>
<li>开发成本高：一个业务需要拆分成3个步骤，分别编写业务实现，业务编写比较复杂</li>
<li>安全性考虑：cancel动作如果执行失败，资源就无法释放，需要引入重试机制，而重试可能导致重复执行，还要考虑重试时的幂等问题</li>
</ul>
</li>
</ul>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>对事务有一定的一致性要求(最终一致); 对性能要求较高; 开发人员需要具备较高的编码能力和幂等处理经验;</p>
<h3 id="可靠消息服务"><a href="#可靠消息服务" class="headerlink" title="可靠消息服务"></a>可靠消息服务</h3><p>这种实现方式的思路，其实是源于ebay，其基本的设计思想是将远程分布式事务拆分成一系列的本地事务。</p>
<h4 id="基本原理-1"><a href="#基本原理-1" class="headerlink" title="基本原理"></a>基本原理</h4><p>一般分为事务的发起者A和事务的其它参与者B：</p>
<ul>
<li>事务发起者A执行本地事务</li>
<li>事务发起者A通过MQ将需要执行的事务信息发送给事务参与者B</li>
<li>事务参与者B接收到消息后执行本地事务</li>
</ul>
<p>如图：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212149750.png" alt="image-20200305181454125"></p>
<p>这个过程有点像你去学校食堂吃饭：</p>
<ul>
<li>拿着钱去收银处，点一份红烧牛肉面，付钱</li>
<li>收银处给你发一个小票，还有一个号牌，你别把票弄丢！</li>
<li>你凭小票和号牌一定能领到一份红烧牛肉面，不管需要多久</li>
</ul>
<p>几个注意事项：</p>
<ul>
<li>事务发起者A必须确保本地事务成功后，消息一定发送成功</li>
<li>MQ必须保证消息正确投递和持久化保存</li>
<li>事务参与者B必须确保消息最终一定能消费，如果失败需要多次重试</li>
<li>事务B执行失败，会重试，但不会导致事务A回滚</li>
</ul>
<p>那么问题来了，我们如何保证消息发送一定成功？如何保证消费者一定能收到消息？</p>
<h4 id="本地消息表"><a href="#本地消息表" class="headerlink" title="本地消息表"></a>本地消息表</h4><p>为了避免消息发送失败或丢失，我们可以把消息持久化到数据库中。实现时有简化版本和解耦合版本两种方式。</p>
<h5 id="简化版本"><a href="#简化版本" class="headerlink" title="简化版本"></a>简化版本</h5><p>原理图：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212149751.png" alt="image-20200305183431211"> </p>
<ul>
<li><p>事务发起者：</p>
<ul>
<li>开启本地事务</li>
<li>执行事务相关业务</li>
<li>发送消息到MQ</li>
<li>把消息持久化到数据库，标记为已发送</li>
<li>提交本地事务</li>
</ul>
</li>
<li><p>事务接收者：</p>
<ul>
<li>接收消息</li>
<li>开启本地事务</li>
<li>处理事务相关业务</li>
<li>修改数据库消息状态为已消费</li>
<li>提交本地事务</li>
</ul>
</li>
<li><p>额外的定时任务</p>
<ul>
<li>定时扫描表中超时未消费消息，重新发送</li>
</ul>
</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li>与tcc相比，实现方式较为简单，开发成本低。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><p>数据一致性完全依赖于消息服务，因此消息服务必须是可靠的。</p>
</li>
<li><p>需要处理被动业务方的幂等问题</p>
</li>
<li><p>被动业务失败不会导致主动业务的回滚，而是重试被动的业务</p>
</li>
<li><p><strong>事务业务与消息发送业务耦合</strong>、业务数据与消息表要在一起</p>
</li>
</ul>
<h5 id="独立消息服务"><a href="#独立消息服务" class="headerlink" title="独立消息服务"></a>独立消息服务</h5><p>为了解决上述问题，我们会引入一个独立的消息服务，来完成对消息的持久化、发送、确认、失败重试等一系列行为，大概的模型如下：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212149752.png" alt="image-20200305200131083"></p>
<p>一次消息发送的时序图：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212149753.png" alt="image-20200305205430863"></p>
<p>事务发起者A的基本执行步骤：</p>
<ul>
<li>开启本地事务</li>
<li>通知消息服务，准备发送消息（消息服务将消息持久化，标记为准备发送）</li>
<li>执行本地业务，<ul>
<li>执行失败则终止，通知消息服务，取消发送（消息服务修改订单状态）</li>
<li>执行成功则继续，通知消息服务，确认发送（消息服务发送消息、修改订单状态）</li>
</ul>
</li>
<li>提交本地事务</li>
</ul>
<p>消息服务本身提供下面的接口：</p>
<ul>
<li>准备发送：把消息持久化到数据库，并标记状态为准备发送</li>
<li>取消发送：把数据库消息状态修改为取消</li>
<li>确认发送：把数据库消息状态修改为确认发送。尝试发送消息，成功后修改状态为已发送</li>
<li>确认消费：消费者已经接收并处理消息，把数据库消息状态修改为已消费</li>
<li>定时任务：定时扫描数据库中状态为确认发送的消息，然后询问对应的事务发起者，事务业务执行是否成功，结果：<ul>
<li>业务执行成功：尝试发送消息，成功后修改状态为已发送</li>
<li>业务执行失败：把数据库消息状态修改为取消</li>
</ul>
</li>
</ul>
<p>事务参与者B的基本步骤：</p>
<ul>
<li>接收消息</li>
<li>开启本地事务</li>
<li>执行业务</li>
<li>通知消息服务，消息已经接收和处理</li>
<li>提交事务</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li>解除了事务业务与消息相关业务的耦合</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>实现起来比较复杂</li>
</ul>
<h4 id="RocketMQ事务消息"><a href="#RocketMQ事务消息" class="headerlink" title="RocketMQ事务消息"></a>RocketMQ事务消息</h4><p>RocketMQ本身自带了事务消息，可以保证消息的可靠性，原理其实就是自带了本地消息表，与我们上面讲的思路类似。</p>
<h4 id="RabbitMQ的消息确认"><a href="#RabbitMQ的消息确认" class="headerlink" title="RabbitMQ的消息确认"></a>RabbitMQ的消息确认</h4><p>RabbitMQ确保消息不丢失的思路比较奇特，并没有使用传统的本地表，而是利用了消息的确认机制：</p>
<ul>
<li>生产者确认机制：确保消息从生产者到达MQ不会有问题<ul>
<li>消息生产者发送消息到RabbitMQ时，可以设置一个异步的监听器，监听来自MQ的ACK</li>
<li>MQ接收到消息后，会返回一个回执给生产者：<ul>
<li>消息到达交换机后路由失败，会返回失败ACK</li>
<li>消息路由成功，持久化失败，会返回失败ACK</li>
<li>消息路由成功，持久化成功，会返回成功ACK</li>
</ul>
</li>
<li>生产者提前编写好不同回执的处理方式<ul>
<li>失败回执：等待一定时间后重新发送</li>
<li>成功回执：记录日志等行为</li>
</ul>
</li>
</ul>
</li>
<li>消费者确认机制：确保消息能够被消费者正确消费<ul>
<li>消费者需要在监听队列的时候指定手动ACK模式</li>
<li>RabbitMQ把消息投递给消费者后，会等待消费者ACK，接收到ACK后才删除消息，如果没有接收到ACK消息会一直保留在服务端，如果消费者断开连接或异常后，消息会投递给其它消费者。</li>
<li>消费者处理完消息，提交事务后，手动ACK。如果执行过程中抛出异常，则不会ACK，业务处理失败，等待下一条消息</li>
</ul>
</li>
</ul>
<p>经过上面的两种确认机制，可以确保从消息生产者到消费者的消息安全，再结合生产者和消费者两端的本地事务，即可保证一个分布式事务的最终一致性。</p>
<h4 id="消息事务的优缺点"><a href="#消息事务的优缺点" class="headerlink" title="消息事务的优缺点"></a>消息事务的优缺点</h4><p>总结上面的几种模型，消息事务的优缺点如下：</p>
<ul>
<li>优点：<ul>
<li>相对TCC，代码侵入较少</li>
<li>业务相对简单</li>
<li>是多个本地事务的结合，因此资源锁定周期短，性能好</li>
</ul>
</li>
<li>缺点：<ul>
<li>依赖于MQ的可靠性</li>
<li>消息发起者可以回滚，但是消息参与者无法引起事务回滚</li>
<li>事务时效性差，取决于MQ消息发送是否及时，还有消息参与者的执行情况</li>
</ul>
</li>
</ul>
<p>针对事务无法回滚的问题，有人提出说可以再事务参与者执行失败后，再次利用MQ通知消息服务，然后由消息服务通知其他参与者回滚。那么，恭喜你，你利用MQ和自定义的消息服务再次实现了2PC 模型，又造了一个大轮子</p>
<h3 id="AT模式"><a href="#AT模式" class="headerlink" title="AT模式"></a>AT模式</h3><p>2019年 1 月份，Seata 开源了 AT 模式。AT 模式是一种<strong>无侵入</strong>的分布式事务解决方案。可以看做是对TCC模型的一种优化，解决了TCC模式中的代码侵入、编码复杂等问题。</p>
<p>在 AT 模式下，用户只需关注自己的“业务 SQL”，用户的 “业务 SQL” 作为一阶段，Seata 框架会自动生成事务的二阶段提交和回滚操作。</p>
<p>可以参考Seata的<a target="_blank" rel="noopener" href="https://seata.io/zh-cn/docs/dev/mode/at-mode.html">官方文档</a>。</p>
<h4 id="基本原理-2"><a href="#基本原理-2" class="headerlink" title="基本原理"></a>基本原理</h4><p>先来看一张流程图：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212149754.png" alt="image-20200305212340203"></p>
<p>有没有感觉跟TCC的执行很像，都是分两个阶段：</p>
<ul>
<li>一阶段：执行本地事务，并返回执行结果</li>
<li>二阶段：根据一阶段的结果，判断二阶段做法：提交或回滚</li>
</ul>
<p>但AT模式底层做的事情可完全不同，而且第二阶段根本不需要我们编写，全部有Seata自己实现了。也就是说：我们写的<strong>代码与本地事务时代码一样</strong>，无需手动处理分布式事务。</p>
<p>那么，AT模式如何实现无代码侵入，如何帮我们自动实现二阶段代码的呢？</p>
<blockquote>
<p>一阶段</p>
</blockquote>
<p>在一阶段，Seata 会拦截“业务 SQL”，首先解析 SQL 语义，找到“<code>业务 SQL</code>”要更新的业务数据，在业务数据被更新前，将其保存成“<code>before image</code>”，然后执行“<code>业务 SQL</code>”更新业务数据，在业务数据更新之后，再将其保存成“<code>after image</code>”，最后获取全局行锁，<strong>提交事务</strong>。以上操作全部在一个数据库事务内完成，这样保证了一阶段操作的原子性。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212149755.png" alt="image-20200305213652558"></p>
<blockquote>
<p>二阶段提交</p>
</blockquote>
<p>二阶段如果是提交的话，因为“<code>业务 SQL</code>”在一阶段已经提交至数据库， 所以 Seata 框架只需将一阶段保存的快照数据和行锁删掉，完成数据清理即可。</p>
<blockquote>
<p>二阶段回滚：</p>
</blockquote>
<p>二阶段如果是回滚的话，Seata 就需要回滚一阶段已经执行的“<code>业务 SQL</code>”，还原业务数据。回滚方式便是用“<code>before image</code>”还原业务数据；但在还原前要首先要校验脏写，对比“数据库当前业务数据”和 “<code>after image</code>”，如果两份数据完全一致就说明没有脏写，可以还原业务数据，如果不一致就说明有<code>脏写</code>，出现脏写就需要转人工处理。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212149756.png" alt="image-20200305214649845"></p>
<p>不过因为有全局锁机制，所以可以降低出现<code>脏写</code>的概率。</p>
<p>AT 模式的一阶段、二阶段提交和回滚均由 Seata 框架自动生成，用户只需编写“业务 SQL”，便能轻松接入分布式事务，AT 模式是一种对业务无任何侵入的分布式事务解决方案。</p>
<h4 id="详细架构和流程"><a href="#详细架构和流程" class="headerlink" title="详细架构和流程"></a>详细架构和流程</h4><p>Seata中的几个基本概念：</p>
<ul>
<li><p>TC（Transaction Coordinator） - 事务协调者</p>
<p>维护全局和分支事务的状态，驱动全局事务提交或回滚（TM之间的协调者）。</p>
</li>
<li><p>TM（Transaction Manager） - 事务管理器</p>
<p>定义全局事务的范围：开始全局事务、提交或回滚全局事务。</p>
</li>
<li><p>RM（Resource Manager） - 资源管理器</p>
<p>管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。</p>
</li>
</ul>
<p>我们看下面的一个架构图</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212149757.png" alt="image-20200305225811888"></p>
<ul>
<li>TM：业务模块中全局事务的开启者<ul>
<li>向TC开启一个全局事务</li>
<li>调用其它微服务</li>
</ul>
</li>
<li>RM：业务模块执行者中，包含RM部分，负责向TC汇报事务执行状态<ul>
<li>执行本地事务</li>
<li>向TC注册分支事务，并提交本地事务执行结果</li>
</ul>
</li>
<li>TM：结束对微服务的调用，通知TC，全局事务执行完毕，事务一阶段结束</li>
<li>TC：汇总各个分支事务执行结果，决定分布式事务是提交还是回滚；</li>
<li>TC 通知所有 RM 提交&#x2F;回滚 资源，事务二阶段结束。</li>
</ul>
<p>一阶段：</p>
<ul>
<li>TM开启全局事务，并向TC声明全局事务，包括全局事务XID信息</li>
<li>TM所在服务调用其它微服务</li>
<li>微服务，主要有RM来执行<ul>
<li>查询<code>before_image</code></li>
<li>执行本地事务</li>
<li>查询<code>after_image</code></li>
<li>生成<code>undo_log</code>并写入数据库</li>
<li>向TC注册分支事务，告知事务执行结果</li>
<li>获取全局锁（阻止其它全局事务并发修改当前数据）</li>
<li>释放本地锁（不影响其它业务对数据的操作）</li>
</ul>
</li>
<li>待所有业务执行完毕，事务发起者（TM）会尝试向TC提交全局事务</li>
</ul>
<p>二阶段：</p>
<ul>
<li>TC统计分支事务执行情况，根据结果判断下一步行为<ul>
<li>分支都成功：通知分支事务，提交事务</li>
<li>有分支执行失败：通知执行成功的分支事务，回滚数据</li>
</ul>
</li>
<li>分支事务的RM<ul>
<li>提交事务：直接清空<code>before_image</code>和<code>after_image</code>信息，释放全局锁</li>
<li>回滚事务：<ul>
<li>校验after_image，判断是否有脏写</li>
<li>如果没有脏写，回滚数据到<code>before_image</code>，清除<code>before_image</code>和<code>after_image</code></li>
<li>如果有脏写，请求人工介入</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h4><p>详见Seata的官方文档：<a target="_blank" rel="noopener" href="https://seata.io/zh-cn/docs/overview/what-is-seata.html">https://seata.io/zh-cn/docs/overview/what-is-seata.html</a></p>
<blockquote>
<h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4></blockquote>
<p>以一个示例来说明整个 AT 分支的工作过程。</p>
<p>业务表：<code>product</code></p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Key</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>bigint(20)</td>
<td>PRI</td>
</tr>
<tr>
<td>name</td>
<td>varchar(100)</td>
<td></td>
</tr>
<tr>
<td>since</td>
<td>varchar(100)</td>
<td></td>
</tr>
</tbody></table>
<p>AT 分支事务的业务逻辑：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> product <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;GTS&#x27;</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;TXC&#x27;</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<h4 id="一阶段"><a href="#一阶段" class="headerlink" title="一阶段"></a>一阶段</h4></blockquote>
<p>过程：</p>
<ol>
<li>解析 SQL：得到 SQL 的类型（UPDATE），表（product），条件（where name &#x3D; ‘TXC’）等相关的信息。</li>
<li>查询前镜像：根据解析得到的条件信息，生成查询语句，定位数据。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id, name, since <span class="keyword">from</span> product <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;TXC&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>得到前镜像：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>since</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>TXC</td>
<td>2014</td>
</tr>
</tbody></table>
<ol>
<li>执行业务 SQL：更新这条记录的 name 为 ‘GTS’。</li>
<li>查询后镜像：根据前镜像的结果，通过 <strong>主键</strong> 定位数据。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id, name, since <span class="keyword">from</span> product <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>`;</span><br></pre></td></tr></table></figure>

<p>得到后镜像：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>since</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>GTS</td>
<td>2014</td>
</tr>
</tbody></table>
<ol>
<li>插入回滚日志：把前后镜像数据以及业务 SQL 相关的信息组成一条回滚日志记录，插入到 <code>UNDO_LOG</code> 表中。</li>
</ol>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">	<span class="attr">&quot;branchId&quot;</span><span class="punctuation">:</span> <span class="number">641789253</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;undoItems&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">&quot;afterImage&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">			<span class="attr">&quot;rows&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">				<span class="attr">&quot;fields&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">					<span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;id&quot;</span><span class="punctuation">,</span></span><br><span class="line">					<span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">,</span></span><br><span class="line">					<span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line">				<span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="punctuation">&#123;</span></span><br><span class="line">					<span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;name&quot;</span><span class="punctuation">,</span></span><br><span class="line">					<span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="number">12</span><span class="punctuation">,</span></span><br><span class="line">					<span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;GTS&quot;</span></span><br><span class="line">				<span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="punctuation">&#123;</span></span><br><span class="line">					<span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;since&quot;</span><span class="punctuation">,</span></span><br><span class="line">					<span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="number">12</span><span class="punctuation">,</span></span><br><span class="line">					<span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2014&quot;</span></span><br><span class="line">				<span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br><span class="line">			<span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;tableName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;product&quot;</span></span><br><span class="line">		<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;beforeImage&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">			<span class="attr">&quot;rows&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">				<span class="attr">&quot;fields&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">					<span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;id&quot;</span><span class="punctuation">,</span></span><br><span class="line">					<span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">,</span></span><br><span class="line">					<span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line">				<span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="punctuation">&#123;</span></span><br><span class="line">					<span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;name&quot;</span><span class="punctuation">,</span></span><br><span class="line">					<span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="number">12</span><span class="punctuation">,</span></span><br><span class="line">					<span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;TXC&quot;</span></span><br><span class="line">				<span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="punctuation">&#123;</span></span><br><span class="line">					<span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;since&quot;</span><span class="punctuation">,</span></span><br><span class="line">					<span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="number">12</span><span class="punctuation">,</span></span><br><span class="line">					<span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2014&quot;</span></span><br><span class="line">				<span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br><span class="line">			<span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;tableName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;product&quot;</span></span><br><span class="line">		<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;sqlType&quot;</span><span class="punctuation">:</span> <span class="string">&quot;UPDATE&quot;</span></span><br><span class="line">	<span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;xid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;xid:xxx&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>提交前，向 TC 注册分支：申请 <code>product</code> 表中，主键值等于 1 的记录的 <strong>全局锁</strong> 。</li>
<li>本地事务提交：业务数据的更新和前面步骤中生成的 UNDO LOG 一并提交。</li>
<li>将本地事务提交的结果上报给 TC。</li>
</ol>
<blockquote>
<h4 id="二阶段-回滚"><a href="#二阶段-回滚" class="headerlink" title="二阶段-回滚"></a>二阶段-回滚</h4></blockquote>
<ol>
<li>收到 TC 的分支回滚请求，开启一个本地事务，执行如下操作。</li>
<li>通过 XID 和 Branch ID 查找到相应的 UNDO LOG 记录。</li>
<li>数据校验：拿 UNDO LOG 中的后镜与当前数据进行比较，如果有不同，说明数据被当前全局事务之外的动作做了修改。这种情况，需要根据配置策略来做处理，详细的说明在另外的文档中介绍。</li>
<li>根据 UNDO LOG 中的前镜像和业务 SQL 的相关信息生成并执行回滚的语句：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> product <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;TXC&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<ol>
<li>提交本地事务。并把本地事务的执行结果（即分支事务回滚的结果）上报给 TC。</li>
</ol>
<blockquote>
<h4 id="二阶段-提交"><a href="#二阶段-提交" class="headerlink" title="二阶段-提交"></a>二阶段-提交</h4></blockquote>
<ol>
<li>收到 TC 的分支提交请求，把请求放入一个异步任务的队列中，马上返回提交成功的结果给 TC。</li>
<li>异步任务阶段的分支提交请求将异步和批量地删除相应 UNDO LOG 记录。</li>
</ol>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>优点：</p>
<ul>
<li>与2PC相比：每个分支事务都是独立提交，不互相等待，减少了资源锁定和阻塞时间</li>
<li>与TCC相比：二阶段的执行操作全部自动化生成，无代码侵入，开发成本低</li>
</ul>
<p>缺点：</p>
<ul>
<li>与TCC相比，需要动态生成二阶段的反向补偿操作，执行性能略低于TCC</li>
</ul>
<h3 id="Saga模式"><a href="#Saga模式" class="headerlink" title="Saga模式"></a>Saga模式</h3><p>Saga [ˈsɑːɡə]模式是 Seata 即将开源的长事务解决方案，将由蚂蚁金服主要贡献。</p>
<p>其理论基础是Hector &amp; Kenneth  在1987年发表的论文<a target="_blank" rel="noopener" href="https://microservices.io/patterns/data/saga.html">Sagas</a>。</p>
<p>Seata官网对于Saga的指南：<a target="_blank" rel="noopener" href="https://seata.io/zh-cn/docs/user/saga.html">https://seata.io/zh-cn/docs/user/saga.html</a></p>
<h4 id="基本模型"><a href="#基本模型" class="headerlink" title="基本模型"></a>基本模型</h4><p>在 Saga 模式下，分布式事务内有多个参与者，每一个参与者都是一个冲正补偿服务，需要用户根据业务场景实现其正向操作和逆向回滚操作。</p>
<p>分布式事务执行过程中，依次执行各参与者的正向操作，如果所有正向操作均执行成功，那么分布式事务提交。如果任何一个正向操作执行失败，那么分布式事务会去退回去执行前面各参与者的逆向回滚操作，回滚已提交的参与者，使分布式事务回到初始状态。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212149758.png" alt="Saga 模式"> </p>
<p>Saga 模式下分布式事务通常是由事件驱动的，各个参与者之间是异步执行的，Saga 模式是一种长事务解决方案。</p>
<h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><ul>
<li>业务流程长、业务流程多</li>
<li>参与者包含其它公司或遗留系统服务，无法提供 TCC 模式要求的三个接口</li>
</ul>
<h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ul>
<li>一阶段提交本地事务，无锁，高性能</li>
<li>事件驱动架构，参与者可异步执行，高吞吐</li>
<li>补偿服务易于实现</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>不保证隔离性（应对方案见<a target="_blank" rel="noopener" href="https://seata.io/zh-cn/docs/user/saga.html">用户文档</a>）</li>
</ul>
<h2 id="Seata"><a href="#Seata" class="headerlink" title="Seata"></a>Seata</h2><p>Seata（Simple Extensible Autonomous Transaction Architecture，简单可扩展自治事务框架）是 2019 年 1 月份蚂蚁金服和阿里巴巴共同开源的分布式事务解决方案。Seata 开源半年左右，目前已经有接近一万 star，社区非常活跃。我们热忱欢迎大家参与到 Seata 社区建设中，一同将 Seata 打造成开源分布式事务标杆产品。</p>
<p>Seata：<a target="_blank" rel="noopener" href="https://github.com/seata/seata">https:&#x2F;&#x2F;</a><a target="_blank" rel="noopener" href="https://github.com/seata/seata">github.com&#x2F;seata&#x2F;seata</a></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212149759.png" alt="image-20210415162035629"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212149760.png" alt="image-20210415162052256"></p>
<h3 id="AT模式实战"><a href="#AT模式实战" class="headerlink" title="AT模式实战"></a>AT模式实战</h3><p>首先在application.yml中添加一行配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">alibaba:</span></span><br><span class="line">      <span class="attr">seata:</span></span><br><span class="line">        <span class="attr">tx-service-group:</span> <span class="string">test_tx_group</span> <span class="comment"># 定义事务组的名称</span></span><br></pre></td></tr></table></figure>

<p>这里是定义事务组的名称，接下来会用到。</p>
<p>然后是在<code>resources</code>目录下放两个配置文件：<code>file.conf</code>和<code>registry.conf</code></p>
<p>其中，<code>registry.conf</code>与TC服务端的一样，此处不再讲解。</p>
<p>Seata的二阶段执行是通过拦截sql语句，分析语义来指定回滚策略，因此需要对DataSource做代理。我们在项目的<code>cn.itcast.order.config</code>包中，添加一个配置类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.order.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.spring.MybatisSqlSessionFactoryBean;</span><br><span class="line"><span class="keyword">import</span> io.seata.rm.datasource.DataSourceProxy;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourceProxyConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactory <span class="title function_">sqlSessionFactoryBean</span><span class="params">(DataSource dataSource)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 订单服务中引入了mybatis-plus，所以要使用特殊的SqlSessionFactoryBean</span></span><br><span class="line">        <span class="type">MybatisSqlSessionFactoryBean</span> <span class="variable">sqlSessionFactoryBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisSqlSessionFactoryBean</span>();</span><br><span class="line">        <span class="comment">// 代理数据源</span></span><br><span class="line">        sqlSessionFactoryBean.setDataSource(<span class="keyword">new</span> <span class="title class_">DataSourceProxy</span>(dataSource));</span><br><span class="line">        <span class="comment">// 生成SqlSessionFactory</span></span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactoryBean.getObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，这里因为订单服务使用了mybatis-plus这个框架（这是一个mybatis集成框架，自动生成单表Sql），因此我们需要用mybatis-plus的<code>MybatisSqlSessionFactoryBean</code>代替<code>SqlSessionFactoryBean</code></p>
<p>如果用的是原生的mybatis，请使用<code>SqlSessionFactoryBean</code>。</p>
<p>添加事务注解</p>
<p>给事务发起者<code>order_service</code>的<code>OrderServiceImpl</code>中的<code>createOrder()</code>方法添加<code>@GlobalTransactional</code>注解，开启全局事务</p>
<h1 id="微信支付"><a href="#微信支付" class="headerlink" title="微信支付"></a>微信支付</h1><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212149762.png" alt="image-20210415162630464"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">MingwHuang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2021/12/21/leyou/leyou%E9%9D%A2%E8%AF%95%E7%89%88/">http://example.com/2021/12/21/leyou/leyou%E9%9D%A2%E8%AF%95%E7%89%88/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">MingwHuang's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Leyou/">Leyou</a></div><div class="post_share"><div class="social-share" data-image="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272047554.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202172251674.png" target="_blank"><img class="post-qr-code-img" src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202172251674.png" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202172251973.png" target="_blank"><img class="post-qr-code-img" src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202172251973.png" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/12/21/leyou/Leyou%E7%AC%94%E8%AE%B0/"><img class="prev-cover" src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272047554.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">leyou项目搭建</div></div></a></div><div class="next-post pull-right"><a href="/2021/12/21/leyou/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/"><img class="next-cover" src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202262325790.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">项目相关面试题</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/12/21/leyou/Java%E6%A1%86%E6%9E%B6/" title="Spring"><img class="cover" src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272046164.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-21</div><div class="title">Spring</div></div></a></div><div><a href="/2021/12/21/leyou/Leyou%E7%AC%94%E8%AE%B0/" title="leyou项目搭建"><img class="cover" src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272047554.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-21</div><div class="title">leyou项目搭建</div></div></a></div><div><a href="/2021/12/21/leyou/%E5%9F%BA%E4%BA%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%9A%84%E7%B1%BB%E4%BA%AC%E4%B8%9C%E5%B9%B3%E5%8F%B0%E7%BB%93%E9%A2%98%E6%8A%A5%E5%91%8A%20/" title="Leyou结题报告"><img class="cover" src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272046348.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-21</div><div class="title">Leyou结题报告</div></div></a></div><div><a href="/2021/12/21/leyou/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/" title="项目相关面试题"><img class="cover" src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202262325790.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-21</div><div class="title">项目相关面试题</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272113875.JPG" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">MingwHuang</div><div class="author-info__description">朝花夕拾 聊以记之</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">42</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">41</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">20</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E9%97%AE%E9%A2%98"><span class="toc-number">1.</span> <span class="toc-text">项目问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SpringCloud"><span class="toc-number">2.</span> <span class="toc-text">SpringCloud</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Gateway%E9%99%90%E6%B5%81-%E4%BA%86%E8%A7%A3"><span class="toc-number">2.1.</span> <span class="toc-text">Gateway限流(了解)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A4%E7%89%8C%E6%A1%B6%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86"><span class="toc-number">2.1.1.</span> <span class="toc-text">令牌桶算法原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ribbon%E5%81%9A%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">2.2.</span> <span class="toc-text">ribbon做负载均衡</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Nginx"><span class="toc-number">3.</span> <span class="toc-text">Nginx</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E5%8E%9F%E7%90%86"><span class="toc-number">3.1.</span> <span class="toc-text">反向代理原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-number">3.2.</span> <span class="toc-text">负载均衡（了解）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E8%BD%AE%E8%AF%A2%E7%AD%96%E7%95%A5"><span class="toc-number">3.2.1.</span> <span class="toc-text">负载均衡轮询策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E6%9D%83%E8%BD%AE%E8%AF%A2"><span class="toc-number">3.2.2.</span> <span class="toc-text">加权轮询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IP%E5%93%88%E5%B8%8C"><span class="toc-number">3.2.3.</span> <span class="toc-text">IP哈希</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%B0%91%E8%BF%9E%E6%8E%A5"><span class="toc-number">3.2.4.</span> <span class="toc-text">最少连接</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E4%B8%BA%E5%9B%BE%E7%89%87%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">3.3.</span> <span class="toc-text">作为图片服务器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%88%B0OSS"><span class="toc-number">4.</span> <span class="toc-text">上传文件到OSS</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F%E6%96%B9%E5%BC%8F"><span class="toc-number">4.1.</span> <span class="toc-text">传统方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#web%E5%89%8D%E7%AB%AF%E7%AD%BE%E5%90%8D%E5%90%8E%E7%9B%B4%E4%BC%A0"><span class="toc-number">4.2.</span> <span class="toc-text">web前端签名后直传</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%AD%BE%E5%90%8D%E5%90%8E%E7%9B%B4%E4%BC%A0%E6%B5%81%E7%A8%8B"><span class="toc-number">4.3.</span> <span class="toc-text">服务端签名后直传流程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%95%86%E5%93%81%E8%AF%A6%E6%83%85%E9%A1%B5"><span class="toc-number">5.</span> <span class="toc-text">商品详情页</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#canal"><span class="toc-number">5.1.</span> <span class="toc-text">canal</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E4%B8%AD%E5%BF%83"><span class="toc-number">6.</span> <span class="toc-text">用户中心</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%86%E7%A0%81%E5%8A%A0%E5%AF%86"><span class="toc-number">6.0.1.</span> <span class="toc-text">密码加密</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8MD5%E4%B8%8D%E5%AE%89%E5%85%A8"><span class="toc-number">6.0.1.1.</span> <span class="toc-text">为什么用MD5不安全?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BCryptPasswordEncoder%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">6.0.1.2.</span> <span class="toc-text">BCryptPasswordEncoder的原理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C"><span class="toc-number">6.1.</span> <span class="toc-text">服务端数据校验</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#jwt%E7%99%BB%E5%BD%95"><span class="toc-number">7.</span> <span class="toc-text">jwt登录</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="toc-number">7.1.</span> <span class="toc-text">面试常见问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#jwt%E5%92%8Csecurity%E7%9A%84%E5%AF%B9%E6%AF%94%EF%BC%9A"><span class="toc-number">7.1.1.</span> <span class="toc-text">jwt和security的对比：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%99%BB%E5%BD%95%E6%8E%A7%E5%88%B6%E9%97%AE%E9%A2%98"><span class="toc-number">7.1.2.</span> <span class="toc-text">登录控制问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cookie%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-number">7.1.3.</span> <span class="toc-text">cookie安全问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98"><span class="toc-number">7.1.4.</span> <span class="toc-text">权限问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E9%97%AE%E9%A2%98"><span class="toc-number">7.1.5.</span> <span class="toc-text">单点登录问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B4%AD%E7%89%A9%E8%BD%A6"><span class="toc-number">8.</span> <span class="toc-text">购物车</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadLocal%E8%8E%B7%E5%8F%96%E7%99%BB%E5%BD%95%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF"><span class="toc-number">8.0.1.</span> <span class="toc-text">ThreadLocal获取登录用户信息</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90"><span class="toc-number">8.0.1.1.</span> <span class="toc-text">获取用户思路分析</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%8B%E5%8D%95%E5%8A%9F%E8%83%BD"><span class="toc-number">9.</span> <span class="toc-text">下单功能</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8B%E5%8D%95%E9%80%BB%E8%BE%91"><span class="toc-number">9.1.</span> <span class="toc-text">下单逻辑</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%8F%E5%BA%93%E5%AD%98"><span class="toc-number">9.2.</span> <span class="toc-text">减库存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%8F%E5%BA%93%E5%AD%98%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-number">9.2.0.1.</span> <span class="toc-text">减库存安全问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E4%B8%80-%E5%90%8C%E6%AD%A5%E9%94%81-Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">9.2.0.2.</span> <span class="toc-text">思路一: 同步锁(Redis分布式锁)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E4%BA%8C-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8E%92%E5%AE%83%E9%94%81"><span class="toc-number">9.2.0.3.</span> <span class="toc-text">思路二: 数据库排它锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E4%B8%89-%E4%B9%90%E8%A7%82%E9%94%81"><span class="toc-number">9.2.0.4.</span> <span class="toc-text">思路三: 乐观锁</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97%E6%B8%85%E7%90%86%E8%AE%A2%E5%8D%95"><span class="toc-number">10.</span> <span class="toc-text">延迟队列清理订单</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">11.</span> <span class="toc-text">分布式锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF"><span class="toc-number">11.1.</span> <span class="toc-text">业务场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%94%81"><span class="toc-number">11.1.1.</span> <span class="toc-text">线程锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81-1"><span class="toc-number">11.1.2.</span> <span class="toc-text">分布式锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">11.2.</span> <span class="toc-text">Redis实现分布式锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%88%E6%9C%AC%E4%B8%80-%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0"><span class="toc-number">11.2.1.</span> <span class="toc-text">版本一:基本实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%88%E6%9C%AC%E4%BA%8C-%E4%BA%92%E6%96%A5%E6%80%A7"><span class="toc-number">11.2.2.</span> <span class="toc-text">版本二: 互斥性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%88%E6%9C%AC%E4%B8%89-%E9%87%8D%E5%85%A5%E6%80%A7"><span class="toc-number">11.2.3.</span> <span class="toc-text">版本三: 重入性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lua%E8%84%9A%E6%9C%AC%E8%A7%A3%E5%86%B3%E5%8E%9F%E5%AD%90%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-number">11.2.4.</span> <span class="toc-text">Lua脚本解决原子性问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E4%BA%92%E6%96%A5%E9%94%81"><span class="toc-number">11.2.5.</span> <span class="toc-text">普通互斥锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81"><span class="toc-number">11.2.6.</span> <span class="toc-text">可重入锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redisson"><span class="toc-number">11.2.7.</span> <span class="toc-text">Redisson</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%81%E8%87%AA%E5%8A%A8%E7%BB%AD%E6%9C%9F"><span class="toc-number">11.2.7.1.</span> <span class="toc-text">锁自动续期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%A6%E9%98%BB%E5%A1%9E%E7%9A%84%E8%8E%B7%E5%8F%96%E9%94%81"><span class="toc-number">11.2.7.2.</span> <span class="toc-text">带阻塞的获取锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">11.2.8.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Zookeeper%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">11.3.</span> <span class="toc-text">Zookeeper实现分布式锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E7%8E%B0"><span class="toc-number">11.4.</span> <span class="toc-text">基于数据库实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="toc-number">12.</span> <span class="toc-text">分布式事务</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="toc-number">12.1.</span> <span class="toc-text">什么是分布式事务?</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E4%BA%8B%E5%8A%A1"><span class="toc-number">12.1.1.</span> <span class="toc-text">本地事务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-1"><span class="toc-number">12.1.2.</span> <span class="toc-text">分布式事务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%A8%E6%95%B0%E6%8D%AE%E6%BA%90"><span class="toc-number">12.1.2.1.</span> <span class="toc-text">跨数据源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%A8%E6%9C%8D%E5%8A%A1"><span class="toc-number">12.1.2.2.</span> <span class="toc-text">跨服务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-number">12.1.2.3.</span> <span class="toc-text">分布式系统的数据一致性问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%80%9D%E8%B7%AF"><span class="toc-number">12.2.</span> <span class="toc-text">解决分布式事务的思路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CAP%E5%AE%9A%E7%90%86"><span class="toc-number">12.2.1.</span> <span class="toc-text">CAP定理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Base%E7%90%86%E8%AE%BA"><span class="toc-number">12.2.2.</span> <span class="toc-text">Base理论</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%8F%AF%E7%94%A8"><span class="toc-number">12.2.2.1.</span> <span class="toc-text">基本可用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E7%8A%B6%E6%80%81"><span class="toc-number">12.2.2.2.</span> <span class="toc-text">软状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">12.2.2.3.</span> <span class="toc-text">最终一致性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undo%E5%92%8Credo"><span class="toc-number">12.2.3.</span> <span class="toc-text">undo和redo</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#undo-log"><span class="toc-number">12.2.3.1.</span> <span class="toc-text">undo log</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redo-log"><span class="toc-number">12.2.3.2.</span> <span class="toc-text">redo log</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">12.2.3.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4"><span class="toc-number">12.2.4.</span> <span class="toc-text">分阶段提交</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DTP%E5%92%8CXA"><span class="toc-number">12.2.4.1.</span> <span class="toc-text">DTP和XA</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4"><span class="toc-number">12.2.4.2.</span> <span class="toc-text">二阶段提交</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCC"><span class="toc-number">12.2.5.</span> <span class="toc-text">TCC</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">12.2.5.1.</span> <span class="toc-text">基本原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B"><span class="toc-number">12.2.5.2.</span> <span class="toc-text">实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8A%BF%E5%92%8C%E7%BC%BA%E7%82%B9"><span class="toc-number">12.2.5.3.</span> <span class="toc-text">优势和缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">12.2.5.4.</span> <span class="toc-text">使用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E9%9D%A0%E6%B6%88%E6%81%AF%E6%9C%8D%E5%8A%A1"><span class="toc-number">12.2.6.</span> <span class="toc-text">可靠消息服务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86-1"><span class="toc-number">12.2.6.1.</span> <span class="toc-text">基本原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E6%B6%88%E6%81%AF%E8%A1%A8"><span class="toc-number">12.2.6.2.</span> <span class="toc-text">本地消息表</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%80%E5%8C%96%E7%89%88%E6%9C%AC"><span class="toc-number">12.2.6.2.1.</span> <span class="toc-text">简化版本</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%8B%AC%E7%AB%8B%E6%B6%88%E6%81%AF%E6%9C%8D%E5%8A%A1"><span class="toc-number">12.2.6.2.2.</span> <span class="toc-text">独立消息服务</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RocketMQ%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF"><span class="toc-number">12.2.6.3.</span> <span class="toc-text">RocketMQ事务消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RabbitMQ%E7%9A%84%E6%B6%88%E6%81%AF%E7%A1%AE%E8%AE%A4"><span class="toc-number">12.2.6.4.</span> <span class="toc-text">RabbitMQ的消息确认</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">12.2.6.5.</span> <span class="toc-text">消息事务的优缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AT%E6%A8%A1%E5%BC%8F"><span class="toc-number">12.2.7.</span> <span class="toc-text">AT模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86-2"><span class="toc-number">12.2.7.1.</span> <span class="toc-text">基本原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E6%9E%B6%E6%9E%84%E5%92%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">12.2.7.2.</span> <span class="toc-text">详细架构和流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6"><span class="toc-number">12.2.7.3.</span> <span class="toc-text">工作机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF"><span class="toc-number">12.2.7.4.</span> <span class="toc-text">场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E9%98%B6%E6%AE%B5"><span class="toc-number">12.2.7.5.</span> <span class="toc-text">一阶段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E9%98%B6%E6%AE%B5-%E5%9B%9E%E6%BB%9A"><span class="toc-number">12.2.7.6.</span> <span class="toc-text">二阶段-回滚</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E9%98%B6%E6%AE%B5-%E6%8F%90%E4%BA%A4"><span class="toc-number">12.2.7.7.</span> <span class="toc-text">二阶段-提交</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">12.2.7.8.</span> <span class="toc-text">优缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Saga%E6%A8%A1%E5%BC%8F"><span class="toc-number">12.2.8.</span> <span class="toc-text">Saga模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9E%8B"><span class="toc-number">12.2.8.1.</span> <span class="toc-text">基本模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">12.2.8.2.</span> <span class="toc-text">适用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8A%BF"><span class="toc-number">12.2.8.3.</span> <span class="toc-text">优势</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-number">12.2.8.4.</span> <span class="toc-text">缺点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Seata"><span class="toc-number">12.3.</span> <span class="toc-text">Seata</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AT%E6%A8%A1%E5%BC%8F%E5%AE%9E%E6%88%98"><span class="toc-number">12.3.1.</span> <span class="toc-text">AT模式实战</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98"><span class="toc-number">13.</span> <span class="toc-text">微信支付</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/02/26/%E9%9D%A2%E8%AF%95/Redis/" title="Redis"><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272046012.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis"/></a><div class="content"><a class="title" href="/2022/02/26/%E9%9D%A2%E8%AF%95/Redis/" title="Redis">Redis</a><time datetime="2022-02-26T06:21:50.000Z" title="发表于 2022-02-26 14:21:50">2022-02-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/02/26/K8S/" title="无题"><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272047300.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2022/02/26/K8S/" title="无题">无题</a><time datetime="2022-02-26T01:48:42.239Z" title="发表于 2022-02-26 09:48:42">2022-02-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/02/26/Chaos/Chaos/" title="无题"><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272046990.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2022/02/26/Chaos/Chaos/" title="无题">无题</a><time datetime="2022-02-26T01:48:42.239Z" title="发表于 2022-02-26 09:48:42">2022-02-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/02/20/Mac-%E6%B7%B1%E5%BA%A6%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/" title="Mac 深度使用技巧"><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272046164.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Mac 深度使用技巧"/></a><div class="content"><a class="title" href="/2022/02/20/Mac-%E6%B7%B1%E5%BA%A6%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/" title="Mac 深度使用技巧">Mac 深度使用技巧</a><time datetime="2022-02-20T14:38:23.000Z" title="发表于 2022-02-20 22:38:23">2022-02-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/02/15/%E9%9D%A2%E8%AF%95/MySQL/" title="MySQL"><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272046348.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL"/></a><div class="content"><a class="title" href="/2022/02/15/%E9%9D%A2%E8%AF%95/MySQL/" title="MySQL">MySQL</a><time datetime="2022-02-15T10:46:58.000Z" title="发表于 2022-02-15 18:46:58">2022-02-15</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By MingwHuang</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a><span class="footer-separator">|</span><a href="https://beian.miit.gov.cn/" target="_blank">赣ICP备2022001353号-1</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>