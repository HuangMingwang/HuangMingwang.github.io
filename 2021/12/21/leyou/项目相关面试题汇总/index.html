<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>项目相关面试题 | MingwHuang's Blog</title><meta name="keywords" content="Leyou"><meta name="author" content="MingwHuang"><meta name="copyright" content="MingwHuang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1.SpringBoot面试题1.1.SpringBoot的作用是什么?答：采用默认配置，帮助我们快速的构建和运行Spring项目：  用来简化spring初始搭建和开发过程使用特定的方式进行配置(properties或者yml文件) 创建独立的spring引用程序main方法运行 嵌入Tomcat无需部署war包，直接打成jar包nohup java -jar – &amp; 启动就好 简化了m">
<meta property="og:type" content="article">
<meta property="og:title" content="项目相关面试题">
<meta property="og:url" content="http://example.com/2021/12/21/leyou/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/index.html">
<meta property="og:site_name" content="MingwHuang&#39;s Blog">
<meta property="og:description" content="1.SpringBoot面试题1.1.SpringBoot的作用是什么?答：采用默认配置，帮助我们快速的构建和运行Spring项目：  用来简化spring初始搭建和开发过程使用特定的方式进行配置(properties或者yml文件) 创建独立的spring引用程序main方法运行 嵌入Tomcat无需部署war包，直接打成jar包nohup java -jar – &amp; 启动就好 简化了m">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272046348.jpg">
<meta property="article:published_time" content="2021-12-21T08:42:14.000Z">
<meta property="article:modified_time" content="2022-02-22T13:55:23.939Z">
<meta property="article:author" content="MingwHuang">
<meta property="article:tag" content="Leyou">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272046348.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2021/12/21/leyou/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":500},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '项目相关面试题',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-02-22 21:55:23'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272113875.JPG" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">42</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">42</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">21</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272046348.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">MingwHuang's Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">项目相关面试题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-12-21T08:42:14.000Z" title="发表于 2021-12-21 16:42:14">2021-12-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-02-22T13:55:23.939Z" title="更新于 2022-02-22 21:55:23">2022-02-22</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Leyou/">Leyou</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="项目相关面试题"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="1-SpringBoot面试题"><a href="#1-SpringBoot面试题" class="headerlink" title="1.SpringBoot面试题"></a>1.SpringBoot面试题</h1><h2 id="1-1-SpringBoot的作用是什么"><a href="#1-1-SpringBoot的作用是什么" class="headerlink" title="1.1.SpringBoot的作用是什么?"></a>1.1.SpringBoot的作用是什么?</h2><p>答：采用默认配置，帮助我们快速的构建和运行Spring项目：</p>
<ul>
<li>用来简化spring初始搭建和开发过程使用特定的方式进行配置(properties或者yml文件)</li>
<li>创建独立的spring引用程序main方法运行</li>
<li>嵌入Tomcat无需部署war包，直接打成jar包nohup java -jar – &amp; 启动就好</li>
<li>简化了maven的配置</li>
<li>自动配置spring添加对应的starter自动化配置</li>
</ul>
<h2 id="1-2-SpringBoot的自动配置原理？"><a href="#1-2-SpringBoot的自动配置原理？" class="headerlink" title="1.2.SpringBoot的自动配置原理？"></a>1.2.SpringBoot的自动配置原理？</h2><p>SpringBoot项目的启动类都会有@SpringBootApplication注解，而这个注解的二级注解是@EnableAutoConfiguration注解。而@EnableAutoConfiguration注解通过@Import注解来导入各种在SpringBoot的jar包中或starter中写好的各种@Configuration声明的类。具体流程如下：</p>
<ul>
<li>@EnableAutoConfiguration通过@Import来导入配置</li>
<li>导入过程中，会利用classLoader读取META-INF&#x2F;spring.factories文件（key-value格式）中的数据</li>
<li>读取文件中以EnableAutoConfiguration为key的值，值就是Spring提供的，或我们引入的starter中的加了@Configuration的类，包括对spring、第三方库的各种配置。例如redis、elasticsearch、springmvc、mybatis等</li>
<li>对加载到的@Configuration类做过滤，分三步过滤：<ul>
<li>滤重</li>
<li>去除用户通过exclude排除的配置</li>
<li>去除不满足@ConditionalOnXX这样条件的配置</li>
</ul>
</li>
<li>将剩余的配置类实例化，完成自动配置加载</li>
</ul>
<p>这个过程中，我们可以通过自定义@Bean的方式，覆盖默认配置中已经完成的Bean。或者我们可以通过编写application.properties或者application.yml文件来覆盖默认配置中的属性值。</p>
<h2 id="1-3-有没有自定义过SpringBoot的stater？"><a href="#1-3-有没有自定义过SpringBoot的stater？" class="headerlink" title="1.3.有没有自定义过SpringBoot的stater？"></a>1.3.有没有自定义过SpringBoot的stater？</h2><p>有，项目中某些中间件的客户端（如Redis、ElasticSearch）会进行二次封装，并通过starter方式提供jar包，供大家使用。</p>
<p>一般定义starter包括下面几个子工程：</p>
<ul>
<li>xxx-spring-boot-starter：pom格式，管理当前starter中需要的各种依赖</li>
<li>xxx-spring-boot-autoconfigure：jar格式，编写@Configuration配置类，读取application.yml文件，实现默认配置</li>
</ul>
<h1 id="2-SpringCloud相关"><a href="#2-SpringCloud相关" class="headerlink" title="2.SpringCloud相关"></a>2.SpringCloud相关</h1><h2 id="2-0-微服务的优缺点"><a href="#2-0-微服务的优缺点" class="headerlink" title="2.0.微服务的优缺点"></a>2.0.微服务的优缺点</h2><p>微服务架构是一种架构模式或者说是一种架构风格，它提倡将单一应用程序划分为一组小服务，每个服务运行在自己的独立进程中，服务间通信采用轻量级通信机制(通常是基于 HTTP 的 RESTful API)。每个服务都围绕着具体业务进行构建，并且能够被独立地部署到生产环境、类生产环境等。另外，应该尽量避免统一的、集中式的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言、工具对其进行构建，可以有一个非常轻量级的集中式管理来协调这些服务，可以使用不同的语言来编写服务，也可以使用不同的数据存储技术。</p>
<ul>
<li>优点：<ul>
<li>易于开发和维护：一个微服务只会关注一个特定的业务功能，所以它业务清晰，代码量较少</li>
<li>单个微服务启动较快：单个微服务代码量较少，所以启动会比较快</li>
<li>业务之间松耦合，无论是在开发阶段或者部署阶段，不同的服务都是互相独立的</li>
<li>局部修改容易部署：单体应用只要有修改，就得重新部署整个应用，微服务解决了这样的问题</li>
<li>技术栈不受限：在微服务架构中，可以结合项目业务及团队的特点，合理地选择技术栈</li>
<li>按需伸缩：可根据需求，实现细粒度的扩展</li>
<li>只有业务逻辑的代码，不会和 HTML、CSS 或者其他前端页面耦合，目前有两种开发模式：前后端分离、全栈开发</li>
</ul>
</li>
<li>缺点：<ul>
<li>运维要求高：更多的服务意味着更多的运维投入</li>
<li>技术开发难度高：涉及到网络通信延迟、服务容错、数据一致性、系统集成测试、系统部署依赖、性能监控等</li>
<li>分布式系统固有的复杂性：使用微服务架构是分布式系统，对于一个分布式系统，系统容错，网络延迟，分布式事务等都会带来巨大的挑战</li>
<li>接口调整成本高：微服务之间通过接口进行通信。如果修改某一个微服务的 API，可能所有使用了该接口的微服务都需要做调整</li>
<li>重复劳动：很多服务可能都会使用到相同的功能，而这个功能并没有达到分解为一个微服务的程度，这个时候，可能各个服务都会开发这一功能，从而导致代码重复</li>
</ul>
</li>
</ul>
<h2 id="2-1-SpringCloud和Dubbo的区别"><a href="#2-1-SpringCloud和Dubbo的区别" class="headerlink" title="2.1.SpringCloud和Dubbo的区别"></a>2.1.SpringCloud和Dubbo的区别</h2><p>SpringCloud：Spring公司开源的微服务框架，SpirngCloud 定位为微服务架构下的一站式解决方案（微服务生态）</p>
<p>Dubbo：阿里巴巴开源的RPC框架，Dubbo 是 SOA 时代的产物，它的关注点主要在于服务的调用，流量分发、流量监控和熔断</p>
<table>
<thead>
<tr>
<th>功能</th>
<th>Dubbo</th>
<th>SpringCloud</th>
</tr>
</thead>
<tbody><tr>
<td>服务注册中心</td>
<td>Zookeeper、Redis</td>
<td>Spring Cloud Netfix Eureka</td>
</tr>
<tr>
<td>服务调用方式</td>
<td>RPC</td>
<td>REST API</td>
</tr>
<tr>
<td>服务监控</td>
<td>Dubbo-Monitor</td>
<td>Spring Boot Admin</td>
</tr>
<tr>
<td>熔断器</td>
<td>不完善</td>
<td>Spring Cloud Netflix Hystrix</td>
</tr>
<tr>
<td>服务网关</td>
<td>无</td>
<td>Spring Cloud Netflix Zuul</td>
</tr>
<tr>
<td>分布式配置</td>
<td>无</td>
<td>Spring Cloud Config</td>
</tr>
<tr>
<td>服务跟踪</td>
<td>无</td>
<td>Spring Cloud Sleuth</td>
</tr>
<tr>
<td>数据流</td>
<td>无</td>
<td>Spring Cloud Stream</td>
</tr>
<tr>
<td>批量任务</td>
<td>无</td>
<td>Spring Cloud Task</td>
</tr>
<tr>
<td>信息总线</td>
<td>无</td>
<td>Spring Cloud Bus</td>
</tr>
</tbody></table>
<p>Spring Cloud 的功能很明显比 Dubbo 更加强大，涵盖面更广，而且作为 Spring 的旗舰项目，它也能够与 Spring Framework、Spring Boot、Spring Data、Spring Batch 等其他 Spring 项目完美融合，这些对于微服务而言是至关重要的。</p>
<p>使用 Dubbo 构建的微服务架构就像组装电脑，各环节选择自由度很高，但是最终结果很有可能因为一条内存质量不行就点不亮了，总是让人不怎么放心，但是如果使用者是一名高手，那这些都不是问题。</p>
<p>而 Spring Cloud 就像品牌机，在 Spring Source 的整合下，做了大量的兼容性测试，保证了机器拥有更高的稳定性，但是如果要在使用非原装组件外的东西，就需要对其基础原理有足够的了解。</p>
<h2 id="2-2-RPC与Rest的区别（dubbo协议和Feign远程调用的差异）"><a href="#2-2-RPC与Rest的区别（dubbo协议和Feign远程调用的差异）" class="headerlink" title="2.2.RPC与Rest的区别（dubbo协议和Feign远程调用的差异）"></a>2.2.RPC与Rest的区别（dubbo协议和Feign远程调用的差异）</h2><p>Dubbo协议默认采用的时RPC框架实现远程调用，而SpringCloud中使用的时基于Rest风格的调用方式。包括下面区别：</p>
<h3 id="1）Rest风格"><a href="#1）Rest风格" class="headerlink" title="1）Rest风格"></a>1）Rest风格</h3><p>REST是一种架构风格，指的是一组架构约束条件和原则。满足这些约束条件和原则的应用程序或设计就是 RESTful。</p>
<p>Rest的风格可以完全通过HTTP协议实现，使用 HTTP 协议处理数据通信。REST架构对资源的操作包括获取、创建、修改和删除资源的操作正好对应HTTP协议提供的GET、POST、PUT和DELETE方法。</p>
<p>因此请求和想要过程只要遵循http协议即可，更加灵活</p>
<p>SpringCloud中的Feign就是Rest风格的调用方式。</p>
<h3 id="2）RPC"><a href="#2）RPC" class="headerlink" title="2）RPC"></a>2）RPC</h3><p>Remote Procedure Call，远程过程调用，就是像调用本地方法一样调用远程方法。RPC架构图：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212142539.png" alt="img"></p>
<p>RPC一般要确定下面几件事情：</p>
<ul>
<li>数据传输方式：多数RPC框架选择TCP作为传输协议，性能比较好，也有部分框架选择http协议。</li>
<li>数据传输内容：请求方需要告知需要调用的函数的名称、参数、等信息。</li>
<li>序列化方式：客户端和服务端交互时将参数或结果转化为字节流在网络中传输，那么数据转化为字节流的或者将字节流转换成能读取的固定格式时就需要进行序列化和反序列化</li>
</ul>
<p>因为有序列化和反序列化的需求，因此对数据传输格式有严格要求，不如Http灵活</p>
<p>Dubbo协议就是RPC的典型代表。</p>
<p>我们看看Dubbo协议和Rest的调用区别：</p>
<table>
<thead>
<tr>
<th></th>
<th>Dubbo</th>
<th>Rest（Http调用）</th>
</tr>
</thead>
<tbody><tr>
<td>传输协议</td>
<td>TCP</td>
<td>TCP</td>
</tr>
<tr>
<td>开发语言</td>
<td>java</td>
<td>不限</td>
</tr>
<tr>
<td>性能</td>
<td>好</td>
<td>一般</td>
</tr>
<tr>
<td>灵活性</td>
<td>一般</td>
<td>好</td>
</tr>
</tbody></table>
<h2 id="2-3-Eureka和Zookeeper注册中心的区别"><a href="#2-3-Eureka和Zookeeper注册中心的区别" class="headerlink" title="2.3.Eureka和Zookeeper注册中心的区别"></a>2.3.Eureka和Zookeeper注册中心的区别</h2><p>答：</p>
<p>先看下CAP原则：C-数据一致性；A-服务可用性；P-服务对网络分区故障的容错性，这三个特性在任何分布式系统中不能同时满足，最多同时满足两个</p>
<ul>
<li>Eureka满足AP，Zookeeper满足CP<ul>
<li>Zookeeper满足一致性、容错性。数据要在各个服务间同步完成后才返回用户结果，而且如果服务出现网络波动，会立即从服务列表中剔除，服务不可使用</li>
<li>Eureka满足AP，可用性，容错性。当因网络故障时，Eureka的自我保护机制不会立即剔除服务，虽然用户获取到的服务不一定时可用的，但是至少能够获取到服务列表。用户访问服务列表时还可以利用重试机制，找到正确的服务。更符合分布式服务的高可用需求</li>
</ul>
</li>
<li>Eureka集群各节点平等，Zookeeper中有主从之分<ul>
<li>如果Zookeeper集群中部分宕机，可能会导致整个集群因为选主而阻塞，服务不可用</li>
<li>eureka集群宕机部分，不会对其它机器产生影响</li>
</ul>
</li>
<li>Eureka的服务发现需要主动去拉取，Zookeeper服务发现是监听机制<ul>
<li>eureka中获取服务列表后会缓存起来，每隔30秒重新拉取服务列表</li>
<li>zookeeper则是监听节点信息变化，当服务节点信息变化时，客户端立即就得到通知</li>
</ul>
</li>
</ul>
<h2 id="2-4-SpringCloud中的常用组件有哪些？"><a href="#2-4-SpringCloud中的常用组件有哪些？" class="headerlink" title="2.4.SpringCloud中的常用组件有哪些？"></a>2.4.SpringCloud中的常用组件有哪些？</h2><p>常见组件：</p>
<ul>
<li>SpringCloudNetflix：<ul>
<li>Eureka：注册中心，可以用Zookeeper和Consul代替</li>
<li>Ribbon：负载均衡器</li>
<li>Hystrix：断路器</li>
<li>Zuul：网关，可以用SpringCloudGateway代替</li>
</ul>
</li>
<li>SpringCloudBus：消息总线，默认基于RabbitMQ和Kafka实现</li>
<li>SpringCloudConfig：统一配置中心，分为server端和client端</li>
<li>SpringCloudStrean：数据流处理，默认基于RabbitMQ和Kafka</li>
<li>SpringCloudSleuth：结合SpringCloudZipkin实现链路追踪</li>
</ul>
<h1 id="3-RabbitMQ常见面试题"><a href="#3-RabbitMQ常见面试题" class="headerlink" title="3.RabbitMQ常见面试题"></a>3.RabbitMQ常见面试题</h1><h2 id="3-1-你们公司为什么选择了RabbitMQ产品，而不是RocketMQ和Kafka（问区别）？"><a href="#3-1-你们公司为什么选择了RabbitMQ产品，而不是RocketMQ和Kafka（问区别）？" class="headerlink" title="3.1.你们公司为什么选择了RabbitMQ产品，而不是RocketMQ和Kafka（问区别）？"></a>3.1.你们公司为什么选择了RabbitMQ产品，而不是RocketMQ和Kafka（问区别）？</h2><p>这个问题其实时问3种MQ的差别，先看一张图：</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>RabbitMQ</th>
<th>RocketMQ</th>
<th>kafka</th>
</tr>
</thead>
<tbody><tr>
<td>开发语言</td>
<td>erlang</td>
<td>java</td>
<td>scala</td>
</tr>
<tr>
<td>单机吞吐量</td>
<td>万级</td>
<td>10万级</td>
<td>10万级</td>
</tr>
<tr>
<td>时效性</td>
<td>us级</td>
<td>ms级</td>
<td>ms级以内</td>
</tr>
<tr>
<td>可用性</td>
<td>高(主从架构)</td>
<td>非常高(分布式架构)</td>
<td>非常高(分布式架构)</td>
</tr>
<tr>
<td>功能特性</td>
<td>基于erlang开发，所以并发能力很强，性能极其好，延时很低;管理界面较丰富</td>
<td>MQ功能比较完备，扩展性佳</td>
<td>只支持主要的MQ功能，像一些消息查询，消息回溯等功能没有提供，毕竟是为大数据准备的，在大数据领域应用广。</td>
</tr>
</tbody></table>
<p>中小型软件公司，建议选RabbitMQ，原因：</p>
<ul>
<li>erlang语言天生具备高并发的特性，而且他的管理界面用起来十分方便。</li>
<li>RabbitMQ的社区十分活跃，可以解决开发过程中遇到的bug，这点对于中小型公司来说十分重要。</li>
<li>不考虑rocketmq和kafka的原因是，一方面中小型软件公司不如互联网公司，数据量没那么大，选消息中间件，应首选功能比较完备的，所以kafka排除。</li>
<li>不考虑rocketmq的原因是，rocketmq是阿里出品，如果阿里放弃维护rocketmq，中小型公司一般抽不出人来进行rocketmq的定制化开发，因此不推荐。</li>
</ul>
<p>RabbitMQ的缺点：</p>
<ul>
<li>虽然RabbitMQ是开源的，然而国内有几个能定制化开发erlang的程序员呢</li>
</ul>
<p>如果有大数据的需求，例如日志记录、程序运行链路追踪的记录，可以使用Kafka来做MQ，毕竟吞吐量比较大。</p>
<h2 id="3-2-在项目中哪些地方使用了MQ，解决了什么问题？"><a href="#3-2-在项目中哪些地方使用了MQ，解决了什么问题？" class="headerlink" title="3.2.在项目中哪些地方使用了MQ，解决了什么问题？"></a>3.2.在项目中哪些地方使用了MQ，解决了什么问题？</h2><p>这个问题主要问的时MQ的作用，包括下列几点： </p>
<ul>
<li><p>数据同步</p>
</li>
<li><p>解耦合</p>
</li>
<li><p>流量削峰</p>
</li>
<li><p>异步执行</p>
</li>
<li><p>延迟队列</p>
</li>
</ul>
<h3 id="1）解耦合"><a href="#1）解耦合" class="headerlink" title="1）解耦合"></a>1）解耦合</h3><p>例如项目中 商品微服务对商品完成了增删改，需要对索引库数据、商品的静态页做处理。但是不能在商品微服务嵌入代码，这样会出现耦合。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212142541.png" alt="1574829165382"> </p>
<p>此时，可以利用MQ来解耦，让商品微服务发送消息通知，而相关的其它系统监听MQ即可：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212142542.png" alt="1574829207585"> </p>
<h3 id="2）流量削峰"><a href="#2）流量削峰" class="headerlink" title="2）流量削峰"></a>2）流量削峰</h3><p>数据库的并发能力有限，往往称为业务执行的性能瓶颈。</p>
<p>例如我们的服务只能支持500的并发，然而又每秒1000甚至更高的服务流量涌入，服务肯定会崩溃的。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212142543.png" alt="1574829378276"> </p>
<p>此时，利用MQ来作为缓冲，就像大坝一样，高并发流量涌入，先放到MQ中缓存起来，后续系统再慢慢取出并处理即可：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212142544.png" alt="1574829476538"> </p>
<h3 id="3）异步调用"><a href="#3）异步调用" class="headerlink" title="3）异步调用"></a>3）异步调用</h3><p>如果一个业务执行中，需要调用多个其它服务，业务链路很长，同步调用的用时就时多个服务执行的总耗时，如图：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212142545.png" alt="1574829703693"> </p>
<p>但是，我们如果再B系统执行完成后，利用MQ通知系统C和系统D去完成，直接返回结果给用户，就可以减少业务耗时。这样就把同步阻塞调用，变成了异步调用：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212142546.png" alt="1574829932259"> </p>
<h2 id="3-3-如何保证MQ的高可用"><a href="#3-3-如何保证MQ的高可用" class="headerlink" title="3.3.如何保证MQ的高可用"></a>3.3.如何保证MQ的高可用</h2><p>RabbitMQ底层时基于Erlang语言，对分布式支持较好。并且官方也给出了搭建镜像机器的方式，可以把队列及其中的数据同步到镜像节点中，当队列所在节点故障时，镜像队列可以继续提供服务。</p>
<p>另外，MQ数据可以持久化，当节点恢复时，可以恢复数据。</p>
<p>而Kafka和RocketMQ是通过主从集群方案来实现高可用的：</p>
<p>以rcoketMQ为例，他的集群就有多master 模式、多master多slave异步复制模式、多 master多slave同步双写模式。RocketMQ多master多slave模式部署架构图</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212142547.png" alt="1574830176536"></p>
<p>kafka：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212142548.png" alt="1574830129381"></p>
<h2 id="3-4-如何保证MQ的消息可靠性，防止消息丢失？"><a href="#3-4-如何保证MQ的消息可靠性，防止消息丢失？" class="headerlink" title="3.4.如何保证MQ的消息可靠性，防止消息丢失？"></a>3.4.如何保证MQ的消息可靠性，防止消息丢失？</h2><h3 id="1）RabbitMQ"><a href="#1）RabbitMQ" class="headerlink" title="1）RabbitMQ"></a>1）RabbitMQ</h3><p>消息丢失的几种情况：</p>
<ul>
<li>生产者发送消息时丢失：<ul>
<li>利用RabbitMQ提供的publisher confirm机制</li>
</ul>
</li>
<li>MQ丢失消息：<ul>
<li>消息持久化</li>
<li>镜像集群备份</li>
</ul>
</li>
<li>消费者丢失消息：rabbitmq中消息消费后自动删除，不会永久保留<ul>
<li>消费者的确认机制，在处理消息结束后，手动Acknowledge</li>
</ul>
</li>
</ul>
<h3 id="2）kafka"><a href="#2）kafka" class="headerlink" title="2）kafka"></a>2）kafka</h3><p>这里先引一张kafka Replication的<a target="_blank" rel="noopener" href="http://www.infoq.com/cn/articles/kafka-analysis-part-2/">数据流向图</a><br><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212142549.png" alt="image"><br>Producer在发布消息到某个Partition时，先通过ZooKeeper找到该Partition的Leader，然后无论该Topic的Replication Factor为多少（也即该Partition有多少个Replica），Producer只将该消息发送到该Partition的Leader。Leader会将该消息写入其本地Log。每个Follower都从Leader中pull数据。<br>针对上述情况，得出如下分析</p>
<ul>
<li><p>生产者丢数据<br>在kafka生产中，基本都有一个leader和多个follwer。follwer会去同步leader的信息。因此，为了避免生产者丢数据，做如下两点配置</p>
<ul>
<li>第一个配置要在producer端设置acks&#x3D;all。这个配置保证了，follwer同步完成后，才认为消息发送成功。</li>
<li>在producer端设置retries&#x3D;MAX，一旦写入失败，这无限重试</li>
</ul>
</li>
<li><p>消息队列丢数据<br>针对消息队列丢数据的情况，无外乎就是，数据还没同步，leader就挂了，这时zookpeer会将其他的follwer切换为leader,那数据就丢失了。针对这种情况，应该做两个配置。</p>
<ul>
<li>replication.factor参数，这个值必须大于1，即要求每个partition必须有至少2个副本</li>
<li>min.insync.replicas参数，这个值必须大于1，这个是要求一个leader至少感知到有至少一个follower还跟自己保持联系</li>
</ul>
<p>这两个配置加上上面生产者的配置联合起来用，基本可确保kafka不丢数据</p>
</li>
<li><p>消费者丢数据<br>这种情况一般是自动提交了offset，然后你处理程序过程中挂了。kafka以为你处理好了</p>
<ul>
<li>offset：指的是kafka的topic中的每个消费组消费的下标。简单的来说就是一条消息对应一个offset下标，每次消费数据的时候如果提交offset，那么下次消费就会从提交的offset加一那里开始消费。<br>比如一个topic中有100条数据，我消费了50条并且提交了，那么此时的kafka服务端记录提交的offset就是49(offset从0开始)，那么下次消费的时候offset就从50开始消费。</li>
<li>解决方案也很简单，改成手动提交即可。</li>
</ul>
</li>
</ul>
<h2 id="3-5-如何防止MQ消息的重复消费？"><a href="#3-5-如何防止MQ消息的重复消费？" class="headerlink" title="3.5.如何防止MQ消息的重复消费？"></a>3.5.如何防止MQ消息的重复消费？</h2><p>消息重复消费产生的原因：</p>
<ul>
<li>因为网络故障，导致生产者确认机制失败，生产者重发消息</li>
<li>因为网络故障，导致生产者确认机制失败，MQ重新投递消息</li>
</ul>
<p>解决思路：保证处理消息接口的幂等性：</p>
<ul>
<li>某些接口天生幂等，例如查询请求，无需处理</li>
<li>某些接口天生不幂等，比如新增，还有某些接口的修改功能<ul>
<li>能根据具体的业务或状态来确定的，在消费端通过业务判断是否执行过，例如新增订单，看看订单ID是否已经存在</li>
<li>对于无法通过业务判断的，我们可以为每一条消息设置全局唯一id，保存到数据库或其它地方。消息处理前对ID进行判断即可</li>
</ul>
</li>
</ul>
<h2 id="3-6-如何解决MQ的消息堆积问题？"><a href="#3-6-如何解决MQ的消息堆积问题？" class="headerlink" title="3.6.如何解决MQ的消息堆积问题？"></a>3.6.如何解决MQ的消息堆积问题？</h2><p>通过同一个队列多消费者监听，实现消息的争抢，加快消息消费速度。</p>
<h2 id="3-7-如何保证MQ消息的有序性？"><a href="#3-7-如何保证MQ消息的有序性？" class="headerlink" title="3.7.如何保证MQ消息的有序性？"></a>3.7.如何保证MQ消息的有序性？</h2><p>某个业务发出了3条消息，要求这3条消息按照发送时的顺序执行。</p>
<ul>
<li>业务同时对并发要求不高：<ul>
<li>保证消息发送时有序同步发送</li>
<li>保证消息发送被同一个队列接收</li>
<li>保证一个队列只有一个消费者</li>
</ul>
</li>
<li>业务同时对并发要求较高：<ul>
<li>满足上述第一个场景的条件</li>
<li>可以有多个队列</li>
<li>有时序要求的一组消息，通过hash方式分派到一个固定队列</li>
</ul>
</li>
</ul>
<h1 id="4-Redis相关问题"><a href="#4-Redis相关问题" class="headerlink" title="4.Redis相关问题"></a>4.Redis相关问题</h1><h2 id="4-1-Redis与Memcache的区别？"><a href="#4-1-Redis与Memcache的区别？" class="headerlink" title="4.1.Redis与Memcache的区别？"></a>4.1.Redis与Memcache的区别？</h2><ul>
<li><code>redis支持更丰富的数据类型</code>（支持更复杂的应用场景）：Redis不仅仅支持简单的k&#x2F;v类型的数据，同时还提供list，set，zset，hash等数据结构的存储。memcache支持简单的数据类型，String。</li>
<li><code>Redis支持数据的持久化</code>，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而Memecache把数据全部存在内存之中。</li>
<li><code>集群模式</code>：memcached没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 redis 目前是原生支持 cluster 模式的.</li>
<li><code>Redis使用单线程</code>：Memcached是多线程，非阻塞IO复用的网络模型；Redis使用单线程的多路 IO 复用模型。</li>
</ul>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212142550.png" alt="1574821356723"></p>
<h2 id="4-2-Redis的持久化方案由哪些？"><a href="#4-2-Redis的持久化方案由哪些？" class="headerlink" title="4.2.Redis的持久化方案由哪些？"></a>4.2.Redis的持久化方案由哪些？</h2><p>Redis主要提供了两种持久化机制，RDB和AOF:</p>
<h3 id="1）RDB："><a href="#1）RDB：" class="headerlink" title="1）RDB："></a>1）RDB：</h3><p>默认开启，满足条件时将内存中的数据快照到磁盘中，创建一个dump.rdb文件，Redis启动时再恢复到内存中。</p>
<p>Redis会单独创建fork()一个子进程，将当前父进程的数据库数据复制到子进程的内存中，然后由子进程写入到临时文件中，持久化的过程结束了，再用这个临时文件替换上次的快照文件，然后子进程退出，内存释放。</p>
<p>需要注意的是，每次快照持久化都会将主进程的数据库数据复制一遍，导致内存开销加倍，若此时内存不足，则会阻塞服务器运行，直到复制结束释放内存；都会将内存数据完整写入磁盘一次，所以如果数据量大的话，而且写操作频繁，必然会引起大量的磁盘I&#x2F;O操作，严重影响性能，并且最后一次持久化后的数据可能会丢失；</p>
<p>RDB策略配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">save 900 1    #在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发BGSAVE命令创建快照。</span><br><span class="line"></span><br><span class="line">save 300 10   #在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发BGSAVE命令创建快照。</span><br><span class="line"></span><br><span class="line">save 60 10000 #在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发BGSAVE命令创建快照。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2）AOF"><a href="#2）AOF" class="headerlink" title="2）AOF:"></a>2）AOF:</h3><p>与快照持久化相比，AOF持久化 的实时性更好，因此已成为主流的持久化方案。默认情况下Redis没有开启AOF（append only file）方式的持久化，可以通过appendonly参数开启：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes</span><br></pre></td></tr></table></figure>

<p>开启AOF持久化后每执行一条会更改Redis中的数据的命令，Redis就会将该命令写入硬盘中的AOF文件。AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的，默认的文件名是appendonly.aof。</p>
<p>在Redis的配置文件中存在三种不同的 AOF 持久化方式，它们分别是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">appendfsync always     <span class="comment">#每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度</span></span><br><span class="line">appendfsync everysec  <span class="comment">#每秒钟同步一次，显示地将多个写命令同步到硬盘</span></span><br><span class="line">appendfsync no      <span class="comment">#让操作系统决定何时进行同步</span></span><br></pre></td></tr></table></figure>

<p>为了兼顾数据和写入性能，用户可以考虑 appendfsync everysec选项 ，让Redis每秒同步一次AOF文件，Redis性能几乎没受到任何影响。而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。当硬盘忙于执行写入操作的时候，Redis还会优雅的放慢自己的速度以便适应硬盘的最大写入速度。</p>
<h2 id="4-3-Redis的集群方式有哪些？"><a href="#4-3-Redis的集群方式有哪些？" class="headerlink" title="4.3.Redis的集群方式有哪些？"></a>4.3.Redis的集群方式有哪些？</h2><h3 id="1）主从集群"><a href="#1）主从集群" class="headerlink" title="1）主从集群"></a>1）主从集群</h3><p>主从集群，也是读写分离集群。一般都是一主多从方式。</p>
<p>Redis 的复制（replication）功能允许用户根据一个 Redis 服务器来创建任意多个该服务器的复制品，其中被复制的服务器为主服务器（master），而通过复制创建出来的服务器复制品则为从服务器（slave）。</p>
<p>只要主从服务器之间的网络连接正常，主从服务器两者会具有相同的数据，主服务器就会一直将发生在自己身上的数据更新同步 给从服务器，从而一直保证主从服务器的数据相同。</p>
<ul>
<li>写数据时只能通过主节点完成</li>
<li>读数据可以从任何节点完成</li>
<li>如果配置了<code>哨兵节点</code>，当master宕机时，哨兵会从salve节点选出一个新的主。</li>
</ul>
<p>主从集群分两种：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212142551.png" alt="1574821993599"> <img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212142552.png" alt="1574822026037"> </p>
<p>带有哨兵的集群：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212142553.png" alt="1574822077190"></p>
<h3 id="2）分片集群"><a href="#2）分片集群" class="headerlink" title="2）分片集群"></a>2）分片集群</h3><p>主从集群中，每个节点都要保存所有信息，容易形成木桶效应。并且当数据量较大时，单个机器无法满足需求。此时我们就要使用分片集群了。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212142554.png" alt="1574822184467"> </p>
<p>集群特征：</p>
<ul>
<li><p>每个节点都保存不同数据</p>
</li>
<li><p>所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽.</p>
</li>
<li><p>节点的fail是通过集群中超过半数的节点检测失效时才生效.</p>
</li>
<li><p>客户端与redis节点直连,不需要中间proxy层连接集群中任何一个可用节点都可以访问到数据</p>
</li>
<li><p>redis-cluster把所有的物理节点映射到[0-16383]slot（插槽）上，实现动态伸缩</p>
</li>
</ul>
<p>为了保证Redis中每个节点的高可用，我们还可以给每个节点创建replication（slave节点），如图：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212142555.png" alt="1574822584357"></p>
<p>出现故障时，主从可以及时切换：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212142556.png" alt="1574822602109"></p>
<h2 id="4-4-Redis的分片集群如何做到集群动态伸缩（hash槽原理）"><a href="#4-4-Redis的分片集群如何做到集群动态伸缩（hash槽原理）" class="headerlink" title="4.4.Redis的分片集群如何做到集群动态伸缩（hash槽原理）"></a>4.4.Redis的分片集群如何做到集群动态伸缩（hash槽原理）</h2><p>创建集群时，Redis会将16384个插槽分配到不同的节点上。</p>
<p>redis集群存储数据时，会根据key计算插槽值，利用key的<code>有效部分</code>使用CRC16算法计算出哈希值，再将哈希值对16384取余，得到插槽值。</p>
<p><strong>插槽在哪个节点，数据就跟随到哪个几点，因此数据时跟插槽绑定，而不是具体的机器</strong>。</p>
<p>当集群中有新的机器加入，我们可以重新分配插槽，Redis会自动把对应插槽的数据同步到新的节点。</p>
<h2 id="4-5-Redis的常用数据类型有哪些？"><a href="#4-5-Redis的常用数据类型有哪些？" class="headerlink" title="4.5.Redis的常用数据类型有哪些？"></a>4.5.Redis的常用数据类型有哪些？</h2><p>支持多种类型的数据结构，主要区别是value存储的数据格式不同：</p>
<ul>
<li><p>string：最基本的数据类型，二进制安全的字符串，最大512M。</p>
</li>
<li><p>list：按照添加顺序保持顺序的字符串列表。</p>
</li>
<li><p>set：无序的字符串集合，不存在重复的元素。</p>
</li>
<li><p>sorted set：已排序的字符串集合。</p>
</li>
<li><p>hash：key-value对格式</p>
</li>
</ul>
<h2 id="4-6-Redis是单线程，为什么并发能力这么强"><a href="#4-6-Redis是单线程，为什么并发能力这么强" class="headerlink" title="4.6.Redis是单线程，为什么并发能力这么强?"></a>4.6.Redis是单线程，为什么并发能力这么强?</h2><p>答：</p>
<p>单线程可以带来下列好处：</p>
<p>1）绝大部分请求是纯粹的内存操作（非常快速）</p>
<p>2）采用单线程,避免了不必要的上下文切换和竞争条件</p>
<p>3）采用非阻塞IO，利用了IO多路复用的特性。</p>
<p>简述IO多路复用的模型：</p>
<p>首先，Redis线程模型包括下面几个概念：</p>
<ul>
<li>套接字（Socket)：用户请求套接字对象</li>
<li>I&#x2F;O 多路复用程序：监听客户端Socket，并未客户端绑定事件处理器</li>
<li>文件事件分派器（dispatcher）：根据客户端目前状态不同，分发不同的事件处理器处理</li>
<li>事件处理器：处理用户具体操作事件，包括：接收套接字（accept）、读取（read）、写入（write）、关闭（close）等操作的处理器</li>
</ul>
<p>如图：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212142557.png" alt="1574819020635"></p>
<h2 id="4-7-聊一下Redis事务机制"><a href="#4-7-聊一下Redis事务机制" class="headerlink" title="4.7.聊一下Redis事务机制"></a>4.7.聊一下Redis事务机制</h2><p>Redis事务功能是通过MULTI、EXEC、DISCARD和WATCH 四个原语实现的。Redis会将一个事务中的所有命令序列化，然后按顺序执行。但是Redis事务不支持回滚操作，命令运行出错后，正确的命令会继续执行。</p>
<ul>
<li><code>MULTI</code>: 用于开启一个事务，它总是返回OK。 MULTI执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中</li>
<li><code>EXEC</code>：执行所有事务块内的命令。返回事务块内所有命令的返回值，按命令执行的先后顺序排列。 当操作被打断时，返回空值 nil </li>
<li><code>DISCARD</code>：清空事务队列，并放弃执行事务， 并且客户端会从事务状态中退出</li>
<li>WATCH：Redis的乐观锁机制，利用compare-and-set（CAS）原理，可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行</li>
</ul>
<h2 id="4-8-Redis的Key过期策略"><a href="#4-8-Redis的Key过期策略" class="headerlink" title="4.8.Redis的Key过期策略"></a>4.8.Redis的Key过期策略</h2><p>Redis是内存存储，如果key永不过期，就会导致内存占用越来越多，因此会采用：定期删除、惰性删除结合内存的淘汰机制来清理内存。</p>
<ul>
<li>定期删除：redis默认每隔100ms检查，是否有过期的key,有过期key则删除。需要说明的是，redis不是每个100ms将所有的key检查一次，而是随机抽取进行检查，因为如果对全部key检查，会占用过多资源。因此，没有抽查到的key就不会删除，这样内存占用依然会越来越多</li>
<li>惰性删除：当获取某个key的时候，redis会检查一下key是否有过期时间，是否已经过期，如果过期就会删除</li>
</ul>
<p>但是依据上面的两种策略，依然会有漏网之鱼（比如过期了，一直没有被抽查到，也没有人访问的key)，这样内存也会耗尽。</p>
<p>因此当redis内存不足时，会采用淘汰机制，删除一些Key，包括下面的策略：</p>
<ul>
<li>volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</li>
<li>volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li>
<li>volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</li>
<li>allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰</li>
<li>allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰</li>
<li>no-enviction：禁止驱逐数据，新写入操作会报错</li>
</ul>
<p>注意：如果没有设置 过期时间的key, 并且淘汰机制是volatile-lru, volatile-random 和 volatile-ttl 中的一个，那么就无法实现淘汰，与no-eviction基本上一致。</p>
<h2 id="4-9-Redis在项目中的哪些地方有用到，解决什么问题？"><a href="#4-9-Redis在项目中的哪些地方有用到，解决什么问题？" class="headerlink" title="4.9.Redis在项目中的哪些地方有用到，解决什么问题？"></a>4.9.Redis在项目中的哪些地方有用到，解决什么问题？</h2><p>（1）共享session</p>
<p>在分布式系统下，服务会部署在不同的tomcat，因此多个tomcat的session无法共享，以前存储在session中的数据无法实现共享，可以用redis代替session，解决分布式系统间数据共享问题。</p>
<p>（2）数据缓存</p>
<p>Redis采用内存存储，读写效率较高。我们可以把数据库的访问频率高的热点数据存储到redis中，这样用户请求时优先从redis中读取，减少数据库压力，提高并发能力。</p>
<p>（3）异步队列</p>
<p>Reids在内存存储引擎领域的一大优点是提供 list 和 set 操作，这使得Redis能作为一个很好的消息队列平台来使用。而且Redis中还有pub&#x2F;sub这样的专用结构，用于1对N的消息通信模式。</p>
<p>（4）排行榜&#x2F;计数器</p>
<p>Redis在内存中对数字进行递增或递减的操作实现的非常好。集合（Set）和有序集合（Sorted Set）也使得我们在执行这些操作的时候变的非常简单，Redis只是正好提供了这两种数据结构。</p>
<p>（5）分布式锁</p>
<p>Redis中的乐观锁机制，可以帮助我们实现分布式锁的效果，用于解决分布式系统下的多线程安全问题</p>
<h2 id="4-10-Redis的缓存击穿（热点Key问题）、缓存雪崩、缓存穿透问题及解决方案"><a href="#4-10-Redis的缓存击穿（热点Key问题）、缓存雪崩、缓存穿透问题及解决方案" class="headerlink" title="4.10.Redis的缓存击穿（热点Key问题）、缓存雪崩、缓存穿透问题及解决方案"></a>4.10.Redis的缓存击穿（热点Key问题）、缓存雪崩、缓存穿透问题及解决方案</h2><h3 id="1）缓存穿透"><a href="#1）缓存穿透" class="headerlink" title="1）缓存穿透"></a>1）缓存穿透</h3><p>一般的缓存系统，都是按照key去缓存查询，如果不存在对应的value，就应该去后端系统查找（比如DB）。一些恶意的请求会故意查询不存在的key,请求量很大，就会对后端系统造成很大的压力。这就叫做缓存穿透。</p>
<p>如何避免？</p>
<ul>
<li>对查询结果为空的情况也进行缓存，缓存时间设置短一点，或者该key对应的数据insert了之后重置缓存。</li>
<li>利用布隆过滤器，对不存在的key进行判断过滤。</li>
</ul>
<h3 id="2）缓存雪崩"><a href="#2）缓存雪崩" class="headerlink" title="2）缓存雪崩"></a>2）缓存雪崩</h3><p>缓存雪崩，是指在某一个时间段，缓存集中过期失效。对这批数据的访问查询，都落到了数据库上，对于数据库而言，就会产生周期性的压力波峰。</p>
<p>解决方案：</p>
<ul>
<li>数据分类分批处理：采取不同分类数据，缓存不同周期</li>
<li>热点数据缓存时间长一些，冷门数据缓存时间短一些</li>
<li>避免redis节点宕机引起雪崩，搭建主从集群，保证高可用</li>
</ul>
<h3 id="3）缓存击穿"><a href="#3）缓存击穿" class="headerlink" title="3）缓存击穿"></a>3）缓存击穿</h3><p>缓存击穿，是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。</p>
<p>解决思路：热点的key永不过期即可。</p>
<h2 id="4-11-Redis实现分布式锁"><a href="#4-11-Redis实现分布式锁" class="headerlink" title="4.11.Redis实现分布式锁"></a>4.11.Redis实现分布式锁</h2><p>分布式锁要满足的条件：</p>
<ul>
<li>多进程互斥：同一时刻，只有一个进程可以获取锁</li>
<li>保证锁可以释放：任务结束或出现异常，锁一定要释放，避免死锁</li>
<li>阻塞锁（可选）：获取锁失败时可否重试</li>
<li>重入锁（可选）：获取锁的代码递归调用时，依然可以获取锁</li>
</ul>
<h3 id="1）最基本的分布式锁："><a href="#1）最基本的分布式锁：" class="headerlink" title="1）最基本的分布式锁："></a>1）最基本的分布式锁：</h3><p>利用Redis的setnx命令，这个命令的特征时如果多次执行，只有第一次执行会成功，可以实现<code>互斥</code>的效果。但是为了保证服务宕机时也可以释放锁，需要利用expire命令给锁设置一个有效期</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setnx lock thread-01 # 尝试获取锁</span><br><span class="line">expire lock 10 # 设置有效期</span><br></pre></td></tr></table></figure>

<p><strong>面试官问题1</strong>：如果expire之前服务宕机怎么办？</p>
<p>要保证setnx和expire命令的原子性。redis的set命令可以满足：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set key value [NX] [EX time] </span><br></pre></td></tr></table></figure>

<p>需要添加nx和ex的选项：</p>
<ul>
<li>NX：与setnx一致，第一次执行成功</li>
<li>EX：设置过期时间</li>
</ul>
<p><strong>面试官问题2</strong>：释放锁的时候，如果自己的锁已经过期了，此时会出现安全漏洞，如何解决？</p>
<p>在锁中存储当前进程和线程标识，释放锁时对锁的标识判断，如果是自己的则删除，不是则放弃操作。</p>
<p>但是这两步操作要保证原子性，需要通过Lua脚本来实现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if redis.call(&quot;get&quot;,KEYS[1]) == ARGV[1] then</span><br><span class="line">    redis.call(&quot;del&quot;,KEYS[1])</span><br><span class="line">end</span><br></pre></td></tr></table></figure>



<h3 id="2-可重入分布式锁"><a href="#2-可重入分布式锁" class="headerlink" title="2)可重入分布式锁"></a>2)可重入分布式锁</h3><p>如果有重入的需求，则除了在锁中记录进程标识，还要记录重试次数，流程如下：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212142558.png" alt="1574824172228"> </p>
<p>下面我们假设锁的key为“<code>lock</code>”，hashKey是当前线程的id：“<code>threadId</code>”，锁自动释放时间假设为20</p>
<p>获取锁的步骤：</p>
<ul>
<li>1、判断lock是否存在 <code>EXISTS lock</code><ul>
<li>存在，说明有人获取锁了，下面判断是不是自己的锁<ul>
<li>判断当前线程id作为hashKey是否存在：<code>HEXISTS lock threadId</code><ul>
<li>不存在，说明锁已经有了，且不是自己获取的，锁获取失败，end</li>
<li>存在，说明是自己获取的锁，重入次数+1：<code>HINCRBY lock threadId 1</code>，去到步骤3</li>
</ul>
</li>
</ul>
</li>
<li>2、不存在，说明可以获取锁，<code>HSET key threadId 1</code></li>
<li>3、设置锁自动释放时间，<code>EXPIRE lock 20</code></li>
</ul>
</li>
</ul>
<p>释放锁的步骤：</p>
<ul>
<li>1、判断当前线程id作为hashKey是否存在：<code>HEXISTS lock threadId</code><ul>
<li>不存在，说明锁已经失效，不用管了</li>
<li>存在，说明锁还在，重入次数减1：<code>HINCRBY lock threadId -1</code>，获取新的重入次数</li>
</ul>
</li>
<li>2、判断重入次数是否为0：<ul>
<li>为0，说明锁全部释放，删除key：<code>DEL lock</code></li>
<li>大于0，说明锁还在使用，重置有效时间：<code>EXPIRE lock 20</code></li>
</ul>
</li>
</ul>
<p>对应的Lua脚本如下：</p>
<p>首先是获取锁：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> key = KEYS[<span class="number">1</span>]; <span class="comment">-- 锁的key</span></span><br><span class="line"><span class="keyword">local</span> threadId = ARGV[<span class="number">1</span>]; <span class="comment">-- 线程唯一标识</span></span><br><span class="line"><span class="keyword">local</span> releaseTime = ARGV[<span class="number">2</span>]; <span class="comment">-- 锁的自动释放时间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(redis.call(<span class="string">&#x27;exists&#x27;</span>, key) == <span class="number">0</span>) <span class="keyword">then</span> <span class="comment">-- 判断是否存在</span></span><br><span class="line">	redis.call(<span class="string">&#x27;hset&#x27;</span>, key, threadId, <span class="string">&#x27;1&#x27;</span>); <span class="comment">-- 不存在, 获取锁</span></span><br><span class="line">	redis.call(<span class="string">&#x27;expire&#x27;</span>, key, releaseTime); <span class="comment">-- 设置有效期</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>; <span class="comment">-- 返回结果</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(redis.call(<span class="string">&#x27;hexists&#x27;</span>, key, threadId) == <span class="number">1</span>) <span class="keyword">then</span> <span class="comment">-- 锁已经存在，判断threadId是否是自己	</span></span><br><span class="line">	redis.call(<span class="string">&#x27;hincrby&#x27;</span>, key, threadId, <span class="string">&#x27;1&#x27;</span>); <span class="comment">-- 不存在, 获取锁，重入次数+1</span></span><br><span class="line">	redis.call(<span class="string">&#x27;expire&#x27;</span>, key, releaseTime); <span class="comment">-- 设置有效期</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>; <span class="comment">-- 返回结果</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; <span class="comment">-- 代码走到这里,说明获取锁的不是自己，获取锁失败</span></span><br></pre></td></tr></table></figure>

<p>然后是释放锁：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> key = KEYS[<span class="number">1</span>]; <span class="comment">-- 锁的key</span></span><br><span class="line"><span class="keyword">local</span> threadId = ARGV[<span class="number">1</span>]; <span class="comment">-- 线程唯一标识</span></span><br><span class="line"><span class="keyword">local</span> releaseTime = ARGV[<span class="number">2</span>]; <span class="comment">-- 锁的自动释放时间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;HEXISTS&#x27;</span>, key, threadId) == <span class="number">0</span>) <span class="keyword">then</span> <span class="comment">-- 判断当前锁是否还是被自己持有</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>; <span class="comment">-- 如果已经不是自己，则直接返回</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">local</span> count = redis.call(<span class="string">&#x27;HINCRBY&#x27;</span>, key, threadId, <span class="number">-1</span>); <span class="comment">-- 是自己的锁，则重入次数-1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (count &gt; <span class="number">0</span>) <span class="keyword">then</span> <span class="comment">-- 判断是否重入次数是否已经为0</span></span><br><span class="line">    redis.call(<span class="string">&#x27;EXPIRE&#x27;</span>, key, releaseTime); <span class="comment">-- 大于0说明不能释放锁，重置有效期然后返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    redis.call(<span class="string">&#x27;DEL&#x27;</span>, key); <span class="comment">-- 等于0说明可以释放锁，直接删除</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>



<h3 id="3-高可用的锁"><a href="#3-高可用的锁" class="headerlink" title="3)高可用的锁"></a>3)高可用的锁</h3><p><code>面试官问题</code>：redis分布式锁依赖与redis，如果redis宕机则锁失效。如何解决？</p>
<p>此时大多数同学会回答说：搭建主从集群，做数据备份。</p>
<p>这样就进入了陷阱，因为面试官的下一个问题就来了：</p>
<p><code>面试官问题</code>：如果搭建主从集群做数据备份时，进程A获取锁，master还没有把数据备份到slave，master宕机，slave升级为master，此时原来锁失效，其它进程也可以获取锁，出现安全问题。如何解决？</p>
<p>关于这个问题，Redis官网给出了解决方案，使用RedLock思路可以解决：</p>
<blockquote>
<p>在Redis的分布式环境中，我们假设有N个Redis master。这些节点完全互相独立，不存在主从复制或者其他集群协调机制。之前我们已经描述了在Redis单实例下怎么安全地获取和释放锁。我们确保将在每（N)个实例上使用此方法获取和释放锁。在这个样例中，我们假设有5个Redis master节点，这是一个比较合理的设置，所以我们需要在5台机器上面或者5台虚拟机上面运行这些实例，这样保证他们不会同时都宕掉。</p>
<p>为了取到锁，客户端应该执行以下操作:</p>
<ol>
<li>获取当前Unix时间，以毫秒为单位。</li>
<li>依次尝试从N个实例，使用相同的key和随机值获取锁。在步骤2，当向Redis设置锁时,客户端应该设置一个网络连接和响应超时时间，这个超时时间应该小于锁的失效时间。例如你的锁自动失效时间为10秒，则超时时间应该在5-50毫秒之间。这样可以避免服务器端Redis已经挂掉的情况下，客户端还在死死地等待响应结果。如果服务器端没有在规定时间内响应，客户端应该尽快尝试另外一个Redis实例。</li>
<li>客户端使用当前时间减去开始获取锁时间（步骤1记录的时间）就得到获取锁使用的时间。当且仅当从大多数（这里是3个节点）的Redis节点都取到锁，并且使用的时间小于锁失效时间时，锁才算获取成功。</li>
<li>如果取到了锁，key的真正有效时间等于有效时间减去获取锁所使用的时间（步骤3计算的结果）。</li>
<li>如果因为某些原因，获取锁失败（<em>没有</em>在至少N&#x2F;2+1个Redis实例取到锁或者取锁时间已经超过了有效时间），客户端应该在所有的Redis实例上进行解锁（即便某些Redis实例根本就没有加锁成功）。</li>
</ol>
</blockquote>
<h1 id="5-秒杀相关"><a href="#5-秒杀相关" class="headerlink" title="5.秒杀相关"></a>5.秒杀相关</h1><h2 id="5-1-锁，减库存"><a href="#5-1-锁，减库存" class="headerlink" title="5.1.锁，减库存"></a>5.1.锁，减库存</h2><h3 id="1）悲观锁"><a href="#1）悲观锁" class="headerlink" title="1）悲观锁"></a>1）悲观锁</h3><p>总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。</p>
<p>以减库存为例来说：</p>
<p>减库存先要查询库存，判断库存是否充足，然后再减库存。</p>
<p>如果我们查询库存后，判断库存是充足的，此时有人修改了库存，则我们的判断就不准确了，此时写数据就会又库存超卖的风险。</p>
<p>必须保证从查询开始就锁定数据，保证其它人无法操作，可以通过下列方式实现：</p>
<ul>
<li><p>同步方法或Synchronized：适用于单点项目，分布式下会失效。</p>
</li>
<li><p>分布式锁：把整个减库存方法通过分布式锁锁定，不允许他人执行减库存逻辑</p>
</li>
<li><p>数据库锁：在执行查询语句时，在语句后面跟上 for update，则查询即会对数据加锁，其它人就无法操作了。</p>
</li>
</ul>
<h3 id="2）乐观锁"><a href="#2）乐观锁" class="headerlink" title="2）乐观锁"></a>2）乐观锁</h3><p>总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的AtomicInteger就是使用了乐观锁的一种实现方式CAS实现的。</p>
<p>以减库存为例来说：</p>
<p>减库存先要查询库存，判断库存是否充足，然后再减库存。</p>
<p>如果我们查询库存后，判断库存是充足的，此时有人修改了库存，则我们的判断就不准确了，此时写数据就会又库存超卖的风险。</p>
<p>我们假设自己减库存时没有其它人在操作，不过执行sql时对库存检查即可。</p>
<h4 id="方式1：版本号"><a href="#方式1：版本号" class="headerlink" title="方式1：版本号"></a>方式1：版本号</h4><p>在库存表添加version字段，每次修改数据都对version执行+1操做。</p>
<p>减库存步骤：</p>
<ul>
<li>查询version值，例如此时version是20</li>
<li>执行减库存，在where条件中判断 version值是否等于查询到的version值：<ul>
<li>UPDATE tb_stock SET stock &#x3D; stock - 1, version &#x3D; 21 WHERE id &#x3D; 101 AND version &#x3D; 20</li>
</ul>
</li>
</ul>
<h4 id="方式2：判断库存"><a href="#方式2：判断库存" class="headerlink" title="方式2：判断库存"></a>方式2：判断库存</h4><p>因为库存本身就是数值，可以用库存来做检查，代替版本号：</p>
<ul>
<li>查询库存，例如值是20，需要减库存值为 2</li>
<li>减库存：UPDATE tb_stock SET stock &#x3D; 18 WHERE id &#x3D; 101 AND stock &#x3D; 20</li>
</ul>
<p>这种方式可能有安全漏洞，即CAS这ABA问题，比如我查询的时候是20，有人购买了一个商品，变成了19，然后又有人退货，库存恢复为20。我们认为库存没变，其实此时已经有人修改了数据了。</p>
<h3 id="方式3：无符号数"><a href="#方式3：无符号数" class="headerlink" title="方式3：无符号数"></a>方式3：无符号数</h3><p>库存是数字，如果我们把库存变成无符号数字，则数据库默认不能为负，如果减库存传入的值为负数，数据库直接报错，因此减库存时无需做特殊判断，直接减库存即可。</p>
<h3 id="3）使用场景"><a href="#3）使用场景" class="headerlink" title="3）使用场景"></a>3）使用场景</h3><p>乐观锁适用于写比较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以一般多写的场景下用悲观锁就比较合适。</p>
<h2 id="5-2-秒杀思路"><a href="#5-2-秒杀思路" class="headerlink" title="5.2.秒杀思路"></a>5.2.秒杀思路</h2><p>秒杀问题的难点：</p>
<ul>
<li>高并发，服务端tomcat并发能力有限</li>
<li>减库存多线程执行容易超卖</li>
<li>下单业务流程、业务链路较长，耗时较久，服务QPS低</li>
<li>秒杀页面请求量大</li>
<li>秒杀机器人防范</li>
</ul>
<p>具体实现：</p>
<h3 id="5-2-1-前端优化"><a href="#5-2-1-前端优化" class="headerlink" title="5.2.1.前端优化"></a>5.2.1.前端优化</h3><p>前端是直接与用户交互的地方，并发最高，一般有下面手段去处理：</p>
<h4 id="1）页面静态化"><a href="#1）页面静态化" class="headerlink" title="1）页面静态化"></a>1）<strong>页面静态化</strong></h4><p>将秒杀商品页面静态化处理，少量动态数据通过ajax异步加载，访问商品页面无需去数据库查询商品信息，大大提高页面加载的速度。</p>
<h4 id="2）CDN服务"><a href="#2）CDN服务" class="headerlink" title="2）CDN服务"></a>2）<strong>CDN服务</strong></h4><p>静态化可以让页面响应速度增加，但是如果我们的静态资源服务器压力过大，也可以考虑购买CDN服务，将静态资源部署到CDN服务，一方面提高响应速度，另一方面减轻对服务端压力</p>
<h4 id="3）秒杀限流"><a href="#3）秒杀限流" class="headerlink" title="3）秒杀限流"></a>3）秒杀限流</h4><p>秒杀按钮点击时，不立即向服务端发送请求，而是要求回答验证问题答案，回答结束才发送秒杀请求。好处有2点：</p>
<ul>
<li>用户回答问题耗时不同，把用户发送请求分散到不同事件段</li>
<li>限制秒杀机器人或爬虫的恶意访问</li>
</ul>
<h4 id="4）动态秒杀按钮"><a href="#4）动态秒杀按钮" class="headerlink" title="4）动态秒杀按钮"></a>4）动态秒杀按钮</h4><p>为了避免秒杀开始前有人提前获取秒杀地址并编写秒杀机器人，我们可以把秒杀按钮利用JS绑定，秒杀开始前对应的JS文件内容设置为点击后禁止发送请求。</p>
<p>秒杀开始时，我们再修改对应的JS文件内容，填写真实发送请求地址，这样开始前不会有人知道秒杀的地址信息。</p>
<h4 id="5）避免重复连续点击"><a href="#5）避免重复连续点击" class="headerlink" title="5）避免重复连续点击"></a>5）避免重复连续点击</h4><p>点击秒杀后，按钮禁用，一定时间后开启使用</p>
<h3 id="5-2-2-网关"><a href="#5-2-2-网关" class="headerlink" title="5.2.2.网关"></a>5.2.2.网关</h3><p>如果采用Nginx作为网关，则可以再Nginx中对用户请求限流，只放行部分用户请求到达微服务群。</p>
<h3 id="5-2-3-微服务"><a href="#5-2-3-微服务" class="headerlink" title="5.2.3.微服务"></a>5.2.3.微服务</h3><h4 id="1）限流"><a href="#1）限流" class="headerlink" title="1）限流"></a>1）限流</h4><p>RateLimiter是guava提供的基于令牌桶算法的限流实现类，通过调整生成token的速率来限制用户频繁访问秒杀页面，从而达到防止超大流量冲垮系统。（令牌桶算法的原理是系统会以一个恒定的速度往桶里放入令牌，而如果请求需要被处理，则需要先从桶里获取一个令牌，当桶里没有令牌可取时，则拒绝服务。</p>
<h4 id="2）预减库存"><a href="#2）预减库存" class="headerlink" title="2）预减库存"></a>2）预减库存</h4><p>请求到达服务端，并发依然很高，数据库直接处理肯定难以接受。</p>
<p>我们可以把秒杀的商品库存存入Redis，利用Redis中的库存判断秒杀商品是否充足，再Redis中完成抢购资格判断、减库存行为。</p>
<p>但是，尽管redis单线程运行，执行Redis的Java代码依然有线程安全风险，所以为了保证redis中减库存判断的安全性，这里推荐使用Lua脚本编写相关逻辑，保证代码执行的原子性。</p>
<h4 id="3）流量削峰，异步写数据"><a href="#3）流量削峰，异步写数据" class="headerlink" title="3）流量削峰，异步写数据"></a>3）流量削峰，异步写数据</h4><p>经过Redis的判断处理，单个商品放行的请求数量基本就是库存剩余量，请求大大减少，但是如果参与秒杀商品较多，用户并发依然很高，数据库可能依然难以处理，所以还需要把下的业务异步执行，实现流量削峰。</p>
<p>用户在redis中获取下单资格后，不要去执行下单逻辑，而是把用户及资格信息发送到MQ中，然后就返回用户抢购成功的结果。</p>
<p>此时服务端下单的业务监听RabbitMQ，逐个处理MQ中的下单消息，利用MQ来缓存高并发的流量。变同步写数据为异步写数据，大大缩短业务链路，提高并发。</p>
<p>流程图：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212142559.png" alt="1574835214511"> </p>
<p>监听到MQ后的处理逻辑，关键时如何防止库存超卖，这一点我们在上面的5.1中已经讲过，不再赘述。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212142560.png" alt="1574835276351"> </p>
<p>秒杀项目相关资料：<a target="_blank" rel="noopener" href="https://github.com/qiurunze123/miaosha">https://github.com/qiurunze123/miaosha</a></p>
<h1 id="6-分布式事务"><a href="#6-分布式事务" class="headerlink" title="6.分布式事务"></a>6.分布式事务</h1><p>详见另一份文档：分布式事务解决方案</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">MingwHuang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2021/12/21/leyou/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/">http://example.com/2021/12/21/leyou/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">MingwHuang's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Leyou/">Leyou</a></div><div class="post_share"><div class="social-share" data-image="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272046348.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202172251674.png" target="_blank"><img class="post-qr-code-img" src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202172251674.png" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202172251973.png" target="_blank"><img class="post-qr-code-img" src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202172251973.png" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/12/21/leyou/leyou%E9%9D%A2%E8%AF%95%E7%89%88/"><img class="prev-cover" src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272047554.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">leyou常见问题</div></div></a></div><div class="next-post pull-right"><a href="/2021/12/21/leyou/leyou/"><img class="next-cover" src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272046990.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">leyou</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/12/21/leyou/Java%E6%A1%86%E6%9E%B6/" title="Spring"><img class="cover" src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272046348.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-21</div><div class="title">Spring</div></div></a></div><div><a href="/2021/12/21/leyou/Leyou%E7%AC%94%E8%AE%B0/" title="leyou项目搭建"><img class="cover" src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272047300.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-21</div><div class="title">leyou项目搭建</div></div></a></div><div><a href="/2021/12/21/leyou/leyou%E9%9D%A2%E8%AF%95%E7%89%88/" title="leyou常见问题"><img class="cover" src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272047554.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-21</div><div class="title">leyou常见问题</div></div></a></div><div><a href="/2021/12/21/leyou/%E5%9F%BA%E4%BA%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%9A%84%E7%B1%BB%E4%BA%AC%E4%B8%9C%E5%B9%B3%E5%8F%B0%E7%BB%93%E9%A2%98%E6%8A%A5%E5%91%8A%20/" title="Leyou结题报告"><img class="cover" src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272046990.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-21</div><div class="title">Leyou结题报告</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272113875.JPG" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">MingwHuang</div><div class="author-info__description">朝花夕拾 聊以记之</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">42</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">42</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">21</div></a></div></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/HuangMingwang" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:1125385880@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站域名：http://mingwzi.cn</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-SpringBoot%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">1.</span> <span class="toc-text">1.SpringBoot面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-SpringBoot%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.1.</span> <span class="toc-text">1.1.SpringBoot的作用是什么?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-SpringBoot%E7%9A%84%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">1.2.</span> <span class="toc-text">1.2.SpringBoot的自动配置原理？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E6%9C%89%E6%B2%A1%E6%9C%89%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%87SpringBoot%E7%9A%84stater%EF%BC%9F"><span class="toc-number">1.3.</span> <span class="toc-text">1.3.有没有自定义过SpringBoot的stater？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-SpringCloud%E7%9B%B8%E5%85%B3"><span class="toc-number">2.</span> <span class="toc-text">2.SpringCloud相关</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-0-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">2.1.</span> <span class="toc-text">2.0.微服务的优缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-SpringCloud%E5%92%8CDubbo%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.2.</span> <span class="toc-text">2.1.SpringCloud和Dubbo的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-RPC%E4%B8%8ERest%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88dubbo%E5%8D%8F%E8%AE%AE%E5%92%8CFeign%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%E7%9A%84%E5%B7%AE%E5%BC%82%EF%BC%89"><span class="toc-number">2.3.</span> <span class="toc-text">2.2.RPC与Rest的区别（dubbo协议和Feign远程调用的差异）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89Rest%E9%A3%8E%E6%A0%BC"><span class="toc-number">2.3.1.</span> <span class="toc-text">1）Rest风格</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89RPC"><span class="toc-number">2.3.2.</span> <span class="toc-text">2）RPC</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-Eureka%E5%92%8CZookeeper%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.4.</span> <span class="toc-text">2.3.Eureka和Zookeeper注册中心的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-SpringCloud%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">2.5.</span> <span class="toc-text">2.4.SpringCloud中的常用组件有哪些？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-RabbitMQ%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">3.</span> <span class="toc-text">3.RabbitMQ常见面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E4%BD%A0%E4%BB%AC%E5%85%AC%E5%8F%B8%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9%E4%BA%86RabbitMQ%E4%BA%A7%E5%93%81%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AFRocketMQ%E5%92%8CKafka%EF%BC%88%E9%97%AE%E5%8C%BA%E5%88%AB%EF%BC%89%EF%BC%9F"><span class="toc-number">3.1.</span> <span class="toc-text">3.1.你们公司为什么选择了RabbitMQ产品，而不是RocketMQ和Kafka（问区别）？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%93%AA%E4%BA%9B%E5%9C%B0%E6%96%B9%E4%BD%BF%E7%94%A8%E4%BA%86MQ%EF%BC%8C%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">3.2.</span> <span class="toc-text">3.2.在项目中哪些地方使用了MQ，解决了什么问题？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E8%A7%A3%E8%80%A6%E5%90%88"><span class="toc-number">3.2.1.</span> <span class="toc-text">1）解耦合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E6%B5%81%E9%87%8F%E5%89%8A%E5%B3%B0"><span class="toc-number">3.2.2.</span> <span class="toc-text">2）流量削峰</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%89%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8"><span class="toc-number">3.2.3.</span> <span class="toc-text">3）异步调用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81MQ%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8"><span class="toc-number">3.3.</span> <span class="toc-text">3.3.如何保证MQ的高可用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81MQ%E7%9A%84%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E6%80%A7%EF%BC%8C%E9%98%B2%E6%AD%A2%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1%EF%BC%9F"><span class="toc-number">3.4.</span> <span class="toc-text">3.4.如何保证MQ的消息可靠性，防止消息丢失？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89RabbitMQ"><span class="toc-number">3.4.1.</span> <span class="toc-text">1）RabbitMQ</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89kafka"><span class="toc-number">3.4.2.</span> <span class="toc-text">2）kafka</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2MQ%E6%B6%88%E6%81%AF%E7%9A%84%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9%EF%BC%9F"><span class="toc-number">3.5.</span> <span class="toc-text">3.5.如何防止MQ消息的重复消费？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3MQ%E7%9A%84%E6%B6%88%E6%81%AF%E5%A0%86%E7%A7%AF%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">3.6.</span> <span class="toc-text">3.6.如何解决MQ的消息堆积问题？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-7-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81MQ%E6%B6%88%E6%81%AF%E7%9A%84%E6%9C%89%E5%BA%8F%E6%80%A7%EF%BC%9F"><span class="toc-number">3.7.</span> <span class="toc-text">3.7.如何保证MQ消息的有序性？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-Redis%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98"><span class="toc-number">4.</span> <span class="toc-text">4.Redis相关问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-Redis%E4%B8%8EMemcache%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">4.1.</span> <span class="toc-text">4.1.Redis与Memcache的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-Redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E6%A1%88%E7%94%B1%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">4.2.</span> <span class="toc-text">4.2.Redis的持久化方案由哪些？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89RDB%EF%BC%9A"><span class="toc-number">4.2.1.</span> <span class="toc-text">1）RDB：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89AOF"><span class="toc-number">4.2.2.</span> <span class="toc-text">2）AOF:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-Redis%E7%9A%84%E9%9B%86%E7%BE%A4%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">4.3.</span> <span class="toc-text">4.3.Redis的集群方式有哪些？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E4%B8%BB%E4%BB%8E%E9%9B%86%E7%BE%A4"><span class="toc-number">4.3.1.</span> <span class="toc-text">1）主从集群</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4"><span class="toc-number">4.3.2.</span> <span class="toc-text">2）分片集群</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-Redis%E7%9A%84%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0%E9%9B%86%E7%BE%A4%E5%8A%A8%E6%80%81%E4%BC%B8%E7%BC%A9%EF%BC%88hash%E6%A7%BD%E5%8E%9F%E7%90%86%EF%BC%89"><span class="toc-number">4.4.</span> <span class="toc-text">4.4.Redis的分片集群如何做到集群动态伸缩（hash槽原理）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-Redis%E7%9A%84%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">4.5.</span> <span class="toc-text">4.5.Redis的常用数据类型有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-6-Redis%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E5%B9%B6%E5%8F%91%E8%83%BD%E5%8A%9B%E8%BF%99%E4%B9%88%E5%BC%BA"><span class="toc-number">4.6.</span> <span class="toc-text">4.6.Redis是单线程，为什么并发能力这么强?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-7-%E8%81%8A%E4%B8%80%E4%B8%8BRedis%E4%BA%8B%E5%8A%A1%E6%9C%BA%E5%88%B6"><span class="toc-number">4.7.</span> <span class="toc-text">4.7.聊一下Redis事务机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-8-Redis%E7%9A%84Key%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5"><span class="toc-number">4.8.</span> <span class="toc-text">4.8.Redis的Key过期策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-9-Redis%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E5%93%AA%E4%BA%9B%E5%9C%B0%E6%96%B9%E6%9C%89%E7%94%A8%E5%88%B0%EF%BC%8C%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">4.9.</span> <span class="toc-text">4.9.Redis在项目中的哪些地方有用到，解决什么问题？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-10-Redis%E7%9A%84%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%EF%BC%88%E7%83%AD%E7%82%B9Key%E9%97%AE%E9%A2%98%EF%BC%89%E3%80%81%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E3%80%81%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">4.10.</span> <span class="toc-text">4.10.Redis的缓存击穿（热点Key问题）、缓存雪崩、缓存穿透问题及解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-number">4.10.1.</span> <span class="toc-text">1）缓存穿透</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-number">4.10.2.</span> <span class="toc-text">2）缓存雪崩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%89%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="toc-number">4.10.3.</span> <span class="toc-text">3）缓存击穿</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-11-Redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">4.11.</span> <span class="toc-text">4.11.Redis实现分布式锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E6%9C%80%E5%9F%BA%E6%9C%AC%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%EF%BC%9A"><span class="toc-number">4.11.1.</span> <span class="toc-text">1）最基本的分布式锁：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%8F%AF%E9%87%8D%E5%85%A5%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">4.11.2.</span> <span class="toc-text">2)可重入分布式锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%AB%98%E5%8F%AF%E7%94%A8%E7%9A%84%E9%94%81"><span class="toc-number">4.11.3.</span> <span class="toc-text">3)高可用的锁</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E7%A7%92%E6%9D%80%E7%9B%B8%E5%85%B3"><span class="toc-number">5.</span> <span class="toc-text">5.秒杀相关</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E9%94%81%EF%BC%8C%E5%87%8F%E5%BA%93%E5%AD%98"><span class="toc-number">5.1.</span> <span class="toc-text">5.1.锁，减库存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-number">5.1.1.</span> <span class="toc-text">1）悲观锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E4%B9%90%E8%A7%82%E9%94%81"><span class="toc-number">5.1.2.</span> <span class="toc-text">2）乐观锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F1%EF%BC%9A%E7%89%88%E6%9C%AC%E5%8F%B7"><span class="toc-number">5.1.2.1.</span> <span class="toc-text">方式1：版本号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F2%EF%BC%9A%E5%88%A4%E6%96%AD%E5%BA%93%E5%AD%98"><span class="toc-number">5.1.2.2.</span> <span class="toc-text">方式2：判断库存</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F3%EF%BC%9A%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B0"><span class="toc-number">5.1.3.</span> <span class="toc-text">方式3：无符号数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%89%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">5.1.4.</span> <span class="toc-text">3）使用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E7%A7%92%E6%9D%80%E6%80%9D%E8%B7%AF"><span class="toc-number">5.2.</span> <span class="toc-text">5.2.秒杀思路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-1-%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96"><span class="toc-number">5.2.1.</span> <span class="toc-text">5.2.1.前端优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89%E9%A1%B5%E9%9D%A2%E9%9D%99%E6%80%81%E5%8C%96"><span class="toc-number">5.2.1.1.</span> <span class="toc-text">1）页面静态化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89CDN%E6%9C%8D%E5%8A%A1"><span class="toc-number">5.2.1.2.</span> <span class="toc-text">2）CDN服务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89%E7%A7%92%E6%9D%80%E9%99%90%E6%B5%81"><span class="toc-number">5.2.1.3.</span> <span class="toc-text">3）秒杀限流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%EF%BC%89%E5%8A%A8%E6%80%81%E7%A7%92%E6%9D%80%E6%8C%89%E9%92%AE"><span class="toc-number">5.2.1.4.</span> <span class="toc-text">4）动态秒杀按钮</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%EF%BC%89%E9%81%BF%E5%85%8D%E9%87%8D%E5%A4%8D%E8%BF%9E%E7%BB%AD%E7%82%B9%E5%87%BB"><span class="toc-number">5.2.1.5.</span> <span class="toc-text">5）避免重复连续点击</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-2-%E7%BD%91%E5%85%B3"><span class="toc-number">5.2.2.</span> <span class="toc-text">5.2.2.网关</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-3-%E5%BE%AE%E6%9C%8D%E5%8A%A1"><span class="toc-number">5.2.3.</span> <span class="toc-text">5.2.3.微服务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89%E9%99%90%E6%B5%81"><span class="toc-number">5.2.3.1.</span> <span class="toc-text">1）限流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89%E9%A2%84%E5%87%8F%E5%BA%93%E5%AD%98"><span class="toc-number">5.2.3.2.</span> <span class="toc-text">2）预减库存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89%E6%B5%81%E9%87%8F%E5%89%8A%E5%B3%B0%EF%BC%8C%E5%BC%82%E6%AD%A5%E5%86%99%E6%95%B0%E6%8D%AE"><span class="toc-number">5.2.3.3.</span> <span class="toc-text">3）流量削峰，异步写数据</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="toc-number">6.</span> <span class="toc-text">6.分布式事务</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/02/26/%E9%9D%A2%E8%AF%95/Redis/" title="Redis"><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272046348.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis"/></a><div class="content"><a class="title" href="/2022/02/26/%E9%9D%A2%E8%AF%95/Redis/" title="Redis">Redis</a><time datetime="2022-02-26T06:21:50.000Z" title="发表于 2022-02-26 14:21:50">2022-02-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/02/25/K8S/" title="K8S"><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272047554.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="K8S"/></a><div class="content"><a class="title" href="/2022/02/25/K8S/" title="K8S">K8S</a><time datetime="2022-02-25T14:38:23.000Z" title="发表于 2022-02-25 22:38:23">2022-02-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/02/25/Chaos/Chaos/" title="Chaos"><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272047300.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Chaos"/></a><div class="content"><a class="title" href="/2022/02/25/Chaos/Chaos/" title="Chaos">Chaos</a><time datetime="2022-02-25T14:38:23.000Z" title="发表于 2022-02-25 22:38:23">2022-02-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/02/20/Mac-%E6%B7%B1%E5%BA%A6%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/" title="Mac 深度使用技巧"><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272046012.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Mac 深度使用技巧"/></a><div class="content"><a class="title" href="/2022/02/20/Mac-%E6%B7%B1%E5%BA%A6%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/" title="Mac 深度使用技巧">Mac 深度使用技巧</a><time datetime="2022-02-20T14:38:23.000Z" title="发表于 2022-02-20 22:38:23">2022-02-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/02/15/%E9%9D%A2%E8%AF%95/MySQL/" title="MySQL"><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272047300.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL"/></a><div class="content"><a class="title" href="/2022/02/15/%E9%9D%A2%E8%AF%95/MySQL/" title="MySQL">MySQL</a><time datetime="2022-02-15T10:46:58.000Z" title="发表于 2022-02-15 18:46:58">2022-02-15</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By MingwHuang</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a><span class="footer-separator">|</span><a href="https://beian.miit.gov.cn/" target="_blank">赣ICP备2022001353号-1</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>