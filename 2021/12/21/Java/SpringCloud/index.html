<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>SpringCloud | MingwHuang's Blog</title><meta name="keywords" content="SpringCloud"><meta name="author" content="MingwHuang"><meta name="copyright" content="MingwHuang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="第一章 微服务架构概述1.1 系统进化理论概述集中式系统： 集中式系统也叫单体应用，就是把所有的程序、功能、模块都集中到一个项目中，部署在一台服务器上，从而对外提供服务； 分布式系统 分布式系统就是把所有的程序、功能拆分成不同的子系统，部署在多台不同的服务器上，这些子系统相互协作共同对外提供服务，而对用户而言他并不知道后台是多个子系统和多台服务器在提供服务，在使用上和集中式系统一样； 集中式系统跟">
<meta property="og:type" content="article">
<meta property="og:title" content="SpringCloud">
<meta property="og:url" content="http://mingwzi.cn/2021/12/21/Java/SpringCloud/index.html">
<meta property="og:site_name" content="MingwHuang&#39;s Blog">
<meta property="og:description" content="第一章 微服务架构概述1.1 系统进化理论概述集中式系统： 集中式系统也叫单体应用，就是把所有的程序、功能、模块都集中到一个项目中，部署在一台服务器上，从而对外提供服务； 分布式系统 分布式系统就是把所有的程序、功能拆分成不同的子系统，部署在多台不同的服务器上，这些子系统相互协作共同对外提供服务，而对用户而言他并不知道后台是多个子系统和多台服务器在提供服务，在使用上和集中式系统一样； 集中式系统跟">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272046348.jpg">
<meta property="article:published_time" content="2021-12-21T08:42:14.000Z">
<meta property="article:modified_time" content="2022-02-22T13:55:23.930Z">
<meta property="article:author" content="MingwHuang">
<meta property="article:tag" content="SpringCloud">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272046348.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://mingwzi.cn/2021/12/21/Java/SpringCloud/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":500},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'SpringCloud',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-02-22 21:55:23'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.1.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272113875.JPG" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">45</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">42</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272046348.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">MingwHuang's Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">SpringCloud</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-12-21T08:42:14.000Z" title="发表于 2021-12-21 16:42:14">2021-12-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-02-22T13:55:23.930Z" title="更新于 2022-02-22 21:55:23">2022-02-22</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="SpringCloud"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="第一章-微服务架构概述"><a href="#第一章-微服务架构概述" class="headerlink" title="第一章 微服务架构概述"></a>第一章 微服务架构概述</h1><h2 id="1-1-系统进化理论概述"><a href="#1-1-系统进化理论概述" class="headerlink" title="1.1 系统进化理论概述"></a>1.1 系统进化理论概述</h2><p><strong>集中式系统：</strong></p>
<p>集中式系统也叫单体应用，就是把所有的程序、功能、模块都集中到一个项目中，部署在一台服务器上，从而对外提供服务；</p>
<p><strong>分布式系统</strong></p>
<p>分布式系统就是把所有的程序、功能拆分成不同的子系统，部署在多台不同的服务器上，这些子系统相互协作共同对外提供服务，而对用户而言他并不知道后台是多个子系统和多台服务器在提供服务，在使用上和集中式系统一样；</p>
<p>集中式系统跟分布式系统是相反的两个概念，他们的区别体现在“合”与“分”。</p>
<h2 id="1-2-系统进化理论背景"><a href="#1-2-系统进化理论背景" class="headerlink" title="1.2 系统进化理论背景"></a>1.2 系统进化理论背景</h2><p>系统进化的背景与中国互联网用户规模庞大有巨大关系，中国互联网用户规模有7.7亿，庞大的用户访问量对系统的架构设计是巨大的挑战； </p>
<p>产品或者网站初期，通常功能较少，用户量也不多，所以一般按照单体应用进行设计和开发，按照经典的MVC三层架构设计；</p>
<p>随着业务的发展，应用功能的增加，访问用户的增多，传统的采用集中式系统进行开发的方式就不再适用了，因为在这种情况下，集中式系统就会逐步变得非常庞大，很多人维护这么一个系统，开发、测试、上线都会造成很大问题，比如代码冲突，代码重复，逻辑错综混乱，代码逻辑复杂度增加，响应新需求的速度降低，隐藏的风险增大；</p>
<p>所以需要按照业务维度进行应用拆分，采用分布式开发，每个应用专职于做某一些方面的事情，比如将一个集中式系统拆分为用户服务、订单服务、产品服务、交易服务等，各个应用服务之间通过相互调用完成某一项业务功能。</p>
<h2 id="1-3-什么是微服务架构"><a href="#1-3-什么是微服务架构" class="headerlink" title="1.3 什么是微服务架构"></a>1.3 什么是微服务架构</h2><p>分布式强调系统的拆分，微服务也是强调系统的拆分，微服务架构属于分布式架构的范畴。</p>
<p>微服务是系统架构上的一种设计风格，它的主旨是将一个原本独立的系统拆分成多个小型服务，这些小型服务都在各自独立的进程中运行，服务间基于HTTP的RESTful API进行通信协作。</p>
<p>被拆分后的每个小型服务都围绕着系统中的某一项业务功能进行构建，并且每个服务都是一个独立的项目，可以进行独立的测试、开发和部署等。</p>
<p>由于每个独立的服务之间使用基于HTTP的作为数据通信协作的基础，所以这些微服务可以使用不同的语言来开发。</p>
<h2 id="1-4-微服务架构的优缺点"><a href="#1-4-微服务架构的优缺点" class="headerlink" title="1.4 微服务架构的优缺点"></a>1.4 微服务架构的优缺点</h2><p>优点：</p>
<ol>
<li><p>我们知道微服务架构是将系统中的不同功能模块拆分成多个不同的服务，这些服务进行独立地开发和部署，每个服务都运行在自己的进程内，这样每个服务的更新都不会影响其他服务的运行；</p>
</li>
<li><p>由于每个服务是独立部署的，所以我们可以更准确地监控每个服务的资源消耗情况，进行性能容量的评估，通过压力测试，也很容易发现各个服务间的性能瓶颈所在；</p>
</li>
<li><p>由于每个服务都是独立开发，项目的开发也比较方便，减少代码的冲突、代码的重复，逻辑处理流程也更加清晰，让后续的维护与扩展更加容易；</p>
</li>
<li><p>微服务可以使用不同的编程语言进行开发；</p>
</li>
</ol>
<p>缺点：</p>
<ol>
<li><p>微服务架构增加了系统维护、部署的难度，导致一些功能模块或代码无法复用；</p>
</li>
<li><p>随着系统规模的日渐增长，微服务在一定程度上也会导致系统变得越来越复杂，增加了集成测试的复杂度；</p>
</li>
<li><p>随着微服务的增多，数据的一致性问题，服务之间的通信成本等都凸显了出来；</p>
</li>
</ol>
<h2 id="1-5-为什么选择Spring-Cloud构建微服务"><a href="#1-5-为什么选择Spring-Cloud构建微服务" class="headerlink" title="1.5 为什么选择Spring Cloud构建微服务"></a>1.5 为什么选择Spring Cloud构建微服务</h2><p>微服务一词是Martin Fowler（马丁.福勒）于2014年提出来的，近几年微服务架构的讨论非常火热，无数的架构师和开发者在实际项目中实践着微服务架构的设计理念，他们在微服务架构中针对不同应用场景出现的各种问题，也推出了很多解决方案和开源框架，其中我们国内的互联网企业也有一些著名的框架和方案；</p>
<p>整个微服务架构是由大量的技术框架和方案构成，比如：</p>
<table>
<thead>
<tr>
<th>服务基础开发</th>
<th>Spring MVC、Spring、SpringBoot</th>
</tr>
</thead>
<tbody><tr>
<td>服务注册与发现</td>
<td>Netflix的Eureka、Apache的ZooKeeper等</td>
</tr>
<tr>
<td>服务调用</td>
<td>RPC调用有阿里巴巴的Dubbo，Rest方式调用有当当网Dubbo基础上扩展的Dubbox、还有其他方式实现的Rest，比如Ribbon、Feign</td>
</tr>
<tr>
<td>分布式配置管理</td>
<td>百度的Disconf、360的QConf、淘宝的Diamond、Netflix的Archaius等</td>
</tr>
<tr>
<td>负载均衡</td>
<td>Ribbon</td>
</tr>
<tr>
<td>服务熔断</td>
<td>Hystrix</td>
</tr>
<tr>
<td>API网关</td>
<td>Zuul</td>
</tr>
<tr>
<td>批量任务</td>
<td>当当网的Elastic-Job、Linkedln的Azkaban</td>
</tr>
<tr>
<td>服务跟踪</td>
<td>京东的Hydra、Twitter的Zipkin等</td>
</tr>
</tbody></table>
<p>但是在微服务架构上，几乎大部分的开源组件都只能解决某一个场景下的问题，所以这些实施微服务架构的公司也是整合来自不同公司或组织的诸多开源框架，并加入针对自身业务的一些改进，没有一个统一的架构方案；</p>
<p>所以当我们准备实施微服务架构时，我们要整合各个公司或组织的开源软件，而且某些开源软件又有多种选择，这导致在做技术选型的初期，需要花费大量的时间进行预备研、分析和实验，这些方案的整合没有得到充分的测试，可能在实践中会遇到各种各样的问题；</p>
<p>Spring Cloud的出现，可以说是为微服务架构迎来一缕曙光，有SpringCloud社区的巨大支持和技术保障，让我们实施微服务架构变得异常简单了起来，它不像我们之前所列举的框架那样，只是解决微服务中的某一个问题，而是一个解决微服务架构实施的综合性解决框架，它整合了诸多被广泛实践和证明有效的框架作为实施的基础组件，又在该体系基础上创建了一些非常优秀的边缘组件将它们很好地整合起来。</p>
<p>加之Spring Cloud 有其Spring 的强大技术背景，极高的社区活跃度，也许未来Spring Cloud会成为微服务的标准技术解决方案；</p>
<h1 id="第二章-认识Spring-Cloud"><a href="#第二章-认识Spring-Cloud" class="headerlink" title="第二章 认识Spring Cloud"></a>第二章 认识Spring Cloud</h1><h2 id="2-1-Spring-Cloud是什么"><a href="#2-1-Spring-Cloud是什么" class="headerlink" title="2.1 Spring Cloud是什么"></a>2.1 Spring Cloud是什么</h2><ol>
<li><p>Spring Cloud是一个一站式的开发分布式系统的框架，为开发者提供了一系列的构建分布式系统的工具集；</p>
</li>
<li><p>Spring Cloud为开发人员提供了快速构建分布式系统中一些常见模式的工具（比如：配置管理，服务发现，断路器，智能路由、微代理、控制总线、全局锁、决策竞选、分布式会话和集群状态管理等）；</p>
</li>
<li><p>开发分布式系统都需要解决一系列共同关心的问题，而使用Spring Cloud可以快速地实现这些分布式开发共同关心的问题，并能方便地在任何分布式环境中部署与运行。</p>
</li>
<li><p>Spring Cloud这个一站式地分布式开发框架，被近年来流行的“微服务”架构所大力推崇，成为目前进行微服务架构的优先选择工具；</p>
</li>
<li><p>Spring Cloud基于Spring Boot框架构建微服务架构，学习Spring Cloud需要先学习Spring Boot；</p>
</li>
<li><p>SpringCloud官网：<a target="_blank" rel="noopener" href="http://spring.io/">http://spring.io</a></p>
</li>
</ol>
<h2 id="2-2-Spring-Cloud的版本"><a href="#2-2-Spring-Cloud的版本" class="headerlink" title="2.2 Spring Cloud的版本"></a>2.2 Spring Cloud的版本</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Spring Cloud最早是从2014年推出的，在推出的前期更新迭代速度非常快，频繁发布新版本，目前更趋于稳定，变化稍慢一些；</span><br><span class="line">Spring Cloud的版本并不是传统的使用数字的方式标识，而是使用诸如：Angel、Brixton、Camden......等伦敦的地名来命名版本，版本的先后顺序使用字母表A-Z的先后来标识,，现在已经进入H版本；Hoxton.RC2版本，对应SpringBoot 2.2.x</span><br></pre></td></tr></table></figure>

<p>Spring Cloud与Spring Boot版本匹配关系</p>
<table>
<thead>
<tr>
<th>Finchley</th>
<th>兼容Spring Boot 2.0.x，  不兼容Spring Boot 1.5.x</th>
</tr>
</thead>
<tbody><tr>
<td>Edgware</td>
<td>兼容Spring Boot 1.5.x，  不兼容Spring Boot 2.0.x</td>
</tr>
<tr>
<td>Dalston</td>
<td>兼容Spring Boot 1.5.x，  不兼容Spring Boot 2.0.x</td>
</tr>
<tr>
<td>Camden</td>
<td>兼容Spring Boot 1.4.x，  也兼容Spring Boot 1.5.x</td>
</tr>
<tr>
<td>Brixton</td>
<td>兼容Spring Boot 1.3.x，  也兼容Spring Boot 1.4.x</td>
</tr>
<tr>
<td>Angel</td>
<td>兼容Spring Boot 1.2.x</td>
</tr>
</tbody></table>
<p>Spring Cloud并不是从0开始开发一整套微服务解决方案，而是集成各个开源软件，构成一整套的微服务解决方案，这其中有非常著名的Netflix公司的开源产品；</p>
<p>Netflix公司成立于1997年，是目前美国最大的版权视频交易网站；</p>
<p>Netflix公司在不断发展的过程中，也成为了一家云计算公司，并积极参与开源项目，Netflix OSS（Open Source）就是由Netflix公司主持开发的一套代码框架和库，github地址：<a target="_blank" rel="noopener" href="https://github.com/Netflix%EF%BC%9B">https://github.com/Netflix；</a></p>
<p>Spring Cloud 所包含的众多组件中，Spring Cloud Netflix就是其中一组不可忽视的组件，由netflix公司开发后又并入Spring Cloud 大家庭；</p>
<p>目前Netflix公司贡献的活跃项目包括：</p>
<p>spring-cloud-netflix-eureka</p>
<p>spring-cloud-netflix-hystrix</p>
<p>spring-cloud-netflix-stream</p>
<p>spring-cloud-netflix-archaius</p>
<p>spring-cloud-netflix-ribbon</p>
<p>spring-cloud-netflix-zuul</p>
<h2 id="2-3-Spring-Cloud开发环境"><a href="#2-3-Spring-Cloud开发环境" class="headerlink" title="2.3 Spring Cloud开发环境"></a>2.3 Spring Cloud开发环境</h2><p>SpringBoot 2.2.x</p>
<p>Spring Cloud Hoxton xxx</p>
<p>Maven 3.5.3</p>
<p>JDK 1.8.152</p>
<p>IntelliJ IDEA</p>
<h2 id="2-4-Spring-Cloud的整体架构"><a href="#2-4-Spring-Cloud的整体架构" class="headerlink" title="2.4 Spring Cloud的整体架构"></a>2.4 Spring Cloud的整体架构</h2><p>  <img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212134871.png" alt="image-20201216192902340">                             </p>
<p>Service Provider： 暴露服务的服务提供方。</p>
<p>Service Consumer：调用远程服务的服务消费方。</p>
<p>EureKa Server： 服务注册中心和服务发现中心。</p>
<h1 id="第三章-Spring-Cloud快速开发入门"><a href="#第三章-Spring-Cloud快速开发入门" class="headerlink" title="第三章 Spring Cloud快速开发入门"></a>第三章 Spring Cloud快速开发入门</h1><h2 id="3-1-搭建和配置一个服务提供者"><a href="#3-1-搭建和配置一个服务提供者" class="headerlink" title="3.1 搭建和配置一个服务提供者"></a>3.1 搭建和配置一个服务提供者</h2><p>我们知道，SpringCloud构建微服务是基于SpringBoot开发的。</p>
<ol>
<li><p>创建一个SpringBoot工程（SpringBoot的Web工程），并且添加SpringBoot的相关依赖；</p>
</li>
<li><p>创建服务提供者的访问方法，也就是后续消费者如何访问提供者；</p>
<p>Spring Cloud是基于rest的访问，所以我们添加一个Controller，在该Controller中提供一个访问入口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/hello&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello Spring Cloud&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
<li><p>启动运行该SpringBoot程序，访问该controller；</p>
</li>
</ol>
<h2 id="3-2-搭建和配置一个服务消费者"><a href="#3-2-搭建和配置一个服务消费者" class="headerlink" title="3.2 搭建和配置一个服务消费者"></a>3.2 搭建和配置一个服务消费者</h2><p>服务消费者也是一个SpringBoot项目，服务消费者主要用来消费服务提供者提供的服务；</p>
<ol>
<li><p>创建一个SpringBoot工程（SpringBoot的Web工程），并且添加SpringBoot的相关依赖；</p>
</li>
<li><p>定义自定义类RestTemplateConfig类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 标记当前类是一个Spring配置类，用于模拟Spring的配置文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RestTemplateConfig</span> &#123;</span><br><span class="line"><span class="comment">//@Bean标记当前方法是一个Spring配置方法，用于模拟Spring配置文件中的Bean标签</span></span><br><span class="line"><span class="comment">//其中方法的返回值相当于Bean标签的class</span></span><br><span class="line"><span class="comment">//其中方法的名字相当于Bean标签的id</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
<li><p>开发一个消费者方法，去消费服务提供者提供的服务，这个消费者方法也是一个Controller:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SpringCloud的消费者端，消费就是一个普通的SpringBoot的web工程</span></span><br><span class="line"><span class="comment"> * 这里需要使用Http协议访问服务提供者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//访问远程的SpringCloud的服务</span></span><br><span class="line">        <span class="comment">//参数1 为服务器的地址以及服务器的请求名</span></span><br><span class="line">        <span class="comment">//参数2 用于指定返回的数据类型是字符格式</span></span><br><span class="line">        <span class="comment">//.getBody()方法的作用是获取响应的主体内容（服务端返回的具体JSON数据）</span></span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForEntity(<span class="string">&quot;http://localhost:8081/test&quot;</span>,String.class).getBody()+<span class="string">&quot;  -----SpringCloud的消费者&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动该SpringBoot程序，测试服务消费者调用服务提供者</p>
</li>
</ol>
<h2 id="3-3-走进服务注册中心Eureka"><a href="#3-3-走进服务注册中心Eureka" class="headerlink" title="3.3 走进服务注册中心Eureka"></a>3.3 走进服务注册中心Eureka</h2><p>在微服务架构中，服务注册与发现是核心组件之一，手动指定每个服务是很低效的，Spring Cloud提供了多种服务注册与发现的实现方式，例如：Eureka、Consul、Zookeeper。</p>
<p>Spring Cloud支持得最好的是Eureka，其次是Consul，再次是Zookeeper。</p>
<p><strong>什么是服务注册？</strong></p>
<p>服务注册：将服务所在主机、端口、版本号、通信协议等信息登记到注册中心上；</p>
<p><strong>什么是服务发现？</strong></p>
<p>服务发现：服务消费者向注册中心请求已经登记的服务列表，然后得到某个服务的主机、端口、版本号、通信协议等信息，从而实现对具体服务的调用；</p>
<p><strong>Eureka是什么？</strong></p>
<p>Eureka是一个服务治理组件，它主要包括服务注册和服务发现，主要用来搭建服务注册中心。</p>
<p>Eureka 是一个基于 REST 的服务，用来定位服务，进行中间层服务器的负载均衡和故障转移；</p>
<p>Eureka是Netflix 公司开发的，Spring Cloud 封装了 Netflix 公司开发的 Eureka 模块来实现服务注册和发现，也就是说Spring Cloud对Netflix Eureka 做了二次封装；</p>
<p>Eureka 采用了C-S（客户端&#x2F;服务端）的设计架构，也就是Eureka由两个组件组成：Eureka服务端和Eureka客户端。Eureka Server 作为服务注册的服务端，它是服务注册中心，而系统中的其他微服务，使用 Eureka 的客户端连接到 Eureka Server服务端，并维持心跳连接，Eureka客户端是一个Java客户端，用来简化与服务器的交互、负载均衡，服务的故障切换等；</p>
<p>有了Eureka注册中心，系统的维护人员就可以通过 Eureka Server 来监控系统中各个微服务是否正常运行。</p>
<h2 id="3-4-Eureka与Zookeeper的比较"><a href="#3-4-Eureka与Zookeeper的比较" class="headerlink" title="3.4 Eureka与Zookeeper的比较"></a>3.4 Eureka与Zookeeper的比较</h2><p>著名的CAP理论指出，一个分布式系统不可能同时满足Consistency(一致性)、Availability(可用性)和Partition tolerance(分区容错性)。</p>
<p>由于分区容错性在是分布式系统中必须要保证的，因此我们只能在A和C之间进行权衡，在此Zookeeper保证的是CP, 而Eureka则是AP。</p>
<p><strong>Zookeeper保证CP</strong></p>
<p>在ZooKeeper中，当master节点因为网络故障与其他节点失去联系时，剩余节点会重新进行leader选举，但是问题在于，选举leader需要一定时间, 且选举期间整个ZooKeeper集群都是不可用的，这就导致在选举期间注册服务瘫痪。在云部署的环境下，因网络问题使得ZooKeeper集群失去master节点是大概率事件，虽然服务最终能够恢复，但是在选举时间内导致服务注册长期不可用是难以容忍的。</p>
<p><strong>Eureka保证AP</strong></p>
<p>Eureka优先保证可用性，Eureka各个节点是平等的，某几个节点挂掉不会影响正常节点的工作，剩余的节点依然可以提供注册和查询服务。而Eureka的客户端在向某个Eureka注册或时如果发现连接失败，则会自动切换至其它节点，只要有一台Eureka还在，就能保证注册服务可用(保证可用性)，只不过查到的信息可能不是最新的(不保证强一致性)。</p>
<p>所以Eureka在网络故障导致部分节点失去联系的情况下，只要有一个节点可用，那么注册和查询服务就可以正常使用，而不会像zookeeper那样使整个注册服务瘫痪，Eureka优先保证了可用性。</p>
<h2 id="3-5-搭建与配置Eureka服务注册中心"><a href="#3-5-搭建与配置Eureka服务注册中心" class="headerlink" title="3.5 搭建与配置Eureka服务注册中心"></a>3.5 搭建与配置Eureka服务注册中心</h2><p>Spring Cloud要使用Eureka注册中心非常简单和方便，Spring Cloud中的Eureka服务注册中心实际上也是一个Spring Boot工程，我们只需通过引入相关依赖和注解配置就能让Spring Boot构建的微服务应用轻松地与Eureka进行整合。</p>
<p>具体步骤如下：</p>
<ol>
<li><p>创建一个SpringBoot项目02-springcloud-eureka-server，并且添加SpringBoot的相关依赖；</p>
</li>
<li><p>添加eureka的依赖：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--Spring Cloud的eureka-server起步依赖--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
<li><p>必须添加Maven的依赖管理器，否则eureka无法被识别</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt;</span><br><span class="line">            &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">            &lt;scope&gt;<span class="keyword">import</span>&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/dependencyManagement&gt;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>注意：如果通过SpringBoot的开发工具创建Web工程那么这个依赖以及依赖管理是自动添加 的</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212134873.png" alt="image-20201216203512922"></p>
</li>
<li><p>在application.properties文件中配置Eureka服务注册中心信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#内嵌定时tomcat的端口</span><br><span class="line">server.port=<span class="number">9100</span></span><br><span class="line">#设置该服务注册中心的hostname</span><br><span class="line">eureka.instance.hostname=localhost</span><br><span class="line">#由于我们目前创建的应用是一个服务注册中心，而不是普通的应用，默认情况下，这个应用会向注册中心（也是它自己）注册它自己，设置为<span class="literal">false</span>表示禁止这种自己向自己注册的默认行为</span><br><span class="line">eureka.client.register-with-eureka=<span class="literal">false</span></span><br><span class="line">#表示不去检索其他的服务，因为服务注册中心本身的职责就是维护服务实例，它不需要去检索其他服务</span><br><span class="line">eureka.client.fetch-registry=<span class="literal">false</span></span><br><span class="line">#指定服务注册中心的位置</span><br><span class="line">eureka.client.service-url.defaultZone=http:<span class="comment">//$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在Spring Boot的入口类上添加一个@EnableEurekaServer注解，用于开启Eureka注册中心服务端</p>
</li>
</ol>
<h2 id="3-6-启动与测试Eureka服务注册中心"><a href="#3-6-启动与测试Eureka服务注册中心" class="headerlink" title="3.6 启动与测试Eureka服务注册中心"></a>3.6 启动与测试Eureka服务注册中心</h2><ol>
<li><p>完成上面的项目搭建后，我们就可以启动SpringBoot程序，main方法运行；</p>
</li>
<li><p>启动成功之后，通过在浏览器地址栏访问我们的注册中心；浏览器输入<a target="_blank" rel="noopener" href="http://localhost:9100/">http://localhost:9100</a> 来测试Eureka是否启动</p>
</li>
</ol>
<h2 id="3-7-向Eureka服务注册中心注册服务"><a href="#3-7-向Eureka服务注册中心注册服务" class="headerlink" title="3.7 向Eureka服务注册中心注册服务"></a>3.7 向Eureka服务注册中心注册服务</h2><p>我们前面搭建了服务提供者项目，接下来我们就可以将该服务提供者注册到Eureke注册中心，步骤如下：</p>
<ol>
<li>在该服务提供者中添加eureka的依赖，因为服务提供者向注册中心注册服务，需要连接eureka，所以需要eureka客户端的支持；</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--SpringCloud集成eureka客户端的起步依赖--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>必须添加Maven的依赖管理器，否则eureka无法被识别</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt;</span><br><span class="line">            &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">            &lt;scope&gt;<span class="keyword">import</span>&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/dependencyManagement&gt;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>注意：如果通过SpringBoot的开发工具创建Web工程那么这个依赖以及依赖管理是自动添加 的</p>
<p>  <img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212134874.png" alt="image-20201216204047337"></p>
<ol start="3">
<li>修改服务提供者的application.properties文件，配置服务名称和注册中心地址</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#指定服务名字 这个名称将在服务消费者时被调用</span><br><span class="line">spring.application.name= <span class="number">02</span>-springcloud-eureka-client-provider</span><br><span class="line">#指定eureka的访问地址</span><br><span class="line">eureka.client.service-url.defaultZone=http:<span class="comment">//localhost:9100/eureka</span></span><br><span class="line">#指定Tomcat的端口号需要避免和其他的Tomcat端口冲突</span><br><span class="line">server.port=<span class="number">8081</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>激活Eureka中的EnableEurekaClient功能：</p>
<p>在Spring Boot的入口函数处，通过添加@EnableEurekaClient注解来表明自己是一个eureka客户端，让我的服务消费者可以使用eureka注册中心</p>
</li>
<li><p>编写控制器提供服务</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义控制器类对外提供服务</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;使用了eureka注册中心的服务提供者&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><p>启动服务提供者SpringBoot程序的main方法运行；</p>
</li>
<li><p>启动运行之后，通过在浏览器地址栏访问我们之前搭建好的eureka注册中心，就可以看到有一个服务已经注册成功了；</p>
</li>
</ol>
<h2 id="3-8-从Eureka服务注册中心发现与消费服务"><a href="#3-8-从Eureka服务注册中心发现与消费服务" class="headerlink" title="3.8 从Eureka服务注册中心发现与消费服务"></a>3.8 从Eureka服务注册中心发现与消费服务</h2><p>我们已经搭建一个服务注册中心，同时也向这个服务注册中心注册了服务，接下来我们就可以发现和消费服务了，这其中服务的发现由eureka客户端实现，而服务的消费由Ribbon实现，也就是说服务的调用需要eureka客户端和Ribbon两者配合起来才能实现；</p>
<p><strong>Eureka客户端是什么？</strong></p>
<p>Eureka客户端是一个Java客户端，用来连接Eureka服务端，与服务端进行交互、负载均衡，服务的故障切换等；</p>
<p><strong>Ribbon是什么？</strong></p>
<p>Ribbon是一个基于HTTP 和 TCP 的客户端负载均衡器，当使用Ribbon对服务进行访问的时候，它会扩展Eureka客户端的服务发现功能，实现从Eureka注册中心中获取服务端列表，并通过Eureka客户端来确定服务端是否己经启动。Ribbon在Eureka客户端服务发现的基础上，实现了对服务实例的选择策略，从而实现对服务的负载均衡消费。</p>
<p>接下来我们来让服务消费者去消费服务：</p>
<p>我们前面搭建了服务消费者项目，接下来我们就可以使用该服务消费者通过注册中心去调用服务提供者，步骤如下：</p>
<ol>
<li>在该消费者项目中添加eureka的依赖，因为服务消费者从注册中心获取服务，需要连接eureka，所以需要eureka客户端的支持；</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--SpringCloud集成eureka客户端的起步依赖--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<ol start="2">
<li>必须添加Maven的依赖管理器，否则eureka无法被识别</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt;</span><br><span class="line">            &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">            &lt;scope&gt;<span class="keyword">import</span>&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/dependencyManagement&gt;</span><br><span class="line"> </span><br><span class="line">注意：如果通过SpringBoot的开发工具创建Web工程那么这个依赖以及依赖管理是自动添加 的</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>配置服务的名称和注册中心的地址：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#指定服务的名称 即使是服务的消费者也会将自己注册到注册中心</span><br><span class="line">spring.application.name=02-springcloud-eureka-client-consumer</span><br><span class="line">#指定Eureka注册中的访问地址</span><br><span class="line">eureka.client.service-url.defaultZone=http://localhost:9100/eureka</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>激活Eureka中的EnableEurekaClient功能：</p>
<p>在Spring Boot的入口函数处，通过添加@EnableEurekaClient注解来表明自己是一个eureka客户端，让我的服务消费者可以使用eureka注册中心；</p>
</li>
<li><p>前面我介绍了服务的发现由eureka客户端实现，而服务的真正调用由ribbon实现，所以我们需要在调用服务提供者时使用ribbon来调用：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RestTemplateConfig</span> &#123;</span><br><span class="line">    <span class="comment">//使用Ribbon的负载均衡从注册中心中获取服务</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><p>调用服务<br>加入了ribbon的支持，那么在调用时，即可改为使用服务名称来访问：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//访问SpringCloud 提供的服务，但是这里我们不需要再次指定服务提供者的地址了，只需要通过服务的名字到</span></span><br><span class="line">        <span class="comment">//Eureka的注册中心中找到对应的服务提供者</span></span><br><span class="line">        <span class="comment">//其中02-SPRINGCLOUD-EUREKA-CLIENT-PROVIDER 就是服务的提供的服务名</span></span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForEntity(<span class="string">&quot;http://02-SPRINGCLOUD-EUREKA-CLIENT-PROVIDER/test&quot;</span>,String.class).getBody()+<span class="string">&quot;----带有注册中心的服务消费者&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>完成上面的步骤后，我们就可以启动消费者的SpringBoot程序，main方法运行；</p>
</li>
<li><p>启动成功之后，通过在浏览器地址栏访问我们的消费者，看是否可以正常调用远程服务提供者提供的服务；浏览器输入<a target="_blank" rel="noopener" href="http://localhost:8080/test">http://localhost:8080/test</a> 进行测试</p>
</li>
</ol>
<h1 id="第四章-服务注册中心Eureka"><a href="#第四章-服务注册中心Eureka" class="headerlink" title="第四章 服务注册中心Eureka"></a>第四章 服务注册中心Eureka</h1><h2 id="4-1-Eureka注册中心高可用集群概述"><a href="#4-1-Eureka注册中心高可用集群概述" class="headerlink" title="4.1 Eureka注册中心高可用集群概述"></a>4.1 Eureka注册中心高可用集群概述</h2><p>在微服务架构的这种分布式系统中，我们要充分考虑各个微服务组件的高可用性问题，不能有单点故障，由于注册中心eureka本身也是一个服务，如果它只有一个节点，那么它有可能发生故障，这样我们就不能注册与查询服务了，所以我们需要一个高可用的服务注册中心，这就需要通过注册中心集群来解决。</p>
<p>eureka服务注册中心它本身也是一个服务，它也可以看做是一个提供者，又可以看做是一个消费者，我们之前通过配置：</p>
<p>eureka.client.register-with-eureka&#x3D;false 让注册中心不注册自己，但是我们可以向其他注册中心注册自己；</p>
<p>Eureka Server的高可用实际上就是将自己作为服务向其他服务注册中心注册自己，这样就会形成一组互相注册的服务注册中心，进而实现服务清单的互相同步，往注册中心A上注册的服务，可以被复制同步到注册中心B上，所以从任何一台注册中心上都能查询到已经注册的服务，从而达到高可用的效果。</p>
<p> <img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212134875.png" alt="image-20201216210302515">                              </p>
<h2 id="4-2-Eureka注册中心高可用集群搭建"><a href="#4-2-Eureka注册中心高可用集群搭建" class="headerlink" title="4.2 Eureka注册中心高可用集群搭建"></a>4.2 Eureka注册中心高可用集群搭建</h2><p>我们知道，Eureka注册中心高可用集群就是各个注册中心相互注册，所以：</p>
<ol>
<li><p>创建2个SpringBoot 的Eureka的服务端项目分别为：</p>
<p>03-springcloud-eureka-server-cluster-9100</p>
<p>03-springcloud-eureka-server-cluster-9200</p>
</li>
<li><p>分别添加依赖包</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">        &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt;</span><br><span class="line">            &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">            &lt;scope&gt;<span class="keyword">import</span>&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/dependencyManagement&gt;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>分别修改2个项目的application.properties文件</p>
<p>03-springcloud-eureka-server-cluster-9100 的application.properties</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#内嵌定时tomcat的端口</span><br><span class="line">server.port=<span class="number">9100</span></span><br><span class="line">#设置该服务注册中心的hostname</span><br><span class="line">eureka.instance.hostname=eureka9100</span><br><span class="line">#由于我们目前创建的应用是一个服务注册中心，而不是普通的应用，默认情况下，这个应用会向注册中心（也是它自己）注册它自己，设置为<span class="literal">false</span>表示禁止这种自己向自己注册的默认行为</span><br><span class="line">eureka.client.register-with-eureka=<span class="literal">false</span></span><br><span class="line">#表示不去检索其他的服务，因为服务注册中心本身的职责就是维护服务实例，它不需要去检索其他服务</span><br><span class="line">eureka.client.fetch-registry=<span class="literal">false</span></span><br><span class="line">#指定服务注册中心的位置</span><br><span class="line">eureka.client.service-url.defaultZone=http:<span class="comment">//eureka9200:9200/eureka</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>03-springcloud-eureka-server-cluster-9200 的application.properties </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#内嵌定时tomcat的端口</span><br><span class="line">server.port=<span class="number">9200</span></span><br><span class="line">#设置该服务注册中心的hostname</span><br><span class="line">eureka.instance.hostname=eureka9100</span><br><span class="line">#由于我们目前创建的应用是一个服务注册中心，而不是普通的应用，默认情况下，这个应用会向注册中心（也是它自己）注册它自己，设置为<span class="literal">false</span>表示禁止这种自己向自己注册的默认行为</span><br><span class="line">eureka.client.register-with-eureka=<span class="literal">false</span></span><br><span class="line">#表示不去检索其他的服务，因为服务注册中心本身的职责就是维护服务实例，它不需要去检索其他服务</span><br><span class="line">eureka.client.fetch-registry=<span class="literal">false</span></span><br><span class="line">#指定服务注册中心的位置</span><br><span class="line">eureka.client.service-url.defaultZone=http:<span class="comment">//eureka9100:9100/eureka</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>然后在本地hosts文件配置：C:\Windows\System32\drivers\etc\hosts</p>
<p><strong>127.0.0.1 eureka9100</strong></p>
<p><strong>127.0.0.1 eureka9200</strong></p>
</li>
</ol>
<p>分别启动两个注册中心，访问两个注册中心页面，观察注册中心页面是否正常；</p>
<p><a target="_blank" rel="noopener" href="http://eureka9100:9100/">http://eureka9100:9100</a></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212134876.png" alt="image-20201216210609548"> </p>
<p><a target="_blank" rel="noopener" href="http://eureka9200:9200/">http://eureka9200:9200</a></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212134877.png" alt="image-20201216210628585">  </p>
<h2 id="4-3-Eureka注册中心高可用集群测试"><a href="#4-3-Eureka注册中心高可用集群测试" class="headerlink" title="4.3 Eureka注册中心高可用集群测试"></a>4.3 Eureka注册中心高可用集群测试</h2><p>服务端配置号以后需要进行注册的服务中配置：</p>
<ol>
<li><p>创建服务的生产者项目SpringBoot项目</p>
<p>03-springcloud-eureka-client-cluster-provider</p>
</li>
<li><p>添加依赖包</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">  &lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">        &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt;</span><br><span class="line">            &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">            &lt;scope&gt;<span class="keyword">import</span>&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/dependencyManagement&gt;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>修改application.properties文件</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">spring.application.name=<span class="number">03</span>-springcloud-eureka-client-cluster-provider</span><br><span class="line">#将服务同时注册到多个注册中心,其实当Eureka注册中心实现集群以后，那么将服务注册到任意一个Eureka的注册中心后，数据服务都会</span><br><span class="line">#同步到其他的Eureka注册中心，但是实际应用时还是建议将服务分别注册到全部的Eureka集群的所有服务中，这个防止某个以Eureka出现</span><br><span class="line">#故障后服务仍然可以注册成功</span><br><span class="line">eureka.client.service-url.defaultZone=http:<span class="comment">//eureka9100:9100/eureka/,http://eureka9200:9200/eureka/</span></span><br><span class="line">#指定Tomcat的端口号需要避免和其他的Tomcat端口冲突</span><br><span class="line">server.port=<span class="number">8081</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>创建服务的消费者项目SpringBoot项目</p>
<p>03-springcloud-eureka-client-cluster-consumer</p>
</li>
<li><p>添加依赖包</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">  &lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">        &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt;</span><br><span class="line">            &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">            &lt;scope&gt;<span class="keyword">import</span>&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/dependencyManagement&gt;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>修改application.properties文件</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">spring.application.name= <span class="number">03</span>-springcloud-eureka-client-cluster-provider</span><br><span class="line"></span><br><span class="line">#将服务同时注册到多个注册中心,其实当Eureka注册中心实现集群以后，那么将服务注册到任意一个Eureka的注册中心后，数据服务都会</span><br><span class="line">#同步到其他的Eureka注册中心，但是实际应用时还是建议将服务分别注册到全部的Eureka集群的所有服务中，这个防止某个以Eureka出现</span><br><span class="line">#故障后服务仍然可以注册成功</span><br><span class="line">eureka.client.service-url.defaultZone=http:<span class="comment">//eureka9100:9100/eureka/,http://eureka9200:9200/eureka/</span></span><br><span class="line">#指定Tomcat的端口号需要避免和其他的Tomcat端口冲突</span><br><span class="line">server.port=<span class="number">8081</span></span><br></pre></td></tr></table></figure>

<p>启动服务提供者服务，然后观察注册中心页面，可以看到服务会在两个注册中心上都注册成功；</p>
<h2 id="4-4-Eureka服务注册中心自我保护机制"><a href="#4-4-Eureka服务注册中心自我保护机制" class="headerlink" title="4.4 Eureka服务注册中心自我保护机制"></a>4.4 Eureka服务注册中心自我保护机制</h2><p>自我保护机制是Eureka注册中心的重要特性，当Eureka注册中心进入自我保护模式时，在Eureka Server首页会输出如下警告信息：</p>
<p>EMERGENCY! EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY’RE NOT. RENEWALS ARE LESSER THAN THRESHOLD AND HENCE THE INSTANCES ARE NOT BEING EXPIRED JUST TO BE SAFE.</p>
<p>emergency! eureka may be incorrectly claiming instances are up when they’re not. renewals are lesser than threshold and hence the instances are not being expired just to be safe.</p>
<p>在没有Eureka自我保护的情况下，如果Eureka Server在一定时间内没有接收到某个微服务实例的心跳，Eureka Server将会注销该实例，但是当发生网络分区故障时，那么微服务与Eureka Server之间将无法正常通信，以上行为可能变得非常危险了——因为微服务本身其实是正常的，此时不应该注销这个微服务，如果没有自我保护机制，那么Eureka Server就会将此服务注销掉。</p>
<p>Eureka通过“自我保护模式”来解决这个问题——当Eureka Server节点在短时间内丢失过多客户端时（可能发生了网络分区故障），那么就会把这个微服务节点进行保护。一旦进入自我保护模式，Eureka Server就会保护服务注册表中的信息，不删除服务注册表中的数据（也就是不会注销任何微服务）。当网络故障恢复后，该Eureka Server节点会再自动退出自我保护模式。</p>
<p>所以，自我保护模式是一种应对网络异常的安全保护措施，它的架构哲学是宁可同时保留所有微服务（健康的微服务和不健康的微服务都会保留），也不盲目注销任何健康的微服务，使用自我保护模式，可以让Eureka集群更加的健壮、稳定。</p>
<p>当然也可以使用配置项：<strong>eureka.server.enable-self-preservation &#x3D; false</strong> 禁用自我保护模式。</p>
<p>但是Eureka Server 自我保护模式也会给我们带来一些困扰，如果在保护期内某个服务提供者刚好非正常下线了，此时服务消费者就会拿到一个无效的服务实例，此时会调用失败，对于这个问题需要服务消费者端具有一些容错机制，如重试，断路器等。</p>
<p>Eureka的自我保护模式是有意义的，该模式被激活后，它不会从注册列表中剔除因长时间没收到心跳导致注册过期的服务，而是等待修复，直到心跳恢复正常之后，它自动退出自我保护模式。这种模式旨在避免因网络分区故障导致服务不可用的问题。</p>
<p>例如，两个微服务客户端实例A和B之间有调用的关系，A是消费者，B是提供者，但是由于网络故障，B未能及时向Eureka发送心跳续约，这时候Eureka 不能简单的将B从注册表中剔除，因为如果剔除了，A就无法从Eureka 服务器中获取B注册的服务，但是这时候B服务是可用的；</p>
<p>所以，Eureka的自我保护模式最好还是开启它。</p>
<p>关于自我保护常用几个配置如下：</p>
<p>分别修改2个Eureka服务服务端的application.properties文件增加一下配置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#关闭自我保护模式 作用是如果开启了自我保护模式以后，那么如果服务的提供者或消费者（Eureka的客户端）因为网络波动问题</span><br><span class="line">#暂时失去了与服务器端的连接那么Eureka就会直接注销这个服务删除这个服务相关的数据，如果关闭了这个自我保护，Eureka只</span><br><span class="line">#会先挂起这个服务，当网络恢复正常以后这个服务将自动的恢复</span><br><span class="line">eureka.server.enable-self-preservation = <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>分别修改服务提供者和服务消费项目的application.properties文件添加一下配置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#每间隔2s，向服务端发送一次心跳，证明自己依然<span class="string">&quot;存活&quot;</span></span><br><span class="line">eureka.instance.lease-renewal-interval-in-seconds=<span class="number">2</span></span><br><span class="line">#告诉服务端，如果我10s之内没有给你发心跳，就代表我故障了，将我踢出掉</span><br><span class="line">eureka.instance.lease-expiration-duration-in-seconds=<span class="number">10</span></span><br></pre></td></tr></table></figure>

<h1 id="第五章：客户端负载均衡Ribbon"><a href="#第五章：客户端负载均衡Ribbon" class="headerlink" title="第五章：客户端负载均衡Ribbon"></a>第五章：客户端负载均衡Ribbon</h1><h2 id="5-1-Spring-Cloud中的Ribbon是什么？"><a href="#5-1-Spring-Cloud中的Ribbon是什么？" class="headerlink" title="5.1 Spring Cloud中的Ribbon是什么？"></a>5.1 Spring Cloud中的Ribbon是什么？</h2><p>我们通常说的负载均衡是指将一个请求均匀地分摊到不同的节点单元上执行，负载均和分为硬件负载均衡和软件负载均衡：</p>
<p><strong>硬件负载均衡</strong>：比如 F5、深信服、Array 等；</p>
<p><strong>软件负载均衡</strong>：比如 Nginx、LVS、HAProxy 等；</p>
<p>硬件负载均衡或是软件负载均衡，他们都会维护一个可用的服务端清单，通过心跳检测来剔除故障的服务端节点以保证清单中都是可以正常访问的服务端节点。当客户端发送请求到负载均衡设备的时候，该设备按某种算法（比如轮询、权重、 最小连接数等）从维护的可用服务端清单中取出一台服务端的地址，然后进行转发。</p>
<p>Ribbon是Netflix发布的开源项目，主要功能是提供客户端的软件负载均衡算法，是一个基于HTTP和TCP的客户端负载均衡工具。</p>
<p>Spring Cloud对Ribbon做了二次封装，可以让我们使用RestTemplate的服务请求，自动转换成客户端负载均衡的服务调用。</p>
<p>Ribbon支持多种负载均衡算法，还支持自定义的负载均衡算法。</p>
<p>Ribbon只是一个工具类框架，比较小巧，Spring Cloud对它封装后使用也非常方便，它不像服务注册中心、配置中心、API网关那样需要独立部署，Ribbon只需要在代码直接使用即可；</p>
<h3 id="Ribbon-与-Nginx-的区别"><a href="#Ribbon-与-Nginx-的区别" class="headerlink" title="Ribbon 与 Nginx 的区别"></a>Ribbon 与 Nginx 的区别</h3><p>Nginx的官方正确读音是“恩静埃克斯”即“ Engine X</p>
<p>Ribbon是客户端的负载均衡工具，而客户端负载均衡和服务端负载均衡最大的区别在于服务清单所存储的位置不同，在客户端负载均衡中，所有客户端节点下的服务端清单，需要自己从服务注册中心上获取，比如Eureka服务注册中心。同服务端负载均衡的架构类似，在客户端负载均衡中也需要心跳去维护服务端清单的健康性，只是这个步骤需要与服务注册中心配合完成。在Spring Cloud中，由于Spring Cloud对Ribbon做了二次封装，所以默认会创建针对Ribbon的自动化整合配置；</p>
<p>在Spring Cloud中，Ribbon主要与RestTemplate对象配合起来使用，Ribbon会自动化配置RestTemplate对象，通过@LoadBalanced开启RestTemplate对象调用时的负载均衡。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212134878.png" alt="image-20201216213130401"></p>
<p>​                               </p>
<h2 id="5-2-Ribbon实现客户端负载均衡"><a href="#5-2-Ribbon实现客户端负载均衡" class="headerlink" title="5.2 Ribbon实现客户端负载均衡"></a>5.2 Ribbon实现客户端负载均衡</h2><p>由于Spring Cloud Ribbon的封装， 我们在微服务架构中使用客户端负载均衡调用非常简单， 只需要如下两步：</p>
<ol>
<li><p>启动多个服务提供者实例并注册到一个服务注册中心或是服务注册中心集群。</p>
</li>
<li><p>服务消费者通过被＠LoadBalanced注解修饰过的RestTemplate来调用服务提供者。</p>
</li>
</ol>
<p>这样，我们就可以实现服务提供者的高可用以及服务消费者的负载均衡调用。</p>
<h2 id="5-3-Ribbon负载均衡策略"><a href="#5-3-Ribbon负载均衡策略" class="headerlink" title="5.3 Ribbon负载均衡策略"></a>5.3 Ribbon负载均衡策略</h2><p>Ribbon的负载均衡策略是由IRule接口定义, 该接口由如下实现：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212134879.png" alt="image-20201216213258692"></p>
<table>
<thead>
<tr>
<th>RandomRule</th>
<th>随机</th>
</tr>
</thead>
<tbody><tr>
<td>RoundRobinRule</td>
<td>轮询</td>
</tr>
<tr>
<td>AvailabilityFilteringRule</td>
<td>先过滤掉由于多次访问故障的服务，以及并发连接数超过阈值的服务，然后对剩下的服务按照轮询策略进行访问；</td>
</tr>
<tr>
<td>WeightedResponseTimeRule</td>
<td>根据平均响应时间计算所有服务的权重，响应时间越快服务权重就越大被选中的概率即越高，如果服务刚启动时统计信息不足，则使用RoundRobinRule策略，待统计信息足够会切换到该WeightedResponseTimeRule策略；</td>
</tr>
<tr>
<td>RetryRule</td>
<td>先按照RoundRobinRule策略分发，如果分发到的服务不能访问，则在指定时间内进行重试，分发其他可用的服务；</td>
</tr>
<tr>
<td>BestAvailableRule</td>
<td>先过滤掉由于多次访问故障的服务，然后选择一个并发量最小的服务；</td>
</tr>
<tr>
<td>ZoneAvoidanceRule</td>
<td>综合判断服务节点所在区域的性能和服务节点的可用性，来决定选择哪个服务；</td>
</tr>
</tbody></table>
<h2 id="5-4-Rest请求模板类解读"><a href="#5-4-Rest请求模板类解读" class="headerlink" title="5.4 Rest请求模板类解读"></a>5.4 Rest请求模板类解读</h2><p>当我们从服务消费端去调用服务提供者的服务的时候，使用了一个极其方便的对象叫RestTemplate，当时我们只使用了RestTemplate中最简单的一个功能getForEntity发起了一个get请求去调用服务端的数据，同时，我们还通过配置@LoadBalanced注解开启客户端负载均衡，RestTemplate的功能非常强大，那么接下来我们就来详细的看一下RestTemplate中几种常见请求方法的使用。</p>
<p>在日常操作中，基于Rest的方式通常是四种情况，它们分表是：</p>
<p><strong>GET请求 –查询数据</strong></p>
<p><strong>POST请求 –添加数据</strong></p>
<p><strong>PUT请求 – 修改数据</strong></p>
<p><strong>DELETE请求 –删除数据</strong></p>
<p>下面我们逐一解读。</p>
<h2 id="5-5-RestTemplate的GET请求"><a href="#5-5-RestTemplate的GET请求" class="headerlink" title="5.5 RestTemplate的GET请求"></a>5.5 RestTemplate的GET请求</h2><p>Get请求可以有两种方式：</p>
<p>第一种：getForEntity</p>
<p>该方法返回一个ResponseEntity<T>对象，ResponseEntity<T>是Spring对HTTP请求响应的封装，包括了几个重要的元素，比如响应码、contentType、contentLength、响应消息体等；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ResponseEntity&lt;String&gt; responseEntity = restTemplate.getForEntity(<span class="string">&quot;http://01-SPRINGCLOUD-SERVICE-PROVIDER/service/hello&quot;</span>, String.class);</span><br><span class="line"><span class="type">String</span> <span class="variable">body</span> <span class="operator">=</span> responseEntity.getBody();</span><br><span class="line"><span class="type">HttpStatus</span> <span class="variable">statusCode</span> <span class="operator">=</span> responseEntity.getStatusCode();</span><br><span class="line"><span class="type">int</span> <span class="variable">statusCodeValue</span> <span class="operator">=</span> responseEntity.getStatusCodeValue();</span><br><span class="line"><span class="type">HttpHeaders</span> <span class="variable">headers</span> <span class="operator">=</span> responseEntity.getHeaders();</span><br><span class="line"></span><br><span class="line">System.out.println(body);</span><br><span class="line">System.out.println(statusCode);</span><br><span class="line">System.out.println(statusCodeValue);</span><br><span class="line">System.out.println(headers);</span><br></pre></td></tr></table></figure>

<p>以上代码：</p>
<p>getForEntity方法第一个参数为要调用的服务的地址，即服务提供者提供的<a target="_blank" rel="noopener" href="http://01-springcloud-service-provider/service/hello%E6%8E%A5%E5%8F%A3%E5%9C%B0%E5%9D%80%EF%BC%8C%E6%B3%A8%E6%84%8F%E8%BF%99%E9%87%8C%E6%98%AF%E9%80%9A%E8%BF%87%E6%9C%8D%E5%8A%A1%E5%90%8D%E8%B0%83%E7%94%A8%E8%80%8C%E4%B8%8D%E6%98%AF%E6%9C%8D%E5%8A%A1%E5%9C%B0%E5%9D%80%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%94%B9%E4%B8%BA%E6%9C%8D%E5%8A%A1%E5%9C%B0%E5%9D%80%E5%B0%B1%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8Ribbon%E5%AE%9E%E7%8E%B0%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E4%BA%86%E3%80%82">http://01-SPRINGCLOUD-SERVICE-PROVIDER/service/hello接口地址，注意这里是通过服务名调用而不是服务地址，如果改为服务地址就无法使用Ribbon实现客户端负载均衡了。</a></p>
<p>getForEntity方法第二个参数String.class表示希望返回的body类型是String类型，如果希望返回一个对象，也是可以的，比如User对象；</p>
<p>另外两个重载方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; ResponseEntity&lt;T&gt; <span class="title function_">getForEntity</span><span class="params">(String url, Class&lt;T&gt; responseType, Object... uriVariables)</span> <span class="keyword">throws</span> RestClientException</span><br><span class="line"> </span><br><span class="line">比如：</span><br><span class="line">Object [] params=&#123;<span class="number">1</span>,”张无忌”&#125;;</span><br><span class="line">restTemplate.getForEntity(<span class="string">&quot;http://01-SPRINGCLOUD-SERVICE-PROVIDER/service/hello?id=&#123;1&#125;&amp;name=&#123;2&#125;&quot;</span>, String.class, params).getBody();</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; ResponseEntity&lt;T&gt; <span class="title function_">getForEntity</span><span class="params">(String url, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables)</span> <span class="keyword">throws</span> RestClientException</span><br><span class="line">比如：</span><br><span class="line">Map&lt;String, Object&gt; paramMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">paramMap.put(<span class="string">&quot;id&quot;</span>, <span class="number">1</span>);</span><br><span class="line">paramMap.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;张无忌&quot;</span>);</span><br><span class="line">restTemplate.getForEntity(<span class="string">&quot;http://01-SPRINGCLOUD-SERVICE-PROVIDER/service/hello?id=&#123;id&#125;&amp;name=&#123;name&#125;&quot;</span>, String.class, paramMap).getBody();                         </span><br></pre></td></tr></table></figure>

<p> 第二种：getForObject()<br>与getForEntity使用类似，只不过getForObject是在getForEntity基础上进行了再次封装，可以将http的响应体body信息转化成指定的对象，方便我们的代码开发；<br>当你不需要返回响应中的其他信息，只需要body体信息的时候，可以使用这个更方便；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">它也有两个重载的方法，和getForEntity相似；</span><br><span class="line">&lt;T&gt; T <span class="title function_">getForObject</span><span class="params">(URI url, Class&lt;T&gt; responseType)</span> <span class="keyword">throws</span> RestClientException;</span><br><span class="line"> </span><br><span class="line">&lt;T&gt; T <span class="title function_">getForObject</span><span class="params">(String url, Class&lt;T&gt; responseType, Object... uriVariables)</span> <span class="keyword">throws</span> RestClientException;</span><br><span class="line"> </span><br><span class="line">&lt;T&gt; T <span class="title function_">getForObject</span><span class="params">(String url, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables)</span> <span class="keyword">throws</span> RestClientException;</span><br></pre></td></tr></table></figure>

<h2 id="5-6-RestTemplate的POST请求："><a href="#5-6-RestTemplate的POST请求：" class="headerlink" title="5.6 RestTemplate的POST请求："></a>5.6 RestTemplate的POST请求：</h2><p>Post与Get请求非常类似：</p>
<p>restTemplate.postForObject()</p>
<p>restTemplate.postForEntity()</p>
<p>restTemplate.postForLocation()</p>
<h2 id="5-7-RestTemplate的PUT请求："><a href="#5-7-RestTemplate的PUT请求：" class="headerlink" title="5.7 RestTemplate的PUT请求："></a>5.7 RestTemplate的PUT请求：</h2><p>restTemplate.put();</p>
<h2 id="5-8-RestTemplate的DELETE请求："><a href="#5-8-RestTemplate的DELETE请求：" class="headerlink" title="5.8 RestTemplate的DELETE请求："></a>5.8 RestTemplate的DELETE请求：</h2><p>restTemplate.delete();</p>
<h1 id="第六章-服务熔断Hystrix"><a href="#第六章-服务熔断Hystrix" class="headerlink" title="第六章 服务熔断Hystrix"></a>第六章 服务熔断Hystrix</h1><h2 id="6-1-Hystrix是什么"><a href="#6-1-Hystrix是什么" class="headerlink" title="6.1 Hystrix是什么"></a>6.1 Hystrix是什么</h2><p>在微服务架构中，我们是将一个单体应用拆分成多个服务单元，各个服务单元之间通过注册中心彼此发现和消费对方提供的服务，每个服务单元都是单独部署，在各自的服务进程中运行，服务之间通过远程调用实现信息交互，那么当某个服务的响应太慢或者故障，又或者因为网络波动或故障，则会造成调用者延迟或调用失败，当大量请求到达，则会造成请求的堆积，导致调用者的线程挂起，从而引发调用者也无法响应，调用者也发生故障。</p>
<p>比如电商中的用户下订单，我们有两个服务，一个下订单服务，一个减库存服务，当用户下订单时调用下订单服务，然后下订单服务又调用减库存服务，如果减库存服务响应延迟或者没有响应，则会造成下订单服务的线程挂起等待，如果大量的用户请求下订单，或导致大量的请求堆积，引起下订单服务也不可用，如果还有另外一个服务依赖于订单服务，比如用户服务，它需要查询用户订单，那么用户服务查询订单也会引起大量的延迟和请求堆积，导致用户服务也不可用。</p>
<p>所以在微服务架构中，很容易造成服务故障的蔓延，引发整个微服务系统瘫痪不可用。</p>
<p>为了解决此问题，微服务架构中引入了一种叫熔断器的服务保护机制。</p>
<p>熔断器也有叫断路器，他们表示同一个意思，最早来源于微服务之父Martin Fowler的论文CircuitBreaker一文。“熔断器”本身是一种开关装置，用于在电路上保护线路过载，当线路中有电器发生短路时，能够及时切断故障电路，防止发生过载、发热甚至起火等严重后果。</p>
<p>微服务架构中的熔断器，就是当被调用方没有响应，调用方直接返回一个错误响应即可，而不是长时间的等待，这样避免调用时因为等待而线程一直得不到释放，避免故障在分布式系统间蔓延；</p>
<p>Spring Cloud Hystrix实现了熔断器、线程隔离等一系列服务保护功能。该功能也是基于Netflix的开源框架Hystrix实现的，该框架的目标在于通过控制那些访问远程系统、服务和第三方库的节点，从而对延迟和故障提供更强大的容错能力。Hystrix具备服务降级、服务熔断、线程和信号隔离、请求缓存、请求合并以及服务监控等强大功能。</p>
<h2 id="6-2-Hystrix快速入门"><a href="#6-2-Hystrix快速入门" class="headerlink" title="6.2 Hystrix快速入门"></a>6.2 Hystrix快速入门</h2><p>在SpringCloud中使用熔断器Hystrix是非常简单和方便的，只需要简单两步即可：</p>
<ol>
<li>添加依赖</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--Spring Cloud熔断器起步依赖--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;</span><br><span class="line"> &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>



<ol start="2">
<li>在入口类中使用@EnableCircuitBreaker注解开启断路器功能，也可以使用一个名为@SpringCloudApplication的注解代替主类上的三个注解；</li>
<li>在调用远程服务的方法上添加注解：@HystrixCommand(fallbackMethod&#x3D;”error”)</li>
</ol>
<h2 id="6-3-服务消费者Hystrix测试"><a href="#6-3-服务消费者Hystrix测试" class="headerlink" title="6.3 服务消费者Hystrix测试"></a>6.3 服务消费者Hystrix测试</h2><p>hystrix默认超时时间是1000毫秒，如果你后端的响应超过此时间，就会触发断路器；</p>
<p>修改hystrix的默认超时时间：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HystrixCommand(fallbackMethod=&quot;error&quot;, commandProperties=&#123;</span></span><br><span class="line"><span class="meta">        @HystrixProperty(name=&quot;execution.isolation.thread.timeoutInMilliseconds&quot;, value=&quot;1500&quot;)&#125;)</span> <span class="comment">//熔断器，调用不通，回调error()方法</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">webHello</span> <span class="params">()</span> &#123;</span><br></pre></td></tr></table></figure>

<h2 id="6-4-Hystrix的服务降级"><a href="#6-4-Hystrix的服务降级" class="headerlink" title="6.4 Hystrix的服务降级"></a>6.4 Hystrix的服务降级</h2><p>有了服务的熔断，随之就会有服务的降级，所谓服务降级，就是当某个服务熔断之后，服务端提供的服务将不再被调用，此时由客户端自己准备一个本地的fallback回调，返回一个默认值来代表服务端的返回； </p>
<p>这种做法，虽然不能得到正确的返回结果，但至少保证了服务的可用，比直接抛出错误或服务不可用要好很多，当然这需要根据具体的业务场景来选择；</p>
<h2 id="6-5-Hystrix的异常处理"><a href="#6-5-Hystrix的异常处理" class="headerlink" title="6.5 Hystrix的异常处理"></a>6.5 Hystrix的异常处理</h2><p>我们在调用服务提供者时，我们自己也有可能会抛异常，默认情况下方法抛了异常会自动进行服务降级，交给服务降级中的方法去处理；</p>
<p>当我们自己发生异常后，只需要在服务降级方法中添加一个Throwable类型的参数就能够获取到抛出的异常的类型，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">error</span><span class="params">(Throwable throwable)</span> &#123;</span><br><span class="line">    System.out.println(throwable.getMessage());</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;error&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">此时我们可以在控制台看到异常的类型；</span><br><span class="line">如果远程服务有一个异常抛出后我们不希望进入到服务降级方法中去处理，而是直接将异常抛给用户，那么我们可以在<span class="meta">@HystrixCommand</span>注解中添加忽略异常，如下：</span><br><span class="line"><span class="meta">@HystrixCommand(fallbackMethod=&quot;error&quot;, ignoreExceptions = Exception.class)</span></span><br></pre></td></tr></table></figure>

<p><strong>自定义Hystrix请求的服务异常熔断处理</strong></p>
<p>我们也可以自定义类继承自HystrixCommand来实现自定义的Hystrix请求，在getFallback方法中调用getExecutionException方法来获取服务抛出的异常；</p>
<p>自定定义熔断器类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyHystrixCommand</span> <span class="keyword">extends</span> <span class="title class_">HystrixCommand</span>&lt;String&gt; &#123;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String url</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">MyHystrixCommand</span> <span class="params">(Setter setter, RestTemplate restTemplate,String url)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">super</span>(setter);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.restTemplate = restTemplate;</span><br><span class="line"></span><br><span class="line">       <span class="built_in">this</span>.url=url;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> String <span class="title function_">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> restTemplate.getForEntity(url, String.class).getBody();</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   * 当远程服务超时、异常、不可用等情况时，会触发该熔断方法</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getFallback</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Throwable</span> <span class="variable">throwable</span> <span class="operator">=</span> <span class="built_in">super</span>.getExecutionException();</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    System.out.println(throwable.getMessage());</span><br><span class="line"></span><br><span class="line">    System.out.println(throwable.getStackTrace());</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="comment">//实现服务熔断/降级逻辑</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;error&quot;</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">编写客户端请求方法</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/test2&quot;)</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">test2</span> <span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="type">MyHystrixCommand</span> <span class="variable">myHystrixCommand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyHystrixCommand</span>(com.netflix.hystrix.HystrixCommand.Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey(<span class="string">&quot;&quot;</span>)), restTemplate);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> myHystrixCommand.execute();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="6-6-Hystrix仪表盘监控"><a href="#6-6-Hystrix仪表盘监控" class="headerlink" title="6.6 Hystrix仪表盘监控"></a>6.6 Hystrix仪表盘监控</h2><p>Hystrix仪表盘（Hystrix Dashboard），就像汽车的仪表盘实时显示汽车的各项数据一样，Hystrix仪表盘主要用来监控Hystrix的实时运行状态，通过它我们可以看到Hystrix的各项指标信息，从而快速发现系统中存在的问题进而解决它。</p>
<p>要使用Hystrix仪表盘功能，我们首先需要有一个Hystrix Dashboard，这个功能我们可以在原来的消费者应用上添加，让原来的消费者应用具备Hystrix仪表盘功能，但一般地，微服务架构思想是推崇服务的拆分，Hystrix Dashboard也是一个服务，所以通常会单独创建一个新的工程专门用做Hystrix Dashboard服务；</p>
<p><strong>搭建一个Hystrix Dashboard服务的步骤：</strong></p>
<p><strong>第一步：</strong>创建一个普通的Spring Boot工程</p>
<p>比如创建一个名为springcloud-hystrix-dashboard的Spring Boot工程，建立好基本的结构和配置；</p>
<p><strong>第二步：</strong>添加相关依赖</p>
<p>在创建好的Spring Boot项目的 pom.xml文件中添加相关依赖，如下：</p>
<p>&lt;**dependency**&gt;<br>   &lt;**groupId**&gt;org.springframework.cloud&lt;&#x2F;**groupId**&gt;<br>   &lt;**artifactId**&gt;spring-cloud-starter-netflix-hystrix-dashboard&lt;&#x2F;**artifactId**&gt;<br> &lt;&#x2F;**dependency**&gt;</p>
<p><strong>第三步：</strong>入口类上添加注解</p>
<p>添加好依赖之后，在入口类上添加@EnableHystrixDashboard注解开启仪表盘功能，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableHystrixDashboard</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第四步：</strong>属性配置</p>
<p>最后，我们可以根据个人习惯配置一下application.properties文件，如下：</p>
<p>server.port&#x3D;3721</p>
<p>至此，我们的Hystrix监控环境就搭建好了；</p>
<p> <img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212134880.png" alt="image-20201216220216809"></p>
<p>Hystrix仪表盘工程已经创建好了，现在我们需要有一个服务，让这个服务提供一个路径为&#x2F;actuator&#x2F;hystrix.stream接口，然后就可以使用Hystrix仪表盘来对该服务进行监控了；</p>
<p>我们改造消费者服务，让其能提供&#x2F;actuator&#x2F;hystrix.stream接口，步骤如下：</p>
<ol>
<li>消费者项目需要有hystrix的依赖：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--Spring Cloud熔断器起步依赖--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;</span><br><span class="line"> &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>需要有一个spring boot的服务监控依赖：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>配置文件需要配置spring boot监控端点的访问权限：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">management.endpoints.web.exposure.include</span><br><span class="line">  这个是用来暴露 endpoints 的，由于 endpoints 中会包含很多敏感信息，除了 health 和 info 两个支持直接访问外，其他的默认不能直接访问，所以我们让它都能访问，或者指定：</span><br><span class="line">management.endpoints.web.exposure.include=hystrix.stream</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>访问入口 <a target="_blank" rel="noopener" href="http://localhost:8081/actuator/hystrix.stream">http://localhost:8081/actuator/hystrix.stream</a><br>注意：这里有一个细节需要注意，要访问&#x2F;hystrix.stream接口，首先得访问consumer工程中的任意一个其他接口，否则直接访问&#x2F;hystrix.stream接口时会输出出一连串的ping:  ping: …，先访问consumer中的任意一个其他接口，然后再访问&#x2F;hystrix.stream接口即可；</p>
</li>
</ol>
<h2 id="6-7-Hystrix仪表盘监控数据解读"><a href="#6-7-Hystrix仪表盘监控数据解读" class="headerlink" title="6.7 Hystrix仪表盘监控数据解读"></a>6.7 Hystrix仪表盘监控数据解读</h2><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212134881.png" alt="image-20201216220921983"></p>
<h1 id="第七章-声明式服务消费Feign"><a href="#第七章-声明式服务消费Feign" class="headerlink" title="第七章 声明式服务消费Feign"></a>第七章 声明式服务消费Feign</h1><h2 id="7-1-Feign是什么"><a href="#7-1-Feign是什么" class="headerlink" title="7-1. Feign是什么"></a>7-1. Feign是什么</h2><p>Feign是Netflix公司开发的一个声明式的REST调用客户端；</p>
<p>Ribbon负载均衡、Hystrix服务熔断是我们Spring Cloud中进行微服务开发非常基础的组件，在使用的过程中我们也发现它们一般都是同时出现的，而且配置也都非常相似，每次开发都有很多相同的代码，因此Spring Cloud基于Netflix Feign整合了Ribbon和Hystrix两个组件，让我们的开发工作变得更加简单，就像Spring Boot是对Spring+SpringMVC的简化一样，Spring Cloud Feign对Ribbon负载均衡、Hystrix服务熔断进行简化，在其基础上进行了进一步的封装，不仅在配置上大大简化了开发工作，同时还提供了一种声明式的Web服务客户端定义方式；</p>
<h2 id="7-2-使用Feign实现消费者"><a href="#7-2-使用Feign实现消费者" class="headerlink" title="7.2 使用Feign实现消费者"></a>7.2 使用Feign实现消费者</h2><p>使用Feign实现消费者，我们通过下面步骤进行：</p>
<p><strong>第一步</strong>：创建普通Spring Boot工程</p>
<p>首先我们来创建一个普通的Spring Boot工程，取名为：</p>
<p>05-springcloud-service-feign；</p>
<p><strong>第二步</strong>：添加依赖</p>
<p>要添加的依赖主要是spring-cloud-starter-netflix-eureka-client和spring-cloud-starter-feign，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p><strong>第三步</strong>：添加注解</p>
<p>在项目入口类上添加@EnableFeignClients注解表示开启Spring Cloud Feign的支持功能；</p>
<p><strong>第四步</strong>：声明服务</p>
<p>定义一个HelloService接口，通过@FeignClient注解来指定服务名称，进而绑定服务，然后再通过SpringMVC中提供的注解来绑定服务提供者提供的接口，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//FeignClient设置当前的接口时一个Feign的声明式接口</span></span><br><span class="line"><span class="comment">//属性</span></span><br><span class="line"><span class="comment">// name 用于指定我们需要访问的服务提供者的服务名</span></span><br><span class="line"><span class="meta">@FeignClient(name = &quot;07-springcloud-eureka-client-feign-provider&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TestService</span> &#123;</span><br><span class="line">    <span class="comment">//RequestMapping 这里用于只当我们需要访问的服务提供者的请求路径</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">test</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这相当于绑定了一个名叫07-springcloud-eureka-client-feign-provider (这里07-springcloud-eureka-client-feign-provider大小写07-SPRINGCLOUD-EUREKA-CLIENT-FEIGN-PROVIDER都可以 ) 的服务提供者提供的&#x2F;test接口；</p>
<p>我们服务提供者提供的接口如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Feign的服务提供者&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p><strong>第五步</strong>：使用Controller中调用服务</p>
<p>接着来创建一个Controller来调用上面的服务，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FeignController</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line"></span><br><span class="line">  HelloService helloService;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestMapping(&quot;/web/hello&quot;)</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> helloService.hello();</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p><strong>第六步</strong>：属性配置</p>
<p>在application.properties中指定服务注册中心、端口号等信息，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#指定服务的名称 即使是服务的消费者也会将自己注册到注册中心</span><br><span class="line">spring.application.name=<span class="number">07</span>-springcloud-eureka-client-feign-consumer</span><br><span class="line">#指定Eureka注册中的访问地址</span><br><span class="line">eureka.client.service-url.defaultZone=http:<span class="comment">//localhost:9100/eureka</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p><strong>第七步</strong>：测试</p>
<p>依次启动注册中心、服务提供者和feign实现服务消费者，然后访问如下地址：<a target="_blank" rel="noopener" href="http://localhost:8080/test">http://localhost:8080/test</a></p>
<h2 id="7-3-使用Feign实现消费者的测试"><a href="#7-3-使用Feign实现消费者的测试" class="headerlink" title="7.3 使用Feign实现消费者的测试"></a>7.3 使用Feign实现消费者的测试</h2><p><strong>负载均衡：</strong></p>
<p>我们知道，Spring Cloud 提供了Ribbon来实现负载均衡，使用Ribbo直接注入一个RestTemplate对象即可，RestTemplate已经做好了负载均衡的配置；</p>
<p>在Spring Cloud下，使用Feign也是直接可以实现负载均衡的，定义一个注解有@FeignClient注解的接口，然后使用@RequestMapping注解到方法上映射远程的REST服务，此方法也是做好负责均衡配置的。</p>
<p><strong>服务熔断：</strong></p>
<ol>
<li><p>在application.properties文件开启feign对hystrix功能支持（支持熔断）</p>
<p>feign.hystrix.enabled&#x3D;true</p>
</li>
<li><p>指定熔断回调逻辑</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//自定义熔断器类，这个类需要实现生命式服务消费接口</span></span><br><span class="line"><span class="comment">//并实现这个接口中所有的方法，为这个接口提供熔断的响应方法</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyFallBack</span> <span class="keyword">implements</span> <span class="title class_">TestService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;test请求不可用请稍后再试&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;test2请求不可用请稍后再试-------&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>服务熔断获取异常信息：<br>为@FeignClient修饰的接口加上fallback方法可以实现远程服务发生异常后进行服务的熔断，但是不能获取到远程服务的异常信息，如果要获取远程服务的异常信息，怎么办？此时可以使用fallbackFactory:<br>样例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(name=&quot;01-springcloud-service-provider&quot;, fallbackFactory= MyFallbackFactory.class)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyFallbackFactory</span> <span class="keyword">implements</span> <span class="title class_">FallbackFactory</span>&lt;HelloService&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> HelloService <span class="title function_">create</span><span class="params">(Throwable throwable)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HelloService</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> throwable.getMessage();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="第八章-API网关Zuul"><a href="#第八章-API网关Zuul" class="headerlink" title="第八章 API网关Zuul"></a>第八章 API网关Zuul</h1><h2 id="8-1-Spring-Cloud的Zuul是什么"><a href="#8-1-Spring-Cloud的Zuul是什么" class="headerlink" title="8.1 Spring Cloud的Zuul是什么"></a>8.1 Spring Cloud的Zuul是什么</h2><p>通过前面内容的学习，我们已经可以基本搭建出一套简略版的微服务架构了，我们有注册中心Eureka，可以将服务注册到该注册中心中，我们有Ribbon或Feign可以实现对服务负载均衡地调用，我们有Hystrix可以实现服务的熔断，但是我们还缺少什么呢？</p>
<p>我们首先来看一个微服务架构图：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212134882.png" alt="image-20201216223910109"></p>
<p>  在上面的架构图中，我们的服务包括：内部服务Service A和内部服务Service B，这两个服务都是集群部署，每个服务部署了3个实例，他们都会通过Eureka Server注册中心注册与订阅服务，而Open Service是一个对外的服务，也是集群部署，外部调用方通过负载均衡设备调用Open Service服务，比如负载均衡使用Nginx，这样的实现是否合理，或者是否有更好的实现方式呢？接下来我们主要围绕该问题展开讨论。</p>
<ol>
<li><p>如果我们的微服务中有很多个独立服务都要对外提供服务，那么我们要如何去管理这些接口？特别是当项目非常庞大的情况下要如何管理？</p>
</li>
<li><p>在微服务中，一个独立的系统被拆分成了很多个独立的服务，为了确保安全，权限管理也是一个不可回避的问题，如果在每一个服务上都添加上相同的权限验证代码来确保系统不被非法访问，那么工作量也就太大了，而且维护也非常不方便。</p>
</li>
</ol>
<p>为了解决上述问题，微服务架构中提出了API网关的概念，它就像一个安检站一样，所有外部的请求都需要经过它的调度与过滤，然后API网关来实现请求路由、负载均衡、权限验证等功能；</p>
<p>那么Spring Cloud这个一站式的微服务开发框架基于Netflix Zuul实现了Spring Cloud Zuul，采用Spring Cloud Zuul即可实现一套API网关服务。</p>
<h2 id="8-2-使用Zuul构建API网关"><a href="#8-2-使用Zuul构建API网关" class="headerlink" title="8.2 使用Zuul构建API网关"></a>8.2 使用Zuul构建API网关</h2><ol>
<li>创建一个普通的Spring Boot工程名为06-springcloud-api-gateway，然后添加相关依赖，这里我们主要添加两个依赖zuul和eureka依赖：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--添加spring cloud的zuul的起步依赖--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-netflix-zuul&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--添加spring cloud的eureka的客户端依赖--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在入口类上添加@EnableZuulProxy注解，开启Zuul的API网关服务功能：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableZuulProxy</span> <span class="comment">//开启Zuul的API网关服务功能</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>在application.properties文件中配置路由规则：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#配置服务内嵌的Tomcat端口</span><br><span class="line">server.port=<span class="number">8083</span></span><br><span class="line">#配置服务的名称</span><br><span class="line">spring.application.name=08-springcloud-eureka-client-zuul</span><br><span class="line">#配置路由规则zuul.routes.api-zuul.path  中api-zuul 可以任意填写</span><br><span class="line">#/api-zuul<span class="comment">/** 表示请求的拦截规则类似拦截器的拦截规则以/api-zuul开头的任意目录以及子孙目录中所有请求都会被拦截</span></span><br><span class="line"><span class="comment">zuul.routes.api-zuul.path=/api-zuul/**</span></span><br><span class="line"><span class="comment">#指向服务名字 用于对这个服务下的某个写特定请求进行拦截</span></span><br><span class="line"><span class="comment">zuul.routes.api-zuul.serviceId=08-springcloud-eureka-client-zuul-consumer</span></span><br><span class="line"><span class="comment">#配置API网关到注册中心上，API网关也将作为一个服务注册到eureka-server上</span></span><br><span class="line"><span class="comment">eureka.client.service-url.defaultZone=http://localhost:9100/eureka</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>以上配置，我们的路由规则就是匹配所有符合&#x2F;api-zuul&#x2F;**的请求，只要路径中带有&#x2F;api- zuul &#x2F;都将被转发到08-springcloud-eureka-client-zuul-consumer服务上，至于08-springcloud-eureka-client-zuul-consumer服务的地址到底是什么则由eureka-server注册中心去分析，我们只需要写上服务名即可。<br>以我们目前搭建的项目为例，请求 <a target="_blank" rel="noopener" href="http://localhost:8080/api-zuul/test">http://localhost:8080/api-zuul/test</a> 接口则相当于请求 <a target="_blank" rel="noopener" href="http://localhost:8080/test">http://localhost:8080/test</a><br>(08-springcloud-eureka-client-zuul-consumer 服务的地址为 <a target="_blank" rel="noopener" href="http://localhost:8080/test)%EF%BC%8C">http://localhost:8080/test)，</a><br>路由规则中配置的api-zuul是路由的名字，可以任意定义，但是一组path和serviceId映射关系的路由名要相同。</p>
<p>如果以上测试成功，则表示们的API网关服务已经构建成功了，我们发送的符合路由规则的请求将自动被转发到相应的服务上去处理。</p>
<h2 id="8-3-使用Zuul进行请求过滤"><a href="#8-3-使用Zuul进行请求过滤" class="headerlink" title="8.3 使用Zuul进行请求过滤"></a>8.3 使用Zuul进行请求过滤</h2><p>我们知道Spring cloud Zuul就像一个安检站，所有请求都会经过这个安检站，所以我们可以在该安检站内实现对请求的过滤，下面我们以一个权限验证案例说这一点：</p>
<p>1、我们定义一个过滤器类并继承自ZuulFilter，并将该Filter作为一个Bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义一个过滤器类用于拦截用户的请求 并继承Zuul提供的过滤器类</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthFilter</span> <span class="keyword">extends</span> <span class="title class_">ZuulFilter</span> &#123;</span><br><span class="line">    <span class="comment">//过滤器类型 决定式在请求之前还是请求之后指定当前过滤器</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">filterType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//返回pre表示要在请求之前执行过滤器</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;pre&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//过滤器的排序，如果有多个过滤器那么这些过滤器将按照返回值大小直接排序执行</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">filterOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//是否启动当前过滤器如果返回true表示将要执行这个过滤器，如果返回false表示不执行这个过滤器</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">shouldFilter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果进入当前过滤后，这个方法就是过滤器中具体的业务逻辑</span></span><br><span class="line">    <span class="comment">//注意：这个返回值目前版本没有什么特殊作用 因此返回 null即可</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">run</span><span class="params">()</span> <span class="keyword">throws</span> ZuulException &#123;</span><br><span class="line">        <span class="comment">//获取当前请求的上下文对象</span></span><br><span class="line">        RequestContext  requestContext=RequestContext.getCurrentContext();</span><br><span class="line">        <span class="comment">//获取当前请求对象</span></span><br><span class="line">        HttpServletRequest request=requestContext.getRequest();</span><br><span class="line">        <span class="comment">//获取请求参数中的token数据（用户的身份令牌）</span></span><br><span class="line">        String token=request.getParameter(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(token==<span class="literal">null</span>)&#123;<span class="comment">//进入if表示当前请求中没有携带token我们任务当前请求是非法请求</span></span><br><span class="line">            <span class="comment">//通知ZuulAPI网关当前请求非法</span></span><br><span class="line">            requestContext.setSendZuulResponse(<span class="literal">false</span>);</span><br><span class="line">            <span class="comment">//设置响应编码为401 表示权限不足</span></span><br><span class="line">            requestContext.setResponseStatusCode(<span class="number">401</span>);</span><br><span class="line">            <span class="comment">//设置响应的头文件信息以html或文本响应编码格式为utf-8</span></span><br><span class="line">            requestContext.addZuulResponseHeader(<span class="string">&quot;content-type&quot;</span>,<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">            <span class="comment">//设置响应的内容</span></span><br><span class="line">            requestContext.setResponseBody(<span class="string">&quot;非法访问&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;用户携带了身份令牌需要验证这个身份是否真的合法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（1）filterType方法的返回值为过滤器的类型，过滤器的类型决定了过滤器在哪个生命周期执行，pre表示在路由之前执行过滤器，其他值还有post、error、route和static，当然也可以自定义。</p>
<p>（2）filterOrder方法表示过滤器的执行顺序，当过滤器很多时，我们可以通过该方法的返回值来指定过滤器的执行顺序。</p>
<p>（3）shouldFilter方法用来判断过滤器是否执行，true表示执行，false表示不执行。</p>
<p>（4）run方法则表示过滤的具体逻辑，如果请求地址中携带了token参数的话，则认为是合法请求，否则为非法请求，如果是非法请求的话，首先设置ctx.setSendZuulResponse(false); 表示不对该请求进行路由，然后设置响应码和响应值。这个run方法的返回值目前暂时没有任何意义，可以返回任意值。</p>
<p>2、通过<a target="_blank" rel="noopener" href="http://localhost:8083/api-zuul/test?token=123456%E5%9C%B0%E5%9D%80%E8%AE%BF%E9%97%AE%EF%BC%8C%E5%B0%B1%E4%BC%9A%E8%A2%AB%E8%BF%87%E6%BB%A4%E5%99%A8%E8%BF%87%E6%BB%A4%E3%80%82">http://localhost:8083/api-zuul/test?token=123456地址访问，就会被过滤器过滤。</a></p>
<h2 id="8-4-Zuul的路由规则"><a href="#8-4-Zuul的路由规则" class="headerlink" title="8.4 Zuul的路由规则"></a>8.4 Zuul的路由规则</h2><p>(1) 在前面的例子中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#配置路由规则</span><br><span class="line">zuul.routes.api-zuul.path=/api-zuul<span class="comment">/**</span></span><br><span class="line"><span class="comment">zuul.routes.api-zuul.serviceId=08-springcloud-eureka-client-zuul-consumer</span></span><br><span class="line"><span class="comment">当访问地址符合/api-zuul/**规则的时候，会被自动定位到08-springcloud-eureka-client-zuul-consumer服务上，不过两行代码有点麻烦，还可以简化为：</span></span><br><span class="line"><span class="comment">zuul.routes.08-springcloud-eureka-client-zuul-consumer =/api-zuul/**</span></span><br></pre></td></tr></table></figure>

<p>zuul.routes后面跟着的是服务名，服务名后面跟着的是路径规则，这种配置方式更简单。</p>
<p>(2) 如果我们需要不给某个接口添加映射，比如说我不想给&#x2F;hello接口路由，那我们可以按如下方式配置：<br>#忽略掉某一些接口路径<br>zuul.ignored-patterns&#x3D;&#x2F;<strong>&#x2F;hello&#x2F;</strong><br>此外，我们也可以统一的为路由规则增加前缀，设置方式如下：<br>#配置网关路由的前缀<br>zuul.prefix&#x3D;&#x2F;myapi<br>此时我们的访问路径就变成了<a target="_blank" rel="noopener" href="http://localhost:8080/myapi/api-zuul/test">http://localhost:8080/myapi/api-zuul/test</a><br>(3) 路由规则通配符的含义：</p>
<table>
<thead>
<tr>
<th>通配符</th>
<th>含义</th>
<th>举例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>？</td>
<td>匹配任意单个字符</td>
<td>&#x2F;05-springcloud-service-feign&#x2F;?</td>
<td>匹配  &#x2F;05-springcloud-service-feign&#x2F;a,  &#x2F;05-springcloud-service-feign&#x2F;b,  &#x2F;05-springcloud-service-feign&#x2F;c等</td>
</tr>
<tr>
<td>*</td>
<td>匹配任意数量的字符</td>
<td>&#x2F;05-springcloud-service-feign&#x2F;*</td>
<td>匹配  &#x2F;05-springcloud-service-feign&#x2F;aaa,  &#x2F;05-springcloud-service-feign&#x2F;bbb,  &#x2F;05-springcloud-service-feign&#x2F;ccc等，  无法匹配  &#x2F;05-springcloud-service-feign&#x2F;a&#x2F;b&#x2F;c</td>
</tr>
<tr>
<td>**</td>
<td>匹配任意数量的字符</td>
<td>&#x2F;05-springcloud-service-feign&#x2F;**</td>
<td>匹配  &#x2F;05-springcloud-service-feign&#x2F;aaa,  &#x2F;05-springcloud-service-feign&#x2F;bbb,  &#x2F;05-springcloud-service-feign&#x2F;ccc等，  也可以匹配  &#x2F;05-springcloud-service-feign&#x2F;a&#x2F;b&#x2F;c</td>
</tr>
</tbody></table>
<p>(4) 一般情况下API网关只是作为各个微服务的统一入口，但是有时候我们可能也需要在API网关服务上做一些特殊的业务逻辑处理，那么我们可以让请求到达API网关后，再转发给自己本身，由API网关自己来处理，那么我们可以进行如下的操作：</p>
<p>在08-springcloud-eureka-client-zuul项目中新建如下Controller：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GateWayController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/api/local&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;exec the api gateway.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在application.properties文件中配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zuul.routes.gateway.path=/gateway<span class="comment">/**</span></span><br><span class="line"><span class="comment">zuul.routes.gateway.url=forward:/api/local</span></span><br></pre></td></tr></table></figure>

<h2 id="8-5-Zuul的异常处理"><a href="#8-5-Zuul的异常处理" class="headerlink" title="8.5 Zuul的异常处理"></a>8.5 Zuul的异常处理</h2><p>Spring Cloud Zuul对异常的处理是非常方便的，但是由于Spring Cloud处于迅速发展中，各个版本之间有所差异，本案例是以Hoxton.RC2版本为例，来说明Spring Cloud Zuul中的异常处理问题。</p>
<p>首先我们来看一张官方给出的Zuul请求的生命周期图：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112212134883.png" alt="image-20201216225425763"></p>
<ol>
<li><p>正常情况下所有的请求都是按照pre、route、post的顺序来执行，然后由post返回response</p>
</li>
<li><p>在pre阶段，如果有自定义的过滤器则执行自定义的过滤器</p>
</li>
<li><p>pre、routing、post的任意一个阶段如果抛异常了，则执行error过滤器</p>
</li>
</ol>
<p>我们可以有两种方式统一处理异常：</p>
<ol>
<li>禁用zuul默认的异常处理SendErrorFilter过滤器，然后自定义我们自己的Errorfilter过滤器</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">zuul.SendErrorFilter.error.disable=<span class="literal">true</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ErrorFilter</span> <span class="keyword">extends</span> <span class="title class_">ZuulFilter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(ErrorFilter.class);</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">filterType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;error&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">filterOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">shouldFilter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">run</span><span class="params">()</span> <span class="keyword">throws</span> ZuulException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">RequestContext</span> <span class="variable">context</span> <span class="operator">=</span> RequestContext.getCurrentContext();</span><br><span class="line">            <span class="type">ZuulException</span> <span class="variable">exception</span> <span class="operator">=</span> (ZuulException)context.getThrowable();</span><br><span class="line">            logger.error(<span class="string">&quot;进入系统异常拦截&quot;</span>, exception);</span><br><span class="line">            <span class="type">HttpServletResponse</span> <span class="variable">response</span> <span class="operator">=</span> context.getResponse();</span><br><span class="line">            response.setContentType(<span class="string">&quot;application/json; charset=utf8&quot;</span>);</span><br><span class="line">            response.setStatus(exception.nStatusCode);</span><br><span class="line">            <span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                writer = response.getWriter();</span><br><span class="line">                writer.print(<span class="string">&quot;&#123;code:&quot;</span>+ exception.nStatusCode +<span class="string">&quot;,message:\&quot;&quot;</span>+ exception.getMessage() +<span class="string">&quot;\&quot;&#125;&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(writer!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    writer.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var5) &#123;</span><br><span class="line">            ReflectionUtils.rethrowRuntimeException(var5);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>自定义全局error错误页面</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ErrorHandlerController</span> <span class="keyword">implements</span> <span class="title class_">ErrorController</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 出异常后进入该方法，交由下面的方法处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getErrorPath</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/error&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/error&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">error</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">RequestContext</span> <span class="variable">ctx</span> <span class="operator">=</span> RequestContext.getCurrentContext();</span><br><span class="line">        <span class="type">ZuulException</span> <span class="variable">exception</span> <span class="operator">=</span> (ZuulException)ctx.getThrowable();</span><br><span class="line">        <span class="keyword">return</span> exception.nStatusCode + <span class="string">&quot;--&quot;</span> + exception.getMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">注意：全局error错误页面与自定义异常的过滤器有冲突二选一即可</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">MingwHuang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://mingwzi.cn/2021/12/21/Java/SpringCloud/">http://mingwzi.cn/2021/12/21/Java/SpringCloud/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://mingwzi.cn" target="_blank">MingwHuang's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/SpringCloud/">SpringCloud</a></div><div class="post_share"><div class="social-share" data-image="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272046348.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202172251674.png" target="_blank"><img class="post-qr-code-img" src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202172251674.png" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202172251973.png" target="_blank"><img class="post-qr-code-img" src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202172251973.png" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/12/21/base/Docker/"><img class="prev-cover" src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272046348.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Docker</div></div></a></div><div class="next-post pull-right"><a href="/2021/12/21/leyou/Java%E6%A1%86%E6%9E%B6/"><img class="next-cover" src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272046348.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Spring</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272113875.JPG" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">MingwHuang</div><div class="author-info__description">朝花夕拾 聊以记之</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">45</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">42</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/HuangMingwang" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:1125385880@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站域名：http://mingwzi.cn</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">第一章 微服务架构概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E7%B3%BB%E7%BB%9F%E8%BF%9B%E5%8C%96%E7%90%86%E8%AE%BA%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 系统进化理论概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E7%B3%BB%E7%BB%9F%E8%BF%9B%E5%8C%96%E7%90%86%E8%AE%BA%E8%83%8C%E6%99%AF"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 系统进化理论背景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84"><span class="toc-number">1.3.</span> <span class="toc-text">1.3 什么是微服务架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">1.4.</span> <span class="toc-text">1.4 微服务架构的优缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9Spring-Cloud%E6%9E%84%E5%BB%BA%E5%BE%AE%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.5.</span> <span class="toc-text">1.5 为什么选择Spring Cloud构建微服务</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%AE%A4%E8%AF%86Spring-Cloud"><span class="toc-number">2.</span> <span class="toc-text">第二章 认识Spring Cloud</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-Spring-Cloud%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 Spring Cloud是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-Spring-Cloud%E7%9A%84%E7%89%88%E6%9C%AC"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 Spring Cloud的版本</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-Spring-Cloud%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 Spring Cloud开发环境</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-Spring-Cloud%E7%9A%84%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84"><span class="toc-number">2.4.</span> <span class="toc-text">2.4 Spring Cloud的整体架构</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-Spring-Cloud%E5%BF%AB%E9%80%9F%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8"><span class="toc-number">3.</span> <span class="toc-text">第三章 Spring Cloud快速开发入门</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E6%90%AD%E5%BB%BA%E5%92%8C%E9%85%8D%E7%BD%AE%E4%B8%80%E4%B8%AA%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E8%80%85"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 搭建和配置一个服务提供者</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E6%90%AD%E5%BB%BA%E5%92%8C%E9%85%8D%E7%BD%AE%E4%B8%80%E4%B8%AA%E6%9C%8D%E5%8A%A1%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 搭建和配置一个服务消费者</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E8%B5%B0%E8%BF%9B%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83Eureka"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 走进服务注册中心Eureka</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-Eureka%E4%B8%8EZookeeper%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">3.4.</span> <span class="toc-text">3.4 Eureka与Zookeeper的比较</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-%E6%90%AD%E5%BB%BA%E4%B8%8E%E9%85%8D%E7%BD%AEEureka%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83"><span class="toc-number">3.5.</span> <span class="toc-text">3.5 搭建与配置Eureka服务注册中心</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6-%E5%90%AF%E5%8A%A8%E4%B8%8E%E6%B5%8B%E8%AF%95Eureka%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83"><span class="toc-number">3.6.</span> <span class="toc-text">3.6 启动与测试Eureka服务注册中心</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-7-%E5%90%91Eureka%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E6%B3%A8%E5%86%8C%E6%9C%8D%E5%8A%A1"><span class="toc-number">3.7.</span> <span class="toc-text">3.7 向Eureka服务注册中心注册服务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-8-%E4%BB%8EEureka%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%8F%91%E7%8E%B0%E4%B8%8E%E6%B6%88%E8%B4%B9%E6%9C%8D%E5%8A%A1"><span class="toc-number">3.8.</span> <span class="toc-text">3.8 从Eureka服务注册中心发现与消费服务</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83Eureka"><span class="toc-number">4.</span> <span class="toc-text">第四章 服务注册中心Eureka</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-Eureka%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4%E6%A6%82%E8%BF%B0"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 Eureka注册中心高可用集群概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-Eureka%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 Eureka注册中心高可用集群搭建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-Eureka%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4%E6%B5%8B%E8%AF%95"><span class="toc-number">4.3.</span> <span class="toc-text">4.3 Eureka注册中心高可用集群测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-Eureka%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6"><span class="toc-number">4.4.</span> <span class="toc-text">4.4 Eureka服务注册中心自我保护机制</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9A%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1Ribbon"><span class="toc-number">5.</span> <span class="toc-text">第五章：客户端负载均衡Ribbon</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-Spring-Cloud%E4%B8%AD%E7%9A%84Ribbon%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">5.1.</span> <span class="toc-text">5.1 Spring Cloud中的Ribbon是什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Ribbon-%E4%B8%8E-Nginx-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.1.1.</span> <span class="toc-text">Ribbon 与 Nginx 的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-Ribbon%E5%AE%9E%E7%8E%B0%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">5.2.</span> <span class="toc-text">5.2 Ribbon实现客户端负载均衡</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-Ribbon%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5"><span class="toc-number">5.3.</span> <span class="toc-text">5.3 Ribbon负载均衡策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-Rest%E8%AF%B7%E6%B1%82%E6%A8%A1%E6%9D%BF%E7%B1%BB%E8%A7%A3%E8%AF%BB"><span class="toc-number">5.4.</span> <span class="toc-text">5.4 Rest请求模板类解读</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-5-RestTemplate%E7%9A%84GET%E8%AF%B7%E6%B1%82"><span class="toc-number">5.5.</span> <span class="toc-text">5.5 RestTemplate的GET请求</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-6-RestTemplate%E7%9A%84POST%E8%AF%B7%E6%B1%82%EF%BC%9A"><span class="toc-number">5.6.</span> <span class="toc-text">5.6 RestTemplate的POST请求：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-7-RestTemplate%E7%9A%84PUT%E8%AF%B7%E6%B1%82%EF%BC%9A"><span class="toc-number">5.7.</span> <span class="toc-text">5.7 RestTemplate的PUT请求：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-8-RestTemplate%E7%9A%84DELETE%E8%AF%B7%E6%B1%82%EF%BC%9A"><span class="toc-number">5.8.</span> <span class="toc-text">5.8 RestTemplate的DELETE请求：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%9C%8D%E5%8A%A1%E7%86%94%E6%96%ADHystrix"><span class="toc-number">6.</span> <span class="toc-text">第六章 服务熔断Hystrix</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-Hystrix%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">6.1.</span> <span class="toc-text">6.1 Hystrix是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-Hystrix%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8"><span class="toc-number">6.2.</span> <span class="toc-text">6.2 Hystrix快速入门</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-%E6%9C%8D%E5%8A%A1%E6%B6%88%E8%B4%B9%E8%80%85Hystrix%E6%B5%8B%E8%AF%95"><span class="toc-number">6.3.</span> <span class="toc-text">6.3 服务消费者Hystrix测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4-Hystrix%E7%9A%84%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7"><span class="toc-number">6.4.</span> <span class="toc-text">6.4 Hystrix的服务降级</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-5-Hystrix%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">6.5.</span> <span class="toc-text">6.5 Hystrix的异常处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-6-Hystrix%E4%BB%AA%E8%A1%A8%E7%9B%98%E7%9B%91%E6%8E%A7"><span class="toc-number">6.6.</span> <span class="toc-text">6.6 Hystrix仪表盘监控</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-7-Hystrix%E4%BB%AA%E8%A1%A8%E7%9B%98%E7%9B%91%E6%8E%A7%E6%95%B0%E6%8D%AE%E8%A7%A3%E8%AF%BB"><span class="toc-number">6.7.</span> <span class="toc-text">6.7 Hystrix仪表盘监控数据解读</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E5%A3%B0%E6%98%8E%E5%BC%8F%E6%9C%8D%E5%8A%A1%E6%B6%88%E8%B4%B9Feign"><span class="toc-number">7.</span> <span class="toc-text">第七章 声明式服务消费Feign</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-Feign%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">7.1.</span> <span class="toc-text">7-1. Feign是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-%E4%BD%BF%E7%94%A8Feign%E5%AE%9E%E7%8E%B0%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-number">7.2.</span> <span class="toc-text">7.2 使用Feign实现消费者</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-%E4%BD%BF%E7%94%A8Feign%E5%AE%9E%E7%8E%B0%E6%B6%88%E8%B4%B9%E8%80%85%E7%9A%84%E6%B5%8B%E8%AF%95"><span class="toc-number">7.3.</span> <span class="toc-text">7.3 使用Feign实现消费者的测试</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0-API%E7%BD%91%E5%85%B3Zuul"><span class="toc-number">8.</span> <span class="toc-text">第八章 API网关Zuul</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-Spring-Cloud%E7%9A%84Zuul%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">8.1.</span> <span class="toc-text">8.1 Spring Cloud的Zuul是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-%E4%BD%BF%E7%94%A8Zuul%E6%9E%84%E5%BB%BAAPI%E7%BD%91%E5%85%B3"><span class="toc-number">8.2.</span> <span class="toc-text">8.2 使用Zuul构建API网关</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-3-%E4%BD%BF%E7%94%A8Zuul%E8%BF%9B%E8%A1%8C%E8%AF%B7%E6%B1%82%E8%BF%87%E6%BB%A4"><span class="toc-number">8.3.</span> <span class="toc-text">8.3 使用Zuul进行请求过滤</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-4-Zuul%E7%9A%84%E8%B7%AF%E7%94%B1%E8%A7%84%E5%88%99"><span class="toc-number">8.4.</span> <span class="toc-text">8.4 Zuul的路由规则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-5-Zuul%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">8.5.</span> <span class="toc-text">8.5 Zuul的异常处理</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/03/17/base/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="计算机网络"><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272046012.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机网络"/></a><div class="content"><a class="title" href="/2022/03/17/base/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="计算机网络">计算机网络</a><time datetime="2022-03-17T12:46:58.000Z" title="发表于 2022-03-17 20:46:58">2022-03-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/17/base/JVM/" title="JVM"><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272046990.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JVM"/></a><div class="content"><a class="title" href="/2022/03/17/base/JVM/" title="JVM">JVM</a><time datetime="2022-03-17T10:46:58.000Z" title="发表于 2022-03-17 18:46:58">2022-03-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/12/%E6%9C%AA%E5%91%BD%E5%90%8D/" title="无题"><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272046348.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2022/03/12/%E6%9C%AA%E5%91%BD%E5%90%8D/" title="无题">无题</a><time datetime="2022-03-12T08:47:16.570Z" title="发表于 2022-03-12 16:47:16">2022-03-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/02/base/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" title="操作系统"><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272046348.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="操作系统"/></a><div class="content"><a class="title" href="/2022/03/02/base/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" title="操作系统">操作系统</a><time datetime="2022-03-02T02:54:05.000Z" title="发表于 2022-03-02 10:54:05">2022-03-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/01/base/Linux/" title="Linux"><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272046990.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux"/></a><div class="content"><a class="title" href="/2022/03/01/base/Linux/" title="Linux">Linux</a><time datetime="2022-03-01T15:08:28.000Z" title="发表于 2022-03-01 23:08:28">2022-03-01</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By MingwHuang</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a><span class="footer-separator">|</span><a href="https://beian.miit.gov.cn/" target="_blank">赣ICP备2022001353号-1</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>