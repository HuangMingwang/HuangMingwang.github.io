<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>C语言 | MingwHuang's Blog</title><meta name="keywords" content="C"><meta name="author" content="MingwHuang"><meta name="copyright" content="MingwHuang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="C简介C 语言是一种通用的高级语言，最初是由丹尼斯·里奇在贝尔实验室为开发 UNIX 操作系统而设计的。C 语言最开始是于 1972 年在 DEC PDP-11 计算机上被首次实现。 在 1978 年，布莱恩·柯林汉（Brian Kernighan）和丹尼斯·里奇（Dennis Ritchie）制作了 C 的第一个公开可用的描述，现在被称为 K&amp;R 标准。 UNIX 操作系统，C编译器，和">
<meta property="og:type" content="article">
<meta property="og:title" content="C语言">
<meta property="og:url" content="http://example.com/2021/12/21/C%E3%80%81C++/C%E8%AF%AD%E8%A8%80/index.html">
<meta property="og:site_name" content="MingwHuang&#39;s Blog">
<meta property="og:description" content="C简介C 语言是一种通用的高级语言，最初是由丹尼斯·里奇在贝尔实验室为开发 UNIX 操作系统而设计的。C 语言最开始是于 1972 年在 DEC PDP-11 计算机上被首次实现。 在 1978 年，布莱恩·柯林汉（Brian Kernighan）和丹尼斯·里奇（Dennis Ritchie）制作了 C 的第一个公开可用的描述，现在被称为 K&amp;R 标准。 UNIX 操作系统，C编译器，和">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202262325790.jpg">
<meta property="article:published_time" content="2021-12-20T20:59:40.000Z">
<meta property="article:modified_time" content="2022-02-22T13:55:23.928Z">
<meta property="article:author" content="MingwHuang">
<meta property="article:tag" content="C">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202262325790.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2021/12/21/C%E3%80%81C++/C%E8%AF%AD%E8%A8%80/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":500},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C语言',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-02-22 21:55:23'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">42</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">41</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">20</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202262325790.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">MingwHuang's Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">C语言</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-12-20T20:59:40.000Z" title="发表于 2021-12-21 04:59:40">2021-12-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-02-22T13:55:23.928Z" title="更新于 2022-02-22 21:55:23">2022-02-22</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C/">C</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="C语言"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="C简介"><a href="#C简介" class="headerlink" title="C简介"></a>C简介</h1><p>C 语言是一种通用的高级语言，最初是由丹尼斯·里奇在贝尔实验室为开发 UNIX 操作系统而设计的。C 语言最开始是于 1972 年在 DEC PDP-11 计算机上被首次实现。</p>
<p>在 1978 年，布莱恩·柯林汉（Brian Kernighan）和丹尼斯·里奇（Dennis Ritchie）制作了 C 的第一个公开可用的描述，现在被称为 K&amp;R 标准。</p>
<p>UNIX 操作系统，C编译器，和几乎所有的 UNIX 应用程序都是用 C 语言编写的。由于各种原因，C 语言现在已经成为一种广泛使用的专业语言。</p>
<ul>
<li>易于学习。</li>
<li>结构化语言。</li>
<li>它产生高效率的程序。</li>
<li>它可以处理底层的活动。</li>
<li>它可以在多种计算机平台上编译。</li>
</ul>
<h2 id="关于C"><a href="#关于C" class="headerlink" title="关于C"></a>关于C</h2><ul>
<li>C 语言是为了编写 UNIX 操作系统而被发明的。</li>
<li>C 语言是以 B 语言为基础的，B 语言大概是在 1970 年被引进的。</li>
<li>C 语言标准是于 1988 年由美国国家标准协会（ANSI，全称 American National Standard Institute）制定的。</li>
<li>截至 1973 年，UNIX 操作系统完全使用 C 语言编写。</li>
<li>目前，C 语言是最广泛使用的系统程序设计语言。</li>
<li>大多数先进的软件都是使用 C 语言实现的。</li>
<li>当今最流行的 Linux 操作系统和 RDBMS（Relational Database Management System：关系数据库管理系统） MySQL 都是使用 C 语言编写的。</li>
</ul>
<h2 id="为什么要使用C"><a href="#为什么要使用C" class="headerlink" title="为什么要使用C?"></a>为什么要使用C?</h2><p>C 语言最初是用于系统开发工作，特别是组成操作系统的程序。由于 C 语言所产生的代码运行速度与汇编语言编写的代码运行速度几乎一样，所以采用 C 语言作为系统开发语言。下面列举几个使用 C 的实例：</p>
<ul>
<li>操作系统</li>
<li>语言编译器</li>
<li>汇编器</li>
<li>文本编辑器</li>
<li>打印机</li>
<li>网络驱动器</li>
<li>现代程序</li>
<li>数据库</li>
<li>语言解释器</li>
<li>实体工具</li>
</ul>
<h2 id="C11"><a href="#C11" class="headerlink" title="C11"></a>C11</h2><p>C11（也被称为C1X）指ISO标准ISO&#x2F;IEC 9899:2011，是当前最新的C语言标准。在它之前的C语言标准为C99。</p>
<p>新特性</p>
<ul>
<li>对齐处理（Alignment）的标准化（包括_Alignas标志符，alignof运算符，aligned_alloc函数以及&lt;stdalign.h&gt;头文件）。</li>
<li>_Noreturn 函数标记，类似于 gcc 的 <strong>attribute</strong>((noreturn))。</li>
<li>_Generic 关键字。</li>
<li>多线程（Multithreading）支持，包括：<br>_Thread_local存储类型标识符，&lt;threads.h&gt;头文件，里面包含了线程的创建和管理函数。<br>_Atomic类型修饰符和&lt;stdatomic.h&gt;头文件。</li>
<li>增强的Unicode的支持。基于C Unicode技术报告ISO&#x2F;IEC TR 19769:2004，增强了对Unicode的支持。包括为UTF-16&#x2F;UTF-32编码增加了char16_t和char32_t数据类型，提供了包含unicode字符串转换函数的头文件&lt;uchar.h&gt;。</li>
<li>删除了 gets() 函数，使用一个新的更安全的函数gets_s()替代。</li>
<li>增加了边界检查函数接口，定义了新的安全的函数，例如 fopen_s()，strcat_s() 等等。</li>
<li>增加了更多浮点处理宏(宏)。</li>
<li>匿名结构体&#x2F;联合体支持。这个在gcc早已存在，C11将其引入标准。</li>
<li>静态断言（Static assertions），_Static_assert()，在解释 #if 和 #error 之后被处理。</li>
<li>新的 fopen() 模式，(“…x”)。类似 POSIX 中的 O_CREAT|O_EXCL，在文件锁中比较常用。</li>
<li>新增 quick_exit() 函数作为第三种终止程序的方式。当 exit()失败时可以做最少的清理工作。</li>
</ul>
<h1 id="C环境设置"><a href="#C环境设置" class="headerlink" title="C环境设置"></a>C环境设置</h1><h2 id="UNIX-x2F-Linux-上的安装"><a href="#UNIX-x2F-Linux-上的安装" class="headerlink" title="UNIX&#x2F;Linux 上的安装"></a>UNIX&#x2F;Linux 上的安装</h2><p>如果您使用的是 <strong>Linux 或 UNIX</strong>，请在命令行使用下面的命令来检查您的系统上是否安装了 GCC：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -v</span><br></pre></td></tr></table></figure>

<p>如果您的计算机上已经安装了 GNU 编译器，则会显示如下消息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Using built-in specs.</span><br><span class="line">Target: i386-redhat-linux</span><br><span class="line">Configured with: ../configure --prefix=/usr .......</span><br><span class="line">Thread model: posix</span><br><span class="line">gcc version 4.1.2 20080704 (Red Hat 4.1.2-46)</span><br></pre></td></tr></table></figure>

<p>如果未安装 GCC，那么请按照 <a target="_blank" rel="noopener" href="http://gcc.gnu.org/install/">http://gcc.gnu.org/install/</a> 上的详细说明安装 GCC。</p>
<p>本教程是基于 Linux 编写的，所有给定的实例都已在 Cent OS Linux 系统上编译过。</p>
<h2 id="Mac-OS-上的安装"><a href="#Mac-OS-上的安装" class="headerlink" title="Mac OS 上的安装"></a>Mac OS 上的安装</h2><p>如果您使用的是 Mac OS X，最快捷的获取 GCC 的方法是从苹果的网站上下载 Xcode 开发环境，并按照安装说明进行安装。一旦安装上 Xcode，您就能使用 GNU 编译器。</p>
<p>Xcode 目前可从 <a target="_blank" rel="noopener" href="http://developer.apple.com/technologies/tools/">developer.apple.com&#x2F;technologies&#x2F;tools&#x2F;</a> 上下载。</p>
<h2 id="Windows-上的安装"><a href="#Windows-上的安装" class="headerlink" title="Windows 上的安装"></a>Windows 上的安装</h2><p>最常用的免费可用的编译器是 GNU 的 C&#x2F;C++ 编译器</p>
<p>为了在 Windows 上安装 GCC，您需要安装 MinGW(“Minimalist GNU for Windows”,)。为了安装 MinGW，请访问 MinGW 的主页 <a target="_blank" rel="noopener" href="http://www.mingw.org/">www.mingw.org</a>，进入 MinGW 下载页面，下载最新版本的 MinGW 安装程序，命名格式为 MinGW-<version>.exe。</p>
<p>当安装 MinGW 时，您至少要安装 gcc-core、gcc-g++、binutils 和 MinGW runtime，但是一般情况下都会安装更多其他的项。</p>
<p>添加您安装的 MinGW 的 bin 子目录到您的 <strong>PATH</strong> 环境变量中，这样您就可以在命令行中通过简单的名称来指定这些工具。</p>
<p>当完成安装时，您可以从 Windows 命令行上运行 gcc、g++、ar、ranlib、dlltool 和其他一些 GNU 工具。</p>
<h1 id="C基本结构和语法"><a href="#C基本结构和语法" class="headerlink" title="C基本结构和语法"></a>C基本结构和语法</h1><h2 id="多文件编译"><a href="#多文件编译" class="headerlink" title="多文件编译"></a>多文件编译</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gcc test1.c test2.c -o main.out</span><br><span class="line">$ ./main.out</span><br></pre></td></tr></table></figure>

<h2 id="C的令牌-Token"><a href="#C的令牌-Token" class="headerlink" title="C的令牌(Token)"></a>C的令牌(Token)</h2><p>C 程序由各种令牌组成，令牌可以是关键字、标识符、常量、字符串值，或者是一个符号。例如，下面的 C 语句包括五个令牌：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello, World! \n&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这五个令牌分别是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span></span><br><span class="line">(</span><br><span class="line"><span class="string">&quot;Hello, World! \n&quot;</span></span><br><span class="line">)</span><br><span class="line">;</span><br></pre></td></tr></table></figure>

<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>C 标识符是用来标识变量、函数，或任何其他用户自定义项目的名称。一个标识符以字母 A-Z 或 a-z 或下划线 _ 开始，后跟零个或多个字母、下划线和数字（0-9）。</p>
<p>C 标识符内不允许出现标点字符，比如 @、$ 和 %。C 是<strong>区分大小写</strong>的编程语言。因此，在 C 中，<em>Manpower</em> 和 <em>manpower</em> 是两个不同的标识符。下面列出几个有效的标识符：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mohd       zara    abc   move_name  a_123</span><br><span class="line">myname50   _temp   j     a23b9      retVal</span><br></pre></td></tr></table></figure>

<h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p>下表列出了 C 中的保留字。这些保留字不能作为常量名、变量名或其他标识符名称。</p>
<table>
<thead>
<tr>
<th align="left">关键字</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">auto</td>
<td align="left">声明自动变量</td>
</tr>
<tr>
<td align="left">break</td>
<td align="left">跳出当前循环</td>
</tr>
<tr>
<td align="left">case</td>
<td align="left">开关语句分支</td>
</tr>
<tr>
<td align="left">char</td>
<td align="left">声明字符型变量或函数返回值类型</td>
</tr>
<tr>
<td align="left">const</td>
<td align="left">定义常量，如果一个变量被 const 修饰，那么它的值就不能再被改变</td>
</tr>
<tr>
<td align="left">continue</td>
<td align="left">结束当前循环，开始下一轮循环</td>
</tr>
<tr>
<td align="left">default</td>
<td align="left">开关语句中的”其它”分支</td>
</tr>
<tr>
<td align="left">do</td>
<td align="left">循环语句的循环体</td>
</tr>
<tr>
<td align="left">double</td>
<td align="left">声明双精度浮点型变量或函数返回值类型</td>
</tr>
<tr>
<td align="left">else</td>
<td align="left">条件语句否定分支（与 if 连用）</td>
</tr>
<tr>
<td align="left">enum</td>
<td align="left">声明枚举类型</td>
</tr>
<tr>
<td align="left">extern</td>
<td align="left">声明变量或函数是在其它文件或本文件的其他位置定义</td>
</tr>
<tr>
<td align="left">float</td>
<td align="left">声明浮点型变量或函数返回值类型</td>
</tr>
<tr>
<td align="left">for</td>
<td align="left">一种循环语句</td>
</tr>
<tr>
<td align="left">goto</td>
<td align="left">无条件跳转语句</td>
</tr>
<tr>
<td align="left">if</td>
<td align="left">条件语句</td>
</tr>
<tr>
<td align="left">int</td>
<td align="left">声明整型变量或函数</td>
</tr>
<tr>
<td align="left">long</td>
<td align="left">声明长整型变量或函数返回值类型</td>
</tr>
<tr>
<td align="left">register</td>
<td align="left">声明寄存器变量</td>
</tr>
<tr>
<td align="left">return</td>
<td align="left">子程序返回语句（可以带参数，也可不带参数）</td>
</tr>
<tr>
<td align="left">short</td>
<td align="left">声明短整型变量或函数</td>
</tr>
<tr>
<td align="left">signed</td>
<td align="left">声明有符号类型变量或函数</td>
</tr>
<tr>
<td align="left">sizeof</td>
<td align="left">计算数据类型或变量长度（即所占字节数）</td>
</tr>
<tr>
<td align="left">static</td>
<td align="left">声明静态变量</td>
</tr>
<tr>
<td align="left">struct</td>
<td align="left">声明结构体类型</td>
</tr>
<tr>
<td align="left">switch</td>
<td align="left">用于开关语句</td>
</tr>
<tr>
<td align="left">typedef</td>
<td align="left">用以给数据类型取别名</td>
</tr>
<tr>
<td align="left">unsigned</td>
<td align="left">声明无符号类型变量或函数</td>
</tr>
<tr>
<td align="left">union</td>
<td align="left">声明共用体类型</td>
</tr>
<tr>
<td align="left">void</td>
<td align="left">声明函数无返回值或无参数，声明无类型指针</td>
</tr>
<tr>
<td align="left">volatile</td>
<td align="left">说明变量在程序执行中可被隐含地改变</td>
</tr>
<tr>
<td align="left">while</td>
<td align="left">循环语句的循环条件</td>
</tr>
</tbody></table>
<h2 id="C99新增关键字"><a href="#C99新增关键字" class="headerlink" title="C99新增关键字"></a>C99新增关键字</h2><table>
<thead>
<tr>
<th><code>_Bool</code></th>
<th><code>_Complex</code></th>
<th><code>_Imaginary</code></th>
<th><code>inline</code></th>
<th><code>restrict</code></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="C11新增关键字"><a href="#C11新增关键字" class="headerlink" title="C11新增关键字"></a>C11新增关键字</h2><table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><code>_Alignas</code></td>
<td><code>_Alignof</code></td>
<td><code>_Atomic</code></td>
<td><code>_Generic</code></td>
<td><code>_Noreturn</code></td>
</tr>
<tr>
<td><code>_Static_assert</code></td>
<td><code>_Thread_local</code></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h1 id="C数据类型"><a href="#C数据类型" class="headerlink" title="C数据类型"></a>C数据类型</h1><p>C 中的类型可分为以下几种：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">类型与描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>基本类型：</strong> 它们是算术类型，包括两种类型：整数类型和浮点类型。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>枚举类型：</strong> 它们也是算术类型，被用来定义在程序中只能赋予其一定的离散整数值的变量。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>void 类型：</strong> 类型说明符 <em>void</em> 表明没有可用的值。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>派生类型：</strong> 它们包括：指针类型、数组类型、结构类型、共用体类型和函数类型。</td>
</tr>
</tbody></table>
<h2 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h2><p>下表列出了关于标准整数类型的存储大小和值范围的细节：</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">存储大小</th>
<th align="left">值范围</th>
</tr>
</thead>
<tbody><tr>
<td align="left">char</td>
<td align="left">1 字节</td>
<td align="left">-128 到 127 或 0 到 255</td>
</tr>
<tr>
<td align="left">unsigned char</td>
<td align="left">1 字节</td>
<td align="left">0 到 255</td>
</tr>
<tr>
<td align="left">signed char</td>
<td align="left">1 字节</td>
<td align="left">-128 到 127</td>
</tr>
<tr>
<td align="left">int</td>
<td align="left">2 或 4 字节</td>
<td align="left">-32,768 到 32,767 或 -2,147,483,648 到 2,147,483,647</td>
</tr>
<tr>
<td align="left">unsigned int</td>
<td align="left">2 或 4 字节</td>
<td align="left">0 到 65,535 或 0 到 4,294,967,295</td>
</tr>
<tr>
<td align="left">short</td>
<td align="left">2 字节</td>
<td align="left">-32,768 到 32,767</td>
</tr>
<tr>
<td align="left">unsigned short</td>
<td align="left">2 字节</td>
<td align="left">0 到 65,535</td>
</tr>
<tr>
<td align="left">long</td>
<td align="left">4 字节</td>
<td align="left">-2,147,483,648 到 2,147,483,647</td>
</tr>
<tr>
<td align="left">unsigned long</td>
<td align="left">4 字节</td>
<td align="left">0 到 4,294,967,295</td>
</tr>
</tbody></table>
<h2 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h2><p>下表列出了关于标准浮点类型的存储大小、值范围和精度的细节：</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">存储大小</th>
<th align="left">值范围</th>
<th align="left">精度</th>
</tr>
</thead>
<tbody><tr>
<td align="left">float</td>
<td align="left">4 字节</td>
<td align="left">1.2E-38 到 3.4E+38</td>
<td align="left">6 位小数</td>
</tr>
<tr>
<td align="left">double</td>
<td align="left">8 字节</td>
<td align="left">2.3E-308 到 1.7E+308</td>
<td align="left">15 位小数</td>
</tr>
<tr>
<td align="left">long double</td>
<td align="left">16 字节</td>
<td align="left">3.4E-4932 到 1.1E+4932</td>
<td align="left">19 位小数</td>
</tr>
</tbody></table>
<h2 id="void类型"><a href="#void类型" class="headerlink" title="void类型"></a>void类型</h2><p>void 类型指定没有可用的值。它通常用于以下三种情况下：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">类型与描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>函数返回为空</strong> C 中有各种函数都不返回值，或者您可以说它们返回空。不返回值的函数的返回类型为空。例如 <strong>void exit (int status);</strong></td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>函数参数为空</strong> C 中有各种函数不接受任何参数。不带参数的函数可以接受一个 void。例如 <strong>int rand(void);</strong></td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>指针指向 void</strong> 类型为 void * 的指针代表对象的地址，而不是类型。例如，内存分配函数 <strong>void *malloc( size_t size );</strong> 返回指向 void 的指针，可以转换为任何数据类型。</td>
</tr>
</tbody></table>
<h1 id="C变量"><a href="#C变量" class="headerlink" title="C变量"></a>C变量</h1><h2 id="C中的变量声明"><a href="#C中的变量声明" class="headerlink" title="C中的变量声明"></a>C中的变量声明</h2><p>变量声明向编译器保证变量以指定的类型和名称存在，这样编译器在不需要知道变量完整细节的情况下也能继续进一步的编译。变量声明只在编译时有它的意义，在程序连接时编译器需要实际的变量声明。</p>
<p>变量的声明有两种情况：</p>
<ul>
<li>1、一种是需要建立存储空间的。例如：int a 在声明的时候就已经建立了存储空间。</li>
<li>2、另一种是不需要建立存储空间的，通过使用extern关键字声明变量名而不定义它。 例如：extern int a 其中变量 a 可以在别的文件中定义的。</li>
<li>除非有extern关键字，否则都是变量的定义。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> i; <span class="comment">//声明，不是定义</span></span><br><span class="line"><span class="type">int</span> i; <span class="comment">//声明，也是定义</span></span><br></pre></td></tr></table></figure>

<h2 id="C中的左值-Lvalues-和右值-Rvalues"><a href="#C中的左值-Lvalues-和右值-Rvalues" class="headerlink" title="C中的左值(Lvalues)和右值(Rvalues)"></a>C中的左值(Lvalues)和右值(Rvalues)</h2><p>C 中有两种类型的表达式：</p>
<ol>
<li><strong>左值（lvalue）：</strong>指向内存位置的表达式被称为左值（lvalue）表达式。左值可以出现在赋值号的左边或右边。</li>
<li><strong>右值（rvalue）：</strong>术语右值（rvalue）指的是存储在内存中某些地址的数值。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边。</li>
</ol>
<h1 id="C常量"><a href="#C常量" class="headerlink" title="C常量"></a>C常量</h1><h2 id="定义常量"><a href="#定义常量" class="headerlink" title="定义常量"></a>定义常量</h2><p>在 C 中，有两种简单的定义常量的方式：</p>
<ol>
<li>使用 <strong>#define</strong> 预处理器。</li>
<li>使用 <strong>const</strong> 关键字。</li>
</ol>
<h1 id="C存储类"><a href="#C存储类" class="headerlink" title="C存储类"></a>C存储类</h1><p>存储类定义 C 程序中变量&#x2F;函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。下面列出 C 程序中可用的存储类：</p>
<ul>
<li>auto</li>
<li>register</li>
<li>static</li>
<li>extern</li>
</ul>
<h2 id="auto存储类"><a href="#auto存储类" class="headerlink" title="auto存储类"></a>auto存储类</h2><p><strong>auto</strong> 存储类是所有局部变量默认的存储类。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> mount;</span><br><span class="line">   <span class="keyword">auto</span> <span class="type">int</span> month;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的实例定义了两个带有相同存储类的变量，auto 只能用在函数内，即 auto 只能修饰局部变量。</p>
<h2 id="register存储类"><a href="#register存储类" class="headerlink" title="register存储类"></a>register存储类</h2><p><strong>register</strong> 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的 ‘&amp;’ 运算符（因为它没有内存位置）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="keyword">register</span> <span class="type">int</span>  miles;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>寄存器只用于需要快速访问的变量，比如计数器。还应注意的是，定义 ‘register’ 并不意味着变量将被存储在寄存器中，它意味着变量可能存储在寄存器中，这取决于硬件和实现的限制。</p>
<h2 id="staic存储类"><a href="#staic存储类" class="headerlink" title="staic存储类"></a>staic存储类</h2><p><strong>static</strong> 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。</p>
<p>static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。</p>
<p>全局声明的一个 static 变量或方法可以被任何函数或方法调用，只要这些方法出现在跟 static 变量或方法同一个文件中。</p>
<h2 id="extern存储类"><a href="#extern存储类" class="headerlink" title="extern存储类"></a>extern存储类</h2><p><strong>extern</strong> 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 <strong>extern</strong> 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。</p>
<p>当您有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 <em>extern</em>来得到已定义的变量或函数的引用。可以这么理解，<em>extern</em> 是用来在另一个文件中声明一个全局变量或函数。</p>
<h1 id="C运算符"><a href="#C运算符" class="headerlink" title="C运算符"></a>C运算符</h1><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><ul>
<li>^异或 </li>
<li>~取反 </li>
<li>&amp;按位与 </li>
<li>|按位或 </li>
<li>&lt;&lt;算数左移(左丢弃,右补0)</li>
<li>&gt;&gt;算数右移(正数左补0,负数补1,右丢弃)</li>
</ul>
<h2 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h2><p>下表将按运算符优先级从高到低列出各个运算符，具有较高优先级的运算符出现在表格的上面，具有较低优先级的运算符出现在表格的下面。在表达式中，较高优先级的运算符会优先被计算。</p>
<table>
<thead>
<tr>
<th align="left">类别</th>
<th align="left">运算符</th>
<th align="left">结合性</th>
</tr>
</thead>
<tbody><tr>
<td align="left">后缀</td>
<td align="left">() [] -&gt; . ++ - -</td>
<td align="left">从左到右</td>
</tr>
<tr>
<td align="left">一元</td>
<td align="left">+ - ! ~ ++ - - (type)* &amp; sizeof</td>
<td align="left">从右到左</td>
</tr>
<tr>
<td align="left">乘除</td>
<td align="left">* &#x2F; %</td>
<td align="left">从左到右</td>
</tr>
<tr>
<td align="left">加减</td>
<td align="left">+ -</td>
<td align="left">从左到右</td>
</tr>
<tr>
<td align="left">移位</td>
<td align="left">&lt;&lt; &gt;&gt;</td>
<td align="left">从左到右</td>
</tr>
<tr>
<td align="left">关系</td>
<td align="left">&lt; &lt;&#x3D; &gt; &gt;&#x3D;</td>
<td align="left">从左到右</td>
</tr>
<tr>
<td align="left">相等</td>
<td align="left">&#x3D;&#x3D; !&#x3D;</td>
<td align="left">从左到右</td>
</tr>
<tr>
<td align="left">位与 AND</td>
<td align="left">&amp;</td>
<td align="left">从左到右</td>
</tr>
<tr>
<td align="left">位异或 XOR</td>
<td align="left">^</td>
<td align="left">从左到右</td>
</tr>
<tr>
<td align="left">位或 OR</td>
<td align="left">|</td>
<td align="left">从左到右</td>
</tr>
<tr>
<td align="left">逻辑与 AND</td>
<td align="left">&amp;&amp;</td>
<td align="left">从左到右</td>
</tr>
<tr>
<td align="left">逻辑或 OR</td>
<td align="left">||</td>
<td align="left">从左到右</td>
</tr>
<tr>
<td align="left">条件</td>
<td align="left">?:</td>
<td align="left">从右到左</td>
</tr>
<tr>
<td align="left">赋值</td>
<td align="left">&#x3D; +&#x3D; -&#x3D; *&#x3D; &#x2F;&#x3D; %&#x3D;&gt;&gt;&#x3D; &lt;&lt;&#x3D; &amp;&#x3D; ^&#x3D; |&#x3D;</td>
<td align="left">从右到左</td>
</tr>
<tr>
<td align="left">逗号</td>
<td align="left">,</td>
<td align="left">从左到右</td>
</tr>
</tbody></table>
<h1 id="C函数"><a href="#C函数" class="headerlink" title="C函数"></a>C函数</h1><p>函数<strong>声明</strong>告诉编译器函数的名称、返回类型和参数。函数<strong>定义</strong>提供了函数的实际主体。</p>
<h2 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h2><p>函数的所有组成部分：</p>
<ul>
<li><strong>返回类型：</strong>一个函数可以返回一个值。<strong>return_type</strong> 是函数返回的值的数据类型。有些函数执行所需的操作而不返回值，在这种情况下，return_type 是关键字 <strong>void</strong>。</li>
<li><strong>函数名称：</strong>这是函数的实际名称。函数名和参数列表一起构成了函数签名。</li>
<li><strong>参数：</strong>参数就像是占位符。当函数被调用时，您向参数传递一个值，这个值被称为实际参数。参数列表包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数。</li>
<li><strong>函数主体：</strong>函数主体包含一组定义函数执行任务的语句。</li>
</ul>
<h2 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h2><p>当程序调用函数时，程序控制权会转移给被调用的函数。被调用的函数执行已定义的任务，当函数的返回语句被执行时，或到达函数的结束括号时，会把程序控制权交还给主程序。</p>
<h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><p>如果函数要使用参数，则必须声明接受参数值的变量。这些变量称为函数的<strong>形式参数</strong>。</p>
<p>形式参数就像函数内的其他局部变量，在进入函数时被创建，退出函数时被销毁。</p>
<p>当调用函数时，有两种向函数传递参数的方式：</p>
<table>
<thead>
<tr>
<th align="left">调用类型</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-call-by-value.html">传值调用</a></td>
<td align="left">该方法把参数的实际值复制给函数的形式参数。在这种情况下，修改函数内的形式参数不会影响实际参数。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-call-by-pointer.html">引用调用</a></td>
<td align="left">通过指针传递方式，形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作。</td>
</tr>
</tbody></table>
<p>默认情况下，C 使用<strong>传值调用</strong>来传递参数。一般来说，这意味着函数内的代码不能改变用于调用函数的实际参数。</p>
<p>###全局变量与局部变量在内存中的区别</p>
<ul>
<li>全局变量保存在内存的全局存储区中，占用静态的存储单元；</li>
<li>局部变量保存在栈中，只有在所在函数被调用时才动态地为变量分配存储单元。</li>
</ul>
<h3 id="初始化局部变量和全局变量"><a href="#初始化局部变量和全局变量" class="headerlink" title="初始化局部变量和全局变量"></a>初始化局部变量和全局变量</h3><p>当局部变量被定义时，系统不会对其初始化，您必须自行对其初始化。定义全局变量时，系统会自动对其初始化，如下所示：</p>
<table>
<thead>
<tr>
<th align="left">数据类型</th>
<th align="left">初始化默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="left">int</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">char</td>
<td align="left">‘\0’</td>
</tr>
<tr>
<td align="left">float</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">double</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">pointer</td>
<td align="left">NULL</td>
</tr>
</tbody></table>
<p>正确地初始化变量是一个良好的编程习惯，否则有时候程序可能会产生意想不到的结果，因为未初始化的变量会导致一些在内存位置中已经可用的垃圾值。</p>
<h1 id="C-enum-枚举"><a href="#C-enum-枚举" class="headerlink" title="C enum(枚举)"></a>C enum(枚举)</h1><p>枚举是 C 语言中的一种基本数据类型，它可以让数据更简洁，更易读。</p>
<p>枚举语法定义格式为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span>　枚举名　&#123;</span>枚举元素<span class="number">1</span>,枚举元素<span class="number">2</span>,……&#125;;</span><br></pre></td></tr></table></figure>

<p>接下来我们举个例子，比如：一星期有 7 天，如果不用枚举，我们需要使用 #define 来为每个整数定义一个别名：</p>
<p>#define MON  1 #define TUE  2 #define WED  3 #define THU  4 #define FRI  5 #define SAT  6 #define SUN  7</p>
<p>这个看起来代码量就比较多，接下来我们看看使用枚举的方式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DAY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">      MON=<span class="number">1</span>, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样看起来是不是更简洁了。</p>
<p><strong>注意：</strong>第一个枚举成员的默认值为整型的 0，后续枚举成员的值在前一个成员上加 1。我们在这个实例中把第一个枚举成员的值定义为 1，第二个就为 2，以此类推。</p>
<h2 id="枚举变量的定义"><a href="#枚举变量的定义" class="headerlink" title="枚举变量的定义"></a>枚举变量的定义</h2><p><strong>1、先定义枚举类型，再定义枚举变量</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DAY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">      MON=<span class="number">1</span>, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DAY</span> <span class="title">day</span>;</span></span><br></pre></td></tr></table></figure>

<p><strong>2、定义枚举类型的同时定义枚举变量</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DAY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">      MON=<span class="number">1</span>, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125; day;</span><br></pre></td></tr></table></figure>

<p><strong>3、省略枚举名称，直接定义枚举变量</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">      MON=<span class="number">1</span>, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125; day;</span><br></pre></td></tr></table></figure>

<h1 id="C函数指针与回掉函数"><a href="#C函数指针与回掉函数" class="headerlink" title="C函数指针与回掉函数"></a>C函数指针与回掉函数</h1><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>函数指针是指向函数的指针变量。</p>
<p>通常我们说的指针变量是指向一个整型、字符型或数组等变量，而函数指针是指向函数。</p>
<p>函数指针可以像一般函数一样，用于调用函数、传递参数。</p>
<p>函数指针变量的声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*fun_ptr)</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span>; <span class="comment">// 声明一个指向同样参数、返回值的函数指针类型</span></span><br></pre></td></tr></table></figure>

<p>实例:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt; y ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">/*p是函数指针*/</span></span><br><span class="line">    <span class="type">int</span> (*p)(<span class="type">int</span>, <span class="type">int</span>) = &amp; max; <span class="comment">//&amp; 可以省略</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,max);  <span class="comment">// 1586090832</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,&amp;max); <span class="comment">// 1586090832</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*max); <span class="comment">// 1586090832</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,p); <span class="comment">// 1586090832</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,&amp;p); <span class="comment">// -431306128</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*p); <span class="comment">// 1586090832</span></span><br><span class="line">    <span class="type">int</span> a, b ,c ,d;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入三个数字:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">    d = p(p(a,b), c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;最大的数字是:%d\n&quot;</span>,d);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译执行，输出结果如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">158690832</span><br><span class="line">158690832</span><br><span class="line">158690832</span><br><span class="line">158690832</span><br><span class="line">-431306128</span><br><span class="line">158690832</span><br><span class="line">请输入三个数字:1 2 3</span><br><span class="line">最大的数字是:3</span><br></pre></td></tr></table></figure>

<h2 id="回掉函数"><a href="#回掉函数" class="headerlink" title="回掉函数"></a>回掉函数</h2><p>函数指针变量可以作为某个函数的参数来使用的，回调函数就是一个通过函数指针调用的函数。</p>
<p>简单讲：回调函数是由别人的函数执行时调用你实现的函数。</p>
<blockquote>
<p>以下是来自知乎作者常溪玲的解说：</p>
<p>你到一个商店买东西，刚好你要的东西没有货，于是你在店员那里留下了你的电话，过了几天店里有货了，店员就打了你的电话，然后你接到电话后就到店里去取了货。在这个例子里，你的电话号码就叫回调函数，你把电话留给店员就叫登记回调函数，店里后来有货了叫做触发了回调关联的事件，店员给你打电话叫做调用回调函数，你到店里去取货叫做响应回调事件。</p>
</blockquote>
<p>实例:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>   </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  <span class="comment">// 回调函数 </span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">populate_array</span><span class="params">(<span class="type">int</span> <span class="built_in">array</span>, <span class="type">size_t</span> arraySize, <span class="type">int</span> (*getNextValue)(<span class="type">void</span>))</span> </span><br><span class="line">&#123;    <span class="keyword">for</span> (<span class="type">size_t</span> i=<span class="number">0</span>; i&lt;arraySize; i++)        </span><br><span class="line">  			<span class="built_in">array</span>[i] = getNextValue(); </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// 获取随机值 </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getNextRandomValue</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123;    </span><br><span class="line">  <span class="keyword">return</span> rand(); </span><br><span class="line">&#125;  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123;    </span><br><span class="line">  <span class="type">int</span> myarray[<span class="number">10</span>];    </span><br><span class="line">  <span class="comment">/* getNextRandomValue 不能加括号，否则无法编译，因为加上括号之后相当于传入此参数时传入了 int , 而不是函数指针*/</span></span><br><span class="line">  populate_array(myarray, <span class="number">10</span>, getNextRandomValue);    </span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;        </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, myarray[i]);    </span><br><span class="line">  &#125;    </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);    </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译执行，输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">16807 282475249 1622650073 984943658 1144108930 470211272 101027544 1457850878 1458777923 2007237709 </span><br></pre></td></tr></table></figure>

<h1 id="C字符串"><a href="#C字符串" class="headerlink" title="C字符串"></a>C字符串</h1><p>在 C 语言中，字符串实际上是使用 <strong>null</strong> 字符 ‘\0’ 终止的一维字符数组。因此，一个以 null 结尾的字符串，包含了组成字符串的字符。</p>
<p>下面的声明和初始化创建了一个 “Hello” 字符串。由于在数组的末尾存储了空字符，所以字符数组的大小比单词 “Hello” 的字符数多一个。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> greeting[<span class="number">6</span>] = &#123;<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>依据数组初始化规则，您可以把上面的语句写成以下语句：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> greeting[] = <span class="string">&quot;Hello&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>以下是 C&#x2F;C++ 中定义的字符串的内存表示：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211234080.jpg" alt="C/C++ 中的字符串表示"></p>
<p>其实，您不需要把 <em>null</em> 字符放在字符串常量的末尾。C 编译器会在初始化数组时，自动把 ‘\0’ 放在字符串的末尾。</p>
<p>C 中有大量操作字符串的函数：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">函数 &amp; 目的</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>strcpy(s1, s2);</strong> 复制字符串 s2 到字符串 s1。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>strcat(s1, s2);</strong> 连接字符串 s2 到字符串 s1 的末尾。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>strlen(s1);</strong> 返回字符串 s1 的长度。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>strcmp(s1, s2);</strong> 如果 s1 和 s2 是相同的，则返回 0；如果 s1&lt;s2 则返回小于 0；如果 s1&gt;s2 则返回大于 0。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><strong>strchr(s1, ch);</strong> 返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><strong>strstr(s1, s2);</strong> 返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。</td>
</tr>
</tbody></table>
<h1 id="C结构体"><a href="#C结构体" class="headerlink" title="C结构体"></a>C结构体</h1><p>##位域</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//说明 data 为 bs 变量，共占两个字节。其中位域 a 占 8 位，位域 b 占 2 位，位域 c 占 6 位。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bs</span>&#123;</span></span><br><span class="line">  <span class="type">int</span> a:<span class="number">8</span>;</span><br><span class="line">  <span class="type">int</span> b:<span class="number">2</span>;</span><br><span class="line">  <span class="type">int</span> c:<span class="number">6</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//在这里，packed_struct 包含了 6 个成员：四个 1 位的标识符 f1..f4、一个 4 位的 type 和一个 9 位的 my_int。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">packed_struct</span> &#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> f1:<span class="number">1</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> f2:<span class="number">1</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> f3:<span class="number">1</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> f4:<span class="number">1</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> type:<span class="number">4</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> my_int:<span class="number">9</span>;</span><br><span class="line">&#125; pack;</span><br><span class="line"><span class="comment">//空域</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bs</span>&#123;</span></span><br><span class="line">  <span class="type">int</span> a:<span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span>  :<span class="number">2</span>; <span class="comment">// 该2位不能使用</span></span><br><span class="line">  <span class="type">int</span> b:<span class="number">3</span>;</span><br><span class="line">  <span class="type">int</span> c:<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="C共用体"><a href="#C共用体" class="headerlink" title="C共用体"></a>C共用体</h1><p><strong>共用体</strong>是一种特殊的数据类型，允许您在相同的内存位置存储不同的数据类型。您可以定义一个带有多成员的共用体，但是任何时候只能有一个成员带有值。共用体提供了一种使用相同的内存位置的有效方式。</p>
<h2 id="定义共用体"><a href="#定义共用体" class="headerlink" title="定义共用体"></a>定义共用体</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Data</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">float</span> f;</span><br><span class="line">  <span class="type">char</span> str[<span class="number">20</span>];</span><br><span class="line">&#125; data;</span><br></pre></td></tr></table></figure>



<h1 id="Ctypedef"><a href="#Ctypedef" class="headerlink" title="Ctypedef"></a>Ctypedef</h1><h2 id="typedef和define"><a href="#typedef和define" class="headerlink" title="typedef和define"></a>typedef和define</h2><ul>
<li><strong>typedef</strong> 仅限于为类型定义符号名称，**#define** 不仅可以为类型定义别名，也能为数值定义别名，比如您可以定义 1 为 ONE。</li>
<li><strong>typedef</strong> 是由编译器执行解释的，**#define** 语句是由预编译器进行处理的。</li>
</ul>
<h1 id="C输入和输出"><a href="#C输入和输出" class="headerlink" title="C输入和输出"></a>C输入和输出</h1><p>当我们提到<strong>输入</strong>时，这意味着要向程序填充一些数据。输入可以是以文件的形式或从命令行中进行。C 语言提供了一系列内置的函数来读取给定的输入，并根据需要填充到程序中。</p>
<p>当我们提到<strong>输出</strong>时，这意味着要在屏幕上、打印机上或任意文件中显示一些数据。C 语言提供了一系列内置的函数来输出数据到计算机屏幕上和保存数据到文本文件或二进制文件中。</p>
<h2 id="标准文件"><a href="#标准文件" class="headerlink" title="标准文件"></a>标准文件</h2><p>C <strong>语言把所有的设备都当作文件</strong>。所以设备（比如显示器）被处理的方式与文件相同。以下三个文件会在程序执行时自动打开，以便访问键盘和屏幕。</p>
<table>
<thead>
<tr>
<th align="left">标准文件</th>
<th align="left">文件指针</th>
<th align="left">设备</th>
</tr>
</thead>
<tbody><tr>
<td align="left">标准输入</td>
<td align="left">stdin</td>
<td align="left">键盘</td>
</tr>
<tr>
<td align="left">标准输出</td>
<td align="left">stdout</td>
<td align="left">屏幕</td>
</tr>
<tr>
<td align="left">标准错误</td>
<td align="left">stderr</td>
<td align="left">您的屏幕</td>
</tr>
</tbody></table>
<p>文件指针是访问文件的方式，本节将讲解如何从屏幕读取值以及如何把结果输出到屏幕上。</p>
<p>C 语言中的 I&#x2F;O (输入&#x2F;输出) 通常使用 printf() 和 scanf() 两个函数。</p>
<p>scanf() 函数用于从标准输入（键盘）读取并格式化， printf() 函数发送格式化输出到标准输出（屏幕）。</p>
<p>实例:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>      <span class="comment">// 执行 printf() 函数需要该库</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;菜鸟教程&quot;</span>);  <span class="comment">//显示引号中的内容</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>编译以上程序，输出结果为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">菜鸟教程</span><br></pre></td></tr></table></figure>

<p><strong>实例解析：</strong></p>
<ul>
<li>所有的 C 语言程序都需要包含 <strong>main()</strong> 函数。 代码从 <strong>main()</strong> 函数开始执行。</li>
</ul>
<ul>
<li><strong>printf()</strong> 用于格式化输出到屏幕。<strong>printf()</strong> 函数在 <strong>“stdio.h”</strong> 头文件中声明。</li>
<li><strong>stdio.h</strong> 是一个头文件 (标准输入输出头文件) and <strong>#include</strong> 是一个预处理命令，用来引入头文件。 当编译器遇到 <strong>printf()</strong> 函数时，如果没有找到 <strong>stdio.h</strong> 头文件，会发生编译错误。</li>
<li><strong>return 0;</strong> 语句用于表示退出程序。</li>
</ul>
<h2 id="getchar-amp-putchar-函数"><a href="#getchar-amp-putchar-函数" class="headerlink" title="getchar() &amp; putchar() 函数"></a>getchar() &amp; putchar() 函数</h2><p><strong>int getchar(void)</strong> 函数从屏幕读取下一个可用的字符，并把它返回为一个整数。这个函数在同一个时间内只会读取一个单一的字符。您可以在循环内使用这个方法，以便从屏幕上读取多个字符。</p>
<p><strong>int putchar(int c)</strong> 函数把字符输出到屏幕上，并返回相同的字符。这个函数在同一个时间内只会输出一个单一的字符。您可以在循环内使用这个方法，以便在屏幕上输出多个字符。</p>
<h2 id="gets-amp-puts-函数"><a href="#gets-amp-puts-函数" class="headerlink" title="gets() &amp; puts() 函数"></a>gets() &amp; puts() 函数</h2><p><strong>char *gets(char *s)</strong> 函数从 <strong>stdin</strong> 读取一行到 <strong>s</strong> 所指向的缓冲区，直到一个终止符或 EOF。</p>
<p><strong>int puts(const char *s)</strong> 函数把字符串 s 和一个尾随的换行符写入到 <strong>stdout</strong>。</p>
<p>实例:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( )</span> </span><br><span class="line">&#123;   </span><br><span class="line">  <span class="type">char</span> str[<span class="number">100</span>];    </span><br><span class="line">  <span class="built_in">printf</span>( <span class="string">&quot;Enter a value :&quot;</span>);   </span><br><span class="line">  gets( str );</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">printf</span>( <span class="string">&quot;\nYou entered: &quot;</span>);   </span><br><span class="line">  <span class="built_in">puts</span>( str );   </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>当上面的代码被编译和执行时，它会等待您输入一些文本，当您输入一个文本并按下回车键时，程序会继续并读取一整行直到该行结束，显示如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$./a.out</span><br><span class="line">Enter a value :runoob</span><br><span class="line"></span><br><span class="line">You entered: runoob</span><br></pre></td></tr></table></figure>

<h2 id="scanf-和-printf-函数"><a href="#scanf-和-printf-函数" class="headerlink" title="scanf() 和 printf() 函数"></a>scanf() 和 printf() 函数</h2><p><strong>int scanf(const char *format, …)</strong> 函数从标准输入流 <strong>stdin</strong> 读取输入，并根据提供的 <strong>format</strong> 来浏览输入。</p>
<p><strong>int printf(const char *format, …)</strong> 函数把输出写入到标准输出流 <strong>stdout</strong> ，并根据提供的格式产生输出。</p>
<p><strong>format</strong> 可以是一个简单的常量字符串，但是您可以分别指定 %s、%d、%c、%f 等来输出或读取字符串、整数、字符或浮点数。还有许多其他可用的格式选项，可以根据需要使用。如需了解完整的细节，可以查看这些函数的参考手册。现在让我们通过下面这个简单的实例来加深理解：</p>
<p>实例:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( )</span> </span><br><span class="line">&#123;    </span><br><span class="line">  <span class="type">char</span> str[<span class="number">100</span>];   </span><br><span class="line">  <span class="type">int</span> i;    </span><br><span class="line">  <span class="built_in">printf</span>( <span class="string">&quot;Enter a value :&quot;</span>);   </span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s %d&quot;</span>, str, &amp;i);    </span><br><span class="line">  <span class="built_in">printf</span>( <span class="string">&quot;\nYou entered: %s %d &quot;</span>, str, i);   </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);   </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>当上面的代码被编译和执行时，它会等待您输入一些文本，当您输入一个文本并按下回车键时，程序会继续并读取输入，显示如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$./a.out</span><br><span class="line">Enter a value :runoob <span class="number">123</span></span><br><span class="line"></span><br><span class="line">You entered: runoob <span class="number">123</span> </span><br></pre></td></tr></table></figure>

<p>在这里，应当指出的是，scanf() 期待输入的格式与您给出的 %s 和 %d 相同，这意味着您必须提供有效的输入，比如 “string integer”，如果您提供的是 “string string” 或 “integer integer”，它会被认为是错误的输入。另外，在读取字符串时，只要遇到一个空格，scanf() 就会停止读取，所以 “this is test” 对 scanf() 来说是三个字符串。</p>
<h1 id="C文件读写"><a href="#C文件读写" class="headerlink" title="C文件读写"></a>C文件读写</h1><p>一个文件，无论它是文本文件还是二进制文件，都是代表了一系列的字节。C 语言不仅提供了访问顶层的函数，也提供了底层（OS）调用来处理存储设备上的文件。</p>
<h2 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h2><p>函数调用原型:</p>
<p>fopen():</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FILE *<span class="title function_">fopen</span><span class="params">( <span class="type">const</span> <span class="type">char</span> * filename, <span class="type">const</span> <span class="type">char</span> * mode )</span>;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>fopen_s(): errno_t &#x3D; 0 表示成功,其余值表示失败</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">errno_t</span> <span class="title function_">fopen_s</span><span class="params">( FILE** pFile, <span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *mode )</span>;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>mode取值:</p>
<table>
<thead>
<tr>
<th align="left">模式</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">r</td>
<td align="left">打开一个已有的文本文件，允许读取文件。</td>
</tr>
<tr>
<td align="left">w</td>
<td align="left">打开一个文本文件，允许写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会从文件的开头写入内容。如果文件存在，则该会被截断为零长度，重新写入。</td>
</tr>
<tr>
<td align="left">a</td>
<td align="left">打开一个文本文件，以追加模式写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会在已有的文件内容中追加内容。</td>
</tr>
<tr>
<td align="left">r+</td>
<td align="left">打开一个文本文件，允许读写文件。</td>
</tr>
<tr>
<td align="left">w+</td>
<td align="left">打开一个文本文件，允许读写文件。如果文件已存在，则文件会被截断为零长度，如果文件不存在，则会创建一个新文件。</td>
</tr>
<tr>
<td align="left">a+</td>
<td align="left">打开一个文本文件，允许读写文件。如果文件不存在，则会创建一个新文件。读取会从文件的开头开始，写入则只能是追加模式。</td>
</tr>
</tbody></table>
<p>如果处理的是二进制文件,则需使用下面的访问模式来取代上面的访问模式：</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="string">&quot;rb&quot;</span>, <span class="string">&quot;wb&quot;</span>, <span class="string">&quot;ab&quot;</span>, <span class="string">&quot;rb+&quot;</span>, <span class="string">&quot;r+b&quot;</span>, <span class="string">&quot;wb+&quot;</span>, <span class="string">&quot;w+b&quot;</span>, <span class="string">&quot;ab+&quot;</span>, <span class="string">&quot;a+b&quot;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h2><p>函数原型:</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fclose</span><span class="params">(FILE *fp)</span>;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>如果成功关闭文件，<strong>fclose( )</strong> 函数返回零，如果关闭文件时发生错误，函数返回 <strong>EOF</strong>。这个函数实际上，会清空缓冲区中的数据，关闭文件，并释放用于该文件的所有内存。EOF 是一个定义在头文件 <strong>stdio.h</strong> 中的常量。</p>
<h2 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h2><p>把字符写入流中的最简单的函数:</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> c, FILE *fp)</span>;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>函数 <strong>fputc()</strong> 把参数 c 的字符值写入到 fp 所指向的输出流中。如果写入成功，它会返回写入的字符，如果发生错误，则会返回 <strong>EOF</strong>。</p>
<p>把一个以 null 结尾的字符串写入到流中：</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fputs</span><span class="params">( <span class="type">const</span> <span class="type">char</span> *s, FILE *fp )</span>;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>函数 <strong>fputs()</strong> 把字符串 <strong>s</strong> 写入到 fp 所指向的输出流中。如果写入成功，它会返回一个非负值，如果发生错误，则会返回 <strong>EOF</strong>。</p>
<p>使用 <strong>int fprintf(FILE *fp,const char *format, …)</strong> 函数来写把一个字符串写入到文件中:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  FILE *fp = <span class="literal">NULL</span>;</span><br><span class="line">  fp = fopen(<span class="string">&quot;/text.txt&quot;</span>,<span class="string">&quot;w+&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(fp,<span class="string">&quot;This is testing for fprintf...\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fputs</span>(<span class="string">&quot;This is testing for fputs...\n&quot;</span>, fp);</span><br><span class="line">  fclose(fp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h2><p>从文件读取单个字符的最简单的函数:</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fgetc</span><span class="params">(FILE *fp)</span>;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>fgetc()</strong> 函数从 fp 所指向的输入文件中读取一个字符。返回值是读取的字符，如果发生错误则返回 <strong>EOF</strong>。</p>
<p>从流中读取一个字符串：</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">fgets</span><span class="params">( <span class="type">char</span> *buf, <span class="type">int</span> n, FILE *fp )</span>;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>函数 <strong>fgets()</strong> 从 fp 所指向的输入流中读取 n - 1 个字符。它会把读取的字符串复制到缓冲区 <strong>buf</strong>，并在最后追加一个 <strong>null</strong> 字符来终止字符串。</p>
<p>如果这个函数在读取最后一个字符之前就遇到一个换行符 ‘\n’ 或文件的末尾 EOF，则只会返回读取到的字符，包括换行符。</p>
<p>使用 <strong>int fscanf(FILE *fp, const char *format, …)</strong> 函数来从文件中读取字符串，但是在遇到第一个<strong>空格</strong>和<strong>换行符</strong>时，它会停止读取:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   FILE *fp = <span class="literal">NULL</span>;</span><br><span class="line">   <span class="type">char</span> buff[<span class="number">255</span>];</span><br><span class="line"> </span><br><span class="line">   fp = fopen(<span class="string">&quot;/test.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">   <span class="built_in">fscanf</span>(fp, <span class="string">&quot;%s&quot;</span>, buff);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;1: %s\n&quot;</span>, buff );</span><br><span class="line"> </span><br><span class="line">   fgets(buff, <span class="number">255</span>, (FILE*)fp);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;2: %s\n&quot;</span>, buff );</span><br><span class="line">   </span><br><span class="line">   fgets(buff, <span class="number">255</span>, (FILE*)fp);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;3: %s\n&quot;</span>, buff );</span><br><span class="line">   fclose(fp);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="number">1</span>: This</span><br><span class="line">&gt;<span class="number">2</span>: is testing <span class="keyword">for</span> <span class="built_in">fprintf</span>...</span><br><span class="line"></span><br><span class="line">&gt;<span class="number">3</span>: This is testing <span class="keyword">for</span> <span class="built_in">fputs</span>...</span><br></pre></td></tr></table></figure>
</blockquote>
<p>首先，<strong>fscanf()</strong> 方法只读取了 <strong>This</strong>，因为它在后边遇到了一个空格。其次，调用 <strong>fgets()</strong> 读取剩余的部分，直到行尾。最后，调用 <strong>fgets()</strong> 完整地读取第二行。</p>
<p><strong>strtok()</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strtok</span><span class="params">(<span class="type">char</span> s[], <span class="type">const</span> <span class="type">char</span> *delim)</span>;</span><br></pre></td></tr></table></figure>

<p>分解字符串为一组字符串。s为要分解的字符串，delim为分隔符字符（如果传入字符串，则传入的字符串中每个字符均为分割符）。首次调用时，s指向要分解的字符串，之后再次调用要把s设成NULL。</p>
<h2 id="二进制I-x2F-O函数"><a href="#二进制I-x2F-O函数" class="headerlink" title="二进制I&#x2F;O函数"></a>二进制I&#x2F;O函数</h2><p>下面两个函数用于二进制输入和输出:</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="type">size_t</span> <span class="title function_">fread</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size_of_elements, </span></span><br><span class="line"><span class="params">       <span class="type">size_t</span> number_of_elements, FILE *a_file)</span>;</span><br><span class="line">        </span><br><span class="line">&gt;<span class="type">size_t</span> <span class="title function_">fwrite</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">size_t</span> size_of_elements, </span></span><br><span class="line"><span class="params">       <span class="type">size_t</span> number_of_elements, FILE *a_file)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<p>这两个函数都是用于存储块的读写 - 通常是数组或结构体。</p>
<h1 id="C预处理器"><a href="#C预处理器" class="headerlink" title="C预处理器"></a>C预处理器</h1><p><strong>C 预处理器</strong>不是编译器的组成部分，但是它是编译过程中一个单独的步骤。简言之，C 预处理器只不过是一个文本替换工具而已，它们会指示编译器在实际编译之前完成所需的预处理。我们将把 C 预处理器（C Preprocessor）简写为 CPP。</p>
<p>所有的预处理器命令都是以井号（#）开头。它必须是第一个非空字符，为了增强可读性，预处理器指令应从第一列开始。下面列出了所有重要的预处理器指令：</p>
<table>
<thead>
<tr>
<th align="left">指令</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">#define</td>
<td align="left">定义宏</td>
</tr>
<tr>
<td align="left">#include</td>
<td align="left">包含一个源代码文件</td>
</tr>
<tr>
<td align="left">#undef</td>
<td align="left">取消已定义的宏</td>
</tr>
<tr>
<td align="left">#ifdef</td>
<td align="left">如果宏已经定义，则返回真</td>
</tr>
<tr>
<td align="left">#ifndef</td>
<td align="left">如果宏没有定义，则返回真</td>
</tr>
<tr>
<td align="left">#if</td>
<td align="left">如果给定条件为真，则编译下面代码</td>
</tr>
<tr>
<td align="left">#else</td>
<td align="left">#if 的替代方案</td>
</tr>
<tr>
<td align="left">#elif</td>
<td align="left">如果前面的 #if 给定条件不为真，当前条件为真，则编译下面代码</td>
</tr>
<tr>
<td align="left">#endif</td>
<td align="left">结束一个 #if……#else 条件编译块</td>
</tr>
<tr>
<td align="left">#error</td>
<td align="left">当遇到标准错误时，输出错误消息</td>
</tr>
<tr>
<td align="left">#pragma</td>
<td align="left">使用标准化方法，向编译器发布特殊的命令到编译器中</td>
</tr>
</tbody></table>
<h2 id="预处理器实例"><a href="#预处理器实例" class="headerlink" title="预处理器实例"></a>预处理器实例</h2><blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SIZE 20</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>这个指令告诉 CPP 把所有的 MAX_ARRAY_LENGTH 替换为 20。使用 <em>#define</em> 定义常量来增强可读性。</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">&gt;<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;myheader.h&quot;</span></span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>这些指令告诉 CPP 从<strong>系统库</strong>中获取 stdio.h，并添加文本到当前的源文件中。下一行告诉 CPP 从本地目录中获取 <strong>myheader.h</strong>，并添加内容到当前的源文件中。</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="meta">#<span class="keyword">undef</span>  FILE_SIZE</span></span><br><span class="line">&gt;<span class="meta">#<span class="keyword">define</span> FILE_SIZE 42</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>这个指令告诉 CPP 取消已定义的 FILE_SIZE，并定义它为 42。</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MESSAGE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MESSAGE <span class="string">&quot;You wish!&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>这个指令告诉 CPP 只有当 MESSAGE 未定义时，才定义 MESSAGE。</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line"><span class="comment">/* Your debugging statements here */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>这个指令告诉 CPP 如果定义了 DEBUG，则执行处理语句。在编译时，如果您向 gcc 编译器传递了 <em>-DDEBUG</em> 开关量，这个指令就非常有用。它定义了 DEBUG，您可以在编译期间随时开启或关闭调试。</p>
<h2 id="预定义宏"><a href="#预定义宏" class="headerlink" title="预定义宏"></a>预定义宏</h2><p>ANSI C 定义了许多宏。在编程中您可以使用这些宏，但是不能直接修改这些预定义的宏。</p>
<table>
<thead>
<tr>
<th align="left">宏</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">_<em>DATE</em>_</td>
<td align="left">当前日期，一个以 “MMM DD YYYY” 格式表示的字符常量。</td>
</tr>
<tr>
<td align="left">_<em>TIME</em>_</td>
<td align="left">当前时间，一个以 “HH:MM:SS” 格式表示的字符常量。</td>
</tr>
<tr>
<td align="left">_<em>FILE</em>_</td>
<td align="left">这会包含当前文件名，一个字符串常量。</td>
</tr>
<tr>
<td align="left">_<em>LINE</em>_</td>
<td align="left">这会包含当前行号，一个十进制常量。</td>
</tr>
<tr>
<td align="left">_<em>STDC</em>_</td>
<td align="left">当编译器以 ANSI 标准编译时，则定义为 1。</td>
</tr>
</tbody></table>
<p>让我们来尝试下面的实例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;File :%s\n&quot;</span>, __FILE__ );</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Date :%s\n&quot;</span>, __DATE__ );</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Time :%s\n&quot;</span>, __TIME__ );</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Line :%d\n&quot;</span>, __LINE__ );</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;ANSI :%d\n&quot;</span>, __STDC__ );</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码（在文件 <strong>test.c</strong> 中）被编译和执行时，它会产生下列结果：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">File :test.c</span><br><span class="line">Date :Jun <span class="number">2</span> <span class="number">2012</span></span><br><span class="line">Time :<span class="number">03</span>:<span class="number">36</span>:<span class="number">24</span></span><br><span class="line">Line :<span class="number">8</span></span><br><span class="line">ANSI :<span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="预处理器运算符"><a href="#预处理器运算符" class="headerlink" title="预处理器运算符"></a>预处理器运算符</h2><p>C 预处理器提供了下列的运算符来帮助您创建宏：</p>
<h5 id="宏延续运算符（-）"><a href="#宏延续运算符（-）" class="headerlink" title="宏延续运算符（\）"></a>宏延续运算符（\）</h5><p>一个宏通常写在一个单行上。但是如果宏太长，一个单行容纳不下，则使用宏延续运算符（\）。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  message_for(a, b)  \</span></span><br><span class="line"><span class="meta">    printf(#a <span class="string">&quot; and &quot;</span> #b <span class="string">&quot;: We love you!\n&quot;</span>)</span></span><br></pre></td></tr></table></figure>

<h5 id="字符串常量化运算符（-）"><a href="#字符串常量化运算符（-）" class="headerlink" title="字符串常量化运算符（#）"></a>字符串常量化运算符（#）</h5><p>在宏定义中，当需要把一个宏的参数转换为字符串常量时，则使用字符串常量化运算符（#）。在宏中使用的该运算符有一个特定的参数或参数列表。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  message_for(a, b)  \</span></span><br><span class="line"><span class="meta">    printf(#a <span class="string">&quot; and &quot;</span> #b <span class="string">&quot;: We love you!\n&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">   message_for(Carole, Debra);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Carole and Debra: We love you!</span><br></pre></td></tr></table></figure>

<h5 id="标记粘贴运算符（-）"><a href="#标记粘贴运算符（-）" class="headerlink" title="标记粘贴运算符（##）"></a>标记粘贴运算符（##）</h5><p>宏定义内的标记粘贴运算符（##）会合并两个参数。它允许在宏定义中两个独立的标记被合并为一个标记。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> tokenpaster(n) printf (<span class="string">&quot;token&quot;</span> #n <span class="string">&quot; = %d&quot;</span>, token##n)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> token34 = <span class="number">40</span>;</span><br><span class="line">   </span><br><span class="line">   tokenpaster(<span class="number">34</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">token34 = <span class="number">40</span></span><br></pre></td></tr></table></figure>

<p>这是怎么发生的，因为这个实例会从编译器产生下列的实际输出：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;token34 = %d&quot;</span>, token34);</span><br></pre></td></tr></table></figure>

<p>这个实例演示了 token##n 会连接到 token34 中，在这里，我们使用了<strong>字符串常量化运算符（#）</strong>和<strong>标记粘贴运算符（##）</strong>。</p>
<h5 id="defined-运算符"><a href="#defined-运算符" class="headerlink" title="defined() 运算符"></a>defined() 运算符</h5><p>预处理器 <strong>defined</strong> 运算符是用在常量表达式中的，用来确定一个标识符是否已经使用 #define 定义过。如果指定的标识符已定义，则值为真（非零）。如果指定的标识符未定义，则值为假（零）。下面的实例演示了 defined() 运算符的用法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined (MESSAGE)</span></span><br><span class="line">   <span class="meta">#<span class="keyword">define</span> MESSAGE <span class="string">&quot;You wish!&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Here is the message: %s\n&quot;</span>, MESSAGE);  </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Here is the message: You wish!</span><br></pre></td></tr></table></figure>

<h2 id="参数化的宏"><a href="#参数化的宏" class="headerlink" title="参数化的宏"></a>参数化的宏</h2><p>CPP 一个强大的功能是可以使用参数化的宏来模拟函数。例如，下面的代码是计算一个数的平方：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">square</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以使用宏重写上面的代码，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> square(x) ((x) * (x))</span></span><br></pre></td></tr></table></figure>

<p>在使用带有参数的宏之前，必须使用 <strong>#define</strong> 指令定义。参数列表是括在圆括号内，且必须紧跟在宏名称的后边。宏名称和左圆括号之间不允许有空格。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(x,y) ((x) &gt; (y) ? (x) : (y))</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Max between 20 and 10 is %d\n&quot;</span>, MAX(<span class="number">10</span>, <span class="number">20</span>));  </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Max between <span class="number">20</span> and <span class="number">10</span> is <span class="number">20</span></span><br></pre></td></tr></table></figure>

<h1 id="C头文件"><a href="#C头文件" class="headerlink" title="C头文件"></a>C头文件</h1><p>头文件是扩展名为 <strong>.h</strong> 的文件，包含了 C 函数声明和宏定义，被多个源文件中引用共享。有两种类型的头文件：程序员编写的头文件和编译器自带的头文件。</p>
<p>在程序中要使用头文件，需要使用 C 预处理指令 <strong>#include</strong> 来引用它。前面我们已经看过 <strong>stdio.h</strong> 头文件，它是编译器自带的头文件。</p>
<p>引用头文件相当于复制头文件的内容，但是我们不会直接在源文件中复制头文件的内容，因为这么做很容易出错，特别在程序是由多个源文件组成的时候。</p>
<p>A simple practice in C 或 C++ 程序中，建议把所有的常量、宏、系统全局变量和函数原型写在头文件中，在需要的时候随时引用这些头文件。</p>
<h2 id="引用头文件的语法"><a href="#引用头文件的语法" class="headerlink" title="引用头文件的语法"></a>引用头文件的语法</h2><p>使用预处理指令 <strong>#include</strong> 可以引用用户和系统头文件。它的形式有以下两种：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;file&gt;</span><br><span class="line">#include &quot;file&quot;</span><br><span class="line">char *test (void);</span><br><span class="line">int x;</span><br><span class="line">#include &quot;header.h&quot;</span><br><span class="line"></span><br><span class="line">int main (void)</span><br><span class="line">&#123;</span><br><span class="line">   puts (test ());</span><br><span class="line">&#125;</span><br><span class="line">int x;</span><br><span class="line">char *test (void);</span><br><span class="line"></span><br><span class="line">int main (void)</span><br><span class="line">&#123;</span><br><span class="line">   puts (test ());</span><br><span class="line">&#125;</span><br><span class="line">#ifndef HEADER_FILE</span><br><span class="line">#define HEADER_FILE</span><br><span class="line"></span><br><span class="line">the entire header file file</span><br><span class="line"></span><br><span class="line">#endif</span><br><span class="line">#if SYSTEM_1</span><br><span class="line">   # include &quot;system_1.h&quot;</span><br><span class="line">#elif SYSTEM_2</span><br><span class="line">   # include &quot;system_2.h&quot;</span><br><span class="line">#elif SYSTEM_3</span><br><span class="line">   ...</span><br><span class="line">#endif</span><br><span class="line"> #define SYSTEM_H &quot;system_1.h&quot;</span><br><span class="line"> ...</span><br><span class="line"> #include SYSTEM_H</span><br></pre></td></tr></table></figure>

<p>SYSTEM_H 会扩展，预处理器会查找 system_1.h，就像 <strong>#include</strong> 最初编写的那样。SYSTEM_H 可通过 -D 选项被您的 Makefile 定义。</p>
<p>但是如果头文件比较多的时候，这么做是很不妥当的，预处理器使用宏来定义头文件的名称。这就是所谓的<strong>有条件引用</strong>。它不是用头文件的名称作为 <strong>#include</strong> 的直接参数，您只需要使用宏名称代替即可：</p>
<p>有时需要从多个不同的头文件中选择一个引用到程序中。例如，需要指定在不同的操作系统上使用的配置参数。您可以通过一系列条件来实现这点，如下：</p>
<h2 id="有条件引用"><a href="#有条件引用" class="headerlink" title="有条件引用"></a>有条件引用</h2><p>这种结构就是通常所说的包装器 <strong>#ifndef</strong>。当再次引用头文件时，条件为假，因为 HEADER_FILE 已定义。此时，预处理器会跳过文件的整个内容，编译器会忽略它。</p>
<p>如果一个头文件被引用两次，编译器会处理两次头文件的内容，这将产生错误。为了防止这种情况，标准的做法是把文件的整个内容放在条件编译语句中，如下：</p>
<h2 id="只引用一次头文件"><a href="#只引用一次头文件" class="headerlink" title="只引用一次头文件"></a>只引用一次头文件</h2><p>编译器会看到如下的代码信息：</p>
<p>和一个使用了头文件的主程序 <em>program.c</em>，如下：</p>
<p><strong>#include</strong> 指令会指示 C 预处理器浏览指定的文件作为输入。预处理器的输出包含了已经生成的输出，被引用文件生成的输出以及 <strong>#include</strong> 指令之后的文本输出。例如，如果您有一个头文件 header.h，如下：</p>
<h2 id="引用头文件的操作"><a href="#引用头文件的操作" class="headerlink" title="引用头文件的操作"></a>引用头文件的操作</h2><p>这种形式用于引用用户头文件。它在包含当前文件的目录中搜索名为 file 的文件。在编译源代码时，您可以通过 -I 选项把目录前置在该列表前。</p>
<p>这种形式用于引用系统头文件。它在系统目录的标准列表中搜索名为 file 的文件。在编译源代码时，您可以通过 -I 选项把目录前置在该列表前。</p>
<h1 id="C错误处理"><a href="#C错误处理" class="headerlink" title="C错误处理"></a>C错误处理</h1><p>C 语言不提供对错误处理的直接支持，但是作为一种系统编程语言，它以返回值的形式允许您访问底层数据。在发生错误时，大多数的 C 或 UNIX 函数调用返回 1 或 NULL，同时会设置一个错误代码 <strong>errno</strong>，该错误代码是全局变量，表示在函数调用期间发生了错误。您可以在 errno.h 头文件中找到各种各样的错误代码。</p>
<p>所以，C 程序员可以通过检查返回值，然后根据返回值决定采取哪种适当的动作。开发人员应该在程序初始化时，把 errno 设置为 0，这是一种良好的编程习惯。0 值表示程序中没有错误。</p>
<h2 id="errno-、perror-和strerror"><a href="#errno-、perror-和strerror" class="headerlink" title="errno()、perror()和strerror()"></a>errno()、perror()和strerror()</h2><p>C 语言提供了 <strong>perror()</strong> 和 <strong>strerror()</strong> 函数来显示与 <strong>errno</strong> 相关的文本消息。</p>
<ul>
<li><strong>perror()</strong> 函数显示您传给它的字符串，后跟一个冒号、一个空格和当前 errno 值的文本表示形式。</li>
<li><strong>strerror()</strong> 函数，返回一个指针，指针指向当前 errno 值的文本表示形式。</li>
</ul>
<p>让我们来模拟一种错误情况，尝试打开一个不存在的文件。您可以使用多种方式来输出错误消息，在这里我们使用函数来演示用法。另外有一点需要注意，您应该使用 <strong>stderr</strong> 文件流来输出所有的错误。</p>
<p>实例:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> errno;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	FILE *pf;</span><br><span class="line">  <span class="type">int</span> errnum;</span><br><span class="line">  pf = fopen(<span class="string">&quot;unexist.txt&quot;</span>,<span class="string">&quot;rb&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (pf == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		errnum = errno;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;错误号:%d\n&quot;</span>,errno);</span><br><span class="line">    perror(<span class="string">&quot;通过perror输出错误&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;打开文件错误:%s\n&quot;</span>,strerror(errnum));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fclose(pf);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">错误号: <span class="number">2</span></span><br><span class="line">通过 perror 输出错误: No such file or directory</span><br><span class="line">打开文件错误: No such file or directory</span><br></pre></td></tr></table></figure>

<h2 id="被零除的错误"><a href="#被零除的错误" class="headerlink" title="被零除的错误"></a>被零除的错误</h2><p>在进行除法运算时，如果不检查除数是否为零，则会导致一个运行时错误。</p>
<p>为了避免这种情况发生，下面的代码在进行除法运算前会先检查除数是否为零：</p>
<p>实例:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line">main() &#123;   </span><br><span class="line">  <span class="type">int</span> dividend = <span class="number">20</span>;   </span><br><span class="line">  <span class="type">int</span> divisor = <span class="number">0</span>;   </span><br><span class="line">  <span class="type">int</span> quotient;    </span><br><span class="line">  <span class="keyword">if</span>( divisor == <span class="number">0</span>)&#123;      </span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;除数为 0 退出运行...\n&quot;</span>);      		 </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);   </span><br><span class="line">  &#125;   </span><br><span class="line">  quotient = dividend / divisor;       </span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;quotient 变量的值为 : %d\n&quot;</span>,quotient );    </span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">除数为 0 退出运行...</span><br></pre></td></tr></table></figure>

<h2 id="程序退出状态"><a href="#程序退出状态" class="headerlink" title="程序退出状态"></a>程序退出状态</h2><p>通常情况下，程序成功执行完一个操作正常退出的时候会带有值 EXIT_SUCCESS。在这里，EXIT_SUCCESS 是宏，它被定义为 0。</p>
<p>如果程序中存在一种错误情况，当您退出程序时，会带有状态值 EXIT_FAILURE，被定义为 -1。所以，上面的程序可以写成：</p>
<p>实例:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line">main() &#123;   </span><br><span class="line">  <span class="type">int</span> dividend = <span class="number">20</span>;   </span><br><span class="line">  <span class="type">int</span> divisor = <span class="number">5</span>;   </span><br><span class="line">  <span class="type">int</span> quotient;    </span><br><span class="line">  <span class="keyword">if</span>( divisor == <span class="number">0</span>)&#123;      </span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;除数为 0 退出运行...\n&quot;</span>);      </span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);   </span><br><span class="line">  &#125;   </span><br><span class="line">  quotient = dividend / divisor;   </span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;quotient 变量的值为: %d\n&quot;</span>, quotient );    </span><br><span class="line">  <span class="built_in">exit</span>(EXIT_SUCCESS); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quotient 变量的值为 : 4</span><br></pre></td></tr></table></figure>

<h2 id="C语言-exit（0）与exit（1）、return区别"><a href="#C语言-exit（0）与exit（1）、return区别" class="headerlink" title="C语言 exit（0）与exit（1）、return区别"></a>C语言 exit（0）与exit（1）、return区别</h2><p>exit（0）：正常运行程序并退出程序；</p>
<p>exit（1）：非正常运行导致退出程序；</p>
<p>return（）：返回函数，若在主函数中，则会退出函数并返回一值。</p>
<p>详细说：</p>
<ol>
<li><p>return返回函数值，是关键字； exit 是一个函数。</p>
</li>
<li><p>return是语言级别的，它表示了调用堆栈的返回；而exit是系统调用级别的，它表示了一个进程的结束。</p>
</li>
<li><p>return是函数的退出(返回)；exit是进程的退出。 </p>
</li>
<li><p>return是C语言提供的，exit是操作系统提供的（或者函数库中给出的）。</p>
</li>
<li><p>return用于结束一个函数的执行，将函数的执行信息传出个其他调用函数使用；exit函数是退出应用程序，删除进程使用的内存空间，并将应用程序的一个状态返回给OS(操作系统)，这个状态标识了应用程序的一些运行信息，这个信息和机器和操作系统有关，一般是 0 为正常退出，非0 为非正常退出。</p>
</li>
<li><p>非主函数中调用return和exit效果很明显，但是在main函数中调用return和exit的现象就很模糊，多数情况下现象都是一致的。</p>
</li>
</ol>
<h1 id="C可变参数"><a href="#C可变参数" class="headerlink" title="C可变参数"></a>C可变参数</h1><p>实例:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span>, ... )</span>  <span class="comment">//int 表示可传入几个参数</span></span><br><span class="line">&#123;</span><br><span class="line">   .</span><br><span class="line">   .</span><br><span class="line">   .</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   func(<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">   func(<span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>请注意，函数 <strong>func()</strong> 最后一个参数写成省略号，即三个点号（**…**），省略号之前的那个参数是 <strong>int</strong>，代表了要传递的可变参数的总数。为了使用这个功能，您需要使用 <strong>stdarg.h</strong> 头文件，该文件提供了实现可变参数功能的函数和宏。具体步骤如下：</p>
<ul>
<li>定义一个函数，最后一个参数为省略号，省略号前面可以设置自定义参数。</li>
<li>在函数定义中创建一个 <strong>va_list</strong> 类型变量，该类型是在 stdarg.h 头文件中定义的。</li>
<li>使用 <strong>int</strong> 参数和 <strong>va_start</strong> 宏来初始化 <strong>va_list</strong> 变量为一个参数列表。宏 va_start 是在 stdarg.h 头文件中定义的。</li>
<li>使用 <strong>va_arg</strong> 宏和 <strong>va_list</strong> 变量来访问参数列表中的每个项。</li>
<li>使用宏 <strong>va_end</strong> 来清理赋予 <strong>va_list</strong> 变量的内存。</li>
</ul>
<p>现在让我们按照上面的步骤，来编写一个带有可变数量参数的函数，并返回它们的平均值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">double</span> <span class="title function_">average</span><span class="params">(<span class="type">int</span> num,...)</span></span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    va_list valist;</span><br><span class="line">    <span class="type">double</span> sum = <span class="number">0.0</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 为 num 个参数初始化 valist */</span></span><br><span class="line">    va_start(valist, num);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 访问所有赋给 valist 的参数 */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">       sum += va_arg(valist, <span class="type">int</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 清理为 valist 保留的内存 */</span></span><br><span class="line">    va_end(valist);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> sum/num;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Average of 2, 3, 4, 5 = %f\n&quot;</span>, average(<span class="number">4</span>, <span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>));</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Average of 5, 10, 15 = %f\n&quot;</span>, average(<span class="number">3</span>, <span class="number">5</span>,<span class="number">10</span>,<span class="number">15</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="C内存管理"><a href="#C内存管理" class="headerlink" title="C内存管理"></a>C内存管理</h1><p>本章将讲解 C 中的动态内存管理。C 语言为内存的分配和管理提供了几个函数。这些函数可以在 <strong>&lt;stdlib.h&gt;</strong> 头文件中找到。</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">函数和描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>void *calloc(int num, int size);</strong> 在内存中动态地分配 num 个长度为 size 的连续空间，并将每一个字节都初始化为 0。所以它的结果是分配了 num*size 个字节长度的内存空间，并且每个字节的值都是0。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>void free(void *address);</strong>  该函数释放 address 所指向的内存块,释放的是动态分配的内存空间。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>void *malloc(int num);</strong>  在堆区分配一块指定大小的内存空间，用来存放数据。这块内存空间在函数执行完成后不会被初始化，它们的值是未知的。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>void *realloc(void *address, int newsize);</strong>  该函数重新分配内存，把内存扩展到 <strong>newsize</strong>。</td>
</tr>
</tbody></table>
<p><strong>注意：</strong>void * 类型表示未确定类型的指针。C、C++ 规定 void * 类型可以通过类型转换强制转换为任何其它类型的指针。</p>
<h1 id="C命令行参数"><a href="#C命令行参数" class="headerlink" title="C命令行参数"></a>C命令行参数</h1><h1 id="C排序算法"><a href="#C排序算法" class="headerlink" title="C排序算法"></a>C排序算法</h1><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j, temp;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="literal">false</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123; <span class="number">22</span>, <span class="number">34</span>, <span class="number">3</span>, <span class="number">32</span>, <span class="number">82</span>, <span class="number">55</span>, <span class="number">89</span>, <span class="number">50</span>, <span class="number">37</span>, <span class="number">5</span>, <span class="number">64</span>, <span class="number">35</span>, <span class="number">9</span>, <span class="number">70</span> &#125;;</span><br><span class="line">    <span class="type">int</span> arr1[] = &#123;<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="type">int</span> len = (<span class="type">int</span>) <span class="keyword">sizeof</span>(arr1) / <span class="keyword">sizeof</span>(*arr1);</span><br><span class="line">    bubbleSort(arr1, len);</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr1[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b)</span> &#123;</span><br><span class="line">  <span class="type">int</span> temp = *a;</span><br><span class="line">  *a = *b;</span><br><span class="line">  *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">selectionSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i, j;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="type">int</span> min = i;</span><br><span class="line">    <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">    		<span class="keyword">if</span> (arr[j] &lt; arr[min]) &#123;</span><br><span class="line">            min = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(&amp;arr[min],&amp;arr[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">insertionSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,temp;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">            temp = arr[i];</span><br><span class="line">            <span class="keyword">for</span> (j=i;j&gt;<span class="number">0</span> &amp;&amp; arr[j<span class="number">-1</span>]&gt;temp;j--)</span><br><span class="line">                    arr[j] = arr[j<span class="number">-1</span>];</span><br><span class="line">            arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h1 id="C标准库-lt-assert-h-gt"><a href="#C标准库-lt-assert-h-gt" class="headerlink" title="C标准库-&lt;assert.h&gt;"></a>C标准库-&lt;assert.h&gt;</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>C 标准库的 <strong>assert.h</strong>头文件提供了一个名为 <strong>assert</strong> 的宏，它可用于验证程序做出的假设，并在假设为假时输出诊断消息。</p>
<p>已定义的宏 <strong>assert</strong> 指向另一个宏 <strong>NDEBUG</strong>，宏 <strong>NDEBUG</strong> 不是 &lt;assert.h&gt; 的一部分。如果已在引用 &lt;assert.h&gt; 的源文件中定义 NDEBUG 为宏名称，则 <strong>assert</strong> 宏的定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define assert(ignore) ((void)0)</span><br></pre></td></tr></table></figure>

<h2 id="库宏"><a href="#库宏" class="headerlink" title="库宏"></a>库宏</h2><p>下面列出了头文件 assert.h 中定义的唯一的函数：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">函数 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-macro-assert.html">void assert(int expression)</a> 这实际上是一个宏，不是一个函数，可用于在 C 程序中添加诊断。</td>
</tr>
</tbody></table>
<h1 id="C-标准库-lt-ctype-h-gt"><a href="#C-标准库-lt-ctype-h-gt" class="headerlink" title="C 标准库 - &lt;ctype.h&gt;"></a>C 标准库 - &lt;ctype.h&gt;</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>C 标准库的 <strong>ctype.h</strong> 头文件提供了一些函数，可用于测试和映射字符。</p>
<p>这些函数接受 <strong>int</strong> 作为参数，它的值必须是 EOF 或表示为一个无符号字符。</p>
<p>如果参数 c 满足描述的条件，则这些函数返回非零（true）。如果参数 c 不满足描述的条件，则这些函数返回零。</p>
<h2 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h2><p>下面列出了头文件 ctype.h 中定义的函数：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">函数 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-isalnum.html">int isalnum(int c)</a> 该函数检查所传的字符是否是字母和数字。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-isalpha.html">int isalpha(int c)</a> 该函数检查所传的字符是否是字母。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-iscntrl.html">int iscntrl(int c)</a> 该函数检查所传的字符是否是控制字符。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-isdigit.html">int isdigit(int c)</a> 该函数检查所传的字符是否是十进制数字。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-isgraph.html">int isgraph(int c)</a> 该函数检查所传的字符是否有图形表示法。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-islower.html">int islower(int c)</a> 该函数检查所传的字符是否是小写字母。</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-isprint.html">int isprint(int c)</a> 该函数检查所传的字符是否是可打印的。</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-ispunct.html">int ispunct(int c)</a> 该函数检查所传的字符是否是标点符号字符。</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-isspace.html">int isspace(int c)</a> 该函数检查所传的字符是否是空白字符。</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-isupper.html">int isupper(int c)</a> 该函数检查所传的字符是否是大写字母。</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-isxdigit.html">int isxdigit(int c)</a> 该函数检查所传的字符是否是十六进制数字。</td>
</tr>
</tbody></table>
<p>标准库还包含了两个转换函数，它们接受并返回一个 “int”</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">函数 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-tolower.html">int tolower(int c)</a> 该函数把大写字母转换为小写字母。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-toupper.html">int toupper(int c)</a> 该函数把小写字母转换为大写字母。</td>
</tr>
</tbody></table>
<h2 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h2><table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">字符类 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>数字</strong> 完整的数字集合 { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>十六进制数字</strong> 集合 { 0 1 2 3 4 5 6 7 8 9 A B C D E F a b c d e f }</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>小写字母</strong> 集合 { a b c d e f g h i j k l m n o p q r s t u v w x y z }</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>大写字母</strong> 集合 {A B C D E F G H I J K L M N O P Q R S T U V W X Y Z }</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><strong>字母</strong> 小写字母和大写字母的集合</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><strong>字母数字字符</strong> 数字、小写字母和大写字母的集合</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><strong>标点符号字符</strong> 集合 ! “ # $ % &amp; ‘ ( ) * + , - . &#x2F; : ; &lt; &#x3D; &gt; ? @ [ \ ] ^ _ &#96; { | } ~</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><strong>图形字符</strong> 字母数字字符和标点符号字符的集合</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><strong>空格字符</strong> 制表符、换行符、垂直制表符、换页符、回车符、空格符的集合。</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left"><strong>可打印字符</strong> 字母数字字符、标点符号字符和空格字符的集合。</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left"><strong>控制字符</strong> 在 ASCII 编码中，这些字符的八进制代码是从 000 到 037，以及 177（DEL）。</td>
</tr>
<tr>
<td align="left">12</td>
<td align="left"><strong>空白字符</strong> 包括空格符和制表符。</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left"><strong>字母字符</strong> 小写字母和大写字母的集合。</td>
</tr>
</tbody></table>
<h1 id="C-标准库-lt-errno-h-gt"><a href="#C-标准库-lt-errno-h-gt" class="headerlink" title="C 标准库 - &lt;errno.h&gt;"></a>C 标准库 - &lt;errno.h&gt;</h1><h2 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h2><p>C 标准库的 <strong>errno.h</strong> 头文件定义了整数变量 <strong>errno</strong>，它是通过系统调用设置的，在错误事件中的某些库函数表明了什么发生了错误。该宏扩展为类型为 int 的可更改的左值，因此它可以被一个程序读取和修改。</p>
<p>在程序启动时，<strong>errno</strong> 设置为零，C 标准库中的特定函数修改它的值为一些非零值以表示某些类型的错误。您也可以在适当的时候修改它的值或重置为零。</p>
<p><strong>errno.h</strong> 头文件定义了一系列表示不同错误代码的宏，这些宏应扩展为类型为 <strong>int</strong> 的整数常量表达式。</p>
<h2 id="库宏-1"><a href="#库宏-1" class="headerlink" title="库宏"></a>库宏</h2><p>下面列出了头文件 errno.h 中定义的宏：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">宏 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-macro-errno.html">extern int errno</a> 这是通过系统调用设置的宏，在错误事件中的某些库函数表明了什么发生了错误。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-macro-edom.html">EDOM Domain Error</a> 这个宏表示一个域错误，它在输入参数超出数学函数定义的域时发生，errno 被设置为 EDOM。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-macro-erange.html">ERANGE Range Error</a> 这个宏表示一个范围错误，它在输入参数超出数学函数定义的范围时发生，errno 被设置为 ERANGE。</td>
</tr>
</tbody></table>
<h1 id="C-进程管理"><a href="#C-进程管理" class="headerlink" title="C 进程管理"></a>C 进程管理</h1><p>一个进程，包括代码、数据和分配给进程的资源。fork（）函数通过系统调用创建一个与原来进程几乎完全相同的进程，也就是两个进程可以做完全相同的事，但如果初始参数或者传入的变量不同，两个进程也可以做不同的事。<br>  一个进程调用fork（）函数后，系统先给新的进程分配资源，例如存储数据和代码的空间。然后把原来的进程的所有值都复制到新的新进程中，只有少数值与原来的进程的值不同。相当于克隆了一个自己。</p>
<p> 1）在父进程中，fork返回新创建子进程的进程ID；<br>  2）在子进程中，fork返回0；<br>  3）如果出现错误，fork返回一个负值；</p>
<h1 id="C-标准库-lt-float-h-gt"><a href="#C-标准库-lt-float-h-gt" class="headerlink" title="C 标准库 - &lt;float.h&gt;"></a>C 标准库 - &lt;float.h&gt;</h1><h2 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h2><p>C 标准库的 <strong>float.h</strong> 头文件包含了一组与浮点值相关的依赖于平台的常量。这些常量是由 ANSI C 提出的，这让程序更具有可移植性。在讲解这些常量之前，最好先弄清楚浮点数是由下面四个元素组成的：</p>
<table>
<thead>
<tr>
<th align="left">组件</th>
<th align="left">组件描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">S</td>
<td align="left">符号 ( +&#x2F;- )</td>
</tr>
<tr>
<td align="left">b</td>
<td align="left">指数表示的基数，2 表示二进制，10 表示十进制，16 表示十六进制，等等…</td>
</tr>
<tr>
<td align="left">e</td>
<td align="left">指数，一个介于最小值 <strong>emin</strong> 和最大值 <strong>emax</strong> 之间的整数。</td>
</tr>
<tr>
<td align="left">p</td>
<td align="left">精度，基数 b 的有效位数</td>
</tr>
</tbody></table>
<p>基于以上 4 个组成部分，一个浮点数的值如下：</p>
<p>$floating-point &#x3D; ( S ) p * b^e$</p>
<p>或</p>
<p>$floating-point &#x3D; (+&#x2F;-) precision * base^{exponent}$</p>
<h2 id="库宏-2"><a href="#库宏-2" class="headerlink" title="库宏"></a>库宏</h2><p>下面的值是特定实现的，且是通过 #define 指令来定义的，这些值都不得低于下边所给出的值。请注意，所有的实例 FLT 是指类型 float，DBL 是指类型 double，LDBL 是指类型 long double。</p>
<table>
<thead>
<tr>
<th align="left">宏</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">FLT_ROUNDS</td>
<td align="left">定义浮点加法的舍入模式，它可以是下列任何一个值：-1 - 无法确定0 - 趋向于零1 - 去最近的值2 - 趋向于正无穷3 - 趋向于负无穷</td>
</tr>
<tr>
<td align="left">FLT_RADIX 2</td>
<td align="left">这个宏定义了指数表示的基数。基数 2 表示二进制，基数 10 表示十进制，基数 16 表示十六进制。</td>
</tr>
<tr>
<td align="left">FLT_MANT_DIGDBL_MANT_DIGLDBL_MANT_DIG</td>
<td align="left">这些宏定义了 FLT_RADIX 基数中的位数。</td>
</tr>
<tr>
<td align="left">FLT_DIG 6DBL_DIG 10LDBL_DIG 10</td>
<td align="left">这些宏定义了舍入后不会改变表示的十进制数字的最大值（基数 10）。</td>
</tr>
<tr>
<td align="left">FLT_MIN_EXPDBL_MIN_EXPLDBL_MIN_EXP</td>
<td align="left">这些宏定义了基数为 FLT_RADIX 时的指数的最小负整数值。</td>
</tr>
<tr>
<td align="left">FLT_MIN_10_EXP -37DBL_MIN_10_EXP -37LDBL_MIN_10_EXP -37</td>
<td align="left">这些宏定义了基数为 10 时的指数的最小负整数值。</td>
</tr>
<tr>
<td align="left">FLT_MAX_EXPDBL_MAX_EXPLDBL_MAX_EXP</td>
<td align="left">这些宏定义了基数为 FLT_RADIX 时的指数的最大整数值。</td>
</tr>
<tr>
<td align="left">FLT_MAX_10_EXP +37DBL_MAX_10_EXP +37LDBL_MAX_10_EXP +37</td>
<td align="left">这些宏定义了基数为 10 时的指数的最大整数值。</td>
</tr>
<tr>
<td align="left">FLT_MAX 1E+37DBL_MAX 1E+37LDBL_MAX 1E+37</td>
<td align="left">这些宏定义最大的有限浮点值。</td>
</tr>
<tr>
<td align="left">FLT_EPSILON 1E-5DBL_EPSILON 1E-9LDBL_EPSILON 1E-9</td>
<td align="left">这些宏定义了可表示的最小有效数字。</td>
</tr>
<tr>
<td align="left">FLT_MIN 1E-37DBL_MIN 1E-37LDBL_MIN 1E-37</td>
<td align="left">这些宏定义了最小的浮点值。</td>
</tr>
</tbody></table>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>下面的实例演示了 float.h 文件中定义的一些常量的使用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;float.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;The maximum value of float = %.10e\n&quot;</span>, FLT_MAX);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;The minimum value of float = %.10e\n&quot;</span>, FLT_MIN);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;The number of digits in the number = %.10e\n&quot;</span>, FLT_MANT_DIG);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>让我们编译和运行上面的程序，这将产生下列结果：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The maximum value of <span class="type">float</span> = <span class="number">3.4028234664e+38</span></span><br><span class="line">The minimum value of <span class="type">float</span> = <span class="number">1.1754943508e-38</span></span><br><span class="line">The number of digits in the number = <span class="number">7.2996655210e-312</span></span><br></pre></td></tr></table></figure>

<h1 id="C-标准库-lt-limits-h-gt"><a href="#C-标准库-lt-limits-h-gt" class="headerlink" title="C 标准库 - &lt;limits.h&gt;"></a>C 标准库 - &lt;limits.h&gt;</h1><h2 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h2><p><strong>limits.h</strong> 头文件决定了各种变量类型的各种属性。定义在该头文件中的宏限制了各种变量类型（比如 char、int 和 long）的值。</p>
<p>这些限制指定了变量不能存储任何超出这些限制的值，例如一个无符号可以存储的最大值是 255。</p>
<h2 id="库宏-3"><a href="#库宏-3" class="headerlink" title="库宏"></a>库宏</h2><p>下面的值是特定实现的，且是通过 #define 指令来定义的，这些值都不得低于下边所给出的值。</p>
<table>
<thead>
<tr>
<th align="left">宏</th>
<th align="left">值</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">CHAR_BIT</td>
<td align="left">8</td>
<td align="left">定义一个字节的比特数。</td>
</tr>
<tr>
<td align="left">SCHAR_MIN</td>
<td align="left">-128</td>
<td align="left">定义一个有符号字符的最小值。</td>
</tr>
<tr>
<td align="left">SCHAR_MAX</td>
<td align="left">127</td>
<td align="left">定义一个有符号字符的最大值。</td>
</tr>
<tr>
<td align="left">UCHAR_MAX</td>
<td align="left">255</td>
<td align="left">定义一个无符号字符的最大值。</td>
</tr>
<tr>
<td align="left">CHAR_MIN</td>
<td align="left">0</td>
<td align="left">定义类型 char 的最小值，如果 char 表示负值，则它的值等于 SCHAR_MIN，否则等于 0。</td>
</tr>
<tr>
<td align="left">CHAR_MAX</td>
<td align="left">127</td>
<td align="left">定义类型 char 的最大值，如果 char 表示负值，则它的值等于 SCHAR_MAX，否则等于 UCHAR_MAX。</td>
</tr>
<tr>
<td align="left">MB_LEN_MAX</td>
<td align="left">1</td>
<td align="left">定义多字节字符中的最大字节数。</td>
</tr>
<tr>
<td align="left">SHRT_MIN</td>
<td align="left">-32768</td>
<td align="left">定义一个短整型的最小值。</td>
</tr>
<tr>
<td align="left">SHRT_MAX</td>
<td align="left">+32767</td>
<td align="left">定义一个短整型的最大值。</td>
</tr>
<tr>
<td align="left">USHRT_MAX</td>
<td align="left">65535</td>
<td align="left">定义一个无符号短整型的最大值。</td>
</tr>
<tr>
<td align="left">INT_MIN</td>
<td align="left">-32768</td>
<td align="left">定义一个整型的最小值。</td>
</tr>
<tr>
<td align="left">INT_MAX</td>
<td align="left">+32767</td>
<td align="left">定义一个整型的最大值。</td>
</tr>
<tr>
<td align="left">UINT_MAX</td>
<td align="left">65535</td>
<td align="left">定义一个无符号整型的最大值。</td>
</tr>
<tr>
<td align="left">LONG_MIN</td>
<td align="left">-2147483648</td>
<td align="left">定义一个长整型的最小值。</td>
</tr>
<tr>
<td align="left">LONG_MAX</td>
<td align="left">+2147483647</td>
<td align="left">定义一个长整型的最大值。</td>
</tr>
<tr>
<td align="left">ULONG_MAX</td>
<td align="left">4294967295</td>
<td align="left">定义一个无符号长整型的最大值。</td>
</tr>
</tbody></table>
<h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><p>下面的实例演示了 limit.h 文件中定义的一些常量的使用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;The number of bits in a byte %d\n&quot;</span>, CHAR_BIT);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;The minimum value of SIGNED CHAR = %d\n&quot;</span>, SCHAR_MIN);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;The maximum value of SIGNED CHAR = %d\n&quot;</span>, SCHAR_MAX);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;The maximum value of UNSIGNED CHAR = %d\n&quot;</span>, UCHAR_MAX);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;The minimum value of SHORT INT = %d\n&quot;</span>, SHRT_MIN);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;The maximum value of SHORT INT = %d\n&quot;</span>, SHRT_MAX); </span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;The minimum value of INT = %d\n&quot;</span>, INT_MIN);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;The maximum value of INT = %d\n&quot;</span>, INT_MAX);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;The minimum value of CHAR = %d\n&quot;</span>, CHAR_MIN);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;The maximum value of CHAR = %d\n&quot;</span>, CHAR_MAX);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;The minimum value of LONG = %ld\n&quot;</span>, LONG_MIN);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;The maximum value of LONG = %ld\n&quot;</span>, LONG_MAX);</span><br><span class="line">  </span><br><span class="line">   <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>让我们编译和运行上面的程序，这将产生下列结果：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">The number of bits in a byte <span class="number">8</span></span><br><span class="line">The minimum value of SIGNED CHAR = <span class="number">-128</span></span><br><span class="line">The maximum value of SIGNED CHAR = <span class="number">127</span></span><br><span class="line">The maximum value of UNSIGNED CHAR = <span class="number">255</span></span><br><span class="line">The minimum value of SHORT INT = <span class="number">-32768</span></span><br><span class="line">The maximum value of SHORT INT = <span class="number">32767</span></span><br><span class="line">The minimum value of INT = <span class="number">-32768</span></span><br><span class="line">The maximum value of INT = <span class="number">32767</span></span><br><span class="line">The minimum value of CHAR = <span class="number">-128</span></span><br><span class="line">The maximum value of CHAR = <span class="number">127</span></span><br><span class="line">The minimum value of LONG = <span class="number">-2147483648</span></span><br><span class="line">The maximum value of LONG = <span class="number">2147483647</span></span><br></pre></td></tr></table></figure>

<h1 id="C-标准库-lt-locale-h-gt"><a href="#C-标准库-lt-locale-h-gt" class="headerlink" title="C 标准库 - &lt;locale.h&gt;"></a>C 标准库 - &lt;locale.h&gt;</h1><h2 id="简介-5"><a href="#简介-5" class="headerlink" title="简介"></a>简介</h2><p><strong>locale.h</strong> 头文件定义了特定地域的设置，比如日期格式和货币符号。接下来我们将介绍一些宏，以及一个重要的结构 <strong>struct lconv</strong> 和两个重要的函数。</p>
<h2 id="库宏-4"><a href="#库宏-4" class="headerlink" title="库宏"></a>库宏</h2><p>下面列出了头文件 locale.h 中定义的宏，这些宏将在下列的两个函数中使用：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">宏 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>LC_ALL</strong> 设置下面的所有选项。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>LC_COLLATE</strong> 影响 strcoll 和 strxfrm 函数。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>LC_CTYPE</strong> 影响所有字符函数。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>LC_MONETARY</strong> 影响 localeconv 函数提供的货币信息。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><strong>LC_NUMERIC</strong> 影响 localeconv 函数提供的小数点格式化和信息。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><strong>LC_TIME</strong> 影响 strftime 函数。</td>
</tr>
</tbody></table>
<h2 id="库函数-1"><a href="#库函数-1" class="headerlink" title="库函数"></a>库函数</h2><p>下面列出了头文件 locale.h 中定义的函数：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">函数 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-setlocale.html">char *setlocale(int category, const char *locale)</a> 设置或读取地域化信息。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-localeconv.html">struct lconv *localeconv(void)</a> 设置或读取地域化信息。</td>
</tr>
</tbody></table>
<h2 id="库结构"><a href="#库结构" class="headerlink" title="库结构"></a>库结构</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">   <span class="type">char</span> *decimal_point;</span><br><span class="line">   <span class="type">char</span> *thousands_sep;</span><br><span class="line">   <span class="type">char</span> *grouping;    </span><br><span class="line">   <span class="type">char</span> *int_curr_symbol;</span><br><span class="line">   <span class="type">char</span> *currency_symbol;</span><br><span class="line">   <span class="type">char</span> *mon_decimal_point;</span><br><span class="line">   <span class="type">char</span> *mon_thousands_sep;</span><br><span class="line">   <span class="type">char</span> *mon_grouping;</span><br><span class="line">   <span class="type">char</span> *positive_sign;</span><br><span class="line">   <span class="type">char</span> *negative_sign;</span><br><span class="line">   <span class="type">char</span> int_frac_digits;</span><br><span class="line">   <span class="type">char</span> frac_digits;</span><br><span class="line">   <span class="type">char</span> p_cs_precedes;</span><br><span class="line">   <span class="type">char</span> p_sep_by_space;</span><br><span class="line">   <span class="type">char</span> n_cs_precedes;</span><br><span class="line">   <span class="type">char</span> n_sep_by_space;</span><br><span class="line">   <span class="type">char</span> p_sign_posn;</span><br><span class="line">   <span class="type">char</span> n_sign_posn;</span><br><span class="line">&#125; lconv</span><br></pre></td></tr></table></figure>

<p>以下是各字段的描述：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">字段 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>decimal_point</strong> 用于非货币值的小数点字符。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>thousands_sep</strong> 用于非货币值的千位分隔符。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>grouping</strong> 一个表示非货币量中每组数字大小的字符串。每个字符代表一个整数值，每个整数指定当前组的位数。值为 0 意味着前一个值将应用于剩余的分组。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>int_curr_symbol</strong> 国际货币符号使用的字符串。前三个字符是由 ISO 4217:1987 指定的，第四个字符用于分隔货币符号和货币量。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><strong>currency_symbol</strong> 用于货币的本地符号。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><strong>mon_decimal_point</strong> 用于货币值的小数点字符。</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><strong>mon_thousands_sep</strong> 用于货币值的千位分隔符。</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><strong>mon_grouping</strong> 一个表示货币值中每组数字大小的字符串。每个字符代表一个整数值，每个整数指定当前组的位数。值为 0 意味着前一个值将应用于剩余的分组。</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><strong>positive_sign</strong> 用于正货币值的字符。</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left"><strong>negative_sign</strong> 用于负货币值的字符。</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left"><strong>int_frac_digits</strong> 国际货币值中小数点后要显示的位数。</td>
</tr>
<tr>
<td align="left">12</td>
<td align="left"><strong>frac_digits</strong> 货币值中小数点后要显示的位数。</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left"><strong>p_cs_precedes</strong> 如果等于 1，则 currency_symbol 出现在正货币值之前。如果等于 0，则 currency_symbol 出现在正货币值之后。</td>
</tr>
<tr>
<td align="left">14</td>
<td align="left"><strong>p_sep_by_space</strong> 如果等于 1，则 currency_symbol 和正货币值之间使用空格分隔。如果等于 0，则 currency_symbol 和正货币值之间不使用空格分隔。</td>
</tr>
<tr>
<td align="left">15</td>
<td align="left"><strong>n_cs_precedes</strong> 如果等于 1，则 currency_symbol 出现在负货币值之前。如果等于 0，则 currency_symbol 出现在负货币值之后。</td>
</tr>
<tr>
<td align="left">16</td>
<td align="left"><strong>n_sep_by_space</strong> 如果等于 1，则 currency_symbol 和负货币值之间使用空格分隔。如果等于 0，则 currency_symbol 和负货币值之间不使用空格分隔。</td>
</tr>
<tr>
<td align="left">17</td>
<td align="left"><strong>p_sign_posn</strong> 表示正货币值中正号的位置。</td>
</tr>
<tr>
<td align="left">18</td>
<td align="left"><strong>n_sign_posn</strong> 表示负货币值中负号的位置。</td>
</tr>
</tbody></table>
<p>下面的值用于 <strong>p_sign_posn</strong> 和 <strong>n_sign_posn</strong>:</p>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left">封装值和 currency_symbol 的括号。</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">放置在值和 currency_symbol 之前的符号。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">放置在值和 currency_symbol 之后的符号。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">紧挨着放置在值和 currency_symbol 之前的符号。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">紧挨着放置在值和 currency_symbol 之后的符号。</td>
</tr>
</tbody></table>
<h1 id="C-标准库-lt-math-h-gt"><a href="#C-标准库-lt-math-h-gt" class="headerlink" title="C 标准库 - &lt;math.h&gt;"></a>C 标准库 - &lt;math.h&gt;</h1><h2 id="简介-6"><a href="#简介-6" class="headerlink" title="简介"></a>简介</h2><p><strong>math.h</strong> 头文件定义了各种数学函数和一个宏。在这个库中所有可用的功能都带有一个 <strong>double</strong> 类型的参数，且都返回 <strong>double</strong> 类型的结果。</p>
<h2 id="库宏-5"><a href="#库宏-5" class="headerlink" title="库宏"></a>库宏</h2><p>下面是这个库中定义的唯一的一个宏：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">宏 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>HUGE_VAL</strong> 当函数的结果不可以表示为浮点数时。如果是因为结果的幅度太大以致于无法表示，则函数会设置 errno 为 ERANGE 来表示范围错误，并返回一个由宏 HUGE_VAL 或者它的否定（- HUGE_VAL）命名的一个特定的很大的值。如果结果的幅度太小，则会返回零值。在这种情况下，error 可能会被设置为 ERANGE，也有可能不会被设置为 ERANGE。</td>
</tr>
</tbody></table>
<h2 id="库函数-2"><a href="#库函数-2" class="headerlink" title="库函数"></a>库函数</h2><p>下面列出了头文件 math.h 中定义的函数：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">函数 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-acos.html">double acos(double x)</a> 返回以弧度表示的 x 的反余弦。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-asin.html">double asin(double x)</a> 返回以弧度表示的 x 的反正弦。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-atan.html">double atan(double x)</a> 返回以弧度表示的 x 的反正切。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-atan2.html">double atan2(double y, double x)</a> 返回以弧度表示的 y&#x2F;x 的反正切。y 和 x 的值的符号决定了正确的象限。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-cos.html">double cos(double x)</a> 返回弧度角 x 的余弦。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-cosh.html">double cosh(double x)</a> 返回 x 的双曲余弦。</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-sin.html">double sin(double x)</a> 返回弧度角 x 的正弦。</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-sinh.html">double sinh(double x)</a> 返回 x 的双曲正弦。</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-tanh.html">double tanh(double x)</a> 返回 x 的双曲正切。</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-exp.html">double exp(double x)</a> 返回 e 的 x 次幂的值。</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-frexp.html">double frexp(double x, int *exponent)</a> 把浮点数 x 分解成尾数和指数。返回值是尾数，并将指数存入 exponent 中。所得的值是 x &#x3D; mantissa * 2 ^ exponent。</td>
</tr>
<tr>
<td align="left">12</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-ldexp.html">double ldexp(double x, int exponent)</a> 返回 x 乘以 2 的 exponent 次幂。</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-log.html">double log(double x)</a> 返回 x 的自然对数（基数为 e 的对数）。</td>
</tr>
<tr>
<td align="left">14</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-log10.html">double log10(double x)</a> 返回 x 的常用对数（基数为 10 的对数）。</td>
</tr>
<tr>
<td align="left">15</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-modf.html">double modf(double x, double *integer)</a> 返回值为小数部分（小数点后的部分），并设置 integer 为整数部分。</td>
</tr>
<tr>
<td align="left">16</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-pow.html">double pow(double x, double y)</a> 返回 x 的 y 次幂。</td>
</tr>
<tr>
<td align="left">17</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-sqrt.html">double sqrt(double x)</a> 返回 x 的平方根。</td>
</tr>
<tr>
<td align="left">18</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-ceil.html">double ceil(double x)</a> 返回大于或等于 x 的最小的整数值。</td>
</tr>
<tr>
<td align="left">19</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-fabs.html">double fabs(double x)</a> 返回 x 的绝对值。</td>
</tr>
<tr>
<td align="left">20</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-floor.html">double floor(double x)</a> 返回小于或等于 x 的最大的整数值。</td>
</tr>
<tr>
<td align="left">21</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-fmod.html">double fmod(double x, double y)</a> 返回 x 除以 y 的余数。</td>
</tr>
</tbody></table>
<h1 id="C-标准库-lt-setjmp-h-gt"><a href="#C-标准库-lt-setjmp-h-gt" class="headerlink" title="C 标准库 - &lt;setjmp.h&gt;"></a>C 标准库 - &lt;setjmp.h&gt;</h1><h2 id="简介-7"><a href="#简介-7" class="headerlink" title="简介"></a>简介</h2><p><strong>setjmp.h</strong> 头文件定义了宏 **setjmp()**、函数 <strong>longjmp()</strong> 和变量类型 <strong>jmp_buf</strong>，该变量类型会绕过正常的函数调用和返回规则。</p>
<h2 id="库变量"><a href="#库变量" class="headerlink" title="库变量"></a>库变量</h2><p>下面列出了头文件 setjmp.h 中定义的变量：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">变量 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>jmp_buf</strong>  这是一个用于存储宏 <strong>setjmp()</strong> 和函数 <strong>longjmp()</strong> 相关信息的数组类型。</td>
</tr>
</tbody></table>
<h2 id="库宏-6"><a href="#库宏-6" class="headerlink" title="库宏"></a>库宏</h2><p>下面是这个库中定义的唯一的一个宏：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">宏 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-macro-setjmp.html">int setjmp(jmp_buf environment)</a> 这个宏把当前环境保存在变量 <strong>environment</strong> 中，以便函数 <strong>longjmp()</strong> 后续使用。如果这个宏直接从宏调用中返回，则它会返回零，但是如果它从 <strong>longjmp()</strong> 函数调用中返回，则它会返回一个非零值。</td>
</tr>
</tbody></table>
<h2 id="库函数-3"><a href="#库函数-3" class="headerlink" title="库函数"></a>库函数</h2><p>下面是头文件 setjmp.h 中定义的唯一的一个函数：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">函数 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-longjmp.html">void longjmp(jmp_buf environment, int value)</a> 该函数恢复最近一次调用 <strong>setjmp()</strong> 宏时保存的环境，<strong>jmp_buf</strong> 参数的设置是由之前调用 setjmp() 生成的。</td>
</tr>
</tbody></table>
<h1 id="C-标准库-lt-signal-h-gt"><a href="#C-标准库-lt-signal-h-gt" class="headerlink" title="C 标准库 - &lt;signal.h&gt;"></a>C 标准库 - &lt;signal.h&gt;</h1><h2 id="简介-8"><a href="#简介-8" class="headerlink" title="简介"></a>简介</h2><p><strong>signal.h</strong> 头文件定义了一个变量类型 <strong>sig_atomic_t</strong>、两个函数调用和一些宏来处理程序执行期间报告的不同信号。</p>
<h2 id="库变量-1"><a href="#库变量-1" class="headerlink" title="库变量"></a>库变量</h2><p>下面是头文件 signal.h 中定义的变量类型：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">变量 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>sig_atomic_t</strong>  这是 <strong>int</strong> 类型，在信号处理程序中作为变量使用。它是一个对象的整数类型，该对象可以作为一个原子实体访问，即使存在异步信号时，该对象可以作为一个原子实体访问。</td>
</tr>
</tbody></table>
<h2 id="库宏-7"><a href="#库宏-7" class="headerlink" title="库宏"></a>库宏</h2><p>下面是头文件 signal.h 中定义的宏，这些宏将在下列两个函数中使用。<strong>SIG_</strong> 宏与 signal 函数一起使用来定义信号的功能。</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">宏 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>SIG_DFL</strong> 默认的信号处理程序。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>SIG_ERR</strong> 表示一个信号错误。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>SIG_IGN</strong> 忽视信号。</td>
</tr>
</tbody></table>
<p><strong>SIG</strong> 宏用于表示以下各种条件的信号码：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">宏 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>SIGABRT</strong> 程序异常终止。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>SIGFPE</strong> 算术运算出错，如除数为 0 或溢出。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>SIGILL</strong> 非法函数映象，如非法指令。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>SIGINT</strong> 中断信号，如 ctrl-C。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><strong>SIGSEGV</strong> 非法访问存储器，如访问不存在的内存单元。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><strong>SIGTERM</strong> 发送给本程序的终止请求信号。</td>
</tr>
</tbody></table>
<h2 id="库函数-4"><a href="#库函数-4" class="headerlink" title="库函数"></a>库函数</h2><p>下面是头文件 signal.h 中定义的函数：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">函数 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-signal.html">void (*signal(int sig, void (*func)(int)))(int)</a> 该函数设置一个函数来处理信号，即信号处理程序。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-raise.html">int raise(int sig)</a> 该函数会促使生成信号 <strong>sig</strong>。sig 参数与 SIG 宏兼容。</td>
</tr>
</tbody></table>
<h1 id="C-标准库-lt-stdarg-h-gt"><a href="#C-标准库-lt-stdarg-h-gt" class="headerlink" title="C 标准库 - &lt;stdarg.h&gt;"></a>C 标准库 - &lt;stdarg.h&gt;</h1><h2 id="简介-9"><a href="#简介-9" class="headerlink" title="简介"></a>简介</h2><p><strong>stdarg.h</strong> 头文件定义了一个变量类型 <strong>va_list</strong> 和三个宏，这三个宏可用于在参数个数未知（即参数个数可变）时获取函数中的参数。</p>
<p>可变参数的函数通在参数列表的末尾是使用省略号(,…)定义的。</p>
<h2 id="库变量-2"><a href="#库变量-2" class="headerlink" title="库变量"></a>库变量</h2><p>下面是头文件 stdarg.h 中定义的变量类型：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">变量 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>va_list</strong>  这是一个适用于 <strong>va_start()、va_arg()</strong> 和 <strong>va_end()</strong> 这三个宏存储信息的类型。</td>
</tr>
</tbody></table>
<h2 id="库宏-8"><a href="#库宏-8" class="headerlink" title="库宏"></a>库宏</h2><p>下面是头文件 stdarg.h 中定义的宏：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">宏 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-macro-va_start.html">void va_start(va_list ap, last_arg)</a> 这个宏初始化 <strong>ap</strong> 变量，它与 <strong>va_arg</strong> 和 <strong>va_end</strong> 宏是一起使用的。<strong>last_arg</strong> 是最后一个传递给函数的已知的固定参数，即省略号之前的参数。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-macro-va_arg.html">type va_arg(va_list ap, type)</a> 这个宏检索函数参数列表中类型为 <strong>type</strong> 的下一个参数。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-macro-va_end.html">void va_end(va_list ap)</a> 这个宏允许使用了 <strong>va_start</strong> 宏的带有可变参数的函数返回。如果在从函数返回之前没有调用 <strong>va_end</strong>，则结果为未定义。</td>
</tr>
</tbody></table>
<h1 id="C-标准库-lt-stddef-h-gt"><a href="#C-标准库-lt-stddef-h-gt" class="headerlink" title="C 标准库 - &lt;stddef.h&gt;"></a>C 标准库 - &lt;stddef.h&gt;</h1><h2 id="简介-10"><a href="#简介-10" class="headerlink" title="简介"></a>简介</h2><p><strong>stddef .h</strong> 头文件定义了各种变量类型和宏。这些定义中的大部分也出现在其它头文件中。</p>
<h2 id="库变量-3"><a href="#库变量-3" class="headerlink" title="库变量"></a>库变量</h2><p>下面是头文件 stddef.h 中定义的变量类型：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">变量 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>ptrdiff_t</strong> 这是有符号整数类型，它是两个指针相减的结果。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>size_t</strong>  这是无符号整数类型，它是 <strong>sizeof</strong> 关键字的结果。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>wchar_t</strong>  这是一个宽字符常量大小的整数类型。</td>
</tr>
</tbody></table>
<h2 id="库宏-9"><a href="#库宏-9" class="headerlink" title="库宏"></a>库宏</h2><p>下面是头文件 stddef.h 中定义的宏：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">宏 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-macro-null.html">NULL</a> 这个宏是一个空指针常量的值。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-macro-offsetof.html">offsetof(type, member-designator)</a> 这会生成一个类型为 size_t 的整型常量，它是一个结构成员相对于结构开头的字节偏移量。成员是由 <em>member-designator</em> 给定的，结构的名称是在 <em>type</em> 中给定的。</td>
</tr>
</tbody></table>
<h1 id="C-标准库-lt-stdio-h-gt"><a href="#C-标准库-lt-stdio-h-gt" class="headerlink" title="C 标准库 - &lt;stdio.h&gt;"></a>C 标准库 - &lt;stdio.h&gt;</h1><h2 id="简介-11"><a href="#简介-11" class="headerlink" title="简介"></a>简介</h2><p><strong>stdio .h</strong> 头文件定义了三个变量类型、一些宏和各种函数来执行输入和输出。</p>
<h2 id="库变量-4"><a href="#库变量-4" class="headerlink" title="库变量"></a>库变量</h2><p>下面是头文件 stdio.h 中定义的变量类型：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">变量 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>size_t</strong>  这是无符号整数类型，它是 <strong>sizeof</strong> 关键字的结果。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>FILE</strong>  这是一个适合存储文件流信息的对象类型。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>fpos_t</strong>  这是一个适合存储文件中任何位置的对象类型。</td>
</tr>
</tbody></table>
<h2 id="库宏-10"><a href="#库宏-10" class="headerlink" title="库宏"></a>库宏</h2><p>下面是头文件 stdio.h 中定义的宏：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">宏 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>NULL</strong> 这个宏是一个空指针常量的值。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>_IOFBF、_IOLBF</strong> 和 <strong>_IONBF</strong>  这些宏扩展了带有特定值的整型常量表达式，并适用于 <strong>setvbuf</strong> 函数的第三个参数。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>BUFSIZ</strong> 这个宏是一个整数，该整数代表了 <strong>setbuf</strong> 函数使用的缓冲区大小。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>EOF</strong>  这个宏是一个表示已经到达文件结束的负整数。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><strong>FOPEN_MAX</strong>  这个宏是一个整数，该整数代表了系统可以同时打开的文件数量。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><strong>FILENAME_MAX</strong>  这个宏是一个整数，该整数代表了字符数组可以存储的文件名的最大长度。如果实现没有任何限制，则该值应为推荐的最大值。</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><strong>L_tmpnam</strong>  这个宏是一个整数，该整数代表了字符数组可以存储的由 tmpnam 函数创建的临时文件名的最大长度。</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><strong>SEEK_CUR、SEEK_END</strong> 和 <strong>SEEK_SET</strong>  这些宏是在 <strong>fseek</strong> 函数中使用，用于在一个文件中定位不同的位置。</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><strong>TMP_MAX</strong>  这个宏是 tmpnam 函数可生成的独特文件名的最大数量。</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left"><strong>stderr、stdin</strong> 和 <strong>stdout</strong>  这些宏是指向 FILE 类型的指针，分别对应于标准错误、标准输入和标准输出流。</td>
</tr>
</tbody></table>
<h2 id="库函数-5"><a href="#库函数-5" class="headerlink" title="库函数"></a>库函数</h2><p>下面是头文件 stdio.h 中定义的函数：</p>
<blockquote>
<p>为了更好地理解函数，请按照下面的序列学习这些函数，因为第一个函数中创建的文件会在后续的函数中使用到。</p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">函数 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-fclose.html">int fclose(FILE *stream)</a> 关闭流 stream。刷新所有的缓冲区。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-clearerr.html">void clearerr(FILE *stream)</a> 清除给定流 stream 的文件结束和错误标识符。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-feof.html">int feof(FILE *stream)</a> 测试给定流 stream 的文件结束标识符。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-ferror.html">int ferror(FILE *stream)</a> 测试给定流 stream 的错误标识符。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-fflush.html">int fflush(FILE *stream)</a> 刷新流 stream 的输出缓冲区。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-fgetpos.html">int fgetpos(FILE *stream, fpos_t *pos)</a> 获取流 stream 的当前文件位置，并把它写入到 pos。</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-fopen.html">FILE *fopen(const char *filename, const char *mode)</a> 使用给定的模式 mode 打开 filename 所指向的文件。</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-fread.html">size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream)</a> 从给定流 stream 读取数据到 ptr 所指向的数组中。</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-freopen.html">FILE *freopen(const char *filename, const char *mode, FILE *stream)</a> 把一个新的文件名 filename 与给定的打开的流 stream 关联，同时关闭流中的旧文件。</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-fseek.html">int fseek(FILE *stream, long int offset, int whence)</a> 设置流 stream 的文件位置为给定的偏移 offset，参数 <em>offset</em> 意味着从给定的 <em>whence</em> 位置查找的字节数。</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-fsetpos.html">int fsetpos(FILE *stream, const fpos_t *pos)</a> 设置给定流 stream 的文件位置为给定的位置。参数 <em>pos</em> 是由函数 fgetpos 给定的位置。</td>
</tr>
<tr>
<td align="left">12</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-ftell.html">long int ftell(FILE *stream)</a> 返回给定流 stream 的当前文件位置。</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-fwrite.html">size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream)</a> 把 ptr 所指向的数组中的数据写入到给定流 stream 中。</td>
</tr>
<tr>
<td align="left">14</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-remove.html">int remove(const char *filename)</a> 删除给定的文件名 filename，以便它不再被访问。</td>
</tr>
<tr>
<td align="left">15</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-rename.html">int rename(const char *old_filename, const char *new_filename)</a> 把 old_filename 所指向的文件名改为 new_filename。</td>
</tr>
<tr>
<td align="left">16</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-rewind.html">void rewind(FILE *stream)</a> 设置文件位置为给定流 stream 的文件的开头。</td>
</tr>
<tr>
<td align="left">17</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-setbuf.html">void setbuf(FILE *stream, char *buffer)</a> 定义流 stream 应如何缓冲。</td>
</tr>
<tr>
<td align="left">18</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-setvbuf.html">int setvbuf(FILE *stream, char *buffer, int mode, size_t size)</a> 另一个定义流 stream 应如何缓冲的函数。</td>
</tr>
<tr>
<td align="left">19</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-tmpfile.html">FILE *tmpfile(void)</a> 以二进制更新模式(wb+)创建临时文件。</td>
</tr>
<tr>
<td align="left">20</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-tmpnam.html">char *tmpnam(char *str)</a> 生成并返回一个有效的临时文件名，该文件名之前是不存在的。</td>
</tr>
<tr>
<td align="left">21</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-fprintf.html">int fprintf(FILE *stream, const char *format, …)</a> 发送格式化输出到流 stream 中。</td>
</tr>
<tr>
<td align="left">22</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-printf.html">int printf(const char *format, …)</a> 发送格式化输出到标准输出 stdout。</td>
</tr>
<tr>
<td align="left">23</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-sprintf.html">int sprintf(char *str, const char *format, …)</a> 发送格式化输出到字符串。</td>
</tr>
<tr>
<td align="left">24</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-vfprintf.html">int vfprintf(FILE *stream, const char *format, va_list arg)</a> 使用参数列表发送格式化输出到流 stream 中。</td>
</tr>
<tr>
<td align="left">25</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-vprintf.html">int vprintf(const char *format, va_list arg)</a> 使用参数列表发送格式化输出到标准输出 stdout。</td>
</tr>
<tr>
<td align="left">26</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-vsprintf.html">int vsprintf(char *str, const char *format, va_list arg)</a> 使用参数列表发送格式化输出到字符串。</td>
</tr>
<tr>
<td align="left">27</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-fscanf.html">int fscanf(FILE *stream, const char *format, …)</a> 从流 stream 读取格式化输入。</td>
</tr>
<tr>
<td align="left">28</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-scanf.html">int scanf(const char *format, …)</a> 从标准输入 stdin 读取格式化输入。</td>
</tr>
<tr>
<td align="left">29</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-sscanf.html">int sscanf(const char *str, const char *format, …)</a> 从字符串读取格式化输入。</td>
</tr>
<tr>
<td align="left">30</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-fgetc.html">int fgetc(FILE *stream)</a> 从指定的流 stream 获取下一个字符（一个无符号字符），并把位置标识符往前移动。</td>
</tr>
<tr>
<td align="left">31</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-fgets.html">char *fgets(char *str, int n, FILE *stream)</a> 从指定的流 stream 读取一行，并把它存储在 str 所指向的字符串内。当读取 <strong>(n-1)</strong> 个字符时，或者读取到换行符时，或者到达文件末尾时，它会停止，具体视情况而定。</td>
</tr>
<tr>
<td align="left">32</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-fputc.html">int fputc(int char, FILE *stream)</a> 把参数 char 指定的字符（一个无符号字符）写入到指定的流 stream 中，并把位置标识符往前移动。</td>
</tr>
<tr>
<td align="left">33</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-fputs.html">int fputs(const char *str, FILE *stream)</a> 把字符串写入到指定的流 stream 中，但不包括空字符。</td>
</tr>
<tr>
<td align="left">34</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-getc.html">int getc(FILE *stream)</a> 从指定的流 stream 获取下一个字符（一个无符号字符），并把位置标识符往前移动。</td>
</tr>
<tr>
<td align="left">35</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-getchar.html">int getchar(void)</a> 从标准输入 stdin 获取一个字符（一个无符号字符）。</td>
</tr>
<tr>
<td align="left">36</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-gets.html">char *gets(char *str)</a> 从标准输入 stdin 读取一行，并把它存储在 str 所指向的字符串中。当读取到换行符时，或者到达文件末尾时，它会停止，具体视情况而定。</td>
</tr>
<tr>
<td align="left">37</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-putc.html">int putc(int char, FILE *stream)</a> 把参数 char 指定的字符（一个无符号字符）写入到指定的流 stream 中，并把位置标识符往前移动。</td>
</tr>
<tr>
<td align="left">38</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-putchar.html">int putchar(int char)</a> 把参数 char 指定的字符（一个无符号字符）写入到标准输出 stdout 中。</td>
</tr>
<tr>
<td align="left">39</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-puts.html">int puts(const char *str)</a> 把一个字符串写入到标准输出 stdout，直到空字符，但不包括空字符。换行符会被追加到输出中。</td>
</tr>
<tr>
<td align="left">40</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-ungetc.html">int ungetc(int char, FILE *stream)</a> 把字符 char（一个无符号字符）推入到指定的流 stream 中，以便它是下一个被读取到的字符。</td>
</tr>
<tr>
<td align="left">41</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-perror.html">void perror(const char *str)</a> 把一个描述性错误消息输出到标准错误 stderr。首先输出字符串 str，后跟一个冒号，然后是一个空格。</td>
</tr>
<tr>
<td align="left">42</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-snprintf.html">int snprintf(char *str, size_t size, const char *format, …)</a> 格式字符串到 str 中。</td>
</tr>
</tbody></table>
<h1 id="C-标准库-lt-stdlib-h-gt"><a href="#C-标准库-lt-stdlib-h-gt" class="headerlink" title="C 标准库 - &lt;stdlib.h&gt;"></a>C 标准库 - &lt;stdlib.h&gt;</h1><h2 id="简介-12"><a href="#简介-12" class="headerlink" title="简介"></a>简介</h2><p><strong>stdlib .h</strong> 头文件定义了四个变量类型、一些宏和各种通用工具函数。</p>
<h2 id="库变量-5"><a href="#库变量-5" class="headerlink" title="库变量"></a>库变量</h2><p>下面是头文件 stdlib.h 中定义的变量类型：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">变量 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>size_t</strong>  这是无符号整数类型，它是 <strong>sizeof</strong> 关键字的结果。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>wchar_t</strong>  这是一个宽字符常量大小的整数类型。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>div_t</strong>  这是 <strong>div</strong> 函数返回的结构。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>ldiv_t</strong>  这是 <strong>ldiv</strong> 函数返回的结构。</td>
</tr>
</tbody></table>
<h2 id="库宏-11"><a href="#库宏-11" class="headerlink" title="库宏"></a>库宏</h2><p>下面是头文件 stdlib.h 中定义的宏：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">宏 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>NULL</strong> 这个宏是一个空指针常量的值。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>EXIT_FAILURE</strong> 这是 exit 函数失败时要返回的值。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>EXIT_SUCCESS</strong> 这是 exit 函数成功时要返回的值。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>RAND_MAX</strong>  这个宏是 rand 函数返回的最大值。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><strong>MB_CUR_MAX</strong>  这个宏表示在多字节字符集中的最大字符数，不能大于 MB_LEN_MAX。</td>
</tr>
</tbody></table>
<h2 id="库函数-6"><a href="#库函数-6" class="headerlink" title="库函数"></a>库函数</h2><p>下面是头文件 stdlib.h 中定义的函数：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">函数 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-atof.html">double atof(const char *str)</a> 把参数 <em>str</em> 所指向的字符串转换为一个浮点数（类型为 double 型）。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-atoi.html">int atoi(const char *str)</a> 把参数 <em>str</em> 所指向的字符串转换为一个整数（类型为 int 型）。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-atol.html">long int atol(const char *str)</a> 把参数 <em>str</em> 所指向的字符串转换为一个长整数（类型为 long int 型）。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-strtod.html">double strtod(const char *str, char **endptr)</a> 把参数 <em>str</em> 所指向的字符串转换为一个浮点数（类型为 double 型）。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-strtol.html">long int strtol(const char *str, char **endptr, int base)</a> 把参数 <em>str</em> 所指向的字符串转换为一个长整数（类型为 long int 型）。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-strtoul.html">unsigned long int strtoul(const char *str, char **endptr, int base)</a> 把参数 <em>str</em> 所指向的字符串转换为一个无符号长整数（类型为 unsigned long int 型）。</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-calloc.html">void *calloc(size_t nitems, size_t size)</a> 分配所需的内存空间，并返回一个指向它的指针。</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-free.html">void free(void *ptr)</a> 释放之前调用 <em>calloc、malloc</em> 或 <em>realloc</em> 所分配的内存空间。</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-malloc.html">void *malloc(size_t size)</a> 分配所需的内存空间，并返回一个指向它的指针。</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-realloc.html">void *realloc(void *ptr, size_t size)</a> 尝试重新调整之前调用 <em>malloc</em> 或 <em>calloc</em> 所分配的 ptr 所指向的内存块的大小。</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-abort.html">void abort(void)</a> 使一个异常程序终止。</td>
</tr>
<tr>
<td align="left">12</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-atexit.html">int atexit(void (*func)(void))</a> 当程序正常终止时，调用指定的函数 <strong>func</strong>。</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-exit.html">void exit(int status)</a> 使程序正常终止。</td>
</tr>
<tr>
<td align="left">14</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-getenv.html">char *getenv(const char *name)</a> 搜索 name 所指向的环境字符串，并返回相关的值给字符串。</td>
</tr>
<tr>
<td align="left">15</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-system.html">int system(const char *string)</a> 由 string 指定的命令传给要被命令处理器执行的主机环境。</td>
</tr>
<tr>
<td align="left">16</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-bsearch.html">void *bsearch(const void *key, const void *base, size_t nitems, size_t size, int (*compar)(const void *, const void *))</a> 执行二分查找。</td>
</tr>
<tr>
<td align="left">17</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-qsort.html">void qsort(void *base, size_t nitems, size_t size, int (*compar)(const void <em>, const void</em>))</a> 数组排序。</td>
</tr>
<tr>
<td align="left">18</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-abs.html">int abs(int x)</a> 返回 x 的绝对值。</td>
</tr>
<tr>
<td align="left">19</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-div.html">div_t div(int numer, int denom)</a> 分子除以分母。</td>
</tr>
<tr>
<td align="left">20</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-labs.html">long int labs(long int x)</a> 返回 x 的绝对值。</td>
</tr>
<tr>
<td align="left">21</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-ldiv.html">ldiv_t ldiv(long int numer, long int denom)</a> 分子除以分母。</td>
</tr>
<tr>
<td align="left">22</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-rand.html">int rand(void)</a> 返回一个范围在 0 到 <em>RAND_MAX</em> 之间的伪随机数。</td>
</tr>
<tr>
<td align="left">23</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-srand.html">void srand(unsigned int seed)</a> 该函数播种由函数 <strong>rand</strong> 使用的随机数发生器。</td>
</tr>
<tr>
<td align="left">24</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-mblen.html">int mblen(const char *str, size_t n)</a> 返回参数 <em>str</em> 所指向的多字节字符的长度。</td>
</tr>
<tr>
<td align="left">25</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-mbstowcs.html">size_t mbstowcs(schar_t *pwcs, const char *str, size_t n)</a> 把参数 <em>str</em> 所指向的多字节字符的字符串转换为参数 <em>pwcs</em> 所指向的数组。</td>
</tr>
<tr>
<td align="left">26</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-mbtowc.html">int mbtowc(whcar_t *pwc, const char *str, size_t n)</a> 检查参数 <em>str</em> 所指向的多字节字符。</td>
</tr>
<tr>
<td align="left">27</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-wcstombs.html">size_t wcstombs(char *str, const wchar_t *pwcs, size_t n)</a> 把数组 <em>pwcs</em> 中存储的编码转换为多字节字符，并把它们存储在字符串 <em>str</em> 中。</td>
</tr>
<tr>
<td align="left">28</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-wctomb.html">int wctomb(char *str, wchar_t wchar)</a> 检查对应于参数 <em>wchar</em> 所给出的多字节字符的编码。</td>
</tr>
</tbody></table>
<h1 id="C-标准库-lt-string-h-gt"><a href="#C-标准库-lt-string-h-gt" class="headerlink" title="C 标准库 - &lt;string.h&gt;"></a>C 标准库 - &lt;string.h&gt;</h1><h2 id="简介-13"><a href="#简介-13" class="headerlink" title="简介"></a>简介</h2><p><strong>string .h</strong> 头文件定义了一个变量类型、一个宏和各种操作字符数组的函数。</p>
<h2 id="库变量-6"><a href="#库变量-6" class="headerlink" title="库变量"></a>库变量</h2><p>下面是头文件 string.h 中定义的变量类型：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">变量 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>size_t</strong>  这是无符号整数类型，它是 <strong>sizeof</strong> 关键字的结果。</td>
</tr>
</tbody></table>
<h2 id="库宏-12"><a href="#库宏-12" class="headerlink" title="库宏"></a>库宏</h2><p>下面是头文件 string.h 中定义的宏：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">宏 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>NULL</strong> 这个宏是一个空指针常量的值。</td>
</tr>
</tbody></table>
<h2 id="库函数-7"><a href="#库函数-7" class="headerlink" title="库函数"></a>库函数</h2><p>下面是头文件 string.h 中定义的函数：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">函数 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-memchr.html">void *memchr(const void *str, int c, size_t n)</a> 在参数 <em>str</em> 所指向的字符串的前 n 个字节中搜索第一次出现字符 c（一个无符号字符）的位置。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-memcmp.html">int memcmp(const void *str1, const void *str2, size_t n)</a> 把 <em>str1</em> 和 <em>str2</em> 的前 n 个字节进行比较。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-memcpy.html">void *memcpy(void *dest, const void *src, size_t n)</a> 从 src 复制 n 个字符到 <em>dest</em>。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-memmove.html">void *memmove(void *dest, const void *src, size_t n)</a> 另一个用于从 <em>src</em> 复制 n 个字符到 <em>dest</em> 的函数。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-memset.html">void *memset(void *str, int c, size_t n)</a> 复制字符 c（一个无符号字符）到参数 <em>str</em> 所指向的字符串的前 n 个字符。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-strcat.html">char *strcat(char *dest, const char *src)</a> 把 <em>src</em> 所指向的字符串追加到 <em>dest</em> 所指向的字符串的结尾。</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-strncat.html">char *strncat(char *dest, const char *src, size_t n)</a> 把 <em>src</em> 所指向的字符串追加到 <em>dest</em> 所指向的字符串的结尾，直到 n 字符长度为止。</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-strchr.html">char *strchr(const char *str, int c)</a> 在参数 <em>str</em> 所指向的字符串中搜索第一次出现字符 c（一个无符号字符）的位置。</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-strcmp.html">int strcmp(const char *str1, const char *str2)</a> 把 <em>str1</em> 所指向的字符串和 <em>str2</em> 所指向的字符串进行比较。</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-strncmp.html">int strncmp(const char *str1, const char *str2, size_t n)</a> 把 <em>str1</em> 和 <em>str2</em> 进行比较，最多比较前 n 个字节。</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-strcoll.html">int strcoll(const char *str1, const char *str2)</a> 把 <em>str1</em> 和 <em>str2</em> 进行比较，结果取决于 LC_COLLATE 的位置设置。</td>
</tr>
<tr>
<td align="left">12</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-strcpy.html">char *strcpy(char *dest, const char *src)</a> 把 <em>src</em> 所指向的字符串复制到 <em>dest</em>。</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-strncpy.html">char *strncpy(char *dest, const char *src, size_t n)</a> 把 <em>src</em> 所指向的字符串复制到 <em>dest</em>，最多复制 n 个字符。</td>
</tr>
<tr>
<td align="left">14</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-strcspn.html">size_t strcspn(const char *str1, const char *str2)</a> 检索字符串 str1 开头连续有几个字符都不含字符串 str2 中的字符。</td>
</tr>
<tr>
<td align="left">15</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-strerror.html">char *strerror(int errnum)</a> 从内部数组中搜索错误号 errnum，并返回一个指向错误消息字符串的指针。</td>
</tr>
<tr>
<td align="left">16</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-strlen.html">size_t strlen(const char *str)</a> 计算字符串 str 的长度，直到空结束字符，但不包括空结束字符。</td>
</tr>
<tr>
<td align="left">17</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-strpbrk.html">char *strpbrk(const char *str1, const char *str2)</a> 检索字符串 <em>str1</em> 中第一个匹配字符串 <em>str2</em> 中字符的字符，不包含空结束字符。也就是说，依次检验字符串 str1 中的字符，当被检验字符在字符串 str2 中也包含时，则停止检验，并返回该字符位置。</td>
</tr>
<tr>
<td align="left">18</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-strrchr.html">char *strrchr(const char *str, int c)</a> 在参数 <em>str</em> 所指向的字符串中搜索最后一次出现字符 c（一个无符号字符）的位置。</td>
</tr>
<tr>
<td align="left">19</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-strspn.html">size_t strspn(const char *str1, const char *str2)</a> 检索字符串 <em>str1</em> 中第一个不在字符串 <em>str2</em> 中出现的字符下标。</td>
</tr>
<tr>
<td align="left">20</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-strstr.html">char *strstr(const char *haystack, const char *needle)</a> 在字符串 <em>haystack</em> 中查找第一次出现字符串 <em>needle</em>（不包含空结束字符）的位置。</td>
</tr>
<tr>
<td align="left">21</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-strtok.html">char *strtok(char *str, const char *delim)</a> 分解字符串 <em>str</em> 为一组字符串，<em>delim</em> 为分隔符。</td>
</tr>
<tr>
<td align="left">22</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-strxfrm.html">size_t strxfrm(char *dest, const char *src, size_t n)</a> 根据程序当前的区域选项中的 LC_COLLATE 来转换字符串 <strong>src</strong> 的前 <strong>n</strong> 个字符，并把它们放置在字符串 <strong>dest</strong> 中。</td>
</tr>
</tbody></table>
<h1 id="C-标准库-lt-time-h-gt"><a href="#C-标准库-lt-time-h-gt" class="headerlink" title="C 标准库 - &lt;time.h&gt;"></a>C 标准库 - &lt;time.h&gt;</h1><h2 id="简介-14"><a href="#简介-14" class="headerlink" title="简介"></a>简介</h2><p><strong>time.h</strong> 头文件定义了四个变量类型、两个宏和各种操作日期和时间的函数。</p>
<h2 id="库变量-7"><a href="#库变量-7" class="headerlink" title="库变量"></a>库变量</h2><p>下面是头文件 time.h 中定义的变量类型：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">变量 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>size_t</strong>  是无符号整数类型，它是 <strong>sizeof</strong> 关键字的结果。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>clock_t</strong>  这是一个适合存储处理器时间的类型。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>time_t is</strong>  这是一个适合存储日历时间类型。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>struct tm</strong>  这是一个用来保存时间和日期的结构。</td>
</tr>
</tbody></table>
<p>tm 结构的定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct tm &#123;</span><br><span class="line">   int tm_sec;         /* 秒，范围从 0 到 59        */</span><br><span class="line">   int tm_min;         /* 分，范围从 0 到 59        */</span><br><span class="line">   int tm_hour;        /* 小时，范围从 0 到 23        */</span><br><span class="line">   int tm_mday;        /* 一月中的第几天，范围从 1 到 31    */</span><br><span class="line">   int tm_mon;         /* 月，范围从 0 到 11        */</span><br><span class="line">   int tm_year;        /* 自 1900 年起的年数        */</span><br><span class="line">   int tm_wday;        /* 一周中的第几天，范围从 0 到 6    */</span><br><span class="line">   int tm_yday;        /* 一年中的第几天，范围从 0 到 365    */</span><br><span class="line">   int tm_isdst;       /* 夏令时                */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="库宏-13"><a href="#库宏-13" class="headerlink" title="库宏"></a>库宏</h2><p>下面是头文件 time.h 中定义的宏：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">宏 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>NULL</strong> 这个宏是一个空指针常量的值。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>CLOCKS_PER_SEC</strong>  这个宏表示每秒的处理器时钟个数。</td>
</tr>
</tbody></table>
<h2 id="库函数-8"><a href="#库函数-8" class="headerlink" title="库函数"></a>库函数</h2><p>下面是头文件 time.h 中定义的函数：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">函数 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-asctime.html">char *asctime(const struct tm *timeptr)</a> 返回一个指向字符串的指针，它代表了结构 timeptr 的日期和时间。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-clock.html">clock_t clock(void)</a> 返回程序执行起（一般为程序的开头），处理器时钟所使用的时间。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-ctime.html">char *ctime(const time_t *timer)</a> 返回一个表示当地时间的字符串，当地时间是基于参数 timer。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-difftime.html">double difftime(time_t time1, time_t time2)</a> 返回 time1 和 time2 之间相差的秒数 (time1-time2)。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-gmtime.html">struct tm *gmtime(const time_t *timer)</a> timer 的值被分解为 tm 结构，并用协调世界时（UTC）也被称为格林尼治标准时间（GMT）表示。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-localtime.html">struct tm *localtime(const time_t *timer)</a> timer 的值被分解为 tm 结构，并用本地时区表示。</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-mktime.html">time_t mktime(struct tm *timeptr)</a> 把 timeptr 所指向的结构转换为一个依据本地时区的 time_t 值。</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-strftime.html">size_t strftime(char *str, size_t maxsize, const char *format, const struct tm *timeptr)</a> 根据 format 中定义的格式化规则，格式化结构 timeptr 表示的时间，并把它存储在 str 中。</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-time.html">time_t time(time_t *timer)</a> 计算当前日历时间，并把它编码成 time_t 格式。</td>
</tr>
</tbody></table>
<h1 id="chaos"><a href="#chaos" class="headerlink" title="chaos"></a>chaos</h1><ol>
<li><p>库函数在LIB目录,头文件在INCLUDE目录,编译器的连接部分负责找到您所需要的库代码.头文件指引编译器把您的程序正确地组合在一起</p>
</li>
<li><p>getchar()读取一次按键输入</p>
</li>
<li><p>c99标准允许一个标识符最多可以有63个字符</p>
</li>
<li><p>c语言的变量名区分大小写</p>
</li>
<li><p>发现错误的位置要比真正出现错误的位置滞后一行</p>
</li>
<li><p>%hd :已十进制显示short整数, %ho表示以八进制显示short整数</p>
</li>
<li><p>double和float: double精度高,有效数字16位,float精度7位. 但double消耗内存是float的两倍,double运算速度比float慢很多. 尽量使用float</p>
</li>
<li><p>不初始化数组,数组元素和为初始化的普通变量一样. 部分初始化,未初始化的元素被设置为0</p>
</li>
<li><p>!&#x3D; 运算符的优先级比&#x3D;高</p>
</li>
<li><p>字符实际上是作为整数被存储的</p>
</li>
<li><p>c语言不能保证复杂表达式的那一部分首先被求值</p>
</li>
<li><p>goto语言最好不要用</p>
</li>
<li><p><code>#include</code> 不是c语言的语句 #表示这一行是在编译器接手之前由c预处理的语句</p>
</li>
<li><p>main函数返回值是返回操作系统</p>
</li>
<li><p>所有的c程序都是从main函数开始执行,不管它放在程序文件中的什么位置</p>
</li>
<li><p>默认条件下,编译器将浮点常量当做double类型</p>
</li>
<li><p>54.3L表示long double, 54.3F表示float</p>
</li>
<li><p>一个字符串只是一个参数</p>
</li>
<li><p>float类型区只能保证前6位是精确的</p>
</li>
<li><p>scanf会在遇到第一个空白字符,制表符或者换行符处停止读取</p>
</li>
<li><p>print先把变量放到堆栈,然后再按照对应格式去读取</p>
</li>
<li><p>如果输入错误,print会返回一个负值,print返回打印字符的个数</p>
</li>
<li><p>不能在字符串中通过回车键来产生实际的换行字符</p>
</li>
<li><p>scanf使用指向变量的指针,scanf返回成功读入的项目个数</p>
</li>
<li><p>print %*d 跳过第一个参数,输入第二个</p>
</li>
<li><p>scanf （“%*d， %*d，%d“，&amp;n）跳过两个整数，并把第三个整数赋值给n</p>
</li>
<li><p>当数值数目少于数组元素时，编译器初始化数组元素为0，若未初始化，则不初始化为0</p>
</li>
<li><p>数组大小只能用常量表示，不能用变量</p>
</li>
<li><p>const只能在声明时赋值，const修饰的数组元素会被当成常量来处理</p>
</li>
<li><p>编译器不检查索引的合法性</p>
</li>
<li><p>数组标记实际上是一种变相使用数组标记的形式</p>
</li>
<li><p>对一个指针加1的结果是对该指针增加一个存储单元</p>
</li>
<li><p>当ar是一个指针变量时，才能使用ar++这样的表达式</p>
</li>
<li><p>可以使用关系运算符来比较两个指针的值，前提是两个指针具有相同的类型</p>
</li>
<li><p>const double *pc &#x3D; rates; pc &#x3D; locked;</p>
</li>
<li><p>只有非常量数据的地址才可以赋给普通的指针</p>
</li>
<li><p>Double * const pc &#x3D; rates; pc指针不能改变</p>
</li>
<li><p>const double * const pc &#x3D; rates；值和指针都不能改变</p>
</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">MingwHuang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2021/12/21/C%E3%80%81C++/C%E8%AF%AD%E8%A8%80/">http://example.com/2021/12/21/C%E3%80%81C++/C%E8%AF%AD%E8%A8%80/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">MingwHuang's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C</a></div><div class="post_share"><div class="social-share" data-image="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202262325790.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202172251674.png" target="_blank"><img class="post-qr-code-img" src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202172251674.png" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202172251973.png" target="_blank"><img class="post-qr-code-img" src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202172251973.png" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/12/21/Chaos/Markdown/"><img class="prev-cover" src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202262325790.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Markdown 教程</div></div></a></div><div class="next-post pull-right"><a href="/2021/12/21/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/"><img class="next-cover" src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202262325790.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">区块链技术</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">MingwHuang</div><div class="author-info__description">朝花夕拾 聊以记之</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">42</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">41</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">20</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#C%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">C简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8EC"><span class="toc-number">1.1.</span> <span class="toc-text">关于C</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8C"><span class="toc-number">1.2.</span> <span class="toc-text">为什么要使用C?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C11"><span class="toc-number">1.3.</span> <span class="toc-text">C11</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE"><span class="toc-number">2.</span> <span class="toc-text">C环境设置</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#UNIX-x2F-Linux-%E4%B8%8A%E7%9A%84%E5%AE%89%E8%A3%85"><span class="toc-number">2.1.</span> <span class="toc-text">UNIX&#x2F;Linux 上的安装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mac-OS-%E4%B8%8A%E7%9A%84%E5%AE%89%E8%A3%85"><span class="toc-number">2.2.</span> <span class="toc-text">Mac OS 上的安装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Windows-%E4%B8%8A%E7%9A%84%E5%AE%89%E8%A3%85"><span class="toc-number">2.3.</span> <span class="toc-text">Windows 上的安装</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E5%92%8C%E8%AF%AD%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">C基本结构和语法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%96%87%E4%BB%B6%E7%BC%96%E8%AF%91"><span class="toc-number">3.1.</span> <span class="toc-text">多文件编译</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C%E7%9A%84%E4%BB%A4%E7%89%8C-Token"><span class="toc-number">3.2.</span> <span class="toc-text">C的令牌(Token)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="toc-number">3.3.</span> <span class="toc-text">标识符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">3.4.</span> <span class="toc-text">关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C99%E6%96%B0%E5%A2%9E%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">3.5.</span> <span class="toc-text">C99新增关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C11%E6%96%B0%E5%A2%9E%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">3.6.</span> <span class="toc-text">C11新增关键字</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.</span> <span class="toc-text">C数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.1.</span> <span class="toc-text">整数类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.2.</span> <span class="toc-text">浮点类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#void%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.3.</span> <span class="toc-text">void类型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C%E5%8F%98%E9%87%8F"><span class="toc-number">5.</span> <span class="toc-text">C变量</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#C%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E"><span class="toc-number">5.1.</span> <span class="toc-text">C中的变量声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C%E4%B8%AD%E7%9A%84%E5%B7%A6%E5%80%BC-Lvalues-%E5%92%8C%E5%8F%B3%E5%80%BC-Rvalues"><span class="toc-number">5.2.</span> <span class="toc-text">C中的左值(Lvalues)和右值(Rvalues)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C%E5%B8%B8%E9%87%8F"><span class="toc-number">6.</span> <span class="toc-text">C常量</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%B8%B8%E9%87%8F"><span class="toc-number">6.1.</span> <span class="toc-text">定义常量</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C%E5%AD%98%E5%82%A8%E7%B1%BB"><span class="toc-number">7.</span> <span class="toc-text">C存储类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#auto%E5%AD%98%E5%82%A8%E7%B1%BB"><span class="toc-number">7.1.</span> <span class="toc-text">auto存储类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#register%E5%AD%98%E5%82%A8%E7%B1%BB"><span class="toc-number">7.2.</span> <span class="toc-text">register存储类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#staic%E5%AD%98%E5%82%A8%E7%B1%BB"><span class="toc-number">7.3.</span> <span class="toc-text">staic存储类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#extern%E5%AD%98%E5%82%A8%E7%B1%BB"><span class="toc-number">7.4.</span> <span class="toc-text">extern存储类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">8.</span> <span class="toc-text">C运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">8.1.</span> <span class="toc-text">位运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">8.2.</span> <span class="toc-text">运算符优先级</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C%E5%87%BD%E6%95%B0"><span class="toc-number">9.</span> <span class="toc-text">C函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0"><span class="toc-number">9.1.</span> <span class="toc-text">定义函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-number">9.2.</span> <span class="toc-text">调用函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="toc-number">9.3.</span> <span class="toc-text">函数参数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%92%8C%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-number">9.3.1.</span> <span class="toc-text">初始化局部变量和全局变量</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-enum-%E6%9E%9A%E4%B8%BE"><span class="toc-number">10.</span> <span class="toc-text">C enum(枚举)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E5%8F%98%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">10.1.</span> <span class="toc-text">枚举变量的定义</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E4%B8%8E%E5%9B%9E%E6%8E%89%E5%87%BD%E6%95%B0"><span class="toc-number">11.</span> <span class="toc-text">C函数指针与回掉函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-number">11.1.</span> <span class="toc-text">函数指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%8E%89%E5%87%BD%E6%95%B0"><span class="toc-number">11.2.</span> <span class="toc-text">回掉函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">12.</span> <span class="toc-text">C字符串</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">13.</span> <span class="toc-text">C结构体</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C%E5%85%B1%E7%94%A8%E4%BD%93"><span class="toc-number">14.</span> <span class="toc-text">C共用体</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%85%B1%E7%94%A8%E4%BD%93"><span class="toc-number">14.1.</span> <span class="toc-text">定义共用体</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Ctypedef"><span class="toc-number">15.</span> <span class="toc-text">Ctypedef</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#typedef%E5%92%8Cdefine"><span class="toc-number">15.1.</span> <span class="toc-text">typedef和define</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA"><span class="toc-number">16.</span> <span class="toc-text">C输入和输出</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E6%96%87%E4%BB%B6"><span class="toc-number">16.1.</span> <span class="toc-text">标准文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#getchar-amp-putchar-%E5%87%BD%E6%95%B0"><span class="toc-number">16.2.</span> <span class="toc-text">getchar() &amp; putchar() 函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gets-amp-puts-%E5%87%BD%E6%95%B0"><span class="toc-number">16.3.</span> <span class="toc-text">gets() &amp; puts() 函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#scanf-%E5%92%8C-printf-%E5%87%BD%E6%95%B0"><span class="toc-number">16.4.</span> <span class="toc-text">scanf() 和 printf() 函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99"><span class="toc-number">17.</span> <span class="toc-text">C文件读写</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6"><span class="toc-number">17.1.</span> <span class="toc-text">打开文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E9%97%AD%E6%96%87%E4%BB%B6"><span class="toc-number">17.2.</span> <span class="toc-text">关闭文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6"><span class="toc-number">17.3.</span> <span class="toc-text">写入文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6"><span class="toc-number">17.4.</span> <span class="toc-text">读取文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6I-x2F-O%E5%87%BD%E6%95%B0"><span class="toc-number">17.5.</span> <span class="toc-text">二进制I&#x2F;O函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-number">18.</span> <span class="toc-text">C预处理器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%E5%AE%9E%E4%BE%8B"><span class="toc-number">18.1.</span> <span class="toc-text">预处理器实例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%84%E5%AE%9A%E4%B9%89%E5%AE%8F"><span class="toc-number">18.2.</span> <span class="toc-text">预定义宏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">18.3.</span> <span class="toc-text">预处理器运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%8F%E5%BB%B6%E7%BB%AD%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88-%EF%BC%89"><span class="toc-number">18.3.0.0.1.</span> <span class="toc-text">宏延续运算符（\）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E5%8C%96%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88-%EF%BC%89"><span class="toc-number">18.3.0.0.2.</span> <span class="toc-text">字符串常量化运算符（#）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E7%B2%98%E8%B4%B4%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88-%EF%BC%89"><span class="toc-number">18.3.0.0.3.</span> <span class="toc-text">标记粘贴运算符（##）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#defined-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">18.3.0.0.4.</span> <span class="toc-text">defined() 运算符</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E5%8C%96%E7%9A%84%E5%AE%8F"><span class="toc-number">18.4.</span> <span class="toc-text">参数化的宏</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="toc-number">19.</span> <span class="toc-text">C头文件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E5%A4%B4%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%AD%E6%B3%95"><span class="toc-number">19.1.</span> <span class="toc-text">引用头文件的语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E6%9D%A1%E4%BB%B6%E5%BC%95%E7%94%A8"><span class="toc-number">19.2.</span> <span class="toc-text">有条件引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AA%E5%BC%95%E7%94%A8%E4%B8%80%E6%AC%A1%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="toc-number">19.3.</span> <span class="toc-text">只引用一次头文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E5%A4%B4%E6%96%87%E4%BB%B6%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">19.4.</span> <span class="toc-text">引用头文件的操作</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-number">20.</span> <span class="toc-text">C错误处理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#errno-%E3%80%81perror-%E5%92%8Cstrerror"><span class="toc-number">20.1.</span> <span class="toc-text">errno()、perror()和strerror()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A2%AB%E9%9B%B6%E9%99%A4%E7%9A%84%E9%94%99%E8%AF%AF"><span class="toc-number">20.2.</span> <span class="toc-text">被零除的错误</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E9%80%80%E5%87%BA%E7%8A%B6%E6%80%81"><span class="toc-number">20.3.</span> <span class="toc-text">程序退出状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C%E8%AF%AD%E8%A8%80-exit%EF%BC%880%EF%BC%89%E4%B8%8Eexit%EF%BC%881%EF%BC%89%E3%80%81return%E5%8C%BA%E5%88%AB"><span class="toc-number">20.4.</span> <span class="toc-text">C语言 exit（0）与exit（1）、return区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0"><span class="toc-number">21.</span> <span class="toc-text">C可变参数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">22.</span> <span class="toc-text">C内存管理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0"><span class="toc-number">23.</span> <span class="toc-text">C命令行参数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-number">24.</span> <span class="toc-text">C排序算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">24.1.</span> <span class="toc-text">冒泡排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">24.2.</span> <span class="toc-text">选择排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">24.3.</span> <span class="toc-text">插入排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="toc-number">24.4.</span> <span class="toc-text">希尔排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">24.5.</span> <span class="toc-text">归并排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">24.6.</span> <span class="toc-text">快速排序</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C%E6%A0%87%E5%87%86%E5%BA%93-lt-assert-h-gt"><span class="toc-number">25.</span> <span class="toc-text">C标准库-&lt;assert.h&gt;</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">25.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%93%E5%AE%8F"><span class="toc-number">25.2.</span> <span class="toc-text">库宏</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E6%A0%87%E5%87%86%E5%BA%93-lt-ctype-h-gt"><span class="toc-number">26.</span> <span class="toc-text">C 标准库 - &lt;ctype.h&gt;</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-1"><span class="toc-number">26.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%93%E5%87%BD%E6%95%B0"><span class="toc-number">26.2.</span> <span class="toc-text">库函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E7%B1%BB"><span class="toc-number">26.3.</span> <span class="toc-text">字符类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E6%A0%87%E5%87%86%E5%BA%93-lt-errno-h-gt"><span class="toc-number">27.</span> <span class="toc-text">C 标准库 - &lt;errno.h&gt;</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-2"><span class="toc-number">27.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%93%E5%AE%8F-1"><span class="toc-number">27.2.</span> <span class="toc-text">库宏</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="toc-number">28.</span> <span class="toc-text">C 进程管理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E6%A0%87%E5%87%86%E5%BA%93-lt-float-h-gt"><span class="toc-number">29.</span> <span class="toc-text">C 标准库 - &lt;float.h&gt;</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-3"><span class="toc-number">29.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%93%E5%AE%8F-2"><span class="toc-number">29.2.</span> <span class="toc-text">库宏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B"><span class="toc-number">29.3.</span> <span class="toc-text">实例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E6%A0%87%E5%87%86%E5%BA%93-lt-limits-h-gt"><span class="toc-number">30.</span> <span class="toc-text">C 标准库 - &lt;limits.h&gt;</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-4"><span class="toc-number">30.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%93%E5%AE%8F-3"><span class="toc-number">30.2.</span> <span class="toc-text">库宏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B-1"><span class="toc-number">30.3.</span> <span class="toc-text">实例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E6%A0%87%E5%87%86%E5%BA%93-lt-locale-h-gt"><span class="toc-number">31.</span> <span class="toc-text">C 标准库 - &lt;locale.h&gt;</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-5"><span class="toc-number">31.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%93%E5%AE%8F-4"><span class="toc-number">31.2.</span> <span class="toc-text">库宏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%93%E5%87%BD%E6%95%B0-1"><span class="toc-number">31.3.</span> <span class="toc-text">库函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%93%E7%BB%93%E6%9E%84"><span class="toc-number">31.4.</span> <span class="toc-text">库结构</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E6%A0%87%E5%87%86%E5%BA%93-lt-math-h-gt"><span class="toc-number">32.</span> <span class="toc-text">C 标准库 - &lt;math.h&gt;</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-6"><span class="toc-number">32.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%93%E5%AE%8F-5"><span class="toc-number">32.2.</span> <span class="toc-text">库宏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%93%E5%87%BD%E6%95%B0-2"><span class="toc-number">32.3.</span> <span class="toc-text">库函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E6%A0%87%E5%87%86%E5%BA%93-lt-setjmp-h-gt"><span class="toc-number">33.</span> <span class="toc-text">C 标准库 - &lt;setjmp.h&gt;</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-7"><span class="toc-number">33.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%93%E5%8F%98%E9%87%8F"><span class="toc-number">33.2.</span> <span class="toc-text">库变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%93%E5%AE%8F-6"><span class="toc-number">33.3.</span> <span class="toc-text">库宏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%93%E5%87%BD%E6%95%B0-3"><span class="toc-number">33.4.</span> <span class="toc-text">库函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E6%A0%87%E5%87%86%E5%BA%93-lt-signal-h-gt"><span class="toc-number">34.</span> <span class="toc-text">C 标准库 - &lt;signal.h&gt;</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-8"><span class="toc-number">34.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%93%E5%8F%98%E9%87%8F-1"><span class="toc-number">34.2.</span> <span class="toc-text">库变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%93%E5%AE%8F-7"><span class="toc-number">34.3.</span> <span class="toc-text">库宏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%93%E5%87%BD%E6%95%B0-4"><span class="toc-number">34.4.</span> <span class="toc-text">库函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E6%A0%87%E5%87%86%E5%BA%93-lt-stdarg-h-gt"><span class="toc-number">35.</span> <span class="toc-text">C 标准库 - &lt;stdarg.h&gt;</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-9"><span class="toc-number">35.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%93%E5%8F%98%E9%87%8F-2"><span class="toc-number">35.2.</span> <span class="toc-text">库变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%93%E5%AE%8F-8"><span class="toc-number">35.3.</span> <span class="toc-text">库宏</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E6%A0%87%E5%87%86%E5%BA%93-lt-stddef-h-gt"><span class="toc-number">36.</span> <span class="toc-text">C 标准库 - &lt;stddef.h&gt;</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-10"><span class="toc-number">36.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%93%E5%8F%98%E9%87%8F-3"><span class="toc-number">36.2.</span> <span class="toc-text">库变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%93%E5%AE%8F-9"><span class="toc-number">36.3.</span> <span class="toc-text">库宏</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E6%A0%87%E5%87%86%E5%BA%93-lt-stdio-h-gt"><span class="toc-number">37.</span> <span class="toc-text">C 标准库 - &lt;stdio.h&gt;</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-11"><span class="toc-number">37.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%93%E5%8F%98%E9%87%8F-4"><span class="toc-number">37.2.</span> <span class="toc-text">库变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%93%E5%AE%8F-10"><span class="toc-number">37.3.</span> <span class="toc-text">库宏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%93%E5%87%BD%E6%95%B0-5"><span class="toc-number">37.4.</span> <span class="toc-text">库函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E6%A0%87%E5%87%86%E5%BA%93-lt-stdlib-h-gt"><span class="toc-number">38.</span> <span class="toc-text">C 标准库 - &lt;stdlib.h&gt;</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-12"><span class="toc-number">38.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%93%E5%8F%98%E9%87%8F-5"><span class="toc-number">38.2.</span> <span class="toc-text">库变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%93%E5%AE%8F-11"><span class="toc-number">38.3.</span> <span class="toc-text">库宏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%93%E5%87%BD%E6%95%B0-6"><span class="toc-number">38.4.</span> <span class="toc-text">库函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E6%A0%87%E5%87%86%E5%BA%93-lt-string-h-gt"><span class="toc-number">39.</span> <span class="toc-text">C 标准库 - &lt;string.h&gt;</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-13"><span class="toc-number">39.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%93%E5%8F%98%E9%87%8F-6"><span class="toc-number">39.2.</span> <span class="toc-text">库变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%93%E5%AE%8F-12"><span class="toc-number">39.3.</span> <span class="toc-text">库宏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%93%E5%87%BD%E6%95%B0-7"><span class="toc-number">39.4.</span> <span class="toc-text">库函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E6%A0%87%E5%87%86%E5%BA%93-lt-time-h-gt"><span class="toc-number">40.</span> <span class="toc-text">C 标准库 - &lt;time.h&gt;</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-14"><span class="toc-number">40.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%93%E5%8F%98%E9%87%8F-7"><span class="toc-number">40.2.</span> <span class="toc-text">库变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%93%E5%AE%8F-13"><span class="toc-number">40.3.</span> <span class="toc-text">库宏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%93%E5%87%BD%E6%95%B0-8"><span class="toc-number">40.4.</span> <span class="toc-text">库函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#chaos"><span class="toc-number">41.</span> <span class="toc-text">chaos</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/02/26/%E9%9D%A2%E8%AF%95/Redis/" title="Redis"><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202262325790.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis"/></a><div class="content"><a class="title" href="/2022/02/26/%E9%9D%A2%E8%AF%95/Redis/" title="Redis">Redis</a><time datetime="2022-02-26T06:21:50.000Z" title="发表于 2022-02-26 14:21:50">2022-02-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/02/26/K8S/" title="无题"><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202262325790.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2022/02/26/K8S/" title="无题">无题</a><time datetime="2022-02-26T01:48:42.239Z" title="发表于 2022-02-26 09:48:42">2022-02-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/02/26/Chaos/Chaos/" title="无题"><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202262325790.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2022/02/26/Chaos/Chaos/" title="无题">无题</a><time datetime="2022-02-26T01:48:42.239Z" title="发表于 2022-02-26 09:48:42">2022-02-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/02/20/Mac-%E6%B7%B1%E5%BA%A6%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/" title="Mac 深度使用技巧"><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202262325790.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Mac 深度使用技巧"/></a><div class="content"><a class="title" href="/2022/02/20/Mac-%E6%B7%B1%E5%BA%A6%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/" title="Mac 深度使用技巧">Mac 深度使用技巧</a><time datetime="2022-02-20T14:38:23.000Z" title="发表于 2022-02-20 22:38:23">2022-02-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/02/15/%E9%9D%A2%E8%AF%95/MySQL/" title="MySQL"><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202262325790.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL"/></a><div class="content"><a class="title" href="/2022/02/15/%E9%9D%A2%E8%AF%95/MySQL/" title="MySQL">MySQL</a><time datetime="2022-02-15T10:46:58.000Z" title="发表于 2022-02-15 18:46:58">2022-02-15</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By MingwHuang</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a><span class="footer-separator">|</span><a href="https://beian.miit.gov.cn/" target="_blank">赣ICP备2022001353号-1</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>