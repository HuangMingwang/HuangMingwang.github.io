<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Java | MingwHuang's Blog</title><meta name="keywords" content="Java"><meta name="author" content="MingwHuang"><meta name="copyright" content="MingwHuang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="[TOC] Java面向对象 private 类加载 双亲委派 垃圾回收算法 G1 ZGC AQS 锁 设计cas synchronized 内存屏障 写屏障 线程池 mysql 索引 hashmap 怎么判断链表环 基础内部类的优点和缺点可以被private和protected修饰。  优点：内部类可以随意使用外部类的成员变量（包括私有）而不用生成外部类的对象，这也是内部类的唯一优点。 缺点：破">
<meta property="og:type" content="article">
<meta property="og:title" content="Java">
<meta property="og:url" content="http://mingwzi.cn/2021/12/21/base/Java/index.html">
<meta property="og:site_name" content="MingwHuang&#39;s Blog">
<meta property="og:description" content="[TOC] Java面向对象 private 类加载 双亲委派 垃圾回收算法 G1 ZGC AQS 锁 设计cas synchronized 内存屏障 写屏障 线程池 mysql 索引 hashmap 怎么判断链表环 基础内部类的优点和缺点可以被private和protected修饰。  优点：内部类可以随意使用外部类的成员变量（包括私有）而不用生成外部类的对象，这也是内部类的唯一优点。 缺点：破">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272046990.jpg">
<meta property="article:published_time" content="2021-12-21T10:46:58.000Z">
<meta property="article:modified_time" content="2022-02-28T04:21:50.000Z">
<meta property="article:author" content="MingwHuang">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272046990.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://mingwzi.cn/2021/12/21/base/Java/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":500},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-02-28 12:21:50'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.1.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272113875.JPG" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">45</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">42</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272046990.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">MingwHuang's Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-12-21T10:46:58.000Z" title="发表于 2021-12-21 18:46:58">2021-12-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-02-28T04:21:50.000Z" title="更新于 2022-02-28 12:21:50">2022-02-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/base/">base</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>[TOC]</p>
<h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><p>面向对象</p>
<p>private</p>
<p>类加载</p>
<p>双亲委派</p>
<p>垃圾回收算法</p>
<p>G1</p>
<p>ZGC</p>
<p>AQS 锁</p>
<p>设计cas</p>
<p>synchronized</p>
<p>内存屏障 写屏障</p>
<p>线程池</p>
<p>mysql</p>
<p>索引</p>
<p>hashmap</p>
<p>怎么判断链表环</p>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="内部类的优点和缺点"><a href="#内部类的优点和缺点" class="headerlink" title="内部类的优点和缺点"></a>内部类的优点和缺点</h3><p>可以被private和protected修饰。</p>
<ul>
<li>优点：内部类可以随意使用外部类的成员变量（包括私有）而不用生成外部类的对象，这也是内部类的唯一优点。</li>
<li>缺点：破坏了原有类的程序结构。</li>
</ul>
<h3 id="switch-是否能作用在-byte，long，String"><a href="#switch-是否能作用在-byte，long，String" class="headerlink" title="switch 是否能作用在 byte，long，String"></a>switch 是否能作用在 byte，long，String</h3><p>Java 5 以前，switch(expr)中，expr 只能是 byte、short、char、int。</p>
<p>从  Java5 开始，expr 可以是 enum 类型。</p>
<p>从 Java 7  开始，expr 还可以是字符串（String）。</p>
<p>长整型（long）在目前所有的版本中都是不可以的。</p>
<h3 id="Java语言采用何种编码方案"><a href="#Java语言采用何种编码方案" class="headerlink" title="Java语言采用何种编码方案"></a>Java语言采用何种编码方案</h3><p>Unicode（标准码）： 它为每个字符制订了一个唯一的数值，因此在任何的语言，平台，程序都可以运行。</p>
<h4 id="在-Java-中，如何跳出当前的多重嵌套循环"><a href="#在-Java-中，如何跳出当前的多重嵌套循环" class="headerlink" title="在 Java 中，如何跳出当前的多重嵌套循环"></a>在 Java 中，如何跳出当前的多重嵌套循环</h4><p>在Java中，要想跳出多重循环，可以在外面的循环语句前定义一个标号，然后在里层循环体的代码中使用带有标号的break 语句，即可跳出外层循环。</p>
<h3 id="用最有效率的方法计算-2的3次方"><a href="#用最有效率的方法计算-2的3次方" class="headerlink" title="用最有效率的方法计算 2的3次方"></a>用最有效率的方法计算 2的3次方</h3><p>2 &lt;&lt; 3</p>
<h3 id="float-f-x3D-3-4"><a href="#float-f-x3D-3-4" class="headerlink" title="float f&#x3D;3.4"></a>float f&#x3D;3.4</h3><p>应该写成float f &#x3D;(float)3.4或 float f &#x3D;3.4F。</p>
<h3 id="short-s1-x3D-1-s1-x3D-s1-1-和-short-s1-x3D-1-s1-x3D-1"><a href="#short-s1-x3D-1-s1-x3D-s1-1-和-short-s1-x3D-1-s1-x3D-1" class="headerlink" title="short s1 &#x3D; 1; s1 &#x3D; s1 + 1; 和 short s1 &#x3D; 1; s1 +&#x3D; 1;"></a>short s1 &#x3D; 1; s1 &#x3D; s1 + 1; 和 short s1 &#x3D; 1; s1 +&#x3D; 1;</h3><p>1 是 int 类型，因此 s1+1 运算结果也是 int型，需要强制类型转换。</p>
<p>s1+&#x3D; 1相当于 s1 &#x3D; (short(s1 + 1)，其中有隐含的强制类型转换。</p>
<h3 id="private，default，protected，public"><a href="#private，default，protected，public" class="headerlink" title="private，default，protected，public"></a>private，default，protected，public</h3><p>private：当前类。使用对象：变量、方法。<br>default：同包。使用对象：类、接口、变量、方法。<br>protected：同包，子类。使用对象：变量、方法<br>public： 同包，子类，其他包。使用对象：类、接口、变量、方法。</p>
<p> 注意：</p>
<p>private和protected不能修饰类（外部类）。外部类就是模版，使用private和protected修饰就没有任何意义。 private和protected不能修饰接口，只能public（default可以写出来，但是编译之后自动转为了public），</p>
<h4 id="为什么类和接口（不考虑内部类和接口）不能使用private和protected修饰词，只能是public和default？"><a href="#为什么类和接口（不考虑内部类和接口）不能使用private和protected修饰词，只能是public和default？" class="headerlink" title="为什么类和接口（不考虑内部类和接口）不能使用private和protected修饰词，只能是public和default？"></a>为什么类和接口（不考虑内部类和接口）不能使用private和protected修饰词，只能是public和default？</h4><p>private：</p>
<p>很好理解，类和接口如果定义成private，那么其他任何类都不能访问，这样的类写出来也没有意义。</p>
<p>protected：</p>
<p>这个问题用反证法比较好解释清楚，假设类B和A不在同一个包，A又是protected类， 那么B能访问A的前提是B是A的子类，而B能成为A的子类（或者说B能继承A）的前提又是B能访问A。这两个条件互为前提，无法实现。</p>
<h4 id="为什么接口的方法不能是private和protected，只能public（default可以写出来，但是编译之后自动转为了public）？"><a href="#为什么接口的方法不能是private和protected，只能public（default可以写出来，但是编译之后自动转为了public）？" class="headerlink" title="为什么接口的方法不能是private和protected，只能public（default可以写出来，但是编译之后自动转为了public）？"></a>为什么接口的方法不能是private和<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=protected&spm=1001.2101.3001.7020">protected</a>，只能public（default可以写出来，但是编译之后自动转为了public）？</h4><p>private：</p>
<p>接口是需要其他类实现的，如果方法定义成private，那么其他任何类都不能访问。这样的方法即要求被实现，又对任何类不可见，这是无法实现的。</p>
<p>protected：</p>
<p>（1）假设public接口I有一个protected方法M，那么位于其他包的public类C就可以实现这个接口（方法M依然是protected）。那么C的同包类D调用方法M只能这样访问：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">C</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">C</span>();</span><br><span class="line">c.M();</span><br><span class="line"><span class="comment">//无法这样访问：</span></span><br><span class="line"><span class="type">I</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">C</span>();</span><br><span class="line">c.M();</span><br></pre></td></tr></table></figure>

<p>这样就失去了使用接口的重要意义：提供统一的接口，面向接口编程思想也无法体现。</p>
<p>（2）假设接口I是default的，那么方法M是protected理论上是没有问题的，而且M也可以是default、public。至于为什么不让用protected，可能是出于简化修饰词的复杂度的目的（如果使用，需要区分接口是public的时候不能用，default接口则能用），至于default请参考（3）。</p>
<p>default:</p>
<p>（3）假设public接口I有一个default方法M， 那么位于其他包的无法正常实现接口I，因为方法M对其不可见。</p>
<p>（4）假设default接口I有一个default方法M，那么方法M是default理论上是没有问题的，而且M也可以是proteced、public。可能出于和（2）所说不能用protected的相同原因，不能使用default。</p>
<p>因此，综合以上四点，接口方法只能使用public，既然只能用public，java编译器在你忘了在M前写public的时候干脆自动帮你转成public了。</p>
<h3 id="3-0-1-x3D-x3D-0-3返回值是什么"><a href="#3-0-1-x3D-x3D-0-3返回值是什么" class="headerlink" title="3*0.1&#x3D;&#x3D;0.3返回值是什么"></a><strong>3*0.1&#x3D;&#x3D;0.3返回值是什么</strong></h3><p>false，因为有些浮点数不能完全精确的表示出来。</p>
<h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><ul>
<li><p>被final修饰的方法，JVM会尝试将其内联，以提高运行效率。</p>
</li>
<li><p>被final修饰的常量，在编译阶段会存入常量池中。</p>
</li>
<li><p>被final修饰的类不可以被继承。</p>
</li>
<li><p>被final修饰的方法不可以被重写。</p>
</li>
<li><p>被final修饰的变量不可以被改变。被final修饰不可变的是变量的引用，而不是引用指向的内容;</p>
</li>
<li><p>final不可变性的保证是靠编译器来保证的。</p>
</li>
</ul>
<h3 id="java语言特点"><a href="#java语言特点" class="headerlink" title="java语言特点"></a>java语言特点</h3><ul>
<li><p>简单易学。</p>
</li>
<li><p>面向对象。</p>
</li>
<li><p>跨平台。</p>
</li>
<li><p>支持多线程。</p>
</li>
<li><p>支持网络编程而且很方便（Java 语言诞生本身就是为简化网络编程设计的，因此 Java 语言不仅支持网络编程而且很方便）。</p>
</li>
<li><p>编译和解释并存。</p>
</li>
</ul>
<h3 id="JVM-JDK-JRE"><a href="#JVM-JDK-JRE" class="headerlink" title="JVM JDK JRE"></a>JVM JDK JRE</h3><p>JVM：运行java字节码的虚拟机。有针对不同系统的特定实现，使用相同的字节码，在不同系统下运行都会有相同的结果。</p>
<blockquote>
<p> class文件到机器码：在这一步 JVM类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的（也就是所谓的热点代码），所以后面引进了 JIT（just-in-time）编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。机器码的运行效率肯定是高于 Java 解释器的。这也解释了为什么经常会说 Java 是编译与解释共存的语言。</p>
</blockquote>
<blockquote>
<p>HotSpot 采用了惰性评估（Lazy Evaluation）的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是 JIT 所需要编译的部分。JVM 会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。JDK 9 引入了一种新的编译模式 AOT（Ahead of Time Compilation），它是直接将class文件编译成机器码，这样就避免了 JIT 预热等各方面的开销。JDK 支持分层编译和 AOT 协作使用。但是 ，AOT 编译器的编译质量是肯定比不上 JIT 编译器的。</p>
</blockquote>
<p>JDK：java development kit </p>
<p>JRE： java runtime environment</p>
<p>有时，即使不打算在计算机上进行任何 Java 开发，仍然需要安装 JDK。例如，如果要使用 JSP 部署 Web 应用程序，那么从技术上讲，只是在应用程序服务器中运行 Java 程序。但是应用程序服务器会将 JSP 转换为 Java servlet，并且需要使用 JDK 来编译 servlet。</p>
<h3 id="Oracle-JDK-和-Open-JDK的对比"><a href="#Oracle-JDK-和-Open-JDK的对比" class="headerlink" title="Oracle JDK 和 Open JDK的对比"></a>Oracle JDK 和 Open JDK的对比</h3><ul>
<li><p>OpenJDK 是一个参考模型并且是完全开源的，而 Oracle JDK 是 OpenJDK 的一个实现，并不是完全开源的；</p>
</li>
<li><p>Oracle JDK 比 OpenJDK 更稳定。OpenJDK 和 Oracle JDK 的代码几乎相同，但 Oracle JDK 有更多的类和一些错误修复。因此，如果想开发企业&#x2F;商业软件，建议选择 Oracle JDK，因为它经过了彻底的测试和稳定。某些情况下，有些人提到在使用 OpenJDK 可能会遇到了许多应用程序崩溃的问题，但是，只需切换到 Oracle JDK 就可以解决问题；</p>
</li>
<li><p>在响应性和 JVM 性能方面，Oracle JDK 与 OpenJDK 相比提供了更好的性能；</p>
</li>
<li><p>Oracle JDK 不会为即将发布的版本提供长期支持，用户每次都必须通过更新到最新版本获得支持来获取最新版本；</p>
</li>
<li><p>Oracle JDK 根据二进制代码许可协议获得许可，而 OpenJDK 根据 GPL v2 许可获得许可。</p>
</li>
</ul>
<h3 id="Java和C-的区别"><a href="#Java和C-的区别" class="headerlink" title="Java和C++的区别"></a>Java和C++的区别</h3><ul>
<li><p>都是面向对象的语言，都支持封装，继承，多态；</p>
</li>
<li><p>Java不提供指针直接访问内存，程序更加安全；</p>
</li>
<li><p>Java的类是单继承的，C++支持多继承，但Java接口可以多继承（为了弥补不支持多继承的缺点）；</p>
</li>
<li><p>Java有GC，不需要程序员手动释放无用内存。</p>
</li>
<li><p>在 C 语言中，字符串或字符数组最后都会有一个额外的字符’\0’来表示结束。但是，Java 语言中没有结束符这一概念。</p>
</li>
</ul>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/sszgg2006/article/details/49148189">https://blog.csdn.net/sszgg2006/article/details/49148189</a></p>
<p>Java里面一切都是对象，是对象的话，字符串肯定就有长度，即然有长度，编译器就可以确定要输出的字符个数，也就没有必要浪费那1字节的空间用以标明字符串的结束了。比如，数组对象里有一个属性length，就是数组的长度，String类里面有方法length()可以确定字符串的长度，因此对于输出函数来说，有直接的大小可以判断字符串的边界，编译器就没必要再去浪费一个空间标识字符串的结束。<br>Java和C通信的时候，由于C中的char中有结束符的，所以当Java收到C发来的字符串时，后面往往会有若干空字符，如果不做处理的话，Java会对其一并输出，为了将空字符处理掉不输出，可以采用如下两种方法：</p>
<p>方法一:</p>
<p>调用Java字符串的trim()方法，该方法会将字符串前后的空字符都去掉。</p>
<p>方法二：</p>
<p>自己实现去掉尾部空字符的方法。</p>
</blockquote>
<h3 id="import-java和javax-的区别"><a href="#import-java和javax-的区别" class="headerlink" title="import java和javax 的区别?"></a>import java和javax 的区别?</h3><p>刚开始的时候 JavaAPI 所必需的包是 java 开头的包，javax 当时只是扩展 API 包来使用。然而随着时间的推移，javax 逐渐地扩展成为 Java API 的组成部分。但是，将扩展从 javax 包移动到 java 包确实太麻烦了，最终会破坏一堆现有的代码。因此，最终决定 javax 包将成为标准 API 的一部分。</p>
<p>所以，实际上 java 和 javax 没有区别。</p>
<h3 id="为什么说Java语言“编译与解释并存”"><a href="#为什么说Java语言“编译与解释并存”" class="headerlink" title="为什么说Java语言“编译与解释并存”?"></a>为什么说Java语言“编译与解释并存”?</h3><p>高级编程语言按照程序的执行方式分为编译型和解释型两种。简单来说，编译型语言是指编译器针对特定的操作系统将源代码一次性翻译成可被该平台执行的机器码；解释型语言是指解释器对源程序逐行解释成特定平台的机器码并立即执行。比如，<strong>你想阅读一本英文名著，你可以找一个英文翻译人员帮助你阅读， 有两种选择方式，你可以先等翻译人员将全本的英文名著（也就是源码）都翻译成汉语，再去阅读，也可以让翻译人员翻译一段，你在旁边阅读一段，慢慢把书读完。</strong></p>
<p>Java 语言既具有编译型语言的特征，也具有解释型语言的特征，因为 Java 程序要经过先编译，后解释两个步骤。由 Java 编写的程序需要先经过编译步骤，生成字节码（*.class 文件），这种字节码必须由 Java 解释器来解释执行。因此，可以认为 Java 语言编译与解释并存。</p>
<h3 id="字符型常量和字符串常量区别"><a href="#字符型常量和字符串常量区别" class="headerlink" title="字符型常量和字符串常量区别"></a>字符型常量和字符串常量区别</h3><ul>
<li><p>形式上：字符常量是单引号引起的一个字符；字符串常量是双引号引起的0个或若干的字符。</p>
</li>
<li><p>含义上：字符常量相当于一个整形值（ASCII值），可以参与表达式的运算；字符串常量代表一个地址值（该字符串在内存中的存放位置）。</p>
</li>
<li><p>占内存大小：字符常量只占两个字节；字符串常量占若干个字节。</p>
</li>
</ul>
<blockquote>
<p>Java基本类型所占存储空间的大小不像其他语言那样随机器硬件架构的变化而变化。这种所占存储空间的大小不变的性质是Java程序比其他大多数语言编写的程序更具有可移植性的原因之一。</p>
</blockquote>
<h3 id="标识符和关键字的区别"><a href="#标识符和关键字的区别" class="headerlink" title="标识符和关键字的区别"></a>标识符和关键字的区别</h3><p>标识符就是一个名字。</p>
<p>关键字是被赋予特殊含义的标识符。比如警察局就是一个关键字。</p>
<h3 id="Java泛型-什么是类型擦除-介绍一下常用的通配符"><a href="#Java泛型-什么是类型擦除-介绍一下常用的通配符" class="headerlink" title="Java泛型?什么是类型擦除? 介绍一下常用的通配符?"></a>Java泛型?什么是类型擦除? 介绍一下常用的通配符?</h3><p>Java 泛型（generics）是 JDK 5 中引入的一个新特性，泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。</p>
<p>Java的泛型是伪泛型，在编译期间，所有的泛型信息都会被擦掉，这也就是类型擦除。在运行期间通过反射创建对象就可以任意添加其他类型的对象。</p>
<p>Java编译器会在编译时尽可能的发现可能出错的地方，但是仍然无法在运行时刻出现的类型转换异常的情况，类型擦除也是Java的泛型与C++模板机制实现方式之间的重要区别。</p>
<p>类型检查就是针对引用的，谁是一个引用，用这个引用调用泛型方法，就会对这个引用调用的方法进行类型检测，而无关它真正引用的对象。</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wuqinglong/p/9456193.html">《Java 泛型类型擦除以及类型擦除带来的问题》</a></p>
<p>原始类型就是擦除了泛型信息，最后在字节码中的类型变量的真正类型，无论何时定义一个泛型，相应的原始类型都会被自动提供，类型变量擦除，并使用其限定类型（无限定的变量用Object）替换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;  </span><br><span class="line">    <span class="keyword">private</span> T value;  </span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getValue</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> value;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(T  value)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.value = value;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// pair的原始类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> Object value;  </span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getValue</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> value;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(Object  value)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.value = value;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Pair如果这样声明的话，那么原始类型就是Comparable</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>在调用泛型方法时，可以指定泛型，也可以不指定泛型。</p>
<ul>
<li>在不指定泛型的情况下，泛型变量的类型为该方法中的几种类型的同一父类的最小级，直到Object；</li>
<li>在指定泛型的情况下，该方法的几种类型必须是该泛型实例的类型或者其子类。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="comment">/**不指定泛型的时候*/</span>  </span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> Test.add(<span class="number">1</span>， <span class="number">2</span>); <span class="comment">//这两个参数都是Integer，所以T为Integer类型  </span></span><br><span class="line">        <span class="type">Number</span> <span class="variable">f</span> <span class="operator">=</span> Test.add(<span class="number">1</span>， <span class="number">1.2</span>); <span class="comment">//这两个参数一个是Integer，以风格是Float，所以取同一父类的最小级，为Number  </span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> Test.add(<span class="number">1</span>， <span class="string">&quot;asd&quot;</span>); <span class="comment">//这两个参数一个是Integer，以风格是Float，所以取同一父类的最小级，为Object  </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**指定泛型的时候*/</span>  </span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> Test.&lt;Integer&gt;add(<span class="number">1</span>， <span class="number">2</span>); <span class="comment">//指定了Integer，所以只能为Integer类型或者其子类  </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> Test.&lt;Integer&gt;add(<span class="number">1</span>， <span class="number">2.2</span>); <span class="comment">//编译错误，指定了Integer，不能为Float  </span></span><br><span class="line">        <span class="type">Number</span> <span class="variable">c</span> <span class="operator">=</span> Test.&lt;Number&gt;add(<span class="number">1</span>， <span class="number">2.2</span>); <span class="comment">//指定为Number，所以可以为Integer和Float  </span></span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//这是一个简单的泛型方法  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">add</span><span class="params">(T x，T y)</span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> y;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>因为类型检查就是编译时完成的，new ArrayList()只是在内存中开辟了一个存储空间，可以存储任何类型对象，而真正设计类型检查的是它的引用，因为是使用它引用list1来调用它的方法，比如说调用add方法，所以list1引用能完成泛型类型的检查。而引用list2没有使用泛型，所以不行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>(); <span class="comment">//可以实现与完全使用泛型参数一样的效果</span></span><br><span class="line"><span class="type">ArrayList</span> <span class="variable">list2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(); <span class="comment">//没有效果，会有编译时警告</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;().add(<span class="string">&quot;11&quot;</span>); <span class="comment">//编译通过  </span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;().add(<span class="number">22</span>);   <span class="comment">//编译错误  </span></span><br></pre></td></tr></table></figure>

<h5 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h5><ul>
<li>？ 表示不确定的 Java 类型</li>
<li>T （type）表示具体的一个 Java 类型</li>
<li>K V （key value）分别代表 Java 键值中的Key Value</li>
<li>E （element） 代表 Element</li>
</ul>
<p>更多关于 Java 泛型中的通配符可以查看这篇文章：<a target="_blank" rel="noopener" href="https://juejin.im/post/5d5789d26fb9a06ad0056bd9">《聊一聊-JAVA 泛型中的通配符 T，E，K，V，？》</a></p>
<p>？和 T 都表示不确定的类型，区别在于可以对 T 进行操作，但是对 ？ 不行，比如如下这种 ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以</span></span><br><span class="line"><span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> operate();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不可以</span></span><br><span class="line">？ car = operate();</span><br></pre></td></tr></table></figure>

<p>区别1：通过T来确保泛型参数的一致性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过 T 来 确保 泛型参数的一致性</span></span><br><span class="line"><span class="keyword">public</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; <span class="keyword">void</span></span><br><span class="line"><span class="title function_">test</span><span class="params">(List&lt;T&gt; dest， List&lt;T&gt; src)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通配符是 不确定的，所以这个方法不能保证两个 List 具有相同的元素类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span></span><br><span class="line"><span class="title function_">test</span><span class="params">(List&lt;? extends Number&gt; dest， List&lt;? extends Number&gt; src)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>区别2：类型参数可以多重限定而通配符不行</p>
<p>区别3：通配符可以使用超类限定而类型参数不行</p>
<p>类型参数 T 只具有 一种 类型限定方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T extends A</span><br></pre></td></tr></table></figure>

<p>但是通配符 ? 可以进行 两种限定：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">? extends A</span><br><span class="line">? super A</span><br></pre></td></tr></table></figure>

<h3 id="x3D-x3D-和-equals"><a href="#x3D-x3D-和-equals" class="headerlink" title="&#x3D;&#x3D; 和 equals"></a>&#x3D;&#x3D; 和 equals</h3><p>string方法的equals重写过了</p>
<h3 id="hashCode-与-equals"><a href="#hashCode-与-equals" class="headerlink" title="hashCode() 与 equals()"></a>hashCode() 与 equals()</h3><p>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个 int 整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode()定义在 JDK 的 Object 类中，Java 中的任何类都包含有 hashCode() 函数。另外需要注意的是： Object 的 hashCode() 方法是本地方法，也就是用 C 语言或 C++ 实现的，该方法通常用来将对象的内存地址转换为整数之后返回。</p>
<p>当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，HashSet 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals() 方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。</p>
<p>如果两个对象相等，则 hashcode 一定也是相同的。两个对象相等，对两个对象分别调用 equals 方法都返回 true。但是，两个对象有相同的 hashcode 值，它们也不一定是相等的 。因此，equals 方法被覆盖过，则 hashCode() 方法也必须被覆盖。</p>
<blockquote>
<p>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</p>
</blockquote>
<h3 id="八种基本类型、包装类、常量池"><a href="#八种基本类型、包装类、常量池" class="headerlink" title="八种基本类型、包装类、常量池"></a>八种基本类型、包装类、常量池</h3><p>byte， char， short， int， long， float， double， boolean</p>
<p>1，2，2，4，8，4，8， 未定义</p>
<p>Byte， Character， Short， Integer， Long， Float， Double， Boolean</p>
<p>Java 里使用 long 类型的数据一定要在数值后面加上 L，否则将作为整型解析。</p>
<p>Java 基本类型的包装类的大部分都实现了常量池技术， Byte、Short、Integer和Long默认创建了数值[-128，127] 的相应类型的缓存数据，Character 创建了数值在[0，127]范围的缓存数据，Boolean 直接返回 True Or False。</p>
<p><strong>Integer的一个例子</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">40</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">40</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i3</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">40</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">40</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;i1=i2   &quot;</span> + (i1 == i2));</span><br><span class="line">System.out.println(<span class="string">&quot;i1=i2+i3   &quot;</span> + (i1 == i2 + i3));</span><br><span class="line">System.out.println(<span class="string">&quot;i1=i4   &quot;</span> + (i1 == i4));</span><br><span class="line">System.out.println(<span class="string">&quot;i4=i5   &quot;</span> + (i4 == i5));</span><br><span class="line">System.out.println(<span class="string">&quot;i4=i5+i6   &quot;</span> + (i4 == i5 + i6));</span><br><span class="line">System.out.println(<span class="string">&quot;40=i5+i6   &quot;</span> + (<span class="number">40</span> == i5 + i6));</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">i1=i2   true</span><br><span class="line">i1=i2+i3   true</span><br><span class="line">i1=i4   false</span><br><span class="line">i4=i5   false</span><br><span class="line">i4=i5+i6   true</span><br><span class="line">40=i5+i6   true</span><br></pre></td></tr></table></figure>

<p>解释：</p>
<p>语句 i4 &#x3D;&#x3D; i5 + i6，因为+这个操作符不适用于 Integer 对象，首先 i5 和 i6 进行自动拆箱操作，进行数值相加，即 i4 &#x3D;&#x3D; 40。然后 Integer 对象无法与数值进行直接比较，所以 i4 自动拆箱转为 int 值 40，最终这条语句转为 40 &#x3D;&#x3D; 40 进行数值比较。</p>
<h3 id="Java值传递"><a href="#Java值传递" class="headerlink" title="Java值传递?"></a>Java值传递?</h3><p>Java 程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，方法不能修改传递给它的任何参数变量的内容。</p>
<h3 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h3><p>重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。</p>
<ul>
<li><p>返回值类型、方法名、参数列表必须相同，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类；</p>
</li>
<li><p>如果父类方法访问修饰符为 private&#x2F;final&#x2F;static 则子类就不能重写该方法，但是被 static 修饰的方法能够被再次声明；</p>
</li>
<li><p>构造方法无法被重写。</p>
</li>
</ul>
<p>综上：重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变。</p>
<table>
<thead>
<tr>
<th>区别点</th>
<th>重载方法</th>
<th>重写方法</th>
</tr>
</thead>
<tbody><tr>
<td>发生范围</td>
<td>同一个类</td>
<td>子类</td>
</tr>
<tr>
<td>参数列表</td>
<td><strong>必须修改</strong></td>
<td>一定不能修改</td>
</tr>
<tr>
<td>返回类型</td>
<td>可修改</td>
<td>子类方法返回值类型应比父类方法返回值类型更小或相等</td>
</tr>
<tr>
<td>异常</td>
<td>可修改</td>
<td>子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</td>
</tr>
<tr>
<td>访问修饰符</td>
<td>可修改</td>
<td>一定不能做更严格的限制（可以降低限制）</td>
</tr>
<tr>
<td>发生阶段</td>
<td>编译期</td>
<td>运行期</td>
</tr>
</tbody></table>
<p><strong>方法的重写要遵循“两同两小一大”</strong></p>
<ul>
<li>“两同”即方法名相同、形参列表相同；</li>
<li>“两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</li>
<li>“一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。</li>
</ul>
<p>⭐️ <strong>重写的返回值类</strong>型：如果方法的返回类型是void和基本数据类型，则返回值重写时不可修改。但是如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的。</p>
<h3 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="面向对象和面向过程的区别"></a>面向对象和面向过程的区别</h3><ul>
<li>面向过程：性能高。 因为类调用时需要实例化，开销比较大，比较消耗资源，所以当性能是最重要的考量因素的时候，比如单片机、嵌入式开发、Linux&#x2F;Unix 等一般采用面向过程开发。但是，面向过程没有面向对象易维护、易复用、易扩展。</li>
<li>面向对象：易维护、易复用、易扩展。 因为面向对象有封装、继承和多态的特性，所以可以设计出低耦合的系统，使系统更加灵活、更加易于维护。但是，面向对象性能比面向过程低。</li>
</ul>
<h3 id="构造器是否可被重写"><a href="#构造器是否可被重写" class="headerlink" title="构造器是否可被重写?"></a>构造器是否可被重写?</h3><p>Constructor 不能被 override（重写），但是可以 overload（重载），可以在一个类中有多个构造函数。</p>
<h3 id="在Java中定义一个不做事且没有参数的构造方法的作用"><a href="#在Java中定义一个不做事且没有参数的构造方法的作用" class="headerlink" title="在Java中定义一个不做事且没有参数的构造方法的作用"></a>在Java中定义一个不做事且没有参数的构造方法的作用</h3><p>Java 程序在执行子类的构造方法之前，如果没有用 super()来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用 super()来调用父类中特定的构造方法，则编译时将发生错误，因为 Java 程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。帮助子类做初始化工作。</p>
<p>如果在类中你提供了其他有参的构造器，则编译器不会提供默认的无参构造器。</p>
<p>如果在类中你没有提供任何构造器，则编译器会提供一个默认的无参构造器。</p>
<p>如果你提供了一个构造器，你无须手动添加super()到你的构造器，编译器会默认添加。</p>
<p>如果父类未提供无参构造器，且子类没有使用super()调用父类有参构造的话编译器会报错。</p>
<p>如果构造器中添加了this引用该类的其他构造器，或者添加了super()调用父类构造器，this和super必须在构造器第一行，this引用其他构造器和super()语句不会同时出现。</p>
<h3 id="一个类的构造方法的作用是什么-若一个类没有声明构造方法，该程序能正确执行吗"><a href="#一个类的构造方法的作用是什么-若一个类没有声明构造方法，该程序能正确执行吗" class="headerlink" title="一个类的构造方法的作用是什么? 若一个类没有声明构造方法，该程序能正确执行吗?"></a>一个类的构造方法的作用是什么? 若一个类没有声明构造方法，该程序能正确执行吗?</h3><p>主要作用是完成对类对象的初始化工作。</p>
<p>可以执行。因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。如果添加了类的构造方法（无论是否有参），Java 就不会再添加默认的无参数的构造方法了，这时候，就不能直接 new 一个对象而不传递参数了。如果重载了有参的构造方法，记得都要把无参的构造方法也写出来（无论是否用到）。</p>
<p>构造方法:</p>
<ul>
<li><p>名字与类名相同。</p>
</li>
<li><p>没有返回值，但不能用 void 声明构造函数。</p>
</li>
<li><p>生成类的对象时自动执行，无需调用。</p>
</li>
</ul>
<h3 id="成员变量和局部变量"><a href="#成员变量和局部变量" class="headerlink" title="成员变量和局部变量"></a>成员变量和局部变量</h3><ul>
<li><p>语法形式上：成员变量是属于类，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 public、private、static 等修饰符所修饰，而局部变量不能被访问控制修饰符及 static 所修饰；但是，成员变量和局部变量都能被 final 所修饰。</p>
</li>
<li><p>从变量在内存中的存储方式来看：如果成员变量是使用static修饰的，那么这个成员变量是属于类的，如果没有使用static修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。</p>
</li>
<li><p>从变量在内存中的生存时间上看：成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。</p>
</li>
<li><p>成员变量（全局变量）是可以不经初始化的（一种情况例外：被 final 修饰的成员变量必须显式地赋值），在类加载过程的准备阶段即可给它赋予默认值，但局部变量使用前需要显示赋予初始值，javac不是推断不出不可以这样做，而是没有这么做，对于成员变量而言，其赋值和取值访问的先后顺序具有不确定性，对于成员变量可以在一个方法调用前赋值，也可以在方法调用后进行，这是运行时发生的，编译器确定不了，交给jvm去做比较合适。而对于局部变量而言，其赋值和取值访问顺序是确定的。这样设计是一种约束，尽最大程度减少使用者犯错的可能。假使局部变量可以使用默认值，可能总会无意间忘记赋值，进而导致不可预期的情况出现。</p>
</li>
</ul>
<h3 id="面向对象的三大特征"><a href="#面向对象的三大特征" class="headerlink" title="面向对象的三大特征"></a>面向对象的三大特征</h3><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。就好像看不到挂在墙上的空调的内部的零件信息（也就是属性），但是可以通过遥控器（方法）来控制空调。如果属性不想被外界访问，大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。就好像如果没有空调遥控器，那么就无法操控空凋制冷，空调本身就没有意义了（当然现在还有很多其他方法 ，这里只是为了举例子）。</p>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>不同类型的对象，相互之间经常有一定数量的共同点。例如，小明同学、小红同学、小李同学，都共享学生的特性（班级、学号等）。同时，每一个对象还定义了额外的特性使得他们与众不同。例如小明的数学比较好，小红的性格惹人喜爱；小李的力气比较大。继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高开发效率。</p>
<p><strong>关于继承如下 3 点请记住：</strong></p>
<ul>
<li><p>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和私有方法子类是无法访问，只是拥有。</p>
</li>
<li><p>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</p>
</li>
<li><p>子类可以用自己的方式实现父类的方法。</p>
</li>
</ul>
<h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>多态，顾名思义，表示一个对象具有多种的状态。具体表现为父类的引用指向子类的实例。</p>
<p>多态分为编译时多态和运行时多态。其中编译时多态是静态的，主要是指方法的重载，它是根据参数列表的不同来区分不同的函数，通过编辑之后会变成两个不同的函数，在运行时谈不上多态。而运行时多态是动态的，它是通过动态绑定来实现的，也就是所说的多态性。</p>
<p><strong>多态的特点:</strong></p>
<ul>
<li>对象类型和引用类型之间具有继承（类）&#x2F;实现（接口）的关系；</li>
<li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；</li>
<li>多态不能调用“只在子类存在但在父类不存在”的方法；</li>
<li>如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。</li>
</ul>
<h3 id="在一个静态方法内调用一个非静态成员为什么是非法的"><a href="#在一个静态方法内调用一个非静态成员为什么是非法的" class="headerlink" title="在一个静态方法内调用一个非静态成员为什么是非法的"></a>在一个静态方法内调用一个非静态成员为什么是非法的</h3><p>类的静态成员（变量或方法）属于类本身，在类加载的时候就会分配内存，可以通过类名直接访问非静态成员（变量或方法）属于类的对象，只有在类的对象产生（实例化）时才会分配内存，然后通过类的对象（实例）去访问。<br>所以，如果一个类的静态方法去调用非静态方法或变量的时候，因为类的静态方法存在的时候，类的非静态成员可能不存在，访问一个内存中不存在的东西当然会出错。</p>
<h3 id="String-StringBuffer-和-StringBuilder"><a href="#String-StringBuffer-和-StringBuilder" class="headerlink" title="String StringBuffer 和 StringBuilder"></a>String StringBuffer 和 StringBuilder</h3><p>String s&#x3D;“This is only ”+”simple”+”test”会被JVM直接优化成String s&#x3D;“This is only simple test”。</p>
<p>简单的来说：String 类中使用 final 关键字修饰字符数组来保存字符串，private final char value[]，所以String 对象是不可变的。</p>
<blockquote>
<p>在 Java 9 之后，String 、StringBuilder 与 StringBuffer 的实现改用 byte 数组存储字符串。</p>
</blockquote>
<p>而 StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串char[] value 但是没有用 final 关键字修饰，所以这两种对象都是可变的。</p>
<p>StringBuilder 与 StringBuffer 的构造方法都是调用父类构造方法也就是AbstractStringBuilder 实现的。</p>
<p>String 中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。</p>
<p>每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p>
<p>对于三者使用的总结：</p>
<ul>
<li><p>操作少量的数据：适用 String；</p>
</li>
<li><p>单线程操作字符串缓冲区下操作大量数据：适用 StringBuilder；</p>
</li>
<li><p>多线程操作字符串缓冲区下操作大量数据：适用 StringBuffer。</p>
</li>
</ul>
<h3 id="Java序列化中如果有些字段不想进行序列化，怎么办"><a href="#Java序列化中如果有些字段不想进行序列化，怎么办" class="headerlink" title="Java序列化中如果有些字段不想进行序列化，怎么办?"></a>Java序列化中如果有些字段不想进行序列化，怎么办?</h3><p>对于不想序列话的变量，可以使用transient关键字修饰。</p>
<p>transient关键字的作用是：阻止实例中哪些用此关键字修饰的变量序列化；当对象被反序列化时，被transient修饰的变量值不会被持久化和恢复；transient只能修饰变量，不能修饰类和方法。</p>
<h3 id="获取键盘输入的常用方法"><a href="#获取键盘输入的常用方法" class="headerlink" title="获取键盘输入的常用方法"></a>获取键盘输入的常用方法</h3><p>方法一：通过scanner</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> input.nextLine();</span><br><span class="line">input.close();</span><br></pre></td></tr></table></figure>

<p>方法二：通过BufferedReader</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BufferedReader</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> input.readLine();</span><br></pre></td></tr></table></figure>

<h3 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h3><p>JAVA 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 java 语言的反射机制。</p>
<p>一个类在内存中只有一个class对象，一个类被加载后，类的整个结构都会封装在class对象中。</p>
<h3 id="静态编译和动态编译"><a href="#静态编译和动态编译" class="headerlink" title="静态编译和动态编译"></a>静态编译和动态编译</h3><p>在编译时确定对象，绑定对象;</p>
<p>运行时确定对象，绑定对象;</p>
<h3 id="反射机制优缺点"><a href="#反射机制优缺点" class="headerlink" title="反射机制优缺点"></a>反射机制优缺点</h3><p>优点：运行期类型的判断，动态加载类，提高代码灵活度。</p>
<p>缺点：</p>
<ul>
<li><p>性能瓶颈：反射相当于一系列解释操作，通知jvm要做的事情，性能比直接Java代码要慢很多。</p>
</li>
<li><p>安全问题：可以动态操作改变类属性的同时也增加了类的安全隐患。</p>
</li>
</ul>
<p>反射修改string值，因为final是编译期关键字，只在编译期进行检查。</p>
<h3 id="反射的应用场景"><a href="#反射的应用场景" class="headerlink" title="反射的应用场景"></a>反射的应用场景</h3><p>平时的项目开发过程中，基本上很少会直接使用到反射机制，但这不能说明反射机制没有用，实际上有很多设计、开发都与反射机制有关，例如模块化的开发，通过反射去调用对应的字节码；动态代理设计模式也采用了反射机制，还有日常使用的 Spring／Hibernate 等框架也大量使用到了反射机制。</p>
<p>举例：</p>
<ul>
<li><p>我们在使用 JDBC 连接数据库时使用 Class.forName()通过反射加载数据库的驱动程序；</p>
</li>
<li><p>Spring 框架的 IOC（动态加载管理 Bean）创建对象以及 AOP（动态代理）功能都和反射有联系；</p>
</li>
<li><p>动态配置实例的属性。</p>
</li>
</ul>
<h3 id="获取class对象的4种方式"><a href="#获取class对象的4种方式" class="headerlink" title="获取class对象的4种方式"></a>获取class对象的4种方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过此方法获取Class对象不会进行初始化</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">string</span> <span class="operator">=</span> String.class;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Class.forName(className)方法，内部实际调用的是一个native方法 forName0(className， true， ClassLoader.getClassLoader(caller)， caller);</span></span><br><span class="line"><span class="comment">//第2个boolean参数表示类是否需要初始化，Class.forName(className)默认是需要初始化。</span></span><br><span class="line"><span class="comment">//一旦初始化，就会触发目标对象的 static块代码执行，static参数也会被再次初始化。</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">alunbarClass1</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;cn.javaguide.TargetObject&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过对象获取</span></span><br><span class="line"><span class="type">Employee</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line"><span class="type">Class</span> <span class="variable">alunbarClass2</span> <span class="operator">=</span> e.getClass();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这种方式加载的不会初始化</span></span><br><span class="line"><span class="type">ClassLoader</span> <span class="variable">systemClassLoader</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader();</span><br><span class="line">Class&lt;?&gt; aClass1 = systemClassLoader.loadClass(<span class="string">&quot;java.lang.String&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本内置类型的包装类都有一个Type属性</span></span><br><span class="line">Class&lt;Integer&gt; type = Integer.TYPE;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得父类的class</span></span><br><span class="line">a.getSuperClass()</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848033.png" alt="img"></p>
<p>在 Java 中，所有的异常都有一个共同的祖先 java.lang 包中的 Throwable 类。Throwable 类有两个重要的子类 Exception（异常）和 Error（错误）。Exception 能被程序本身处理（try-catch）， Error 是无法处理的（只能尽量避免）。</p>
<ul>
<li>Exception：程序本身可以处理的异常，可以通过 catch 来进行捕获。Exception 又可以分为受检查异常（必须处理，不然编译会报错） 和不受检查异常（可以不处理）。</li>
<li>Error：Error 属于程序无法处理的错误 ，没办法通过 catch 来进行捕获 。例如，Java 虚拟机运行错误（Virtual MachineError）、虚拟机内存不够错误（OutOfMemoryError）、类定义错误（NoClassDefFoundError）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</li>
</ul>
<h4 id="受检异常"><a href="#受检异常" class="headerlink" title="受检异常"></a><strong>受检异常</strong></h4><p>除了RuntimeException及其子类以外，其他的Exception类及其子类都属于受检查异常 。常见的受检查异常有： IO 相关的异常、ClassNotFoundException 、SQLException…。</p>
<h4 id="不受检异常"><a href="#不受检异常" class="headerlink" title="不受检异常"></a><strong>不受检异常</strong></h4><p>Java代码在编译过程中，即使不处理不受检查异常也可以正常通过编译。</p>
<p>RuntimeException 及其子类都统称为非受检查异常，例如：NullPointerException、NumberFormatException（字符串转换为数字）、ArrayIndexOutOfBoundsException（数组越界）、ClassCastException（类型转换错误）、ArithmeticException（算术错误）等。</p>
<h4 id="Throwable类常用方法"><a href="#Throwable类常用方法" class="headerlink" title="Throwable类常用方法"></a>Throwable类常用方法</h4><ul>
<li>public string getMessage()：返回异常发生时的简要描述；</li>
<li>public string toString()：返回异常发生时的详细信息；</li>
<li>public string getLocalizedMessage()：返回异常对象的本地化信息。使用 Throwable 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 getMessage（）返回的结果相同；</li>
<li>public void printStackTrace()：在控制台上打印 Throwable 对象封装的异常信息。</li>
</ul>
<h4 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h4><ul>
<li>try块： 用于捕获异常。其后可接零个或多个 catch 块，如果没有 catch 块，则必须跟一个 finally 块。</li>
<li>catch块： 用于处理 try 捕获到的异常。</li>
<li>finally 块： 无论是否捕获或处理异常，finally 块里的语句都会被执行。当在 try 块或 catch块中遇到 return 语句时，finally 语句块将在方法返回之前被执行。</li>
</ul>
<p>在以下 3 种特殊情况下，finally块不会被执行：</p>
<ol>
<li>在 try 或 finally块中用了 System.exit(int)退出程序。但是，如果 System.exit(int) 在异常语句之后，finally 还是会被执行。</li>
<li>程序所在的线程死亡。</li>
<li>关闭 CPU。</li>
</ol>
<p><strong>注意：</strong> 当 try 语句和 finally 语句中都有 return 语句时，在方法返回之前，finally 语句的内容将被执行，并且 finally 语句的返回值将会覆盖原始的返回值。如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> value * value;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (value == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果调用 f(2)，返回值将是 0，finally 语句的返回值覆盖了 try 语句块的返回值。</p>
<h4 id="使用try-with-resources来代替try-catch-finally"><a href="#使用try-with-resources来代替try-catch-finally" class="headerlink" title="使用try-with-resources来代替try-catch-finally"></a>使用try-with-resources来代替try-catch-finally</h4><ul>
<li><p>适用范围（资源的定义）： 任何实现 java.lang.AutoCloseable或者 java.io.Closeable 的对象</p>
</li>
<li><p>关闭资源和 final 的执行顺序： 在 try-with-resources 语句中，任何 catch 或 finally 块在声明的资源关闭后运行</p>
</li>
</ul>
<p>《Effecitve Java》中明确指出：</p>
<blockquote>
<p>面对必须要关闭的资源，我们总是应该优先使用 try-with-resources 而不是try-finally。随之产生的代码更简短，更清晰，产生的异常对我们也更有用。try-with-resources语句让我们更容易编写必须要关闭的资源的代码，若采用try-finally则几乎做不到这点。</p>
</blockquote>
<p>当然多个资源需要关闭的时候，使用 try-with-resources 实现起来也非常简单，通过使用分号分隔，可以在try-with-resources块中声明多个资源。</p>
<h4 id="JVM-是如何处理异常的？"><a href="#JVM-是如何处理异常的？" class="headerlink" title="JVM 是如何处理异常的？"></a>JVM 是如何处理异常的？</h4><p>在一个方法中如果发生异常，这个方法会创建一个异常对象，并转交给 JVM， 该异常对象包含异常名称，异常描述以及异常发生时应用程序的状态。创建异常对象并转交给 JVM 的过程称为抛出异常。可能有一系列的方法调用，终才进入抛出异常的方法，这一系列方法调用的有序列表叫做调用栈。</p>
<p>JVM 会顺着调用栈去查找看是否有可以处理异常的代码，如果有，则调用异常处理代码。当 JVM 发现可以处理异常的代码时，会把发生的异常传递给它。如果 JVM 没有找到可以处理该异常的代码块，JVM 就会将该异常转交给默认的异常处理器（默认处理器为 JVM 的一部分），默认异常处理器打印出异常信息并终止应用程序。 </p>
<h4 id="throw-和-throws"><a href="#throw-和-throws" class="headerlink" title="throw 和 throws"></a>throw 和 throws</h4><ul>
<li>throw 关键字用在方法内部，只能用于抛出一种异常，用来抛出方法或代码块中的异常，受查异常和非受查异常都可以被抛出。 </li>
<li>throws 关键字用在方法声明上，可以抛出多个异常，用来标识该方法可能抛出的异常列表。一个方法用 throws 标识了可能抛出的异常列表，调用该方法的方法中必须包含可处理异常的代码，否则也要在方法签名中用 throws 关键字声明相应的异常。</li>
</ul>
<h4 id="final、finally、finalize-有什么区别？"><a href="#final、finally、finalize-有什么区别？" class="headerlink" title="final、finally、finalize 有什么区别？"></a>final、finally、finalize 有什么区别？</h4><ul>
<li>final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值。 </li>
<li>finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块中，表示不管是否出现异常，该代码块都会执行，一般用 来存放一些关闭资源的代码。 </li>
<li>finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类， Java 中允许使用 finalize()方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。 可以手动调用，但是在对象被销毁时，还是会被调用。</li>
</ul>
<h4 id="NoClassDefFoundError-和-ClassNotFoundException"><a href="#NoClassDefFoundError-和-ClassNotFoundException" class="headerlink" title="NoClassDefFoundError 和  ClassNotFoundException"></a>NoClassDefFoundError 和  ClassNotFoundException</h4><ul>
<li>NoClassDefFoundError 是一个 Error 类型的异常，是由 JVM 引起的，不应该尝试捕获这个异常。 引起该异常的原因是 JVM 或 ClassLoader 尝试加载某类时在内存中找不到该类的定义，该动作发生在运行期间，即编译时该类存在，但是在运行时却找不到 了，可能是变异后被删除了等原因；</li>
<li>ClassNotFoundException是一个受查异常，需要显式地使用 try-catch 对其进行捕获和处理，或在方法签名中用 throws 关键字进行声明。当使用  Class.forName， ClassLoader.loadClass 或 ClassLoader.findSystemClass 动态加载类到内存的时候，通过传入的类路径参数没有找到该类，就会抛出该异常；另一种抛出该异常的可能原因是某个类已经由一个类加载器加载至内存中，另一个加载器又尝试去加载它。</li>
</ul>
<h4 id="try-catch-finally-1"><a href="#try-catch-finally-1" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h4><p>try只适合处理运行时异常，try+catch适合处理运行时异常+普通异常。如果你只用try去处理普通异常却不加以catch处理，编译是通不过的，因为编译器硬性规定，普通异常如果选择捕获，则必须用 catch显示声明以便进一步处理。而运行时异常在编译时没有如此规定，所以 catch可以省略，你加上catch编译器也觉得无可厚非。 </p>
<p>理论上，编译器看任何代码都不顺眼，都觉得可能有潜在的问题，所以你即使对所有代码加上try，代码在运行期时也只不过是在正常运行的基础上加一层皮。 但是你一旦对一段代码加上try，就等于显示地承诺编译器，对这段代码可能抛出的异常进行捕获而非向上抛出处理。如果是普通异常，编译器要求必须用 catch捕获以便进一步处理；如果运行时异常，捕获然后丢弃并且+finally扫尾处理，或者加上catch捕获以便进一步处理。 </p>
<p>至于加上finally，则是在不管有没捕获异常，都要进行的“扫尾”处理。  </p>
<h4 id="try-catch-finally-中，如果-catch-中-return-了，-finally-还会执行吗？"><a href="#try-catch-finally-中，如果-catch-中-return-了，-finally-还会执行吗？" class="headerlink" title="try-catch-finally 中，如果 catch 中 return 了， finally 还会执行吗？"></a>try-catch-finally 中，如果 catch 中 return 了， finally 还会执行吗？</h4><p>会执行，在 return 前执行。 </p>
<p><strong>注意：</strong>在 finally 中改变返回值的做法是不好的，因为如果存在 finally 代码块， try中的 return 语句不会立马返回调用者，而是记录下返回值待 finally 代码块执行完毕之后再向调用者返回其值，然后如果在 finally 中修改了返回值，就会返回修改后的值。显然，在 finally 中返回或者修改返回值会对程序造成很大的困扰，C#中直接用编译错误的方式来阻止，Java 中也可以通过提升编译器的语法检查级别来产生警告或错误。 </p>
<p><strong>示例：</strong> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 2</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getInt</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 30</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getInt1</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          System.out.println(a / <span class="number">0</span>);</span><br><span class="line">          a = <span class="number">20</span>;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">          a = <span class="number">30</span>;</span><br><span class="line">          <span class="keyword">return</span> a;</span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">           * return a 在程序执行到这一步的时候，这里不是return a 而是 return 30；这个返回路径就形成了</span></span><br><span class="line"><span class="comment">           * 但是呢，它发现后面还有finally，所以继续执行finally的内容，a=40</span></span><br><span class="line"><span class="comment">           * 再次回到以前的路径，继续走return 30，形成返回路径之后，这里的a就不是a变量了，而是常量30</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          a = <span class="number">40</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 40</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getInt2</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          System.out.println(a / <span class="number">0</span>);</span><br><span class="line">          a = <span class="number">20</span>;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">          a = <span class="number">30</span>;</span><br><span class="line">          <span class="keyword">return</span> a;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          a = <span class="number">40</span>;</span><br><span class="line">          <span class="keyword">return</span> a;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="类-ExampleA-继承-Exception，类-ExampleB-继承-ExampleA。"><a href="#类-ExampleA-继承-Exception，类-ExampleB-继承-ExampleA。" class="headerlink" title="类 ExampleA 继承 Exception，类 ExampleB 继承 ExampleA。"></a>类 ExampleA 继承 Exception，类 ExampleB 继承 ExampleA。</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExampleB</span>(<span class="string">&quot;b&quot;</span>) </span><br><span class="line"> &#125; <span class="keyword">catch</span>（ExampleA e）&#123; </span><br><span class="line">  System.out.println(<span class="string">&quot;ExampleA&quot;</span>); </span><br><span class="line"> &#125; <span class="keyword">catch</span>（Exception e）&#123; </span><br><span class="line">  System.out.println(<span class="string">&quot;Exception&quot;</span>); </span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// ExampleA</span></span><br><span class="line"><span class="comment">// 根据里氏代换原则[能使用父类型的地方一定能使用子类型]，抓取 ExampleA 类型异常的 catch块能够抓住 try 块中抛出的 ExampleB  类型的异常</span></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Human</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Sneeze</span>();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Annoyance e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Caught Annoyance&quot;</span>);</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Sneeze sneeze) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Caught Sneeze&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Annoyance</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sneeze</span> <span class="keyword">extends</span> <span class="title class_">Annoyance</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> <strong>结果:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Caught Annoyance </span><br><span class="line">Caught Sneeze </span><br><span class="line">Hello World! </span><br></pre></td></tr></table></figure>

<h4 id="Java常见异常"><a href="#Java常见异常" class="headerlink" title="Java常见异常"></a>Java常见异常</h4><p>java.lang.IllegalAccessError：违法访问错误。当一个应用试图访问、修改某个类的域（Field）或者调用其方法，但是又违反域或方法的可见性声明，则抛出该异常。</p>
<p>java.lang.InstantiationError：实例化错误。当一个应用试图通过Java的new操作符构造一个抽象类或者接口时抛出该异常.</p>
<p>java.lang.OutOfMemoryError：内存不足错误。当可用内存不足以让Java虚拟机分配给一个对象时抛出该错误。</p>
<p>java.lang.StackOverflowError：堆栈溢出错误。当一个应用递归调用的层次太深而导致堆栈溢出或者陷入死循环时抛出该错误。</p>
<p>java.lang.ClassCastException：类造型异常。假设有类A和B（A不是B的父类或子类），O是A的实例，那么当强制将O构造为类B的实例时抛出该异常。该异常经常被称为强制类型转换异常。</p>
<p>java.lang.ClassNotFoundException：找不到类异常。当应用试图根据字符串形式的类名构造类，而在遍历CLASSPAH之后找不到对应名称的class文件时，抛出该异常。 java.lang.ArithmeticException：算术条件异常。譬如：整数除零等。</p>
<p>java.lang.ArrayIndexOutOfBoundsException：数组索引越界异常。当对数组的索引值为负数或大于等于数组大小时抛出。</p>
<p>java.lang.IndexOutOfBoundsException：索引越界异常。当访问某个序列的索引值小于0或大于等于序列大小时，抛出该异常。 java.lang.InstantiationException：实例化异常。当试图通过newInstance()方法创建某个类的实例，而该类是一个抽象类或接口时，抛出该异常。</p>
<p>java.lang.NoSuchFieldException：属性不存在异常。当访问某个类的不存在的属性时抛出该异常。</p>
<p>java.lang.NoSuchMethodException：方法不存在异常。当访问某个类的不存在的方法时抛出该异常。</p>
<p>java.lang.NullPointerException：空指针异常。当应用试图在要求使用对象的地方使用了null时，抛出该异常。譬如：调用null对象的实例方法、访问null对象的属性、计算null对象的长度、使用throw语句抛出null等等。</p>
<p>java.lang.NumberFormatException：数字格式异常。当试图将一个String转换为指定的数字类型，而该字符串确不满足数字类型要求的格式时，抛出该异常。</p>
<p>java.lang.StringIndexOutOfBoundsException：字符串索引越界异常。当使用索引值访问某个字符串中的字符，而该索引值小于0或大于等于序列大小时，抛出该异常</p>
<h3 id="既然有了字节流，为什么还要有字符流"><a href="#既然有了字节流，为什么还要有字符流" class="headerlink" title="既然有了字节流，为什么还要有字符流?"></a>既然有了字节流，为什么还要有字符流?</h3><p>Java中一切都是字节流，没有字符流，字符只是根据编码对字节流进行翻译的结果。字符流是由 Java 虚拟机将字节转换得到的，问题就出在这个过程还算是非常耗时，并且，如果我们不知道编码类型就很容易出现乱码问题。所以， I&#x2F;O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。</p>
<h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>静态代理中，对目标对象的每个方法的增强都是手动完成的，非常不灵活（比如接口一旦新增加方法，目标对象和代理对象都要进行修改）且麻烦（需要对每个目标类都单独写一个代理类）。 实际应用场景非常非常少，日常开发几乎看不到使用静态代理的场景。</p>
<p>上面是从实现和应用角度来说的静态代理，从 JVM 层面来说， 静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。</p>
<p><strong>1.定义发送短信的接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SmsService</span> &#123;</span><br><span class="line">    String <span class="title function_">send</span><span class="params">(String message)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.实现发送短信的接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmsServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">SmsService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">send</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;send message:&quot;</span> + message);</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.创建代理类并同样实现发送短信的接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmsProxy</span> <span class="keyword">implements</span> <span class="title class_">SmsService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SmsService smsService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SmsProxy</span><span class="params">(SmsService smsService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.smsService = smsService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">send</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="comment">//调用方法之前，我们可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;before method send()&quot;</span>);</span><br><span class="line">        smsService.send(message);</span><br><span class="line">        <span class="comment">//调用方法之后，我们同样可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;after method send()&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4.实际使用</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SmsService</span> <span class="variable">smsService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SmsServiceImpl</span>();</span><br><span class="line">        <span class="type">SmsProxy</span> <span class="variable">smsProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SmsProxy</span>(smsService);</span><br><span class="line">        smsProxy.send(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行上述代码之后，控制台打印出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">before method send()</span><br><span class="line">send message:java</span><br><span class="line">after method send()</span><br></pre></td></tr></table></figure>

<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>相比于静态代理来说，动态代理更加灵活。不需要针对每个目标类都单独创建一个代理类，并且也不需要必须实现接口，可以直接代理实现类（CGLIB 动态代理机制）。</p>
<p><strong>从 JVM 角度来说，动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。</strong></p>
<p>Spring AOP、RPC 框架实现都依赖了动态代理。</p>
<p><strong>动态代理在日常开发中使用的相对较小，但是在框架中的几乎是必用的一门技术。</strong></p>
<p>就 Java 来说，动态代理的实现方式有<strong>JDK 动态代理</strong>、<strong>CGLIB 动态代理</strong>等。</p>
<h3 id="JDK动态代理机制"><a href="#JDK动态代理机制" class="headerlink" title="JDK动态代理机制"></a>JDK动态代理机制</h3><ol>
<li>定义一个接口及其实现类；</li>
<li>自定义 InvocationHandler 并重写invoke方法，在 invoke 方法中会调用原生方法（被代理类的方法）并自定义一些处理逻辑；</li>
<li>通过 Proxy.newProxyInstance(ClassLoader loader，Class&lt;?&gt;[] interfaces，InvocationHandler h) 方法创建代理对象；</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义发送短信的接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SmsService</span> &#123;</span><br><span class="line">    String <span class="title function_">send</span><span class="params">(String message)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现发送短信的接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmsServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">SmsService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">send</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;send message:&quot;</span> + message);</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义一个JDK动态代理类</span></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DebugInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代理类中的真实对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DebugInvocationHandler</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//invoke() 方法: 当我们的动态代理对象调用原生方法的时候，最终实际上调用到的是 invoke() 方法，然后 invoke() 方法代替我们去调用了被代理对象的原生方法。</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy， Method method， Object[] args)</span> <span class="keyword">throws</span> InvocationTargetException， IllegalAccessException &#123;</span><br><span class="line">        <span class="comment">//调用方法之前，我们可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;before method &quot;</span> + method.getName());</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target， args);</span><br><span class="line">        <span class="comment">//调用方法之后，我们同样可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;after method &quot;</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取代理对象的工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdkProxyFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getProxy</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">                target.getClass().getClassLoader()， <span class="comment">// 目标类的类加载</span></span><br><span class="line">                target.getClass().getInterfaces()，  <span class="comment">// 代理需要实现的接口，可指定多个</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">DebugInvocationHandler</span>(target)   <span class="comment">// 代理对象对应的自定义 InvocationHandler</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际使用</span></span><br><span class="line"><span class="type">SmsService</span> <span class="variable">smsService</span> <span class="operator">=</span> (SmsService) JdkProxyFactory.getProxy(<span class="keyword">new</span> <span class="title class_">SmsServiceImpl</span>());</span><br><span class="line">smsService.send(<span class="string">&quot;java&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="CGLIB动态代理机制"><a href="#CGLIB动态代理机制" class="headerlink" title="CGLIB动态代理机制"></a>CGLIB动态代理机制</h3><p>JDK动态代理有一个最致命的问题是其只能代理实现了接口的类。可以使用CGLIB动态代理机制来避免。</p>
<p>CGLIB（Code Generation Library）是一个基于ASM的字节码生成库，它允许在运行时对字节码进行修改和动态生成。CGLIB 通过继承方式实现代理。很多知名的开源框架都使用到了CGLIB， 例如 Spring 中的 AOP 模块中：如果目标对象实现了接口，则默认采用 JDK 动态代理，否则采用 CGLIB 动态代理。</p>
<p>在 CGLIB 动态代理机制中 MethodInterceptor 接口和 Enhancer 类是核心。</p>
<p>需要自定义 MethodInterceptor 并重写 intercept 方法，intercept 用于拦截增强被代理类的方法。</p>
<ol>
<li>定义一个类；</li>
<li>自定义 MethodInterceptor 并重写 intercept 方法，intercept 用于拦截增强被代理类的方法，和 JDK 动态代理中的 invoke 方法类似；</li>
<li>通过 Enhancer 类的 create()创建代理类。</li>
</ol>
<p>不同于 JDK 动态代理不需要额外的依赖。CGLIB（Code Generation Library）实际是属于一个开源项目，如果要使用话，需要手动添加相关依赖。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>1.实现一个使用阿里云发送短信的类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> github.javaguide.dynamicProxy.cglibDynamicProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AliSmsService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">send</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;send message:&quot;</span> + message);</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.自定义 MethodInterceptor（方法拦截器）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义MethodInterceptor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DebugMethodInterceptor</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o           被代理的对象（需要增强的对象）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method      被拦截的方法（需要增强的方法）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args        方法入参</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodProxy 用于调用原始方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object o， Method method， Object[] args， MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">//调用方法之前，我们可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;before method &quot;</span> + method.getName());</span><br><span class="line">        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> methodProxy.invokeSuper(o， args);</span><br><span class="line">        <span class="comment">//调用方法之后，我们同样可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;after method &quot;</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.获取代理类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CglibProxyFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getProxy</span><span class="params">(Class&lt;?&gt; clazz)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建动态代理增强类</span></span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        <span class="comment">// 设置类加载器</span></span><br><span class="line">        enhancer.setClassLoader(clazz.getClassLoader());</span><br><span class="line">        <span class="comment">// 设置被代理类</span></span><br><span class="line">        enhancer.setSuperclass(clazz);</span><br><span class="line">        <span class="comment">// 设置方法拦截器</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> <span class="title class_">DebugMethodInterceptor</span>());</span><br><span class="line">        <span class="comment">// 创建代理类</span></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4.实际使用</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AliSmsService</span> <span class="variable">aliSmsService</span> <span class="operator">=</span> (AliSmsService) CglibProxyFactory.getProxy(AliSmsService.class);</span><br><span class="line">aliSmsService.send(<span class="string">&quot;java&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="JDK动态代理和CGLIB动态代理对比"><a href="#JDK动态代理和CGLIB动态代理对比" class="headerlink" title="JDK动态代理和CGLIB动态代理对比"></a>JDK动态代理和CGLIB动态代理对比</h3><ul>
<li><p><strong>JDK 动态代理只能只能代理实现了接口的类或者直接代理接口，而 CGLIB 可以代理未实现任何接口的类。</strong> 另外， CGLIB 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理声明为 final 类型的类和方法。</p>
</li>
<li><p>就二者的效率来说，大部分情况都是 JDK 动态代理更优秀，随着 JDK 版本的升级，这个优势更加明显。</p>
</li>
</ul>
<h3 id="动态代理和静态代理的对比"><a href="#动态代理和静态代理的对比" class="headerlink" title="动态代理和静态代理的对比"></a>动态代理和静态代理的对比</h3><ul>
<li><p><strong>灵活性</strong>：动态代理更加灵活，不需要必须实现接口，可以直接代理实现类，并且可以不需要针对每个目标类都创建一个代理类。另外，静态代理中，接口一旦新增加方法，目标对象和代理对象都要进行修改，这是非常麻烦的。</p>
</li>
<li><p><strong>JVM 层面</strong>：静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。而动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。</p>
</li>
</ul>
<h2 id="整型包装类"><a href="#整型包装类" class="headerlink" title="整型包装类"></a>整型包装类</h2><ul>
<li><p>所有整型包装类对象值的比较必须使用equals方法。</p>
</li>
<li><p>所有的 POJO 类属性必须使用包装数据类型。</p>
</li>
<li><p>RPC 方法的返回值和参数必须使用包装数据类型。</p>
</li>
<li><p>所有的局部变量使用基本数据类型。</p>
</li>
</ul>
<p>例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">System.out.println(x == y);<span class="comment">// true</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">3</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">3</span>);</span><br><span class="line">System.out.println(a == b);<span class="comment">//false</span></span><br><span class="line">System.out.println(a.equals(b));<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>当使用自动装箱方式创建一个Integer对象时，当数值在-128 ~127时，会将创建的 Integer 对象缓存起来，当下次再出现该数值时，直接从缓存中取出对应的Integer对象。所以上述代码中，x和y引用的是相同的Integer对象。 </p>
<p><strong>注意：</strong> 如果你的IDE（IDEA&#x2F;Eclipse）上安装了阿里巴巴的p3c插件，这个插件如果检测到你用 &#x3D;&#x3D; 的话会报错提示。</p>
<h2 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h2><p>在使用BigDecimal时，为了防止精度丢失，推荐使用它的 <strong>BigDecimal(String)</strong> 构造方法来创建对象。</p>
<p>BigDecimal 主要用来操作（大）浮点数，BigInteger 主要用来操作大整数（超过 long 类型）。</p>
<p>BigDecimal 的实现利用到了 BigInteger， 所不同的是 BigDecimal 加入了小数位的概念</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1.0f</span> - <span class="number">0.9f</span>;</span><br><span class="line"><span class="type">float</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0.9f</span> - <span class="number">0.8f</span>;</span><br><span class="line">System.out.println(a);<span class="comment">// 0.100000024</span></span><br><span class="line">System.out.println(b);<span class="comment">// 0.099999964</span></span><br><span class="line">System.out.println(a == b);<span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.0&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.9&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.8&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">x</span> <span class="operator">=</span> a.subtract(b); </span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">y</span> <span class="operator">=</span> b.subtract(c); </span><br><span class="line">System.out.println(x); <span class="comment">/* 0.1 */</span></span><br><span class="line">System.out.println(y); <span class="comment">/* 0.1 */</span></span><br><span class="line">System.out.println(Objects.equals(x， y)); <span class="comment">/* true */</span></span><br><span class="line"></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.0&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.9&quot;</span>);</span><br><span class="line">System.out.println(a.compareTo(b));<span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.255433&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">n</span> <span class="operator">=</span> m.setScale(<span class="number">3</span>，BigDecimal.ROUND_HALF_DOWN);</span><br><span class="line">System.out.println(n);<span class="comment">// 1.2551</span></span><br></pre></td></tr></table></figure>

<h2 id="Arrays-asList"><a href="#Arrays-asList" class="headerlink" title="Arrays.asList()"></a>Arrays.asList()</h2><p>Arrays.asList()将数组转换为集合后，底层其实还是数组。</p>
<p>Arrays.asList()是泛型方法，传入的对象必须是对象数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] myArray = &#123;<span class="number">1</span>， <span class="number">2</span>， <span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">List</span> <span class="variable">myList</span> <span class="operator">=</span> Arrays.asList(myArray);</span><br><span class="line">System.out.println(myList.size());<span class="comment">//1</span></span><br><span class="line">System.out.println(myList.get(<span class="number">0</span>));<span class="comment">//数组地址值</span></span><br><span class="line">System.out.println(myList.get(<span class="number">1</span>));<span class="comment">//报错：ArrayIndexOutOfBoundsException</span></span><br><span class="line"><span class="type">int</span>[] array = (<span class="type">int</span>[]) myList.get(<span class="number">0</span>);</span><br><span class="line">System.out.println(array[<span class="number">0</span>]);<span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<p>当传入一个原生数据类型数组时，<code>Arrays.asList()</code> 的真正得到的参数就不是数组中的元素，而是数组对象本身，此时List 的唯一元素就是这个数组，这也就解释了上面的代码。</p>
<p>使用包装类型数组就可以解决这个问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer[] myArray = &#123;<span class="number">1</span>， <span class="number">2</span>， <span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>使用集合的修改方法:add()、remove()、clear()会抛出异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">myList</span> <span class="operator">=</span> Arrays.asList(<span class="number">1</span>， <span class="number">2</span>， <span class="number">3</span>);</span><br><span class="line">myList.add(<span class="number">4</span>);<span class="comment">//运行时报错：UnsupportedOperationException</span></span><br><span class="line">myList.remove(<span class="number">1</span>);<span class="comment">//运行时报错：UnsupportedOperationException</span></span><br><span class="line">myList.clear();<span class="comment">//运行时报错：UnsupportedOperationException</span></span><br></pre></td></tr></table></figure>

<p>Arrays.asList() 方法返回的并不是 java.util.ArrayList ，而是 java.util.Arrays 的一个内部类，这个内部类并没有实现集合的修改方法或者说并没有重写这些方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">myList</span> <span class="operator">=</span> Arrays.asList(<span class="number">1</span>， <span class="number">2</span>， <span class="number">3</span>);</span><br><span class="line">System.out.println(myList.getClass());<span class="comment">//class java.util.Arrays$ArrayList</span></span><br></pre></td></tr></table></figure>

<p>java.util.Arrays$ArrayList的简易源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">      <span class="keyword">implements</span> <span class="title class_">RandomAccess</span>， java.io.Serializable</span><br><span class="line">  &#123;</span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index， E element)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">         ...</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> E&gt; action)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">replaceAll</span><span class="params">(UnaryOperator&lt;E&gt; operator)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> E&gt; c)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>再看一下java.util.AbstractList的remove()方法，这样就明白为啥会抛出UnsupportedOperationException。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="如何正确的将数组转换为ArrayList"><a href="#如何正确的将数组转换为ArrayList" class="headerlink" title="如何正确的将数组转换为ArrayList?"></a>如何正确的将数组转换为ArrayList?</h3><p><strong>1.自己动手实现</strong></p>
<p><strong>2.最简便的方法(推荐)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="string">&quot;a&quot;</span>， <span class="string">&quot;b&quot;</span>，<span class="string">&quot;c&quot;</span>));</span><br></pre></td></tr></table></figure>

<p><strong>3. 使用 Java8 的Stream(推荐)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Integer [] myArray = &#123; <span class="number">1</span>， <span class="number">2</span>， <span class="number">3</span> &#125;;</span><br><span class="line"><span class="type">List</span> <span class="variable">myList</span> <span class="operator">=</span> Arrays.stream(myArray).collect(Collectors.toList());</span><br><span class="line"><span class="comment">//基本类型也可以实现转换（依赖boxed的装箱操作）</span></span><br><span class="line"><span class="type">int</span> [] myArray2 = &#123; <span class="number">1</span>， <span class="number">2</span>， <span class="number">3</span> &#125;;</span><br><span class="line"><span class="type">List</span> <span class="variable">myList</span> <span class="operator">=</span> Arrays.stream(myArray2).boxed().collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p><strong>4. 使用 Guava(推荐)</strong></p>
<p>对于不可变集合，你可以使用ImmutableList类及其of()与copyOf()工厂方法：（参数不能为空）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; il = ImmutableList.of(<span class="string">&quot;string&quot;</span>， <span class="string">&quot;elements&quot;</span>);  <span class="comment">// from varargs</span></span><br><span class="line">List&lt;String&gt; il = ImmutableList.copyOf(aStringArray);      <span class="comment">// from array</span></span><br></pre></td></tr></table></figure>

<p>对于可变集合，你可以使用Lists类及其newArrayList()工厂方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; l1 = Lists.newArrayList(anotherListOrCollection);    <span class="comment">// from collection</span></span><br><span class="line">List&lt;String&gt; l2 = Lists.newArrayList(aStringArray);               <span class="comment">// from array</span></span><br><span class="line">List&lt;String&gt; l3 = Lists.newArrayList(<span class="string">&quot;or&quot;</span>， <span class="string">&quot;string&quot;</span>， <span class="string">&quot;elements&quot;</span>); <span class="comment">// from varargs</span></span><br></pre></td></tr></table></figure>

<p><strong>5. 使用 Apache Commons Collections</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">CollectionUtils.addAll(list， str);</span><br></pre></td></tr></table></figure>

<p><strong>6. 使用 Java9 的 <code>List.of()</code>方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer[] array = &#123;<span class="number">1</span>， <span class="number">2</span>， <span class="number">3</span>&#125;;</span><br><span class="line">List&lt;Integer&gt; list = List.of(array);</span><br><span class="line">System.out.println(list); <span class="comment">/* [1， 2， 3] */</span></span><br><span class="line"><span class="comment">/* 不支持基本数据类型 */</span></span><br></pre></td></tr></table></figure>

<h3 id="Collection-toArray-方法使用的坑-amp-如何反转数组"><a href="#Collection-toArray-方法使用的坑-amp-如何反转数组" class="headerlink" title="Collection.toArray()方法使用的坑&amp;如何反转数组"></a>Collection.toArray()方法使用的坑&amp;如何反转数组</h3><p>该方法是一个泛型方法：<code>&lt;T&gt; T[] toArray(T[] a);</code> 如果<code>toArray</code>方法中没有传递任何参数的话返回的是<code>Object</code>类型数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String [] s= <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;</span><br><span class="line">    <span class="string">&quot;dog&quot;</span>， <span class="string">&quot;lazy&quot;</span>， <span class="string">&quot;a&quot;</span>， <span class="string">&quot;over&quot;</span>， <span class="string">&quot;jumps&quot;</span>， <span class="string">&quot;fox&quot;</span>， <span class="string">&quot;brown&quot;</span>， <span class="string">&quot;quick&quot;</span>， <span class="string">&quot;A&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line">List&lt;String&gt; list = Arrays.asList(s);</span><br><span class="line">Collections.reverse(list);</span><br><span class="line">s=list.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>]);<span class="comment">//没有指定类型的话会报错</span></span><br></pre></td></tr></table></figure>

<p>由于JVM优化，<code>new String[0]</code>作为<code>Collection.toArray()</code>方法的参数现在使用更好，<code>new String[0]</code>就是起一个模板的作用，指定了返回数组的类型，0是为了节省空间，因为它只是为了说明返回的类型。详见：<a target="_blank" rel="noopener" href="https://shipilev.net/blog/2016/arrays-wisdom-ancients/">https://shipilev.net/blog/2016/arrays-wisdom-ancients/</a></p>
<h3 id="不要在-foreach-循环里进行元素的-remove-x2F-add-操作"><a href="#不要在-foreach-循环里进行元素的-remove-x2F-add-操作" class="headerlink" title="不要在 foreach 循环里进行元素的 remove&#x2F;add 操作"></a>不要在 foreach 循环里进行元素的 remove&#x2F;add 操作</h3><p>如果要进行remove操作，可以调用迭代器的 remove方法而不是集合类的 remove 方法。因为如果列表在任何时间从结构上修改创建迭代器之后，以任何方式除非通过迭代器自身remove&#x2F;add方法，迭代器都将抛出一个ConcurrentModificationException，这就是单线程状态下产生的 fail-fast 机制。</p>
<blockquote>
<p>fail-fast 机制：多个线程对 fail-fast 集合进行修改的时，可能会抛出ConcurrentModificationException，单线程下也会出现这种情况，上面已经提到过。</p>
</blockquote>
<p>Java8开始，可以使用Collection#removeIf()方法删除满足特定条件的元素，如 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; ++i) &#123;</span><br><span class="line">    list.add(i);</span><br><span class="line">&#125;</span><br><span class="line">list.removeIf(filter -&gt; filter % <span class="number">2</span> == <span class="number">0</span>); <span class="comment">/* 删除list中的所有偶数 */</span></span><br><span class="line">System.out.println(list); <span class="comment">/* [1， 3， 5， 7， 9] */</span></span><br></pre></td></tr></table></figure>

<p><code>java.util</code>包下面的所有的集合类都是fail-fast的，而<code>java.util.concurrent</code>包下面的所有的类都是fail-safe的。</p>
<h2 id="final，static，this，super关键字"><a href="#final，static，this，super关键字" class="headerlink" title="final，static，this，super关键字"></a>final，static，this，super关键字</h2><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><ol>
<li>静态内部类（static修饰类的话只能修饰内部类）： 静态内部类与非静态内部类之间存在一个最大的区别: 非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用就意味着：1. 它的创建是不需要依赖外围类的创建。2. 它不能使用任何外围类的非static成员变量和方法。</li>
<li>静态导包（用来导入类中的静态资源，1.5之后的新特性）：格式为：import static 这两个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法。</li>
</ol>
<h3 id="this和super的区别"><a href="#this和super的区别" class="headerlink" title="this和super的区别"></a>this和super的区别</h3><ul>
<li>不可以在static环境中用；</li>
<li>this是一个指向本对象的指针；</li>
<li>super是一个java关键字都需要放到方法的第一行；</li>
<li>this和super不能同时出现在一个构造函数里面，因为this必然会调用其他的构造函数，其他的构造函数必然会有super语句的存在。</li>
</ul>
<h3 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h3><p>定义在类中方法外，静态代码块在非静态代码块之前执行（静态代码块 - 非静态代码块 - 构造方法）。 该类不管创建多少对象，静态代码块只执行一次。一个类中可以有多个静态代码块，位置可以随便放，它不在任何的方法体内，JVM加载类时会执行这些静态代码块，如果静态代码块有多个，JVM将按它们的先后顺序执行，每个代码块只会执行一次。</p>
<p><strong>静态代码块对于定义在它之后的静态变量，可以赋值，但不能访问.</strong></p>
<p>静态代码块可能在第一次new的时候执行，但不一定只在第一次new的时候执行。比如通过 <code>Class.forName(&quot;ClassDemo&quot;)</code>创建 Class 对象的时候也会执行。</p>
<p>非静态代码块在每new一次就执行一次。 非静态代码块可在普通方法中定义（不过作用不大）；而静态代码块不行。</p>
<p>一般情况下，如果有些代码比如一些项目最常用的变量或对象必须在项目启动的时候就执行的时候，需要使用静态代码块，这种代码是主动执行的。如果想要设计不需要创建对象就可以调用类中的方法，例如：Arrays类，Character类，String类等，就需要使用静态方法， 两者的区别是静态代码块是自动执行的而静态方法是被调用的时候才执行的。</p>
<h2 id="Java内存泄漏"><a href="#Java内存泄漏" class="headerlink" title="Java内存泄漏"></a>Java内存泄漏</h2><p>长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，例如threadLocal，这就是Java中内存泄露的发生场景。</p>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>Reference：<a target="_blank" rel="noopener" href="https://www.baeldung.com/a-guide-to-java-enums">https://www.baeldung.com/a-guide-to-java-enums</a> </p>
<p><strong>以这种方式定义的常量使代码更具可读性，允许进行编译时检查，预先记录可接受值的列表，并避免由于传入无效值而引起的意外行为。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> shuang.kou.enumdemo.enumtest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">PizzaStatus</span> &#123;</span><br><span class="line">    ORDERED，</span><br><span class="line">    READY， </span><br><span class="line">    DELIVERED; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 简单来说，通过上面的代码避免了定义常量，将所有和 pizza 订单的状态的常量都统一放到了一个枚举类型里面。</span></span><br><span class="line">System.out.println(PizzaStatus.ORDERED.name());<span class="comment">//ORDERED</span></span><br><span class="line">System.out.println(PizzaStatus.ORDERED);<span class="comment">//ORDERED</span></span><br><span class="line">System.out.println(PizzaStatus.ORDERED.name().getClass());<span class="comment">//class java.lang.String</span></span><br><span class="line">System.out.println(PizzaStatus.ORDERED.getClass());<span class="comment">//class shuang.kou.enumdemo.enumtest.PizzaStatus</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="自定义枚举方法"><a href="#自定义枚举方法" class="headerlink" title="自定义枚举方法"></a>自定义枚举方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pizza</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> PizzaStatus status;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">PizzaStatus</span> &#123;</span><br><span class="line">        ORDERED，</span><br><span class="line">        READY，</span><br><span class="line">        DELIVERED;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isDeliverable</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getStatus() == PizzaStatus.READY;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// Methods that set and get the status variable.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用-x3D-x3D-比较枚举类型"><a href="#使用-x3D-x3D-比较枚举类型" class="headerlink" title="使用&#x3D;&#x3D;比较枚举类型"></a>使用&#x3D;&#x3D;比较枚举类型</h3><p>由于枚举类型确保JVM中仅存在一个常量实例，因此可以安全地使用 <code>==</code> 运算符比较两个变量，如上例所示；此外，<code>==</code> 运算符可提供编译时和运行时的安全性。</p>
<p>如果两个值均为null 都不会引发 NullPointerException。相反，如果使用equals方法，将抛出 NullPointerException：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Pizza.<span class="type">PizzaStatus</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">System.out.println(pizza.equals(Pizza.PizzaStatus.DELIVERED));<span class="comment">//空指针异常</span></span><br><span class="line">System.out.println(pizza == Pizza.PizzaStatus.DELIVERED);<span class="comment">//正常运行</span></span><br></pre></td></tr></table></figure>

<p>对于编译时安全性，两个不同枚举类型进行比较：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Pizza.PizzaStatus.DELIVERED.equals(TestColor.GREEN)); <span class="comment">// 编译正常</span></span><br><span class="line"><span class="keyword">if</span> (Pizza.PizzaStatus.DELIVERED == TestColor.GREEN);      <span class="comment">// 编译失败，类型不匹配</span></span><br></pre></td></tr></table></figure>

<h3 id="在Switch语句中使用枚举类型"><a href="#在Switch语句中使用枚举类型" class="headerlink" title="在Switch语句中使用枚举类型"></a>在Switch语句中使用枚举类型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getDeliveryTimeInDays</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (status) &#123;</span><br><span class="line">        <span class="keyword">case</span> ORDERED:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">case</span> READY:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">case</span> DELIVERED:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>…</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">PinType</span> &#123;</span><br><span class="line"></span><br><span class="line">    REGISTER(<span class="number">100000</span>， <span class="string">&quot;注册使用&quot;</span>)，</span><br><span class="line">    FORGET_PASSWORD(<span class="number">100001</span>， <span class="string">&quot;忘记密码使用&quot;</span>)，</span><br><span class="line">    UPDATE_PHONE_NUMBER(<span class="number">100002</span>， <span class="string">&quot;更新手机号码使用&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> code;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String message;</span><br><span class="line"></span><br><span class="line">    PinType(<span class="type">int</span> code， String message) &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;PinType&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;code=&quot;</span> + code +</span><br><span class="line">                <span class="string">&quot;， message=&#x27;&quot;</span> + message + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">实际使用：</span><br><span class="line"></span><br><span class="line">System.out.println(PinType.FORGET_PASSWORD.getCode());</span><br><span class="line">System.out.println(PinType.FORGET_PASSWORD.getMessage());</span><br><span class="line">System.out.println(PinType.FORGET_PASSWORD.toString());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line"><span class="number">100001</span></span><br><span class="line">忘记密码使用</span><br><span class="line">PinType&#123;code=<span class="number">100001</span>， message=<span class="string">&#x27;忘记密码使用&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<h1 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h1><p>java buffer一般比普通io流快，因为普通io10b也调用系统调用写回，而buffer集齐8KB才调用一次系统调用</p>
<p>有些对象自己能控制就可以分配堆内内存（jvm堆里的字节数组），有些时候只能使用堆内内存（jvm堆外，java进程的堆内）（你不能控制）；都要走系统调用</p>
<p>mmap可以省一次系统调用</p>
<p>为什么设计pagecache？</p>
<p>提速，减少硬件io调用，优先使用内存；</p>
<p>如果只是new 一个socket为5，不执行accept也能建立连接，只是没有分配文件描述符去接受，只是建立连接的状态，还能相互发送数据包，但是没有分配进程去处理，文件描述符没有分配给对应的进程；  如果这个时候执行accpet把这个连接分配给对应的进程，之前发的东西也能接受到。</p>
<p>面向连接，三次握手后内核开辟资源，这个资源代表了双方建立了连接</p>
<p>socket是四元组，只要能唯一标识即可</p>
<p>不同进程之间的fd可以相同， 进程里的fd不能相同，进程间是隔离的；</p>
<p>一个进程可以监听多个端口号，new 一个socket监听一个端口号</p>
<p>Back_log &#x3D; 2， 表示最多只有2个没有进程认领的socket连接，如果超过了就会显示syn—recv状态，服务不回复syn包，或者发的包丢失都会是这个状态，没有收到客户端的ack都会是这个状态。</p>
<p>&amp;9 是指9这个文件描述符</p>
<p>不加的话就是9这个文件</p>
<p>windows可以支持aio，linux出于安全考虑没有做这个，内核更精简</p>
<p>线程池可以省下clone的时间，先clone好直接用 </p>
<p>root用户不受连接数限制，普通用户受连接数限制；</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/javaguide/p/io.html">https://www.cnblogs.com/javaguide/p/io.html</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_36364419/article/details/114238400">https://blog.csdn.net/weixin_36364419/article/details/114238400</a></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1488087">https://cloud.tencent.com/developer/article/1488087</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/crazymakercircle/p/10225159.html">https://www.cnblogs.com/crazymakercircle/p/10225159.html</a></p>
<p><a target="_blank" rel="noopener" href="https://llc687.top/post/%E5%A6%82%E4%BD%95%E5%AE%8C%E6%88%90%E4%B8%80%E6%AC%A1-io/#gsc.tab=0">如何完成一次IO</a></p>
<h2 id="Direct-IO"><a href="#Direct-IO" class="headerlink" title="Direct IO"></a>Direct IO</h2><p>数据库一般使用directIO，就是自己管理pagecache，和linux操作系统管理的区别是它可以自己控制一些参数，而不用修改linux内核pagecache的全局参数</p>
<h2 id="Select-Poll-Epoll"><a href="#Select-Poll-Epoll" class="headerlink" title="Select Poll Epoll"></a>Select Poll Epoll</h2><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><ol>
<li><p>fd_set 使用数组实现，fd_size 有限制 1024 bitmap ， fd【i】 &#x3D; accept()</p>
</li>
<li><p>fd_set不可重用，新的fd进来，重新创建</p>
</li>
<li><p>用户态和内核态拷贝fd集合产生开销</p>
</li>
<li><p>O(n)时间复杂度的轮询<br>​</p>
</li>
</ol>
<p>成功调用返回结果大于 0，出错返回结果为 -1，超时返回结果为 0， 具有超时时间</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848052.png" alt="img"></p>
<p>首先，fd_set结构体仅包含一个整型数组，该数组的每一位（bit）标记一个文件描述符。fd_set能容纳的文件描述符数量由FD_SETSIZE指定，这也就限制了select能同时处理的文件描述符的总量。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848060.png" alt="img"></p>
<p>FD_ZERO : 清除fdset的所有位， FD_CLR 清除位fd， FD_SET 设置fdset的位fd， FD_ISSET 测试fdset的位fd是否被设置过</p>
<h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><ol>
<li><p>用户态和内核态拷贝fd集合产生开销</p>
</li>
<li><p>O(n)时间复杂度的轮询</p>
</li>
</ol>
<p>​    基于结构体存储fd<br>​    struct pollfd{<br>​        int fd;<br>​        short events;<br>​        short revents; &#x2F;&#x2F;可重用<br>​    }<br>​    解决了select的1，2两点缺点</p>
<p>int poll(struct pollfd *ufds， unsigned int nfds， int timeout)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poll([&#123;fd=5， events=POLLIN|POLLERR&#125;]， 1， -1) = 1 ([&#123;fd=5， revents=POLLIN&#125;])</span><br></pre></td></tr></table></figure>



<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><ol>
<li>用户空间可以调用epoll create返回一个epfd即epoll文件描述符即共享空间的地址给到用户空间，</li>
<li>有一个fd过来了之后， 用户控件就把这个fd传给epoll文件描述符， 然后epoll会准备一个红黑树(增删改由内核完成)，和链表。epoll会把这个fd注册给红黑树.</li>
<li>然后用户空间会调一个系统调用调到epoll上， 此时调用的是wait，它会阻塞，直到链表中有数据，才会返回。由阻塞变为不阻塞。</li>
<li>然后用户空间再去读链表，把到达的几个文件描述符取出来，然后根据文件描述符的类型做不同的处理。</li>
</ol>
<p>解决select的1，2，3，4; 不需要轮询，时间复杂度为O(1)</p>
<p>epoll_create ：创建一个白板，存放fd_events</p>
<p>epoll_ctl ：用于向内核注册新的描述符或者是改变某个文件描述符的状态。已注册的描述符在内核中会被维护在一棵红黑树上</p>
<p>epoll_wait ：通过回调函数内核会将 I&#x2F;O 准备好的描述符加入到一个链表中管理，进程调用epoll_wait() 便可以得到事件完成的描述符</p>
<p>两种触发模式：</p>
<ul>
<li><p>LT:水平触发<br>​当 epoll_wait() 检测到描述符事件到达时，将此事件通知进程，进程可以不立即处理该事件，下次调用 epoll_wait() 会再次通知进程。是默认的一种模式，并且同时支持 Blocking 和 No-Blocking。</p>
</li>
<li><p>ET:边缘触发</p>
<p>和 LT 模式不同的是，通知之后进程必须立即处理事件。下次再调用 epoll_wait() 时不会再得到事件到达的通知。很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。只支持 No-Blocking，以避免由于一个文件句柄的阻塞读&#x2F;阻塞写操作把处理多个文件描述符的任务饿死。</p>
</li>
</ul>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><h4 id="1-select-应用场景"><a href="#1-select-应用场景" class="headerlink" title="1. select 应用场景"></a>1. select 应用场景</h4><p>select 的 timeout 参数精度为微秒，而 poll 和 epoll 为毫秒，因此 select 更加适用于实时性要求比较高的场景，比如核反应堆的控制。</p>
<p>select 可移植性更好，几乎被所有主流平台所支持。</p>
<h4 id="2-poll-应用场景"><a href="#2-poll-应用场景" class="headerlink" title="2. poll 应用场景"></a>2. poll 应用场景</h4><p>poll 没有最大描述符数量的限制，如果平台支持并且对实时性要求不高，应该使用 poll 而不是 select。</p>
<h4 id="3-epoll-应用场景"><a href="#3-epoll-应用场景" class="headerlink" title="3. epoll 应用场景"></a>3. epoll 应用场景</h4><p>只需要运行在 Linux 平台上，有大量的描述符需要同时轮询，并且这些连接最好是长连接。</p>
<p>需要同时监控小于 1000 个描述符，就没有必要使用 epoll，因为这个应用场景下并不能体现 epoll 的优势。</p>
<p>需要监控的描述符状态变化多，而且都是非常短暂的，也没有必要使用 epoll。因为 epoll 中的所有描述符都存储在内核中，造成每次需要对描述符的状态改变都需要通过 epoll_ctl() 进行系统调用，频繁系统调用降低效率。并且 epoll 的描述符存储在内核，不容易调试。</p>
<h2 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h2><p>每个线程对应每个连接， 用一个主线程接受连接，连接上了之后分配一个线程去处理请求;</p>
<p>a.accept()</p>
<p>jdk 1.4 直接调用accept()阻塞等待;  jdk 8之后先调用多路复用器 poll()，这个poll()也会阻塞，然后有连接进来再调用accept()来处理;</p>
<p>缺点: 线程太多; 调度开销， 资源消耗， 根本就是因为是阻塞的;</p>
<p>socket()返回fd， 然后bind(fd，9090)，然后listen(fd)，然后accept()</p>
<h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><p>OS维度是NONEBLOCKING IO 非阻塞的具体实现; java维度是New IO; 有没有NIO是操作系统内核决定的，而不是jar包; linux内核老版只支持BIO; 内核没有select就不会有java NIO; </p>
<p>ss.configureBlocking(false); 设置OS 非阻塞</p>
<p>优点:可以一个线程处理N个连接以及读写</p>
<p>弊端: 不限的系统调用，上下文切换资源消耗很多，很浪费cpu资源; 假设一个线程处理一万个请求(C10K问题)， 那么一次while循环一次会有一万次read调用; 假设前9999个read调用都返回-1，最后一个read返回了数据，那么前9999个read()调用就不该调，O(n)的复杂度;</p>
<p>NIO 属于同步非阻塞，收到的请求会先注册到多路复用器 Selector 上，多路复用器轮询直到连接有 I&#x2F;O 请求时才启动一个线程进行处理。也就是前文中的<strong>多路复用 I&#x2F;O 模型</strong>，虽然说多路复用模型是阻塞的，但在 NIO 这里，因为有<strong>Selector</strong>，read 和 write 操作都是非阻塞的，其中 Selector 其实就是 select&#x2F;poll&#x2F;epoll 的外包类。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848068.png" alt="image-20200610173230680"></p>
<p>不仅如此，NIO 除了面向流和非阻塞外，还有一个效率高的原因就是前文中也有提到的零拷贝。</p>
<p>NIO 中的 Channel（通道）相当于操作系统中的内核缓冲区， Buffer 就相当于操作系统中的用户空间缓冲区。零拷贝在 NIO 这里重要的是两个实现：</p>
<ul>
<li>FileChannel.map() : 基于内存映射 <strong>mmap</strong> 方式一种实现，可以把一个文件从 position 位置开始的 size 大小的区域映射为内存映像文件。</li>
<li>FileChannel.transferTo() : 通过调用 <strong>sendfile</strong> 方式实现的零拷贝。</li>
</ul>
<p>关于 NIO 还有一个常见的实现。那就是 Netty ， Netty 是一个高性能、异步事件驱动的 NIO 框架，但为啥不直接用 JDK 中的 NIO ，而要再造轮子呢，那当然是 Netty 比 JDK NIO 做的更多，比如解决了粘包半包、断连和 idle 处理、支持流量整形等。</p>
<p>另外说起 NIO 的零拷贝，消息队列现在基本是标配，常用有 Kafka、RocketMQ、RabbitMQ，排名按性能分先后。其中 Kafka 和 RocketMQ 分别是基于 <strong>sendfile</strong> 和 <strong>mmap + write</strong>实现的零拷贝，这也是吞吐量较大的原因之一。Nignx 通过sendfile on 配置可以开启sendfile系统调用。</p>
<p>函数定义：ssize_t read(int fd， void * buf， size_t count);</p>
<p>函数说明：read()会把参数fd所指的文件传送count 个字节到buf 指针所指的内存中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">LinkedList&lt;SocketChannel&gt; clients = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"><span class="type">ServerSocketChannel</span> <span class="variable">ss</span> <span class="operator">=</span> ServerSocketChannel.open(); <span class="comment">// 服务端开启监听: 接受客户端</span></span><br><span class="line">ss.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">9090</span>));</span><br><span class="line">ss.configureBlocking(<span class="literal">false</span>); <span class="comment">//OS  NONBLOCKING 只让接受客户端 不阻塞</span></span><br><span class="line"><span class="comment">// 在一次循环中尝试接受一个连接，接收到就入队列</span></span><br><span class="line"><span class="comment">// 一个线程</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) </span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    <span class="type">SocketChannel</span> <span class="variable">client</span> <span class="operator">=</span> ss.accept(); <span class="comment">// 不会阻塞，立刻返回</span></span><br><span class="line"> 	<span class="comment">// accept 调用内核 : 1. 没有客户端连接进来，返回值? 在BIO的时候一直卡住，但是在NIO，不卡住，返回-1</span></span><br><span class="line">    <span class="comment">// 如果来客户端的连接， accept返回的是这个客户端的fd 5， client object</span></span><br><span class="line">    <span class="comment">// NONBLOCKING 就是代码不能卡住，只不过有不同的情况</span></span><br><span class="line">   	<span class="keyword">if</span> (client == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// System.out.println(&quot;null..&quot;);</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        client.configureBlocking(<span class="literal">false</span>); <span class="comment">// 保证客户端不阻塞</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> client.socket().getPort();</span><br><span class="line">        System.out.println(<span class="string">&quot;client..port&quot;</span> + port);</span><br><span class="line">        clients.add(client);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocateDirect(<span class="number">4096</span>);<span class="comment">// 可以在堆里，堆外</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 遍历已经连接进来的客户端能不能读写数据</span></span><br><span class="line">	<span class="keyword">for</span> (SocketChannel c : clients) &#123; <span class="comment">//串行化，多线程， 可以把他们抛给多个线程或者线程池去处理</span></span><br><span class="line">       </span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> c.read(buffer); <span class="comment">//&gt;0 -1 0 不会阻塞</span></span><br><span class="line">        <span class="keyword">if</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            buffer.flip();</span><br><span class="line">            <span class="type">byte</span>[] aa = <span class="keyword">new</span> <span class="title class_">byte</span>[buffer.limit()];</span><br><span class="line">            buffer.get(aa);</span><br><span class="line">            <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(aa);</span><br><span class="line">            System.out.println(ss.socket().getPort() + <span class="string">&quot; : &quot;</span> + b);</span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Java NIO 由以下几个核心部分组成：</p>
<ul>
<li>Channels</li>
<li>Buffers</li>
<li>Selectors</li>
</ul>
<p>虽然Java NIO 中除此之外还有很多类和组件，Channel，Buffer 和 Selector 构成了核心的API。其它组件，如Pipe和FileLock，只不过是与三个核心组件共同使用的工具类。</p>
<h3 id="Channel-和-Buffer"><a href="#Channel-和-Buffer" class="headerlink" title="Channel 和 Buffer"></a>Channel 和 Buffer</h3><p>基本上，所有的 IO 在NIO 中都从一个Channel 开始。Channel 有点像流。 数据可以从Channel读到Buffer中，也可以从Buffer 写到Channel中。这里有个图示：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848074.png" alt="img"></p>
<p>Channel和Buffer有好几种类型。下面是JAVA NIO中的一些主要Channel的实现：</p>
<ul>
<li>FileChannel</li>
<li>DatagramChannel</li>
<li>SocketChannel</li>
<li>ServerSocketChannel</li>
</ul>
<p>正如你所看到的，这些通道涵盖了UDP 和 TCP 网络IO，以及文件IO。</p>
<p>以下是Java NIO里关键的Buffer实现：</p>
<ul>
<li>ByteBuffer</li>
<li>CharBuffer</li>
<li>DoubleBuffer</li>
<li>FloatBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>ShortBuffer</li>
</ul>
<p>这些Buffer覆盖了你能通过IO发送的基本数据类型：byte， short， int， long， float， double 和 char。</p>
<p>Java NIO 还有个 MappedByteBuffer，用于表示内存映射文件，底层调用mmap系统调用</p>
<h3 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h3><p>Selector允许单线程处理多个 Channel。如果你的应用打开了多个连接（通道），但每个连接的流量都很低，使用Selector就会很方便。例如，在一个聊天服务器中。</p>
<p>这是在一个单线程中使用一个Selector处理3个Channel的图示：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848080.png" alt="img"></p>
<p>要使用Selector，得向Selector注册Channel，然后调用它的select()方法。这个方法会一直阻塞到某个注册的通道有事件就绪。一旦这个方法返回，线程就可以处理这些事件，事件的例子有如新连接进来，数据接收等</p>
<p>recv() 和 send()：面向已连接的TCP&#x2F;IP类型socket接收或发送数据。</p>
<p>recvfrom() 和 sendto()：面向无连接的UDP数据报。</p>
<h3 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h3><p>调用select或poll，select或poll逐个去看那个数据准备好了，然后返回状态集，状态集里面有准好了的文件描述符，接着就可以调用read或recv或write读写数据;内核遍历那个好了比自己去看少了很多次系统调用，能省很多时间</p>
<p>阻塞单线程</p>
<p>收费站模型，  你开了一个收费站 ，fd为5，你在办公室办公，离收费站很远，你只有一个人， 然后你调用ss.accept()，早期linux内核直接调accept()，然后你就去收费站等着直到有路需要修，你把路修好，并把路标记为6，然后你再回去办公室，接着你读到int len &#x3D; accept.getInputStream().read(buffer);(6.read())， 然后你直接去6号路看看货物有没有准备好，没准备好你就一直等，等到了然后你再把货物搬到你的办公室，然后再处理;</p>
<p>阻塞多线程</p>
<p>收费站模型，  你开了一个收费站 ，fd为5，你在办公司办公，离收费站很远，你可以请人工作， 然后你调用ss.accept()，早期linux内核直接调accept()，然后你就去收费站等着直到有路需要修，fd6你把路修好，然后请一个工人（线程）看着这6号路，接着这个人读到int len &#x3D; accept.getInputStream().read(buffer);(6.read())， 然后他直接去6号路看看货物有没有准备好，没准备好他就一直等，等到了然后他再把货物搬到你的办公室，然后再处理; 期间你可以去干别的事;</p>
<p>非阻塞</p>
<p>收费站模型， 你在办公室办公，离收费站比较远， 调用一次SocketChannel client &#x3D; ss.accept();(底层是accept)你就去收费站看一下有没有路要加进来，有的话你把路加进来， 然后你又跑回办公室做干别的事情，没有的话你直接回去干别的事情， 然后执行到int num &#x3D; c.read(byteBuffer);  你去收费站看对应的路是否有货来了，有的话你处理一下， 你得把货物搬到自己的办公室， 然后你再对货物进行处理， 处理完了再执行到int num &#x3D; c.read(byteBuffer)，你又重复刚刚的办法; 直到把所有已注册的路处理完，然后又执行SocketChannel client &#x3D; ss.accept();  其实多跑了很多躺路; 明明可以一次性看那条路好了，然后去处理那一条路就可以，不用每一条路都去看一下;</p>
<p>阻塞多路复用器poll单线程（让linux帮你看，但是会有C10K问题，linux很傻记不住，每次重新遍历，而不是自己看）</p>
<p>收费站模型，  你开了一个收费站 ，fd为5，你在办公室办公，离收费站很远，你只有一个人， 然后你调用ss.accept()，linux内核直接调poll()，这个poll相当于一个人(他就住在收费站)， 你跑到收费站，把收费站号告诉他，然后他就去各个收费站看有没有需要修的路(但是这个人没有记忆，每次都会全看一遍，不会记录状态，很傻)，没有或者有都告诉你(期间你得在收费站等着)，你接着就调用accept来修路，修好路并且给个路号6;，然后你回去，读到6.read()，你就去6号路等着，直到有货物然后搬回来;</p>
<p>非阻塞多路复用单线程epoll</p>
<p>让那个住在收费站的人(内核)留个小本本，将所有注册的fd组织成红黑树， 然后来个链表记录</p>
<h2 id="Read和Write系统调用"><a href="#Read和Write系统调用" class="headerlink" title="Read和Write系统调用"></a>Read和Write系统调用</h2><p>read系统调用: 将数据从内核缓冲区复制到用户缓冲区</p>
<p>write系统调用: 将数据从用户缓冲区复制到内核缓冲区</p>
<p>这个两个系统调用，都不负责数据在内核缓冲区和磁盘之间的交换。底层的读写交换，是由操作系统kernel内核完成的。</p>
<p> <img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848274.png" alt="img"></p>
<p>一个典型Java 服务端处理网络请求的典型过程：</p>
<p>（1）客户端请求</p>
<p>Linux通过网卡，读取客户断的请求数据，将数据读取到内核缓冲区。</p>
<p>（2）获取请求数据</p>
<p>服务器从内核缓冲区读取数据到Java进程缓冲区。</p>
<p>（3）服务器端业务处理</p>
<p>Java服务端在自己的用户空间中，处理客户端的请求。</p>
<p>（4）服务器端返回数据</p>
<p>Java服务端已构建好的响应，从用户缓冲区写入系统缓冲区。</p>
<p>（5）发送给客户端</p>
<p>Linux内核通过网络 I&#x2F;O ，将内核缓冲区中的数据，写入网卡，网卡通过底层的通讯协议，会将数据发送给目标客户端。</p>
<h2 id="Linux五种IO模型"><a href="#Linux五种IO模型" class="headerlink" title="Linux五种IO模型"></a>Linux五种IO模型</h2><p>前4种都是同步的</p>
<p>阻塞式I&#x2F;O<br>非阻塞式I&#x2F;O<br>I&#x2F;O复用（select，poll，epoll等）<br>信号驱动式I&#x2F;O（SIGIO）<br>异步I&#x2F;O（POSIX的aio_系列函数）</p>
<h3 id="信号驱动式IO"><a href="#信号驱动式IO" class="headerlink" title="信号驱动式IO"></a>信号驱动式IO</h3><p>允许Socket进行信号驱动IO，并注册一个信号处理函数，进程继续运行并不阻塞。当数据准备好时，进程会收到一个SIGIO信号，可以在信号处理函数中调用I&#x2F;O操作函数处理数据。如下图：<br><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848311.png" alt="这里写图片描述"></p>
<h3 id="同步阻塞IO-Blocking-IO"><a href="#同步阻塞IO-Blocking-IO" class="headerlink" title="同步阻塞IO(Blocking IO)"></a>同步阻塞IO(Blocking IO)</h3><p>同步阻塞 IO 模型是最常用的一个模型，也是最简单的模型。在linux中，默认情况下所有的socket都是blocking。它符合人们最常见的思考逻辑。阻塞就是进程 “被” 休息， CPU处理其它进程去了。</p>
<h3 id="同步非阻塞-None-Blocking-IO"><a href="#同步非阻塞-None-Blocking-IO" class="headerlink" title="同步非阻塞(None Blocking IO)"></a>同步非阻塞(None Blocking IO)</h3><p>NIO模型在高并发场景下，也是不可用的。一般 Web 服务器不使用这种 IO 模型。一般很少直接使用这种模型，而是在其他IO模型中使用非阻塞IO这一特性。java的实际开发中，也不会涉及这种IO模型。</p>
<h3 id="IO多路复用模型-I-x2F-O-multiplexing）"><a href="#IO多路复用模型-I-x2F-O-multiplexing）" class="headerlink" title="IO多路复用模型(I&#x2F;O multiplexing）"></a>IO多路复用模型(I&#x2F;O multiplexing）</h3><p>IO多路复用模型，就是通过一种新的系统调用，一个进程可以监视多个文件描述符，一旦某个描述符就绪（一般是内核缓冲区可读&#x2F;可写），内核kernel能够通知程序进行相应的IO系统调用。</p>
<p>目前支持IO多路复用的系统调用，有 select，poll，epoll等等。select系统调用，是目前几乎在所有的操作系统上都有支持，具有良好跨平台特性。epoll是在linux 2.6内核中提出的，是select，poll系统调用的linux增强版本。</p>
<p>IO多路复用模型的基本原理就是select&#x2F;poll&#x2F;epoll系统调用，单个线程不断的轮询select&#x2F;poll&#x2F;epoll系统调用所负责的成百上千的socket连接，当某个或者某些socket网络连接有数据到达了，就返回这些可以读写的连接。因此，好处也就显而易见了——通过一次select&#x2F;poll&#x2F;epoll系统调用，就查询到到可以读写的一个甚至是成百上千的网络连接。</p>
<p>举个栗子。发起一个多路复用IO的的read读操作系统调用，流程是这个样子：</p>
<p>[<img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848325.jpeg" alt="在这里插入图片描述"></p>
<p>在这种模式中，首先不是进行read系统调动，而是进行select&#x2F;poll&#x2F;epoll系统调用。当然，这里有一个前提，需要将目标网络连接，提前注册到select&#x2F;poll&#x2F;epoll的可查询socket列表中。然后，才可以开启整个的IO多路复用模型的读流程。</p>
<p>（1）进行select&#x2F;epoll系统调用，查询可以读的连接。kernel会查询所有select的可查询socket列表，当任何一个socket中的数据准备好了，select就会返回。</p>
<p>当用户进程调用了select，那么整个线程会被block（阻塞掉）。</p>
<p>（2）用户线程获得了目标连接后，发起read系统调用，用户线程阻塞。内核开始复制数据。它就会将数据从kernel内核缓冲区，拷贝到用户缓冲区（用户内存），然后kernel返回结果。</p>
<p>（3）用户线程才解除block的状态，用户线程终于真正读取到数据，继续执行。</p>
<p>多路复用IO的特点：</p>
<p>IO多路复用模型，建立在操作系统kernel内核能够提供的多路复用系统调用select&#x2F;poll&#x2F;epoll基础之上的。多路复用IO需要用到两个系统调用（system call）， 一个select&#x2F;poll&#x2F;epoll查询调用，一个是IO的读取调用。</p>
<p>和NIO模型相似，多路复用IO需要轮询。负责select&#x2F;poll&#x2F;epoll查询调用的线程，需要不断的进行select&#x2F;epoll轮询，查找出可以进行IO操作的连接。</p>
<p>另外，多路复用IO模型与前面的NIO模型，是有关系的。对于每一个可以查询的socket，一般都设置成为non-blocking模型。只是这一点，对于用户程序是透明的（不感知）。</p>
<p>多路复用IO的优点：</p>
<p>用select&#x2F;poll&#x2F;epoll的优势在于，它可以同时处理成千上万个连接（connection）。与一条线程维护一个连接相比，I&#x2F;O多路复用技术的最大优势是：系统不必创建线程，也不必维护这些线程，从而大大减小了系统的开销。</p>
<p>Java的NIO（new IO）技术，使用的就是IO多路复用模型。在linux系统上，使用的是epoll系统调用。</p>
<p>多路复用IO的缺点：</p>
<p>本质上，select&#x2F;poll&#x2F;epoll系统调用，属于同步IO，也是阻塞IO。都需要在读写事件就绪后，自己负责进行读写，也就是说这个读写过程是阻塞的。</p>
<p>如何充分的解除线程的阻塞呢？那就是异步IO模型。</p>
<h3 id="异步IO模型（asynchronous-IO）"><a href="#异步IO模型（asynchronous-IO）" class="headerlink" title="异步IO模型（asynchronous IO）"></a>异步IO模型（asynchronous IO）</h3><p>如何进一步提升效率，解除最后一点阻塞呢？这就是异步IO模型，全称asynchronous I&#x2F;O，简称为AIO。</p>
<p>AIO的基本流程是：用户线程通过系统调用，告知kernel内核启动某个IO操作，用户线程返回。kernel内核在整个IO操作（包括数据准备、数据复制）完成后，通知用户程序，用户执行后续的业务操作。</p>
<p>kernel的数据准备是将数据从网络物理设备（网卡）读取到内核缓冲区；kernel的数据复制是将数据从内核缓冲区拷贝到用户程序空间的缓冲区。</p>
<p>[<img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848327.jpeg" alt="在这里插入图片描述"></p>
<p>（1）当用户线程调用了read系统调用，立刻就可以开始去做其它的事，用户线程不阻塞。</p>
<p>（2）内核（kernel）就开始了IO的第一个阶段：准备数据。当kernel一直等到数据准备好了，它就会将数据从kernel内核缓冲区，拷贝到用户缓冲区（用户内存）。</p>
<p>（3）kernel会给用户线程发送一个信号（signal），或者回调用户线程注册的回调接口，告诉用户线程read操作完成了。</p>
<p>（4）用户线程读取用户缓冲区的数据，完成后续的业务操作。</p>
<p>异步IO模型的特点：</p>
<p>在内核kernel的等待数据和复制数据的两个阶段，用户线程都不是block(阻塞)的。用户线程需要接受kernel的IO操作完成的事件，或者说注册IO操作完成的回调函数，到操作系统的内核。所以说，异步IO有的时候，也叫做信号驱动 IO 。</p>
<p>异步IO模型缺点：</p>
<p>需要完成事件的注册与传递，这里边需要底层操作系统提供大量的支持，去做大量的工作。</p>
<p>目前来说， Windows 系统下通过 IOCP 实现了真正的异步 I&#x2F;O。但是，就目前的业界形式来说，Windows 系统，很少作为百万级以上或者说高并发应用的服务器操作系统来使用。</p>
<p>而在 Linux 系统下，异步IO模型在2.6版本才引入，目前并不完善。所以，这也是在Linux下，实现高并发网络编程时都是以 IO 复用模型模式为主。</p>
<h3 id="小结一下："><a href="#小结一下：" class="headerlink" title="小结一下："></a>小结一下：</h3><p>四种IO模型，理论上越往后，阻塞越少，效率也是最优。在这四种 I&#x2F;O 模型中，前三种属于同步 I&#x2F;O，因为其中真正的 I&#x2F;O 操作将阻塞线程。只有最后一种，才是真正的异步 I&#x2F;O 模型，可惜目前Linux 操作系统尚欠完善。</p>
<h2 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h2><h4 id="1-传统-I-x2F-O"><a href="#1-传统-I-x2F-O" class="headerlink" title="1. 传统 I&#x2F;O"></a>1. 传统 I&#x2F;O</h4><p>先来看看传统方式，在进行一次读写时共涉及了4次上下文切换，2次 DMA 拷贝以及2次 CPU 拷贝。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848345.png" alt="screen-1535441"></p>
<h4 id="2-用户态直接IO"><a href="#2-用户态直接IO" class="headerlink" title="2. 用户态直接IO"></a>2. 用户态直接IO</h4><p>这是第一种思路，使应用进程或处于用户态下的库函数跨过内核直接访问硬件，内核在数据传输过程除了进行必要的虚拟存储配置工作外，不参与任何其他工作。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848347.png" alt="screen-1535947"></p>
<p>但只适用于不需要内核缓冲区处理的应用程序，这些应用程序通常在进程地址空间有自己的数据缓存机制，又称为自缓存应用程序，如数据库管理系统。其次，因 CPU 和磁盘 I&#x2F;O 之间的性能差距，就会造成资源的浪费，一般是会配合异步 I&#x2F;O 使用。</p>
<h4 id="3-mmap"><a href="#3-mmap" class="headerlink" title="3. mmap"></a>3. mmap</h4><p>这属于第二类优化，减少了 1 次 CPU 拷贝。MMAP 是数据不会到达用户空间内存，只会存在于系统空间的内存上，用户空间与系统空间共用同一个缓冲区，两者通过映射关联。<img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848464.png" alt="screen-1773287"></p>
<p>整个 MMAP 过程，发生了 4 次上下文切换 + 1 次 CPU 拷贝 + 2 次 DMA 拷贝。</p>
<h4 id="4-sendfile"><a href="#4-sendfile" class="headerlink" title="4. sendfile"></a>4. sendfile</h4><p>这也是第二类优化。用户进程不需要单独调用 read&#x2F;write ，而是直接调用 sendfile() ，sendfile 再帮用户调用 read&#x2F;write 操作。数据可以直接在内核空间进行 I&#x2F;O 传输，省去了数据在用户空间和内核空间之间的拷贝。</p>
<p>与 mmap 内存映射方式不同的是， sendfile() 调用中数据对用户空间是完全不可见的。也就是说，这是一次完全意义上的数据传输过程。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848624.png" alt="image-20200610154454498"></p>
<p>整个过程发生 2 次上下文切换，1 次 CPU 拷贝和 2 次 DMA 拷贝。</p>
<h4 id="5-sendfile-DMA-gather-copy"><a href="#5-sendfile-DMA-gather-copy" class="headerlink" title="5. sendfile + DMA gather copy"></a>5. sendfile + DMA gather copy</h4><p>在前面的 sendfile() 方式中，CPU 仍需要一次拷贝，从 Linux 2.4 版本开始，DMA 自带了收集功能，可以将对应的数据描述信息（内存地址、地址偏移量）记录到相应的网络缓冲区（ socket buffer），由DMA 根据这些信息直接将内核缓冲区的数据拷贝到网卡设备中，省下了最后一次 CPU 拷贝。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848672.png" alt="image-20200610154613272"></p>
<p>这次只发生 2 次上下文切换 + 2 次 DMA 数据拷贝。</p>
<h4 id="6-splice"><a href="#6-splice" class="headerlink" title="6. splice"></a>6. splice</h4><p>sendfile 只适用于将数据从文件拷贝到网卡上，限定了使用范围。</p>
<p>splice 系统调用可以在内核空间的读缓冲区和网络缓冲区之间建立管道，支持任意两个文件之间互连，可以在操作系统地址空间中整块地移动数据。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848689.png" alt="image-20200610161033841"></p>
<p>同样发生 2 次上下文切换 + 2 次 DMA 数据拷贝。</p>
<h4 id="7-写时复制"><a href="#7-写时复制" class="headerlink" title="7. 写时复制"></a>7. 写时复制</h4><p>这个就是第三种思路了，COW 写时复制。</p>
<p>当用户进程有写操作时，就把这块共享的内存空间复制一份到其他区域，给写进程专用。这种方法在能够降低系统开销，如果某个进程永远不会对数据进行更改，那就永远不需要拷贝。</p>
<h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><p>进程: 进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程; 启动两个main函数就是两个jvm进程;</p>
<p>线程: 线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p>
<ul>
<li>计算机的核心是CPU，它承担了所有的计算任务。它就像一座工厂，时刻在运行。</li>
<li>假定工厂的电力有限，一次只能供给一个车间使用。也就是说，一个车间开工的时候，其他车间都必须停工。背后的含义就是，单个CPU一次只能运行一个任务。编者注: 多核的CPU就像有了多个发电厂，使多工厂(多进程)实现可能。</li>
<li>进程就好比工厂的车间，它代表CPU所能处理的单个任务。任一时刻，CPU总是运行一个进程，其他进程处于非运行状态。（子进程就是工厂的复制版， 各个工厂独立，一般互不影响）</li>
<li>一个车间里（可能只有一台机器），可以有很多工人。他们协同完成一个任务。（由于是流水线工作，一个线程挂了很可能会影响到整个进程，每个工人有自己的独有区域，不能给别人访问）</li>
<li>线程就好比车间里的工人。一个进程可以包括多个线程。</li>
<li>车间的空间是工人们共享的，比如许多房间是每个工人都可以进出的。这象征一个进程的内存空间是共享的，每个线程都可以使用这些共享内存。</li>
<li>可是，每间房间的大小不同，有些房间最多只能容纳一个人，比如厕所。里面有人的时候，其他人就不能进去了。这代表一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。</li>
<li>一个防止他人进入的简单方法，就是门口加一把锁。先到的人锁上门，后到的人看到上锁，就在门口排队，等锁打开再进去。这就叫”互斥锁”（Mutual exclusion，缩写 Mutex），防止多个线程同时读写某一块内存区域。</li>
<li>还有些房间，可以同时容纳n个人，比如厨房。也就是说，如果人数大于n，多出来的人只能在外面等着。这好比某些内存区域，只能供给固定数目的线程使用。</li>
<li>这时的解决方法，就是在门口挂n把钥匙。进去的人就取一把钥匙，出来时再把钥匙挂回原处。后到的人发现钥匙架空了，就知道必须在门口排队等着了。这种做法叫做”信号量”（Semaphore），用来保证多个线程不会互相冲突。</li>
<li>不难看出，mutex是semaphore的一种特殊情况（n&#x3D;1时）。也就是说，完全可以用后者替代前者。但是，因为mutex较为简单，且效率高，所以在必须保证资源独占的情况下，还是采用这种设计。</li>
</ul>
<h3 id="多进程编程和多线程编程的优缺点"><a href="#多进程编程和多线程编程的优缺点" class="headerlink" title="多进程编程和多线程编程的优缺点"></a>多进程编程和多线程编程的优缺点</h3><p>多进程编程和多线程编程，都可以使用并行机制来提升系统的运行效率。二者的区别在于运行时所占的内存分布不同，多线程是共用一套内存的代码块区间；而多进程是各用一套独立的内存区间。</p>
<p>多进程的优点是稳定性好，一个子进程崩溃了，不会影响主进程以及其余进程。基于这个特性，常常会用多进程来实现守护服务器的功能。</p>
<p>多进程编程也有不足，即创建进程的代价非常大，因为操作系统要给每个进程分配固定的资源，并且操作系统对进程的总数会有一定的限制，若进程过多，操作系统调度都会存在问题，会造成假死状态。</p>
<p>多线程编程的优点是效率较高一些，适用于批处理任务等功能；不足之处在于，任何一个线程崩溃都可能造成整个进程的崩溃，因为它们共享了进程的内存资源池。</p>
<p>既然多线程编程和多进程编程各有优缺点，因此它们分别适用于不同的场景。比如说（python），对于计算密集型的任务，多进程效率会更高一下；而对于IO密集型的任务（比如文件操作，网络爬虫），采用多线程编程效率更高。为什么是这样呢？</p>
<p>其实也不难理解。对于 IO 密集型操作，大部分消耗时间其实是等待时间，在等待时间中，<a target="_blank" rel="noopener" href="http://c.biancheng.net/python/">Python</a>会释放GIL供新的线程使用，实现了线程间的切换；相反对于 CPU 密集型代码，2 个 CPU 干活肯定比一个 CPU 快很多。</p>
<p>Python，特指CPython的实现，由于GIL的存在，CPython不能有效的利用多核处理器。表现为任意时间一个进程只有一个线程在跑，而IO密集型运算，多数是在IO读写将线程堵塞掉了，这个时候线程切换是很合理的，反正线程只是单纯地等待，在这个等待的时候去做其他的事情，资源利用率就上去了。</p>
<p>在大型的计算机集群系统中，通常都会将多进程程序分布运行在不同的计算机上协同工作。而每一台计算机上的进程内部，又会由多个线程来并行工作。</p>
<p>注意，对于任务数来说，无论是多进程编程或者多线程编程，其进程数或线程数都不能太多：</p>
<ul>
<li>对于多进程编程来说，操作系统在切换任务时，会有一系列的保护现场措施，这要花费相当多的系统资源，若任务过多，则大部分资源都被用做干这些了，结果就是所有任务都做不好；</li>
<li>多线程编程也不是线程个数越多效率越高，通过下面的公式可以计算出线程数量最优的一个参考值。</li>
</ul>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848694.gif" alt="img"></p>
<h3 id="线程的生命周期和状态"><a href="#线程的生命周期和状态" class="headerlink" title="线程的生命周期和状态?"></a>线程的生命周期和状态?</h3><p>new，runnable(就绪和运行)，blocked，waiting，time_waiting， terminated; </p>
<h3 id="线程死锁的四个必要条件"><a href="#线程死锁的四个必要条件" class="headerlink" title="线程死锁的四个必要条件?"></a>线程死锁的四个必要条件?</h3><p>互斥，请求和保持，不可剥夺，循环等待;</p>
<h3 id="死锁处理方案"><a href="#死锁处理方案" class="headerlink" title="死锁处理方案?"></a>死锁处理方案?</h3><p>破坏4个必要条件;银行家算法;死锁的检测与恢复;</p>
<h3 id="sleep-和wait"><a href="#sleep-和wait" class="headerlink" title="sleep()和wait()"></a>sleep()和wait()</h3><p>sleep()不释放锁，wait()释放锁;wait()用于线程间交互&#x2F;通信，sleep用于暂停执行;wait需要别的对象调用同一对象上的notify()和notifyAll()或者使用wait(long timeout)自动苏醒;</p>
<h3 id="Start-和Run"><a href="#Start-和Run" class="headerlink" title="Start()和Run()"></a>Start()和Run()</h3><p>new 一个 Thread，线程进入了新建状态。调用 start()方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 start() 会执行线程的相应准备工作，然后自动执行 run() 方法的内容，这是真正的多线程工作。 但是，直接执行 run() 方法，会把 run() 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p>
<h4 id="创建线程的3种方式"><a href="#创建线程的3种方式" class="headerlink" title="创建线程的3种方式"></a>创建线程的3种方式</h4><ul>
<li><p>继承thread类，重写run方法，调用start()开启线程，不建议使用，避免oop(object-oriented programming)单继承局限性; Thread类也实现了Runable接口，Thread类里面的start方法调用native的start方法，也就是有操作系统来创建线程。</p>
</li>
<li><p>实现runnable接口，重写run方法， new Thread(p).start() (推荐);避免单继承局限性，灵活方便，方便同一个对象被多个线程使用，（用到了代理模式），这里可以使用匿名内部类</p>
</li>
<li><p>实现Callable接口</p>
</li>
</ul>
<p>（1）创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。</p>
<p>（2）创建Callable实现类的实例，使用FutureTask(实现RunnableFutrue接口， 这个接口有继承Runnable接口)类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。</p>
<p>（3）使用FutureTask对象作为Thread对象的target创建并启动新线程。</p>
<p>（4）调用FutureTask对象的get()方法来获得子线程执行结束后的返回值</p>
<h3 id="停止线程"><a href="#停止线程" class="headerlink" title="停止线程"></a>停止线程</h3><p>不推荐使用jdk提供的stop()和destroy()方法; 推荐线程自己停下来， 使用一个标志位来终止; </p>
<p>Yield()礼让但不一定成功，让出cpu然后重新竞争; join (底层是wait方法， 每个线程退出的时候会调用notofyAll()(优先级高的优先被调度)方法，通知所有等待在该线程对象上的线程)会让自己停下来，等被自己插队的那个线程执行完才执行自己;</p>
<h3 id="CopyOnWriteArrayList（COW）"><a href="#CopyOnWriteArrayList（COW）" class="headerlink" title="CopyOnWriteArrayList（COW）"></a>CopyOnWriteArrayList（COW）</h3><p>concurrentModificationException 并发修改异常</p>
<p>vector是安全的； Collections.synchronizedList(); 使用JUC下的CopyOnWriteArrayList；</p>
<p>cow ： 在写入时候避免覆盖，造成数据问题；cow实现在jdk8之后的版本改成了synchronized，比lock更高效；</p>
<p>多线程同时写也不会出问题， 使用volatile修饰， 使用了reentrantlock</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jdk 8</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object[] elements = getArray();</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line">            <span class="comment">// 复制一份</span></span><br><span class="line">            Object[] newElements = Arrays.copyOf(elements， len + <span class="number">1</span>);</span><br><span class="line">            newElements[len] = e;</span><br><span class="line">            setArray(newElements);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="Fail-fast-快速失败-和-fail-safe-安全失败"><a href="#Fail-fast-快速失败-和-fail-safe-安全失败" class="headerlink" title="Fail-fast(快速失败) 和 fail-safe(安全失败)"></a>Fail-fast(快速失败) 和 fail-safe(安全失败)</h3><p>fail-safe允许在遍历的过程中对容器中的数据进行修改，而fail-fast则不允许。</p>
<p> <strong>fail-fast ( 快速失败 )</strong></p>
<p>fail-fast:直接在容器上进行遍历，在遍历过程中，一旦发现容器中的数据被修改了，会立刻抛出ConcurrentModificationException异常导致遍历失败。java.util包下的集合类都是快速失败机制的， 常见的的使用fail-fast方式遍历的容器有HashMap和ArrayList等。</p>
<p>在使用迭代器遍历一个集合对象时，比如增强for，如果遍历过程中对集合对象的内容进行了修改(增删改)，会抛出ConcurrentModificationException 异常.</p>
<p>fail-fast的出现场景<br>在我们常见的java集合中就可能出现fail-fast机制，比如ArrayList，HashMap。在多线程和单线程环境下都有可能出现快速失败。</p>
<p>避免fail-fast的方法：</p>
<p>方法1</p>
<p>在单线程的遍历过程中，如果要进行remove操作，可以调用迭代器的remove方法而不是集合类的remove方法</p>
<p>方法2</p>
<p>使用fail-safe机制，使用java并发包(java.util.concurrent)中的CopyOnWriterArrayList类来代替ArrayList，使用 ConcurrentHashMap来代替hashMap。</p>
<p><strong>fail-safe ( 安全失败 )</strong><br>fail-safe:这种遍历基于容器的一个克隆。因此，对容器内容的修改不影响遍历。java.util.concurrent包下的容器都是安全失败的，可以在多线程下并发使用，并发修改。常见的的使用fail-safe方式遍历的容器有ConcerrentHashMap和CopyOnWriteArrayList等。</p>
<p>原理：</p>
<p>采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception。</p>
<p>缺点：基于拷贝内容的优点是避免了Concurrent Modification Exception，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。</p>
<h3 id="concurrentModificationException-并发修改异常"><a href="#concurrentModificationException-并发修改异常" class="headerlink" title="concurrentModificationException 并发修改异常"></a>concurrentModificationException 并发修改异常</h3><p>在并发情况下，多个线程同时读写可能会报这个异常</p>
<p>vector是安全的； Collections.synchronizedList(); 使用JUC下的CopyOnWriteArrayList；</p>
<p>cow ： 在写入时候避免覆盖，造成数据问题；cow后面改成了synchronized，比lock更高效；</p>
<h3 id="ArrayIndexOutOfBoundsException"><a href="#ArrayIndexOutOfBoundsException" class="headerlink" title="ArrayIndexOutOfBoundsException"></a>ArrayIndexOutOfBoundsException</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> syn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Huang Mingwang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-04-25 9:37 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestArrayList</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        ArrayList&lt;String&gt; strings = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">101</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">0</span>; i1 &lt; <span class="number">20</span>; i1++) &#123;</span><br><span class="line">                    strings.add(UUID.randomUUID().toString().substring(<span class="number">0</span>，<span class="number">5</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(strings.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="CopyOnWriteSet"><a href="#CopyOnWriteSet" class="headerlink" title="CopyOnWriteSet"></a>CopyOnWriteSet</h3><p>collections.synchronizedSet(); </p>
<h3 id="两个线程交替打印1-100"><a href="#两个线程交替打印1-100" class="headerlink" title="两个线程交替打印1-100"></a>两个线程交替打印1-100</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * synchronized实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doSynchronized1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Number</span> <span class="variable">number</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Number</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            number.odd();</span><br><span class="line">        &#125;， <span class="string">&quot;odd&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            number.even();</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Number</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">TOTAL</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">even</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= TOTAL) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;i=&quot;</span> + i++);</span><br><span class="line">                <span class="built_in">this</span>.notify();</span><br><span class="line">                System.out.println(<span class="string">&quot;偶数打印完毕，释放锁&quot;</span>);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;偶数锁等待&quot;</span>);</span><br><span class="line">                    <span class="built_in">this</span>.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">odd</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= TOTAL) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;i=&quot;</span> + i++);</span><br><span class="line">                <span class="built_in">this</span>.notify();</span><br><span class="line">                System.out.println(<span class="string">&quot;奇数打印完毕，释放锁&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;奇数锁等待&quot;</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">this</span>.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * lock实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doLock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Number2</span> <span class="variable">number2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Number2</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            number2.odd();</span><br><span class="line">        &#125;， <span class="string">&quot;odd&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            number2.even();</span><br><span class="line">        &#125;， <span class="string">&quot;even&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Number2</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">TOTAL</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">even</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt;= TOTAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;i=&quot;</span> + i++);</span><br><span class="line">                    condition.signal();</span><br><span class="line">                    System.out.println(<span class="string">&quot;偶数打印完毕，释放锁&quot;</span>);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;偶数锁等待&quot;</span>);</span><br><span class="line">                        condition.await();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">odd</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt;= TOTAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;i=&quot;</span> + i++);</span><br><span class="line">                    condition.signal();</span><br><span class="line">                    System.out.println(<span class="string">&quot;奇数打印完毕，释放锁&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;奇数锁等待&quot;</span>);</span><br><span class="line">                        condition.await();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><p>允许一个或多个线程等待直到在其他线程中执行的一组操作完成的同步辅助;CAS思想;减法计数器;可以一个线程里countdown很多次，不一定要在多个线程里；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">countDownLatch.countDown(); <span class="comment">// 数量-1</span></span><br><span class="line">        countDownLatch.await(); <span class="comment">// 等待计数器归零，然后向下执行</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><p>加法计数器，底层使用reentrantlock， 如果计数器到达了设置值，则会新建一个线程去执行;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> add;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Huang Mingwang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-04-26 4:10 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrierDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CyclicBarrier</span> <span class="variable">success</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">8</span>， () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;收集&quot;</span>+temp+<span class="string">&quot;个龙珠&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 等到7个然后执行success</span></span><br><span class="line">                    success.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Semaphore-类"><a href="#Semaphore-类" class="headerlink" title="Semaphore(类)"></a>Semaphore(类)</h3><p>底层CAS</p>
<h3 id="ReadWriteLock-接口"><a href="#ReadWriteLock-接口" class="headerlink" title="ReadWriteLock(接口)"></a>ReadWriteLock(接口)</h3><p>读可以多线程同时读，写只能一个写;读锁是为了防止读的时候有线程写入; ReentrantReadWriteLock()默认读优先，对写不公平;</p>
<h3 id="BlockingQueue-接口"><a href="#BlockingQueue-接口" class="headerlink" title="BlockingQueue(接口)"></a>BlockingQueue(接口)</h3><p>多线程，线程池会使用; </p>
<p>add() 可能报IllegalStateException异常， remove() 可能报NoSuchElementException异常，有返回值抛异常; </p>
<p>offer()， poll()有返回值，不抛异常 ， offer(d， 2，TimeUnit.SECONDS)， poll(2， TImeUnit.SECONDS) 可以设置等待时间;</p>
<p> element() peek()返回队首元素; </p>
<p> put()， take() 会等待，直到能操作成功;  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        ArrayBlockingQueue&lt;Object&gt; objects = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        System.out.println(objects.add(<span class="string">&quot;a&quot;</span>));</span><br><span class="line">        System.out.println(objects.add(<span class="string">&quot;a&quot;</span>));</span><br><span class="line">        System.out.println(objects.add(<span class="string">&quot;a&quot;</span>));</span><br><span class="line">        System.out.println(objects.add(<span class="string">&quot;a&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//java.lang.IllegalStateException: Queue full</span></span><br><span class="line"><span class="comment">//java.util.NoSuchElementException</span></span><br></pre></td></tr></table></figure>

<h3 id="SynchronizedQueue-类"><a href="#SynchronizedQueue-类" class="headerlink" title="SynchronizedQueue(类)"></a>SynchronizedQueue(类)</h3><p>没有容量， 进去一个元素， 必须等待取出来之后，才能再往里面放一个元素; put() take(); </p>
<h2 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u012403290/article/details/64910926">https://blog.csdn.net/u012403290/article/details/64910926</a></p>
<p>必须可重入，例如子类重写父类方法，都加了synchronized，这个时候子类方法里会调用super（）方法，如果不可重入就会死锁；最好不要锁string字符串；</p>
<p>jdk早期版本属于重量级锁; 可重入锁;JVM层面; 非公平锁; 内置关键字，隐形锁;线程异常时自动释放锁，不会发生死锁; 非中断锁，必须等线程执行完才释放锁; 代码块同步: 通过使用monitorenter和monitorexit指令实现的; 同步方法: ACC_SYNCHRONIZED修饰;有对象锁和类锁（static方法和class上枷锁）区分，两者不冲突可以并行存在; </p>
<p>synchronized关键字与wait()和notify()&#x2F;notifyAll()方法相结合可以实现等待&#x2F;通知机制;</p>
<p> wait()和notify()只能在同步代码块中使用;</p>
<p>监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高。庆幸的是在 Java 6 之后 Java 官方对从 JVM 层面对 synchronized 较大优化，所以现在的 synchronized 锁效率也优化得很不错了.</p>
<h3 id="深入分析wait-x2F-notify为什么要在同步块内"><a href="#深入分析wait-x2F-notify为什么要在同步块内" class="headerlink" title="深入分析wait&#x2F;notify为什么要在同步块内"></a>深入分析wait&#x2F;notify为什么要在同步块内</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/lsgqjh/article/details/61915074">https://blog.csdn.net/lsgqjh/article/details/61915074</a></p>
<p>notify不释放锁，得让你自己wait释放锁，才能notify</p>
<p>Java API 强制要求这样做，如果你不这么做，你的代码会抛出IllegalMonitorStateException 异常。还有一个原因是为了避免 wait 和 notify之间产生竞态条件，生产者线程向缓冲区中写入数据，消费者线程从缓冲区中读取数据。消费者线程需要等待直到生产者线程完成一次写入操作。</p>
<p>生产者线程需要等待消费者线程完成一次读取操作。假设wait()，notify()，notifyAll()方法不需要加锁就能够被调用。此时消费者线程调用wait()正在进入状态变量的等待队列(译者注:可能还未进入)。在同一时刻，生产者线程调用notify()方法打算向消费者线程通知状态改变。那么此时消费者线程将错过这个通知并一直阻塞。因此，对象的wait()，notify()，notifyAll()方法必须在该对象的同步方法或同步代码块中被互斥地调用。</p>
<h3 id="虚假唤醒问题"><a href="#虚假唤醒问题" class="headerlink" title="虚假唤醒问题"></a>虚假唤醒问题</h3><p>当一个条件满足时，很多线程都被唤醒了，但是只有其中部分是有用的唤醒，其它的唤醒都是无用功；<br>比如买货：如果商品本来没有货物，突然进了一件商品，这是所有的线程都被唤醒了，但是只能一个人买，所以其他人都是假唤醒，获取不到对象的锁；</p>
<h4 id="虚假唤醒是如何产生的？"><a href="#虚假唤醒是如何产生的？" class="headerlink" title="虚假唤醒是如何产生的？"></a>虚假唤醒是如何产生的？</h4><p>　　把 while (number !&#x3D; 0) {}</p>
<p>　　换成 if (number &#x3D;&#x3D; 0) {}</p>
<p>　　就会出现虚假唤醒。官方文档有标注；</p>
<h4 id="为什么if判断会出现虚假唤醒？"><a href="#为什么if判断会出现虚假唤醒？" class="headerlink" title="为什么if判断会出现虚假唤醒？"></a>为什么if判断会出现虚假唤醒？</h4><p>  　　1. 因为if只会执行一次，执行完会接着向下执行if（）外边的</p>
<pre><code>    　　2. 而while不会，直到条件满足才会向下执行while（）外边的
</code></pre>
<h3 id="8锁现象-关于锁的8个问题"><a href="#8锁现象-关于锁的8个问题" class="headerlink" title="8锁现象(关于锁的8个问题)"></a>8锁现象(关于锁的8个问题)</h3><h3 id="synchronized优化"><a href="#synchronized优化" class="headerlink" title="synchronized优化"></a>synchronized优化</h3><p>锁的四种状态: 无锁状态，偏向锁状态，轻量级锁状态，重量级锁;锁可以升级，但不能降级;</p>
<p>偏向锁是针对于一个线程而言的， 线程获得锁之后就不会再有解锁等操作了，假如有两个线程来竞争该锁的话， 那么偏向锁就失效了， 进而升级成轻量级锁了.因为大部分情况下， 都会是同一个线程进入同一块同步代码块的. 这也是为什么会有偏向锁出现的原因.在Jdk1.6中， 偏向锁的开关是默认开启的， 适用于只有一个线程访问同步块的场景. -XX:BiasedLockingStartupDelay&#x3D;0来关闭偏向锁的启动延迟， 也可以使用-XX:-UseBiasedLocking&#x3D;false来关闭偏向锁， 那么程序会直接进入轻量级锁状态.</p>
<p>轻量级锁: CAS思想;竞争的线程不会阻塞， 提高了程序的响应速度;如果始终得不到锁竞争的线程， 使用自旋会消耗CPU;</p>
<p>重量级锁: 线程竞争不适用自旋， 不会消耗CPU;线程堵塞， 响应时间缓慢</p>
<h4 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h4><p>锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除。<br>锁消除主要是通过逃逸分析来支持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成私有数据对待，也就可以将它们的锁进行消除。对于一些看起来没有加锁的代码，其实隐式的加了很多锁。例如下面的字符串拼接代码就隐式加了锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">concatString</span><span class="params">(String s1， String s2， String s3)</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> s1 + s2 + s3; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// String 是一个不可变的类，编译器会对 String 的拼接自动优化。在 JDK 1.5 之前，会转化为 StringBuffer 对象的连续 append() 操作：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">concatString</span><span class="params">(String s1， String s2， String s3)</span> &#123; </span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(); </span><br><span class="line">    sb.append(s1); </span><br><span class="line">    sb.append(s2); </span><br><span class="line">    sb.append(s3); </span><br><span class="line">    <span class="keyword">return</span> sb.toString(); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 每个 append() 方法中都有一个同步块。虚拟机观察变量 sb，很快就会发现它的动态作用域被限制在 concatString() 方法内部。也就是说，sb 的所有引用永远不会逃逸到 concatString() 方法之外，其他线程无法访问到它，因此可以进行消除。</span></span><br></pre></td></tr></table></figure>

<h4 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h4><p>如果一系列的连续操作都对同一个对象反复加锁和解锁，频繁的加锁操作就会导致性能损耗。<br>上一节的示例代码中连续的 append() 方法就属于这类情况。如果虚拟机探测到由这样的一串零碎的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部。对于上一节的示例代码就是扩展到第一个 append() 操作之前直至最后一个 append() 操作之后，这样只需要加锁一次就可以了。</p>
<h2 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h2><p>conditon代替对象监视器; await ， signal，只能在同步代码块中使用;</p>
<h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p>显性锁，可重入锁; JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try&#x2F;finally 语句块来完成); 等待可中断; 可实现公平锁(默认是非公平的); 底层是CAS乐观锁，依赖AbstractQueuedSynchronizer类，把所有的请求线程构成一个CLH队列。而对该队列的操作均通过Lock-Free（CAS）操作; 适合锁大量的代码块;</p>
<h2 id="可重入锁、读写锁、公平锁、可中断锁"><a href="#可重入锁、读写锁、公平锁、可中断锁" class="headerlink" title="可重入锁、读写锁、公平锁、可中断锁"></a>可重入锁、读写锁、公平锁、可中断锁</h2><h5 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h5><p>Synchronized和ReentrantLook都是可重入锁，锁的可重入性标明了锁是针对线程分配方式而不是针对方法。例如调用Synchronized方法A中可以调用Synchronized方法B，而不需要重新申请锁。</p>
<h5 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h5><p>按照数据库事务隔离特性的类比读写锁，在访问统一个资源（一个文件）的时候，使用读锁来保证多线程可以同步读取资源。ReadWriteLock是一个读写锁，通过readLock()获取读锁，通过writeLock()获取写锁。</p>
<h5 id="可中断锁"><a href="#可中断锁" class="headerlink" title="可中断锁"></a>可中断锁</h5><p>可中断是指锁是可以被中断的，Synchronized内置锁是不可中断锁，ReentrantLock可以通过lockInterruptibly方法中断显性锁。例如线程B在等待等待线程A释放锁，但是线程B由于等待时间太久，可以主动中断等待锁。</p>
<h5 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h5><p>多个线程按照申请锁的顺序去获得锁，线程会直接进入队列去排队，永远都是队列的第一位才能得到锁。synchronized隐性锁是非公平锁，它无法保证等待的线程获取锁的顺序，ReentrantLook可以自己控制是否公平锁。公平锁先来后到，对短任务不友好，所以默认非公平锁，可以插队; </p>
<p>优点：所有的线程都能得到资源，不会饿死在队列中。</p>
<p>缺点：吞吐量会下降很多，队列里面除了第一个线程，其他的线程都会阻塞，cpu唤醒阻塞线程的开销会很大， 对短任务不友好;</p>
<h5 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h5><p>多个线程去获取锁的时候， 会直接去尝试获取，获取不到，再去进入到等待队列， 如果能获取到， 就直接获取到锁.</p>
<p>优点:  可以减少CPU唤醒线程的开销， 整体的吞吐效率会高点， CPU也不必唤醒所有线程， 会减少唤起线程的数量;</p>
<p>缺点:  容易饿死， 可能会导致线程中间的线程一直获取不到锁或者长时间获取不到锁，导致饿死.这么多个线程应cas去尝试会浪费cpu;</p>
<h2 id="Synchronized和Lock比较"><a href="#Synchronized和Lock比较" class="headerlink" title="Synchronized和Lock比较"></a>Synchronized和Lock比较</h2><ul>
<li>Synchronized是关键字，内置语言实现，Lock是接口。</li>
<li>Synchronized在线程发生异常时会自动释放锁，因此不会发生异常死锁。Lock异常时不会自动释放锁，所以需要在finally中实现释放锁。</li>
<li>Lock是可以中断锁，Synchronized是非中断锁，必须等待线程执行完成释放锁。</li>
<li>Lock可以使用读锁提高多线程读效率。</li>
</ul>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848702.png" alt="image-20210605202825290"></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yaowen/p/11240540.html">https://www.cnblogs.com/yaowen/p/11240540.html</a></p>
<p> 可见性，不保证原子性，禁止指令重排;</p>
<p>指令重排: 源代码- 编译器优化重排-指令并行也可能会重排-内存系统也会重排-执行; 在DCL单例模式用的多;</p>
<p>volatile作用：</p>
<p>1.锁总线，其它CPU对内存的读写请求都会被阻塞，直到锁释放，不过实际后来的处理器都采用锁缓存替代锁总线，因为锁总线的开销比较大，锁总线期间其他CPU没法访问内存</p>
<p>2.lock后的写操作会回写已修改的数据，同时让其它CPU相关缓存行失效，从而重新从主存中加载最新的数据</p>
<p>3.<strong>不是内存屏障却能完成类似内存屏障的功能，阻止屏障两遍的指令重排序</strong></p>
<p>被volatile修饰的变量在编译成字节码文件时会多个lock指令，该指令在执行过程中会生成相应的<strong>内存屏障</strong>，以此来解决可见性跟重排序的问题。</p>
<p>内存屏障的作用：<br>1.在有内存屏障的地方，会禁止指令重排序，即屏障下面的代码不能跟屏障上面的代码交换执行顺序。<br>2.在有内存屏障的地方，线程修改完共享变量以后会马上把该变量从本地内存写回到主内存，<strong>并且让其他线程本地内存中该变量副本失效（使用MESI协议）</strong></p>
<p>JSR内存屏障可以被分为以下几种类型(JVM的要求， 具体hotpsot使用lock机制来实现)<br><strong>LoadLoad屏障：</strong>对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。<br><strong>StoreStore屏障：</strong>对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。<br><strong>LoadStore屏障：</strong>对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。<br><strong>StoreLoad屏障：</strong>对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的。     在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能。</p>
<p>为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎不可能，为此，JMM采取保守策略。下面是基于保守策略的JMM内存屏障插入策略：</p>
<ol>
<li>在每个volatile写操作的前面插入一个StoreStore屏障。</li>
<li>在每个volatile写操作的后面插入一个StoreLoad屏障。</li>
<li>在每个volatile读操作的后面插入一个LoadLoad屏障。</li>
<li>在每个volatile读操作的后面插入一个LoadStore屏障。</li>
</ol>
<p>上述内存屏障插入策略非常保守，但它可以保证在任意处理器平台，任意的程序中都能得到正确的volatile内存语义。</p>
<p>volatile关键字修饰的变量会存在一个lock:的前缀; </p>
<p>Lock前缀，lock不是一种内存屏障，但是它能完成内存屏障的功能. lock会对CPU总线和高速缓存行加锁，可以理解为CPU指令级的锁. 类似于lock指令. 在具体执行上， 它先对总线和缓存加锁，然后执行后面的指令， 在lock锁住总线的时候，其他cpu读写请求都会被阻塞， 直到锁被释放. 最后释放锁后会把高速缓存中的脏数据全部刷新回主内存， 且这个写回内存的操作会使在其他cpu里缓存了该地址的数据无效.</p>
<p>当线程b发现对应地址的缓存行被锁了，等待锁的释放， 缓存一致性协议会保证它读取到最新的值(重新从主存中读取， 因为有总线锁，如果线程a还没写回，b无法读取内存的东西，总线被锁住了) </p>
<p> volatile是“轻量级”synchronized，保证了共享变量的“可见性”（JMM确保所有线程看到这个变量的值是一致的），当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态并且锁住缓存行，因此当其他CPU需要读取这个变量时，要等锁释放，并发现自己缓存行是无效的，那么它就会从内存重新读取。</p>
<p> volatile是“轻量级”synchronized，保证了共享变量的“可见性”（JMM确保所有线程看到这个变量的值是一致的），使用和执行成本比synchronized低，因为它不会引起线程上下文切换和调度。</p>
<hr>
<p>工作内存Work Memory其实就是对CPU寄存器和高速缓存的抽象，或者说每个线程的工作内存也可以简单理解为CPU寄存器和高速缓存。</p>
<h3 id="volatile无法保证共享变量i-线程安全原因-JVM字节码层面"><a href="#volatile无法保证共享变量i-线程安全原因-JVM字节码层面" class="headerlink" title="volatile无法保证共享变量i++线程安全原因(JVM字节码层面)"></a>volatile无法保证共享变量i++线程安全原因(JVM字节码层面)</h3><p>volatile是为了解决JMM带来的变量可见性问题。</p>
<p>如果共享变量i++也和局部变量i++的执行流程相同：直接将局部变量中i值自增加1，那么volatile不就能保证多线程数据安全了？众所周知，volatile无法保证原子性，它只保证可见性。来看看JVM的具体实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//行数2</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        i++;<span class="comment">//行数4</span></span><br><span class="line">    &#125;<span class="comment">//行数5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Compiled from <span class="string">&quot;Demo.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(java.lang.String[])</span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: getstatic     #<span class="number">2</span>   <span class="comment">// Field i:I    //获取静态共享变量i的值放入操作数栈顶</span></span><br><span class="line">       <span class="number">3</span>: iconst_1                           <span class="comment">//将整数1推到栈顶</span></span><br><span class="line">       <span class="number">4</span>: iadd                               <span class="comment">//将栈顶两int值相加并将结果压入栈顶</span></span><br><span class="line">       <span class="number">5</span>: putstatic     #<span class="number">2</span>   <span class="comment">// Field i:I    //将栈顶的值同步回主存</span></span><br><span class="line">       <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line <span class="number">4</span>: <span class="number">0</span>    <span class="comment">//共享变量i++，包含了0、3、4、5的代码执行</span></span><br><span class="line">      line <span class="number">5</span>: <span class="number">8</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;&#125;;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: iconst_0</span><br><span class="line">       <span class="number">1</span>: putstatic     #<span class="number">2</span>   <span class="comment">// Field i:I</span></span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line <span class="number">2</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>总结：static共享变量i++：分3步，一.获取变量i的值，二.值加1，三.加1后的值写回i中。伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> i;</span><br><span class="line">temp = temp + <span class="number">1</span>;</span><br><span class="line">i = temp;</span><br></pre></td></tr></table></figure>

<p>很明显了，原因就是java共享变量的运算操作符不是原子操作！（字节码层面。其实不够严谨，因为就算编译出来只有一条字节码指令，JVM解释器也会运行多行代码解释执行或即时编译器也会编译成多行本地机器码执行，使用 -XX:+PrintAssembly 参数输出反汇编来分析会更严谨些，但这里字节码层面已经足以说明问题）</p>
<p>多线程环境，假设A、B线程同时执行，都执行到了第二步，B线程先执行结束i&#x3D;1，因为变量i是volatile类型，所以B线程执行结束马上刷新工作线程中i&#x3D;1到主存，并且通知其它cpu中线程：主存中i的值更新了，使A工作线程中缓存的i失效。如果A线程这时候使用到变量i，就需要去主存重新copy一份副本到自己的工作内存。但是这时候A执行到了temp &#x3D; temp + 1，已经用临时变量temp记录了之前i的值，不需要再读取i的值了。所以，虽然变量i的值0在A的工作内存中确实失效了，但是值temp仍然是有效的，既然有效，A就会将第三步的结果i&#x3D;1再次写入主存，覆盖了之前B线程写入的值。这就是为什么volatile无法保证共享变量i++线程安全的原因。简单讲就是volatile关键字只保证了 “0: getstatic” 获取到的是主存中最新的值，不保证 “4: iadd” 执行时操作栈中的值是主存最新的。</p>
<p>其实，这些都是JMM Java内存模型带来的数据问题：可见性、有序性、原子性。volatile是JDK提供的解决JMM数据可见性的关键字（volatile还保证了有序性），JVM实现volatile内存可见性语义，上面反汇编得到的代码就是JVM的具体实现流程。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202203170824569.png" alt="image-20220317082451317"></p>
<p>new 申请内存，4 调用构造方法赋初始值。 如果4、7互换的话就会有问题，先把内存地址放回去，再赋值。这样就会导致有些线程拿到半初始化的对象。</p>
<h3 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h3><p>java内存模型主要定义了各种变量的访问规则;</p>
<p>Java内存模型（Java Memory Model ，JMM）(指JDK5的新模型)就是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能保证效果一致的机制及规范。</p>
<p>Java内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程中是用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。而JMM就作用于工作内存和主存之间数据同步过程。他规定了如何做数据同步以及什么时候做数据同步。<strong>JMM是一种规范，目的是解决由于多线程通过共享内存进行通信时，存在的本地内存数据不一致、编译器会对代码指令重排序、处理器会对代码乱序执行等带来的问题。</strong></p>
<p>在开发多线程的代码的时候，我们可以直接使用synchronized等关键字来控制并发，从来就不需要关心底层的编译器优化、缓存一致性等问题。所以，Java内存模型，除了定义了一套规范，还提供了一系列原语，封装了底层实现后，供开发者直接使用。</p>
<p>Jdk1.2之前，都是从主存中读取变量; 而在当前的 Java 内存模型下，线程可以把变量保存<strong>本地内存</strong>（比如机器的寄存器）中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成<strong>数据的不一致</strong>。</p>
<img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848717.png" alt="JMM(Java内存模型)" style="zoom:50%;" />

<p>volatile指示JVM这个变量是共享且不稳定的，每次使用它都到主存中去读取; 防止指令重排;保证变量的可见性;</p>
<img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848004.png" alt="volatile关键字的可见性" style="zoom:50%;" />

<p>同步约定: 线程解锁前，必须把共享变量立刻刷回主存; 线程加锁前， 必须读取主存中的最新的值到工作内存中; 加锁和解锁是同一把锁; </p>
<p>8种操作</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848038.png" alt="image-20210427084129374"></p>
<p>8种操作如下：</p>
<ul>
<li>lock(锁定)：作用于主内存，它把一个变量标记为一条线程独占状态；</li>
<li>read(读取)：作用于主内存，它把变量值从主内存传送到线程的工作内存中，以便随后的load动作使用；</li>
<li>load(载入)：作用于工作内存，它把read操作的值放入工作内存中的变量副本中；</li>
<li>use(使用)：作用于工作内存，它把工作内存中的值传递给执行引擎，每当虚拟机遇到一个需要使用这个变量的指令时候，将会执行这个动作；</li>
<li>assign(赋值)：作用于工作内存，它把从执行引擎获取的值赋值给工作内存中的变量，每当虚拟机遇到一个给变量赋值的指令时候，执行该操作；</li>
<li>store(存储)：作用于工作内存，它把工作内存中的一个变量传送给主内存中，以备随后的write操作使用；</li>
<li>write(写入)：作用于主内存，它把store传送值放到主内存中的变量中。</li>
<li>unlock(解锁)：作用于主内存，它将一个处于锁定状态的变量释放出来，释放后的变量才能够被其他线程锁定；</li>
</ul>
<p>Java内存模型还规定了执行上述8种基本操作时必须满足如下规则:</p>
<p>（1）不允许read和load、store和write操作之一单独出现（即不允许一个变量从主存读取了但是工作内存不接受，或者从工作内存发起会写了但是主存不接受的情况），以上两个操作必须按顺序执行，但没有保证必须连续执行，也就是说，read与load之间、store与write之间是可插入其他指令的。</p>
<p>（2）不允许一个线程丢弃它的最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。</p>
<p>（3）不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存中。</p>
<p>（4）一个新的变量只能从主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量，换句话说就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。</p>
<p>（5）一个变量在同一个时刻只允许一条线程对其执行lock操作，但lock操作可以被同一个条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。</p>
<p>（6）如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值。</p>
<p>（7）如果一个变量实现没有被lock操作锁定，则不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定的变量。</p>
<p>（8）对一个变量执行unlock操作之前，必须先把此变量同步回主内存（执行store和write操作）。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202203170828921.png" alt="image-20220317082858813"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202203170831463.png" alt="image-20220317083152370"></p>
<h4 id="缓存行对齐的问题-伪共享问题"><a href="#缓存行对齐的问题-伪共享问题" class="headerlink" title="缓存行对齐的问题 伪共享问题"></a>缓存行对齐的问题 伪共享问题</h4><p>一个cacheline 一般64字节。 </p>
<p>位于同一缓存行的两个不同数据，被两个不同CPU锁定，产生互相影响的伪共享问题。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202203170846129.png" alt="image-20220317084654866"></p>
<p>disruptor 框架</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202203170851968.png" alt="image-20220317085127676"></p>
<p>前后7个long，怎么都不会混在别的缓存行里面。</p>
<h3 id="并发编程的三个重要特性"><a href="#并发编程的三个重要特性" class="headerlink" title="并发编程的三个重要特性"></a>并发编程的三个重要特性</h3><p>原子性;可见性;有序性</p>
<h3 id="synchronized和volatile的区别"><a href="#synchronized和volatile的区别" class="headerlink" title="synchronized和volatile的区别"></a>synchronized和volatile的区别</h3><ul>
<li>volatile 关键字是线程同步的轻量级实现，所以volatile性能比synchronized关键字要好。但是volatile 关键字只能用于变量而 synchronized 关键字可以修饰方法以及代码块。</li>
<li>volatile 关键字能保证数据的可见性，但不能保证数据的原子性。synchronized 关键字两者都能保证。</li>
<li>volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized 关键字解决的是多个线程之间访问资源的同步性。</li>
</ul>
<h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p>Java无法操作内存，Java可以调用C++，C++可以操作内存；java可以通过unsafe类操作内存；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取传入对象o在内存中偏移量为offset位置的值与期望值expected作比较。相等就把x值赋值给offset位置的值。方法返回true。不相等，就取消赋值，方法返回false。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapInt</span><span class="params">(Object o， <span class="type">long</span> offset，</span></span><br><span class="line"><span class="params">                                              <span class="type">int</span> expected，</span></span><br><span class="line"><span class="params">                                              <span class="type">int</span> x)</span>;</span><br></pre></td></tr></table></figure>

<p>CAS的全称为Compare And Swap，直译就是比较交换。是一条CPU的原子指令，其作用是让CPU先进行比较两个值是否相等，然后原子地更新某个位置的值，其实现方式是基于硬件平台的汇编指令，在intel的CPU中，使用的是cmpxchg指令，就是说CAS是靠硬件实现的，从而在硬件层面提升效率。</p>
<p>它是一个无锁的原子算法。所以它就是一个乐观锁，也就是不加锁。无锁也就没有加锁和解锁的过程，不存在阻塞，也就提高了效率，提高了CPU的吞吐量（单位时间内执行完成的操作条数就多了）。</p>
<h3 id="CPU实现原子操作的原理"><a href="#CPU实现原子操作的原理" class="headerlink" title="CPU实现原子操作的原理"></a>CPU实现原子操作的原理</h3><ol>
<li>测试并设置（Tetst-and-Set）</li>
<li>获取并增加（Fetch-and-Increment）</li>
<li>交换（Swap）</li>
<li>比较并交换（Compare-and-Swap）</li>
<li>加载链接&#x2F;条件存储（Load-Linked&#x2F;Store-Conditional）</li>
</ol>
<h4 id="处理器自动保证基本内存操作的原子性"><a href="#处理器自动保证基本内存操作的原子性" class="headerlink" title="处理器自动保证基本内存操作的原子性"></a>处理器自动保证基本内存操作的原子性</h4><p>首先处理器会自动保证基本的内存操作的原子性。处理器保证从系统内存当中读取或者写入一个字节是原子的，意思是当一个处理器读取一个字节时，其他处理器不能访问这个字节的内存地址。奔腾6和最新的处理器能自动保证单处理器对同一个缓存行里进行16&#x2F;32&#x2F;64位的操作是原子的，但是复杂的内存操作处理器不能自动保证其原子性，比如跨总线宽度，跨多个缓存行，跨页表的访问。但是处理器提供总线锁定和缓存锁定两个机制来保证复杂内存操作的原子性。</p>
<h4 id="通过总线锁定来保证原子性（类似于数据库表锁，重量级锁）"><a href="#通过总线锁定来保证原子性（类似于数据库表锁，重量级锁）" class="headerlink" title="通过总线锁定来保证原子性（类似于数据库表锁，重量级锁）"></a>通过总线锁定来保证原子性（类似于数据库表锁，重量级锁）</h4><p>总线锁定其实就是处理器使用了总线锁，所谓总线锁就是使用处理器提供的一个 LOCK# 信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以独占共享内存。但是该方法成本太大。因此有了下面的方式。</p>
<h4 id="通过缓存锁定来保证原子性（类似于数据库行锁）"><a href="#通过缓存锁定来保证原子性（类似于数据库行锁）" class="headerlink" title="通过缓存锁定来保证原子性（类似于数据库行锁）"></a>通过缓存锁定来保证原子性（类似于数据库行锁）</h4><p>在同一时刻只需保证对某个内存地址的操作是原子性即可，但总线锁定把CPU和内存之间通信锁住了，这使得锁定期间，其他处理器不能操作其他内存地址的数据，所以总线锁定的开销比较大，最近的处理器在某些场合下使用缓存锁定代替总线锁定。</p>
<p>所谓缓存锁定是指内存区域如果被缓存在处理器的缓存行中，并且在Lock 操作期间被锁定，那么当它执行操作写回到内存时，处理器不在总线上输出 LOCK# 信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性，因为缓存一致性机制会阻止同时修改两个以上处理器缓存的内存区域数据（这里和 volatile 的可见性原理相同），当其他处理器回写已被锁定的缓存行的数据时，会使缓存行无效。</p>
<p>注意：有两种情况下处理器不会使用缓存锁定</p>
<p>当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行时，则处理器会调用总线锁定。<br>有些处理器不支持缓存锁定，对于 Intel 486 和 Pentium 处理器，就是锁定的内存区域在处理器的缓存行也会调用总线锁定。</p>
<p>586之前的CPU，会通过<strong>LOCK</strong>锁总线的形式来实现原子操作。686开始则提供了存储一致性（Cache coherence），这是多处理的基础，也是原子操作的基础。</p>
<p>原子指令在软件上看来逻辑并不复杂，但在微架构上看，成本是很高的。如果把CPU和内存都看做是总线上的一个个独立的实体，有一个CPU要做CAS指令，这个CPU需要先从内存中读一个值，同时要在内存控制器上设置一个标志，保证其他CPU写不进去，等它比较完了，然后再决定写一个值回去，才会让其他CPU写入。</p>
<p>不同微架构实现有不同方法对行为进行优化，在鲲鹏920(是<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%8D%8E%E4%B8%BA/298705">华为</a>在2019年1月发布的数据中心高性能处理器)上，原子指令的请求需要在 L3Cache上进行排队，保证在原子操作的多个动作之间能维持原子指令要求的语义。这个排队本身也有成本。所以没有原子需要就不要轻易用原子变量，这其实是有成本的。</p>
<p>幸运的是，缓存一致性协议提供了原子性被保障的基础。举例来说，当遇到一个原子指令时，这个协议知道需要保证原子性。他首先获得对存储单元M的”独家所有权” （通过将其他包含M的缓存块中的拷贝都置为无效）。当获得独家所有权之后，这个协议会确保只有一个处理器能够访问这个块，而如果其他处理器在此时想要访问的话就会经历缓存缺失，接下来原子指令就可以执行。在原子指令持续期间，其他处理器不允许”偷走”这个块。具体来说，如果通过另一个处理器要求读或者写这个块，这个块就被”偷”了（如块被清理，块的状态被降级为无效）。在原子指令完成之前暴露块会破坏指令的原子性。</p>
<h3 id="CAS的问题-自旋浪费cpu资源"><a href="#CAS的问题-自旋浪费cpu资源" class="headerlink" title="CAS的问题  自旋浪费cpu资源"></a>CAS的问题  自旋浪费cpu资源</h3><p>循环时间太长；只能保存一个共享变量原子操作；ABA问题；CAS造成Cache一致性流量过大。</p>
<h5 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h5><p>与前女友复合后，她可能谈过多个。</p>
<p>CAS需要检查操作值有没有发生改变，如果没有发生改变则更新。但是存在这样一种情况：如果一个值原来是A，变成了B，然后又变成了A，那么在CAS检查的时候会发现没有改变，但是实质上它已经发生了改变，这就是所谓的ABA问题。对于ABA问题其解决方案是加上版本号，即在每个变量都加上一个版本号，每次改变时加1，即A —&gt; B —&gt; A，变成1A —&gt; 2B —&gt; 3A。</p>
<p>从Java1.5 开始JDK的atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。其实就类似于引入了版本概念，给每一个数据都有一个它唯一的版本号，通关检查版本号来判断数据是否被修改。</p>
<h5 id="一致性流量过大问题"><a href="#一致性流量过大问题" class="headerlink" title="一致性流量过大问题"></a>一致性流量过大问题</h5><p>现在几乎所有的锁都是可重入的，即已经获得锁的线程可以多次锁住&#x2F;解锁监视对象，按照之前的HotSpot设计，每次加锁&#x2F;解锁都会涉及到一些CAS操作（比如对等待队列的CAS操作），CAS操作会延迟本地调用（使本地调用不是那么及时），因此偏向锁的想法是一旦线程第一次获得了监视对象，之后让监视对象“偏向”这个线程，之后的多次调用则可以避免CAS操作，说白了就是置个变量，如果发现为true则无需再走各种加锁&#x2F;解锁流程。轻量级锁就是基于CAS操作的。</p>
<p>CAS为什么会引入本地延迟？这要从SMP（对称多处理器）架构说起，下图大概表明了SMP的结构：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202203150937200.png" alt="img"></p>
<p>其意思是 所有的CPU会共享一条系统总线（BUS），靠此总线连接主存。每个核都有自己的一级缓存，各核相对于BUS对称分布，因此这种结构称为“对称多处理器”。</p>
<p>而CAS的全称为Compare-And-Swap，是一条CPU的原子指令，其作用是让CPU比较后原子地更新某个位置的值，其实现方式是基于硬件平台的汇编指令，就是说CAS是靠硬件实现的，JVM只是封装了汇编调用，那些AtomicInteger类便是使用了这些封装后的接口。</p>
<p>例如：Core1和Core2可能会同时把主存中某个位置的值Load到自己的L1 Cache中，当Core1在自己的L1 Cache中修改这个位置的值时，会通过总线，使Core2中L1 Cache对应的值“失效”，而Core2一旦发现自己L1 Cache中的值失效（称为Cache命中缺失）则会通过总线从内存中加载该地址最新的值，大家通过总线的来回通信称为“Cache一致性流量”，因为总线被设计为固定的“通信能力”，如果Cache一致性流量过大，总线将成为瓶颈。而当Core1和Core2中的值再次一致时，称为“Cache一致性”，从这个层面来说，锁设计的终极目标便是减少Cache一致性流量。</p>
<p>而CAS恰好会导致Cache一致性流量，如果有很多线程都共享同一个对象，当某个Core CAS成功时必然会引起总线风暴，这就是所谓的本地延迟，本质上偏向锁就是为了消除CAS，降低Cache一致性流量。</p>
<p>相关参考：</p>
<p>Cache一致性：<br>上面提到Cache一致性，其实是有协议支持的，现在通用的协议是MESI（最早由Intel开始支持），具体参考：<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/MESI_protocol%E3%80%82">http://en.wikipedia.org/wiki/MESI_protocol。</a></p>
<p>Cache一致性流量的例外情况：<br>其实也不是所有的CAS都会导致总线风暴，这跟Cache一致性协议有关，具体参考：<a target="_blank" rel="noopener" href="http://blogs.oracle.com/dave/entry/biased_locking_in_hotspot">http://blogs.oracle.com/dave/entry/biased_locking_in_hotspot</a></p>
<p>NUMA(Non Uniform Memory Access Achitecture）架构：<br>与SMP对应还有非对称多处理器架构，现在主要应用在一些高端处理器上，主要特点是没有总线，没有公用主存，每个Core有自己的内存，针对这种结构此处不做讨论。</p>
<h3 id="MESI（缓存一致性协议）"><a href="#MESI（缓存一致性协议）" class="headerlink" title="MESI（缓存一致性协议）"></a>MESI（缓存一致性协议）</h3><p>首先，由于CPU和内存的速度不匹配，所以有了CPU高速缓存，现代CPU的缓存一般分为3级，L1，L2，L3，通常来讲，一个多核处理器上，每个CPU核心都有自己的L1和L2 Cache，L3 Cache则是被所有核心共享的。CPU读取某一数据时，会先从缓存中读，若缓存read miss，则将数据从主存加载到缓存。缓存中的一个数据单位称为一个缓存行（cache line），通常是64字节，从主存中加载数据到缓存，不是一次加载一个字节，而是一次加载一个缓存行。</p>
<p>有些无法被缓存的数据， 或者跨越多个缓存行的数据依然必须使用总线锁。</p>
<p>cpu每个cache line标记四种状态（额外两位）， 通过这个协议保证各个cpu的缓存保持一致性。</p>
<p>Modified</p>
<p>该cache line只存在于当前cache，而不存在于其他cache，并且该cache line的数据与主存中的数据不一致，是脏数据（dirty）</p>
<p>Exclusive</p>
<p>该cache line只存在于当前cache，而不存在于其他cache，并且该cache line的数据与主存中的数据一致，是clean的</p>
<p>Shared</p>
<p>该cache line存在于多个cache中，并且该cache line 的数据与主存中的数据一致</p>
<p>Invalid</p>
<p>该cache line 失效</p>
<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>如果你创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是ThreadLocal变量名的由来。他们可以使用 get（）和 set（） 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。</p>
<h3 id="ThreadLocal使用场景"><a href="#ThreadLocal使用场景" class="headerlink" title="ThreadLocal使用场景"></a>ThreadLocal使用场景</h3><p>假设多个函数递归调用，这个时候最里面的那个函数想要获取刚开始的那个函数的值，这个时候里面有某个函数是系统库里的函数，参数传不下去，用static多线程下会不安全，可以用ThreadLocal。</p>
<p>Spring里面@Transactional 注解，标注某个方法需要支持事务，这个方法里面调用了几个方法，然后connection怎么传，每一个线程用的connection必须是同一个，会放到ThreadLocal；mybatis关于分页的处理；</p>
<h4 id="在项目中使用到的地方"><a href="#在项目中使用到的地方" class="headerlink" title="在项目中使用到的地方"></a>在项目中使用到的地方</h4><p>获取登录用户信息，既然要把用户id作为集合名称的一部分，必须在请求进入交易服务时就获取到用户信息，并且将当前用户信息与当前请求线程绑定。</p>
<p>获取用户的思路分析: </p>
<ul>
<li><p>页面直接把用户作为请求参数传递：</p>
<ul>
<li>优点：简单、方便，代码量为0；</li>
<li>缺点：不安全，因为调用购物车CRUD的请求时从页面发过来的，不能确定这个传递过来的id是不是真的是用户的id。</li>
</ul>
</li>
<li><p>自己从cookie的token中解析用户信息：</p>
<ul>
<li>优点：安全；</li>
<li>缺点：需要重复检验JWT，已经在网关中做过了，代码麻烦。</li>
</ul>
</li>
</ul>
<p>为了在请求进入服务后直接能拿到用户，可以拦截每一个进入controller的请求，统一完成登录用户的获取，这个拦截可以通过SpringMVC的通用拦截器：HandlerInterceptor来实现。</p>
<h3 id="ThreadLocal原理"><a href="#ThreadLocal原理" class="headerlink" title="ThreadLocal原理"></a>ThreadLocal原理</h3><p>Thread类有两个变量，默认情况下这两个变量都是 null，只有当前线程调用 ThreadLocal 类的 set或get方法时才创建它们，实际上调用这两个方法的时候，调用的是ThreadLocalMap类对应的 get()、set()方法；</p>
<p>最终的变量是放在了当前线程的 ThreadLocalMap 中，并不是存在 ThreadLocal 上，ThreadLocal 可以理解为只是ThreadLocalMap的封装，传递了变量值。 ThrealLocal 类中可以通过Thread.currentThread()获取到当前线程对象后，直接通过getMap(Thread t)可以访问到该线程的ThreadLocalMap对象。</p>
<p>每个Thread中都具备一个ThreadLocalMap，而ThreadLocalMap可以存储以ThreadLocal为 key，Object对象为 value 的键值对。</p>
<p>比如在同一个线程中声明了两个 ThreadLocal 对象的话，都是使用同一个 ThreadLocalMap 存放数据的，ThreadLocalMap的 key 就是 ThreadLocal 对象，value 就是 ThreadLocal 对象调用set方法设置的值。</p>
<p>Entry是WeakReference的子类，key是弱引用，内存不足的时候，threadlocal对象且没有强引用引用的时候会被gc回收；</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848071.png" alt="image-20210508151923558"></p>
<p>ThreadLocal属于类，设置为static；</p>
<h4 id="set-源码"><a href="#set-源码" class="headerlink" title="set()源码"></a>set()源码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">// this为ThreadLocal对象</span></span><br><span class="line">            map.set(<span class="built_in">this</span>， value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t， value);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="ThreadLocal内存泄露问题"><a href="#ThreadLocal内存泄露问题" class="headerlink" title="ThreadLocal内存泄露问题"></a>ThreadLocal内存泄露问题</h3><p>ThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用，而 value 是强引用。所以，如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候，key直接会被清理掉（不管内存是否够），而 value 不会被清理掉。这样一来，ThreadLocalMap 中就会出现 key 为 null 的 Entry。假如不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。ThreadLocalMap 实现中已经考虑了这种情况，在调用 set()、get()、remove() 方法的时候，会清理掉 key 为 null 的记录。但是假设长时间不执行get()和set()，就会造成内存泄漏， 所以使用完 ThreadLocal 方法后最好手动调用remove()方法。</p>
<h4 id="ThreadLocalMap-key为什么用弱引用"><a href="#ThreadLocalMap-key为什么用弱引用" class="headerlink" title="ThreadLocalMap key为什么用弱引用?"></a>ThreadLocalMap key为什么用弱引用?</h4><p>假设是强引用，即使把tl设置为空，但是key的引用依然指向threadLocal对象，所以会有内存泄漏，而使用弱引用不会，但是还是会导致内存泄漏的存在，threadLocal被回收，key的值变成null，则导致整个value再也无法被访问到，因此依然存在内存泄漏。</p>
<h3 id="在线程池中ThreadLocal使用的问题"><a href="#在线程池中ThreadLocal使用的问题" class="headerlink" title="在线程池中ThreadLocal使用的问题"></a>在线程池中ThreadLocal使用的问题</h3><p>每个线程被拿出去用的时候假如不清理threadlocalmap的话，下次被拿去使用的时候就会出现很多问题，例如key重复了； 所以线程池使用完会立刻清理Threadlocalmap然后再放回去。</p>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>类比银行柜台；2个核心柜台，开了之后就一直不关， 一共5个柜台，剩下3个柜台1个时间单位内没有任务处理就撤掉，时间单位为小时，等待区一共有10把椅子，生产柜台的工厂，5个柜台满了并且等待区满了就有4种方式拒绝（直接拒绝并抛出异常；直接拒绝，不抛异常；让他回到分配任务的公司去处理业务，假设公司关门则丢弃任务；尝试将第一个柜台取出给他办理业务，不抛异常）</p>
<p>池化技术：事先准备好一些资源，有人要用，就来我这里拿，用完之后还给我。</p>
<p>好处：线程复用，可以控制最大并发数、管理线程；</p>
<h3 id="执行-execute-方法和-submit-方法的区别是什么呢？"><a href="#执行-execute-方法和-submit-方法的区别是什么呢？" class="headerlink" title="执行 execute()方法和 submit()方法的区别是什么呢？"></a>执行 execute()方法和 submit()方法的区别是什么呢？</h3><p>execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；</p>
<p>submit()方法用于提交需要返回值的任务。线程池会返回一个Future类型的对象，通过这个Future对象可以判断任务是否执行成功，并且可以通过Future的get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成，而使用get（long timeout，TimeUnit unit）方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</p>
<h3 id="如何创建线程池"><a href="#如何创建线程池" class="headerlink" title="如何创建线程池"></a>如何创建线程池</h3><p>《阿里巴巴 Java 开发手册》中强制线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险;</p>
<p>Executors 返回线程池对象的弊端如下：</p>
<ul>
<li><strong>FixedThreadPool 和 SingleThreadExecutor</strong> ： 允许请求的队列长度为 Integer.MAX_VALUE ，可能堆积大量的请求，从而导致 OOM。</li>
<li><strong>CachedThreadPool 和 ScheduledThreadPool</strong> ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致 OOM。</li>
<li>Executors.newFixedThreadPool()：无界队列，内存可能被打爆</li>
<li>Executors.newSingleThreadExecutor()：单个线程，效率低，串行。</li>
<li>Executors.newCachedThreadPool()：没有核心线程，最大线程数可能为无限大，内存可能还会爆掉。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> pool;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Huang Mingwang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-04-26 8:04 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Runtime.getRuntime().availableProcessors();</span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">3</span>， max， <span class="number">3</span>， TimeUnit.SECONDS，</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">10</span>)， Executors.defaultThreadFactory()， <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy()</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                threadPoolExecutor.execute(()-&gt; &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName());</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            threadPoolExecutor.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="线程池3大方法"><a href="#线程池3大方法" class="headerlink" title="线程池3大方法"></a>线程池3大方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Executors.newSingleThreadExecutor(); <span class="comment">// 单</span></span><br><span class="line">Executors.newFixedThreadPool(<span class="number">5</span>); <span class="comment">// 固定大小 </span></span><br><span class="line">Executors.newCachedThreadPool(); <span class="comment">// 可伸缩</span></span><br></pre></td></tr></table></figure>

<h3 id="线程池的7个参数"><a href="#线程池的7个参数" class="headerlink" title="线程池的7个参数"></a>线程池的7个参数</h3><ul>
<li>corePoolSize ：核心线程数线程数定义了最小可以同时运行的线程数量；</li>
<li>maximumPoolSize：当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数；</li>
<li>keepAliveTime：当线程池中的线程数量大于 corePoolSize 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 keepAliveTime才会被回收销毁；</li>
<li>unit： keepAliveTime 参数的时间单位；</li>
<li>workQueue:  当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中；</li>
<li>threadFactory：executor 创建新线程的时候会用到；</li>
<li>handler：饱和策略。</li>
</ul>
<h4 id="最大线程该怎么定义"><a href="#最大线程该怎么定义" class="headerlink" title="最大线程该怎么定义?"></a>最大线程该怎么定义?</h4><p>计算（CPU）密集型消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1，比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。</p>
<p>io密集型系统会用大部分的时间来处理 I&#x2F;O 交互，而线程在处理 I&#x2F;O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I&#x2F;O 密集型任务的应用中，可以多配置一些线程，具体的计算方法是 2N。</p>
<h3 id="线程池的四大饱和策略"><a href="#线程池的四大饱和策略" class="headerlink" title="线程池的四大饱和策略"></a>线程池的四大饱和策略</h3><ul>
<li>ThreadPoolExecutor.AbortPolicy(默认)：抛出 RejectedExecutionException来拒绝新任务的处理。</li>
<li>ThreadPoolExecutor.CallerRunsPolicy：调用执行自己的线程运行任务，也就是直接在调用execute方法的线程中运行(run)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，可以选择这个策略。</li>
<li>ThreadPoolExecutor.DiscardPolicy： 不处理新任务，直接丢弃掉，不抛出异常。</li>
<li>ThreadPoolExecutor.DiscardOldestPolicy： 如果线程池没有关闭，取出线程池队列的第一个线程，尝试让该线程去处理任务，但是如果该线程在忙，则会直接拒绝，也不抛出异常。</li>
</ul>
<p>举个例子：Spring 通过 ThreadPoolTaskExecutor 或者直接通过 ThreadPoolExecutor 的构造函数创建线程池的时候，如果不指定 RejectedExecutionHandler 饱和策略的话来配置线程池的时候默认使用的是 ThreadPoolExecutor.AbortPolicy。在默认情况下，ThreadPoolExecutor 将抛出 RejectedExecutionException 来拒绝新来的任务 ，这将丢失对这个任务的处理。 对于可伸缩的应用程序，建议使用 ThreadPoolExecutor.CallerRunsPolicy。当最大池被填满时，此策略提供可伸缩队列。（这个直接查看 ThreadPoolExecutor 的构造函数源码就可以看出）</p>
<h3 id="线程池原理分析"><a href="#线程池原理分析" class="headerlink" title="线程池原理分析"></a>线程池原理分析</h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9teS1ibG9nLXRvLXVzZS5vc3MtY24tYmVpamluZy5hbGl5dW5jcy5jb20vMjAxOS03LyVFNSU5QiVCRSVFOCVBNyVBMyVFNyVCQSVCRiVFNyVBOCU4QiVFNiVCMSVBMCVFNSVBRSU5RSVFNyU4RSVCMCVFNSU4RSU5RiVFNyU5MCU4Ni5wbmc?x-oss-process=image/format%EF%BC%8Cpng" alt="图解线程池实现原理"></p>
<h3 id="线程池优化"><a href="#线程池优化" class="headerlink" title="线程池优化"></a>线程池优化</h3><ul>
<li>如果想要降低系统资源的消耗（cpu使用率，操作系统资源消耗，上下文切换开销），那么可以设置一个比较大的队列容量和一个比较小的线程池容量；</li>
<li>如果队列经常堆积比较多的任务，并且业务方面需要加快处理速度时，可以适当加大maximumPoolSize，找一些池外线程（临时工）帮忙；</li>
<li>timer是单线程的，如果一个线程执行时间很长，会影响下一个执行线程，实际项目中尽可能用ScheduledThreadPoolExecutor，慎用Timer；</li>
<li>ScheduledThreadPoolExecutor继承了ThreadPoolExecutor，一般被用来当做延迟队列线程池使用，最大线程数maximumPoolSize都被设置成默认的Integer.MAX_VALUE，生产环境上容易造成OOM或者导致服务器性能下降，建议使用消息队列中的延迟队列代替。</li>
</ul>
<h3 id="线程池参数动态化"><a href="#线程池参数动态化" class="headerlink" title="线程池参数动态化"></a>线程池参数动态化</h3><p>业务与流量不会总是一成不变的，当初合理的配置可能也会在突发的巨大流量面前兵败如山倒，固定的线程池配置亦是如此，满足当时，却可能顶不住未来。为此，美团团队在博客中提到了<strong>线程池参数动态化</strong>的思路，非常值得精读！</p>
<p><a target="_blank" rel="noopener" href="http://xuyk.top/go.html?u=aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvYmFZdVg4YUN3UTlQUDZrN1REbDJXdw==">Java线程池实现原理及其在美团业务中的实践</a></p>
<p><code>ctl</code>这个AtomicInteger类型，是对线程池的运行状态和线程池中有效线程的数量进行控制的一个字段， 它同时包含两部分的信息：线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)，高3位保存runState，低29位保存workerCount，两个变量之间互不干扰。用一个变量去存储两个值，可避免在做相关决策时，出现不一致的情况，不必为了维护两者的一致，而占用锁资源。通过阅读线程池源代码也可以发现，经常出现要同时判断线程池运行状态和线程数量的情况。线程池也提供了若干方法去供用户获得线程池当前的运行状态、线程个数。这里都使用的是位运算的方式，相比于基本运算，速度也会快很多。</p>
<p>ThreadPoolExecutor的运行状态和生命周期：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211904470.jpg" alt="图片"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211856318.png" alt="image-20211221185614876"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211855709.png" alt="image-20211221185558185"></p>
<h3 id="当线程池里的线程执行异常会发生什么？"><a href="#当线程池里的线程执行异常会发生什么？" class="headerlink" title="当线程池里的线程执行异常会发生什么？"></a>当线程池里的线程执行异常会发生什么？</h3><p>一个线程出现异常不会影响线程池里面其他线程的正常执行，该异常线程不是被回收而是线程池把这个线程移除掉，同时创建一个新的线程放到线程池中。</p>
<p><strong>异常线程是否会打印异常信息</strong></p>
<ol>
<li>调用方法为 execute() ，会打印出堆栈异常日志</li>
<li>调用方法为 submit() ，堆栈异常没有输出。但是如果业务需要获取线程返回值，调用了Future.get()方法时，可以捕获打印出堆栈异常信息。而很多时候可能并不需要获取执行结果，导致异常“被吃”，进而不触发告警信息酿成大祸，所以不建议使用submit()。</li>
</ol>
<blockquote>
<p>两者在使用日志工具打印自定义日志都比较困难，推荐结合<strong>jdk8的新特性CompletableFuture</strong>，搭配线程池一起使用，详情可以查看这篇文章：<a target="_blank" rel="noopener" href="http://xuyk.top/go.html?u=aHR0cDovL3h1eWsudG9wL3Bvc3RzL2FzeW5jLmh0bWw=">如何优雅地异步编程</a></p>
</blockquote>
<h3 id="如果线上突然宕机，阻塞队列中的任务怎么办？"><a href="#如果线上突然宕机，阻塞队列中的任务怎么办？" class="headerlink" title="如果线上突然宕机，阻塞队列中的任务怎么办？"></a>如果线上突然宕机，阻塞队列中的任务怎么办？</h3><p>阻塞队列中的所有任务会丢失。</p>
<p>保证任务不丢失的思路：</p>
<ol>
<li>可以在提交任务前先进行落库处理，当宕机重启后，再拿出待处理的任务继续执行。</li>
<li>使用消息队列。</li>
</ol>
<h3 id="如果线程池的队列满了之后会发生什么事情？"><a href="#如果线程池的队列满了之后会发生什么事情？" class="headerlink" title="如果线程池的队列满了之后会发生什么事情？"></a>如果线程池的队列满了之后会发生什么事情？</h3><p>关键在于线程池当前活跃线程数 与 最大线程数 的对比</p>
<ol>
<li>线程池当前活跃线程数 &lt; 最大线程数，则线程池会抽调池外线程（系统线程）来处理任务</li>
<li>线程池当前活跃线程数 &gt;&#x3D; 最大线程数，会根据线程池的拒绝策略来处理任务</li>
</ol>
<p>保证任务100%被处理的思路： 自定义拒绝策略，把任务交给其他负载低的线程池进行处理，或者放入消息队列交给其他线程池处理 &#x2F; 阻塞队列处理完毕后处理消息队列中的任务。</p>
<h2 id="四大函数式接口"><a href="#四大函数式接口" class="headerlink" title="四大函数式接口"></a>四大函数式接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> function;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 函数式接口：有一个输入参数，有一个输出</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Huang Mingwang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-04-26 9:04 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//        Function&lt;String， String&gt; function = new Function&lt;String， String&gt;() &#123;</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public String apply(String s) &#123;</span></span><br><span class="line"><span class="comment">//                System.out.println(s);</span></span><br><span class="line"><span class="comment">//                return s;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;;</span></span><br><span class="line"><span class="comment">//        function.apply(&quot;100&quot;);</span></span><br><span class="line">        <span class="type">Function</span> <span class="variable">function</span> <span class="operator">=</span> (str) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(function.apply(<span class="string">&quot;asd&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> function;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 断定型接口： 有一个输入参数， 返回值为boolean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Huang Mingwang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-04-26 9:25 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//        Predicate&lt;String&gt; predicate = new Predicate&lt;String&gt;() &#123;</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public boolean test(String s) &#123;</span></span><br><span class="line"><span class="comment">//                return !&quot;&quot;.equals(s);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;;</span></span><br><span class="line"><span class="comment">//        String s = &quot;&quot;;</span></span><br><span class="line"><span class="comment">//        System.out.println(predicate.test(s));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        Predicate&lt;String&gt; predicate = (s)-&gt; !&quot;&quot;.equals(s);</span></span><br><span class="line"><span class="comment">//        String s = &quot;&quot;;</span></span><br><span class="line"><span class="comment">//        System.out.println(predicate.test(s));</span></span><br><span class="line"></span><br><span class="line">        Predicate&lt;String&gt; predicate = String::isEmpty;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;11&quot;</span>;</span><br><span class="line">        System.out.println(predicate.test(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> function;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Consumer 消费型接口：只有输入，没有返回值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Huang Mingwang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-04-26 9:32 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//        Consumer&lt;String&gt; consumer = new Consumer&lt;String&gt;() &#123;</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public void accept(String s) &#123;</span></span><br><span class="line"><span class="comment">//                System.out.println(s);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;;</span></span><br><span class="line"><span class="comment">//        consumer.accept(&quot;sss&quot;);</span></span><br><span class="line"></span><br><span class="line">        Consumer&lt;String&gt; consumer = System.out::println;</span><br><span class="line">        consumer.accept(<span class="string">&quot;ss&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> function;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.Supplier;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * supplier 供给型接口， 没有参数只有返回值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Huang Mingwang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-04-26 9:33 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//        Supplier&lt;Integer&gt; supplier = new Supplier&lt;Integer&gt;() &#123;</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public Integer get() &#123;</span></span><br><span class="line"><span class="comment">//                return 1024;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;;</span></span><br><span class="line"><span class="comment">//        System.out.println(supplier.get());</span></span><br><span class="line"></span><br><span class="line">        Supplier&lt;Integer&gt; supplier = ()-&gt;<span class="number">1024</span>;</span><br><span class="line">        System.out.println(supplier.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Stream流式计算"><a href="#Stream流式计算" class="headerlink" title="Stream流式计算"></a>Stream流式计算</h2><p>集合、MySQL本质就是存储东西的；计算都应该交给流来操作；</p>
<h2 id="ForkJoin"><a href="#ForkJoin" class="headerlink" title="ForkJoin"></a>ForkJoin</h2><p>Jdk1.7，并发执行任务，提高效率； 大数据量；  工作窃取；  B线程执行完会去拿A的线程没执行完的任务； 线程里面的任务是双端队列，两端都可以取到任务； </p>
<img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848164.png" alt="image-20210427072722808" style="zoom:50%;" />

<p>大数据： Map Reduce（把大任务拆分成小任务）；</p>
<p>fork()：开启一个新线程（或是重用线程池内的空闲线程），将任务交给该线程处理。<br>join()：等待该任务的处理线程处理完毕，获得返回值。</p>
<h2 id="异步回调"><a href="#异步回调" class="headerlink" title="异步回调"></a>异步回调</h2><p>completableFuture可以有返回值也可以没有，也是新建线程去处理。</p>
<h2 id="Atomic原子类"><a href="#Atomic原子类" class="headerlink" title="Atomic原子类"></a>Atomic原子类</h2><ul>
<li>具有原子&#x2F;原子操作特征的类；</li>
<li>使用 AtomicInteger 之后，不用对 increment() 方法加锁也可以保证线程安全；</li>
<li>底层CAS实现；</li>
<li>在内存中修改值， Unsafe类，里面基本都是调用native方法。</li>
</ul>
<p>AtomicInteger 类主要利用 CAS (compare and swap) + volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</p>
<h3 id="JUC-包中的原子类是哪-4-类"><a href="#JUC-包中的原子类是哪-4-类" class="headerlink" title="JUC 包中的原子类是哪 4 类?"></a>JUC 包中的原子类是哪 4 类?</h3><p><strong>基本类型</strong></p>
<p>使用原子的方式更新基本类型</p>
<ul>
<li><code>AtomicInteger</code>：整形原子类</li>
<li><code>AtomicLong</code>：长整型原子类</li>
<li><code>AtomicBoolean</code>：布尔型原子类</li>
</ul>
<p><strong>数组类型</strong></p>
<p>使用原子的方式更新数组里的某个元素</p>
<ul>
<li><code>AtomicIntegerArray</code>：整形数组原子类</li>
<li><code>AtomicLongArray</code>：长整形数组原子类</li>
<li><code>AtomicReferenceArray</code>：引用类型数组原子类</li>
</ul>
<p><strong>引用类型</strong></p>
<ul>
<li><code>AtomicReference</code>：引用类型原子类</li>
<li><code>AtomicStampedReference</code>：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。</li>
<li><code>AtomicMarkableReference</code> ：原子更新带有标记位的引用类型</li>
</ul>
<p><strong>对象的属性修改类型</strong></p>
<ul>
<li><code>AtomicIntegerFieldUpdater</code>：原子更新整形字段的更新器</li>
<li><code>AtomicLongFieldUpdater</code>：原子更新长整形字段的更新器</li>
<li><code>AtomicReferenceFieldUpdater</code>：原子更新引用类型字段的更新器</li>
</ul>
<h3 id="AtomicInteger的使用"><a href="#AtomicInteger的使用" class="headerlink" title="AtomicInteger的使用"></a>AtomicInteger的使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> <span class="comment">//获取当前的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndSet</span><span class="params">(<span class="type">int</span> newValue)</span><span class="comment">//获取当前的值，并设置新的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">()</span><span class="comment">//获取当前的值，并自增</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndDecrement</span><span class="params">()</span> <span class="comment">//获取当前的值，并自减</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAdd</span><span class="params">(<span class="type">int</span> delta)</span> <span class="comment">//获取当前的值，并加上预期的值</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> expect， <span class="type">int</span> update)</span> <span class="comment">//如果输入的数值等于预期值，则以原子方式将该值设置为输入值（update）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lazySet</span><span class="params">(<span class="type">int</span> newValue)</span><span class="comment">//最终设置为newValue，使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</span></span><br></pre></td></tr></table></figure>

<h3 id="AtomicInteger类的原理"><a href="#AtomicInteger类的原理" class="headerlink" title="AtomicInteger类的原理"></a>AtomicInteger类的原理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// setup to use Unsafe.compareAndSwapInt for updates（更新操作时提供“比较并替换”的作用）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> Unsafe.getUnsafe();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        valueOffset = unsafe.objectFieldOffset</span><br><span class="line">            (AtomicInteger.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(ex); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> value;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>AtomicInteger 类主要利用 CAS （compare and swap）+ volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</p>
<p>CAS 的原理是拿期望的值和原本的一个值作比较，如果相同则更新成新的值。UnSafe 类的 objectFieldOffset() 方法是一个本地方法，这个方法是用来拿到“原来的值”的内存地址，返回值是 valueOffset。另外 value 是一个 volatile 变量，在内存中可见，因此 JVM 可以保证任何时刻任何线程总能拿到该变量的最新值。</p>
<h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><p>AQS 的全称为（AbstractQueuedSynchronizer），这个类在java.util.concurrent.locks包下面;</p>
<p>AQS 是一个用来构建锁和同步器的框架，使用 AQS 能简单且高效地构造出应用广泛的大量的同步器，比如 ReentrantLock，Semaphore，其他的诸如 ReentrantReadWriteLock，SynchronousQueue，FutureTask 等等皆是基于 AQS 的。</p>
<h3 id="AQS原理分析"><a href="#AQS原理分析" class="headerlink" title="AQS原理分析"></a>AQS原理分析</h3><p>AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 CLH 队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</p>
<p>CLH（Craig、Landin、and Hagersten）队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS 是将每条请求共享资源的线程封装成一个 CLH 锁队列的一个结点（Node）来实现锁的分配。</p>
<p>AQS 使用一个 int 成员变量来表示同步状态，通过内置的 FIFO 队列来完成获取资源线程的排队工作。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848262.png" alt="AQS原理图"></p>
<h3 id="AQS对资源的共享方式"><a href="#AQS对资源的共享方式" class="headerlink" title="AQS对资源的共享方式"></a>AQS对资源的共享方式</h3><p><strong>AQS 定义两种资源共享方式</strong></p>
<ul>
<li>Exclusive（独占）：只有一个线程能执行，如ReentrantLock<ul>
<li>公平锁：按照线程在队列中的排队顺序，先到者先拿到锁</li>
<li>非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的</li>
</ul>
</li>
<li>Share（共享）：多个线程可同时执行，如CountDownLatch、Semaphore、 CyclicBarrier、ReadWriteLock 。</li>
</ul>
<p>ReentrantReadWriteLock 可以看成是组合式，因为 ReentrantReadWriteLock 也就是读写锁允许多个线程同时对某一资源进行读。</p>
<p>不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队&#x2F;唤醒出队等），AQS 已经在顶层实现好了。</p>
<h4 id="AQS底层使用模版方法模式"><a href="#AQS底层使用模版方法模式" class="headerlink" title="AQS底层使用模版方法模式"></a>AQS底层使用模版方法模式</h4><p>同步器的设计是基于模板方法模式的，如果需要自定义同步器一般的方式是这样（模板方法模式很经典的一个应用）：</p>
<ol>
<li>使用者继承 AbstractQueuedSynchronizer 并重写指定的方法。（这些重写方法很简单，无非是对于共享资源 state 的获取和释放）</li>
<li>将 AQS 组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。</li>
</ol>
<p>这和我们以往通过实现接口的方式有很大区别，这是模板方法模式很经典的一个运用。</p>
<p>AQS 使用了模板方法模式，自定义同步器时需要重写下面几个 AQS 提供的模板方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">isHeldExclusively()<span class="comment">//该线程是否正在独占资源。只有用到condition才需要去实现它。</span></span><br><span class="line">tryAcquire(<span class="type">int</span>)<span class="comment">//独占方式。尝试获取资源，成功则返回true，失败则返回false。</span></span><br><span class="line">tryRelease(<span class="type">int</span>)<span class="comment">//独占方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br><span class="line">tryAcquireShared(<span class="type">int</span>)<span class="comment">//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span></span><br><span class="line">tryReleaseShared(<span class="type">int</span>)<span class="comment">//共享方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br></pre></td></tr></table></figure>

<p>默认情况下，每个方法都抛出 UnsupportedOperationException。 这些方法的实现必须是内部线程安全的，并且通常应该简短而不是阻塞。AQS 类中的其他方法都是 final ，所以无法被其他类使用，只有这几个方法可以被其他类使用。</p>
<p>以 ReentrantLock 为例，state 初始化为 0，表示未锁定状态。A 线程 lock()时，会调用 tryAcquire()独占该锁并将 state+1。此后，其他线程再 tryAcquire()时就会失败，直到 A 线程 unlock()到 state&#x3D;0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A 线程自己是可以重复获取此锁的（state 会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证 state 是能回到零态的。</p>
<p>再以 CountDownLatch 以例，任务分为 N 个子线程去执行，state 也初始化为 N（注意 N 要与线程个数一致）。这 N 个子线程是并行执行的，每个子线程执行完后countDown() 一次，state 会 CAS（Compare and Swap）减 1。等到所有子线程都执行完后（即 state&#x3D;0），会 unpark()主调用线程，然后主调用线程就会从 await() 函数返回，继续后余动作。</p>
<p>一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。但 AQS 也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。</p>
<p>推荐两篇 AQS 原理和相关源码分析的文章：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://www.cnblogs.com/waterystone/p/4920797.html">http://www.cnblogs.com/waterystone/p/4920797.html</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/chengxiao/archive/2017/07/24/7141160.html">https://www.cnblogs.com/chengxiao/archive/2017/07/24/7141160.html</a></li>
</ul>
<h3 id="AQS组件总结"><a href="#AQS组件总结" class="headerlink" title="AQS组件总结"></a>AQS组件总结</h3><ul>
<li>Semaphore（信号量）-允许多个线程同时访问： synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源，Semaphore(信号量)可以指定多个线程同时访问某个资源。</li>
<li>CountDownLatch（倒计时器）： CountDownLatch 是一个同步工具类，用来协调多个线程之间的同步。这个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束，再开始执行。</li>
<li>CyclicBarrier（循环栅栏）： CyclicBarrier 和 CountDownLatch 非常类似，它也可以实现线程间的技术等待，但是它的功能比 CountDownLatch 更加复杂和强大。主要应用场景和 CountDownLatch 类似。CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。CyclicBarrier 默认的构造方法是 CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用 await() 方法告诉 CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。</li>
</ul>
<h3 id="CountDownLatch-1"><a href="#CountDownLatch-1" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><p>CountDownLatch 的作用就是允许 count 个线程阻塞在一个地方，直至所有线程的任务都执行完毕。</p>
<p>例如：</p>
<p>要读取处理 6 个文件，这 6 个任务都是没有执行顺序依赖的任务，但是需要返回给用户的时候将这几个文件的处理的结果进行统计整理。</p>
<p>为此定义了一个线程池和 count 为 6 的CountDownLatch对象 。使用线程池处理读取任务，每一个线程处理完之后就将 count-1，调用CountDownLatch对象的 await()方法，直到所有文件读取完之后，才会接着执行后面的逻辑。</p>
<h1 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h1><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848279.png" alt="img"></p>
<h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><ul>
<li><p>初始大小10；</p>
</li>
<li><p>扩容1.5倍左右，15、 33 、 49；</p>
</li>
<li><p>线程不安全，适用于频繁的查找工作；</p>
</li>
<li><p>list尾部会预留一些空间；</p>
</li>
<li><p>插入和删除元素需要复制，浪费性能。 </p>
</li>
<li><p>实现了RandomAccess接口（在 binarySearch方法中），它要判断传入的 list 是否是RamdomAccess 的实例，如果是，调用indexedBinarySearch()方法，如果不是，那么调用iteratorBinarySearch()方法；</p>
</li>
<li><p>实现了cloneable和serializable接口；</p>
</li>
<li><p>JDK7 new无参构造的ArrayList对象时，直接创建了长度是10的Object[]数组elementData 。jdk7中的ArrayList的对象的创建类似于单例的饿汉式，而jdk8中的ArrayList的对象的创建类似于单例的懒汉式。</p>
</li>
</ul>
<h3 id="为什么-ArrayList-的-elementData-加上-transient-修饰？"><a href="#为什么-ArrayList-的-elementData-加上-transient-修饰？" class="headerlink" title="为什么 ArrayList 的 elementData 加上 transient 修饰？"></a>为什么 ArrayList 的 elementData 加上 transient 修饰？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Object[] elementData;</span><br></pre></td></tr></table></figure>

<p>ArrayList 的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;， RandomAccess， Cloneable， java.io.Serializable</span><br></pre></td></tr></table></figure>

<p>可以看到 ArrayList 实现了 Serializable 接口，这意味着 ArrayList 支持序列化。transient 的作用是说不希望 elementData 数组被序列化，重写了 writeObject 实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span> <span class="keyword">throws</span> java.io.IOE xception&#123; </span><br><span class="line">  <span class="comment">// Write out element count， and any hidden stuff </span></span><br><span class="line">  <span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount; </span><br><span class="line">  s.defaultWriteObject(); </span><br><span class="line">  <span class="comment">// Write out array length</span></span><br><span class="line">  s.writeInt(elementData.length); </span><br><span class="line">  <span class="comment">// Write out all elements in the proper order.* </span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;size; i++) </span><br><span class="line">  s.writeObject(elementData[i]); </span><br><span class="line">  <span class="keyword">if</span> (modCount != expectedModCount) &#123; </span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每次序列化时，先调用 defaultWriteObject() 方法序列化 ArrayList 中的非transient 元素，然后遍历 elementData，只序列化已存入的元素，这样既加快了序列化的速度，又减小了序列化之后的文件大小。</p>
<h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><ul>
<li>JDK1.6是双向循环链表，JDK1.7为双向链表；</li>
<li>不保证线程安全；</li>
<li>存放前驱和后继的引用会浪费空间；</li>
<li>没有实现RandomAccess接口；</li>
<li>实现List接口和Deque接口；</li>
<li>Collections类中的synchronizedList方法。</li>
</ul>
<h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><ul>
<li>初始大小为10，扩容是2倍；</li>
<li>list的古老实现类；</li>
<li>Vector 的所有方法加上了 synchronized 关键字，线程安全。</li>
</ul>
<h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h2><ul>
<li>继承自vector；</li>
<li>线程安全。</li>
</ul>
<h2 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h2><ul>
<li>PriorityQueue是非线程安全的；</li>
<li>Java提供了PriorityBlockingQueue（实现BlockingQueue接口）用于Java多线程环境；</li>
<li>默认小顶堆实现，底层为数组。</li>
</ul>
<h2 id="ArrayDeque"><a href="#ArrayDeque" class="headerlink" title="ArrayDeque"></a>ArrayDeque</h2><ul>
<li>初始为16，扩容两倍；</li>
<li>双端队列，底层为循环数组；</li>
<li>不能添加null值；</li>
<li>add方法就是调用addLast方法；getLast、getFirst、addFirst、pollFirst、pollLast；</li>
<li>判断队满(tail &#x3D; (tail + 1) &amp; (elements.length - 1)) &#x3D;&#x3D; head。</li>
</ul>
<img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848289.png" alt="img" style="zoom: 67%;" />

<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><ul>
<li>检索元素效率低下，删除和插入效率高，插入和删除不会引起元素位置改变。</li>
</ul>
<h2 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h2><ul>
<li>TreeSet 底层使用红黑树，能够按照添加元素的顺序进行遍历，排序的方式有自然排序和定制排序；</li>
<li>有序的，并且没有重复元素的集合；</li>
<li>非线程安全；</li>
<li>可序列化。</li>
</ul>
<h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><ul>
<li><p>HashMap 相对于 HashSet 较快，因为它是使用唯一的键获取对象；</p>
</li>
<li><p>HashSet 底层就是基于 HashMap 实现的。HashSet 的源码非常非常少，因为除了 clone()、writeObject()、readObject()是 HashSet 自己不得不实现之外，其他方法都是直接调用 HashMap 中的方法。</p>
</li>
<li><p>当把对象加入HashSet时，HashSet 会先计算对象的hashcode值来判断对象加入的位置，同时也会与其他加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，HashSet 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用equals()方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让加入操作成功。</p>
</li>
</ul>
<h2 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h2><ul>
<li>LinkedHashSet 是 HashSet 的子类，能够按照添加的顺序遍历；</li>
</ul>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848337.png" alt="img"></p>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><ul>
<li>16 0.75 扩容为2倍；</li>
<li>尾插法 (jdk1.7用头插法)，桶大于64才会树化，当桶小于64则先扩容；</li>
<li>单链表；</li>
<li>允许一个key为null，value可以有多个null； </li>
<li>1.7 先判断是否需要扩容，再插入，1.8 先进行插入，插入完成再判断是否需要扩容； 1.7没有红黑树机制；</li>
</ul>
<h3 id="扩容机制-1-8"><a href="#扩容机制-1-8" class="headerlink" title="扩容机制(1.8)"></a>扩容机制(1.8)</h3><p>假设初始容量为16，hash(key1) &#x3D; 0001，然后计算0001 &amp; 1111&#x3D; 1， 尾插法放到1号位置，hash(key2) &#x3D; 10001，然后计算10001 &amp; 1111 &#x3D; 1，尾插法放到1号位置，此时扩容为32，先判断hash(key1) &amp; 16 &#x3D;&#x3D; 0? 等于0的都放到lohead这队，然后不等于0的都放到 hihead这一队，lohead放在新表的原来的位置， hihead这队放到新表的j + oldCap位置（原来的位置加上旧表的容量）；可以防止死循环问题；</p>
<h3 id="HashMap为什么不序列化table"><a href="#HashMap为什么不序列化table" class="headerlink" title="HashMap为什么不序列化table?"></a>HashMap为什么不序列化table?</h3><p>桶数组被transient修饰，HashMap 并没有使用默认的序列化机制，而是通过实现readObject&#x2F;writeObject两个方法自定义了序列化的内容。HashMap 中存储的内容是键值对。所以只要把键值对序列化了，就可以根据键值对数据重建 HashMap。直接序列化 talbe 存在着两个问题：</p>
<ol>
<li>table 多数情况下是无法被存满的，序列化未使用的部分，浪费空间；</li>
<li>同一个键值对在不同 JVM 下，所处的桶位置可能是不同的，在不同的 JVM 下反序列化 table 可能会发生错误。</li>
</ol>
<p>HashMap 的get&#x2F;put&#x2F;remove等方法第一步就是根据 hash找到键所在的桶位置，但如果键没有覆写 hashCode 方法，计算hash 时最终调用 Object 中的 hashCode 方法。但Object 中的hashCode方法是native 型的，不同的 JVM下，可能会有不同的实现，产生的 hash 可能也是不一样的。也就是说同一个键在不同平台下可能会产生不同的 hash，此时再对在同一个 table 继续操作，就会出现问题。</p>
<h3 id="hashmap的长度为什么是2的幂次方"><a href="#hashmap的长度为什么是2的幂次方" class="headerlink" title="hashmap的长度为什么是2的幂次方"></a>hashmap的长度为什么是2的幂次方</h3><p>为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀。Hash（需要扰动）值的范围值-2147483648 到 2147483647，前后加起来大概 40 亿的映射空间，只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。但问题是一个 40 亿长度的数组，内存是放不下的。所以这个散列值是不能直接拿来用的。用之前还要先做对数组的长度取模运算，得到的余数才能用来要存放的位置也就是对应的数组下标。这个数组下标的计算方法是“ <code>(n - 1) &amp; hash</code>”。（n 代表数组长度）。这也就解释了 HashMap 的长度为什么是 2 的幂次方。</p>
<p>这个算法应该如何设计呢？</p>
<p>首先可能会想到采用%取余的操作来实现。但是，重点来了：“取余(%)操作中如果除数是 2 的幂次则等价于与其除数减一的与(&amp;)操作（也就是说 hash%length&#x3D;&#x3D;hash&amp;(length-1)的前提是 length 是 2 的 n 次方；）。” 并且采用二进制位操作 &amp;，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是 2 的幂次方。</p>
<h3 id="HashMap多线程操作导致死循环问题"><a href="#HashMap多线程操作导致死循环问题" class="headerlink" title="HashMap多线程操作导致死循环问题"></a>HashMap多线程操作导致死循环问题</h3><p>主要原因在于并发下的 Rehash 会造成元素之间会形成一个循环链表。jdk 1.8 后解决了这个问题，但是还是不建议在多线程下使用 HashMap，因为多线程下使用 HashMap 还是会存在其他问题比如数据丢失。并发环境下推荐使用 ConcurrentHashMap 。</p>
<p>详情请查看：<a target="_blank" rel="noopener" href="https://coolshell.cn/articles/9606.html">https://coolshell.cn/articles/9606.html</a></p>
<h3 id="Hash-Collision-Dos问题"><a href="#Hash-Collision-Dos问题" class="headerlink" title="Hash Collision Dos问题"></a>Hash Collision Dos问题</h3><p>这个安全弱点利用了各语言的Hash算法的“非随机性”可以制造出N多的value不一样，但是key一样数据，然后Hash表成为一张单向链表，而导致整个网站或是程序的运行性能以级数下降（可以很轻松的CPU升到100%）</p>
<h3 id="能否使用任何类作为-Map-的-key？"><a href="#能否使用任何类作为-Map-的-key？" class="headerlink" title="能否使用任何类作为 Map 的 key？"></a>能否使用任何类作为 Map 的 key？</h3><p>可以使用任何类作为 Map 的 key，然而在使用之前，需要考虑以下几点：  如果类重写了 equals() 方法，也应该重写 hashCode() 方法。类的所有实例需要遵循与 equals() 和 hashCode() 相关的规则。</p>
<p>如果一个类没有使用 equals()，不应该在 hashCode() 中使用它。</p>
<p>用户自定义 Key 类佳实践是使之为不可变的，这样 hashCode() 值可以被缓存起来，拥有更好的性能。不可变的类也可以确保 hashCode() 和 equals() 在未来不会改变，这样就会解决与可变相关的问题了。</p>
<h3 id="在使用-HashMap-的时候，用-String-做-key-有什么好处？"><a href="#在使用-HashMap-的时候，用-String-做-key-有什么好处？" class="headerlink" title="在使用 HashMap 的时候，用 String 做 key 有什么好处？"></a>在使用 HashMap 的时候，用 String 做 key 有什么好处？</h3><p>HashMap 内部实现是通过 key 的 hashcode 来确定 value 的存储位置，因为字符串是不可变的，所以当创建字符串时，它的 hashcode 被缓存下来，不需要再次计算，所以相比于其他对象更快。</p>
<p>String、Integer等包装类的特性能够保证Hash值的不可更改性和计算准确性，能够有效的减少Hash碰撞的几率</p>
<ol>
<li>都是final类型，即不可变性，保证key的不可更改性，不会存在获取 hash值不同的情况.</li>
</ol>
<p>内部已重写了equals()、hashCode()等方法，遵守了HashMap内部的规范（不清楚可以去上面看看putValue的过程），不容易出现Hash值计算错误的情况</p>
<h3 id="如果使用Object作为HashMap的Key，应该怎么办呢？"><a href="#如果使用Object作为HashMap的Key，应该怎么办呢？" class="headerlink" title="如果使用Object作为HashMap的Key，应该怎么办呢？"></a>如果使用Object作为HashMap的Key，应该怎么办呢？</h3><p>答：重写hashCode()和equals()方法</p>
<ol>
<li><p>重写hashCode()是因为需要计算存储数据的存储位置，需要注意不要试图从散列码计算中排除掉一个对象的关键部分来提高性能，这样虽然能更快但可能会导致更多的Hash碰撞；</p>
</li>
<li><p>重写equals()方法，需要遵守自反性、对称性、传递性、一致性以及对于任何非null的引用值x，x.equals(null)必须返回false的这几个特性，目的是为了保证key在哈希表中的唯一性。</p>
</li>
</ol>
<h3 id="HashMap为什么不直接使用hashCode-处理后的哈希值直接作为table的下标？"><a href="#HashMap为什么不直接使用hashCode-处理后的哈希值直接作为table的下标？" class="headerlink" title="HashMap为什么不直接使用hashCode()处理后的哈希值直接作为table的下标？"></a>HashMap为什么不直接使用hashCode()处理后的哈希值直接作为table的下标？</h3><p>答：hashCode()方法返回的是int整数类型，其范围为-(2 ^ 31)<del>(2 ^ 31 - 1)，约有40亿个映射空间，而HashMap的容量范围是在16（初始化默认值）</del>2 ^ 30，HashMap通常情况下是取不到大值的，并且设备上也难以提供这么多的存储空间，从而导致通过hashCode()计算出的哈希值可能不在数组大小范围内，进而无法匹配存储位置；</p>
<ol>
<li><p>HashMap自己实现了自己的hash()方法，通过两次扰动使得它自己的哈希值高低位自行进行异或运算，降低哈希碰撞概率也使得数据分布更平均；</p>
</li>
<li><p>在保证数组长度为2的幂次方的时候，使用hash()运算之后的值与运算（&amp;）（数组长度 - 1）来获取数组下标的方式进行存储，这样一来是比取余操作更加有效率，二来也是因为只有当数组长度为2的幂次方时，h&amp;(length-1)才等价于h%length，三来解决了“哈希值与数组大小范围不匹配”的问题。</p>
</li>
</ol>
<h3 id="HashMap-putVal"><a href="#HashMap-putVal" class="headerlink" title="HashMap putVal"></a>HashMap putVal</h3><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848502.png" alt="image-20210502162723163"></p>
<h3 id="解决hash冲突问题"><a href="#解决hash冲突问题" class="headerlink" title="解决hash冲突问题"></a>解决hash冲突问题</h3><ul>
<li>拉链法；</li>
<li>使用两次扰动函数（hash函数）；</li>
<li>引入红黑树。</li>
</ul>
<p>如果只是单纯的用hashCode取余来获取对应的bucket这将会大大增加哈希碰撞的概率，并且最坏情况下还会将HashMap变成一个单链表，所以还需要对hashCode作一定的优化 hash()函数。</p>
<p>上面提到的问题，主要是因为如果使用hashCode取余，那么相当于参与运算的只有hashCode的低位，高位是没有起到任何作用的，所以我们的思路就是让 hashCode取值出的高位也参与运算，进一步降低hash碰撞的概率，使得数据分布更平均，这样的操作称为扰动，在JDK 1.8中的hash()函数如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1	static final int hash(Object key) &#123;</span><br><span class="line">2	int h;</span><br><span class="line">3	return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);// 与自己右移16位进行异或运算（高低位异或）</span><br><span class="line">4	&#125;</span><br></pre></td></tr></table></figure>

<p>这比在JDK 1.7中，更为简洁，相比在1.7中的4次位运算，5次异或运算（9次扰动），在1.8中，只进行了1次位运算和1次异或运算（2次扰动）；</p>
<h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><ul>
<li><p>Jdk1.7 分段数组+链表，jdk1.8 数组+链表&#x2F;红黑树；</p>
</li>
<li><p>Jdk1.7 采用分段锁，每把锁只锁一部分数据；</p>
</li>
<li><p>Jdk 1.8 采用 CAS 和 synchronized 来保证并发安全；</p>
</li>
<li><p>synchronized 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，效率又提升 N 倍；</p>
</li>
<li><p>ConcurrentHashMap 的初始化是通过自旋和 CAS 操作完成的；</p>
</li>
<li><p>建值对不能为空；</p>
</li>
<li><p>建议根据需求给初始容量，以防后期扩容很耗时，给32的话实际是64。</p>
</li>
</ul>
<p>sizeCtl:</p>
<ol>
<li>-1 说明正在初始化</li>
<li>-N 说明有N-1个线程正在进行扩容</li>
<li>表示 table 初始化大小，如果 table 没有初始化</li>
<li>表示 table 容量，如果 table已经初始化。</li>
</ol>
<p>put源码:</p>
<ol>
<li>根据 key 计算出 hashcode 。</li>
<li>判断是否需要进行初始化。</li>
<li>即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。</li>
<li>如果当前位置的 <code>hashcode == MOVED == -1</code>，则需要进行扩容。</li>
<li>如果都不满足，则利用 synchronized 锁写入数据。</li>
<li>如果数量大于 <code>TREEIFY_THRESHOLD</code> 则要转换为红黑树。</li>
</ol>
<p>get源码:</p>
<ol>
<li>根据 hash 值计算位置。</li>
<li>查找到指定位置，如果头节点就是要找的，直接返回它的 value。</li>
<li>如果头节点 hash 值小于 0 ，说明正在扩容或者是红黑树，查找之。</li>
<li>如果是链表，遍历查找之。</li>
</ol>
<p>插入元素过程：</p>
<p>如果相应位置的Node还没有初始化，则调用CAS插入相应的数据；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1	else if ((f = tabAt(tab， i = (n ‐ 1) &amp; hash)) == null) &#123;</span><br><span class="line">2	if (casTabAt(tab， i， null， new Node&lt;K，V&gt;(hash， key， value， null)))</span><br><span class="line">3	break; // no lock when adding to empty bin</span><br><span class="line">4	&#125;</span><br></pre></td></tr></table></figure>

<p>如果相应位置的Node不为空，且当前该节点不处于移动状态，则对该节点加synchronized锁，如果该节点的hash不小于0，则遍历链表更新节点或插入新节点；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1 if (fh &gt;= 0) &#123; </span><br><span class="line">2 binCount = 1;</span><br><span class="line">3	for (Node&lt;K，V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">4	K ek;</span><br><span class="line">5	if (e.hash == hash &amp;&amp;</span><br><span class="line">6	((ek = e.key) == key ||</span><br><span class="line">7	(ek != null &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">8	oldVal = e.val;</span><br><span class="line">9	if (!onlyIfAbsent)</span><br><span class="line">10	e.val = value;</span><br><span class="line">11	break;</span><br><span class="line">12	&#125;</span><br><span class="line">13	Node&lt;K，V&gt; pred = e;</span><br><span class="line">14	if ((e = e.next) == null) &#123;</span><br><span class="line">15	pred.next = new Node&lt;K，V&gt;(hash， key， value， null);</span><br><span class="line">16	break;</span><br><span class="line">17	&#125;</span><br><span class="line">18	&#125;</span><br><span class="line">19	&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>如果该节点是TreeBin类型的节点，说明是红黑树结构，则通过 putTreeVal方法往红黑树中插入节点；如果binCount不为0，说明put操作对数据产生了影响，如果当前链表的个数达到8个，则通过treeifyBin方法转化为红黑树，如果oldVal不为空，说明是一次更新操作，没有对元素个数产生影响，则直接返回旧值；</p>
</li>
<li><p>如果插入的是一个新节点，则执行addCount()方法尝试更新元素个数 baseCount；</p>
</li>
</ol>
<h2 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h2><ul>
<li>默认11，扩容2n+ 1；</li>
<li>线程安全，所有方法都用sychronized修饰；</li>
<li>不允许null键和值；</li>
<li>没有转红黑树的机制；</li>
<li>如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get。</li>
</ul>
<h2 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h2><ul>
<li>用于获取配置文件值，key-value形式。</li>
</ul>
<h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><ul>
<li>相比于HashMap来说 TreeMap 主要多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力。</li>
</ul>
<h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848696.jpg" alt="LinkedHashMap源码详细分析（JDK1.8）_"></p>
<h2 id="如何决定使用-HashMap-还是TreeMap？"><a href="#如何决定使用-HashMap-还是TreeMap？" class="headerlink" title="如何决定使用 HashMap 还是TreeMap？"></a>如何决定使用 HashMap 还是TreeMap？</h2><p>对于在Map中插入、删除和定位元素这类操作，HashMap是好的选择。然而，假如你需要对一个有序的key集合进行遍历，TreeMap是更好的选择。基于你的collection的大小，也许向HashMap中添加元素会更快，将map换为TreeMap进行有序key的遍历</p>
<h2 id="Array-和-ArrayList-有何区别？"><a href="#Array-和-ArrayList-有何区别？" class="headerlink" title="Array 和 ArrayList 有何区别？"></a>Array 和 ArrayList 有何区别？</h2><ul>
<li>Array 可以存储基本数据类型和对象，ArrayList 只能存储对象；</li>
<li>Array 是指定固定大小的，而 ArrayList 大小是自动扩展的；</li>
<li>Array 内置方法没有 ArrayList 多，比如 addAll、removeAll、iteration 等方法只有 ArrayList 有；</li>
</ul>
<p>对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。</p>
<h2 id="如何实现-Array-和-List-之间的转换？"><a href="#如何实现-Array-和-List-之间的转换？" class="headerlink" title="如何实现 Array 和 List 之间的转换？"></a>如何实现 Array 和 List 之间的转换？</h2><ul>
<li>Array 转 List： Arrays. asList(array) ；</li>
<li>List 转 Array：List 的 toArray() 方法。</li>
</ul>
<h2 id="comparable-和-comparator的区别？"><a href="#comparable-和-comparator的区别？" class="headerlink" title="comparable 和 comparator的区别？"></a>comparable 和 comparator的区别？</h2><ul>
<li>comparable接口是出自java.lang包，它有一个 compareTo(Object obj)方法用来排序</li>
<li>comparator接口是出自 java.util 包，它有一个compare(Object obj1， Object obj2)方法用来排序</li>
</ul>
<p>一般需要对一个集合使用自定义排序时，就要重写compareTo方法或 compare方法，当需要对某一个集合实现两种排序方式，比如一个song对象中的歌名和歌手名分别采用一种排序方法的话，可以重写compareTo方法和使用自制的Comparator方法或者以两个Comparator来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的Collections.sort()。</p>
<h2 id="Collection-和-Collections-有什么区别？"><a href="#Collection-和-Collections-有什么区别？" class="headerlink" title="Collection 和 Collections 有什么区别？"></a>Collection 和 Collections 有什么区别？</h2><ul>
<li>java.util.Collection 是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了 大化的统一操作方式，其直接继承接口有List与Set。</li>
<li>Collections则是集合类的一个工具类&#x2F;帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。</li>
</ul>
<h2 id="TreeMap-和-TreeSet-在排序时如何比较元素？-Collections-工具类中的-sort-方法如何比较元素？"><a href="#TreeMap-和-TreeSet-在排序时如何比较元素？-Collections-工具类中的-sort-方法如何比较元素？" class="headerlink" title="TreeMap 和 TreeSet 在排序时如何比较元素？ Collections 工具类中的 sort()方法如何比较元素？"></a>TreeMap 和 TreeSet 在排序时如何比较元素？ Collections 工具类中的 sort()方法如何比较元素？</h2><p>TreeSet 要求存放的对象所属的类必须实现 Comparable 接口，该接口提供了比较元素的 compareTo()方法，当插入元素时会回调该方法比较元素的大小。</p>
<p>TreeMap 要求存放的键值对映射的键必须实现 Comparable 接口从而根据键对元素进行排序。</p>
<p>Collections 工具类的 sort 方法有两种重载的形式，</p>
<p>第一种要求传入的待排序容器中存放的对象比较实现 Comparable 接口以实现元素的比较；</p>
<p>第二种不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，参数是Comparator 接口的子类型（需要重写 compare 方法实现元素的比较），相当于一个临时定义的排序规则，其实就是通过接口注入比较元素大小的算法，也是对回调模式的应用（Java 中对函数式编程的支持）。</p>
<h1 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h1><p>多核cpu性能好， 但是成本高; 多cpu成本小，便宜，但是性能相对较差;</p>
<p>超线程， 一个核里面有两组寄存器，pc，但只有一个ALU，两个线程切换不需要保存现场，速度很快; 4核8线程是指有4个核，每个核有两组寄存器和pc;</p>
<p>一个cacheline 64字节， 从内存一次中一次读一个cacheline， 先读到L3cache， 然后L2cache， 然后L1cache;</p>
<p>图中一个cpu里面两个核， 一般L3Cache1只在一个cpu里面;</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848138.png" alt="image-20210423105857316"></p>
<p>假设对x和y使用了volatile，那么缓存需要一致，保持可见性，使用缓存一致性协议</p>
<p>线程1只用x， 而线程2只用y，使用有缓存一致性协议，x改了，线程二也得重新读缓存行，其实没有必要，它只用y， 可以缓存行对齐的方式解决， 浪费几个空间，x后面用无用数据占满;</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848127.png" alt="image-20210423110113455"></p>
<p>MSI MESI(intel) MOSI Synapse Firefly Dragon 都是缓存一致性协议，只是用在不同的cpu上</p>
<p>硬件上使用缓存锁;</p>
<p>如果其中一个缓存行改了，它会写回主存，它还会通过总线，告诉另一个缓存行你这个是invaild，然后这个缓存行回去缓存中读过; </p>
<p>MESI， 总线锁是volatile的具体实现;</p>
<p>volatile在jvm级别是通过内存屏障来防止乱序执行;到c++这个级别是通过lock执行来保证;</p>
<h2 id="DCL-double-checked-locking-单例模式需要加volatile吗"><a href="#DCL-double-checked-locking-单例模式需要加volatile吗" class="headerlink" title="DCL (double-checked locking)单例模式需要加volatile吗"></a>DCL (double-checked locking)单例模式需要加volatile吗</h2><p>对象创建分为3步， 分配内存(此时的变量都只有默认值)，初始化，然后引用指向这块内存</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848148.png" alt="image-20210423114558613"></p>
<p>假设第一个线程初始化的时候发生指令重拍，指向了半初始化对象， 此时还没有执行构造方法; </p>
<p>然后第二个线程来了， 先判断t是否为空， 不空就直接用，使用了半初始化的对象，运行一百万次都难得出现一次，没有并发一定不会出现.</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848159.png" alt="image-20210423114754951"></p>
<p>cpu指令重排: 假设指令一去读数据了，然后指令二不依赖于指令一，cpu就会接着执行指令二</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848295.png" alt="image-20210423111942569"></p>
<p>wcbuffer (write combining)合并写buffer， 就4个字节，</p>
<p>为了提高效率，cpu在写入L1时，同时用wc写入L2， 由于ALU速度太快，所以在写入L1的同时，写入一份WCBuffer ， 满了之后， 再直接更新到L2</p>
<h2 id="cpu层面如何禁止重排序"><a href="#cpu层面如何禁止重排序" class="headerlink" title="cpu层面如何禁止重排序?"></a>cpu层面如何禁止重排序?</h2><p>内存屏障， 对某部分内存做操作时前后添加屏障， 屏障前后的操作不可以乱序执行</p>
<h2 id="禁止乱序"><a href="#禁止乱序" class="headerlink" title="禁止乱序"></a>禁止乱序</h2><p>cpu层面: Intel -》原语(mfence（混合）， lfence（Load）， sfence（Store）)或者锁总线</p>
<p>JVM层面: 8个happens-before原则， 4个内存屏障(ll， ls， sl， ss)</p>
<p>as if serial: 不管硬件什么执行顺序， 单线程执行的结果不变， 看上去像是serial</p>
<p>hotspot就使用了lock(汇编指令)指令来执行</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">MingwHuang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://mingwzi.cn/2021/12/21/base/Java/">http://mingwzi.cn/2021/12/21/base/Java/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://mingwzi.cn" target="_blank">MingwHuang's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post_share"><div class="social-share" data-image="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272046990.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202172251674.png" target="_blank"><img class="post-qr-code-img" src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202172251674.png" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202172251973.png" target="_blank"><img class="post-qr-code-img" src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202172251973.png" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/12/21/base/LeetCode/"><img class="prev-cover" src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272046012.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Leetcode</div></div></a></div><div class="next-post pull-right"><a href="/2021/12/21/base/Zookeeper/"><img class="next-cover" src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272046164.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Zookeeper</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272113875.JPG" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">MingwHuang</div><div class="author-info__description">朝花夕拾 聊以记之</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">45</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">42</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/HuangMingwang" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:1125385880@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站域名：http://mingwzi.cn</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Java"><span class="toc-number">1.</span> <span class="toc-text">Java</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80"><span class="toc-number">1.1.</span> <span class="toc-text">基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9"><span class="toc-number">1.1.1.</span> <span class="toc-text">内部类的优点和缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#switch-%E6%98%AF%E5%90%A6%E8%83%BD%E4%BD%9C%E7%94%A8%E5%9C%A8-byte%EF%BC%8Clong%EF%BC%8CString"><span class="toc-number">1.1.2.</span> <span class="toc-text">switch 是否能作用在 byte，long，String</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E8%AF%AD%E8%A8%80%E9%87%87%E7%94%A8%E4%BD%95%E7%A7%8D%E7%BC%96%E7%A0%81%E6%96%B9%E6%A1%88"><span class="toc-number">1.1.3.</span> <span class="toc-text">Java语言采用何种编码方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8-Java-%E4%B8%AD%EF%BC%8C%E5%A6%82%E4%BD%95%E8%B7%B3%E5%87%BA%E5%BD%93%E5%89%8D%E7%9A%84%E5%A4%9A%E9%87%8D%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">在 Java 中，如何跳出当前的多重嵌套循环</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%9C%80%E6%9C%89%E6%95%88%E7%8E%87%E7%9A%84%E6%96%B9%E6%B3%95%E8%AE%A1%E7%AE%97-2%E7%9A%843%E6%AC%A1%E6%96%B9"><span class="toc-number">1.1.4.</span> <span class="toc-text">用最有效率的方法计算 2的3次方</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#float-f-x3D-3-4"><span class="toc-number">1.1.5.</span> <span class="toc-text">float f&#x3D;3.4</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#short-s1-x3D-1-s1-x3D-s1-1-%E5%92%8C-short-s1-x3D-1-s1-x3D-1"><span class="toc-number">1.1.6.</span> <span class="toc-text">short s1 &#x3D; 1; s1 &#x3D; s1 + 1; 和 short s1 &#x3D; 1; s1 +&#x3D; 1;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#private%EF%BC%8Cdefault%EF%BC%8Cprotected%EF%BC%8Cpublic"><span class="toc-number">1.1.7.</span> <span class="toc-text">private，default，protected，public</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%EF%BC%88%E4%B8%8D%E8%80%83%E8%99%91%E5%86%85%E9%83%A8%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%EF%BC%89%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8private%E5%92%8Cprotected%E4%BF%AE%E9%A5%B0%E8%AF%8D%EF%BC%8C%E5%8F%AA%E8%83%BD%E6%98%AFpublic%E5%92%8Cdefault%EF%BC%9F"><span class="toc-number">1.1.7.1.</span> <span class="toc-text">为什么类和接口（不考虑内部类和接口）不能使用private和protected修饰词，只能是public和default？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%96%B9%E6%B3%95%E4%B8%8D%E8%83%BD%E6%98%AFprivate%E5%92%8Cprotected%EF%BC%8C%E5%8F%AA%E8%83%BDpublic%EF%BC%88default%E5%8F%AF%E4%BB%A5%E5%86%99%E5%87%BA%E6%9D%A5%EF%BC%8C%E4%BD%86%E6%98%AF%E7%BC%96%E8%AF%91%E4%B9%8B%E5%90%8E%E8%87%AA%E5%8A%A8%E8%BD%AC%E4%B8%BA%E4%BA%86public%EF%BC%89%EF%BC%9F"><span class="toc-number">1.1.7.2.</span> <span class="toc-text">为什么接口的方法不能是private和protected，只能public（default可以写出来，但是编译之后自动转为了public）？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-0-1-x3D-x3D-0-3%E8%BF%94%E5%9B%9E%E5%80%BC%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.1.8.</span> <span class="toc-text">3*0.1&#x3D;&#x3D;0.3返回值是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#final"><span class="toc-number">1.1.9.</span> <span class="toc-text">final</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java%E8%AF%AD%E8%A8%80%E7%89%B9%E7%82%B9"><span class="toc-number">1.1.10.</span> <span class="toc-text">java语言特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM-JDK-JRE"><span class="toc-number">1.1.11.</span> <span class="toc-text">JVM JDK JRE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Oracle-JDK-%E5%92%8C-Open-JDK%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">1.1.12.</span> <span class="toc-text">Oracle JDK 和 Open JDK的对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E5%92%8CC-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.13.</span> <span class="toc-text">Java和C++的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#import-java%E5%92%8Cjavax-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.14.</span> <span class="toc-text">import java和javax 的区别?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4Java%E8%AF%AD%E8%A8%80%E2%80%9C%E7%BC%96%E8%AF%91%E4%B8%8E%E8%A7%A3%E9%87%8A%E5%B9%B6%E5%AD%98%E2%80%9D"><span class="toc-number">1.1.15.</span> <span class="toc-text">为什么说Java语言“编译与解释并存”?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E5%9E%8B%E5%B8%B8%E9%87%8F%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.16.</span> <span class="toc-text">字符型常量和字符串常量区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AF%86%E7%AC%A6%E5%92%8C%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.17.</span> <span class="toc-text">标识符和关键字的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E6%B3%9B%E5%9E%8B-%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E5%B8%B8%E7%94%A8%E7%9A%84%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-number">1.1.18.</span> <span class="toc-text">Java泛型?什么是类型擦除? 介绍一下常用的通配符?</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-number">1.1.18.0.1.</span> <span class="toc-text">通配符</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#x3D-x3D-%E5%92%8C-equals"><span class="toc-number">1.1.19.</span> <span class="toc-text">&#x3D;&#x3D; 和 equals</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hashCode-%E4%B8%8E-equals"><span class="toc-number">1.1.20.</span> <span class="toc-text">hashCode() 与 equals()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AB%E7%A7%8D%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E3%80%81%E5%8C%85%E8%A3%85%E7%B1%BB%E3%80%81%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-number">1.1.21.</span> <span class="toc-text">八种基本类型、包装类、常量池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E5%80%BC%E4%BC%A0%E9%80%92"><span class="toc-number">1.1.22.</span> <span class="toc-text">Java值传递?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.23.</span> <span class="toc-text">重载和重写的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.24.</span> <span class="toc-text">面向对象和面向过程的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8%E6%98%AF%E5%90%A6%E5%8F%AF%E8%A2%AB%E9%87%8D%E5%86%99"><span class="toc-number">1.1.25.</span> <span class="toc-text">构造器是否可被重写?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8Java%E4%B8%AD%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E4%B8%8D%E5%81%9A%E4%BA%8B%E4%B8%94%E6%B2%A1%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.1.26.</span> <span class="toc-text">在Java中定义一个不做事且没有参数的构造方法的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88-%E8%8B%A5%E4%B8%80%E4%B8%AA%E7%B1%BB%E6%B2%A1%E6%9C%89%E5%A3%B0%E6%98%8E%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%EF%BC%8C%E8%AF%A5%E7%A8%8B%E5%BA%8F%E8%83%BD%E6%AD%A3%E7%A1%AE%E6%89%A7%E8%A1%8C%E5%90%97"><span class="toc-number">1.1.27.</span> <span class="toc-text">一个类的构造方法的作用是什么? 若一个类没有声明构造方法，该程序能正确执行吗?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">1.1.28.</span> <span class="toc-text">成员变量和局部变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81"><span class="toc-number">1.1.29.</span> <span class="toc-text">面向对象的三大特征</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%81%E8%A3%85"><span class="toc-number">1.1.29.1.</span> <span class="toc-text">封装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">1.1.29.2.</span> <span class="toc-text">继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-number">1.1.29.3.</span> <span class="toc-text">多态</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E4%B8%80%E4%B8%AA%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%86%85%E8%B0%83%E7%94%A8%E4%B8%80%E4%B8%AA%E9%9D%9E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%9E%E6%B3%95%E7%9A%84"><span class="toc-number">1.1.30.</span> <span class="toc-text">在一个静态方法内调用一个非静态成员为什么是非法的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String-StringBuffer-%E5%92%8C-StringBuilder"><span class="toc-number">1.1.31.</span> <span class="toc-text">String StringBuffer 和 StringBuilder</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%AD%E5%A6%82%E6%9E%9C%E6%9C%89%E4%BA%9B%E5%AD%97%E6%AE%B5%E4%B8%8D%E6%83%B3%E8%BF%9B%E8%A1%8C%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%8C%E6%80%8E%E4%B9%88%E5%8A%9E"><span class="toc-number">1.1.32.</span> <span class="toc-text">Java序列化中如果有些字段不想进行序列化，怎么办?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.33.</span> <span class="toc-text">获取键盘输入的常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6"><span class="toc-number">1.1.34.</span> <span class="toc-text">反射机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E7%BC%96%E8%AF%91%E5%92%8C%E5%8A%A8%E6%80%81%E7%BC%96%E8%AF%91"><span class="toc-number">1.1.35.</span> <span class="toc-text">静态编译和动态编译</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">1.1.36.</span> <span class="toc-text">反射机制优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.1.37.</span> <span class="toc-text">反射的应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96class%E5%AF%B9%E8%B1%A1%E7%9A%844%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">1.1.38.</span> <span class="toc-text">获取class对象的4种方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8"><span class="toc-number">1.1.39.</span> <span class="toc-text">异常</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%97%E6%A3%80%E5%BC%82%E5%B8%B8"><span class="toc-number">1.1.39.1.</span> <span class="toc-text">受检异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%8F%97%E6%A3%80%E5%BC%82%E5%B8%B8"><span class="toc-number">1.1.39.2.</span> <span class="toc-text">不受检异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Throwable%E7%B1%BB%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.39.3.</span> <span class="toc-text">Throwable类常用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#try-catch-finally"><span class="toc-number">1.1.39.4.</span> <span class="toc-text">try-catch-finally</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8try-with-resources%E6%9D%A5%E4%BB%A3%E6%9B%BFtry-catch-finally"><span class="toc-number">1.1.39.5.</span> <span class="toc-text">使用try-with-resources来代替try-catch-finally</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JVM-%E6%98%AF%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8%E7%9A%84%EF%BC%9F"><span class="toc-number">1.1.39.6.</span> <span class="toc-text">JVM 是如何处理异常的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#throw-%E5%92%8C-throws"><span class="toc-number">1.1.39.7.</span> <span class="toc-text">throw 和 throws</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#final%E3%80%81finally%E3%80%81finalize-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.1.39.8.</span> <span class="toc-text">final、finally、finalize 有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NoClassDefFoundError-%E5%92%8C-ClassNotFoundException"><span class="toc-number">1.1.39.9.</span> <span class="toc-text">NoClassDefFoundError 和  ClassNotFoundException</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#try-catch-finally-1"><span class="toc-number">1.1.39.10.</span> <span class="toc-text">try-catch-finally</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#try-catch-finally-%E4%B8%AD%EF%BC%8C%E5%A6%82%E6%9E%9C-catch-%E4%B8%AD-return-%E4%BA%86%EF%BC%8C-finally-%E8%BF%98%E4%BC%9A%E6%89%A7%E8%A1%8C%E5%90%97%EF%BC%9F"><span class="toc-number">1.1.39.11.</span> <span class="toc-text">try-catch-finally 中，如果 catch 中 return 了， finally 还会执行吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB-ExampleA-%E7%BB%A7%E6%89%BF-Exception%EF%BC%8C%E7%B1%BB-ExampleB-%E7%BB%A7%E6%89%BF-ExampleA%E3%80%82"><span class="toc-number">1.1.39.12.</span> <span class="toc-text">类 ExampleA 继承 Exception，类 ExampleB 继承 ExampleA。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java%E5%B8%B8%E8%A7%81%E5%BC%82%E5%B8%B8"><span class="toc-number">1.1.39.13.</span> <span class="toc-text">Java常见异常</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A2%E7%84%B6%E6%9C%89%E4%BA%86%E5%AD%97%E8%8A%82%E6%B5%81%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E6%9C%89%E5%AD%97%E7%AC%A6%E6%B5%81"><span class="toc-number">1.1.40.</span> <span class="toc-text">既然有了字节流，为什么还要有字符流?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">1.2.</span> <span class="toc-text">静态代理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">1.3.</span> <span class="toc-text">动态代理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%9C%BA%E5%88%B6"><span class="toc-number">1.3.1.</span> <span class="toc-text">JDK动态代理机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CGLIB%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%9C%BA%E5%88%B6"><span class="toc-number">1.3.2.</span> <span class="toc-text">CGLIB动态代理机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8CCGLIB%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AF%B9%E6%AF%94"><span class="toc-number">1.3.3.</span> <span class="toc-text">JDK动态代理和CGLIB动态代理对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8C%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">1.3.4.</span> <span class="toc-text">动态代理和静态代理的对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E5%9E%8B%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="toc-number">1.4.</span> <span class="toc-text">整型包装类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BigDecimal"><span class="toc-number">1.5.</span> <span class="toc-text">BigDecimal</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Arrays-asList"><span class="toc-number">1.6.</span> <span class="toc-text">Arrays.asList()</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%B0%86%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BAArrayList"><span class="toc-number">1.6.1.</span> <span class="toc-text">如何正确的将数组转换为ArrayList?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Collection-toArray-%E6%96%B9%E6%B3%95%E4%BD%BF%E7%94%A8%E7%9A%84%E5%9D%91-amp-%E5%A6%82%E4%BD%95%E5%8F%8D%E8%BD%AC%E6%95%B0%E7%BB%84"><span class="toc-number">1.6.2.</span> <span class="toc-text">Collection.toArray()方法使用的坑&amp;如何反转数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E8%A6%81%E5%9C%A8-foreach-%E5%BE%AA%E7%8E%AF%E9%87%8C%E8%BF%9B%E8%A1%8C%E5%85%83%E7%B4%A0%E7%9A%84-remove-x2F-add-%E6%93%8D%E4%BD%9C"><span class="toc-number">1.6.3.</span> <span class="toc-text">不要在 foreach 循环里进行元素的 remove&#x2F;add 操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#final%EF%BC%8Cstatic%EF%BC%8Cthis%EF%BC%8Csuper%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.7.</span> <span class="toc-text">final，static，this，super关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#static"><span class="toc-number">1.7.1.</span> <span class="toc-text">static</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#this%E5%92%8Csuper%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.7.2.</span> <span class="toc-text">this和super的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">1.7.3.</span> <span class="toc-text">静态代码块</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-number">1.8.</span> <span class="toc-text">Java内存泄漏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE"><span class="toc-number">1.9.</span> <span class="toc-text">枚举</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9E%9A%E4%B8%BE%E6%96%B9%E6%B3%95"><span class="toc-number">1.9.1.</span> <span class="toc-text">自定义枚举方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-x3D-x3D-%E6%AF%94%E8%BE%83%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.9.2.</span> <span class="toc-text">使用&#x3D;&#x3D;比较枚举类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8Switch%E8%AF%AD%E5%8F%A5%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.9.3.</span> <span class="toc-text">在Switch语句中使用枚举类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B"><span class="toc-number">1.9.4.</span> <span class="toc-text">实例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#IO"><span class="toc-number">2.</span> <span class="toc-text">IO</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Direct-IO"><span class="toc-number">2.1.</span> <span class="toc-text">Direct IO</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Select-Poll-Epoll"><span class="toc-number">2.2.</span> <span class="toc-text">Select Poll Epoll</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#select"><span class="toc-number">2.2.1.</span> <span class="toc-text">select</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#poll"><span class="toc-number">2.2.2.</span> <span class="toc-text">poll</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#epoll"><span class="toc-number">2.2.3.</span> <span class="toc-text">epoll</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">2.2.4.</span> <span class="toc-text">应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-select-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">2.2.4.1.</span> <span class="toc-text">1. select 应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-poll-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">2.2.4.2.</span> <span class="toc-text">2. poll 应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-epoll-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">2.2.4.3.</span> <span class="toc-text">3. epoll 应用场景</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BIO"><span class="toc-number">2.3.</span> <span class="toc-text">BIO</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NIO"><span class="toc-number">2.4.</span> <span class="toc-text">NIO</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Channel-%E5%92%8C-Buffer"><span class="toc-number">2.4.1.</span> <span class="toc-text">Channel 和 Buffer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Selector"><span class="toc-number">2.4.2.</span> <span class="toc-text">Selector</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3"><span class="toc-number">2.4.3.</span> <span class="toc-text">个人理解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Read%E5%92%8CWrite%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">2.5.</span> <span class="toc-text">Read和Write系统调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.6.</span> <span class="toc-text">Linux五种IO模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8%E5%BC%8FIO"><span class="toc-number">2.6.1.</span> <span class="toc-text">信号驱动式IO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E9%98%BB%E5%A1%9EIO-Blocking-IO"><span class="toc-number">2.6.2.</span> <span class="toc-text">同步阻塞IO(Blocking IO)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E9%9D%9E%E9%98%BB%E5%A1%9E-None-Blocking-IO"><span class="toc-number">2.6.3.</span> <span class="toc-text">同步非阻塞(None Blocking IO)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%A8%A1%E5%9E%8B-I-x2F-O-multiplexing%EF%BC%89"><span class="toc-number">2.6.4.</span> <span class="toc-text">IO多路复用模型(I&#x2F;O multiplexing）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5IO%E6%A8%A1%E5%9E%8B%EF%BC%88asynchronous-IO%EF%BC%89"><span class="toc-number">2.6.5.</span> <span class="toc-text">异步IO模型（asynchronous IO）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93%E4%B8%80%E4%B8%8B%EF%BC%9A"><span class="toc-number">2.6.6.</span> <span class="toc-text">小结一下：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%B6%E6%8B%B7%E8%B4%9D"><span class="toc-number">2.7.</span> <span class="toc-text">零拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BC%A0%E7%BB%9F-I-x2F-O"><span class="toc-number">2.7.0.1.</span> <span class="toc-text">1. 传统 I&#x2F;O</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%94%A8%E6%88%B7%E6%80%81%E7%9B%B4%E6%8E%A5IO"><span class="toc-number">2.7.0.2.</span> <span class="toc-text">2. 用户态直接IO</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-mmap"><span class="toc-number">2.7.0.3.</span> <span class="toc-text">3. mmap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-sendfile"><span class="toc-number">2.7.0.4.</span> <span class="toc-text">4. sendfile</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-sendfile-DMA-gather-copy"><span class="toc-number">2.7.0.5.</span> <span class="toc-text">5. sendfile + DMA gather copy</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-splice"><span class="toc-number">2.7.0.6.</span> <span class="toc-text">6. splice</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6"><span class="toc-number">2.7.0.7.</span> <span class="toc-text">7. 写时复制</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91"><span class="toc-number">3.</span> <span class="toc-text">并发</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="toc-number">3.1.</span> <span class="toc-text">进程和线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">3.1.1.</span> <span class="toc-text">多进程编程和多线程编程的优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E7%8A%B6%E6%80%81"><span class="toc-number">3.1.2.</span> <span class="toc-text">线程的生命周期和状态?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81%E7%9A%84%E5%9B%9B%E4%B8%AA%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="toc-number">3.1.3.</span> <span class="toc-text">线程死锁的四个必要条件?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88"><span class="toc-number">3.1.4.</span> <span class="toc-text">死锁处理方案?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sleep-%E5%92%8Cwait"><span class="toc-number">3.1.5.</span> <span class="toc-text">sleep()和wait()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Start-%E5%92%8CRun"><span class="toc-number">3.1.6.</span> <span class="toc-text">Start()和Run()</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%843%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">3.1.6.1.</span> <span class="toc-text">创建线程的3种方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%81%9C%E6%AD%A2%E7%BA%BF%E7%A8%8B"><span class="toc-number">3.1.7.</span> <span class="toc-text">停止线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CopyOnWriteArrayList%EF%BC%88COW%EF%BC%89"><span class="toc-number">3.1.8.</span> <span class="toc-text">CopyOnWriteArrayList（COW）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Fail-fast-%E5%BF%AB%E9%80%9F%E5%A4%B1%E8%B4%A5-%E5%92%8C-fail-safe-%E5%AE%89%E5%85%A8%E5%A4%B1%E8%B4%A5"><span class="toc-number">3.1.9.</span> <span class="toc-text">Fail-fast(快速失败) 和 fail-safe(安全失败)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#concurrentModificationException-%E5%B9%B6%E5%8F%91%E4%BF%AE%E6%94%B9%E5%BC%82%E5%B8%B8"><span class="toc-number">3.1.10.</span> <span class="toc-text">concurrentModificationException 并发修改异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayIndexOutOfBoundsException"><span class="toc-number">3.1.11.</span> <span class="toc-text">ArrayIndexOutOfBoundsException</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CopyOnWriteSet"><span class="toc-number">3.1.12.</span> <span class="toc-text">CopyOnWriteSet</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B01-100"><span class="toc-number">3.1.13.</span> <span class="toc-text">两个线程交替打印1-100</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CountDownLatch"><span class="toc-number">3.1.14.</span> <span class="toc-text">CountDownLatch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CyclicBarrier"><span class="toc-number">3.1.15.</span> <span class="toc-text">CyclicBarrier</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Semaphore-%E7%B1%BB"><span class="toc-number">3.1.16.</span> <span class="toc-text">Semaphore(类)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReadWriteLock-%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.1.17.</span> <span class="toc-text">ReadWriteLock(接口)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BlockingQueue-%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.1.18.</span> <span class="toc-text">BlockingQueue(接口)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SynchronizedQueue-%E7%B1%BB"><span class="toc-number">3.1.19.</span> <span class="toc-text">SynchronizedQueue(类)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Synchronized"><span class="toc-number">3.2.</span> <span class="toc-text">Synchronized</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90wait-x2F-notify%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%9C%A8%E5%90%8C%E6%AD%A5%E5%9D%97%E5%86%85"><span class="toc-number">3.2.1.</span> <span class="toc-text">深入分析wait&#x2F;notify为什么要在同步块内</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E5%81%87%E5%94%A4%E9%86%92%E9%97%AE%E9%A2%98"><span class="toc-number">3.2.2.</span> <span class="toc-text">虚假唤醒问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E5%81%87%E5%94%A4%E9%86%92%E6%98%AF%E5%A6%82%E4%BD%95%E4%BA%A7%E7%94%9F%E7%9A%84%EF%BC%9F"><span class="toc-number">3.2.2.1.</span> <span class="toc-text">虚假唤醒是如何产生的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88if%E5%88%A4%E6%96%AD%E4%BC%9A%E5%87%BA%E7%8E%B0%E8%99%9A%E5%81%87%E5%94%A4%E9%86%92%EF%BC%9F"><span class="toc-number">3.2.2.2.</span> <span class="toc-text">为什么if判断会出现虚假唤醒？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E9%94%81%E7%8E%B0%E8%B1%A1-%E5%85%B3%E4%BA%8E%E9%94%81%E7%9A%848%E4%B8%AA%E9%97%AE%E9%A2%98"><span class="toc-number">3.2.3.</span> <span class="toc-text">8锁现象(关于锁的8个问题)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized%E4%BC%98%E5%8C%96"><span class="toc-number">3.2.4.</span> <span class="toc-text">synchronized优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%81%E6%B6%88%E9%99%A4"><span class="toc-number">3.2.4.1.</span> <span class="toc-text">锁消除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%81%E7%B2%97%E5%8C%96"><span class="toc-number">3.2.4.2.</span> <span class="toc-text">锁粗化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lock"><span class="toc-number">3.3.</span> <span class="toc-text">Lock</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ReentrantLock"><span class="toc-number">3.4.</span> <span class="toc-text">ReentrantLock</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E3%80%81%E8%AF%BB%E5%86%99%E9%94%81%E3%80%81%E5%85%AC%E5%B9%B3%E9%94%81%E3%80%81%E5%8F%AF%E4%B8%AD%E6%96%AD%E9%94%81"><span class="toc-number">3.5.</span> <span class="toc-text">可重入锁、读写锁、公平锁、可中断锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81"><span class="toc-number">3.5.0.0.1.</span> <span class="toc-text">可重入锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E9%94%81"><span class="toc-number">3.5.0.0.2.</span> <span class="toc-text">读写锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E4%B8%AD%E6%96%AD%E9%94%81"><span class="toc-number">3.5.0.0.3.</span> <span class="toc-text">可中断锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81"><span class="toc-number">3.5.0.0.4.</span> <span class="toc-text">公平锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81"><span class="toc-number">3.5.0.0.5.</span> <span class="toc-text">非公平锁</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Synchronized%E5%92%8CLock%E6%AF%94%E8%BE%83"><span class="toc-number">3.6.</span> <span class="toc-text">Synchronized和Lock比较</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#volatile"><span class="toc-number">3.7.</span> <span class="toc-text">volatile</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile%E6%97%A0%E6%B3%95%E4%BF%9D%E8%AF%81%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8Fi-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%8E%9F%E5%9B%A0-JVM%E5%AD%97%E8%8A%82%E7%A0%81%E5%B1%82%E9%9D%A2"><span class="toc-number">3.7.1.</span> <span class="toc-text">volatile无法保证共享变量i++线程安全原因(JVM字节码层面)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JMM"><span class="toc-number">3.7.2.</span> <span class="toc-text">JMM</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E8%A1%8C%E5%AF%B9%E9%BD%90%E7%9A%84%E9%97%AE%E9%A2%98-%E4%BC%AA%E5%85%B1%E4%BA%AB%E9%97%AE%E9%A2%98"><span class="toc-number">3.7.2.1.</span> <span class="toc-text">缓存行对齐的问题 伪共享问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E4%B8%89%E4%B8%AA%E9%87%8D%E8%A6%81%E7%89%B9%E6%80%A7"><span class="toc-number">3.7.3.</span> <span class="toc-text">并发编程的三个重要特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized%E5%92%8Cvolatile%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.7.4.</span> <span class="toc-text">synchronized和volatile的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CAS"><span class="toc-number">3.8.</span> <span class="toc-text">CAS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU%E5%AE%9E%E7%8E%B0%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">3.8.1.</span> <span class="toc-text">CPU实现原子操作的原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%99%A8%E8%87%AA%E5%8A%A8%E4%BF%9D%E8%AF%81%E5%9F%BA%E6%9C%AC%E5%86%85%E5%AD%98%E6%93%8D%E4%BD%9C%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-number">3.8.1.1.</span> <span class="toc-text">处理器自动保证基本内存操作的原子性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E6%80%BB%E7%BA%BF%E9%94%81%E5%AE%9A%E6%9D%A5%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7%EF%BC%88%E7%B1%BB%E4%BC%BC%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E9%94%81%EF%BC%8C%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81%EF%BC%89"><span class="toc-number">3.8.1.2.</span> <span class="toc-text">通过总线锁定来保证原子性（类似于数据库表锁，重量级锁）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E7%BC%93%E5%AD%98%E9%94%81%E5%AE%9A%E6%9D%A5%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7%EF%BC%88%E7%B1%BB%E4%BC%BC%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%8C%E9%94%81%EF%BC%89"><span class="toc-number">3.8.1.3.</span> <span class="toc-text">通过缓存锁定来保证原子性（类似于数据库行锁）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS%E7%9A%84%E9%97%AE%E9%A2%98-%E8%87%AA%E6%97%8B%E6%B5%AA%E8%B4%B9cpu%E8%B5%84%E6%BA%90"><span class="toc-number">3.8.2.</span> <span class="toc-text">CAS的问题  自旋浪费cpu资源</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ABA%E9%97%AE%E9%A2%98"><span class="toc-number">3.8.2.0.1.</span> <span class="toc-text">ABA问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7%E6%B5%81%E9%87%8F%E8%BF%87%E5%A4%A7%E9%97%AE%E9%A2%98"><span class="toc-number">3.8.2.0.2.</span> <span class="toc-text">一致性流量过大问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MESI%EF%BC%88%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE%EF%BC%89"><span class="toc-number">3.8.3.</span> <span class="toc-text">MESI（缓存一致性协议）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadLocal"><span class="toc-number">3.9.</span> <span class="toc-text">ThreadLocal</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadLocal%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">3.9.1.</span> <span class="toc-text">ThreadLocal使用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%88%B0%E7%9A%84%E5%9C%B0%E6%96%B9"><span class="toc-number">3.9.1.1.</span> <span class="toc-text">在项目中使用到的地方</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadLocal%E5%8E%9F%E7%90%86"><span class="toc-number">3.9.2.</span> <span class="toc-text">ThreadLocal原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#set-%E6%BA%90%E7%A0%81"><span class="toc-number">3.9.2.1.</span> <span class="toc-text">set()源码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadLocal%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E9%97%AE%E9%A2%98"><span class="toc-number">3.9.3.</span> <span class="toc-text">ThreadLocal内存泄露问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ThreadLocalMap-key%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8%E5%BC%B1%E5%BC%95%E7%94%A8"><span class="toc-number">3.9.3.1.</span> <span class="toc-text">ThreadLocalMap key为什么用弱引用?</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%ADThreadLocal%E4%BD%BF%E7%94%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">3.9.4.</span> <span class="toc-text">在线程池中ThreadLocal使用的问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">3.10.</span> <span class="toc-text">线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C-execute-%E6%96%B9%E6%B3%95%E5%92%8C-submit-%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%E5%91%A2%EF%BC%9F"><span class="toc-number">3.10.1.</span> <span class="toc-text">执行 execute()方法和 submit()方法的区别是什么呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">3.10.2.</span> <span class="toc-text">如何创建线程池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A03%E5%A4%A7%E6%96%B9%E6%B3%95"><span class="toc-number">3.10.3.</span> <span class="toc-text">线程池3大方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%847%E4%B8%AA%E5%8F%82%E6%95%B0"><span class="toc-number">3.10.4.</span> <span class="toc-text">线程池的7个参数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E7%BA%BF%E7%A8%8B%E8%AF%A5%E6%80%8E%E4%B9%88%E5%AE%9A%E4%B9%89"><span class="toc-number">3.10.4.1.</span> <span class="toc-text">最大线程该怎么定义?</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%9B%9B%E5%A4%A7%E9%A5%B1%E5%92%8C%E7%AD%96%E7%95%A5"><span class="toc-number">3.10.5.</span> <span class="toc-text">线程池的四大饱和策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90"><span class="toc-number">3.10.6.</span> <span class="toc-text">线程池原理分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BC%98%E5%8C%96"><span class="toc-number">3.10.7.</span> <span class="toc-text">线程池优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8F%82%E6%95%B0%E5%8A%A8%E6%80%81%E5%8C%96"><span class="toc-number">3.10.8.</span> <span class="toc-text">线程池参数动态化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%93%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%87%8C%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E5%BC%82%E5%B8%B8%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">3.10.9.</span> <span class="toc-text">当线程池里的线程执行异常会发生什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E7%BA%BF%E4%B8%8A%E7%AA%81%E7%84%B6%E5%AE%95%E6%9C%BA%EF%BC%8C%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E4%B8%AD%E7%9A%84%E4%BB%BB%E5%8A%A1%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-number">3.10.10.</span> <span class="toc-text">如果线上突然宕机，阻塞队列中的任务怎么办？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E9%98%9F%E5%88%97%E6%BB%A1%E4%BA%86%E4%B9%8B%E5%90%8E%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%E4%BA%8B%E6%83%85%EF%BC%9F"><span class="toc-number">3.10.11.</span> <span class="toc-text">如果线程池的队列满了之后会发生什么事情？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E5%A4%A7%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.11.</span> <span class="toc-text">四大函数式接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Stream%E6%B5%81%E5%BC%8F%E8%AE%A1%E7%AE%97"><span class="toc-number">3.12.</span> <span class="toc-text">Stream流式计算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ForkJoin"><span class="toc-number">3.13.</span> <span class="toc-text">ForkJoin</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E5%9B%9E%E8%B0%83"><span class="toc-number">3.14.</span> <span class="toc-text">异步回调</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Atomic%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="toc-number">3.15.</span> <span class="toc-text">Atomic原子类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JUC-%E5%8C%85%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%AD%90%E7%B1%BB%E6%98%AF%E5%93%AA-4-%E7%B1%BB"><span class="toc-number">3.15.1.</span> <span class="toc-text">JUC 包中的原子类是哪 4 类?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AtomicInteger%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">3.15.2.</span> <span class="toc-text">AtomicInteger的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AtomicInteger%E7%B1%BB%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">3.15.3.</span> <span class="toc-text">AtomicInteger类的原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AQS"><span class="toc-number">3.16.</span> <span class="toc-text">AQS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AQS%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90"><span class="toc-number">3.16.1.</span> <span class="toc-text">AQS原理分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AQS%E5%AF%B9%E8%B5%84%E6%BA%90%E7%9A%84%E5%85%B1%E4%BA%AB%E6%96%B9%E5%BC%8F"><span class="toc-number">3.16.2.</span> <span class="toc-text">AQS对资源的共享方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AQS%E5%BA%95%E5%B1%82%E4%BD%BF%E7%94%A8%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.16.2.1.</span> <span class="toc-text">AQS底层使用模版方法模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AQS%E7%BB%84%E4%BB%B6%E6%80%BB%E7%BB%93"><span class="toc-number">3.16.3.</span> <span class="toc-text">AQS组件总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CountDownLatch-1"><span class="toc-number">3.16.4.</span> <span class="toc-text">CountDownLatch</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8"><span class="toc-number">4.</span> <span class="toc-text">容器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ArrayList"><span class="toc-number">4.1.</span> <span class="toc-text">ArrayList</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-ArrayList-%E7%9A%84-elementData-%E5%8A%A0%E4%B8%8A-transient-%E4%BF%AE%E9%A5%B0%EF%BC%9F"><span class="toc-number">4.1.1.</span> <span class="toc-text">为什么 ArrayList 的 elementData 加上 transient 修饰？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LinkedList"><span class="toc-number">4.2.</span> <span class="toc-text">LinkedList</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vector"><span class="toc-number">4.3.</span> <span class="toc-text">Vector</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Stack"><span class="toc-number">4.4.</span> <span class="toc-text">Stack</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PriorityQueue"><span class="toc-number">4.5.</span> <span class="toc-text">PriorityQueue</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ArrayDeque"><span class="toc-number">4.6.</span> <span class="toc-text">ArrayDeque</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Set"><span class="toc-number">4.7.</span> <span class="toc-text">Set</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TreeSet"><span class="toc-number">4.8.</span> <span class="toc-text">TreeSet</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashSet"><span class="toc-number">4.9.</span> <span class="toc-text">HashSet</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LinkedHashSet"><span class="toc-number">4.10.</span> <span class="toc-text">LinkedHashSet</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap"><span class="toc-number">4.11.</span> <span class="toc-text">HashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6-1-8"><span class="toc-number">4.11.1.</span> <span class="toc-text">扩容机制(1.8)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%BA%8F%E5%88%97%E5%8C%96table"><span class="toc-number">4.11.2.</span> <span class="toc-text">HashMap为什么不序列化table?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hashmap%E7%9A%84%E9%95%BF%E5%BA%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF2%E7%9A%84%E5%B9%82%E6%AC%A1%E6%96%B9"><span class="toc-number">4.11.3.</span> <span class="toc-text">hashmap的长度为什么是2的幂次方</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%93%8D%E4%BD%9C%E5%AF%BC%E8%87%B4%E6%AD%BB%E5%BE%AA%E7%8E%AF%E9%97%AE%E9%A2%98"><span class="toc-number">4.11.4.</span> <span class="toc-text">HashMap多线程操作导致死循环问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hash-Collision-Dos%E9%97%AE%E9%A2%98"><span class="toc-number">4.11.5.</span> <span class="toc-text">Hash Collision Dos问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%83%BD%E5%90%A6%E4%BD%BF%E7%94%A8%E4%BB%BB%E4%BD%95%E7%B1%BB%E4%BD%9C%E4%B8%BA-Map-%E7%9A%84-key%EF%BC%9F"><span class="toc-number">4.11.6.</span> <span class="toc-text">能否使用任何类作为 Map 的 key？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E4%BD%BF%E7%94%A8-HashMap-%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E7%94%A8-String-%E5%81%9A-key-%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84%EF%BC%9F"><span class="toc-number">4.11.7.</span> <span class="toc-text">在使用 HashMap 的时候，用 String 做 key 有什么好处？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E4%BD%BF%E7%94%A8Object%E4%BD%9C%E4%B8%BAHashMap%E7%9A%84Key%EF%BC%8C%E5%BA%94%E8%AF%A5%E6%80%8E%E4%B9%88%E5%8A%9E%E5%91%A2%EF%BC%9F"><span class="toc-number">4.11.8.</span> <span class="toc-text">如果使用Object作为HashMap的Key，应该怎么办呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8hashCode-%E5%A4%84%E7%90%86%E5%90%8E%E7%9A%84%E5%93%88%E5%B8%8C%E5%80%BC%E7%9B%B4%E6%8E%A5%E4%BD%9C%E4%B8%BAtable%E7%9A%84%E4%B8%8B%E6%A0%87%EF%BC%9F"><span class="toc-number">4.11.9.</span> <span class="toc-text">HashMap为什么不直接使用hashCode()处理后的哈希值直接作为table的下标？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap-putVal"><span class="toc-number">4.11.10.</span> <span class="toc-text">HashMap putVal</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3hash%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98"><span class="toc-number">4.11.11.</span> <span class="toc-text">解决hash冲突问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ConcurrentHashMap"><span class="toc-number">4.12.</span> <span class="toc-text">ConcurrentHashMap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashTable"><span class="toc-number">4.13.</span> <span class="toc-text">HashTable</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Properties"><span class="toc-number">4.14.</span> <span class="toc-text">Properties</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TreeMap"><span class="toc-number">4.15.</span> <span class="toc-text">TreeMap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LinkedHashMap"><span class="toc-number">4.16.</span> <span class="toc-text">LinkedHashMap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%86%B3%E5%AE%9A%E4%BD%BF%E7%94%A8-HashMap-%E8%BF%98%E6%98%AFTreeMap%EF%BC%9F"><span class="toc-number">4.17.</span> <span class="toc-text">如何决定使用 HashMap 还是TreeMap？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Array-%E5%92%8C-ArrayList-%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">4.18.</span> <span class="toc-text">Array 和 ArrayList 有何区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0-Array-%E5%92%8C-List-%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2%EF%BC%9F"><span class="toc-number">4.19.</span> <span class="toc-text">如何实现 Array 和 List 之间的转换？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#comparable-%E5%92%8C-comparator%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">4.20.</span> <span class="toc-text">comparable 和 comparator的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Collection-%E5%92%8C-Collections-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">4.21.</span> <span class="toc-text">Collection 和 Collections 有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TreeMap-%E5%92%8C-TreeSet-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%97%B6%E5%A6%82%E4%BD%95%E6%AF%94%E8%BE%83%E5%85%83%E7%B4%A0%EF%BC%9F-Collections-%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%B8%AD%E7%9A%84-sort-%E6%96%B9%E6%B3%95%E5%A6%82%E4%BD%95%E6%AF%94%E8%BE%83%E5%85%83%E7%B4%A0%EF%BC%9F"><span class="toc-number">4.22.</span> <span class="toc-text">TreeMap 和 TreeSet 在排序时如何比较元素？ Collections 工具类中的 sort()方法如何比较元素？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86"><span class="toc-number">5.</span> <span class="toc-text">计算机组成原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#DCL-double-checked-locking-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E9%9C%80%E8%A6%81%E5%8A%A0volatile%E5%90%97"><span class="toc-number">5.1.</span> <span class="toc-text">DCL (double-checked locking)单例模式需要加volatile吗</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cpu%E5%B1%82%E9%9D%A2%E5%A6%82%E4%BD%95%E7%A6%81%E6%AD%A2%E9%87%8D%E6%8E%92%E5%BA%8F"><span class="toc-number">5.2.</span> <span class="toc-text">cpu层面如何禁止重排序?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A6%81%E6%AD%A2%E4%B9%B1%E5%BA%8F"><span class="toc-number">5.3.</span> <span class="toc-text">禁止乱序</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/03/17/base/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="计算机网络"><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272046990.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机网络"/></a><div class="content"><a class="title" href="/2022/03/17/base/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="计算机网络">计算机网络</a><time datetime="2022-03-17T12:46:58.000Z" title="发表于 2022-03-17 20:46:58">2022-03-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/17/base/JVM/" title="JVM"><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272046012.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JVM"/></a><div class="content"><a class="title" href="/2022/03/17/base/JVM/" title="JVM">JVM</a><time datetime="2022-03-17T10:46:58.000Z" title="发表于 2022-03-17 18:46:58">2022-03-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/12/%E6%9C%AA%E5%91%BD%E5%90%8D/" title="无题"><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272047300.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2022/03/12/%E6%9C%AA%E5%91%BD%E5%90%8D/" title="无题">无题</a><time datetime="2022-03-12T08:47:16.570Z" title="发表于 2022-03-12 16:47:16">2022-03-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/02/base/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" title="操作系统"><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272047300.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="操作系统"/></a><div class="content"><a class="title" href="/2022/03/02/base/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" title="操作系统">操作系统</a><time datetime="2022-03-02T02:54:05.000Z" title="发表于 2022-03-02 10:54:05">2022-03-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/01/base/Linux/" title="Linux"><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272046012.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux"/></a><div class="content"><a class="title" href="/2022/03/01/base/Linux/" title="Linux">Linux</a><time datetime="2022-03-01T15:08:28.000Z" title="发表于 2022-03-01 23:08:28">2022-03-01</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By MingwHuang</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a><span class="footer-separator">|</span><a href="https://beian.miit.gov.cn/" target="_blank">赣ICP备2022001353号-1</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>