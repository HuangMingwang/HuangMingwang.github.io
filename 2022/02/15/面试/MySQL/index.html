<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>MySQL | MingwHuang's Blog</title><meta name="keywords" content="MySQL"><meta name="author" content="MingwHuang"><meta name="copyright" content="MingwHuang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="MySQL DML、DDL、DCL区别以及定义结构化查询语言（Structured Query Language，SQL）是用于管理关系数据库管理系统（RDBMS）。 SQL 的范围包括数据插入、查询、更新和删除，数据库模式创建和修改，以及数据访问控制。 数据操作语言（Data Manipulation Language，DML）用于检索或者修改数据。DML包括：SELECT、DELETE、 UP">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL">
<meta property="og:url" content="http://mingwzi.cn/2022/02/15/%E9%9D%A2%E8%AF%95/MySQL/index.html">
<meta property="og:site_name" content="MingwHuang&#39;s Blog">
<meta property="og:description" content="MySQL DML、DDL、DCL区别以及定义结构化查询语言（Structured Query Language，SQL）是用于管理关系数据库管理系统（RDBMS）。 SQL 的范围包括数据插入、查询、更新和删除，数据库模式创建和修改，以及数据访问控制。 数据操作语言（Data Manipulation Language，DML）用于检索或者修改数据。DML包括：SELECT、DELETE、 UP">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272046990.jpg">
<meta property="article:published_time" content="2022-02-15T10:46:58.000Z">
<meta property="article:modified_time" content="2022-02-28T04:21:50.000Z">
<meta property="article:author" content="MingwHuang">
<meta property="article:tag" content="MySQL">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272046990.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://mingwzi.cn/2022/02/15/%E9%9D%A2%E8%AF%95/MySQL/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":500},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'MySQL',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-02-28 12:21:50'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272113875.JPG" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">41</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">40</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">16</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272046990.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">MingwHuang's Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">MySQL</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-02-15T10:46:58.000Z" title="发表于 2022-02-15 18:46:58">2022-02-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-02-28T04:21:50.000Z" title="更新于 2022-02-28 12:21:50">2022-02-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="MySQL"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202151504917.png" alt="image-20210423222127334"></p>
<h2 id="DML、DDL、DCL区别以及定义"><a href="#DML、DDL、DCL区别以及定义" class="headerlink" title="DML、DDL、DCL区别以及定义"></a>DML、DDL、DCL区别以及定义</h2><p>结构化查询语言（Structured Query Language，SQL）是用于管理关系数据库管理系统（RDBMS）。 SQL 的范围包括数据插入、查询、更新和删除，数据库模式创建和修改，以及数据访问控制。</p>
<p>数据操作语言（Data Manipulation Language，DML）用于检索或者修改数据。DML包括：SELECT、DELETE、 UPDATE和INSERT。</p>
<p>数据定义语言（Data Definition Language，DDL）用于定义数据的结构，比如创建、修改或者删除数据库对象DDL包括：CREATE TABLE、ALTER TABLE、DROP TABLE、CREATE INDEX、DROP INDEX和TRUNCATE TABLE。</p>
<p>数据控制语言（Data Control Language，DCL）用于定于数据库用户的权限。DCL包括：ALTER PASSWORD、GRANT、REVOKE 和CREATE SYNONYM。</p>
<h2 id="TRUNCATE、DELETE和DROP的区别"><a href="#TRUNCATE、DELETE和DROP的区别" class="headerlink" title="TRUNCATE、DELETE和DROP的区别"></a>TRUNCATE、DELETE和DROP的区别</h2><ul>
<li>truncate table类似于delete删除所有行的语句或drop table然后再create table语句的组合。</li>
<li>truncate为了实现高性能，它绕过了删除数据的DML方法，因此，它不能回滚。</li>
<li>truncate会清空所有数据且执行速度很快。</li>
<li>truncate不能对有外键约束引用的表使用。</li>
<li>执行truncate需要drop权限，不建议给账号drop权限。</li>
<li>执行truncate前一定要再三检查确认，最好提前备份下表数据。</li>
<li>truncate与drop是DDL语句，执行后无法通过binlog回滚；delete是DML语句，可回滚。</li>
<li>truncate只能作用于表；delete，drop可作用于表、视图等。</li>
<li>truncate删除没有返回值；delete删除有返回值。</li>
<li>truncate删除后插入从0开始；delete从删除时的下一个位置开始；</li>
<li>truncate会清空表中的所有行，但表结构及其约束、索引等保持不变；drop会删除表的结构及其所依赖的约束、索引等。</li>
<li>truncate不会激活与表有关的删除触发器；delete可以。</li>
<li>truncate后会使表和索引所占用的空间会恢复到初始大小；delete操作不会减少表或索引所占用的空间；drop语句将表所占用的空间全释放掉。</li>
<li>在InnoDB中，delete操作并不会真的删除数据，mysql实际上只是给要删除的数据打了标记，标记为删除。磁盘所占空间不会变小，即表空间并没有真正被释放。</li>
</ul>
<h2 id="交叉连接、内连接、外连接、联合连接和自然连接"><a href="#交叉连接、内连接、外连接、联合连接和自然连接" class="headerlink" title="交叉连接、内连接、外连接、联合连接和自然连接"></a>交叉连接、内连接、外连接、联合连接和自然连接</h2><h3 id="交叉连接（CROSS-JOIN）"><a href="#交叉连接（CROSS-JOIN）" class="headerlink" title="交叉连接（CROSS JOIN）"></a>交叉连接（CROSS JOIN）</h3><p> 交叉连接（CROSS JOIN）：有两种，显式的和隐式的，不带ON子句（在MySQL支持ON，和INNER JOIN等价），返回的是两表的乘积，也叫笛卡尔积。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 隐式的交叉连接</span><br><span class="line"><span class="keyword">select</span> a.qq, b.name <span class="keyword">from</span> `test_table` <span class="keyword">as</span> a, `<span class="keyword">user</span>` <span class="keyword">as</span> b <span class="keyword">where</span> a.id <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"># 显式的交叉连接</span><br><span class="line"><span class="keyword">select</span> a.qq, b.name <span class="keyword">from</span> `test_table` <span class="keyword">as</span> a <span class="keyword">cross</span> <span class="keyword">join</span> `<span class="keyword">user</span>` b <span class="keyword">where</span> a.id <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="内连接（INNER-JOIN）"><a href="#内连接（INNER-JOIN）" class="headerlink" title="内连接（INNER JOIN）"></a>内连接（INNER JOIN）</h3><p>内连接（INNER JOIN）：有两种，显式的和隐式的，返回连接表中符合连接条件和查询条件的数据行。（所谓的链接表就是数据库在做查询形成的中间表）。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 隐式的内连接，没有<span class="keyword">INNER</span> <span class="keyword">JOIN</span>，形成的中间表为两个表的笛卡尔积。</span><br><span class="line"><span class="keyword">select</span> a.qq, b.name <span class="keyword">from</span> `test_table` <span class="keyword">as</span> a, `<span class="keyword">user</span>` <span class="keyword">as</span> b <span class="keyword">where</span> a.id <span class="operator">=</span> b.id</span><br><span class="line"></span><br><span class="line"># 显示的内连接，一般称为内连接，有<span class="keyword">INNER</span> <span class="keyword">JOIN</span>，形成的中间表为两个表经过<span class="keyword">ON</span>条件过滤后的笛卡尔积。</span><br><span class="line"><span class="keyword">select</span> a.qq, b.name <span class="keyword">from</span> `test_table` <span class="keyword">as</span> a <span class="keyword">inner</span> <span class="keyword">join</span> `<span class="keyword">user</span>` b <span class="keyword">on</span> a.id <span class="operator">=</span> b.id</span><br></pre></td></tr></table></figure>

<h3 id="外连接（OUTER-JOIN）"><a href="#外连接（OUTER-JOIN）" class="headerlink" title="外连接（OUTER JOIN）"></a>外连接（OUTER JOIN）</h3><p>外连接（OUTER JOIN）不但返回符合连接和查询条件的数据行，还返回不符合条件的一些行。外连接分三类：左外连接（LEFT OUTER JOIN）、右外连接（RIGHT OUTER JOIN）和全外连接（FULL OUTER JOIN）。在三种类型的外连接中，OUTER 关键字是可省略的。 </p>
<p>三者的共同点是都返回符合连接条件和查询条件（即：内连接）的数据行。</p>
<p>不同点如下： </p>
<ul>
<li>左外连接还返回左表中不符合连接条件单符合查询条件的数据行。</li>
<li>右外连接还返回右表中不符合连接条件单符合查询条件的数据行。</li>
<li>全外连接还返回左表中不符合连接条件单符合查询条件的数据行，并且还返回右表中不符合连接条件单符合查询条件的数据行。全外连接实际是上左外连接和右外连接的数学合集（去掉重复），即“全外&#x3D;左外 UNION 右外”。在MySQL中不支持全外连接，可以用“左外 UNION 右外”实现全外连接。</li>
</ul>
<h3 id="联合连接（UNION-JOIN）"><a href="#联合连接（UNION-JOIN）" class="headerlink" title="联合连接（UNION JOIN）"></a>联合连接（UNION JOIN）</h3><p>这是一种很少见的连接方式。Oracle、MySQL均不支持，其作用是：找出全外连接和内连接之间差异的所有行。这在数据分析中排错中比较常用。也可以利用数据库的集合操作来实现此功能。</p>
<h3 id="自然连接（NATURAL-INNER-JOIN）"><a href="#自然连接（NATURAL-INNER-JOIN）" class="headerlink" title="自然连接（NATURAL INNER JOIN）"></a>自然连接（NATURAL INNER JOIN）</h3><p>自然连接无需指定连接列，SQL会检查两个表中是否相同名称的列，且假设他们在连接条件中使用，并且在连接条件中仅包含一个连接列。</p>
<p>MySQL环境下：不允许使用ON语句，允许指定显式列。自然连接分为内外之分。内：NATURAL JOIN（不能加INNER）。外：NATURAL LEFT JOIN和NATURAL RIGHT JOIN。</p>
<p>ORACLE环境下：不允许使用ON语句，不允许指定显式列，显式列只能用*表示。对于每种连接类型（除了交叉连接外），均可指定NATURAL。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name,age <span class="keyword">from</span> `test_table` <span class="keyword">as</span> a <span class="keyword">natural</span> <span class="keyword">join</span> `<span class="keyword">user</span>` <span class="keyword">as</span> b</span><br><span class="line"># 如果两张表都有name，age字段，相当于如下语句，但是必须写a.name,a.age</span><br><span class="line"><span class="keyword">select</span> a.name,a.age <span class="keyword">from</span> `test_table` <span class="keyword">as</span> a <span class="keyword">join</span> `<span class="keyword">user</span>` <span class="keyword">as</span> b <span class="keyword">on</span> a.name <span class="operator">=</span> b.name <span class="keyword">and</span> a.age <span class="operator">=</span> b.age</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> name,age <span class="keyword">from</span> `test_table` <span class="keyword">as</span> a <span class="keyword">natural</span> <span class="keyword">left</span> <span class="keyword">join</span> `<span class="keyword">user</span>` <span class="keyword">as</span> b</span><br><span class="line"># 如果两张表都有name，age字段，相当于如下语句，但是必须写a.name,a.age</span><br><span class="line"><span class="keyword">select</span> a.name,a.age <span class="keyword">from</span> `test_table` <span class="keyword">as</span> a <span class="keyword">left</span> <span class="keyword">join</span> `<span class="keyword">user</span>` <span class="keyword">as</span> b <span class="keyword">on</span> a.name <span class="operator">=</span> b.name <span class="keyword">and</span> a.age <span class="operator">=</span> b.age</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> name,age <span class="keyword">from</span> `test_table` <span class="keyword">as</span> a <span class="keyword">natural</span> <span class="keyword">right</span> <span class="keyword">join</span> `<span class="keyword">user</span>` <span class="keyword">as</span> b</span><br><span class="line"># 如果两张表都有name，age字段，相当于如下语句，但是必须写b.name,b.age</span><br><span class="line"><span class="keyword">select</span> b.name,b.age <span class="keyword">from</span> `test_table` <span class="keyword">as</span> a  <span class="keyword">right</span> <span class="keyword">join</span> `<span class="keyword">user</span>` <span class="keyword">as</span> b <span class="keyword">on</span> a.name <span class="operator">=</span> b.name <span class="keyword">and</span> a.age <span class="operator">=</span> b.age</span><br></pre></td></tr></table></figure>

<h2 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h2><p>主表中没有的数据值，在副表中是不可以使用的。主表中的记录被副表引用，是不可以被删除的</p>
<h2 id="三大范式"><a href="#三大范式" class="headerlink" title="三大范式"></a>三大范式</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/20028672">https://zhuanlan.zhihu.com/p/20028672</a> </p>
<h3 id="第一范式（列不可分）"><a href="#第一范式（列不可分）" class="headerlink" title="第一范式（列不可分）"></a>第一范式（列不可分）</h3><p>定义：数据库表的每一列都是不可分割的原子数据项，而不能是集合，数组，记录等非原子数据项。如果实体中的某个属性有多个值时，必须拆分为不同的属性。</p>
<p><strong>1NF是所有关系型数据库的最基本要求</strong>，你在关系型数据库管理系统（RDBMS），例如SQL Server，Oracle，MySQL中创建数据表的时候，如果数据表的设计不符合这个最基本的要求，那么操作一定是不能成功的。</p>
<p>例如：</p>
<p>不满足第一范式</p>
<table>
<thead>
<tr>
<th>学号</th>
<th>姓名</th>
<th>班级</th>
</tr>
</thead>
<tbody><tr>
<td>0001</td>
<td>小红</td>
<td>高三1班</td>
</tr>
</tbody></table>
<p>改成</p>
<table>
<thead>
<tr>
<th>学号</th>
<th>姓名</th>
<th>年级</th>
<th>班级</th>
</tr>
</thead>
<tbody><tr>
<td>0001</td>
<td>小红</td>
<td>高三</td>
<td>1班</td>
</tr>
</tbody></table>
<h3 id="第二范式（属性完全依赖于主键）"><a href="#第二范式（属性完全依赖于主键）" class="headerlink" title="第二范式（属性完全依赖于主键）"></a>第二范式（属性完全依赖于主键）</h3><p>定义：满足第一范式前提， 当存在联合主键的时候，才会发生不符合第二范式的情况。比如有两个属性的联合主键，如果存在这样的属性，它只依赖于联合主键中的一个属性而不依赖另一个，这就是不符合第二范式的。</p>
<p>仅仅符合1NF的设计，仍然会存在数据冗余过大，插入异常，删除异常，修改异常的问题，例如：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202151849658.jpg" alt="img"></p>
<p>注１：根据三种关系完整性约束中实体完整性的要求，关系中的码（注２）所包含的任意一个属性都不能为空，所有属性的组合也不能重复。为了满足此要求，图中的表，只能将学号与课名的组合作为码，否则就无法唯一地区分每一条记录。</p>
<p>注２：码：关系中的某个属性或者某几个属性的组合，用于区分每个元组（可以把“元组”理解为一张表中的每条记录，也就是每一行）。</p>
<ol>
<li>每一名学生的学号、姓名、系名、系主任这些数据重复多次。每个系与对应的系主任的数据也重复多次。——<strong>数据冗余过大</strong>。</li>
<li>假如学校新建了一个系，但是暂时还没有招收任何学生（比如3月份就新建了，但要等到8月份才招生），那么是无法将系名与系主任的数据单独地添加到数据表中去的 （注１）。——<strong>插入异常</strong>。</li>
<li>假如将某个系中所有学生相关的记录都删除，那么所有系与系主任的数据也就随之消失了（一个系所有学生都没有了，并不表示这个系就没有了）。——<strong>删除异常</strong>。</li>
<li>假如李勇转系到法律系，那么为了保证数据库中数据的一致性，需要修改三条记录中系与系主任的数据。——<strong>修改异常</strong>。</li>
</ol>
<p>修改后：</p>
<p>选课表</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202151854983.jpg" alt="img"></p>
<p>学生表</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202151854314.jpg" alt="img"></p>
<p>对于修改后的表：</p>
<ol>
<li>李小明转系到法律系<br>只需要修改一次李小明对应的系的值即可。——有改进</li>
<li>数据冗余是否减少了？<br>学生的姓名、系名与系主任，不再像之前一样重复那么多次了。——有改进</li>
<li>删除某个系中所有的学生记录<br>该系的信息仍然全部丢失。——无改进</li>
<li>插入一个尚无学生的新系的信息。<br>因为学生表的码是学号，不能为空，所以此操作不被允许。——无改进</li>
</ol>
<p>所以说，仅仅符合2NF的要求，很多情况下还是不够的，而出现问题的原因，在于仍然存在非主属性<strong>系主任</strong>对于码<strong>学号</strong>的传递函数依赖。为了能进一步解决这些问题，还需要将符合2NF要求的数据表改进为符合3NF的要求。</p>
<h3 id="第三范式（属性不能传递依赖于主键）"><a href="#第三范式（属性不能传递依赖于主键）" class="headerlink" title="第三范式（属性不能传递依赖于主键）"></a>第三范式（属性不能传递依赖于主键）</h3><p>定义：满足第二范式前提， 如果某一属性依赖于其他非主键属性，而其他非主键属性又依赖于主键，那么这个属性就是间接依赖于主键，这被称作传递依赖于主属性。</p>
<p>例如：</p>
<p>选课表</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202151901434.jpg" alt="img"></p>
<p>学生表</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202151901270.jpg" alt="img"></p>
<p>系表</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202151901808.jpg" alt="img"></p>
<p>修改后：</p>
<ol>
<li>删除某个系中所有的学生记录<br>该系的信息不会丢失。——有改进</li>
<li>插入一个尚无学生的新系的信息。<br>因为系表与学生表目前是独立的两张表，所以不影响。——有改进</li>
<li>数据冗余更加少了。——有改进</li>
</ol>
<h3 id="BCNF范式"><a href="#BCNF范式" class="headerlink" title="BCNF范式"></a>BCNF范式</h3><p>要了解 BCNF 范式，那么先看这样一个问题：<br>若：</p>
<ol>
<li>某公司有若干个仓库；</li>
<li>每个仓库只能有一名管理员，一名管理员只能在一个仓库中工作；</li>
<li>一个仓库中可以存放多种物品，一种物品也可以存放在不同的仓库中。每种物品在每个仓库中都有对应的数量。</li>
</ol>
<p>那么关系模式仓库（仓库名，管理员，物品名，数量） 属于哪一级范式？</p>
<p>答：已知函数依赖集：仓库名 → 管理员，管理员 → 仓库名，（仓库名，物品名）→ 数量<br>码：（管理员，物品名），（仓库名，物品名）<br>主属性：仓库名、管理员、物品名<br>非主属性：数量<br>∵ 不存在非主属性对码的部分函数依赖和传递函数依赖。∴ 此关系模式属于3NF。</p>
<p>基于此关系模式的关系（具体的数据）可能如图所示：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202151906491.jpg" alt="img"></p>
<p>好，既然此关系模式已经属于了 3NF，那么这个关系模式是否存在问题呢？我们来看以下几种操作：</p>
<ol>
<li>先新增加一个仓库，但尚未存放任何物品，是否可以为该仓库指派管理员？——不可以，因为物品名也是主属性，根据实体完整性的要求，主属性不能为空。</li>
<li>某仓库被清空后，需要删除所有与这个仓库相关的物品存放记录，会带来什么问题？——仓库本身与管理员的信息也被随之删除了。</li>
<li>如果某仓库更换了管理员，会带来什么问题？——这个仓库有几条物品存放记录，就要修改多少次管理员信息。</li>
</ol>
<p>从这里我们可以得出结论，在某些特殊情况下，即使关系模式符合 3NF 的要求，仍然存在着插入异常，修改异常与删除异常的问题，仍然不是 ”好“ 的设计。</p>
<p>造成此问题的原因：存在着<strong>主属性</strong>对于码的部分函数依赖与传递函数依赖。（在此例中就是存在主属性【仓库名】对于码【（管理员，物品名）】的部分函数依赖。</p>
<p>解决办法就是要在 3NF 的基础上消除<strong>主属性</strong>对于码的部分与传递函数依赖。</p>
<p>仓库（仓库名，管理员）<br>库存（仓库名，物品名，数量）</p>
<p>这样，之前的插入异常，修改异常与删除异常的问题就被解决了。</p>
<h2 id="事务四大特性（ACID）"><a href="#事务四大特性（ACID）" class="headerlink" title="事务四大特性（ACID）"></a>事务四大特性（ACID）</h2><h3 id="事务的理解"><a href="#事务的理解" class="headerlink" title="事务的理解"></a>事务的理解</h3><p>事务的产生，是为了当应用程序访问数据库的时候，事务能够简化我们的编程模型，不需要我们去考虑各种各样的潜在错误和并发问题。当我们使用事务时，要么提交，要么回滚，不用考虑网络异常，服务器宕机了，同时更改一个数据这些情况。<strong>因此事务本质上是为了应用层服务的</strong>，而不是伴随着数据库系统天生就有的。</p>
<h4 id="数据库为什么要有事务？"><a href="#数据库为什么要有事务？" class="headerlink" title="数据库为什么要有事务？"></a>数据库为什么要有事务？</h4><p>为了保证数据的最终一致性。</p>
<h3 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h3><ul>
<li>原子性（Automicity）：满足原子操作单元，对数据的操作，要么全部执行，要么全部失败（通过undo log来保证）。</li>
<li>一致性（Consistency）： 应用系统从一个正确的状态到另一个正确的状态。而ACID就是说事务能够通过AID来保证这个C的过程。C是目的，AID都是手段。</li>
<li>隔离性（Isolation）： 事务之间时相互独立的，中间状态对外不可见。 隔离状态执行事务，使它们好像是系统在给定时间内执行的唯一操作。如果有两个事务，运行在相同的时间内，执行相同的功能，事务的隔离性将确保每一事务在系统中认为只有该事务在使用系统。这种属性有时称为串行化，为了防止事务操作间的混淆，必须串行化或序列化请求，使得在同一时间仅有一个请求用于同一数据。</li>
<li>持久性（Durability）： 数据的修改是永久的，即使数据库发生故障。</li>
</ul>
<h4 id="一致性的理解"><a href="#一致性的理解" class="headerlink" title="一致性的理解"></a>一致性的理解</h4><p>ACID里的AID都是数据库的特征，依赖数据库的具体实现。而这个C，它依赖于应用层，也就是依赖于开发者。这里的一致性是指系统从一个正确的状态，迁移到另一个正确的状态（当前的状态满足预定的约束）。事务具备ACID里C的特性是说通过事务的AID来保证一致性。</p>
<p>例如：</p>
<blockquote>
<p>我们提到保镖会说强壮、好功夫和踏实。这里强壮、好功夫和踏实都是保镖自己的特征，而安全是属于你的，而你通过保镖的特征来保护你的安全。</p>
</blockquote>
<p>我们能够通过AID保证我们的一致性，但事务本身没办法确保。用上面保镖的例子来说，你正常被保护一定是安全的，但是你故意骗保镖离开你身边，然后你自己溜出去玩就不安全了。同样，如果你在事务里故意写出违反约束的代码，比如在银行系统里定时每天给自己的账户打入100w，这个事务是没办法的。</p>
<p>例如：</p>
<blockquote>
<p>A要向B支付100元，而A的账户中只有90元，并且给定账户余额这一列的约束是不能小于0。那么这条事务执行会失败，因为90-100&#x3D;-10，小于给定的约束。</p>
</blockquote>
<p>这个例子里，支付之前数据库里的数据都是符合约束的，但是如果事务执行成功了，数据库的数据就破坏约束了，因此事务不能成功，事务提供了一致性的保证。</p>
<p>例如：</p>
<blockquote>
<p>A要向B支付100元，而A的账户中只有90元，账户余额列没有任何约束。但是业务上不允许账户余额小于0。因此支付完成后业务上会检查A的账户余额，发现余额小于0了，于是业务上进行了事务的回滚。</p>
</blockquote>
<p>这个例子里，如果事务执行成功，虽然没有破坏数据库的约束，但是破坏了应用层的约束。而事务的回滚保证了数据库的约束，因此也可以说事务提供了一致性保证（ps：事实上，是应用层利用事务回滚保证了约束不被破坏）。</p>
<p>例如：</p>
<blockquote>
<p>A要向B支付100元，而A的账户中只有90元，账户余额列没有任何约束。然后支付成功了。</p>
</blockquote>
<p>这个例子里，直观上账户余额为什么能为负呢？但这里事务执行前和执行后，系统没有任何的约束被破坏。一直都是保持正确的状态。</p>
<p>综上，可以理解一致性就是：应用系统从一个正确的状态到另一个正确的状态。而ACID就是说事务能够通过AID来保证这个C的过程。C是目的，AID都是手段。</p>
<h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><h3 id="并发出现的问题"><a href="#并发出现的问题" class="headerlink" title="并发出现的问题"></a>并发出现的问题</h3><ul>
<li>脏读（dirty read）： A事务还没提交，B事务就读到了A事务的结果。（破坏了隔离性）</li>
<li>丢失修改（Lost to modify）：事务1读取某表中的数据 A &#x3D; 20，事务2也读取 A &#x3D; 20，事务1修改A &#x3D; A - 1，事务2也修改 A &#x3D; A - 1，最终结果A&#x3D;19，事务1的修改丢失了。</li>
<li>不可重复读（Unrepeatableread）： 针对其提交前后，读取数据本身的对比。A事务在本次事物中，对自己未操作过的数据，进行了多次读取，结果出现了不一致情况。(破坏了一致性，update)</li>
<li>幻读（Phantom read）：针对其提交前后，读取数据条数的对比。同样一笔查询在整个事务过程中多次执行后，数据总量不一致。 A事务在本次事务中，对自己未操作过的数据，进行了多次读取，第一次读取时，数据总量100条，第二次读取时，数据总量200条。(破坏了一致性，delete)</li>
</ul>
<h3 id="解决方案-制定标准"><a href="#解决方案-制定标准" class="headerlink" title="解决方案(制定标准)"></a>解决方案(制定标准)</h3><p>读取未提交（READ-UNCOMMITTED）：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</p>
<p>读取已提交（READ-COMMITTED）：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。事务1在事务2提交前读取 A &#x3D; 20，在事务2提交后读取 A &#x3D; 19，不可重复读。 假设A刚开始不存在，事务1读取记录不存在，事务2提交后，事务1又读取到了A，幻读。</p>
<p>可重复读（REPEATABLE-READ）：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。假设 A 刚开始不存在，事务1读取记录不存在，事务2将A插入然后提交，事务1又读取到A，幻读。</p>
<p>可串行化（SERIALIZABLE）：最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>READ-UNCOMMITTED</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>READ-COMMITTED</td>
<td>×</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>REPEATABLE-READ</td>
<td>×</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>SERIALIZABLE</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody></table>
<h3 id="实现-Innodb"><a href="#实现-Innodb" class="headerlink" title="实现(Innodb)"></a>实现(Innodb)</h3><ul>
<li><p>锁机制：阻止其他事务对数据进行操作，各个隔离级别主要体现在读取数据时加的锁和释放时机。</p>
<ul>
<li>RU：事务读取的时候，不加锁。</li>
<li>RC：事务读取的时候加行级共享锁（读到才加锁，加锁后必须等其他事务提交后才会执行）， 一旦读完，立刻释放（并不是事务结束）。</li>
<li>RR：事务读取时加行级共享锁，直到事务结束才释放。</li>
<li>SE：事务读取时加表级共享锁，直到事务结束时才会释放。</li>
</ul>
</li>
<li><p>多版本并发控制（Multiversion Concurrency Control，MVCC）机制（Innodb默认开启）：生成一个数据快照，并用这个快照来提供一定级别的一致性的读取，也称为多版本数据控制。</p>
<ul>
<li>实际上就是CAS版本控制和读写分离的思想</li>
<li>主要作用于RC和RR级别</li>
</ul>
</li>
</ul>
<h2 id="MyISAM和InnoDB"><a href="#MyISAM和InnoDB" class="headerlink" title="MyISAM和InnoDB"></a>MyISAM和InnoDB</h2><p>如果某个进程想要获取读锁，同时另外一个进程想要获取写锁。在MySQL中，写锁是优先于读锁的。写锁和读锁优先级的问题是可以通过参数调节的：max_write_lock_count和low-priority-updates。</p>
<h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><ul>
<li>MYISAM表级锁</li>
<li>不支持事务</li>
<li>不支持外键</li>
<li>不支持数据库异常崩溃后的安全恢复</li>
<li>不支持MVCC</li>
</ul>
<h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><ul>
<li><p>InnoDB只有通过索引条件检索数据才使用行级锁，否则，InnoDB使用表锁。也就是说，InnoDB的行锁是基于索引的。</p>
</li>
<li><p>Innodb支持行锁和表锁，默认为行级锁。 </p>
</li>
<li><p>支持事务，并且具有提交（commit）和回滚（rollback）事务的能力。</p>
</li>
<li><p>支持外键（不建议使用）。</p>
</li>
<li><p>支持数据库异常崩溃后的安全恢复，发生异常崩溃后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态，这个恢复依赖于redo log。</p>
</li>
<li><p>支持MVCC，MVCC可以看作是行级锁的一个升级，可以有效减少加锁操作，提升性能。</p>
</li>
<li><p>在分布式事务的情况下一般会用到SERIALIZABLE（可串性化）隔离级别。</p>
</li>
<li><p>MySQL InnoDB引擎使用redo log保证事务的持久性，使用undo log来保证事务的原子性。</p>
</li>
<li><p>MySQL InnoDB引擎通过锁机制、MVCC等手段来保证事务的隔离性（默认的隔离级别是REPEARTABLE-READ）。</p>
</li>
</ul>
<h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/whoamiyang/article/details/51901888?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-2.control&dist_request_id=1331645.10885.16183849906828127&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-2.control">MVCC</a></h3><p>读不加锁，读写不冲突。大多数情况下可以代替行级锁。</p>
<p>MVCC是通过在每行记录后面保存两个隐藏的列来实现。这两个列，一个保存了行的创建时间，一个保存行的过期时间（或删除时间）。 当然存储的并不是实际的时间值，而是系统版本号。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。</p>
<p>在REPEATABLE READ隔离级别下，MVCC具体操作如下：</p>
<ol>
<li>SELECT</li>
</ol>
<p>InnoDB会根据以下两个条件检查每行记录：</p>
<ul>
<li><p>InnoDB只会查找版本早于当前事务版本的数据行（也就是，行的系统版本号小于或等于事务的系统版本号），这样可以确保事务读取的行要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的。</p>
</li>
<li><p>行的删除版本号要么未定义，要么大于当前事务版本号，这可以确保事务读取到的行，在事务开始之前未被删除。</p>
</li>
</ul>
<p>只有同时满足的记录，才能返回作为查询结果。</p>
<p>MVCC可以解决这种场景的幻读问题，例如事务1的事务版本号ñ为1， 事务2的事务版本号为2。事务2第一次查询是有100条记录， 然后事务1添加了100条数据，这些数据的版本号是当前系统版本号（假设为3），此时事务2再去查询的话也只能查询出100条数据，因为当前系统版本号（3）大于事务2的事务版本号（2）。</p>
<ol start="2">
<li>INSERT</li>
</ol>
<p>InnoDB为新插入的每一行保存当前系统版本号（注意不是事务版本号）作为版本号。</p>
<ol start="3">
<li>DELETE</li>
</ol>
<p>InnoDB会为删除的每一行保存当前系统的版本号（注意不是事务版本号）作为删除标识.</p>
<ol start="4">
<li>UPDATE</li>
</ol>
<p>InnoDB执行UPDATE，实际上是新插入了一行记录，并保存其创建时间为当前系统版本号（注意不是事务版本号），同时保存当前系统版本号到要UPDATE的行的删除时间。</p>
<h3 id="InnoDB-存储引擎中行锁的三种算法"><a href="#InnoDB-存储引擎中行锁的三种算法" class="headerlink" title="InnoDB 存储引擎中行锁的三种算法"></a>InnoDB 存储引擎中行锁的三种算法</h3><h4 id="记录锁（Record-lock）"><a href="#记录锁（Record-lock）" class="headerlink" title="记录锁（Record lock）"></a>记录锁（Record lock）</h4><p>记录锁就是为某行记录加锁，基于唯一索引，事实上，它封锁的是该行的索引记录。如果表在建立的时候没有设置任何一个索引，那么 InnoDB 存储引擎会使用 “隐式的主键” 来进行锁定。</p>
<p>隐式的主键就是指：如果在建表的时候没有指定主键，InnoDB 存储引擎会将第一列非空的列作为主键；如果没有的话会自动生成一列为 6 字节的主键。</p>
<p>如果我们的 SQL 语句中的条件导致索引失效（比如使用 or） 或者说条件根本就不涉及索引或者主键，行级锁就将退化为表锁。</p>
<h5 id="两条不同记录拥有相同的索引，会发生锁冲突吗？"><a href="#两条不同记录拥有相同的索引，会发生锁冲突吗？" class="headerlink" title="两条不同记录拥有相同的索引，会发生锁冲突吗？"></a>两条不同记录拥有相同的索引，会发生锁冲突吗？</h5><p>行锁锁住的是索引，而不是一条记录（只不过我们平常这么说锁住了哪条记录，比较好理解罢了）。所以如果两个事务分别操作的两条不同记录拥有相同的索引，某个事务会因为行锁被另一个事务占用而发生等待。例如两条记录里年龄字段都为20，年龄字段有索引。</p>
<h4 id="间隙锁（Gap-Lock）"><a href="#间隙锁（Gap-Lock）" class="headerlink" title="间隙锁（Gap Lock）"></a>间隙锁（Gap Lock）</h4><p>基于非唯一索引，锁定一个范围，不包括记录本身。 在可重复读提交下为了解决幻读问题时引入的锁机制。 </p>
<p>Gap Lock 和 Next-Key Lock 锁定的都是一段范围内的索引记录：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">where</span> id <span class="keyword">between</span> <span class="number">1</span> <span class="keyword">and</span> <span class="number">10</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>

<p>对于上述 SQL 语句，所有在（1，10）区间内（左开右开）的记录行都会被 Gap Lock 锁住，所有 id 为 2、3、4、5、6、7、8、9 的数据行的插入会被阻塞，但是 1 和 10 两条被操作的索引记录并不会被锁住。</p>
<h4 id="临键锁（Next-key-lock）"><a href="#临键锁（Next-key-lock）" class="headerlink" title="临键锁（Next-key lock）"></a>临键锁（Next-key lock）</h4><p>基于非唯一索引，行锁和间隙锁的组合，锁定一个范围，包含记录本身。 对于行查询，都是采用该方法，主要目的是为了解决幻读问题。</p>
<p>例如一个索引有 10，11，13 和 20 这四个值，分别对这个 4 个索引进行加锁操作，那么这四个操作分别对应的 Next-Key Lock 锁住的区间是：</p>
<ul>
<li>(-∞, 10]</li>
<li>(10, 11]</li>
<li>(11, 13]</li>
<li>(13, 20]</li>
<li>(20, +∞]</li>
</ul>
<p>和 Gap Lock 的不同之处就在于，Next-Key Lock 锁定的区间是左开右闭的，也就是说它是包含当前被操作的索引记录的。</p>
<p>在 InnoDB 默认的隔离级别 REPEATABLE-READ 下，行锁默认使用的算法就是 Next-Key Lock。但是，如果操作的索引是唯一索引或主键，InnoDB 会对 Next-Key Lock 进行优化，将其降级为 Record Lock，即仅锁住索引本身，而不是范围。</p>
<p>由于主键也是一种唯一索引，所以我们可以这么说：Record Lock 是基于唯一索引的，而 Next-Key Lock 是基于非唯一索引的。</p>
<p>需要注意的，当操作的索引为非唯一索引时，InnoDB 会先用 Record Lock 锁住对应的唯一索引，再用 Next-Key Lock 和 Gap Lock 对这个非唯一索引进行处理，而不仅仅是锁住这个非唯一索引。</p>
<p>Next-Key Lock 降级为 Record Lock 仅存在于操作所有的唯一索引列的情况。若唯一索引由多个列组成，而操作的仅是多个唯一索引列中的其中一个，那么 InnoDB 存储引擎依然使用 Next-Key Lock 进行锁定。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> DATABASE IF <span class="keyword">EXISTS</span> `test`;</span><br><span class="line"><span class="keyword">CREATE</span> DATABASE `test`;</span><br><span class="line"></span><br><span class="line">USE `test`;</span><br><span class="line"><span class="keyword">SET</span> NAMES utf8mb4;</span><br><span class="line"><span class="keyword">SET</span> FOREIGN_KEY_CHECKS <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- Table structure for test</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `test`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `test` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `user_name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `class` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `index_class` (`class`) <span class="keyword">USING</span> BTREE COMMENT <span class="string">&#x27;非唯一索引&#x27;</span></span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- Records of test</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` (`id`, `user_name`, `class`) <span class="keyword">VALUES</span> (<span class="number">101</span>, <span class="string">&#x27;one&#x27;</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` (`id`, `user_name`, `class`) <span class="keyword">VALUES</span> (<span class="number">103</span>, <span class="string">&#x27;two&#x27;</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` (`id`, `user_name`, `class`) <span class="keyword">VALUES</span> (<span class="number">105</span>, <span class="string">&#x27;three&#x27;</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` (`id`, `user_name`, `class`) <span class="keyword">VALUES</span> (<span class="number">107</span>, <span class="string">&#x27;four&#x27;</span>, <span class="number">6</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` (`id`, `user_name`, `class`) <span class="keyword">VALUES</span> (<span class="number">110</span>, <span class="string">&#x27;five&#x27;</span>, <span class="number">8</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` (`id`, `user_name`, `class`) <span class="keyword">VALUES</span> (<span class="number">120</span>, <span class="string">&#x27;five&#x27;</span>, <span class="number">88</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` (`id`, `user_name`, `class`) <span class="keyword">VALUES</span> (<span class="number">150</span>, <span class="string">&#x27;150&#x27;</span>, <span class="number">100</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` (`id`, `user_name`, `class`) <span class="keyword">VALUES</span> (<span class="number">180</span>, <span class="string">&#x27;180&#x27;</span>, <span class="number">180</span>);</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> FOREIGN_KEY_CHECKS <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>



<h5 id="行锁示例"><a href="#行锁示例" class="headerlink" title="行锁示例"></a>行锁示例</h5><p>事务1不提交的话，事务2会因为获取不到锁而等待。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 事务<span class="number">1</span></span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">update</span> test <span class="keyword">set</span> user_name <span class="operator">=</span> <span class="string">&#x27;test1&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 事务<span class="number">2</span></span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">update</span> test <span class="keyword">set</span> user_name <span class="operator">=</span> <span class="string">&#x27;test2&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure>

<h5 id="行锁退化为表锁示例"><a href="#行锁退化为表锁示例" class="headerlink" title="行锁退化为表锁示例"></a>行锁退化为表锁示例</h5><p>事务1不提交的话就是锁住了整张表。此时执行事务 2 试图申请 id &#x3D; 5 的记录锁，事务 T2 会卡住，最后超时关闭事务。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 事务<span class="number">1</span></span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">where</span> user_name <span class="operator">=</span> <span class="string">&#x27;one&#x27;</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"></span><br><span class="line"># 事务<span class="number">2</span></span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">update</span> test <span class="keyword">set</span> user_name <span class="operator">=</span> <span class="string">&#x27;test&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure>

<h5 id="两条不同记录拥有相同的索引示例"><a href="#两条不同记录拥有相同的索引示例" class="headerlink" title="两条不同记录拥有相同的索引示例"></a>两条不同记录拥有相同的索引示例</h5><p>这两天记录拥有相同的索引，事务1不提交的话，此时执行事务 2 试图申请 class&#x3D;1 的记录锁，事务 T2 会卡住，最后超时关闭事务。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 事务<span class="number">1</span></span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">where</span> user_name <span class="operator">=</span> <span class="string">&#x27;one&#x27;</span> <span class="keyword">and</span> class <span class="operator">=</span> <span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"></span><br><span class="line"># 事务<span class="number">2</span></span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">update</span> test <span class="keyword">set</span> user_name <span class="operator">=</span> <span class="string">&#x27;test&#x27;</span> <span class="keyword">where</span> user_name <span class="operator">=</span> <span class="string">&#x27;two&#x27;</span> <span class="keyword">and</span> class <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure>

<h5 id="临键锁示例"><a href="#临键锁示例" class="headerlink" title="临键锁示例"></a>临键锁示例</h5><p>在事务1这种情况下，InnoDB 事实上会加上三种行锁（select * … from update 加的是行级写锁即 X 锁）：</p>
<ul>
<li><p>给主键索引 id &#x3D; 105 加上 Record Lock。</p>
</li>
<li><p>对于非唯一索引 class &#x3D; 3，其加上的是 Next-Key Lock，锁定的范围是 (1，3]。</p>
</li>
<li><p>另外，InnoDB 存储引擎还会对非唯一索引 class 的下一个键值加上 Gap Lock（表中 class &#x3D; 3 的下个键值是 6），所以还有一个 class 索引范围为 （3，6）的间隙锁。</p>
</li>
</ul>
<p>对于这条 SQL 语句，InnoDB 存储引擎锁定的 class 索引范围是 （1，6）。</p>
<p>实例1：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># 事务<span class="number">1</span></span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">where</span> class <span class="operator">=</span> <span class="number">3</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"></span><br><span class="line"># 事务<span class="number">2</span></span><br><span class="line"># 无法查询</span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">105</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"></span><br><span class="line"># 无法插入</span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test <span class="keyword">values</span>(<span class="number">104</span>, &quot;test&quot;, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"></span><br><span class="line"># 可以查询</span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">where</span> class<span class="operator">=</span><span class="number">6</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"></span><br><span class="line"># 可以查询</span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">where</span> class<span class="operator">=</span><span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"></span><br><span class="line"># 可以插入</span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test <span class="keyword">values</span>(<span class="number">104</span>, &quot;test&quot;, <span class="number">6</span>);</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure>

<p>实例2：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 事务<span class="number">1</span> 整个表都锁住了</span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">where</span> class <span class="keyword">between</span> <span class="number">6</span> <span class="keyword">and</span> <span class="number">88</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>



<h2 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h2><p>执行查询语句的时候，会先查询缓存。 在MySQL8.0版本后移出该功能，开启查询缓存后在同样的查询条件以及数据情况下，会直接在缓存中返回结果。 缓存虽然能够提升数据库的查询性能，但是缓存同时也带来了额外的开销，每次查询后都要做一次缓存操作，失效后还要销毁。对于写密集的应用最好不要开启。</p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>通过唯一性索引，可以保证数据库中每一行数据的唯一性。</p>
<p>索引可以大大加快数据的检索速度，帮助服务器避免排序和临时表。 将随机IO变为顺序IO。</p>
<h3 id="为什么不对表中的每一个列创建一个索引"><a href="#为什么不对表中的每一个列创建一个索引" class="headerlink" title="为什么不对表中的每一个列创建一个索引?"></a>为什么不对表中的每一个列创建一个索引?</h3><ul>
<li><p>表中数据增删和修改的时候，索引也要动态的维护，索引太多会降低数据的维护速度。</p>
</li>
<li><p>索引需要占用空间，如果要建立聚族索引的话，需要的空间就会更大。</p>
</li>
</ul>
<h4 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h4><p>按照每张表的主键构造一颗B+树，同时叶子节点中存放的就是整张表的行记录数据，也将聚簇索引的叶子节点称为数据页。这个特性决定了索引组织表中数据也是索引的一部分，每张表只能拥有一个聚簇索引。</p>
<p>Innodb通过主键聚集数据，如果没有定义主键，innodb会选择非空的唯一索引代替。如果没有这样的索引，Innodb会隐式的定义一个主键来作为聚簇索引。</p>
<h3 id="使用索引的注意事项"><a href="#使用索引的注意事项" class="headerlink" title="使用索引的注意事项"></a>使用索引的注意事项</h3><ul>
<li><p>在经常需要搜索的列上，可以加快搜索速度。</p>
</li>
<li><p>在经常使用where子句的列上。</p>
</li>
<li><p>在经常需要排序的列上。</p>
</li>
<li><p>对于中到大型表索引都是非常有效的，但是特大表的话维护开销会很大，不适合建索引。</p>
</li>
<li><p>在经常用于连接的列上，这些列主要是一些外键，可以加快连接的速度。</p>
</li>
<li><p>避免where子句对字段施加函数，这会造成无法命中索引。</p>
</li>
<li><p>在使用InnoDB是使用于业务无关的自增主键作为主键,即使用逻辑主键,而不要使用业务主键; </p>
</li>
<li><p>将某一列设置为default null，where 是可以走索引的，另外索引列是否设置null是不会影响性能的。但是，最好设置为not null，因为null需要更多的存储空间并且null值无法参与某些运算。</p>
</li>
<li><p>删除长期未使用的索引，不用的索引的存在会造成不必要的性能损耗 MySQL 5.7 可以通过查询 sys 库的 schema_unused_indexes 视图来查询哪些索引从未被使用; </p>
</li>
<li><p>在使用limit offset查询缓慢时，可以借助索引来提高性能。</p>
</li>
<li><p>对于那些在查询中很少使用或者参考的列不应该创建索引。既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。</p>
</li>
<li><p>对于那些只有很少数据值的列也不应该增加索引。由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。</p>
</li>
<li><p>对于那些定义为text，image和bit数据类型的列不应该增加索引。这些列的数据量要么相当大，要么取值很少。</p>
</li>
<li><p>当修改性能远远大于检索性能时，不应该创建索引。因为<strong>修改性能和检索性能是互相矛盾的</strong>。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。</p>
</li>
</ul>
<h3 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h3><p>底层为哈希表，在绝大多数需求为单条查询时，可以选择哈希索引，查询速度最快。</p>
<h3 id="B-树索引"><a href="#B-树索引" class="headerlink" title="B+树索引"></a>B+树索引</h3><p><strong>MyISAM：</strong></p>
<p>叶节点存放的是数据记录的地址。在索引检索时，首先按照b+tree搜索索引，如果key存在，则取出data域的值，然后以data域的值为地址读取对应的数据记录。这被称为非聚簇索引;</p>
<p><strong>InnoDB：</strong></p>
<p>其数据文件本身就是索引文件。树的叶节点data域保存了完整的数据记录。这个索引的key是数据库的主键，因此InnoDB表数据文件本身就是主索引。 这被称为聚簇索引。 其余索引都是辅助索引，辅助索引的data域存的时主键的值而不是地址。在根据主索引搜索时，直接找到key所在的节点即可取出数据。在根据辅助索引查找时，则需要先取出主键的值，再走一遍索引。因此，在设计表时，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。</p>
<p>缺点：会产生大量随机io，主键不是有序递增的话，导致每次插入数据产生大量的数据迁移和空间碎片。 即使主键是有序递增，大量写请求的分布仍然是随机的。</p>
<h3 id="局部性原理与磁盘预读"><a href="#局部性原理与磁盘预读" class="headerlink" title="局部性原理与磁盘预读"></a>局部性原理与磁盘预读</h3><p>由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘I&#x2F;O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的<strong>局部性原理</strong>：<strong>当一个数据被用到时，其附近的数据也通常会马上被使用。程序运行期间所需要的数据通常比较集中。</strong></p>
<p>由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I&#x2F;O效率。</p>
<p>预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。</p>
<h3 id="数据库在磁盘中如何存储？"><a href="#数据库在磁盘中如何存储？" class="headerlink" title="数据库在磁盘中如何存储？"></a>数据库在磁盘中如何存储？</h3><p>以Innodb引擎为准，简单的说，按照表空间、段、簇、页进行存储。</p>
<p>当新建一个表，就会在磁盘上新建一个表空间（逻辑概念），用于存储数据。</p>
<p>一个表空间中包含多个段，包括叶子节点段（数据段），非叶子节点段（索引段），回滚段（保证数据完整性）。在Innodb引擎中，数据以索引组织，即聚簇索引，新建一个索引，在表空间中会同时建立数据段和索引段。</p>
<p>一个段又包括多个簇。簇是构成段的基本元素，一个段由若干个簇构成。一个簇是物理上连续分配的一个段空间，每一个段至少会有一个簇，在创建一个段时会创建一个默认的簇。如果存储数据时，一个簇已经不足以放下更多的数据，此时需要从这个段中分配一个新的簇来存放新的数据。一个段所管理的空间大小是无限的，可以一直扩展下去，但是扩展的最小单位就是簇。</p>
<p>一个簇由64个连续的页组成。每个页大小为16KB，即每个簇的大小为1MB。页可以理解为簇的细化，在逻辑（页面号连续递增）和物理上页的存储都是连续的，在向表中插入数据时，如果一个页面已经被写完，系统会从当前簇中分配一个新的空闲页面处理使用，如果当前簇中的64个页面都被分配完，系统会从当前页面所在段中分配一个新的簇，然后再从这个簇中分配一个新的页面来使用。</p>
<h3 id="Mysql为什么使用b-树，而不是b树、二叉树、AVL树或红黑树？"><a href="#Mysql为什么使用b-树，而不是b树、二叉树、AVL树或红黑树？" class="headerlink" title="Mysql为什么使用b+树，而不是b树、二叉树、AVL树或红黑树？"></a>Mysql为什么使用b+树，而不是b树、二叉树、AVL树或红黑树？</h3><ul>
<li>B+树的高度一般只有2-4层，所以查找记录时最多只需要2-4次IO，相对二叉平衡树已经大大降低了。平衡二叉树的每个节点只有两个孩子节点，如果一张表的数据量特别大，整棵树的高度也会随之上升。一个千万级别的表如果用平衡二叉树作为索引的话，树高将会达到二十多层。这也就意味着做一次查询需要二十多次磁盘io，这是一个不小的开销。平衡二叉树的瓶颈在于一个节点只有两个孩子节点，而B树一个节点可以存放N个孩子节点，这就完美解决了树高的问题，我们可以把B树称为平衡多叉树。</li>
<li>范围查找时，能通过叶子节点的指针获取数据。例如查找大于等于3的数据，当在叶子节点中查到3时，通过3的尾指针便能获取所有数据，而不需要再像二叉树一样再获取到3的父节点。</li>
</ul>
<h4 id="B树和B-树"><a href="#B树和B-树" class="headerlink" title="B树和B+树"></a>B树和B+树</h4><p>平衡二叉树的瓶颈在于一个节点只有两个孩子节点，而B树一个节点可以存放N个孩子节点，这就完美解决了树高的问题，我们可以把B树称为平衡多叉树，B树作为索引如下图所示：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202151438194.png" alt="图片来源网络"></p>
<p>但是以B树的结构作为索引仍有可以优化的地方</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202151438215.png" alt="图片来源网络"></p>
<p>从图片中可以看到B+树同样是一棵多差平衡树，和B树一样很好地解决了树高的问题。</p>
<h5 id="改进点一："><a href="#改进点一：" class="headerlink" title="改进点一："></a>改进点一：</h5><p>B树的节点中既存储索引，也存储表对应的数据；而B+树的非叶子节点是不存储数据的，只存储索引，数据全部存储在叶子节点上。</p>
<p>例如：</p>
<p>假设树高为2，主键ID为bigint类型，长度为8字节，节点指针为6字节，一行数据记录的大小为1k，一次io操作能获得一页16k的数据。</p>
<p>在索引为B+树的情况下，根节点能存储：16k &#x2F; （6 + 8） &#x3D; 1170 条索引指针；到了第一层，一共能指向 1170 * 1170 &#x3D; 1368900 条索引指针；到了最底一层叶子节点，一个节点能存储16k &#x2F; 1k &#x3D; 16 条记录，一共能存储 1170 * 1170 * 16 &#x3D; 21902400 条记录</p>
<p>在B树的情况下，由于非叶子节点使用了大量空间存储数据，存放的索引指针肯定就少，最终整棵树如果想要存储和B+树一样多的数据就必须要增加树高，这样一来就增加了磁盘io，所以说B+树作为索引的性能比B树高。</p>
<h5 id="改进点二："><a href="#改进点二：" class="headerlink" title="改进点二："></a>改进点二：</h5><p>使用b树，数据存储在每一个节点中，搜索时会做局部中序遍历，如果查询多条数据，即需要跨层访问，仍然对搜索效率有不利影响；B+叶子节点之间使用指针连接，提高区间访问效率。如果要进行范围查询，可以轻松通过B+树叶子节点之间的指针进行遍历，减少了不必要的磁盘io。</p>
<h3 id="为什么不常用哈希表和数组作为索引"><a href="#为什么不常用哈希表和数组作为索引" class="headerlink" title="为什么不常用哈希表和数组作为索引?"></a>为什么不常用哈希表和数组作为索引?</h3><p>哈希表虽然单一个值的查询效率很高，但是撑不住范围查询。</p>
<p>而数组虽然查询的效率高，但是增加和删除的效率低，由于记录在增加和删除的时候索引也得跟着维护，这会导致大数据量的情况下，增加或删除一条记录效率较低。如果没有增删，且按id查询，id递增，只有范围查询和单条查询，可以用数组做索引。</p>
<h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>一个索引包含所有需要查询的字段的值，不需要回表。</p>
<p>例如： select id,name where name&#x3D;’shenjian’ 此时索引包含了所需要查询的字段的值， 不需要回表。</p>
<h3 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h3><p>加联合索引(name, city)</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name<span class="operator">=</span>xx <span class="keyword">and</span> city<span class="operator">=</span>xx ; ／／可以命中索引</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name<span class="operator">=</span>xx ; <span class="operator">/</span><span class="operator">/</span> 可以命中索引</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> city<span class="operator">=</span>xx ; <span class="operator">/</span><span class="operator">/</span> 无法命中索引            </span><br></pre></td></tr></table></figure>

<h3 id="注意避免索引冗余"><a href="#注意避免索引冗余" class="headerlink" title="注意避免索引冗余"></a>注意避免索引冗余</h3><p>(name,city)和(name)冗余</p>
<h3 id="添加索引"><a href="#添加索引" class="headerlink" title="添加索引"></a>添加索引</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `table_name` <span class="keyword">ADD</span> <span class="keyword">PRIMARY</span> KEY ( `<span class="keyword">column</span>` ) <span class="operator">/</span><span class="operator">/</span>主键索引</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `table_name` <span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> ( `<span class="keyword">column</span>` ) <span class="operator">/</span><span class="operator">/</span> 唯一索引</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `table_name` <span class="keyword">ADD</span> INDEX index_name ( `<span class="keyword">column</span>` ) <span class="operator">/</span><span class="operator">/</span>普通索引</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `table_name` <span class="keyword">ADD</span> FULLTEXT ( `<span class="keyword">column</span>`)  <span class="operator">/</span><span class="operator">/</span> 全文索引</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `table_name` <span class="keyword">ADD</span> INDEX index_name ( `column1`, `column2`, `column3` ) <span class="operator">/</span><span class="operator">/</span>多行索引</span><br></pre></td></tr></table></figure>

<h2 id="分库分表后，id主键如何处理？"><a href="#分库分表后，id主键如何处理？" class="headerlink" title="分库分表后，id主键如何处理？"></a>分库分表后，id主键如何处理？</h2><p>因为要是分成多个表之后，需要一个全局唯一的 id 。</p>
<p>为了达到业务的幂等，必须要有这样一个id存在，需要满足下面几个条件：</p>
<ul>
<li>同一业务场景要全局唯一。</li>
<li>该id必须是在消息的发送方进行产生发送到MQ。</li>
<li>消费端根据该id进行判断是否重复，确保幂等。</li>
</ul>
<h3 id="通用唯一识别码（Universally-Unique-Identifier，UUID）"><a href="#通用唯一识别码（Universally-Unique-Identifier，UUID）" class="headerlink" title="通用唯一识别码（Universally Unique Identifier，UUID）"></a>通用唯一识别码（Universally Unique Identifier，UUID）</h3><p>不适合作为主键，因为太长了，并且无序不可读，查询效率低。比较适合用于生成唯一的名字的标示比如文件的名字。</p>
<h4 id="为什么无序的UUID会导致入库性能变差呢？"><a href="#为什么无序的UUID会导致入库性能变差呢？" class="headerlink" title="为什么无序的UUID会导致入库性能变差呢？"></a>为什么无序的UUID会导致入库性能变差呢？</h4><p>关系型数据库的索引大都是B+树的结构，拿ID字段来举例，索引树的每一个节点都存储着若干个ID。如果我们的ID按递增的顺序来插入，比如陆续插入8，9，10，新的ID都只会插入到最后一个节点当中。当最后一个节点满了，会裂变出新的节点。这样的插入是性能比较高的插入，因为这样节点的分裂次数最少，而且充分利用了每一个节点的空间。但是，如果我们的插入完全无序，不但会导致一些中间节点产生分裂，也会白白创造出很多不饱和的节点，这样大大降低了数据库插入的性能。</p>
<p>信息不安全：基于MAC地址生成UUID的算法可能会造成MAC地址泄露，这个漏洞曾被用于寻找梅丽莎病毒的制作者位置。</p>
<h3 id="数据库生成"><a href="#数据库生成" class="headerlink" title="数据库生成"></a>数据库生成</h3><p>以MySQL举例，利用给字段设置<code>auto_increment_increment</code>和<code>auto_increment_offset</code>来保证ID自增，每次业务使用下列SQL读写MySQL得到ID号。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line">REPLACE <span class="keyword">INTO</span> Tickets64 (stub) <span class="keyword">VALUES</span> (<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="keyword">SELECT</span> LAST_INSERT_ID();</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202262013045.png" alt="image"></p>
<p><strong>优点：</strong></p>
<ul>
<li>非常简单，利用现有数据库系统的功能实现，成本小，有DBA专业维护。</li>
<li>ID号单调自增，可以实现一些对ID有特殊要求的业务。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>强依赖DB，当DB异常时整个系统不可用，属于致命问题。配置主从复制可以尽可能的增加可用性，但是数据一致性在特殊情况下难以保证。主从切换时的不一致可能会导致重复发号。</li>
<li>ID发号性能瓶颈限制在单台MySQL的读写性能。</li>
</ul>
<p>对于MySQL性能问题，可用如下方案解决：在分布式系统中可以多部署几台机器，每台机器设置不同的初始值，且步长和机器数相等。比如有两台机器。设置步长step为2，TicketServer1的初始值为1（1，3，5，7，9，11…）、TicketServer2的初始值为2（2，4，6，8，10…）。这是Flickr团队在2010年撰文介绍的一种主键生成策略（<a target="_blank" rel="noopener" href="http://code.flickr.net/2010/02/08/ticket-servers-distributed-unique-primary-keys-on-the-cheap/">Ticket Servers: Distributed Unique Primary Keys on the Cheap </a>）。如下所示，为了实现上述方案分别设置两台机器对应的参数，TicketServer1从1开始发号，TicketServer2从2开始发号，两台机器每次发号之后都递增2。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TicketServer1:</span><br><span class="line">auto<span class="operator">-</span>increment<span class="operator">-</span>increment <span class="operator">=</span> <span class="number">2</span></span><br><span class="line">auto<span class="operator">-</span>increment<span class="operator">-</span><span class="keyword">offset</span> <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">TicketServer2:</span><br><span class="line">auto<span class="operator">-</span>increment<span class="operator">-</span>increment <span class="operator">=</span> <span class="number">2</span></span><br><span class="line">auto<span class="operator">-</span>increment<span class="operator">-</span><span class="keyword">offset</span> <span class="operator">=</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>假设我们要部署N台机器，步长需设置为N，每台的初始值依次为0,1,2…N-1那么整个架构就变成了如下图所示：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202262015433.png" alt="image"></p>
<p>这种架构貌似能够满足性能的需求，但有以下几个缺点：</p>
<ul>
<li>系统水平扩展比较困难，比如定义好了步长和机器台数之后，如果要添加机器该怎么做？假设现在只有一台机器发号是1,2,3,4,5（步长是1），这个时候需要扩容机器一台。可以这样做：把第二台机器的初始值设置得比第一台超过很多，比如14（假设在扩容时间之内第一台不可能发到14），同时设置步长为2，那么这台机器下发的号码都是14以后的偶数。然后摘掉第一台，把ID值保留为奇数，比如7，然后修改第一台的步长为2。让它符合我们定义的号段标准，对于这个例子来说就是让第一台以后只能产生奇数。扩容方案看起来复杂吗？貌似还好，现在想象一下如果我们线上有100台机器，这个时候要扩容该怎么做？简直是噩梦。所以系统水平扩展方案复杂难以实现。</li>
<li>ID没有了单调递增的特性，只能趋势递增，这个缺点对于一般业务需求不是很重要，可以容忍。</li>
<li>数据库压力还是很大，每次获取ID都得读写一次数据库，只能靠堆机器来提高性能。</li>
</ul>
<h3 id="利用-redis-生成-id"><a href="#利用-redis-生成-id" class="headerlink" title="利用 redis 生成 id"></a>利用 redis 生成 id</h3><p>性能比较好，灵活方便，不依赖于数据库。但是，引入了新的组件造成系统更加复杂，可用性降低，编码更加复杂，增加了系统成本。</p>
<h3 id="Twitter的snowflake算法"><a href="#Twitter的snowflake算法" class="headerlink" title="Twitter的snowflake算法"></a>Twitter的snowflake算法</h3><p>Github 地址：<a target="_blank" rel="noopener" href="https://github.com/twitter-archive/snowflake%E3%80%82">https://github.com/twitter-archive/snowflake。</a></p>
<p>核心思想：</p>
<p>使用41bit作为毫秒数，10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID），12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 ID），最后还有一个符号位，永远是0。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202262008389.png" alt="img"></p>
<p><strong>优点：</strong> </p>
<ul>
<li>生成ID不依赖于DB，完全在内存生成，高性能高可用。 </li>
<li>ID呈趋势递增，后续插入索引树的时候性能较好。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><p>依赖于系统时钟的一致性。如果某台机器的系统时钟回拨，有可能造成ID冲突，或者ID乱序。</p>
</li>
<li><p>id递增还可能会有信息安全问题，竞争对手可能会通过这个id知道公司一天的单量。</p>
</li>
</ul>
<h3 id="美团的Leaf分布式ID生成系统"><a href="#美团的Leaf分布式ID生成系统" class="headerlink" title="美团的Leaf分布式ID生成系统"></a>美团的Leaf分布式ID生成系统</h3><blockquote>
<p>There are no two identical leaves in the world !</p>
</blockquote>
<p>Leaf 是美团开源的分布式ID生成器，能保证全局唯一性、趋势递增、单调递增、信息安全，但也需要依赖关系数据库、Zookeeper等中间件。</p>
<p>美团技术团队的一篇文章：<a target="_blank" rel="noopener" href="https://tech.meituan.com/2017/04/21/mt-leaf.html">https://tech.meituan.com/2017/04/21/mt-leaf.html</a> 。</p>
<h4 id="Leaf-segment数据库方案"><a href="#Leaf-segment数据库方案" class="headerlink" title="Leaf-segment数据库方案"></a>Leaf-segment数据库方案</h4><p>Leaf-segment方案，在使用数据库生成的方案上，做了如下改变：原方案每次获取ID都得读写一次数据库，造成数据库压力大。改为利用proxy server批量获取，每次获取一个segment（step决定大小）号段的值。用完之后再去数据库获取新的号段，可以大大的减轻数据库的压力。 各个业务不同的发号需求用biz_tag字段来区分，每个biz-tag的ID获取相互隔离，互不影响。如果以后有性能需求需要对数据库扩容，不需要上述描述的复杂的扩容操作，只需要对biz_tag分库分表就行。</p>
<p>数据库表设计如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">-------------+--------------+------+-----+-------------------+-----------------------------+</span></span><br><span class="line"><span class="operator">|</span> Field       <span class="operator">|</span> Type         <span class="operator">|</span> <span class="keyword">Null</span> <span class="operator">|</span> Key <span class="operator">|</span> <span class="keyword">Default</span>           <span class="operator">|</span> Extra                       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+--------------+------+-----+-------------------+-----------------------------+</span></span><br><span class="line"><span class="operator">|</span> biz_tag     <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">128</span>) <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> PRI <span class="operator">|</span>                   <span class="operator">|</span>                             <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> max_id      <span class="operator">|</span> <span class="type">bigint</span>(<span class="number">20</span>)   <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> <span class="number">1</span>                 <span class="operator">|</span>                             <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> step        <span class="operator">|</span> <span class="type">int</span>(<span class="number">11</span>)      <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>              <span class="operator">|</span>                             <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">desc</span>        <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">256</span>) <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>              <span class="operator">|</span>                             <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> update_time <span class="operator">|</span> <span class="type">timestamp</span>    <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="operator">|</span> <span class="keyword">on</span> <span class="keyword">update</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+--------------+------+-----+-------------------+-----------------------------+</span></span><br></pre></td></tr></table></figure>

<p>重要字段说明：biz_tag用来区分业务，max_id表示该biz_tag目前所被分配的ID号段的最大值，step表示每次分配的号段长度。原来获取ID每次都需要写数据库，现在只需要把step设置得足够大，比如1000。那么只有当1000个号被消耗完了之后才会去重新读写一次数据库。读写数据库的频率从1减小到了1&#x2F;step，大致架构如下图所示：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202262038462.png" alt="image"></p>
<p>test_tag在第一台Leaf机器上是1~1000的号段，当这个号段用完时，会去加载另一个长度为step&#x3D;1000的号段，假设另外两台号段都没有更新，这个时候第一台机器新加载的号段就应该是3001~4000。同时数据库对应的biz_tag这条数据的max_id会从3000被更新成4000，更新号段的SQL语句如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Begin</span></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">table</span> <span class="keyword">SET</span> max_id<span class="operator">=</span>max_id<span class="operator">+</span>step <span class="keyword">WHERE</span> biz_tag<span class="operator">=</span>xxx</span><br><span class="line"><span class="keyword">SELECT</span> tag, max_id, step <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> biz_tag<span class="operator">=</span>xxx</span><br><span class="line"><span class="keyword">Commit</span></span><br></pre></td></tr></table></figure>

<p>这种模式有以下优缺点：</p>
<p>优点：</p>
<ul>
<li>Leaf服务可以很方便的线性扩展，性能完全能够支撑大多数业务场景。</li>
<li>ID号码是趋势递增的8byte的64位数字，满足上述数据库存储的主键要求。</li>
<li>容灾性高，Leaf服务内部有号段缓存，即使DB宕机，短时间内Leaf仍能正常对外提供服务。</li>
<li>可以自定义max_id的大小，非常方便业务从原有的ID方式上迁移过来。</li>
</ul>
<p>缺点：</p>
<ul>
<li>ID号码不够随机，能够泄露发号数量的信息，不太安全。</li>
<li>TP999数据波动大，当号段使用完之后还是会hang在更新数据库的I&#x2F;O上，tg999数据会出现偶尔的尖刺。</li>
<li>DB宕机会造成整个系统不可用。</li>
</ul>
<h5 id="双buffer优化"><a href="#双buffer优化" class="headerlink" title="双buffer优化"></a>双buffer优化</h5><p>对于第二个缺点，Leaf-segment做了一些优化：</p>
<p>Leaf 取号段的时机是在号段消耗完的时候进行的，也就意味着号段临界点的ID下发时间取决于下一次从DB取回号段的时间，并且在这期间进来的请求也会因为DB号段没有取回来，导致线程阻塞。如果请求DB的网络和DB的性能稳定，这种情况对系统的影响是不大的，但是假如取DB的时候网络发生抖动，或者DB发生慢查询就会导致整个系统的响应时间变慢。</p>
<p>为此，我们希望DB取号段的过程能够做到无阻塞，不需要在DB取号段的时候阻塞请求线程，即当号段消费到某个点时就异步的把下一个号段加载到内存中。而不需要等到号段用尽的时候才去更新号段。这样做就可以很大程度上的降低系统的TP999指标。详细实现如下图所示：</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202262038791.png" alt="image"></p>
<p>采用双buffer的方式，Leaf服务内部有两个号段缓存区segment。当前号段已下发10%时，如果下一个号段未更新，则另启一个更新线程去更新下一个号段。当前号段全部下发完后，如果下个号段准备好了则切换到下个号段为当前segment接着下发，循环往复。</p>
<ul>
<li>每个biz-tag都有消费速度监控，通常推荐segment长度设置为服务高峰期发号QPS的600倍（10分钟），这样即使DB宕机，Leaf仍能持续发号10-20分钟不受影响。</li>
<li>每次请求来临时都会判断下个号段的状态，从而更新此号段，所以偶尔的网络抖动不会影响下个号段的更新。</li>
</ul>
<h5 id="Leaf高可用容灾"><a href="#Leaf高可用容灾" class="headerlink" title="Leaf高可用容灾"></a>Leaf高可用容灾</h5><p>对于第三点“DB可用性”问题，目前采用一主两从的方式，同时分机房部署，Master和Slave之间采用<strong>半同步方式同步数据</strong>。同时使用公司Atlas数据库中间件(已开源，改名为<a target="_blank" rel="noopener" href="http://tech.meituan.com/dbproxy-introduction.html">DBProxy</a>)做主从切换。当然这种方案在一些情况会退化成异步模式，甚至在<strong>非常极端</strong>情况下仍然会造成数据不一致的情况，但是出现的概率非常小。如果你的系统要保证100%的数据强一致，可以选择使用“类Paxos算法”实现的强一致MySQL方案，如MySQL 5.7前段时间刚刚GA的<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/group-replication.html">MySQL Group Replication</a>。但是运维成本和精力都会相应的增加，根据实际情况选型即可。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202262038815.png" alt="image"></p>
<p>同时Leaf服务分IDC部署，内部的服务化框架是“MTthrift RPC”。服务调用的时候，根据负载均衡算法会优先调用同机房的Leaf服务。在该IDC内Leaf服务不可用的时候才会选择其他机房的Leaf服务。同时服务治理平台OCTO还提供了针对服务的过载保护、一键截流、动态流量分配等对服务的保护措施。</p>
<h4 id="Leaf-snowflake方案"><a href="#Leaf-snowflake方案" class="headerlink" title="Leaf-snowflake方案"></a>Leaf-snowflake方案</h4><p>Leaf-segment方案可以生成趋势递增的ID，同时ID号是可计算的，不适用于订单ID生成场景，比如竞对在两天中午12点分别下单，通过订单id号相减就能大致计算出公司一天的订单量，这个是不能忍受的。 Leaf-snowflake方案可以很好的解决这个问题。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202262023049.png" alt="img"></p>
<p>Leaf-snowflake方案完全沿用snowflake方案的bit位设计，即是“1+41+10+12”的方式组装ID号。对于workerID的分配，当服务集群数量较小的情况下，完全可以手动配置。Leaf服务规模较大，动手配置成本太高。所以使用Zookeeper持久顺序节点的特性自动对snowflake节点配置wokerID。Leaf-snowflake是按照下面几个步骤启动的：</p>
<ol>
<li>启动Leaf-snowflake服务，连接Zookeeper，在leaf_forever父节点下检查自己是否已经注册过（是否有该顺序子节点）。</li>
<li>如果有注册过直接取回自己的workerID（zk顺序节点生成的int类型ID号），启动服务。</li>
<li>如果没有注册过，就在该父节点下面创建一个持久顺序节点，创建成功后取回顺序号当做自己的workerID号，启动服务。</li>
</ol>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202262024027.png" alt="image"></p>
<h5 id="弱依赖ZooKeeper"><a href="#弱依赖ZooKeeper" class="headerlink" title="弱依赖ZooKeeper"></a>弱依赖ZooKeeper</h5><p>除了每次会去ZK拿数据以外，也会在本机文件系统上缓存一个workerID文件。当ZooKeeper出现问题，恰好机器出现问题需要重启时，能保证服务能够正常启动。这样做到了对三方组件的弱依赖。一定程度上提高了SLA。</p>
<h5 id="解决时钟问题"><a href="#解决时钟问题" class="headerlink" title="解决时钟问题"></a>解决时钟问题</h5><p>因为这种方案依赖时间，如果机器的时钟发生了回拨，那么就会有可能生成重复的ID号，需要解决时钟回退的问题。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202262024180.png" alt="image"></p>
<p>服务启动时首先检查自己是否写过ZooKeeper leaf_forever节点：</p>
<ol>
<li>若写过，则用自身系统时间与leaf_forever&#x2F;${self}节点记录时间做比较，若小于leaf_forever&#x2F;${self}时间则认为机器时间发生了大步长回拨，服务启动失败并报警。</li>
<li>若未写过，证明是新服务节点，直接创建持久节点leaf_forever&#x2F;${self}并写入自身系统时间，接下来综合对比其余Leaf节点的系统时间来判断自身系统时间是否准确，具体做法是取leaf_temporary下的所有临时节点（所有运行中的Leaf-snowflake节点）的服务IP：Port，然后通过RPC请求得到所有节点的系统时间，计算sum(time)&#x2F;nodeSize。</li>
<li>若abs( 系统时间-sum(time)&#x2F;nodeSize ) &lt; 阈值，认为当前系统时间准确，正常启动服务，同时写临时节点leaf_temporary&#x2F;${self} 维持租约。</li>
<li>否则认为本机系统时间发生大步长偏移，启动失败并报警。</li>
<li>每隔一段时间(3s)上报自身系统时间写入leaf_forever&#x2F;${self}。</li>
</ol>
<p>由于强依赖时钟，对时间的要求比较敏感，在机器工作时NTP同步也会造成秒级别的回退，建议可以直接关闭NTP同步。要么在时钟回拨的时候直接不提供服务直接返回ERROR_CODE，等时钟追上即可。<strong>或者做一层重试，然后上报报警系统，更或者是发现有时钟回拨之后自动摘除本身节点并报警</strong>。</p>
<p><strong>从上线情况来看，在2017年闰秒出现那一次出现过部分机器回拨，由于Leaf-snowflake的策略保证，成功避免了对业务造成的影响。</strong></p>
<h4 id="Leaf现状"><a href="#Leaf现状" class="headerlink" title="Leaf现状"></a>Leaf现状</h4><p>Leaf在美团点评公司内部服务包含金融、支付交易、餐饮、外卖、酒店旅游、猫眼电影等众多业务线。目前Leaf的性能在4C8G的机器上QPS能压测到近5w&#x2F;s，TP999 1ms，已经能够满足大部分的业务的需求。每天提供亿数量级的调用量，作为公司内部公共的基础技术设施，必须保证高SLA和高性能的服务.</p>
<h2 id="一条SQL语句在MySQL中如何执行的"><a href="#一条SQL语句在MySQL中如何执行的" class="headerlink" title="一条SQL语句在MySQL中如何执行的"></a>一条SQL语句在MySQL中如何执行的</h2><ul>
<li><p>server层：连接，查询缓存，分析，优化，执行</p>
<ul>
<li><p>连接器：登录数据库，分析权限，建立连接，在连接不断开的情况下，即使管理员修改这个用户的权限也不会生效。</p>
</li>
<li><p>查询缓存（mysql8.0 版本后移除）： 查询缓存主要用来缓存我们所执行的 SELECT 语句以及该语句的结果集。</p>
<p>连接建立后，执行查询语句的时候，会先查询缓存，MySQL 会先校验这个 sql 是否执行过，以 Key-Value 的形式缓存在内存中，Key 是查询语句，Value 是结果集。如果缓存 key 被命中，就会直接返回给客户端，如果没有命中，就会执行后续的操作，完成后也会把结果缓存起来，方便下一次调用。当然在真正执行缓存查询的时候还是会校验用户的权限，是否有该表的查询条件。</p>
<p>MySQL 查询不建议使用缓存，因为查询缓存失效在实际业务场景中可能会非常频繁，假如你对一个表更新的话，这个表上的所有的查询缓存都会被清空。对于不经常更新的数据来说，使用缓存还是可以的。</p>
<p>所以，一般在大多数情况下都是不推荐去使用查询缓存的。</p>
<p>MySQL 8.0 版本后删除了缓存的功能，官方也是认为该功能在实际的应用场景比较少，所以干脆直接删掉了。</p>
</li>
<li><p>分析器：</p>
<ul>
<li><p>词法分析：一条 SQL 语句有多个字符串组成，首先要提取关键字，比如 select，提出查询的表，提出字段名，提出查询条件等等。做完这些操作后，就会进入第二步。</p>
</li>
<li><p>语法分析：主要就是判断你输入的 sql 是否正确，是否符合 MySQL 的语法。</p>
</li>
</ul>
</li>
<li><p>优化器：优化器的作用就是已它认为的最优的执行方案去执行（有时候可能也不是最优），比如多个索引的时候该如何选择索引，多表查询的时候如何选择关联顺序等。</p>
<p>可以说，经过了优化器之后可以说这个语句具体该如何执行就已经定下来。</p>
</li>
<li><p>执行器：当选择了执行方案后,mysql就准备开始执行了,首先执行前会检验该用户有没有权限,如果没有权限,就会返回错误信息,如果有权限,就会去调用引擎的接口,返回接口执行的结果</p>
</li>
</ul>
</li>
<li><p>存储引擎：主要负责数据的存储和读取，采用可以替换的插件式架构，支持 InnoDB、MyISAM、Memory 等多个存储引擎，其中 InnoDB 引擎有自有的日志模块 redolog 模块。<strong>现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始就被当做默认存储引擎了。</strong></p>
</li>
</ul>
<p>MySQL 主要分为 Server 层和引擎层，Server 层主要包括连接器、查询缓存、分析器、优化器、执行器，同时还有一个日志模块（binlog），这个日志模块所有执行引擎都可以共用，redolog 只有 InnoDB 有。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202151438635.png" alt="img"></p>
<h3 id="一条更新语句执行的顺序"><a href="#一条更新语句执行的顺序" class="headerlink" title="一条更新语句执行的顺序"></a>一条更新语句执行的顺序</h3><p>update T set c&#x3D;c+1 where ID&#x3D;2;</p>
<ul>
<li>执行器先找引擎取 ID&#x3D;2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID&#x3D;2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。如果内存不足，则需要页面置换（最佳置换、先进先出、最近最近未用、时钟置换算法（只有一个访问位）、改进型时钟置换算法（有一个访问和修改位，优先淘汰没有修改过的页面） ）。</li>
<li>执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。</li>
<li>引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。</li>
<li>执行器生成这个操作的binlog，并把 binlog 写入磁盘（FIFS、 最短寻道时间、扫描算法和循环扫描算法）。</li>
<li>执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。</li>
</ul>
<h2 id="Undo-log、-Redo-log、Binary-log"><a href="#Undo-log、-Redo-log、Binary-log" class="headerlink" title="Undo log、 Redo log、Binary log"></a>Undo log、 Redo log、Binary log</h2><h3 id="undo-log和redo-log"><a href="#undo-log和redo-log" class="headerlink" title="undo log和redo log"></a>undo log和redo log</h3><p>在数据库系统中，既有存放数据的文件，也有存放日志的文件。日志在内存中也是有缓存Log buffer，也有磁盘文件log file。MySQL中的日志文件，有这么两类与事务有关：undo日志与redo日志。</p>
<h4 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h4><p>持久性和原子性可以利用undo log来实现。</p>
<p>原理：为了满足事务的原子性，在操作任何数据之前，首先将数据备份到undo log，然后进行数据的修改。如果出现了错误或者用户执行了ROLLBACK语句，系统可以利用Undo log 中的备份数据将数据恢复到事务开始之前的状态。</p>
<p>数据库写入数据到磁盘之前会把数据先缓存在内存中，事务提交时才会写入磁盘中。</p>
<p>用undo log 实现原子性和持久性的事务的简化过程: </p>
<p>假设有A、B两个数据，值分别为1,2</p>
<p> A. 事务开始.<br> B. 记录A&#x3D;1到undo log buffer.<br> C. 修改A&#x3D;3.<br> D. 记录B&#x3D;2到undo log buffer.<br> E. 修改B&#x3D;4.<br> F. 将undo log buffer写到磁盘。<br> G. 将数据写到磁盘。<br> H. 事务提交</p>
<ul>
<li><p>如何保证原子性？</p>
<p>在修改数据到磁盘前，会先记录undo log，并将undo log持久化到硬盘</p>
</li>
<li><p>如何保证持久性？</p>
<p>在事务提交之前，把内存中缓存的数据写入磁盘。这样事务提交时，可以确定数据是已经持久化的，不会丢失。</p>
</li>
<li><p>若系统在G和H之间崩溃</p>
<p>此时事务并未提交，需要回滚。而undo log已经被持久化，可以根据undo log来恢复数据</p>
</li>
<li><p>若系统在G之前崩溃</p>
<p>此时数据并未持久化到硬盘，依然保持在事务之前的状态</p>
</li>
</ul>
<p><strong>缺陷：</strong>每个事务提交前将数据和Undo Log写入磁盘，这样会导致大量的磁盘IO，因此性能很低。</p>
<p>如果能够将数据缓存一段时间，就能减少IO提高性能。但是这样就会丧失事务的持久性。因此引入了另外一种机制来实现持久化，即<strong>Redo Log</strong>.</p>
<h4 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h4><p>和Undo Log相反，Redo Log记录的是<strong>新数据</strong>的备份。<strong>在事务提交前，只要将Redo Log持久化即可，不需要将数据持久化，减少了IO的次数。</strong></p>
<p>先来看下基本原理：</p>
<blockquote>
<p><strong>Undo + Redo事务的简化过程</strong></p>
</blockquote>
<p> 假设有A、B两个数据，值分别为1,2</p>
<p> A. 事务开始.<br> B. 记录A&#x3D;1到undo log buffer.<br> C. 修改A&#x3D;3.<br> D. 记录A&#x3D;3到redo log buffer.<br> E. 记录B&#x3D;2到undo log buffer.<br> F. 修改B&#x3D;4.<br> G. 记录B&#x3D;4到redo log buffer.<br> H. 将undo log buffer写入redo log buffer<br> I. 将redo log写入磁盘<br> J. 事务提交</p>
<p>K.最后再将数据写回磁盘(不一定立刻写回)</p>
<ul>
<li><p>如何保证原子性？</p>
<p>如果在事务提交前故障，通过undo log日志恢复数据。如果undo log都还没写入，那么数据就尚未持久化，无需回滚</p>
</li>
<li><p>如何保证持久化？</p>
<p>这里并没有出现数据的持久化。因为数据已经写入redo log，而redo log持久化到了硬盘，因此只要到了I以后，事务是可以提交的。</p>
</li>
<li><p>内存中的数据库数据何时持久化到磁盘？</p>
<p>因为redo log已经持久化，因此数据库数据写入磁盘与否影响不大，不过为了避免出现脏数据（内存中与磁盘不一致），事务提交后也会将内存数据刷入磁盘（也可以按照固设定的频率刷新内存数据到磁盘中）。</p>
</li>
<li><p>持久化redo和持久化数据库数据有什么性能差异？</p>
<ul>
<li><p>数据库数据写入是随机IO，性能很差</p>
</li>
<li><p>redo log在初始化时会开辟一段连续的空间，写入是顺序IO，性能很好</p>
</li>
</ul>
</li>
<li><p>redo log中记录的数据，有可能尚未提交，那么如何完成数据恢复？</p>
<p>数据恢复有两种策略：</p>
<ul>
<li>恢复时，只重做已经提交了的事务</li>
<li>恢复时，重做所有事务包括未提交的事务和回滚了的事务。然后通过Undo Log回滚那些未提交的事务</li>
</ul>
<p>Inodb引擎采用的是第二种方案，因此undo log要在 redo log前持久化</p>
</li>
<li><p>写入性能的优化</p>
<p>事务提交前需要同时写入undo log和 redo log，势必增加IO次数，因此实际上undo log并不是直接写入磁盘，而是先写入到redo log中，当redo log持久化时，undo log就同时持久化到硬盘了。</p>
<p>因此事务提交前，只需要对redo log持久化即可。</p>
<p>另外，redo log并不是写入一次就持久化一次，redo log在内存中也有自己的缓冲池：<code>redo log buffer</code>。每次写redo log都是写入到buffer，在提交时一次性持久化到磁盘，减少IO此时。</p>
</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>undo log 记录更新前数据，用于保证事务原子性</li>
<li>redo log 记录更新后数据，用于保证事务的持久性</li>
<li>redo log有自己的内存buffer，先写入到buffer，事务提交时写入磁盘</li>
<li>redo log持久化之后，意味着事务是<strong>可提交</strong>的</li>
</ul>
<h3 id="redo-log日志模块"><a href="#redo-log日志模块" class="headerlink" title="redo log日志模块"></a>redo log日志模块</h3><p>redo log是InnoDB存储引擎层的日志，又称重做日志文件，用于记录事务操作的变化，记录的是数据修改之后的值，不管事务是否提交都会记录下来。在实例和介质失败（media failure）时，redo log文件就能派上用场，如数据库掉电，InnoDB存储引擎会使用redo log恢复到掉电前的时刻，以此来保证数据的完整性。</p>
<p>在一条更新语句进行执行的时候，InnoDB引擎会把更新记录写到redo log日志中，然后更新内存，此时算是语句执行完了，然后在空闲的时候或者是按照设定的更新策略将redo log中的内容更新到磁盘中，这里涉及到WAL即Write Ahead logging技术，他的关键点是先写日志，再写磁盘。</p>
<p>有了redo log日志，那么在数据库进行异常重启的时候，可以根据redo log日志进行恢复，也就达到了crash-safe。</p>
<p>redo log日志的大小是固定的，即记录满了以后就从头循环写。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202151438630.jpg" alt="img"></p>
<p>该图展示了一组4个文件的redo log日志，checkpoint之前表示擦除完了的，即可以进行写的，擦除之前会更新到磁盘中，write pos是指写的位置，当write pos和checkpoint相遇的时候表明redo log已经满了，这个时候数据库停止进行数据库更新语句的执行，转而进行redo log日志同步到磁盘中。</p>
<h4 id="redo-log机制："><a href="#redo-log机制：" class="headerlink" title="redo log机制："></a>redo log机制：</h4><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202151438643.jpg" alt="必须了解的mysql三大日志-binlog、redo log和undo log"></p>
<ul>
<li>由两部分组成，一个是内存中的redo log buffer，另一个是磁盘的 redo log file</li>
<li>每次对数据进行修改，先写进buffer中，后续某个时间点再一次将多个操作记录写到redo log file中</li>
<li>三种写入级别<ul>
<li>延迟写，延迟刷新，参数0，适合普通数据，每隔一秒刷新到磁盘一次</li>
<li>实时写，实时刷新，参数1，适合金融数据，写到内存的同时直接刷新到磁盘</li>
<li>实时写，延迟刷新，参数2，适合订单数据，每次提交立马写入os buffer，每隔一秒刷到磁盘</li>
</ul>
</li>
</ul>
<h3 id="binlog日志模块"><a href="#binlog日志模块" class="headerlink" title="binlog日志模块"></a>binlog日志模块</h3><p>binlog是属于MySQL Server层面的，又称为归档日志，属于逻辑日志，是以二进制的形式记录的是这个语句的原始逻辑，依靠binlog是没有crash-safe能力的</p>
<h3 id="redo-log和binlog区别"><a href="#redo-log和binlog区别" class="headerlink" title="redo log和binlog区别"></a>redo log和binlog区别</h3><ul>
<li>redo log是属于innoDB层面，binlog属于MySQL Server层面的，这样在数据库用别的存储引擎时可以达到一致性的要求。</li>
<li>redo log是物理日志，记录该数据页更新的内容；binlog是逻辑日志，记录的是这个更新语句的原始逻辑。</li>
<li>redo log是循环写，日志空间大小固定；binlog是追加写，是指一份写到一定大小的时候会更换下一个文件，不会覆盖。</li>
<li>binlog可以作为恢复数据使用，主从复制搭建，redo log作为异常宕机或者介质故障后的数据恢复使用。</li>
</ul>
<h3 id="redo-log-1"><a href="#redo-log-1" class="headerlink" title="redo log"></a>redo log</h3><p><strong>作用：</strong></p>
<p>确保事务的持久性。防止在发生故障的时间点，尚有脏页未写入磁盘，在重启mysql服务的时候，根据redo log进行重做，从而达到事务的持久性这一特性。</p>
<p>redo log通常是物理日志，记录的是数据页的物理修改，而不是某一行或某几行修改成怎样，它用来恢复提交后的物理数据页（恢复数据页，且只能恢复到最后一次提交的位置）。</p>
<h3 id="undo-log-1"><a href="#undo-log-1" class="headerlink" title="undo log"></a>undo log</h3><p><strong>作用：</strong></p>
<p>保存了事务发生之前的数据的一个版本，可以用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读。</p>
<p>undo用来回滚行记录到某个版本。undo log一般是逻辑日志，根据每行记录进行记录。</p>
<h3 id="binlog-监听binary-log"><a href="#binlog-监听binary-log" class="headerlink" title="binlog   监听binary log"></a>binlog   监听binary log</h3><p><strong>作用：</strong></p>
<p>用于复制，在主从复制中，从库利用主库上的binlog进行重播，实现主从同步。<br>用于数据库的基于时间点的还原。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u012834750/article/details/79533866">https://blog.csdn.net/u012834750/article/details/79533866</a></p>
<p>数据库数据存放的文件称为data file；日志文件称为log file；数据库数据是有缓存的，如果没有缓存，每次都写或者读物理disk，那性能就太低下了。数据库数据的缓存称为data buffer，日志（redo）缓存称为log buffer；既然数据库数据有缓存，就很难保证缓存数据（脏数据）与磁盘数据的一致性。比如某次数据库操作：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> T <span class="keyword">set</span> age<span class="operator">=</span><span class="number">20</span> <span class="keyword">where</span> ID<span class="operator">=</span><span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>更新age字段的数据会存放在缓存中，等待存储引擎将age刷新data_file，并返回给业务方更新成功。如果此时数据库宕机，缓存中的数据就丢失了，业务方却以为更新成功了，数据不一致，也没有持久化存储。</p>
<p>上面的问题就可以通过事务的ACID特性来保证。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> T <span class="keyword">set</span> age<span class="operator">=</span><span class="number">20</span> <span class="keyword">where</span> ID<span class="operator">=</span><span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>

<p>这样执行后，更新要么成功，要么失败。业务方的返回和数据库data file中的数据保持一致。要保证这样的特性得靠innodb的redo和undo日志。</p>
<p>redo日志、undo日志：</p>
<p>存储引擎也会为redo undo日志开辟内存缓存空间，log buffer。磁盘上的日志文件称为log file，是顺序追加的，性能非常高，注：磁盘的顺序写性能比内存的写性能差不了多少。</p>
<p>undo日志用于记录事务开始前的状态，用于事务失败时的回滚操作；redo日志记录事务执行后的状态，用来恢复未写入data file的已成功事务更新的数据。例如某一事务的事务序号为T1，其对数据X进行修改，设X的原值是5，修改后的值为15，那么Undo日志为&lt;T1, X, 5&gt;，Redo日志为&lt;T1, X, 15&gt;。</p>
<p>事务执行的各个阶段：</p>
<p>（1）写undo日志到log buffer；</p>
<p>（2）执行事务，并写redo日志到log buffer；</p>
<p>（3）如果innodb_flush_log_at_trx_commit&#x3D;1，则将redo日志写到log file，并刷新磁盘。</p>
<p>（4）提交事务。</p>
<p>为什么没有写data file，事务就提交了？</p>
<p>在数据库的世界里，数据从来都不重要，日志才是最重要的，有了日志就有了一切。</p>
<p>因为data buffer中的数据会在合适的时间由存储引擎写入到data file，如果在写入之前，数据库宕机了，根据磁盘的redo日志，完全可以将事务更改的数据恢复。先持久化日志的策略叫做Write Ahead Log，即预写日志。</p>
<p>分析几种异常情况：</p>
<ul>
<li>innodb_flush_log_at_trx_commit&#x3D;2（<a href="http://link.zhihu.com/?target=https://mp.weixin.qq.com/s?__biz=MzU4NjQwNTE5Ng==&mid=2247483681&idx=1&sn=03adfb89521568013f6a1efd9ca1af6a&scene=21%23wechat_redirect">innodb_flush_log_at_trx_commit和sync_binlog参数详解</a>）时，将redo日志写入logfile后，为提升事务执行的性能，存储引擎并没有调用文件系统的sync操作，将日志落盘。如果此时宕机了，那么未落盘redo日志事务的数据是无法保证一致性的。</li>
<li>undo日志同样存在未落盘的情况，可能出现无法回滚的情况。</li>
</ul>
<p>checkpoint：</p>
<p>checkpoint是为了定期将db buffer的内容刷新到data file。当遇到内存不足、db buffer已满等情况时，需要将db buffer中的内容&#x2F;部分内容（特别是脏数据）转储到data file中。在转储时，会记录checkpoint发生的”时刻“。在故障恢复的时候，只需要redo&#x2F;undo最近的一次checkpoint之后的操作。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/bluejoe2000/article/details/80349499">https://blog.csdn.net/bluejoe2000/article/details/80349499</a></p>
<h2 id="一条SQL执行很慢的原因有哪些"><a href="#一条SQL执行很慢的原因有哪些" class="headerlink" title="一条SQL执行很慢的原因有哪些?"></a>一条SQL执行很慢的原因有哪些?</h2><p>分两类讨论</p>
<h3 id="大多数情况正常-只是偶尔出现很慢的情况"><a href="#大多数情况正常-只是偶尔出现很慢的情况" class="headerlink" title="大多数情况正常,只是偶尔出现很慢的情况"></a>大多数情况正常,只是偶尔出现很慢的情况</h3><ol>
<li>数据库在刷脏页</li>
</ol>
<p>刷脏页有4种情况:</p>
<ul>
<li>redolog写满了。</li>
<li>内存不够用了：如果一次查询较多的数据，恰好碰到所查的数据页不在内存中，需要申请内存，而此时恰好内存不足的时候就需要淘汰一部分内存数据页，如果是干净页，就直接释放，如果恰好是脏页就需要刷脏页。</li>
<li>mysql认为系统空闲的时候。</li>
<li>mysql正常关闭的时候。</li>
</ul>
<ol start="2">
<li>拿不到锁</li>
</ol>
<p>刚好这条语句涉及到的表，别人在用，并且加锁了，我们拿不到锁，只能慢慢等待别人释放锁了。或者，表没有加锁，但要使用到的某个一行被加锁了，这个时候，也是没有办法的。</p>
<p>可以用 <strong>show processlist</strong>这个命令来查看当前的状态。</p>
<p>这里可以看出update在等待锁。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202262256669.png" alt="image-20220226225645544"></p>
<h3 id="针对一直这么慢的情况"><a href="#针对一直这么慢的情况" class="headerlink" title="针对一直这么慢的情况"></a>针对一直这么慢的情况</h3><p>没用到索引</p>
<p>1.字段没有索引</p>
<p>2.字段有索引,但没有用上</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> c <span class="operator">-</span> <span class="number">1</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> pow(c,<span class="number">2</span>) <span class="operator">=</span> <span class="number">1000</span>;</span><br></pre></td></tr></table></figure>

<p>3.数据库算错了索引</p>
<p>通过采样统计，由于统计的失误，导致系统没有走索引，而是走了全表扫描，这也是导致我们 SQL 语句执行的很慢的原因。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="number">100</span> <span class="operator">&lt;</span> c <span class="keyword">and</span> c <span class="operator">&lt;</span> <span class="number">100000</span>;</span><br></pre></td></tr></table></figure>

<h2 id="Chaos"><a href="#Chaos" class="headerlink" title="Chaos"></a>Chaos</h2><ol>
<li>SQL 查询语句：<code>SELECT * FROM A JOIN B ON A.id = B.id</code>，执行过程性能差，原因可能是什么？</li>
<li>上述 SQL 语句的执行过程是什么？哪里需要建立索引？</li>
<li>在 A.id 还是 B.id 上建立索引呢？</li>
</ol>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202262325790.jpg" alt="aerith_2-wallpaper-7680x4320"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272046164.jpg" alt="beautiful_landscapes_in_the_world-wallpaper-5120x2880"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272046348.jpg" alt="princess_8-wallpaper-3840x2160"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272046012.jpg" alt="full_moon_reflection-wallpaper-1920x1080"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272046990.jpg" alt="amazing_mountain_milky_way_by_yakub_nihat-wallpaper-2560x1440"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272047300.jpg" alt="best_beaches_in_the_world-wallpaper-2880x1620"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272047554.jpg" alt="very_nice_satellite_images_of_iran-wallpaper-2880x1620"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272113875.JPG" alt="IMG_3460"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">MingwHuang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://mingwzi.cn/2022/02/15/%E9%9D%A2%E8%AF%95/MySQL/">http://mingwzi.cn/2022/02/15/%E9%9D%A2%E8%AF%95/MySQL/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://mingwzi.cn" target="_blank">MingwHuang's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/MySQL/">MySQL</a></div><div class="post_share"><div class="social-share" data-image="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272046990.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202172251674.png" target="_blank"><img class="post-qr-code-img" src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202172251674.png" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202172251973.png" target="_blank"><img class="post-qr-code-img" src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202172251973.png" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/02/20/Mac-%E6%B7%B1%E5%BA%A6%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"><img class="prev-cover" src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272046164.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Mac 深度使用技巧</div></div></a></div><div class="next-post pull-right"><a href="/2022/01/14/Chaos/%E6%90%AD%E5%BB%BA%E6%A2%AF%E5%AD%90/"><img class="next-cover" src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272046990.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">搭建梯子</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272113875.JPG" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">MingwHuang</div><div class="author-info__description">朝花夕拾 聊以记之</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">41</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">40</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">16</div></a></div></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/HuangMingwang" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:1125385880@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站域名：http://mingwzi.cn</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#MySQL"><span class="toc-number">1.</span> <span class="toc-text">MySQL</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#DML%E3%80%81DDL%E3%80%81DCL%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8A%E5%AE%9A%E4%B9%89"><span class="toc-number">1.1.</span> <span class="toc-text">DML、DDL、DCL区别以及定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TRUNCATE%E3%80%81DELETE%E5%92%8CDROP%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.2.</span> <span class="toc-text">TRUNCATE、DELETE和DROP的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%A4%E5%8F%89%E8%BF%9E%E6%8E%A5%E3%80%81%E5%86%85%E8%BF%9E%E6%8E%A5%E3%80%81%E5%A4%96%E8%BF%9E%E6%8E%A5%E3%80%81%E8%81%94%E5%90%88%E8%BF%9E%E6%8E%A5%E5%92%8C%E8%87%AA%E7%84%B6%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.3.</span> <span class="toc-text">交叉连接、内连接、外连接、联合连接和自然连接</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E5%8F%89%E8%BF%9E%E6%8E%A5%EF%BC%88CROSS-JOIN%EF%BC%89"><span class="toc-number">1.3.1.</span> <span class="toc-text">交叉连接（CROSS JOIN）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E8%BF%9E%E6%8E%A5%EF%BC%88INNER-JOIN%EF%BC%89"><span class="toc-number">1.3.2.</span> <span class="toc-text">内连接（INNER JOIN）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%96%E8%BF%9E%E6%8E%A5%EF%BC%88OUTER-JOIN%EF%BC%89"><span class="toc-number">1.3.3.</span> <span class="toc-text">外连接（OUTER JOIN）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%94%E5%90%88%E8%BF%9E%E6%8E%A5%EF%BC%88UNION-JOIN%EF%BC%89"><span class="toc-number">1.3.4.</span> <span class="toc-text">联合连接（UNION JOIN）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E7%84%B6%E8%BF%9E%E6%8E%A5%EF%BC%88NATURAL-INNER-JOIN%EF%BC%89"><span class="toc-number">1.3.5.</span> <span class="toc-text">自然连接（NATURAL INNER JOIN）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%96%E9%94%AE%E7%BA%A6%E6%9D%9F"><span class="toc-number">1.4.</span> <span class="toc-text">外键约束</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F"><span class="toc-number">1.5.</span> <span class="toc-text">三大范式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E8%8C%83%E5%BC%8F%EF%BC%88%E5%88%97%E4%B8%8D%E5%8F%AF%E5%88%86%EF%BC%89"><span class="toc-number">1.5.1.</span> <span class="toc-text">第一范式（列不可分）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E8%8C%83%E5%BC%8F%EF%BC%88%E5%B1%9E%E6%80%A7%E5%AE%8C%E5%85%A8%E4%BE%9D%E8%B5%96%E4%BA%8E%E4%B8%BB%E9%94%AE%EF%BC%89"><span class="toc-number">1.5.2.</span> <span class="toc-text">第二范式（属性完全依赖于主键）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E8%8C%83%E5%BC%8F%EF%BC%88%E5%B1%9E%E6%80%A7%E4%B8%8D%E8%83%BD%E4%BC%A0%E9%80%92%E4%BE%9D%E8%B5%96%E4%BA%8E%E4%B8%BB%E9%94%AE%EF%BC%89"><span class="toc-number">1.5.3.</span> <span class="toc-text">第三范式（属性不能传递依赖于主键）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BCNF%E8%8C%83%E5%BC%8F"><span class="toc-number">1.5.4.</span> <span class="toc-text">BCNF范式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7%EF%BC%88ACID%EF%BC%89"><span class="toc-number">1.6.</span> <span class="toc-text">事务四大特性（ACID）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">1.6.1.</span> <span class="toc-text">事务的理解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E4%BA%8B%E5%8A%A1%EF%BC%9F"><span class="toc-number">1.6.1.1.</span> <span class="toc-text">数据库为什么要有事务？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ACID"><span class="toc-number">1.6.2.</span> <span class="toc-text">ACID</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">一致性的理解</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">1.7.</span> <span class="toc-text">隔离级别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.7.1.</span> <span class="toc-text">并发出现的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-%E5%88%B6%E5%AE%9A%E6%A0%87%E5%87%86"><span class="toc-number">1.7.2.</span> <span class="toc-text">解决方案(制定标准)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-Innodb"><span class="toc-number">1.7.3.</span> <span class="toc-text">实现(Innodb)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MyISAM%E5%92%8CInnoDB"><span class="toc-number">1.8.</span> <span class="toc-text">MyISAM和InnoDB</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MyISAM"><span class="toc-number">1.8.1.</span> <span class="toc-text">MyISAM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InnoDB"><span class="toc-number">1.8.2.</span> <span class="toc-text">InnoDB</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MVCC"><span class="toc-number">1.8.3.</span> <span class="toc-text">MVCC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InnoDB-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%B8%AD%E8%A1%8C%E9%94%81%E7%9A%84%E4%B8%89%E7%A7%8D%E7%AE%97%E6%B3%95"><span class="toc-number">1.8.4.</span> <span class="toc-text">InnoDB 存储引擎中行锁的三种算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%B0%E5%BD%95%E9%94%81%EF%BC%88Record-lock%EF%BC%89"><span class="toc-number">1.8.4.1.</span> <span class="toc-text">记录锁（Record lock）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%A4%E6%9D%A1%E4%B8%8D%E5%90%8C%E8%AE%B0%E5%BD%95%E6%8B%A5%E6%9C%89%E7%9B%B8%E5%90%8C%E7%9A%84%E7%B4%A2%E5%BC%95%EF%BC%8C%E4%BC%9A%E5%8F%91%E7%94%9F%E9%94%81%E5%86%B2%E7%AA%81%E5%90%97%EF%BC%9F"><span class="toc-number">1.8.4.1.1.</span> <span class="toc-text">两条不同记录拥有相同的索引，会发生锁冲突吗？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%B4%E9%9A%99%E9%94%81%EF%BC%88Gap-Lock%EF%BC%89"><span class="toc-number">1.8.4.2.</span> <span class="toc-text">间隙锁（Gap Lock）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%B4%E9%94%AE%E9%94%81%EF%BC%88Next-key-lock%EF%BC%89"><span class="toc-number">1.8.4.3.</span> <span class="toc-text">临键锁（Next-key lock）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.8.4.4.</span> <span class="toc-text">示例</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A1%8C%E9%94%81%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.8.4.4.1.</span> <span class="toc-text">行锁示例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A1%8C%E9%94%81%E9%80%80%E5%8C%96%E4%B8%BA%E8%A1%A8%E9%94%81%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.8.4.4.2.</span> <span class="toc-text">行锁退化为表锁示例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%A4%E6%9D%A1%E4%B8%8D%E5%90%8C%E8%AE%B0%E5%BD%95%E6%8B%A5%E6%9C%89%E7%9B%B8%E5%90%8C%E7%9A%84%E7%B4%A2%E5%BC%95%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.8.4.4.3.</span> <span class="toc-text">两条不同记录拥有相同的索引示例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%B4%E9%94%AE%E9%94%81%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.8.4.4.4.</span> <span class="toc-text">临键锁示例</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98"><span class="toc-number">1.9.</span> <span class="toc-text">查询缓存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95"><span class="toc-number">1.10.</span> <span class="toc-text">索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%AF%B9%E8%A1%A8%E4%B8%AD%E7%9A%84%E6%AF%8F%E4%B8%80%E4%B8%AA%E5%88%97%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%B4%A2%E5%BC%95"><span class="toc-number">1.10.1.</span> <span class="toc-text">为什么不对表中的每一个列创建一个索引?</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95"><span class="toc-number">1.10.1.1.</span> <span class="toc-text">聚簇索引</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.10.2.</span> <span class="toc-text">使用索引的注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95"><span class="toc-number">1.10.3.</span> <span class="toc-text">哈希索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-%E6%A0%91%E7%B4%A2%E5%BC%95"><span class="toc-number">1.10.4.</span> <span class="toc-text">B+树索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86%E4%B8%8E%E7%A3%81%E7%9B%98%E9%A2%84%E8%AF%BB"><span class="toc-number">1.10.5.</span> <span class="toc-text">局部性原理与磁盘预读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9C%A8%E7%A3%81%E7%9B%98%E4%B8%AD%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%EF%BC%9F"><span class="toc-number">1.10.6.</span> <span class="toc-text">数据库在磁盘中如何存储？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mysql%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8b-%E6%A0%91%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AFb%E6%A0%91%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%81AVL%E6%A0%91%E6%88%96%E7%BA%A2%E9%BB%91%E6%A0%91%EF%BC%9F"><span class="toc-number">1.10.7.</span> <span class="toc-text">Mysql为什么使用b+树，而不是b树、二叉树、AVL树或红黑树？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#B%E6%A0%91%E5%92%8CB-%E6%A0%91"><span class="toc-number">1.10.7.1.</span> <span class="toc-text">B树和B+树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%94%B9%E8%BF%9B%E7%82%B9%E4%B8%80%EF%BC%9A"><span class="toc-number">1.10.7.1.1.</span> <span class="toc-text">改进点一：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%94%B9%E8%BF%9B%E7%82%B9%E4%BA%8C%EF%BC%9A"><span class="toc-number">1.10.7.1.2.</span> <span class="toc-text">改进点二：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%B8%B8%E7%94%A8%E5%93%88%E5%B8%8C%E8%A1%A8%E5%92%8C%E6%95%B0%E7%BB%84%E4%BD%9C%E4%B8%BA%E7%B4%A2%E5%BC%95"><span class="toc-number">1.10.8.</span> <span class="toc-text">为什么不常用哈希表和数组作为索引?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95"><span class="toc-number">1.10.9.</span> <span class="toc-text">覆盖索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E5%8E%9F%E5%88%99"><span class="toc-number">1.10.10.</span> <span class="toc-text">最左前缀原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E9%81%BF%E5%85%8D%E7%B4%A2%E5%BC%95%E5%86%97%E4%BD%99"><span class="toc-number">1.10.11.</span> <span class="toc-text">注意避免索引冗余</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E7%B4%A2%E5%BC%95"><span class="toc-number">1.10.12.</span> <span class="toc-text">添加索引</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E5%90%8E%EF%BC%8Cid%E4%B8%BB%E9%94%AE%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%EF%BC%9F"><span class="toc-number">1.11.</span> <span class="toc-text">分库分表后，id主键如何处理？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E5%94%AF%E4%B8%80%E8%AF%86%E5%88%AB%E7%A0%81%EF%BC%88Universally-Unique-Identifier%EF%BC%8CUUID%EF%BC%89"><span class="toc-number">1.11.1.</span> <span class="toc-text">通用唯一识别码（Universally Unique Identifier，UUID）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%97%A0%E5%BA%8F%E7%9A%84UUID%E4%BC%9A%E5%AF%BC%E8%87%B4%E5%85%A5%E5%BA%93%E6%80%A7%E8%83%BD%E5%8F%98%E5%B7%AE%E5%91%A2%EF%BC%9F"><span class="toc-number">1.11.1.1.</span> <span class="toc-text">为什么无序的UUID会导致入库性能变差呢？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%94%9F%E6%88%90"><span class="toc-number">1.11.2.</span> <span class="toc-text">数据库生成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8-redis-%E7%94%9F%E6%88%90-id"><span class="toc-number">1.11.3.</span> <span class="toc-text">利用 redis 生成 id</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Twitter%E7%9A%84snowflake%E7%AE%97%E6%B3%95"><span class="toc-number">1.11.4.</span> <span class="toc-text">Twitter的snowflake算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BE%8E%E5%9B%A2%E7%9A%84Leaf%E5%88%86%E5%B8%83%E5%BC%8FID%E7%94%9F%E6%88%90%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.11.5.</span> <span class="toc-text">美团的Leaf分布式ID生成系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Leaf-segment%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%B9%E6%A1%88"><span class="toc-number">1.11.5.1.</span> <span class="toc-text">Leaf-segment数据库方案</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%8Cbuffer%E4%BC%98%E5%8C%96"><span class="toc-number">1.11.5.1.1.</span> <span class="toc-text">双buffer优化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Leaf%E9%AB%98%E5%8F%AF%E7%94%A8%E5%AE%B9%E7%81%BE"><span class="toc-number">1.11.5.1.2.</span> <span class="toc-text">Leaf高可用容灾</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Leaf-snowflake%E6%96%B9%E6%A1%88"><span class="toc-number">1.11.5.2.</span> <span class="toc-text">Leaf-snowflake方案</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%B1%E4%BE%9D%E8%B5%96ZooKeeper"><span class="toc-number">1.11.5.2.1.</span> <span class="toc-text">弱依赖ZooKeeper</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%97%B6%E9%92%9F%E9%97%AE%E9%A2%98"><span class="toc-number">1.11.5.2.2.</span> <span class="toc-text">解决时钟问题</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Leaf%E7%8E%B0%E7%8A%B6"><span class="toc-number">1.11.5.3.</span> <span class="toc-text">Leaf现状</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E6%9D%A1SQL%E8%AF%AD%E5%8F%A5%E5%9C%A8MySQL%E4%B8%AD%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84"><span class="toc-number">1.12.</span> <span class="toc-text">一条SQL语句在MySQL中如何执行的</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E6%9D%A1%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E7%9A%84%E9%A1%BA%E5%BA%8F"><span class="toc-number">1.12.1.</span> <span class="toc-text">一条更新语句执行的顺序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Undo-log%E3%80%81-Redo-log%E3%80%81Binary-log"><span class="toc-number">1.13.</span> <span class="toc-text">Undo log、 Redo log、Binary log</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#undo-log%E5%92%8Credo-log"><span class="toc-number">1.13.1.</span> <span class="toc-text">undo log和redo log</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#undo-log"><span class="toc-number">1.13.1.1.</span> <span class="toc-text">undo log</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redo-log"><span class="toc-number">1.13.1.2.</span> <span class="toc-text">redo log</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.13.1.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redo-log%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97"><span class="toc-number">1.13.2.</span> <span class="toc-text">redo log日志模块</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#redo-log%E6%9C%BA%E5%88%B6%EF%BC%9A"><span class="toc-number">1.13.2.1.</span> <span class="toc-text">redo log机制：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#binlog%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97"><span class="toc-number">1.13.3.</span> <span class="toc-text">binlog日志模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redo-log%E5%92%8Cbinlog%E5%8C%BA%E5%88%AB"><span class="toc-number">1.13.4.</span> <span class="toc-text">redo log和binlog区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redo-log-1"><span class="toc-number">1.13.5.</span> <span class="toc-text">redo log</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undo-log-1"><span class="toc-number">1.13.6.</span> <span class="toc-text">undo log</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#binlog-%E7%9B%91%E5%90%ACbinary-log"><span class="toc-number">1.13.7.</span> <span class="toc-text">binlog   监听binary log</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E6%9D%A1SQL%E6%89%A7%E8%A1%8C%E5%BE%88%E6%85%A2%E7%9A%84%E5%8E%9F%E5%9B%A0%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">1.14.</span> <span class="toc-text">一条SQL执行很慢的原因有哪些?</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A7%E5%A4%9A%E6%95%B0%E6%83%85%E5%86%B5%E6%AD%A3%E5%B8%B8-%E5%8F%AA%E6%98%AF%E5%81%B6%E5%B0%94%E5%87%BA%E7%8E%B0%E5%BE%88%E6%85%A2%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">1.14.1.</span> <span class="toc-text">大多数情况正常,只是偶尔出现很慢的情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%92%88%E5%AF%B9%E4%B8%80%E7%9B%B4%E8%BF%99%E4%B9%88%E6%85%A2%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">1.14.2.</span> <span class="toc-text">针对一直这么慢的情况</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chaos"><span class="toc-number">1.15.</span> <span class="toc-text">Chaos</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/03/01/%E9%9D%A2%E8%AF%95/Linux/" title="Linux"><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272047300.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux"/></a><div class="content"><a class="title" href="/2022/03/01/%E9%9D%A2%E8%AF%95/Linux/" title="Linux">Linux</a><time datetime="2022-03-01T15:08:28.000Z" title="发表于 2022-03-01 23:08:28">2022-03-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/01/%E9%9D%A2%E8%AF%95/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="设计模式"><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272046990.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="设计模式"/></a><div class="content"><a class="title" href="/2022/03/01/%E9%9D%A2%E8%AF%95/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="设计模式">设计模式</a><time datetime="2022-03-01T15:03:15.000Z" title="发表于 2022-03-01 23:03:15">2022-03-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/02/26/%E9%9D%A2%E8%AF%95/Redis/" title="Redis"><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272046012.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis"/></a><div class="content"><a class="title" href="/2022/02/26/%E9%9D%A2%E8%AF%95/Redis/" title="Redis">Redis</a><time datetime="2022-02-26T06:21:50.000Z" title="发表于 2022-02-26 14:21:50">2022-02-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/02/25/K8S/" title="K8S"><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272046348.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="K8S"/></a><div class="content"><a class="title" href="/2022/02/25/K8S/" title="K8S">K8S</a><time datetime="2022-02-25T14:38:23.000Z" title="发表于 2022-02-25 22:38:23">2022-02-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/02/25/Chaos/Chaos/" title="Chaos"><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272046164.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Chaos"/></a><div class="content"><a class="title" href="/2022/02/25/Chaos/Chaos/" title="Chaos">Chaos</a><time datetime="2022-02-25T14:38:23.000Z" title="发表于 2022-02-25 22:38:23">2022-02-25</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By MingwHuang</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a><span class="footer-separator">|</span><a href="https://beian.miit.gov.cn/" target="_blank">赣ICP备2022001353号-1</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>