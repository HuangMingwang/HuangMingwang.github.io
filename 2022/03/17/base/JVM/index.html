<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>JVM | MingwHuang's Blog</title><meta name="keywords" content="JVM"><meta name="author" content="MingwHuang"><meta name="copyright" content="MingwHuang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="[TOC] JVM 运行时数据区域      堆 JDK 7 新生代、老年代和永久代；jdk8 永久代被移除，用元空间代替，元空间使用的是直接内存； 对象初始年龄为1，到了15会去老年代；  OutOfMemoryError: GC Overhead Limit Exceeded：当JVM花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误； java.lang.OutOfMemory">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM">
<meta property="og:url" content="http://mingwzi.cn/2022/03/17/base/JVM/index.html">
<meta property="og:site_name" content="MingwHuang&#39;s Blog">
<meta property="og:description" content="[TOC] JVM 运行时数据区域      堆 JDK 7 新生代、老年代和永久代；jdk8 永久代被移除，用元空间代替，元空间使用的是直接内存； 对象初始年龄为1，到了15会去老年代；  OutOfMemoryError: GC Overhead Limit Exceeded：当JVM花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误； java.lang.OutOfMemory">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272046990.jpg">
<meta property="article:published_time" content="2022-03-17T10:46:58.000Z">
<meta property="article:modified_time" content="2022-03-17T10:46:58.000Z">
<meta property="article:author" content="MingwHuang">
<meta property="article:tag" content="JVM">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272046990.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://mingwzi.cn/2022/03/17/base/JVM/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":500},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JVM',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-03-17 18:46:58'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272113875.JPG" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">45</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">42</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272046990.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">MingwHuang's Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">JVM</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-03-17T10:46:58.000Z" title="发表于 2022-03-17 18:46:58">2022-03-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-03-17T10:46:58.000Z" title="更新于 2022-03-17 18:46:58">2022-03-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/base/">base</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="JVM"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>[TOC]</p>
<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848716.png" alt="image-20210508171931448"></p>
<h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848702.png" alt="JVM运行时数据区域" style="zoom:80%;" />

<img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848700.png" alt="Java运行时数据区域JDK1.8" style="zoom:80%;" />



<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><ul>
<li>JDK 7 新生代、老年代和永久代；jdk8 永久代被移除，用元空间代替，元空间使用的是直接内存；</li>
<li>对象初始年龄为1，到了15会去老年代；</li>
</ul>
<p>OutOfMemoryError: GC Overhead Limit Exceeded：当JVM花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误；</p>
<p>java.lang.OutOfMemoryError: Java heap space：假如在创建新的对象时，堆内存中的空间不足以存放新创建的对象，就会引发java.lang.OutOfMemoryError： Java heap space 错误。(和本机物理内存无关，和你配置的内存大小有关！)</p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><ul>
<li>为永久代；线程共享；</li>
<li>存储已被虚拟机加载的类信息、常量、静态变量（即时编译器编译后的代码等数据）；</li>
<li>方法区和永久代的关系很像 Java 中接口和类的关系，类实现了接口，而永久代就是 HotSpot 虚拟机对虚拟机规范中方法区的一种实现方式；</li>
</ul>
<h4 id="为什么要将永久代-PermGen-替换为元空间-MetaSpace"><a href="#为什么要将永久代-PermGen-替换为元空间-MetaSpace" class="headerlink" title="为什么要将永久代(PermGen)替换为元空间(MetaSpace)?"></a>为什么要将永久代(PermGen)替换为元空间(MetaSpace)?</h4><ul>
<li>整个永久代有一个 JVM 本身设置固定大小上限，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小；java.lang.OutOfMemoryError: MetaSpace； </li>
<li>元空间里面存放的是类的元数据，这样加载多少类的元数据就不由 MaxPermSize 控制了，而由系统的实际可用空间来控制，这样能加载的类就更多了；在 JDK8，合并 HotSpot 和 JRockit 的代码时，JRockit 从来没有一个叫永久代的东西，合并之后就没有必要额外的设置这么一个永久代的地方了。</li>
</ul>
<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><ul>
<li>运行时常量池是方法区的一部分；</li>
<li>JDK1.7之前运行时常量池逻辑包含字符串常量池存放在方法区，此时hotspot虚拟机对方法区的实现为永久代；</li>
<li>JDK1.7 字符串常量池被从方法区拿到了堆中，这里没有提到运行时常量池，也就是说字符串常量池被单独拿到堆，运行时常量池剩下的东西还在方法区， 也就是hotspot中的永久代 <strong>; JDK1.8 hotspot移除了永久代用元空间(Metaspace)取而代之， 这时候字符串常量池还在堆， 运行时常量池还在方法区， 只不过方法区的实现从永久代变成了元空间(Metaspace);</strong></li>
</ul>
<h4 id="JVM-常量池中存储的是对象还是引用呢？"><a href="#JVM-常量池中存储的是对象还是引用呢？" class="headerlink" title="JVM 常量池中存储的是对象还是引用呢？"></a>JVM 常量池中存储的是对象还是引用呢？</h4><p>如果是runtime constant pool（而不是interned string pool &#x2F; StringTable之类的其他东西）的话，其中的引用类型常量（例如CONSTANT_String、CONSTANT_Class、CONSTANT_MethodHandle、CONSTANT_MethodType之类）都存的是引用，实际的对象还是存在Java heap上的。</p>
<h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><p>类加载检查: 虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p>
<p>分配内存: 指针碰撞:内存规整的情况下，GC收集器Serial，Parnew;空闲列表:堆内存不规整的情况下，CMS; 多线程下用CAS+失败重试;TLAB，为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配;</p>
<p>初始化零值:内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p>
<p>设置对象头:初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p>
<p>执行init方法: 在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<init>方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <init> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p>
<h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><p>句柄和直接指针;使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销;</p>
<h2 id="JVM常用调优指令和参数"><a href="#JVM常用调优指令和参数" class="headerlink" title="JVM常用调优指令和参数"></a>JVM常用调优指令和参数</h2><h3 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h3><p>查询正在运行的JVM进程；</p>
<h3 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h3><p>可以实时显示本地或远程JVM进程中类装载、内存、垃圾收集、JIT编译等数据；</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-class             // 显示类加载信息</span><br><span class="line">-compiler          // 显示编译信息</span><br><span class="line">-gc                // 显示GC相关信息</span><br><span class="line">-gccapacity        // 显示各区域容量及使用情况</span><br><span class="line">-gccause           // 显示垃圾回收信息</span><br><span class="line">-gcmetacapacity    // 显示元空间容量信息</span><br><span class="line">-gcnew             // 显示新生代信息</span><br><span class="line">-gcnewcapacity     // 显示新生代容量信息</span><br><span class="line">-gcold             // 显示老年代信息</span><br><span class="line">-gcoldcapacity     // 显示老年代容量信息</span><br><span class="line">-gcutil            // 显示垃圾收集信息</span><br><span class="line">-printcompilation  // 显示JIT编译的方法信息</span><br><span class="line"></span><br><span class="line">jstat -gcutil 20272 2s 3</span><br><span class="line"></span><br><span class="line">jstat -gc 20272 2s 3</span><br></pre></td></tr></table></figure>



<p>S0C：第一个幸存者区（Survivor Space）容量</p>
<p>S1C：第二个幸存者区（Survivor Space）容量</p>
<p>S0U：第二个幸存者区使用量</p>
<p>S1U：第二个幸存者区使用量</p>
<p>EC：伊甸园去容量</p>
<p>EU：伊甸园区使用量</p>
<p>OC：Old Generation区容量</p>
<p>OU：Old Generation使用量</p>
<p>MC：Mataspace区容量</p>
<p>MU：Mataspace区实际使用量</p>
<p>CCSC：压缩类空间大小（不是很懂，先标记一下）</p>
<p>CCSU：压缩类空间使用率（不是很懂，先标记一下）</p>
<p>YGC：年轻代垃圾回收次数</p>
<p>YGCT：年轻代垃圾回收时间</p>
<p>FGC：年老代垃圾回收次数</p>
<p>FGCT：年老代垃圾回收时间</p>
<p>GCT：总垃圾回收时间</p>
<p>S0：S0C区域使用率</p>
<p>S0：S1C区域使用率</p>
<p>E：伊甸园去使用率</p>
<p>O：Old Generation使用率，OU&#x2F;OC</p>
<p>M：Matespace区使用率，MU&#x2F;MC</p>
<p>CCS：压缩类空间使用率</p>
<h3 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h3><p>用于查询当前运行这的JVM属性和参数的值；</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jinfo 4777</span><br></pre></td></tr></table></figure>

<h3 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h3><p>显示当前Java堆和永久代的详细信息；</p>
<p>命令jmap是一个多功能的命令。它可以生成 java 程序的 dump 文件，生成dump的命令为：jmap -dump:live，format&#x3D;b，file&#x3D;文文件名(hprof后缀) &lt;PID&gt; 也可以查看堆内对象示例的统计信息、查看 ClassLoader 的信息以及 finalizer 队列。 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">查看某一实例jvm配置</span></span><br><span class="line">jmap  -heap 29544</span><br><span class="line"> </span><br></pre></td></tr></table></figure>



<h3 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h3><p>用于生成当前JVM的所有线程快照，线程快照是虚拟机每一条线程正在执行的方法，目的是定位线程出现长时间停顿的原因。</p>
<h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><p>通过top -Hp 23344可以查看该进程下各个线程的cpu使用情况；具体实操经验见：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/wuchanming/p/7766994.html">https://www.cnblogs.com/wuchanming/p/7766994.html</a></p>
<h3 id="pidstat"><a href="#pidstat" class="headerlink" title="pidstat"></a>pidstat</h3><p>实时查看一个进程的CPU使用情况及上下文切换情况</p>
<h3 id="vmstat"><a href="#vmstat" class="headerlink" title="vmstat"></a>vmstat</h3><p>查看总体的CPU使用情况 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">參数2表示每一个2秒显示一下结果，3表示显示结果的数目。</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">cs列表示每秒上下文切换次数，us表示用户CPU时间。</span></span><br><span class="line">sudo vmstat 2 3</span><br></pre></td></tr></table></figure>



<h3 id="JVM常见的调优参数"><a href="#JVM常见的调优参数" class="headerlink" title="JVM常见的调优参数"></a>JVM常见的调优参数</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定java程序的最大堆内存， 使用java -Xmx5000M -version判断当前系统能分配的最大堆内存。</span></span><br><span class="line">-Xmx</span><br><span class="line"><span class="comment"># 指定最小堆内存， 通常设置成跟最大堆内存一样，减少GC。</span></span><br><span class="line">-Xms</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置年轻代大小。整个堆大小=年轻代大小 + 年老代大小。所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。</span></span><br><span class="line">-Xmn</span><br><span class="line"><span class="comment"># 指定线程的最大栈空间， 此参数决定了java函数调用的深度， 值越大调用深度越深， 若值太小则容易出栈溢出错误（StackOverflowError）。</span></span><br><span class="line">-Xss</span><br><span class="line"><span class="comment"># 指定方法区(永久区)的初始值，默认是物理内存的1/64， 在Java8永久区移除， 代之的是元数据区， 由-XX:MetaspaceSize指定。</span></span><br><span class="line">-XX:PermSize</span><br><span class="line"><span class="comment"># 指定方法区的最大值， 默认是物理内存的1/4，在java8中由-XX:MaxMetaspaceSize指定元数据区的大小。</span></span><br><span class="line">-XX:MaxPermSize</span><br><span class="line"><span class="comment"># 老年代与年轻代的比值，-XX:NewRatio=2， 表示年老代与年轻代的比值为2:1。</span></span><br><span class="line">-XX:NewRatio=n</span><br><span class="line"></span><br><span class="line"><span class="comment"># Eden区与Survivor区的大小比值，-XX:SurvivorRatio=8表示Eden区与Survivor区的大小比值是8:1:1，因为Survivor区有两个（from， to）</span></span><br><span class="line">-XX:SurvivorRatio=8 </span><br><span class="line"><span class="comment"># 最大堆内存为20m， 最小堆内存为5m， 通常设置为和最大一样，减少GC</span></span><br><span class="line">-Xmx20m -Xms5m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=你要输出的日志路径</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印gc信息</span></span><br><span class="line">-XX:+PrintGCDetails</span><br><span class="line"><span class="comment"># 偏向锁开启时间</span></span><br><span class="line">-XX:BaisedLockingStartupDelay=0</span><br><span class="line"><span class="comment"># 不使用偏向锁</span></span><br><span class="line">-XX:-UseBiasedLocking=<span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 主要是控制新生代需要经历多少次GC晋升到老年代中的最大阈值; Tenuring Threshold[ˈθreʃhəʊld]终身监禁的门槛</span></span><br><span class="line">-XX:MaxTenuringThreshold=15; </span><br><span class="line"><span class="comment"># 设置 Metaspace 的初始（以及最小大小）</span></span><br><span class="line">-XX:MetaspaceSize=N </span><br><span class="line"><span class="comment"># 设置 Metaspace 的最大大小</span></span><br><span class="line">-XX:MaxMetaspaceSize=N </span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认为混合模式 开始解释执行，启动速度较快，对热点代码执行检测和编译</span></span><br><span class="line">-Xmixed </span><br><span class="line"><span class="comment"># 使用解释模式，启动很快，执行稍慢</span></span><br><span class="line">-Xint</span><br><span class="line"><span class="comment"># 使用纯编译编译模式，执行很快，启动很慢</span></span><br><span class="line">-Xcomp</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Jprofiler</p>
<p>分析内存dump文件，快速定位内存泄漏</p>
<h3 id="arthas"><a href="#arthas" class="headerlink" title="arthas"></a>arthas</h3><p>Alibaba开源的Java诊断工具</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -O https://arthas.aliyun.com/arthas-boot.jar</span><br><span class="line">java -jar arthas-boot.jar</span><br></pre></td></tr></table></figure>

<h4 id="help"><a href="#help" class="headerlink" title="help"></a>help</h4><h4 id="dashboard"><a href="#dashboard" class="headerlink" title="dashboard"></a>dashboard</h4><p>命令可以查看当前系统的实时数据面板 输入Q或者 Ctrl+C 可以退出dashboard命令。</p>
<h4 id="thread"><a href="#thread" class="headerlink" title="thread"></a>thread</h4><p><code>thread 1</code> 命令会打印线程ID 1的栈。</p>
<p>Arthas支持管道，可以用 <code>thread 1 | grep &#39;main(&#39;</code> 查找到<code>main class</code>。</p>
<h4 id="sc"><a href="#sc" class="headerlink" title="sc"></a>sc</h4><p>可以通过 <code>sc</code> 命令来查找JVM里已加载的类：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc -d *MathGame</span><br></pre></td></tr></table></figure>

<h4 id="jad"><a href="#jad" class="headerlink" title="jad"></a>jad</h4><p>可以通过 <code>jad</code> 命令来反编译代码：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jad demo.MathGame</span><br></pre></td></tr></table></figure>



<h4 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h4><p>通过<code>watch</code>命令可以查看函数的参数&#x2F;返回值&#x2F;异常信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch demo.MathGame primeFactors returnObj</span><br></pre></td></tr></table></figure>

<p>输入 <code>Q</code> 或者 <code>Ctrl+C</code> 退出watch命令。</p>
<h4 id="vmtool"><a href="#vmtool" class="headerlink" title="vmtool"></a>vmtool</h4><p>通过<code>vmtool</code>命令，可以搜索内存对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vmtool --action getInstances --className java.lang.String --limit 10</span><br></pre></td></tr></table></figure>

<h4 id="查看JVM信息"><a href="#查看JVM信息" class="headerlink" title="查看JVM信息"></a>查看JVM信息</h4><p>下面介绍Arthas里查看<code>JVM</code>信息的命令。</p>
<h5 id="sysprop"><a href="#sysprop" class="headerlink" title="sysprop"></a>sysprop</h5><p><code>sysprop</code> 可以打印所有的System Properties信息。</p>
<p>也可以指定单个key： <code>sysprop java.version</code></p>
<p>也可以通过<code>grep</code>来过滤： <code>sysprop | grep user</code></p>
<p>可以设置新的value： <code>sysprop testKey testValue</code></p>
<h5 id="sysenv"><a href="#sysenv" class="headerlink" title="sysenv"></a>sysenv</h5><p><code>sysenv</code> 命令可以获取到环境变量。和<code>sysprop</code>命令类似。</p>
<h5 id="jvm"><a href="#jvm" class="headerlink" title="jvm"></a>jvm</h5><p><code>jvm</code> 命令会打印出<code>JVM</code>的各种详细信息。</p>
<h4 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h4><p>为了更好使用Arthas，下面先介绍Arthas里的一些使用技巧。</p>
<h4 id="help-1"><a href="#help-1" class="headerlink" title="help"></a>help</h4><p>Arthas里每一个命令都有详细的帮助信息。可以用<code>-h</code>来查看。帮助信息里有<code>EXAMPLES</code>和<code>WIKI</code>链接。</p>
<p>比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysprop -h</span><br></pre></td></tr></table></figure>

<h5 id="自动补全"><a href="#自动补全" class="headerlink" title="自动补全"></a>自动补全</h5><p>Arthas支持丰富的自动补全功能，在使用有疑惑时，可以输入<code>Tab</code>来获取更多信息。</p>
<p>比如输入 <code>sysprop java.</code> 之后，再输入<code>Tab</code>，会补全出对应的key：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sysprop java.</span><br><span class="line">java.runtime.name             java.protocol.handler.pkgs    java.vm.version</span><br><span class="line">java.vm.vendor                java.vendor.url               java.vm.name</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h5 id="readline的快捷键支持"><a href="#readline的快捷键支持" class="headerlink" title="readline的快捷键支持"></a>readline的快捷键支持</h5><p>Arthas支持常见的命令行快捷键，比如<code>Ctrl + A</code>跳转行首，<code>Ctrl + E</code>跳转行尾。</p>
<p>更多的快捷键可以用 <code>keymap</code> 命令查看。</p>
<h5 id="历史命令的补全"><a href="#历史命令的补全" class="headerlink" title="历史命令的补全"></a>历史命令的补全</h5><p>如果想再执行之前的命令，可以在输入一半时，按<code>Up/↑</code> 或者 <code>Ddown/↓</code>，来匹配到之前的命令。</p>
<p>比如之前执行过<code>sysprop java.version</code>，那么在输入<code>sysprop ja</code>之后，可以输入<code>Up/↑</code>，就会自动补全为<code>sysprop java.version</code>。</p>
<p>如果想查看所有的历史命令，也可以通过 <code>history</code> 命令查看到。</p>
<h5 id="pipeline"><a href="#pipeline" class="headerlink" title="pipeline"></a>pipeline</h5><p>Arthas支持在pipeline之后，执行一些简单的命令，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sysprop | grep java</span><br><span class="line">sysprop | wc -l</span><br></pre></td></tr></table></figure>

<h4 id="sc-x2F-sm-查看已加载的类"><a href="#sc-x2F-sm-查看已加载的类" class="headerlink" title="sc&#x2F;sm 查看已加载的类"></a>sc&#x2F;sm 查看已加载的类</h4><p>下面介绍Arthas里查找已加载类的命令。</p>
<h5 id="sc-1"><a href="#sc-1" class="headerlink" title="sc"></a>sc</h5><p><code>sc</code> 命令可以查找到所有JVM已经加载到的类。</p>
<p>如果搜索的是接口，还会搜索所有的实现类。比如查看所有的<code>Filter</code>实现类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc javax.servlet.Filter</span><br></pre></td></tr></table></figure>

<p>通过<code>-d</code>参数，可以打印出类加载的具体信息，很方便查找类加载问题。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc -d javax.servlet.Filter</span><br></pre></td></tr></table></figure>

<p><code>sc</code>支持通配，比如搜索所有的<code>StringUtils</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc *StringUtils</span><br></pre></td></tr></table></figure>

<h5 id="sm"><a href="#sm" class="headerlink" title="sm"></a>sm</h5><p><code>sm</code>命令则是查找类的具体函数。比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sm java.math.RoundingMode</span><br></pre></td></tr></table></figure>

<p>通过<code>-d</code>参数可以打印函数的具体属性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sm -d java.math.RoundingMode</span><br></pre></td></tr></table></figure>

<p>也可以查找特定的函数，比如查找构造函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sm java.math.RoundingMode &lt;init&gt;</span><br></pre></td></tr></table></figure>



<h4 id="Jad"><a href="#Jad" class="headerlink" title="Jad"></a>Jad</h4><p>可以通过 <code>jad</code> 命令来反编译代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jad com.example.demo.arthas.user.UserController</span><br></pre></td></tr></table></figure>

<p>通过<code>--source-only</code>参数可以只打印出在反编译的源代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jad --source-only com.example.demo.arthas.user.UserController</span><br></pre></td></tr></table></figure>





<h4 id="Ognl"><a href="#Ognl" class="headerlink" title="Ognl"></a>Ognl</h4><p>在Arthas里，有一个单独的<code>ognl</code>命令，可以动态执行代码。</p>
<h5 id="调用static函数"><a href="#调用static函数" class="headerlink" title="调用static函数"></a>调用static函数</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ognl &#x27;@java.lang.System@out.println(&quot;hello ognl&quot;)&#x27;</span><br></pre></td></tr></table></figure>

<p>可以检查<code>Terminal 1</code>（不是arthas的Terminal 2）里的进程输出，可以发现打印出了<code>hello ognl</code>。</p>
<h5 id="查找UserController的ClassLoader"><a href="#查找UserController的ClassLoader" class="headerlink" title="查找UserController的ClassLoader"></a>查找UserController的ClassLoader</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sc -d com.example.demo.arthas.user.UserController | grep classLoaderHash</span><br><span class="line">$ sc -d com.example.demo.arthas.user.UserController | grep classLoaderHash</span><br><span class="line"> classLoaderHash   1be6f5c3</span><br></pre></td></tr></table></figure>

<p>注意hashcode是变化的，需要先查看当前的ClassLoader信息，提取对应ClassLoader的hashcode。</p>
<p>如果你使用<code>-c</code>，你需要手动输入hashcode：<code>-c &lt;hashcode&gt;</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ognl -c 1be6f5c3 @com.example.demo.arthas.user.UserController@logger</span><br></pre></td></tr></table></figure>

<p>对于只有唯一实例的ClassLoader可以通过<code>--classLoaderClass</code>指定class name，使用起来更加方便：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader  @org.springframework.boot.SpringApplication@logger</span><br><span class="line">@Slf4jLocationAwareLog[</span><br><span class="line">    FQCN=@String[org.apache.commons.logging.LogAdapter<span class="variable">$Slf4jLocationAwareLog</span>],</span><br><span class="line">    name=@String[org.springframework.boot.SpringApplication],</span><br><span class="line">    logger=@Logger[Logger[org.springframework.boot.SpringApplication]],</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><code>--classLoaderClass</code> 的值是ClassLoader的类名，只有匹配到唯一的ClassLoader实例时才能工作，目的是方便输入通用命令，而<code>-c &lt;hashcode&gt;</code>是动态变化的。</p>
<h5 id="获取静态类的静态字段"><a href="#获取静态类的静态字段" class="headerlink" title="获取静态类的静态字段"></a>获取静态类的静态字段</h5><p>获取<code>UserController</code>类里的<code>logger</code>字段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader @com.example.demo.arthas.user.UserController@logger</span><br></pre></td></tr></table></figure>

<p>还可以通过<code>-x</code>参数控制返回值的展开层数。比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader -x 2 @com.example.demo.arthas.user.UserController@logger</span><br></pre></td></tr></table></figure>

<h5 id="执行多行表达式，赋值给临时变量，返回一个List"><a href="#执行多行表达式，赋值给临时变量，返回一个List" class="headerlink" title="执行多行表达式，赋值给临时变量，返回一个List"></a>执行多行表达式，赋值给临时变量，返回一个List</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ognl &#x27;#value1=@System@getProperty(&quot;java.home&quot;), #value2=@System@getProperty(&quot;java.runtime.name&quot;), &#123;#value1, #value2&#125;&#x27;</span><br><span class="line">$ ognl &#x27;#value1=@System@getProperty(&quot;java.home&quot;), #value2=@System@getProperty(&quot;java.runtime.name&quot;), &#123;#value1, #value2&#125;&#x27;</span><br><span class="line">@ArrayList[</span><br><span class="line">    @String[/Library/Java/JavaVirtualMachines/jdk1.8.0_162.jdk/Contents/Home/jre],</span><br><span class="line">    @String[Java(TM) SE Runtime Environment],</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h5 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h5><p>在Arthas里<code>ognl</code>表达式是很重要的功能，在很多命令里都可以使用<code>ognl</code>表达式。</p>
<p>一些更复杂的用法，可以参考：</p>
<ul>
<li>OGNL特殊用法请参考：<a target="_blank" rel="noopener" href="https://github.com/alibaba/arthas/issues/71">https://github.com/alibaba/arthas/issues/71</a></li>
<li>OGNL表达式官方指南：<a target="_blank" rel="noopener" href="https://commons.apache.org/proper/commons-ognl/language-guide.html">https://commons.apache.org/proper/commons-ognl/language-guide.html</a></li>
</ul>
<h4 id="Exit-x2F-Stop"><a href="#Exit-x2F-Stop" class="headerlink" title="Exit&#x2F;Stop"></a>Exit&#x2F;Stop</h4><h5 id="退出Arthas"><a href="#退出Arthas" class="headerlink" title="退出Arthas"></a>退出Arthas</h5><p>用 <code>exit</code> 或者 <code>quit</code> 命令可以退出Arthas。</p>
<p>退出Arthas之后，还可以再次用 <code>java -jar arthas-boot.jar</code> 来连接。</p>
<h5 id="彻底退出Arthas"><a href="#彻底退出Arthas" class="headerlink" title="彻底退出Arthas"></a>彻底退出Arthas</h5><p><code>exit/quit</code>命令只是退出当前session，arthas server还在目标进程中运行。</p>
<p>想完全退出Arthas，可以执行 <code>stop</code> 命令。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202203172207414.png" alt="image-20220317220740046"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202203172208418.png" alt="image-20220317220826169"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202203172209619.png" alt="image-20220317220924544"></p>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>大对象直接进入老年代;经过一次minor gc年龄加1，对象年龄到了15也会进去老年代;</p>
<h3 id="判断对象死亡"><a href="#判断对象死亡" class="headerlink" title="判断对象死亡"></a>判断对象死亡</h3><p>引用计数法:实现简单效率高;但是无法解决相互循环引用问题;（Java没有这种）</p>
<p> 这三个都没人引用，但是引用计数不为0，会导致无法被回收。</p>
<p> <img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202203170942333.png" alt="image-20220317094212249"></p>
<p>可达性分析算法（Java）: 这个算法的基本思想就是通过一系列的称为 <strong>“GC Roots”</strong> 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的;可以解决循环引用问题;在多线程环境下，其他线程可能会更新已经访问过的对象中的引用，从而造成误报（将引用设置为null）或者漏报（将引用设置为未被访问过的对象）。误报并没有什么伤害，Java虚拟机至多损失了部分垃圾回收的机会。漏报则比较麻烦，因为垃圾回收器可能回收事实上仍被引用的对象内存。 一旦从原引用访问已经被回收了的对象，则很有可能会直接导致Java虚拟机崩溃。</p>
<p>即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize 方法。当对象没有覆盖 finalize 方法，或 finalize 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。</p>
<p>被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。</p>
<p>类似与有向图的遍历，没有被遍历到的就是垃圾</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202203170959134.png" alt="image-20220317095911899"></p>
<h4 id="介绍一下强引用、软引用、弱引用、虚引用的区别？"><a href="#介绍一下强引用、软引用、弱引用、虚引用的区别？" class="headerlink" title="介绍一下强引用、软引用、弱引用、虚引用的区别？"></a>介绍一下强引用、软引用、弱引用、虚引用的区别？</h4><p>强引用: 必不可少的生活用品，即使报OOM也不回收; </p>
<p>软引用: 可有可无的生活用品，内存够不回收，内存不够就回收; 适合做缓存;</p>
<p>弱引用: 可有可无的生活用品，但是只要垃圾回收器发现就会回收，不管内存够不够;  Thread LocalMap的key是弱引用;</p>
<p>虚引用: 形同虚设， 任何时候都会被回收; get()也拿不到; 管理直接内存(mmap);在回收的时候起一个通知的作用，被回收的时候放到队列里去， 然后JVM再去处理这个队列，可以通知OS去处理堆外内存;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 强引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">strongReference</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"><span class="comment">// 软引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">SoftReference&lt;String&gt; softReference = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;String&gt;(str);</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">WeakReference&lt;String&gt; weakReference = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(str);</span><br><span class="line"><span class="comment">// 弱引用转强引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">strongReference</span> <span class="operator">=</span> weakReference.get();</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"><span class="type">ReferenceQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>();</span><br><span class="line"><span class="comment">// 创建虚引用，要求必须与一个引用队列关联</span></span><br><span class="line"><span class="type">PhantomReference</span> <span class="variable">pr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PhantomReference</span>(str， queue);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903665241686029">https://juejin.cn/post/6844903665241686029</a></p>
<h3 id="判断常量是否是废弃常量"><a href="#判断常量是否是废弃常量" class="headerlink" title="判断常量是否是废弃常量"></a>判断常量是否是废弃常量</h3><p>假如在字符串常量池中存在字符串 “abc”，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 “abc” 就是废弃常量，如果这时发生内存回收的话而且有必要的话，”abc” 就会被系统清理出常量池了。</p>
<h3 id="判断一个类是无用的类"><a href="#判断一个类是无用的类" class="headerlink" title="判断一个类是无用的类"></a>判断一个类是无用的类</h3><p>满足三个条件才可以被回收; java堆不存在任何该类的实例; 该类的classloader已经被回收;该类的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法;</p>
<h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><p>标记清除算法: 标记需要不清除的对象，然后清除没有被标记的对象， 也可以标记不需要清除的对象， 然后清除未被标记的对象; 缺点:  内存碎片很多， 执行效率不稳定， 如果有大量对象需要清除， 这时就需要进行大量的标记和清除动作，导致标记和清除这两个过程的执行效率随对象数量增加而降低;</p>
<p>标记复制算法: 内存分为两块，将存活的对象复制到另一块空间，然后将原来这块空间全部清除; 缺点: 会浪费空间</p>
<p>标记整理算法: 老年代使用;将对象往一端移动，直接清理掉端边界以外的内存; 整理的过程比较耗时;</p>
<p>分代收集算法: 在新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集;</p>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p>随着内存大小的不断增长而演进</p>
<p>类似家里小孩子再玩玩具，家长一遍收拾垃圾</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202203171025063.png" alt="image-20220317102553967"></p>
<h3 id="Serial"><a href="#Serial" class="headerlink" title="Serial"></a>Serial</h3><ul>
<li><p>内存少，几兆到几十兆；</p>
</li>
<li><p>单线程，需要暂停其他工作线程，没有线程切换的开销，效率高；</p>
</li>
<li><p>新生代：标记复制，老年代：标记整理；</p>
</li>
<li><p>适用运行在 Client 模式下的虚拟机。</p>
</li>
</ul>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202203171126832.png" alt="image-20220317112610735"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202203171031583.png" alt="image-20220317103109500"></p>
<p>eden园区活着的比较少，一次minor gc 会把90%的对象清除，只有部分活着的得放到survivor 1里面去。s1和s2只有一个存了对象。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202203172231240.png" alt="image-20220317105459089"></p>
<h3 id="serial-old"><a href="#serial-old" class="headerlink" title="serial old"></a>serial old</h3><p>Serial的老年代版本;</p>
<h3 id="ParNew"><a href="#ParNew" class="headerlink" title="ParNew"></a>ParNew</h3><ul>
<li>新标记复制，老标记整理；</li>
<li>Serial的多线程版本，ParNew在单核甚至双核环境下绝对不会有比Serial收集器更好的效果，但是随着CPU数量的增加ParNew相较于Serial的优势会越来越明显，但并不是成倍增长的，因为有多线程切换的开销。</li>
<li>使用方式：-XX:+UseParNewGC，打开该开关后，使用ParNew(年轻代)+Serial Old(老年代)组合进行GC。另外，ParNew是CMS收集器的默认年轻代收集器。</li>
<li>ParNew用于垃圾回收的线程可用参数-XX:ParallelGCThreads&#x3D;n进行配置,建议n与主机逻辑cpu数一致。ParNew是许多运行在Server模式下的虚拟机中首选的新生代收集器，在JDK1.6以及之前的版本中，除了Serial收集器外，只有它能与CMS收集器配合工作。</li>
<li>除了多线程外，其余的行为、特点和Serial收集器一样；如Serial收集器可用控制参数、收集算法、Stop The World、内存分配规则、回收策略等；两个收集器共用了不少代码。</li>
<li>在Server模式下，ParNew收集器是一个非常重要的收集器，因为除了Serial收集器外，目前只有它能与CMS收集器配合工作；但在单个CPU环境中，不会比Serail收集器有更好的效果，因为存在线程交互开销。</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/2160494-d7320c067200d2b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/537/format/webp" alt="img"></p>
<h3 id="Parallel-Scavenge"><a href="#Parallel-Scavenge" class="headerlink" title="Parallel Scavenge"></a>Parallel Scavenge</h3><ul>
<li><p>内存几十兆到上百兆</p>
</li>
<li><p>关注cpu吞吐量，新标记复制，老标记整理，jdk 8默认;</p>
</li>
</ul>
<h3 id="Parallel-Old"><a href="#Parallel-Old" class="headerlink" title="Parallel Old"></a>Parallel Old</h3><ul>
<li>Parallel Scavenge的老年代版本</li>
</ul>
<h3 id="CMS-concurrent-mark-sweep"><a href="#CMS-concurrent-mark-sweep" class="headerlink" title="CMS(concurrent mark sweep)"></a>CMS(concurrent mark sweep)</h3><p>注重用户体验，为了获取最短停顿时间；是hotspot虚拟机第一款并发收集器，第一次实现让垃圾收集线程和用户线程基本上同时工作; 老标记清除，只收集老年代垃圾。 </p>
<ul>
<li>初始标记： 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；</li>
<li>并发标记： 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。（一定会出现错标）</li>
<li>重新标记： 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</li>
<li>并发清除： 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。</li>
</ul>
<p>从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：并发收集、低停顿。但是它有下面三个明显的缺点：</p>
<ul>
<li>对 CPU 资源敏感；</li>
<li>无法处理浮动垃圾；</li>
<li>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。</li>
</ul>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202203171803694.png" alt="image-20220317180322608"></p>
<h4 id="三色标记算法"><a href="#三色标记算法" class="headerlink" title="三色标记算法"></a>三色标记算法</h4><p>用在并发标记阶段，</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202203172013702.png" alt="image-20220317201338596"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202203172018985.png" alt="image-20220317201800864"></p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202203172018338.png" alt="image-20220317201847260"></p>
<h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><p>G1 (Garbage-First) 是一款面向服务器的垃圾收集器，主要针对配备多颗处理器及大容量内存的机器。以极高概率满足 GC 停顿时间要求的同时，还具备高吞吐量性能特征。能独立管理整个 GC 堆。</p>
<p>被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征。它具备以下特点：</p>
<ul>
<li>并行与并发：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。</li>
<li>分代收集：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。</li>
<li>空间整合：与 CMS 的“标记-清理”算法不同，G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。</li>
<li>可预测的停顿：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。</li>
</ul>
<p>G1 收集器的运作大致分为以下几个步骤：</p>
<ul>
<li>初始标记</li>
<li>并发标记</li>
<li>最终标记</li>
<li>筛选回收</li>
</ul>
<p>G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来) 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。</p>
<ul>
<li>G1的内存区域不是固定的E或者O</li>
</ul>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202203172027405.png" alt="image-20220317202754133"></p>
<h3 id="ZGC（zero-paused-GC）-收集器"><a href="#ZGC（zero-paused-GC）-收集器" class="headerlink" title="ZGC（zero paused GC） 收集器"></a>ZGC（zero paused GC） 收集器</h3><ul>
<li><p>支持TB级别（4T，据说已经扩展到16T）；</p>
</li>
<li><p>最大GC停顿10ms；在 ZGC 中出现 Stop The World 的情况会更少；</p>
</li>
<li><p>与 CMS 中的 ParNew 和 G1 类似，ZGC 也采用标记-复制算法，不过 ZGC 对该算法做了重大改进。</p>
</li>
<li><p>不再分代；</p>
</li>
</ul>
<h2 id="class类文件结构"><a href="#class类文件结构" class="headerlink" title="class类文件结构"></a>class类文件结构</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">    u4             magic; <span class="comment">//Class 文件的标志</span></span><br><span class="line">    u2             minor_version;<span class="comment">//Class 的小版本号</span></span><br><span class="line">    u2             major_version;<span class="comment">//Class 的大版本号</span></span><br><span class="line">    u2             constant_pool_count;<span class="comment">//常量池的数量</span></span><br><span class="line">    cp_info        constant_pool[constant_pool_count-<span class="number">1</span>];<span class="comment">//常量池</span></span><br><span class="line">    u2             access_flags;<span class="comment">//Class 的访问标记</span></span><br><span class="line">    u2             this_class;<span class="comment">//当前类</span></span><br><span class="line">    u2             super_class;<span class="comment">//父类</span></span><br><span class="line">    u2             interfaces_count;<span class="comment">//接口</span></span><br><span class="line">    u2             interfaces[interfaces_count];<span class="comment">//一个类可以实现多个接口</span></span><br><span class="line">    u2             fields_count;<span class="comment">//Class 文件的字段属性</span></span><br><span class="line">    field_info     fields[fields_count];<span class="comment">//一个类会可以有多个字段</span></span><br><span class="line">    u2             methods_count;<span class="comment">//Class 文件的方法数量</span></span><br><span class="line">    method_info    methods[methods_count];<span class="comment">//一个类可以有个多个方法</span></span><br><span class="line">    u2             attributes_count;<span class="comment">//此类的属性表中的属性数</span></span><br><span class="line">    attribute_info attributes[attributes_count];<span class="comment">//属性表集合</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><p>一个类的完整生命周期中:</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202112211848914.png" alt="img"></p>
<h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p> 通过全类名获取定义此类的二进制字节流; 将字节流转换为方法区的运行时数据结构; 在内存中生成一个代表该类的Class对象，作为方法区这些数据的访问入口;</p>
<p>一个非数组类的加载阶段（加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，这一步我们可以去完成还可以自定义类加载器去控制字节流的获取方式（重写一个类加载器的 loadClass() 方法）。数组类型不通过类加载器创建，它由 Java 虚拟机直接创建。</p>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>验证文件是否符合JVM规范</p>
<p> 文件格式验证(类名，主次版本号); 元数据验证(对字节码描述信息进行语义分析，final); 字节码验证(最复杂的阶段，确定程序语义是合法的、符合逻辑的); 符号引用验证(确保解析动作能正确执行)</p>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>静态变量赋初始值</p>
<p>给static赋默认值，如果加了final关键字就是赋指定的值;</p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>将类、属性、方法等符号引用解析为直接饮用，常量池中的各种符号引用解析为指针、偏移量等内存地址的直接引用</p>
<p>讲常量池内的符号引用替换为直接引用的过程; 解析动作主要针对类或接口、字段、类方法、接口方法、方类型、方法句柄和调用限定符7类符号引用进行; </p>
<p>符号引用就是一组符号来描述目标，可以是任何字面量。<strong>直接引用</strong>就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。在程序实际运行时，只有符号引用是不够的，举个例子：在程序执行方法时，系统需要明确知道这个方法所在的位置。Java 虚拟机为每个类都准备了一张方法表来存放类中所有的方法。当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就可以直接调用该方法了。通过解析操作符号引用就可以直接转变为目标方法在类中方法表的位置，从而使得方法可以被调用。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202203170815442.png" alt="image-20220317081538320"></p>
<p>结果为2，换个位置，结果就是3</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>执行初始化方法<clinit>()方法的过程; 这个方法是带锁线程安全的，在多线程的环境下可能会引发死锁，这种死锁是很难发现的; </p>
<p>虚拟机严格规范了下面几种情况下必须对类进行初始化</p>
<p>1.当遇到new、getstatic、putstatic、invokestatic这4条字节码指令时</p>
<p>2.使用反射时</p>
<p>3.初始化一个类，如果其父类还没有初始化，则先出发该父类的初始化</p>
<p>4.当虚拟机启动时，用户需要定义一个执行的主类，虚拟机乎先初始化这个类</p>
<p>5.MethodHandle和VarHandle可以看作是轻量级的反射调用机制，要想使用这两个调用，就必须先使用findstaticVarHandle来初始化要调用的类</p>
<p>6.当一个接口中定义了JDK8新加入的默认方法(被default关键字修饰的接口方法)时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化</p>
<h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><p>卸载类即该类的Class对象被GC</p>
<p>卸载类需要满足3个条件</p>
<p>1.该类的所有实例对象都已被GC，也就是说堆不存在该类的实例对象</p>
<p>2.该类没有在其他地方别引用</p>
<p>3.该类的类加载器的实例已被GC</p>
<p>所以，在JVM生命周期类，由jvm自带的类加载器加载的类是不会被卸载的。但是由我们自定义的类加载器加载的类是可能被卸载的。</p>
<p>只要想通一点就好了，jdk自带的BootstrapClassLoader， ExtClassLoader， AppClassLoader负责加载jdk提供的类，所以它们(类加载器的实例)肯定不会被回收。而我们自定义的类加载器的实例是可以被回收的，所以使用我们自定义加载器加载的类是可以被卸载掉的。</p>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>java.lang.ClassLoader内置了三个ClassLoader</p>
<p>BootstrapClassLoader(启动类加载器): 最顶层的加载类，由C++实现，负责加载%JAVA_HOME%&#x2F;lib目录下的jar包和类或者被-Xbootclasspath参数指定路径中的所有类;</p>
<p>ExtensionClassLoader(扩展类加载器): 主要负责加载目录%JRE_HOME%&#x2F;lib&#x2F;ext目录下的jar包和类，或被java.ext.dirs系统变量所指定的路径下的jar包</p>
<p>AppClassLoader(应用程序类加载器): 面向我们用户的加载器，负责加载当前应用classpath下的所有jar包和类</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202203162135643.png" alt="image-20220316213519574">  </p>
<h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><ul>
<li>每个类都有一个对应它的类加载器；</li>
<li>系统中的ClassLoader在协同工作的时候会默认使用双亲委派模型。即在类加载的时候，系统会首先判断当前类是否被加载过。 已经被加载的类会直接返回，否则才会尝试加载。 加载的时候，会把请求委派给父类加载器的loadClass() 处理， 因此所有请求最终都应该传送到顶层的启动类加载器。当父类加载器无法处理时，才由自己来处理。当父类加载器为null时，会使用启动类加载器bootstrapClassLoader作为父类加载器。</li>
</ul>
<h3 id="双亲委派模型的好处"><a href="#双亲委派模型的好处" class="headerlink" title="双亲委派模型的好处"></a>双亲委派模型的好处</h3><ul>
<li>可以保证java程序的稳定运行，可以避免类的重复加载（JVM区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类）；</li>
<li>保证了Java核心API不被篡改；如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个java.lang.Object类的话，那么程序运行的时候，系统就会出现多个不同的Object类。</li>
</ul>
<h3 id="如果不想用双亲委派模型怎么办"><a href="#如果不想用双亲委派模型怎么办" class="headerlink" title="如果不想用双亲委派模型怎么办?"></a>如果不想用双亲委派模型怎么办?</h3><p>自定义类加载器的话，需要继承ClassLoader。如果我们不想打破双亲委派模型，就重写ClassLoader类中的findClass()方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。但是，如果要打破双亲委派机制模型则需要重写loadClass()方法。</p>
<p>破坏性双亲委派模型的经典案例（JDBC）<br>原生的JDBC中Driver驱动本身只是一个接口，并没有具体的实现，具体的实现是由不同数据库类型去实现的。例如，MySQL的mysql-connector-.jar中的Driver类具体实现的。 原生的JDBC中的类是放在rt.jar包的，是由启动类加载器进行类加载的，在JDBC中的Driver类中需要动态去加载不同数据库类型的Driver类，而mysql-connector-.jar中的Driver类是用户自己写的代码，那启动类加载器肯定是不能进行加载的，既然是自己编写的代码，那就需要由应用程序启动类去进行类加载。于是乎，这个时候就引入线程上下文件类加载器(Thread Context ClassLoader)。有了这个东西之后，程序就可以把原本需要由启动类加载器进行加载的类，由应用程序类加载器去进行加载了。</p>
<h3 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h3><p>除了BootstrapClassLoader其他类加载器均由java实现，且全部继承自java.lang.ClassLoader. 如果要定义自己的类加载器，就需要继承ClassLoader.</p>
<h2 id="混合模式"><a href="#混合模式" class="headerlink" title="混合模式"></a>混合模式</h2><p>热点代码检测：</p>
<ul>
<li>方法计数器：监测方法执行频率</li>
<li>循环计数器：检测循环执行频率</li>
</ul>
<h2 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h2><p>JVM规范并没有规定何时加载。</p>
<p>一般的jvm实现都是懒加载。</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202203170918315.png" alt="image-20220317091811225"></p>
<p>栈空间自动释放</p>
<p> 野指针，指向了不该指向的空间</p>
<p><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202203170928400.png" alt="image-20220317092819316"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">MingwHuang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://mingwzi.cn/2022/03/17/base/JVM/">http://mingwzi.cn/2022/03/17/base/JVM/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://mingwzi.cn" target="_blank">MingwHuang's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JVM/">JVM</a></div><div class="post_share"><div class="social-share" data-image="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272046990.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202172251674.png" target="_blank"><img class="post-qr-code-img" src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202172251674.png" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202172251973.png" target="_blank"><img class="post-qr-code-img" src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202172251973.png" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/03/17/base/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><img class="prev-cover" src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272047554.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">计算机网络</div></div></a></div><div class="next-post pull-right"><a href="/2022/03/12/%E6%9C%AA%E5%91%BD%E5%90%8D/"><img class="next-cover" src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272047554.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info"></div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272113875.JPG" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">MingwHuang</div><div class="author-info__description">朝花夕拾 聊以记之</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">45</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">42</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/HuangMingwang" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:1125385880@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站域名：http://mingwzi.cn</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#JVM"><span class="toc-number">1.</span> <span class="toc-text">JVM</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F"><span class="toc-number">1.1.</span> <span class="toc-text">运行时数据区域</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86"><span class="toc-number">1.1.1.</span> <span class="toc-text">堆</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="toc-number">1.1.2.</span> <span class="toc-text">方法区</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%B0%86%E6%B0%B8%E4%B9%85%E4%BB%A3-PermGen-%E6%9B%BF%E6%8D%A2%E4%B8%BA%E5%85%83%E7%A9%BA%E9%97%B4-MetaSpace"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">为什么要将永久代(PermGen)替换为元空间(MetaSpace)?</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-number">1.1.3.</span> <span class="toc-text">运行时常量池</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JVM-%E5%B8%B8%E9%87%8F%E6%B1%A0%E4%B8%AD%E5%AD%98%E5%82%A8%E7%9A%84%E6%98%AF%E5%AF%B9%E8%B1%A1%E8%BF%98%E6%98%AF%E5%BC%95%E7%94%A8%E5%91%A2%EF%BC%9F"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">JVM 常量池中存储的是对象还是引用呢？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">1.2.</span> <span class="toc-text">对象的创建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D"><span class="toc-number">1.3.</span> <span class="toc-text">对象的访问定位</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM%E5%B8%B8%E7%94%A8%E8%B0%83%E4%BC%98%E6%8C%87%E4%BB%A4%E5%92%8C%E5%8F%82%E6%95%B0"><span class="toc-number">1.4.</span> <span class="toc-text">JVM常用调优指令和参数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#jps"><span class="toc-number">1.4.1.</span> <span class="toc-text">jps</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jstat"><span class="toc-number">1.4.2.</span> <span class="toc-text">jstat</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jinfo"><span class="toc-number">1.4.3.</span> <span class="toc-text">jinfo</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jmap"><span class="toc-number">1.4.4.</span> <span class="toc-text">jmap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jstack"><span class="toc-number">1.4.5.</span> <span class="toc-text">jstack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#top"><span class="toc-number">1.4.6.</span> <span class="toc-text">top</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pidstat"><span class="toc-number">1.4.7.</span> <span class="toc-text">pidstat</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vmstat"><span class="toc-number">1.4.8.</span> <span class="toc-text">vmstat</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM%E5%B8%B8%E8%A7%81%E7%9A%84%E8%B0%83%E4%BC%98%E5%8F%82%E6%95%B0"><span class="toc-number">1.4.9.</span> <span class="toc-text">JVM常见的调优参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#arthas"><span class="toc-number">1.4.10.</span> <span class="toc-text">arthas</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#help"><span class="toc-number">1.4.10.1.</span> <span class="toc-text">help</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dashboard"><span class="toc-number">1.4.10.2.</span> <span class="toc-text">dashboard</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#thread"><span class="toc-number">1.4.10.3.</span> <span class="toc-text">thread</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sc"><span class="toc-number">1.4.10.4.</span> <span class="toc-text">sc</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#jad"><span class="toc-number">1.4.10.5.</span> <span class="toc-text">jad</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#watch"><span class="toc-number">1.4.10.6.</span> <span class="toc-text">watch</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vmtool"><span class="toc-number">1.4.10.7.</span> <span class="toc-text">vmtool</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8BJVM%E4%BF%A1%E6%81%AF"><span class="toc-number">1.4.10.8.</span> <span class="toc-text">查看JVM信息</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#sysprop"><span class="toc-number">1.4.10.8.1.</span> <span class="toc-text">sysprop</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#sysenv"><span class="toc-number">1.4.10.8.2.</span> <span class="toc-text">sysenv</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#jvm"><span class="toc-number">1.4.10.8.3.</span> <span class="toc-text">jvm</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Tips"><span class="toc-number">1.4.10.9.</span> <span class="toc-text">Tips</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#help-1"><span class="toc-number">1.4.10.10.</span> <span class="toc-text">help</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8"><span class="toc-number">1.4.10.10.1.</span> <span class="toc-text">自动补全</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#readline%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%94%AE%E6%94%AF%E6%8C%81"><span class="toc-number">1.4.10.10.2.</span> <span class="toc-text">readline的快捷键支持</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%86%E5%8F%B2%E5%91%BD%E4%BB%A4%E7%9A%84%E8%A1%A5%E5%85%A8"><span class="toc-number">1.4.10.10.3.</span> <span class="toc-text">历史命令的补全</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#pipeline"><span class="toc-number">1.4.10.10.4.</span> <span class="toc-text">pipeline</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sc-x2F-sm-%E6%9F%A5%E7%9C%8B%E5%B7%B2%E5%8A%A0%E8%BD%BD%E7%9A%84%E7%B1%BB"><span class="toc-number">1.4.10.11.</span> <span class="toc-text">sc&#x2F;sm 查看已加载的类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#sc-1"><span class="toc-number">1.4.10.11.1.</span> <span class="toc-text">sc</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#sm"><span class="toc-number">1.4.10.11.2.</span> <span class="toc-text">sm</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Jad"><span class="toc-number">1.4.10.12.</span> <span class="toc-text">Jad</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Ognl"><span class="toc-number">1.4.10.13.</span> <span class="toc-text">Ognl</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B0%83%E7%94%A8static%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.10.13.1.</span> <span class="toc-text">调用static函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E6%89%BEUserController%E7%9A%84ClassLoader"><span class="toc-number">1.4.10.13.2.</span> <span class="toc-text">查找UserController的ClassLoader</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E9%9D%99%E6%80%81%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E5%AD%97%E6%AE%B5"><span class="toc-number">1.4.10.13.3.</span> <span class="toc-text">获取静态类的静态字段</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E5%A4%9A%E8%A1%8C%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%8C%E8%B5%8B%E5%80%BC%E7%BB%99%E4%B8%B4%E6%97%B6%E5%8F%98%E9%87%8F%EF%BC%8C%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AAList"><span class="toc-number">1.4.10.13.4.</span> <span class="toc-text">执行多行表达式，赋值给临时变量，返回一个List</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9B%B4%E5%A4%9A"><span class="toc-number">1.4.10.13.5.</span> <span class="toc-text">更多</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Exit-x2F-Stop"><span class="toc-number">1.4.10.14.</span> <span class="toc-text">Exit&#x2F;Stop</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%80%E5%87%BAArthas"><span class="toc-number">1.4.10.14.1.</span> <span class="toc-text">退出Arthas</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BD%BB%E5%BA%95%E9%80%80%E5%87%BAArthas"><span class="toc-number">1.4.10.14.2.</span> <span class="toc-text">彻底退出Arthas</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">1.5.</span> <span class="toc-text">垃圾回收</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%AD%BB%E4%BA%A1"><span class="toc-number">1.5.1.</span> <span class="toc-text">判断对象死亡</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E5%BC%BA%E5%BC%95%E7%94%A8%E3%80%81%E8%BD%AF%E5%BC%95%E7%94%A8%E3%80%81%E5%BC%B1%E5%BC%95%E7%94%A8%E3%80%81%E8%99%9A%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">介绍一下强引用、软引用、弱引用、虚引用的区别？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E5%B8%B8%E9%87%8F%E6%98%AF%E5%90%A6%E6%98%AF%E5%BA%9F%E5%BC%83%E5%B8%B8%E9%87%8F"><span class="toc-number">1.5.2.</span> <span class="toc-text">判断常量是否是废弃常量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E7%B1%BB%E6%98%AF%E6%97%A0%E7%94%A8%E7%9A%84%E7%B1%BB"><span class="toc-number">1.5.3.</span> <span class="toc-text">判断一个类是无用的类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="toc-number">1.6.</span> <span class="toc-text">垃圾回收算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">1.7.</span> <span class="toc-text">垃圾收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Serial"><span class="toc-number">1.7.1.</span> <span class="toc-text">Serial</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#serial-old"><span class="toc-number">1.7.2.</span> <span class="toc-text">serial old</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ParNew"><span class="toc-number">1.7.3.</span> <span class="toc-text">ParNew</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Parallel-Scavenge"><span class="toc-number">1.7.4.</span> <span class="toc-text">Parallel Scavenge</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Parallel-Old"><span class="toc-number">1.7.5.</span> <span class="toc-text">Parallel Old</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CMS-concurrent-mark-sweep"><span class="toc-number">1.7.6.</span> <span class="toc-text">CMS(concurrent mark sweep)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E7%AE%97%E6%B3%95"><span class="toc-number">1.7.6.1.</span> <span class="toc-text">三色标记算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#G1%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">1.7.7.</span> <span class="toc-text">G1收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ZGC%EF%BC%88zero-paused-GC%EF%BC%89-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">1.7.8.</span> <span class="toc-text">ZGC（zero paused GC） 收集器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#class%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-number">1.8.</span> <span class="toc-text">class类文件结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="toc-number">1.9.</span> <span class="toc-text">类加载过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD"><span class="toc-number">1.9.1.</span> <span class="toc-text">加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81"><span class="toc-number">1.9.2.</span> <span class="toc-text">验证</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%86%E5%A4%87"><span class="toc-number">1.9.3.</span> <span class="toc-text">准备</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90"><span class="toc-number">1.9.4.</span> <span class="toc-text">解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.9.5.</span> <span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%B8%E8%BD%BD"><span class="toc-number">1.9.6.</span> <span class="toc-text">卸载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">1.10.</span> <span class="toc-text">类加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.10.1.</span> <span class="toc-text">双亲委派模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">1.10.2.</span> <span class="toc-text">双亲委派模型的好处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E4%B8%8D%E6%83%B3%E7%94%A8%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%E6%80%8E%E4%B9%88%E5%8A%9E"><span class="toc-number">1.10.3.</span> <span class="toc-text">如果不想用双亲委派模型怎么办?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">1.10.4.</span> <span class="toc-text">自定义类加载器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.11.</span> <span class="toc-text">混合模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%87%92%E5%8A%A0%E8%BD%BD"><span class="toc-number">1.12.</span> <span class="toc-text">懒加载</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/03/17/base/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="计算机网络"><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272047554.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机网络"/></a><div class="content"><a class="title" href="/2022/03/17/base/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="计算机网络">计算机网络</a><time datetime="2022-03-17T12:46:58.000Z" title="发表于 2022-03-17 20:46:58">2022-03-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/17/base/JVM/" title="JVM"><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272046990.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JVM"/></a><div class="content"><a class="title" href="/2022/03/17/base/JVM/" title="JVM">JVM</a><time datetime="2022-03-17T10:46:58.000Z" title="发表于 2022-03-17 18:46:58">2022-03-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/12/%E6%9C%AA%E5%91%BD%E5%90%8D/" title="无题"><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272047554.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2022/03/12/%E6%9C%AA%E5%91%BD%E5%90%8D/" title="无题">无题</a><time datetime="2022-03-12T08:47:16.570Z" title="发表于 2022-03-12 16:47:16">2022-03-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/02/base/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" title="操作系统"><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272046348.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="操作系统"/></a><div class="content"><a class="title" href="/2022/03/02/base/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" title="操作系统">操作系统</a><time datetime="2022-03-02T02:54:05.000Z" title="发表于 2022-03-02 10:54:05">2022-03-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/01/base/Linux/" title="Linux"><img src="https://typora-mingwhuang.oss-cn-shenzhen.aliyuncs.com/typora/202202272046348.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux"/></a><div class="content"><a class="title" href="/2022/03/01/base/Linux/" title="Linux">Linux</a><time datetime="2022-03-01T15:08:28.000Z" title="发表于 2022-03-01 23:08:28">2022-03-01</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By MingwHuang</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a><span class="footer-separator">|</span><a href="https://beian.miit.gov.cn/" target="_blank">赣ICP备2022001353号-1</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>